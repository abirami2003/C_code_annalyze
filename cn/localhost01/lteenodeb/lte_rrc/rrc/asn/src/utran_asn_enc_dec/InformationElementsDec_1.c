/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.5, Date: 06-May-2016.
 */
#include "InformationElements.h"
#include "Constant-definitions.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PD_utran_UL_CommonTransChInfo_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_UL_CommonTransChInfo_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ul_TFCS */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TFCS");

   stat = asn1PD_utran_TFCS (pctxt, &pvalue->ul_TFCS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_IndividualUL_CCTrCH_Info (OSCTXT* pctxt, utran_IndividualUL_CCTrCH_Info* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IndividualUL-CCTrCH-Info");

   /* decode root elements */
   /* decode ul_TFCS_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TFCS-Identity");

   stat = asn1PD_utran_TFCS_Identity (pctxt, &pvalue->ul_TFCS_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TFCS */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TFCS");

   stat = asn1PD_utran_TFCS (pctxt, &pvalue->ul_TFCS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfc_Subset */
   RTXCTXTPUSHELEMNAME (pctxt, "tfc-Subset");

   stat = asn1PD_utran_TFC_Subset (pctxt, &pvalue->tfc_Subset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_IndividualUL_CCTrCH_InfoList (OSCTXT* pctxt, utran_IndividualUL_CCTrCH_InfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IndividualUL-CCTrCH-InfoList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_IndividualUL_CCTrCH_Info* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "IndividualUL-CCTrCH-Info", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_IndividualUL_CCTrCH_Info, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_IndividualUL_CCTrCH_Info (pdata);

      stat = asn1PD_utran_IndividualUL_CCTrCH_Info (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CommonTransChInfo_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_UL_CommonTransChInfo_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode individualUL_CCTrCH_InfoList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "individualUL-CCTrCH-InfoList");

      pvalue->m.individualUL_CCTrCH_InfoListPresent = 1;

      stat = asn1PD_utran_IndividualUL_CCTrCH_InfoList (pctxt, &pvalue->individualUL_CCTrCH_InfoList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_CommonTransChInfo_modeSpecificInfo (OSCTXT* pctxt, utran_UL_CommonTransChInfo_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_CommonTransChInfo_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_CommonTransChInfo_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_CommonTransChInfo_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_CommonTransChInfo_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_CommonTransChInfo_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_CommonTransChInfo_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_CommonTransChInfo (OSCTXT* pctxt, utran_UL_CommonTransChInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CommonTransChInfo");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tfc_Subset */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tfc-Subset");

      pvalue->m.tfc_SubsetPresent = 1;

      stat = asn1PD_utran_TFC_Subset (pctxt, &pvalue->tfc_Subset);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode prach_TFCS */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "prach-TFCS");

      pvalue->m.prach_TFCSPresent = 1;

      stat = asn1PD_utran_TFCS (pctxt, &pvalue->prach_TFCS);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

      pvalue->m.modeSpecificInfoPresent = 1;

      stat = asn1PD_utran_UL_CommonTransChInfo_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TransportChannelIdentity (OSCTXT* pctxt, utran_UL_TransportChannelIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-TransportChannelIdentity");

   /* decode root elements */
   /* decode ul_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TransportChannelType");

   stat = asn1PD_utran_UL_TrCH_Type (pctxt, &pvalue->ul_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TransportChannelIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TransportChannelIdentity");

   stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->ul_TransportChannelIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DeletedTransChInfoList (OSCTXT* pctxt, utran_UL_DeletedTransChInfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DeletedTransChInfoList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UL_TransportChannelIdentity* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-TransportChannelIdentity", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UL_TransportChannelIdentity, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_UL_TransportChannelIdentity (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-AddReconfTransChInformation");

   /* decode root elements */
   /* decode ul_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TransportChannelType");

   stat = asn1PD_utran_UL_TrCH_Type (pctxt, &pvalue->ul_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportChannelIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "transportChannelIdentity");

   stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->transportChannelIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportFormatSet */
   RTXCTXTPUSHELEMNAME (pctxt, "transportFormatSet");

   stat = asn1PD_utran_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInfoList (OSCTXT* pctxt, utran_UL_AddReconfTransChInfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-AddReconfTransChInfoList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UL_AddReconfTransChInformation* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-AddReconfTransChInformation", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UL_AddReconfTransChInformation, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UL_AddReconfTransChInformation (pdata);

      stat = asn1PD_utran_UL_AddReconfTransChInformation (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CPCH_SetID (OSCTXT* pctxt, utran_CPCH_SetID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CPCH-SetID");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TransmissionTimeValidity (OSCTXT* pctxt, utran_TransmissionTimeValidity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TransmissionTimeValidity");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(256));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TimeDurationBeforeRetry (OSCTXT* pctxt, utran_TimeDurationBeforeRetry* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeDurationBeforeRetry");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(256));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DRAC_ClassIdentity (OSCTXT* pctxt, utran_DRAC_ClassIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRAC-ClassIdentity");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DRAC_StaticInformation (OSCTXT* pctxt, utran_DRAC_StaticInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRAC-StaticInformation");

   /* decode root elements */
   /* decode transmissionTimeValidity */
   RTXCTXTPUSHELEMNAME (pctxt, "transmissionTimeValidity");

   stat = asn1PD_utran_TransmissionTimeValidity (pctxt, &pvalue->transmissionTimeValidity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeDurationBeforeRetry */
   RTXCTXTPUSHELEMNAME (pctxt, "timeDurationBeforeRetry");

   stat = asn1PD_utran_TimeDurationBeforeRetry (pctxt, &pvalue->timeDurationBeforeRetry);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode drac_ClassIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "drac-ClassIdentity");

   stat = asn1PD_utran_DRAC_ClassIdentity (pctxt, &pvalue->drac_ClassIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DRAC_StaticInformationList (OSCTXT* pctxt, utran_DRAC_StaticInformationList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRAC-StaticInformationList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DRAC_StaticInformation* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DRAC-StaticInformation", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DRAC_StaticInformation, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_DRAC_StaticInformation (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonTransChInfo_modeSpecificInfo_fdd_dl_Parameters (OSCTXT* pctxt, utran_DL_CommonTransChInfo_modeSpecificInfo_fdd_dl_Parameters* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_DCH_TFCS */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-DCH-TFCS");

         pvalue->u.dl_DCH_TFCS = rtxMemAllocType (pctxt, utran_TFCS);

         if (pvalue->u.dl_DCH_TFCS == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TFCS (pvalue->u.dl_DCH_TFCS);

         stat = asn1PD_utran_TFCS (pctxt, pvalue->u.dl_DCH_TFCS);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sameAsUL */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsUL");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonTransChInfo_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_CommonTransChInfo_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_Parameters */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-Parameters");

      pvalue->m.dl_ParametersPresent = 1;

      stat = asn1PD_utran_DL_CommonTransChInfo_modeSpecificInfo_fdd_dl_Parameters (pctxt, &pvalue->dl_Parameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_IndividualDL_CCTrCH_Info_tfcs_SignallingMode (OSCTXT* pctxt, utran_IndividualDL_CCTrCH_Info_tfcs_SignallingMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* explicit_config */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "explicit-config");

         pvalue->u.explicit_config = rtxMemAllocType (pctxt, utran_TFCS);

         if (pvalue->u.explicit_config == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TFCS (pvalue->u.explicit_config);

         stat = asn1PD_utran_TFCS (pctxt, pvalue->u.explicit_config);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sameAsUL */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsUL");

         pvalue->u.sameAsUL = rtxMemAllocType (pctxt, utran_TFCS_Identity);

         if (pvalue->u.sameAsUL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TFCS_Identity (pvalue->u.sameAsUL);

         stat = asn1PD_utran_TFCS_Identity (pctxt, pvalue->u.sameAsUL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_IndividualDL_CCTrCH_Info (OSCTXT* pctxt, utran_IndividualDL_CCTrCH_Info* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IndividualDL-CCTrCH-Info");

   /* decode root elements */
   /* decode dl_TFCS_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TFCS-Identity");

   stat = asn1PD_utran_TFCS_Identity (pctxt, &pvalue->dl_TFCS_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfcs_SignallingMode */
   RTXCTXTPUSHELEMNAME (pctxt, "tfcs-SignallingMode");

   stat = asn1PD_utran_IndividualDL_CCTrCH_Info_tfcs_SignallingMode (pctxt, &pvalue->tfcs_SignallingMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_IndividualDL_CCTrCH_InfoList (OSCTXT* pctxt, utran_IndividualDL_CCTrCH_InfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IndividualDL-CCTrCH-InfoList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_IndividualDL_CCTrCH_Info* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "IndividualDL-CCTrCH-Info", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_IndividualDL_CCTrCH_Info, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_IndividualDL_CCTrCH_Info (pdata);

      stat = asn1PD_utran_IndividualDL_CCTrCH_Info (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonTransChInfo_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_CommonTransChInfo_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode individualDL_CCTrCH_InfoList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "individualDL-CCTrCH-InfoList");

      pvalue->m.individualDL_CCTrCH_InfoListPresent = 1;

      stat = asn1PD_utran_IndividualDL_CCTrCH_InfoList (pctxt, &pvalue->individualDL_CCTrCH_InfoList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonTransChInfo_modeSpecificInfo (OSCTXT* pctxt, utran_DL_CommonTransChInfo_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonTransChInfo_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonTransChInfo_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_CommonTransChInfo_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonTransChInfo_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonTransChInfo_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_CommonTransChInfo_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonTransChInfo (OSCTXT* pctxt, utran_DL_CommonTransChInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CommonTransChInfo");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode sccpch_TFCS */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sccpch-TFCS");

      pvalue->m.sccpch_TFCSPresent = 1;

      stat = asn1PD_utran_TFCS (pctxt, &pvalue->sccpch_TFCS);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_CommonTransChInfo_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_TrCH_Type (OSCTXT* pctxt, utran_DL_TrCH_Type* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-TrCH-Type");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_TransportChannelIdentity (OSCTXT* pctxt, utran_DL_TransportChannelIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-TransportChannelIdentity");

   /* decode root elements */
   /* decode dl_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TransportChannelType");

   stat = asn1PD_utran_DL_TrCH_Type (pctxt, &pvalue->dl_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_TransportChannelIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TransportChannelIdentity");

   stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->dl_TransportChannelIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DeletedTransChInfoList (OSCTXT* pctxt, utran_DL_DeletedTransChInfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DeletedTransChInfoList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_TransportChannelIdentity* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-TransportChannelIdentity", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_TransportChannelIdentity, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_DL_TransportChannelIdentity (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation_tfs_SignallingMode (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation_tfs_SignallingMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* explicit_config */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "explicit-config");

         pvalue->u.explicit_config = rtxMemAllocType (pctxt, 
            utran_TransportFormatSet);

         if (pvalue->u.explicit_config == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TransportFormatSet (pvalue->u.explicit_config);

         stat = asn1PD_utran_TransportFormatSet (pctxt, pvalue->u.explicit_config);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sameAsULTrCH */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsULTrCH");

         pvalue->u.sameAsULTrCH = rtxMemAllocTypeZ (pctxt, 
            utran_UL_TransportChannelIdentity);

         if (pvalue->u.sameAsULTrCH == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UL_TransportChannelIdentity (pctxt, pvalue->u.sameAsULTrCH);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MessType (OSCTXT* pctxt, utran_MessType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "MessType");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_transportFormatCombinationControl; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_ControlledTrChList (OSCTXT* pctxt, utran_UL_ControlledTrChList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-ControlledTrChList");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 5);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 32) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TransportChannelIdentity", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_TransportChannelIdentity));
      stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TM_SignallingInfo_tm_SignallingMode_mode2 (OSCTXT* pctxt, utran_TM_SignallingInfo_tm_SignallingMode_mode2* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ul_controlledTrChList */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-controlledTrChList");

   stat = asn1PD_utran_UL_ControlledTrChList (pctxt, &pvalue->ul_controlledTrChList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TM_SignallingInfo_tm_SignallingMode (OSCTXT* pctxt, utran_TM_SignallingInfo_tm_SignallingMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* mode1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "mode1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* mode2 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "mode2");

         pvalue->u.mode2 = rtxMemAllocType (pctxt, 
            utran_TM_SignallingInfo_tm_SignallingMode_mode2);

         if (pvalue->u.mode2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TM_SignallingInfo_tm_SignallingMode_mode2 (pvalue->u.mode2);

         stat = asn1PD_utran_TM_SignallingInfo_tm_SignallingMode_mode2 (pctxt, pvalue->u.mode2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TM_SignallingInfo (OSCTXT* pctxt, utran_TM_SignallingInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TM-SignallingInfo");

   /* decode root elements */
   /* decode messType */
   RTXCTXTPUSHELEMNAME (pctxt, "messType");

   stat = asn1PD_utran_MessType (pctxt, &pvalue->messType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tm_SignallingMode */
   RTXCTXTPUSHELEMNAME (pctxt, "tm-SignallingMode");

   stat = asn1PD_utran_TM_SignallingInfo_tm_SignallingMode (pctxt, &pvalue->tm_SignallingMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInformation");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TransportChannelType");

   stat = asn1PD_utran_DL_TrCH_Type (pctxt, &pvalue->dl_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_transportChannelIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-transportChannelIdentity");

   stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->dl_transportChannelIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfs_SignallingMode */
   RTXCTXTPUSHELEMNAME (pctxt, "tfs-SignallingMode");

   stat = asn1PD_utran_DL_AddReconfTransChInformation_tfs_SignallingMode (pctxt, &pvalue->tfs_SignallingMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dch_QualityTarget */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dch-QualityTarget");

      pvalue->m.dch_QualityTargetPresent = 1;

      stat = asn1PD_utran_QualityTarget (pctxt, &pvalue->dch_QualityTarget);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dummy */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy");

      pvalue->m.dummyPresent = 1;

      stat = asn1PD_utran_TM_SignallingInfo (pctxt, &pvalue->dummy);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInfoList (OSCTXT* pctxt, utran_DL_AddReconfTransChInfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInfoList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_AddReconfTransChInformation* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-AddReconfTransChInformation", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_AddReconfTransChInformation, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_AddReconfTransChInformation (pdata);

      stat = asn1PD_utran_DL_AddReconfTransChInformation (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DPCCH_PowerOffset (OSCTXT* pctxt, utran_DPCCH_PowerOffset* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DPCCH-PowerOffset");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-82), OSINTCONST(-3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SRB_delay (OSCTXT* pctxt, utran_SRB_delay* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-delay");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PowerControlAlgorithm (OSCTXT* pctxt, utran_PowerControlAlgorithm* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "PowerControlAlgorithm");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* algorithm1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "algorithm1");

         stat = asn1PD_utran_TPC_StepSizeFDD (pctxt, &pvalue->u.algorithm1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* algorithm2 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "algorithm2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_fdd (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode dpcch_PowerOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "dpcch-PowerOffset");

   stat = asn1PD_utran_DPCCH_PowerOffset (pctxt, &pvalue->dpcch_PowerOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pc_Preamble */
   RTXCTXTPUSHELEMNAME (pctxt, "pc-Preamble");

   stat = asn1PD_utran_PC_Preamble (pctxt, &pvalue->pc_Preamble);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sRB_delay */
   RTXCTXTPUSHELEMNAME (pctxt, "sRB-delay");

   stat = asn1PD_utran_SRB_delay (pctxt, &pvalue->sRB_delay);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerControlAlgorithm */
   RTXCTXTPUSHELEMNAME (pctxt, "powerControlAlgorithm");

   stat = asn1PD_utran_PowerControlAlgorithm (pctxt, &pvalue->powerControlAlgorithm);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TargetSIR (OSCTXT* pctxt, utran_UL_TargetSIR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-TargetSIR");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(62));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TDD_UL_Interference (OSCTXT* pctxt, utran_TDD_UL_Interference* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TDD-UL-Interference");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-110), OSINTCONST(-52));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_IndividualTS_Interference (OSCTXT* pctxt, utran_IndividualTS_Interference* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IndividualTS-Interference");

   /* decode root elements */
   /* decode timeslot */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslot");

   stat = asn1PD_utran_TimeslotNumber (pctxt, &pvalue->timeslot);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TimeslotInterference */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TimeslotInterference");

   stat = asn1PD_utran_TDD_UL_Interference (pctxt, &pvalue->ul_TimeslotInterference);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_IndividualTS_InterferenceList (OSCTXT* pctxt, utran_IndividualTS_InterferenceList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IndividualTS-InterferenceList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(14), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_IndividualTS_Interference* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "IndividualTS-Interference", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_IndividualTS_Interference, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_IndividualTS_Interference (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ConstantValueTdd (OSCTXT* pctxt, utran_ConstantValueTdd* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ConstantValueTdd");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-35), OSINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_TX_Power (OSCTXT* pctxt, utran_PrimaryCCPCH_TX_Power* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PrimaryCCPCH-TX-Power");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(6), OSUINTCONST(43));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling_individuallySignalled (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTS_InterferenceList */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTS-InterferenceList");

   stat = asn1PD_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpch_ConstantValue */
   RTXCTXTPUSHELEMNAME (pctxt, "dpch-ConstantValue");

   stat = asn1PD_utran_ConstantValueTdd (pctxt, &pvalue->dpch_ConstantValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode primaryCCPCH_TX_Power */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCCPCH-TX-Power");

   stat = asn1PD_utran_PrimaryCCPCH_TX_Power (pctxt, &pvalue->primaryCCPCH_TX_Power);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* broadcast_UL_OL_PC_info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "broadcast-UL-OL-PC-info");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* individuallySignalled */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "individuallySignalled");

         pvalue->u.individuallySignalled = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling_individuallySignalled);

         if (pvalue->u.individuallySignalled == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling_individuallySignalled (pvalue->u.individuallySignalled);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling_individuallySignalled (pctxt, pvalue->u.individuallySignalled);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_tdd (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TargetSIR */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TargetSIR");

      pvalue->m.ul_TargetSIRPresent = 1;

      stat = asn1PD_utran_UL_TargetSIR (pctxt, &pvalue->ul_TargetSIR);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_OL_PC_Signalling */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-OL-PC-Signalling");

      pvalue->m.ul_OL_PC_SignallingPresent = 1;

      stat = asn1PD_utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling (pctxt, &pvalue->ul_OL_PC_Signalling);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-PowerControlInfo");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_NumberOfDPDCH (OSCTXT* pctxt, utran_NumberOfDPDCH* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NumberOfDPDCH");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SpreadingFactor (OSCTXT* pctxt, utran_SpreadingFactor* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SpreadingFactor");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_NumberOfFBI_Bits (OSCTXT* pctxt, utran_NumberOfFBI_Bits* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NumberOfFBI-Bits");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_UL_DPCH_Info_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode scramblingCodeType */
   RTXCTXTPUSHELEMNAME (pctxt, "scramblingCodeType");

   stat = asn1PD_utran_ScramblingCodeType (pctxt, &pvalue->scramblingCodeType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode scramblingCode */
   RTXCTXTPUSHELEMNAME (pctxt, "scramblingCode");

   stat = asn1PD_utran_UL_ScramblingCode (pctxt, &pvalue->scramblingCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfDPDCH */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfDPDCH");

      stat = asn1PD_utran_NumberOfDPDCH (pctxt, &pvalue->numberOfDPDCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->numberOfDPDCH = 1;
   }

   /* decode spreadingFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactor");

   stat = asn1PD_utran_SpreadingFactor (pctxt, &pvalue->spreadingFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfFBI_Bits */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfFBI-Bits");

      pvalue->m.numberOfFBI_BitsPresent = 1;

      stat = asn1PD_utran_NumberOfFBI_Bits (pctxt, &pvalue->numberOfFBI_Bits);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode puncturingLimit */
   RTXCTXTPUSHELEMNAME (pctxt, "puncturingLimit");

   stat = asn1PD_utran_PuncturingLimit (pctxt, &pvalue->puncturingLimit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvance (OSCTXT* pctxt, utran_UL_TimingAdvance* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-TimingAdvance");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl_enabled (OSCTXT* pctxt, utran_UL_TimingAdvanceControl_enabled* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TimingAdvance */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TimingAdvance");

      pvalue->m.ul_TimingAdvancePresent = 1;

      stat = asn1PD_utran_UL_TimingAdvance (pctxt, &pvalue->ul_TimingAdvance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode activationTime */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "activationTime");

      pvalue->m.activationTimePresent = 1;

      stat = asn1PD_utran_ActivationTime (pctxt, &pvalue->activationTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl (OSCTXT* pctxt, utran_UL_TimingAdvanceControl* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-TimingAdvanceControl");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* disabled */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "disabled");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* enabled */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "enabled");

         pvalue->u.enabled = rtxMemAllocType (pctxt, 
            utran_UL_TimingAdvanceControl_enabled);

         if (pvalue->u.enabled == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_TimingAdvanceControl_enabled (pvalue->u.enabled);

         stat = asn1PD_utran_UL_TimingAdvanceControl_enabled (pctxt, pvalue->u.enabled);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TS_ChannelisationCode (OSCTXT* pctxt, utran_UL_TS_ChannelisationCode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-TS-ChannelisationCode");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(30));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TS_ChannelisationCodeList (OSCTXT* pctxt, utran_UL_TS_ChannelisationCodeList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-TS-ChannelisationCodeList");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 2) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-TS-ChannelisationCode", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_UL_TS_ChannelisationCode));
      stat = asn1PD_utran_UL_TS_ChannelisationCode (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_consecutive (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_consecutive* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode numAdditionalTimeslots */
   RTXCTXTPUSHELEMNAME (pctxt, "numAdditionalTimeslots");

   stat = pd_ConsUInt8 (pctxt, &pvalue->numAdditionalTimeslots, OSUINTCONST(1), OSUINTCONST(13));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_parameters_sameAsLast (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_parameters_sameAsLast* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_parameters_newParameters (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_parameters_newParameters* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTimeslotInfo");

   stat = asn1PD_utran_IndividualTimeslotInfo (pctxt, &pvalue->individualTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TS_ChannelisationCodeList */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TS-ChannelisationCodeList");

   stat = asn1PD_utran_UL_TS_ChannelisationCodeList (pctxt, &pvalue->ul_TS_ChannelisationCodeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_parameters (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_parameters* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* sameAsLast */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsLast");

         pvalue->u.sameAsLast = rtxMemAllocTypeZ (pctxt, 
            utran_UplinkAdditionalTimeslots_parameters_sameAsLast);

         if (pvalue->u.sameAsLast == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UplinkAdditionalTimeslots_parameters_sameAsLast (pctxt, pvalue->u.sameAsLast);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* newParameters */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "newParameters");

         pvalue->u.newParameters = rtxMemAllocType (pctxt, 
            utran_UplinkAdditionalTimeslots_parameters_newParameters);

         if (pvalue->u.newParameters == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UplinkAdditionalTimeslots_parameters_newParameters (pvalue->u.newParameters);

         stat = asn1PD_utran_UplinkAdditionalTimeslots_parameters_newParameters (pctxt, pvalue->u.newParameters);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkAdditionalTimeslots");

   /* decode root elements */
   /* decode parameters */
   RTXCTXTPUSHELEMNAME (pctxt, "parameters");

   stat = asn1PD_utran_UplinkAdditionalTimeslots_parameters (pctxt, &pvalue->parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(13), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UplinkAdditionalTimeslots* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UplinkAdditionalTimeslots", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UplinkAdditionalTimeslots, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UplinkAdditionalTimeslots (pdata);

      stat = asn1PD_utran_UplinkAdditionalTimeslots (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* consecutive */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "consecutive");

         pvalue->u.consecutive = rtxMemAllocTypeZ (pctxt, 
            utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_consecutive);

         if (pvalue->u.consecutive == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_consecutive (pctxt, pvalue->u.consecutive);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* timeslotList */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "timeslotList");

         pvalue->u.timeslotList = rtxMemAllocType (pctxt, 
            utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList);

         if (pvalue->u.timeslotList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList (pvalue->u.timeslotList);

         stat = asn1PD_utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList (pctxt, pvalue->u.timeslotList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_moreTimeslots (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_moreTimeslots* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* noMore */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "noMore");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* additionalTimeslots */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "additionalTimeslots");

         pvalue->u.additionalTimeslots = rtxMemAllocType (pctxt, 
            utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots);

         if (pvalue->u.additionalTimeslots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots (pvalue->u.additionalTimeslots);

         stat = asn1PD_utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots (pctxt, pvalue->u.additionalTimeslots);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes (OSCTXT* pctxt, utran_UplinkTimeslotsCodes* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkTimeslotsCodes");

   /* decode root elements */
   /* decode dynamicSFusage */
   RTXCTXTPUSHELEMNAME (pctxt, "dynamicSFusage");

   stat = DEC_BIT (pctxt, &pvalue->dynamicSFusage);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode firstIndividualTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "firstIndividualTimeslotInfo");

   stat = asn1PD_utran_IndividualTimeslotInfo (pctxt, &pvalue->firstIndividualTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TS_ChannelisationCodeList */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TS-ChannelisationCodeList");

   stat = asn1PD_utran_UL_TS_ChannelisationCodeList (pctxt, &pvalue->ul_TS_ChannelisationCodeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode moreTimeslots */
   RTXCTXTPUSHELEMNAME (pctxt, "moreTimeslots");

   stat = asn1PD_utran_UplinkTimeslotsCodes_moreTimeslots (pctxt, &pvalue->moreTimeslots);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CCTrCH (OSCTXT* pctxt, utran_UL_CCTrCH* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CCTrCH");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tfcs_ID */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tfcs-ID");

      stat = asn1PD_utran_TFCS_IdentityPlain (pctxt, &pvalue->tfcs_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->tfcs_ID = 1;
   }

   /* decode ul_TargetSIR */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TargetSIR");

   stat = asn1PD_utran_UL_TargetSIR (pctxt, &pvalue->ul_TargetSIR);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "timeInfo");

   stat = asn1PD_utran_TimeInfo (pctxt, &pvalue->timeInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode commonTimeslotInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "commonTimeslotInfo");

      pvalue->m.commonTimeslotInfoPresent = 1;

      stat = asn1PD_utran_CommonTimeslotInfo (pctxt, &pvalue->commonTimeslotInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCH_TimeslotsCodes */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCH-TimeslotsCodes");

      pvalue->m.ul_CCTrCH_TimeslotsCodesPresent = 1;

      stat = asn1PD_utran_UplinkTimeslotsCodes (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CCTrCHList (OSCTXT* pctxt, utran_UL_CCTrCHList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CCTrCHList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UL_CCTrCH* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-CCTrCH", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UL_CCTrCH, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UL_CCTrCH (pdata);

      stat = asn1PD_utran_UL_CCTrCH (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CCTrCHListToRemove (OSCTXT* pctxt, utran_UL_CCTrCHListToRemove* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CCTrCHListToRemove");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 8) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TFCS-IdentityPlain", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_TFCS_IdentityPlain));
      stat = asn1PD_utran_TFCS_IdentityPlain (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_UL_DPCH_Info_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TimingAdvance */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TimingAdvance");

      pvalue->m.ul_TimingAdvancePresent = 1;

      stat = asn1PD_utran_UL_TimingAdvanceControl (pctxt, &pvalue->ul_TimingAdvance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCHList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCHList");

      pvalue->m.ul_CCTrCHListPresent = 1;

      stat = asn1PD_utran_UL_CCTrCHList (pctxt, &pvalue->ul_CCTrCHList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCHListToRemove */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCHListToRemove");

      pvalue->m.ul_CCTrCHListToRemovePresent = 1;

      stat = asn1PD_utran_UL_CCTrCHListToRemove (pctxt, &pvalue->ul_CCTrCHListToRemove);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_modeSpecificInfo (OSCTXT* pctxt, utran_UL_DPCH_Info_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_DPCH_Info_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_DPCH_Info_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info (OSCTXT* pctxt, utran_UL_DPCH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-Info");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-DPCH-PowerControlInfo");

      pvalue->m.ul_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_UL_DPCH_PowerControlInfo (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_UL_DPCH_Info_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AP_PreambleScramblingCode (OSCTXT* pctxt, utran_AP_PreambleScramblingCode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AP-PreambleScramblingCode");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(79));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AP_AICH_ChannelisationCode (OSCTXT* pctxt, utran_AP_AICH_ChannelisationCode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AP-AICH-ChannelisationCode");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CD_PreambleScramblingCode (OSCTXT* pctxt, utran_CD_PreambleScramblingCode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CD-PreambleScramblingCode");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(79));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CD_CA_ICH_ChannelisationCode (OSCTXT* pctxt, utran_CD_CA_ICH_ChannelisationCode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CD-CA-ICH-ChannelisationCode");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CD_AccessSlotSubchannel (OSCTXT* pctxt, utran_CD_AccessSlotSubchannel* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CD-AccessSlotSubchannel");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(11));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CD_AccessSlotSubchannelList (OSCTXT* pctxt, utran_CD_AccessSlotSubchannelList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CD-AccessSlotSubchannelList");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 12) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CD-AccessSlotSubchannel", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_CD_AccessSlotSubchannel));
      stat = asn1PD_utran_CD_AccessSlotSubchannel (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CD_SignatureCode (OSCTXT* pctxt, utran_CD_SignatureCode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CD-SignatureCode");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CD_SignatureCodeList (OSCTXT* pctxt, utran_CD_SignatureCodeList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CD-SignatureCodeList");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 16) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CD-SignatureCode", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_CD_SignatureCode));
      stat = asn1PD_utran_CD_SignatureCode (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DeltaPp_m (OSCTXT* pctxt, utran_DeltaPp_m* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeltaPp-m");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-10), OSINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCCH_SlotFormat (OSCTXT* pctxt, utran_UL_DPCCH_SlotFormat* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCCH-SlotFormat");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_N_StartMessage (OSCTXT* pctxt, utran_N_StartMessage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "N-StartMessage");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_N_EOT (OSCTXT* pctxt, utran_N_EOT* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "N-EOT");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MinimumSpreadingFactor (OSCTXT* pctxt, utran_MinimumSpreadingFactor* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MinimumSpreadingFactor");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_NF_Max (OSCTXT* pctxt, utran_NF_Max* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NF-Max");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(64));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MaxAvailablePCPCH_Number (OSCTXT* pctxt, utran_MaxAvailablePCPCH_Number* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MaxAvailablePCPCH-Number");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(64));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AP_Signature (OSCTXT* pctxt, utran_AP_Signature* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AP-Signature");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AP_Subchannel (OSCTXT* pctxt, utran_AP_Subchannel* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AP-Subchannel");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(11));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AvailableAP_SubchannelList (OSCTXT* pctxt, utran_AvailableAP_SubchannelList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AvailableAP-SubchannelList");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 12) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AP-Subchannel", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_AP_Subchannel));
      stat = asn1PD_utran_AP_Subchannel (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AP_Signature_VCAM (OSCTXT* pctxt, utran_AP_Signature_VCAM* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AP-Signature-VCAM");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ap_Signature */
   RTXCTXTPUSHELEMNAME (pctxt, "ap-Signature");

   stat = asn1PD_utran_AP_Signature (pctxt, &pvalue->ap_Signature);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode availableAP_SubchannelList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "availableAP-SubchannelList");

      pvalue->m.availableAP_SubchannelListPresent = 1;

      stat = asn1PD_utran_AvailableAP_SubchannelList (pctxt, &pvalue->availableAP_SubchannelList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AvailableAP_Signature_VCAMList (OSCTXT* pctxt, utran_AvailableAP_Signature_VCAMList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AvailableAP-Signature-VCAMList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_AP_Signature_VCAM* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AP-Signature-VCAM", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_AP_Signature_VCAM, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_AP_Signature_VCAM (pdata);

      stat = asn1PD_utran_AP_Signature_VCAM (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AvailableMinimumSF_VCAM (OSCTXT* pctxt, utran_AvailableMinimumSF_VCAM* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AvailableMinimumSF-VCAM");

   /* decode root elements */
   /* decode minimumSpreadingFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "minimumSpreadingFactor");

   stat = asn1PD_utran_MinimumSpreadingFactor (pctxt, &pvalue->minimumSpreadingFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nf_Max */
   RTXCTXTPUSHELEMNAME (pctxt, "nf-Max");

   stat = asn1PD_utran_NF_Max (pctxt, &pvalue->nf_Max);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maxAvailablePCPCH_Number */
   RTXCTXTPUSHELEMNAME (pctxt, "maxAvailablePCPCH-Number");

   stat = asn1PD_utran_MaxAvailablePCPCH_Number (pctxt, &pvalue->maxAvailablePCPCH_Number);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode availableAP_Signature_VCAMList */
   RTXCTXTPUSHELEMNAME (pctxt, "availableAP-Signature-VCAMList");

   stat = asn1PD_utran_AvailableAP_Signature_VCAMList (pctxt, &pvalue->availableAP_Signature_VCAMList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AvailableMinimumSF_ListVCAM (OSCTXT* pctxt, utran_AvailableMinimumSF_ListVCAM* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AvailableMinimumSF-ListVCAM");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(7), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_AvailableMinimumSF_VCAM* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AvailableMinimumSF-VCAM", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_AvailableMinimumSF_VCAM, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_AvailableMinimumSF_VCAM (pdata);

      stat = asn1PD_utran_AvailableMinimumSF_VCAM (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ChannelAssignmentActive (OSCTXT* pctxt, utran_ChannelAssignmentActive* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "ChannelAssignmentActive");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* notActive */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "notActive");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* isActive */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "isActive");

         pvalue->u.isActive = rtxMemAllocType (pctxt, 
            utran_AvailableMinimumSF_ListVCAM);

         if (pvalue->u.isActive == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_AvailableMinimumSF_ListVCAM (pvalue->u.isActive);

         stat = asn1PD_utran_AvailableMinimumSF_ListVCAM (pctxt, pvalue->u.isActive);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CPCH_StatusIndicationMode (OSCTXT* pctxt, utran_CPCH_StatusIndicationMode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CPCH-StatusIndicationMode");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PCP_Length (OSCTXT* pctxt, utran_PCP_Length* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PCP-Length");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AvailableAP_SignatureList (OSCTXT* pctxt, utran_AvailableAP_SignatureList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AvailableAP-SignatureList");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 16) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AP-Signature", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_AP_Signature));
      stat = asn1PD_utran_AP_Signature (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ChannelReqParamsForUCSM (OSCTXT* pctxt, utran_ChannelReqParamsForUCSM* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ChannelReqParamsForUCSM");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode availableAP_SignatureList */
   RTXCTXTPUSHELEMNAME (pctxt, "availableAP-SignatureList");

   stat = asn1PD_utran_AvailableAP_SignatureList (pctxt, &pvalue->availableAP_SignatureList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode availableAP_SubchannelList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "availableAP-SubchannelList");

      pvalue->m.availableAP_SubchannelListPresent = 1;

      stat = asn1PD_utran_AvailableAP_SubchannelList (pctxt, &pvalue->availableAP_SubchannelList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UCSM_Info (OSCTXT* pctxt, utran_UCSM_Info* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UCSM-Info");

   /* decode root elements */
   /* decode minimumSpreadingFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "minimumSpreadingFactor");

   stat = asn1PD_utran_MinimumSpreadingFactor (pctxt, &pvalue->minimumSpreadingFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nf_Max */
   RTXCTXTPUSHELEMNAME (pctxt, "nf-Max");

   stat = asn1PD_utran_NF_Max (pctxt, &pvalue->nf_Max);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode channelReqParamsForUCSM */
   RTXCTXTPUSHELEMNAME (pctxt, "channelReqParamsForUCSM");

   stat = asn1PD_utran_ChannelReqParamsForUCSM (pctxt, &pvalue->channelReqParamsForUCSM);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PCPCH_ChannelInfo (OSCTXT* pctxt, utran_PCPCH_ChannelInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "PCPCH-ChannelInfo");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pcpch_UL_ScramblingCode */
   RTXCTXTPUSHELEMNAME (pctxt, "pcpch-UL-ScramblingCode");

   stat = pd_ConsUInt8 (pctxt, &pvalue->pcpch_UL_ScramblingCode, OSUINTCONST(0), OSUINTCONST(79));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pcpch_DL_ChannelisationCode */
   RTXCTXTPUSHELEMNAME (pctxt, "pcpch-DL-ChannelisationCode");

   stat = pd_ConsUInt16 (pctxt, &pvalue->pcpch_DL_ChannelisationCode, OSUINTCONST(0), OSUINTCONST(511));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pcpch_DL_ScramblingCode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pcpch-DL-ScramblingCode");

      pvalue->m.pcpch_DL_ScramblingCodePresent = 1;

      stat = asn1PD_utran_SecondaryScramblingCode (pctxt, &pvalue->pcpch_DL_ScramblingCode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pcp_Length */
   RTXCTXTPUSHELEMNAME (pctxt, "pcp-Length");

   stat = asn1PD_utran_PCP_Length (pctxt, &pvalue->pcp_Length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ucsm_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ucsm-Info");

      pvalue->m.ucsm_InfoPresent = 1;

      stat = asn1PD_utran_UCSM_Info (pctxt, &pvalue->ucsm_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PCPCH_ChannelInfoList (OSCTXT* pctxt, utran_PCPCH_ChannelInfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PCPCH-ChannelInfoList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_PCPCH_ChannelInfo* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PCPCH-ChannelInfo", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_PCPCH_ChannelInfo, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_PCPCH_ChannelInfo (pdata);

      stat = asn1PD_utran_PCPCH_ChannelInfo (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CPCH_SetInfo (OSCTXT* pctxt, utran_CPCH_SetInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "CPCH-SetInfo");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cpch_SetID */
   RTXCTXTPUSHELEMNAME (pctxt, "cpch-SetID");

   stat = asn1PD_utran_CPCH_SetID (pctxt, &pvalue->cpch_SetID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportFormatSet */
   RTXCTXTPUSHELEMNAME (pctxt, "transportFormatSet");

   stat = asn1PD_utran_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfcs */
   RTXCTXTPUSHELEMNAME (pctxt, "tfcs");

   stat = asn1PD_utran_TFCS (pctxt, &pvalue->tfcs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ap_PreambleScramblingCode */
   RTXCTXTPUSHELEMNAME (pctxt, "ap-PreambleScramblingCode");

   stat = asn1PD_utran_AP_PreambleScramblingCode (pctxt, &pvalue->ap_PreambleScramblingCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ap_AICH_ChannelisationCode */
   RTXCTXTPUSHELEMNAME (pctxt, "ap-AICH-ChannelisationCode");

   stat = asn1PD_utran_AP_AICH_ChannelisationCode (pctxt, &pvalue->ap_AICH_ChannelisationCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cd_PreambleScramblingCode */
   RTXCTXTPUSHELEMNAME (pctxt, "cd-PreambleScramblingCode");

   stat = asn1PD_utran_CD_PreambleScramblingCode (pctxt, &pvalue->cd_PreambleScramblingCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cd_CA_ICH_ChannelisationCode */
   RTXCTXTPUSHELEMNAME (pctxt, "cd-CA-ICH-ChannelisationCode");

   stat = asn1PD_utran_CD_CA_ICH_ChannelisationCode (pctxt, &pvalue->cd_CA_ICH_ChannelisationCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cd_AccessSlotSubchannelList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cd-AccessSlotSubchannelList");

      pvalue->m.cd_AccessSlotSubchannelListPresent = 1;

      stat = asn1PD_utran_CD_AccessSlotSubchannelList (pctxt, &pvalue->cd_AccessSlotSubchannelList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cd_SignatureCodeList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cd-SignatureCodeList");

      pvalue->m.cd_SignatureCodeListPresent = 1;

      stat = asn1PD_utran_CD_SignatureCodeList (pctxt, &pvalue->cd_SignatureCodeList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode deltaPp_m */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaPp-m");

   stat = asn1PD_utran_DeltaPp_m (pctxt, &pvalue->deltaPp_m);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_DPCCH_SlotFormat */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-DPCCH-SlotFormat");

   stat = asn1PD_utran_UL_DPCCH_SlotFormat (pctxt, &pvalue->ul_DPCCH_SlotFormat);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode n_StartMessage */
   RTXCTXTPUSHELEMNAME (pctxt, "n-StartMessage");

   stat = asn1PD_utran_N_StartMessage (pctxt, &pvalue->n_StartMessage);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode n_EOT */
   RTXCTXTPUSHELEMNAME (pctxt, "n-EOT");

   stat = asn1PD_utran_N_EOT (pctxt, &pvalue->n_EOT);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode channelAssignmentActive */
   RTXCTXTPUSHELEMNAME (pctxt, "channelAssignmentActive");

   stat = asn1PD_utran_ChannelAssignmentActive (pctxt, &pvalue->channelAssignmentActive);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cpch_StatusIndicationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "cpch-StatusIndicationMode");

   stat = asn1PD_utran_CPCH_StatusIndicationMode (pctxt, &pvalue->cpch_StatusIndicationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pcpch_ChannelInfoList */
   RTXCTXTPUSHELEMNAME (pctxt, "pcpch-ChannelInfoList");

   stat = asn1PD_utran_PCPCH_ChannelInfoList (pctxt, &pvalue->pcpch_ChannelInfoList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_ChannelRequirement (OSCTXT* pctxt, utran_UL_ChannelRequirement* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-ChannelRequirement");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* ul_DPCH_Info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "ul-DPCH-Info");

         pvalue->u.ul_DPCH_Info = rtxMemAllocType (pctxt, utran_UL_DPCH_Info);

         if (pvalue->u.ul_DPCH_Info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info (pvalue->u.ul_DPCH_Info);

         stat = asn1PD_utran_UL_DPCH_Info (pctxt, pvalue->u.ul_DPCH_Info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dummy */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dummy");

         pvalue->u.dummy = rtxMemAllocType (pctxt, utran_CPCH_SetInfo);

         if (pvalue->u.dummy == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_CPCH_SetInfo (pvalue->u.dummy);

         stat = asn1PD_utran_CPCH_SetInfo (pctxt, pvalue->u.dummy);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DSCH_RadioLinkIdentifier (OSCTXT* pctxt, utran_DSCH_RadioLinkIdentifier* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DSCH-RadioLinkIdentifier");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(511));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RL_IdentifierList (OSCTXT* pctxt, utran_RL_IdentifierList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RL-IdentifierList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_PrimaryCPICH_Info* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PrimaryCPICH-Info", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_PrimaryCPICH_Info, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_PrimaryCPICH_Info (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PDSCH_SHO_DCH_Info (OSCTXT* pctxt, utran_PDSCH_SHO_DCH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDSCH-SHO-DCH-Info");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dsch_RadioLinkIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "dsch-RadioLinkIdentifier");

   stat = asn1PD_utran_DSCH_RadioLinkIdentifier (pctxt, &pvalue->dsch_RadioLinkIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rl_IdentifierList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rl-IdentifierList");

      pvalue->m.rl_IdentifierListPresent = 1;

      stat = asn1PD_utran_RL_IdentifierList (pctxt, &pvalue->rl_IdentifierList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SF_PDSCH (OSCTXT* pctxt, utran_SF_PDSCH* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SF-PDSCH");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MultiCodeInfo (OSCTXT* pctxt, utran_MultiCodeInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MultiCodeInfo");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CodeNumberDSCH (OSCTXT* pctxt, utran_CodeNumberDSCH* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CodeNumberDSCH");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PDSCH_CodeMap (OSCTXT* pctxt, utran_PDSCH_CodeMap* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDSCH-CodeMap");

   /* decode root elements */
   /* decode spreadingFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactor");

   stat = asn1PD_utran_SF_PDSCH (pctxt, &pvalue->spreadingFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode multiCodeInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "multiCodeInfo");

   stat = asn1PD_utran_MultiCodeInfo (pctxt, &pvalue->multiCodeInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode codeNumberStart */
   RTXCTXTPUSHELEMNAME (pctxt, "codeNumberStart");

   stat = asn1PD_utran_CodeNumberDSCH (pctxt, &pvalue->codeNumberStart);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode codeNumberStop */
   RTXCTXTPUSHELEMNAME (pctxt, "codeNumberStop");

   stat = asn1PD_utran_CodeNumberDSCH (pctxt, &pvalue->codeNumberStop);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PDSCH_CodeMapList (OSCTXT* pctxt, utran_PDSCH_CodeMapList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDSCH-CodeMapList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_PDSCH_CodeMap* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDSCH-CodeMap", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_PDSCH_CodeMap, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_PDSCH_CodeMap (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CodeRange (OSCTXT* pctxt, utran_CodeRange* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CodeRange");

   /* decode root elements */
   /* decode pdsch_CodeMapList */
   RTXCTXTPUSHELEMNAME (pctxt, "pdsch-CodeMapList");

   stat = asn1PD_utran_PDSCH_CodeMapList (pctxt, &pvalue->pdsch_CodeMapList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MaxTFCI_Field2Value (OSCTXT* pctxt, utran_MaxTFCI_Field2Value* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MaxTFCI-Field2Value");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(1023));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DSCH_Mapping (OSCTXT* pctxt, utran_DSCH_Mapping* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DSCH-Mapping");

   /* decode root elements */
   /* decode maxTFCI_Field2Value */
   RTXCTXTPUSHELEMNAME (pctxt, "maxTFCI-Field2Value");

   stat = asn1PD_utran_MaxTFCI_Field2Value (pctxt, &pvalue->maxTFCI_Field2Value);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode spreadingFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactor");

   stat = asn1PD_utran_SF_PDSCH (pctxt, &pvalue->spreadingFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode codeNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "codeNumber");

   stat = asn1PD_utran_CodeNumberDSCH (pctxt, &pvalue->codeNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode multiCodeInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "multiCodeInfo");

   stat = asn1PD_utran_MultiCodeInfo (pctxt, &pvalue->multiCodeInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DSCH_MappingList (OSCTXT* pctxt, utran_DSCH_MappingList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DSCH-MappingList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DSCH_Mapping* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DSCH-Mapping", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DSCH_Mapping, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_DSCH_Mapping (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PDSCH_CodeInfo (OSCTXT* pctxt, utran_PDSCH_CodeInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDSCH-CodeInfo");

   /* decode root elements */
   /* decode spreadingFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactor");

   stat = asn1PD_utran_SF_PDSCH (pctxt, &pvalue->spreadingFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode codeNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "codeNumber");

   stat = asn1PD_utran_CodeNumberDSCH (pctxt, &pvalue->codeNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode multiCodeInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "multiCodeInfo");

   stat = asn1PD_utran_MultiCodeInfo (pctxt, &pvalue->multiCodeInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PDSCH_CodeInfoList (OSCTXT* pctxt, utran_PDSCH_CodeInfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDSCH-CodeInfoList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(512), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_PDSCH_CodeInfo* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDSCH-CodeInfo", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_PDSCH_CodeInfo, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_PDSCH_CodeInfo (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ReplacedPDSCH_CodeInfo (OSCTXT* pctxt, utran_ReplacedPDSCH_CodeInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReplacedPDSCH-CodeInfo");

   /* decode root elements */
   /* decode tfci_Field2 */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Field2");

   stat = asn1PD_utran_MaxTFCI_Field2Value (pctxt, &pvalue->tfci_Field2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode spreadingFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactor");

   stat = asn1PD_utran_SF_PDSCH (pctxt, &pvalue->spreadingFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode codeNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "codeNumber");

   stat = asn1PD_utran_CodeNumberDSCH (pctxt, &pvalue->codeNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode multiCodeInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "multiCodeInfo");

   stat = asn1PD_utran_MultiCodeInfo (pctxt, &pvalue->multiCodeInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ReplacedPDSCH_CodeInfoList (OSCTXT* pctxt, utran_ReplacedPDSCH_CodeInfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReplacedPDSCH-CodeInfoList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(512), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_ReplacedPDSCH_CodeInfo* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ReplacedPDSCH-CodeInfo", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_ReplacedPDSCH_CodeInfo, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_ReplacedPDSCH_CodeInfo (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PDSCH_CodeMapping_signallingMethod (OSCTXT* pctxt, utran_PDSCH_CodeMapping_signallingMethod* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* codeRange */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "codeRange");

         pvalue->u.codeRange = rtxMemAllocType (pctxt, utran_CodeRange);

         if (pvalue->u.codeRange == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_CodeRange (pvalue->u.codeRange);

         stat = asn1PD_utran_CodeRange (pctxt, pvalue->u.codeRange);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tfci_Range */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tfci-Range");

         pvalue->u.tfci_Range = rtxMemAllocType (pctxt, 
            utran_DSCH_MappingList);

         if (pvalue->u.tfci_Range == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DSCH_MappingList (pvalue->u.tfci_Range);

         stat = asn1PD_utran_DSCH_MappingList (pctxt, pvalue->u.tfci_Range);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* explicit_config */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "explicit-config");

         pvalue->u.explicit_config = rtxMemAllocType (pctxt, 
            utran_PDSCH_CodeInfoList);

         if (pvalue->u.explicit_config == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_PDSCH_CodeInfoList (pvalue->u.explicit_config);

         stat = asn1PD_utran_PDSCH_CodeInfoList (pctxt, pvalue->u.explicit_config);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* replace */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "replace");

         pvalue->u.replace = rtxMemAllocType (pctxt, 
            utran_ReplacedPDSCH_CodeInfoList);

         if (pvalue->u.replace == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_ReplacedPDSCH_CodeInfoList (pvalue->u.replace);

         stat = asn1PD_utran_ReplacedPDSCH_CodeInfoList (pctxt, pvalue->u.replace);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_PDSCH_CodeMapping (OSCTXT* pctxt, utran_PDSCH_CodeMapping* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDSCH-CodeMapping");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_ScramblingCode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-ScramblingCode");

      pvalue->m.dl_ScramblingCodePresent = 1;

      stat = asn1PD_utran_SecondaryScramblingCode (pctxt, &pvalue->dl_ScramblingCode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode signallingMethod */
   RTXCTXTPUSHELEMNAME (pctxt, "signallingMethod");

   stat = asn1PD_utran_PDSCH_CodeMapping_signallingMethod (pctxt, &pvalue->signallingMethod);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_PDSCH_Information (OSCTXT* pctxt, utran_DL_PDSCH_Information* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-PDSCH-Information");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dummy1 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy1");

      pvalue->m.dummy1Present = 1;

      stat = asn1PD_utran_PDSCH_SHO_DCH_Info (pctxt, &pvalue->dummy1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dummy2 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy2");

      pvalue->m.dummy2Present = 1;

      stat = asn1PD_utran_PDSCH_CodeMapping (pctxt, &pvalue->dummy2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Cfntargetsfnframeoffset (OSCTXT* pctxt, utran_Cfntargetsfnframeoffset* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Cfntargetsfnframeoffset");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_cfnHandling_initialise (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_cfnHandling_initialise* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dummy */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy");

      pvalue->m.dummyPresent = 1;

      stat = asn1PD_utran_Cfntargetsfnframeoffset (pctxt, &pvalue->dummy);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_cfnHandling (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_cfnHandling* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* maintain */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "maintain");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* initialise */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "initialise");

         pvalue->u.initialise = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_cfnHandling_initialise);

         if (pvalue->u.initialise == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_cfnHandling_initialise (pvalue->u.initialise);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_cfnHandling_initialise (pctxt, pvalue->u.initialise);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_PowerControlInfo_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_DPCH_PowerControlInfo_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode dpc_Mode */
   RTXCTXTPUSHELEMNAME (pctxt, "dpc-Mode");

   stat = asn1PD_utran_DPC_Mode (pctxt, &pvalue->dpc_Mode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TPC_StepSizeTDD (OSCTXT* pctxt, utran_TPC_StepSizeTDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TPC-StepSizeTDD");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_PowerControlInfo_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_DPCH_PowerControlInfo_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tpc_StepSizeTDD */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tpc-StepSizeTDD");

      pvalue->m.tpc_StepSizeTDDPresent = 1;

      stat = asn1PD_utran_TPC_StepSizeTDD (pctxt, &pvalue->tpc_StepSizeTDD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_PowerControlInfo_modeSpecificInfo (OSCTXT* pctxt, utran_DL_DPCH_PowerControlInfo_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocTypeZ (pctxt, 
            utran_DL_DPCH_PowerControlInfo_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_DPCH_PowerControlInfo_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_PowerControlInfo_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_PowerControlInfo_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_DPCH_PowerControlInfo_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_PowerControlInfo (OSCTXT* pctxt, utran_DL_DPCH_PowerControlInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DPCH-PowerControlInfo");

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_DPCH_PowerControlInfo_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PowerOffsetPilot_pdpdch (OSCTXT* pctxt, utran_PowerOffsetPilot_pdpdch* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PowerOffsetPilot-pdpdch");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(24));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RestrictedTrCH (OSCTXT* pctxt, utran_RestrictedTrCH* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RestrictedTrCH");

   /* decode root elements */
   /* decode dl_restrictedTrCh_Type */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-restrictedTrCh-Type");

   stat = asn1PD_utran_DL_TrCH_Type (pctxt, &pvalue->dl_restrictedTrCh_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode restrictedDL_TrCH_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "restrictedDL-TrCH-Identity");

   stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->restrictedDL_TrCH_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode allowedTFIList */
   RTXCTXTPUSHELEMNAME (pctxt, "allowedTFIList");

   stat = asn1PD_utran_AllowedTFI_List (pctxt, &pvalue->allowedTFIList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RestrictedTrCH_InfoList (OSCTXT* pctxt, utran_RestrictedTrCH_InfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RestrictedTrCH-InfoList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RestrictedTrCH* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RestrictedTrCH", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RestrictedTrCH, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RestrictedTrCH (pdata);

      stat = asn1PD_utran_RestrictedTrCH (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Dl_rate_matching_restriction (OSCTXT* pctxt, utran_Dl_rate_matching_restriction* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "Dl-rate-matching-restriction");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode restrictedTrCH_InfoList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "restrictedTrCH-InfoList");

      pvalue->m.restrictedTrCH_InfoListPresent = 1;

      stat = asn1PD_utran_RestrictedTrCH_InfoList (pctxt, &pvalue->restrictedTrCH_InfoList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PilotBits128 (OSCTXT* pctxt, utran_PilotBits128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PilotBits128");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PilotBits256 (OSCTXT* pctxt, utran_PilotBits256* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PilotBits256");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SF512_AndPilot (OSCTXT* pctxt, utran_SF512_AndPilot* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "SF512-AndPilot");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* sfd4 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sfd8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd8");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sfd16 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd16");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sfd32 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd32");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sfd64 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd64");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sfd128 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd128");

         stat = asn1PD_utran_PilotBits128 (pctxt, &pvalue->u.sfd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sfd256 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd256");

         stat = asn1PD_utran_PilotBits256 (pctxt, &pvalue->u.sfd256);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sfd512 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd512");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-PowerControlInfo");

      pvalue->m.dl_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode powerOffsetPilot_pdpdch */
   RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetPilot-pdpdch");

   stat = asn1PD_utran_PowerOffsetPilot_pdpdch (pctxt, &pvalue->powerOffsetPilot_pdpdch);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_rate_matching_restriction */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-rate-matching-restriction");

      pvalue->m.dl_rate_matching_restrictionPresent = 1;

      stat = asn1PD_utran_Dl_rate_matching_restriction (pctxt, &pvalue->dl_rate_matching_restriction);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode spreadingFactorAndPilot */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactorAndPilot");

   stat = asn1PD_utran_SF512_AndPilot (pctxt, &pvalue->spreadingFactorAndPilot);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode positionFixedOrFlexible */
   RTXCTXTPUSHELEMNAME (pctxt, "positionFixedOrFlexible");

   stat = asn1PD_utran_PositionFixedOrFlexible (pctxt, &pvalue->positionFixedOrFlexible);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-PowerControlInfo");

      pvalue->m.dl_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_modeSpecificInfo (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DPCH-InfoCommon");

   /* decode root elements */
   /* decode cfnHandling */
   RTXCTXTPUSHELEMNAME (pctxt, "cfnHandling");

   stat = asn1PD_utran_DL_DPCH_InfoCommon_cfnHandling (pctxt, &pvalue->cfnHandling);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_DPCH_InfoCommon_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DefaultDPCH_OffsetValueFDD (OSCTXT* pctxt, utran_DefaultDPCH_OffsetValueFDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DefaultDPCH-OffsetValueFDD");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(599));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGCFN (OSCTXT* pctxt, utran_TGCFN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TGCFN");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGP_Sequence_tgps_Status_activate (OSCTXT* pctxt, utran_TGP_Sequence_tgps_Status_activate* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tgcfn */
   RTXCTXTPUSHELEMNAME (pctxt, "tgcfn");

   stat = asn1PD_utran_TGCFN (pctxt, &pvalue->tgcfn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGP_Sequence_tgps_Status (OSCTXT* pctxt, utran_TGP_Sequence_tgps_Status* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* activate */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "activate");

         pvalue->u.activate = rtxMemAllocTypeZ (pctxt, 
            utran_TGP_Sequence_tgps_Status_activate);

         if (pvalue->u.activate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_TGP_Sequence_tgps_Status_activate (pctxt, pvalue->u.activate);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* deactivate */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "deactivate");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TGMP (OSCTXT* pctxt, utran_TGMP* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TGMP");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGPRC (OSCTXT* pctxt, utran_TGPRC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TGPRC");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(511));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGSN (OSCTXT* pctxt, utran_TGSN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TGSN");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(14));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGL (OSCTXT* pctxt, utran_TGL* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TGL");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(14));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGD (OSCTXT* pctxt, utran_TGD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TGD");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(15), OSUINTCONST(270));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGPL (OSCTXT* pctxt, utran_TGPL* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TGPL");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(144));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RPP (OSCTXT* pctxt, utran_RPP* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RPP");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ITP (OSCTXT* pctxt, utran_ITP* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ITP");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CompressedModeMethod (OSCTXT* pctxt, utran_UL_CompressedModeMethod* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CompressedModeMethod");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CompressedModeMethod (OSCTXT* pctxt, utran_DL_CompressedModeMethod* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CompressedModeMethod");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DL_Mode_ul_and_dl (OSCTXT* pctxt, utran_UL_DL_Mode_ul_and_dl* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ul */
   RTXCTXTPUSHELEMNAME (pctxt, "ul");

   stat = asn1PD_utran_UL_CompressedModeMethod (pctxt, &pvalue->ul);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl */
   RTXCTXTPUSHELEMNAME (pctxt, "dl");

   stat = asn1PD_utran_DL_CompressedModeMethod (pctxt, &pvalue->dl);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DL_Mode (OSCTXT* pctxt, utran_UL_DL_Mode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DL-Mode");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* ul */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "ul");

         stat = asn1PD_utran_UL_CompressedModeMethod (pctxt, &pvalue->u.ul);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl");

         stat = asn1PD_utran_DL_CompressedModeMethod (pctxt, &pvalue->u.dl);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ul_and_dl */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "ul-and-dl");

         pvalue->u.ul_and_dl = rtxMemAllocTypeZ (pctxt, 
            utran_UL_DL_Mode_ul_and_dl);

         if (pvalue->u.ul_and_dl == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UL_DL_Mode_ul_and_dl (pctxt, pvalue->u.ul_and_dl);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_FrameType (OSCTXT* pctxt, utran_DL_FrameType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-FrameType");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DeltaSIR (OSCTXT* pctxt, utran_DeltaSIR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeltaSIR");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(30));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_NidentifyAbort (OSCTXT* pctxt, utran_NidentifyAbort* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NidentifyAbort");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(128));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TreconfirmAbort (OSCTXT* pctxt, utran_TreconfirmAbort* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TreconfirmAbort");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(20));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGPS_ConfigurationParams (OSCTXT* pctxt, utran_TGPS_ConfigurationParams* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[6];

   RTXCTXTPUSHTYPENAME (pctxt, "TGPS-ConfigurationParams");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tgmp */
   RTXCTXTPUSHELEMNAME (pctxt, "tgmp");

   stat = asn1PD_utran_TGMP (pctxt, &pvalue->tgmp);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgprc */
   RTXCTXTPUSHELEMNAME (pctxt, "tgprc");

   stat = asn1PD_utran_TGPRC (pctxt, &pvalue->tgprc);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgsn */
   RTXCTXTPUSHELEMNAME (pctxt, "tgsn");

   stat = asn1PD_utran_TGSN (pctxt, &pvalue->tgsn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgl1 */
   RTXCTXTPUSHELEMNAME (pctxt, "tgl1");

   stat = asn1PD_utran_TGL (pctxt, &pvalue->tgl1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgl2 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tgl2");

      pvalue->m.tgl2Present = 1;

      stat = asn1PD_utran_TGL (pctxt, &pvalue->tgl2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tgd */
   RTXCTXTPUSHELEMNAME (pctxt, "tgd");

   stat = asn1PD_utran_TGD (pctxt, &pvalue->tgd);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgpl1 */
   RTXCTXTPUSHELEMNAME (pctxt, "tgpl1");

   stat = asn1PD_utran_TGPL (pctxt, &pvalue->tgpl1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dummy */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy");

      pvalue->m.dummyPresent = 1;

      stat = asn1PD_utran_TGPL (pctxt, &pvalue->dummy);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rpp */
   RTXCTXTPUSHELEMNAME (pctxt, "rpp");

   stat = asn1PD_utran_RPP (pctxt, &pvalue->rpp);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode itp */
   RTXCTXTPUSHELEMNAME (pctxt, "itp");

   stat = asn1PD_utran_ITP (pctxt, &pvalue->itp);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_DL_Mode */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-DL-Mode");

   stat = asn1PD_utran_UL_DL_Mode (pctxt, &pvalue->ul_DL_Mode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_FrameType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-FrameType");

   stat = asn1PD_utran_DL_FrameType (pctxt, &pvalue->dl_FrameType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaSIR1 */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaSIR1");

   stat = asn1PD_utran_DeltaSIR (pctxt, &pvalue->deltaSIR1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaSIRAfter1 */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaSIRAfter1");

   stat = asn1PD_utran_DeltaSIR (pctxt, &pvalue->deltaSIRAfter1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaSIR2 */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaSIR2");

      pvalue->m.deltaSIR2Present = 1;

      stat = asn1PD_utran_DeltaSIR (pctxt, &pvalue->deltaSIR2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode deltaSIRAfter2 */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaSIRAfter2");

      pvalue->m.deltaSIRAfter2Present = 1;

      stat = asn1PD_utran_DeltaSIR (pctxt, &pvalue->deltaSIRAfter2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nidentifyAbort */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nidentifyAbort");

      pvalue->m.nidentifyAbortPresent = 1;

      stat = asn1PD_utran_NidentifyAbort (pctxt, &pvalue->nidentifyAbort);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode treconfirmAbort */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "treconfirmAbort");

      pvalue->m.treconfirmAbortPresent = 1;

      stat = asn1PD_utran_TreconfirmAbort (pctxt, &pvalue->treconfirmAbort);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGP_Sequence (OSCTXT* pctxt, utran_TGP_Sequence* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TGP-Sequence");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tgpsi */
   RTXCTXTPUSHELEMNAME (pctxt, "tgpsi");

   stat = asn1PD_utran_TGPSI (pctxt, &pvalue->tgpsi);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgps_Status */
   RTXCTXTPUSHELEMNAME (pctxt, "tgps-Status");

   stat = asn1PD_utran_TGP_Sequence_tgps_Status (pctxt, &pvalue->tgps_Status);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgps_ConfigurationParams */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tgps-ConfigurationParams");

      pvalue->m.tgps_ConfigurationParamsPresent = 1;

      stat = asn1PD_utran_TGPS_ConfigurationParams (pctxt, &pvalue->tgps_ConfigurationParams);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGP_SequenceList (OSCTXT* pctxt, utran_TGP_SequenceList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TGP-SequenceList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(6), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_TGP_Sequence* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TGP-Sequence", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_TGP_Sequence, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_TGP_Sequence (pdata);

      stat = asn1PD_utran_TGP_Sequence (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DPCH_CompressedModeInfo (OSCTXT* pctxt, utran_DPCH_CompressedModeInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DPCH-CompressedModeInfo");

   /* decode root elements */
   /* decode tgp_SequenceList */
   RTXCTXTPUSHELEMNAME (pctxt, "tgp-SequenceList");

   stat = asn1PD_utran_TGP_SequenceList (pctxt, &pvalue->tgp_SequenceList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_CommonInformation_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueFDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dpch_CompressedModeInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dpch-CompressedModeInfo");

      pvalue->m.dpch_CompressedModeInfoPresent = 1;

      stat = asn1PD_utran_DPCH_CompressedModeInfo (pctxt, &pvalue->dpch_CompressedModeInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tx_DiversityMode */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tx-DiversityMode");

      pvalue->m.tx_DiversityModePresent = 1;

      stat = asn1PD_utran_TX_DiversityMode (pctxt, &pvalue->tx_DiversityMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dummy */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy");

      pvalue->m.dummyPresent = 1;

      stat = asn1PD_utran_SSDT_Information (pctxt, &pvalue->dummy);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DefaultDPCH_OffsetValueTDD (OSCTXT* pctxt, utran_DefaultDPCH_OffsetValueTDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DefaultDPCH-OffsetValueTDD");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_CommonInformation_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueTDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_modeSpecificInfo (OSCTXT* pctxt, utran_DL_CommonInformation_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_CommonInformation_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_CommonInformation_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation (OSCTXT* pctxt, utran_DL_CommonInformation* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CommonInformation");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_DPCH_InfoCommon */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoCommon");

      pvalue->m.dl_DPCH_InfoCommonPresent = 1;

      stat = asn1PD_utran_DL_DPCH_InfoCommon (pctxt, &pvalue->dl_DPCH_InfoCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_CommonInformation_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_InformationPerRL_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode primaryCPICH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCPICH-Info");

   stat = asn1PD_utran_PrimaryCPICH_Info (pctxt, &pvalue->primaryCPICH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dummy1 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy1");

      pvalue->m.dummy1Present = 1;

      stat = asn1PD_utran_PDSCH_SHO_DCH_Info (pctxt, &pvalue->dummy1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dummy2 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy2");

      pvalue->m.dummy2Present = 1;

      stat = asn1PD_utran_PDSCH_CodeMapping (pctxt, &pvalue->dummy2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info_fdd (OSCTXT* pctxt, utran_PrimaryCCPCH_Info_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tx_DiversityIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "tx-DiversityIndicator");

   stat = DEC_BIT (pctxt, &pvalue->tx_DiversityIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info_tdd_syncCase_syncCase1 (OSCTXT* pctxt, utran_PrimaryCCPCH_Info_tdd_syncCase_syncCase1* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslot */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslot");

   stat = asn1PD_utran_TimeslotNumber (pctxt, &pvalue->timeslot);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TimeslotSync2 (OSCTXT* pctxt, utran_TimeslotSync2* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeslotSync2");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info_tdd_syncCase_syncCase2 (OSCTXT* pctxt, utran_PrimaryCCPCH_Info_tdd_syncCase_syncCase2* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslotSync2 */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotSync2");

   stat = asn1PD_utran_TimeslotSync2 (pctxt, &pvalue->timeslotSync2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info_tdd_syncCase (OSCTXT* pctxt, utran_PrimaryCCPCH_Info_tdd_syncCase* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* syncCase1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "syncCase1");

         pvalue->u.syncCase1 = rtxMemAllocTypeZ (pctxt, 
            utran_PrimaryCCPCH_Info_tdd_syncCase_syncCase1);

         if (pvalue->u.syncCase1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_PrimaryCCPCH_Info_tdd_syncCase_syncCase1 (pctxt, pvalue->u.syncCase1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* syncCase2 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "syncCase2");

         pvalue->u.syncCase2 = rtxMemAllocTypeZ (pctxt, 
            utran_PrimaryCCPCH_Info_tdd_syncCase_syncCase2);

         if (pvalue->u.syncCase2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_PrimaryCCPCH_Info_tdd_syncCase_syncCase2 (pctxt, pvalue->u.syncCase2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info_tdd (OSCTXT* pctxt, utran_PrimaryCCPCH_Info_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode syncCase */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "syncCase");

      pvalue->m.syncCasePresent = 1;

      stat = asn1PD_utran_PrimaryCCPCH_Info_tdd_syncCase (pctxt, &pvalue->syncCase);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cellParametersID */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellParametersID");

      pvalue->m.cellParametersIDPresent = 1;

      stat = asn1PD_utran_CellParametersID (pctxt, &pvalue->cellParametersID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode sctd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "sctd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->sctd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info (OSCTXT* pctxt, utran_PrimaryCCPCH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "PrimaryCCPCH-Info");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocTypeZ (pctxt, 
            utran_PrimaryCCPCH_Info_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_PrimaryCCPCH_Info_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, utran_PrimaryCCPCH_Info_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_PrimaryCCPCH_Info_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_PrimaryCCPCH_Info_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_modeSpecificInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_InformationPerRL_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, utran_PrimaryCCPCH_Info);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_PrimaryCCPCH_Info (pvalue->u.tdd);

         stat = asn1PD_utran_PrimaryCCPCH_Info (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL (OSCTXT* pctxt, utran_DL_InformationPerRL* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_InformationPerRL_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_DPCH_InfoPerRL */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoPerRL");

      pvalue->m.dl_DPCH_InfoPerRLPresent = 1;

      stat = asn1PD_utran_DL_DPCH_InfoPerRL (pctxt, &pvalue->dl_DPCH_InfoPerRL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dummy */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy");

      pvalue->m.dummyPresent = 1;

      stat = asn1PD_utran_SCCPCH_InfoForFACH (pctxt, &pvalue->dummy);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_List (OSCTXT* pctxt, utran_DL_InformationPerRL_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-List");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_InformationPerRL* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-InformationPerRL", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_InformationPerRL, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_InformationPerRL (pdata);

      stat = asn1PD_utran_DL_InformationPerRL (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DSCH_RNTI (OSCTXT* pctxt, utran_DSCH_RNTI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DSCH-RNTI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PDCP_ROHC_TargetMode (OSCTXT* pctxt, utran_PDCP_ROHC_TargetMode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDCP-ROHC-TargetMode");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_BEACON_PL_Est (OSCTXT* pctxt, utran_BEACON_PL_Est* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "BEACON-PL-Est");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__263; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MBMS_PL_ServiceRestrictInfo_r6 (OSCTXT* pctxt, utran_MBMS_PL_ServiceRestrictInfo_r6* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMS-PL-ServiceRestrictInfo-r6");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__342; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ROHC_Profile_r4 (OSCTXT* pctxt, utran_ROHC_Profile_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ROHC-Profile-r4");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ROHC_ProfileList_r4 (OSCTXT* pctxt, utran_ROHC_ProfileList_r4* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ROHC-ProfileList-r4");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 8) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ROHC-Profile-r4", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_ROHC_Profile_r4));
      stat = asn1PD_utran_ROHC_Profile_r4 (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CID_InclusionInfo_r4 (OSCTXT* pctxt, utran_CID_InclusionInfo_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CID-InclusionInfo-r4");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ROHC_PacketSize_r4 (OSCTXT* pctxt, utran_ROHC_PacketSize_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ROHC-PacketSize-r4");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(2), OSUINTCONST(1500));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ROHC_PacketSizeList_r4 (OSCTXT* pctxt, utran_ROHC_PacketSizeList_r4* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ROHC-PacketSizeList-r4");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 16) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ROHC-PacketSize-r4", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_ROHC_PacketSize_r4));
      stat = asn1PD_utran_ROHC_PacketSize_r4 (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_RFC3095_r4 (OSCTXT* pctxt, utran_UL_RFC3095_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-RFC3095-r4");

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dummy1 */
   RTXCTXTPUSHELEMNAME (pctxt, "dummy1");

   stat = asn1PD_utran_CID_InclusionInfo_r4 (pctxt, &pvalue->dummy1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode max_CID */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "max-CID");

      stat = pd_ConsUInt16 (pctxt, &pvalue->max_CID, OSUINTCONST(1), OSUINTCONST(16383));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->max_CID = 15;
   }

   /* decode dummy */
   RTXCTXTPUSHELEMNAME (pctxt, "dummy");

   stat = asn1PD_utran_ROHC_PacketSizeList_r4 (pctxt, &pvalue->dummy);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_RFC3095_r4 (OSCTXT* pctxt, utran_DL_RFC3095_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-RFC3095-r4");

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dummy */
   RTXCTXTPUSHELEMNAME (pctxt, "dummy");

   stat = asn1PD_utran_CID_InclusionInfo_r4 (pctxt, &pvalue->dummy);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode max_CID */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "max-CID");

      stat = pd_ConsUInt16 (pctxt, &pvalue->max_CID, OSUINTCONST(1), OSUINTCONST(16383));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->max_CID = 15;
   }

   /* decode reverseDecompressionDepth */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "reverseDecompressionDepth");

      stat = pd_ConsUInt16 (pctxt, &pvalue->reverseDecompressionDepth, OSUINTCONST(0), OSUINTCONST(65535));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->reverseDecompressionDepth = 0;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RFC3095_Info_r4 (OSCTXT* pctxt, utran_RFC3095_Info_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RFC3095-Info-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rohcProfileList */
   RTXCTXTPUSHELEMNAME (pctxt, "rohcProfileList");

   stat = asn1PD_utran_ROHC_ProfileList_r4 (pctxt, &pvalue->rohcProfileList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_RFC3095 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-RFC3095");

      pvalue->m.ul_RFC3095Present = 1;

      stat = asn1PD_utran_UL_RFC3095_r4 (pctxt, &pvalue->ul_RFC3095);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_RFC3095 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-RFC3095");

      pvalue->m.dl_RFC3095Present = 1;

      stat = asn1PD_utran_DL_RFC3095_r4 (pctxt, &pvalue->dl_RFC3095);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AlgorithmSpecificInfo_r4 (OSCTXT* pctxt, utran_AlgorithmSpecificInfo_r4* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "AlgorithmSpecificInfo-r4");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rfc2507_Info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rfc2507-Info");

         pvalue->u.rfc2507_Info = rtxMemAllocType (pctxt, utran_RFC2507_Info);

         if (pvalue->u.rfc2507_Info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_RFC2507_Info (pvalue->u.rfc2507_Info);

         stat = asn1PD_utran_RFC2507_Info (pctxt, pvalue->u.rfc2507_Info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* rfc3095_Info */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rfc3095-Info");

         pvalue->u.rfc3095_Info = rtxMemAllocType (pctxt, 
            utran_RFC3095_Info_r4);

         if (pvalue->u.rfc3095_Info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_RFC3095_Info_r4 (pvalue->u.rfc3095_Info);

         stat = asn1PD_utran_RFC3095_Info_r4 (pctxt, pvalue->u.rfc3095_Info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HeaderCompressionInfo_r4 (OSCTXT* pctxt, utran_HeaderCompressionInfo_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HeaderCompressionInfo-r4");

   /* decode root elements */
   /* decode algorithmSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "algorithmSpecificInfo");

   stat = asn1PD_utran_AlgorithmSpecificInfo_r4 (pctxt, &pvalue->algorithmSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HeaderCompressionInfoList_r4 (OSCTXT* pctxt, utran_HeaderCompressionInfoList_r4* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HeaderCompressionInfoList-r4");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_HeaderCompressionInfo_r4* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "HeaderCompressionInfo-r4", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_HeaderCompressionInfo_r4, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_HeaderCompressionInfo_r4 (pdata);

      stat = asn1PD_utran_HeaderCompressionInfo_r4 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PDCP_Info_r4 (OSCTXT* pctxt, utran_PDCP_Info_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "PDCP-Info-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode losslessSRNS_RelocSupport */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "losslessSRNS-RelocSupport");

      pvalue->m.losslessSRNS_RelocSupportPresent = 1;

      stat = asn1PD_utran_LosslessSRNS_RelocSupport (pctxt, &pvalue->losslessSRNS_RelocSupport);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pdcp_PDU_Header */
   RTXCTXTPUSHELEMNAME (pctxt, "pdcp-PDU-Header");

   stat = asn1PD_utran_PDCP_PDU_Header (pctxt, &pvalue->pdcp_PDU_Header);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode headerCompressionInfoList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "headerCompressionInfoList");

      pvalue->m.headerCompressionInfoListPresent = 1;

      stat = asn1PD_utran_HeaderCompressionInfoList_r4 (pctxt, &pvalue->headerCompressionInfoList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PDCP_InfoReconfig_r4 (OSCTXT* pctxt, utran_PDCP_InfoReconfig_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDCP-InfoReconfig-r4");

   /* decode root elements */
   /* decode pdcp_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Info");

   stat = asn1PD_utran_PDCP_Info_r4 (pctxt, &pvalue->pdcp_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationReconfig_r4 (OSCTXT* pctxt, utran_RB_InformationReconfig_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationReconfig-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdcp_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Info");

      pvalue->m.pdcp_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_InfoReconfig_r4 (pctxt, &pvalue->pdcp_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pdcp_SN_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-SN-Info");

      pvalue->m.pdcp_SN_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_SN_Info (pctxt, &pvalue->pdcp_SN_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_Info */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlc-Info");

      pvalue->m.rlc_InfoPresent = 1;

      stat = asn1PD_utran_RLC_Info (pctxt, &pvalue->rlc_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_MappingInfo */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

      pvalue->m.rb_MappingInfoPresent = 1;

      stat = asn1PD_utran_RB_MappingInfo (pctxt, &pvalue->rb_MappingInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_StopContinue */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-StopContinue");

      pvalue->m.rb_StopContinuePresent = 1;

      stat = asn1PD_utran_RB_StopContinue (pctxt, &pvalue->rb_StopContinue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationReconfigList_r4 (OSCTXT* pctxt, utran_RB_InformationReconfigList_r4* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationReconfigList-r4");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationReconfig_r4* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationReconfig-r4", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationReconfig_r4, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationReconfig_r4 (pdata);

      stat = asn1PD_utran_RB_InformationReconfig_r4 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CommonTransChInfo_r4_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_UL_CommonTransChInfo_r4_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ul_TFCS */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TFCS");

   stat = asn1PD_utran_TFCS (pctxt, &pvalue->ul_TFCS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CommonTransChInfo_r4_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_UL_CommonTransChInfo_r4_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode individualUL_CCTrCH_InfoList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "individualUL-CCTrCH-InfoList");

      pvalue->m.individualUL_CCTrCH_InfoListPresent = 1;

      stat = asn1PD_utran_IndividualUL_CCTrCH_InfoList (pctxt, &pvalue->individualUL_CCTrCH_InfoList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_CommonTransChInfo_r4_modeSpecificInfo (OSCTXT* pctxt, utran_UL_CommonTransChInfo_r4_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_CommonTransChInfo_r4_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_CommonTransChInfo_r4_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_CommonTransChInfo_r4_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_CommonTransChInfo_r4_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_CommonTransChInfo_r4_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_CommonTransChInfo_r4_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFC_SubsetList_element_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_TFC_SubsetList_element_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tfcs_ID */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tfcs-ID");

      pvalue->m.tfcs_IDPresent = 1;

      stat = asn1PD_utran_TFCS_Identity (pctxt, &pvalue->tfcs_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFC_SubsetList_element_modeSpecificInfo (OSCTXT* pctxt, utran_TFC_SubsetList_element_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_TFC_SubsetList_element_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TFC_SubsetList_element_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_TFC_SubsetList_element_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFC_SubsetList_element (OSCTXT* pctxt, utran_TFC_SubsetList_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_TFC_SubsetList_element_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfc_Subset */
   RTXCTXTPUSHELEMNAME (pctxt, "tfc-Subset");

   stat = asn1PD_utran_TFC_Subset (pctxt, &pvalue->tfc_Subset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TFC_SubsetList (OSCTXT* pctxt, utran_TFC_SubsetList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TFC-SubsetList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_TFC_SubsetList_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_TFC_SubsetList_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_TFC_SubsetList_element (pdata);

      stat = asn1PD_utran_TFC_SubsetList_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CommonTransChInfo_r4 (OSCTXT* pctxt, utran_UL_CommonTransChInfo_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CommonTransChInfo-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tfc_Subset */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tfc-Subset");

      pvalue->m.tfc_SubsetPresent = 1;

      stat = asn1PD_utran_TFC_Subset (pctxt, &pvalue->tfc_Subset);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode prach_TFCS */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "prach-TFCS");

      pvalue->m.prach_TFCSPresent = 1;

      stat = asn1PD_utran_TFCS (pctxt, &pvalue->prach_TFCS);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

      pvalue->m.modeSpecificInfoPresent = 1;

      stat = asn1PD_utran_UL_CommonTransChInfo_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tfc_SubsetList */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tfc-SubsetList");

      pvalue->m.tfc_SubsetListPresent = 1;

      stat = asn1PD_utran_TFC_SubsetList (pctxt, &pvalue->tfc_SubsetList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters_dl_DCH_TFCS (OSCTXT* pctxt, utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters_dl_DCH_TFCS* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tfcs */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tfcs");

      pvalue->m.tfcsPresent = 1;

      stat = asn1PD_utran_TFCS (pctxt, &pvalue->tfcs);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters (OSCTXT* pctxt, utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_DCH_TFCS */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-DCH-TFCS");

         pvalue->u.dl_DCH_TFCS = rtxMemAllocType (pctxt, 
            utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters_dl_DCH_TFCS);

         if (pvalue->u.dl_DCH_TFCS == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters_dl_DCH_TFCS (pvalue->u.dl_DCH_TFCS);

         stat = asn1PD_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters_dl_DCH_TFCS (pctxt, pvalue->u.dl_DCH_TFCS);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sameAsUL */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsUL");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_Parameters */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-Parameters");

      pvalue->m.dl_ParametersPresent = 1;

      stat = asn1PD_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters (pctxt, &pvalue->dl_Parameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_CommonTransChInfo_r4_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode individualDL_CCTrCH_InfoList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "individualDL-CCTrCH-InfoList");

      pvalue->m.individualDL_CCTrCH_InfoListPresent = 1;

      stat = asn1PD_utran_IndividualDL_CCTrCH_InfoList (pctxt, &pvalue->individualDL_CCTrCH_InfoList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonTransChInfo_r4_modeSpecificInfo (OSCTXT* pctxt, utran_DL_CommonTransChInfo_r4_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonTransChInfo_r4_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonTransChInfo_r4 (OSCTXT* pctxt, utran_DL_CommonTransChInfo_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CommonTransChInfo-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode sccpch_TFCS */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sccpch-TFCS");

      pvalue->m.sccpch_TFCSPresent = 1;

      stat = asn1PD_utran_TFCS (pctxt, &pvalue->sccpch_TFCS);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

      pvalue->m.modeSpecificInfoPresent = 1;

      stat = asn1PD_utran_DL_CommonTransChInfo_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation_r4_tfs_SignallingMode (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation_r4_tfs_SignallingMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* explicit_config */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "explicit-config");

         pvalue->u.explicit_config = rtxMemAllocType (pctxt, 
            utran_TransportFormatSet);

         if (pvalue->u.explicit_config == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TransportFormatSet (pvalue->u.explicit_config);

         stat = asn1PD_utran_TransportFormatSet (pctxt, pvalue->u.explicit_config);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sameAsULTrCH */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsULTrCH");

         pvalue->u.sameAsULTrCH = rtxMemAllocTypeZ (pctxt, 
            utran_UL_TransportChannelIdentity);

         if (pvalue->u.sameAsULTrCH == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UL_TransportChannelIdentity (pctxt, pvalue->u.sameAsULTrCH);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation_r4 (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInformation-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TransportChannelType");

   stat = asn1PD_utran_DL_TrCH_Type (pctxt, &pvalue->dl_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_transportChannelIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-transportChannelIdentity");

   stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->dl_transportChannelIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfs_SignallingMode */
   RTXCTXTPUSHELEMNAME (pctxt, "tfs-SignallingMode");

   stat = asn1PD_utran_DL_AddReconfTransChInformation_r4_tfs_SignallingMode (pctxt, &pvalue->tfs_SignallingMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dch_QualityTarget */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dch-QualityTarget");

      pvalue->m.dch_QualityTargetPresent = 1;

      stat = asn1PD_utran_QualityTarget (pctxt, &pvalue->dch_QualityTarget);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInfoList_r4 (OSCTXT* pctxt, utran_DL_AddReconfTransChInfoList_r4* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInfoList-r4");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_AddReconfTransChInformation_r4* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-AddReconfTransChInformation-r4", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_AddReconfTransChInformation_r4, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_AddReconfTransChInformation_r4 (pdata);

      stat = asn1PD_utran_DL_AddReconfTransChInformation_r4 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r4_fdd (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r4_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode dpcch_PowerOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "dpcch-PowerOffset");

   stat = asn1PD_utran_DPCCH_PowerOffset (pctxt, &pvalue->dpcch_PowerOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pc_Preamble */
   RTXCTXTPUSHELEMNAME (pctxt, "pc-Preamble");

   stat = asn1PD_utran_PC_Preamble (pctxt, &pvalue->pc_Preamble);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sRB_delay */
   RTXCTXTPUSHELEMNAME (pctxt, "sRB-delay");

   stat = asn1PD_utran_SRB_delay (pctxt, &pvalue->sRB_delay);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerControlAlgorithm */
   RTXCTXTPUSHELEMNAME (pctxt, "powerControlAlgorithm");

   stat = asn1PD_utran_PowerControlAlgorithm (pctxt, &pvalue->powerControlAlgorithm);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTS_InterferenceList */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTS-InterferenceList");

   stat = asn1PD_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpch_ConstantValue */
   RTXCTXTPUSHELEMNAME (pctxt, "dpch-ConstantValue");

   stat = asn1PD_utran_ConstantValue (pctxt, &pvalue->dpch_ConstantValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tpc_StepSize */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-StepSize");

   stat = asn1PD_utran_TPC_StepSizeTDD (pctxt, &pvalue->tpc_StepSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocTypeZ (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode primaryCCPCH_TX_Power */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCCPCH-TX-Power");

   stat = asn1PD_utran_PrimaryCCPCH_TX_Power (pctxt, &pvalue->primaryCCPCH_TX_Power);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* broadcast_UL_OL_PC_info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "broadcast-UL-OL-PC-info");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* individuallySignalled */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "individuallySignalled");

         pvalue->u.individuallySignalled = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled);

         if (pvalue->u.individuallySignalled == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled (pvalue->u.individuallySignalled);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled (pctxt, pvalue->u.individuallySignalled);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r4_tdd (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r4_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TargetSIR */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TargetSIR");

      pvalue->m.ul_TargetSIRPresent = 1;

      stat = asn1PD_utran_UL_TargetSIR (pctxt, &pvalue->ul_TargetSIR);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_OL_PC_Signalling */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-OL-PC-Signalling");

   stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling (pctxt, &pvalue->ul_OL_PC_Signalling);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r4 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r4* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-PowerControlInfo-r4");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r4_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r4_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r4_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r4_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r4_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r4_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r4_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_UL_DPCH_Info_r4_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode scramblingCodeType */
   RTXCTXTPUSHELEMNAME (pctxt, "scramblingCodeType");

   stat = asn1PD_utran_ScramblingCodeType (pctxt, &pvalue->scramblingCodeType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode scramblingCode */
   RTXCTXTPUSHELEMNAME (pctxt, "scramblingCode");

   stat = asn1PD_utran_UL_ScramblingCode (pctxt, &pvalue->scramblingCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfDPDCH */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfDPDCH");

      stat = asn1PD_utran_NumberOfDPDCH (pctxt, &pvalue->numberOfDPDCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->numberOfDPDCH = 1;
   }

   /* decode spreadingFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactor");

   stat = asn1PD_utran_SpreadingFactor (pctxt, &pvalue->spreadingFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfFBI_Bits */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfFBI-Bits");

      pvalue->m.numberOfFBI_BitsPresent = 1;

      stat = asn1PD_utran_NumberOfFBI_Bits (pctxt, &pvalue->numberOfFBI_Bits);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode puncturingLimit */
   RTXCTXTPUSHELEMNAME (pctxt, "puncturingLimit");

   stat = asn1PD_utran_PuncturingLimit (pctxt, &pvalue->puncturingLimit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd384 (OSCTXT* pctxt, utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd384* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TimingAdvance */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TimingAdvance");

      pvalue->m.ul_TimingAdvancePresent = 1;

      stat = asn1PD_utran_UL_TimingAdvance (pctxt, &pvalue->ul_TimingAdvance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode activationTime */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "activationTime");

      pvalue->m.activationTimePresent = 1;

      stat = asn1PD_utran_ActivationTime (pctxt, &pvalue->activationTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_SynchronisationParameters_r4 (OSCTXT* pctxt, utran_UL_SynchronisationParameters_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-SynchronisationParameters-r4");

   /* decode root elements */
   /* decode stepSize */
   RTXCTXTPUSHELEMNAME (pctxt, "stepSize");

   stat = pd_ConsUInt8 (pctxt, &pvalue->stepSize, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode frequency */
   RTXCTXTPUSHELEMNAME (pctxt, "frequency");

   stat = pd_ConsUInt8 (pctxt, &pvalue->frequency, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SynchronisationParameters_r4_sync_UL_CodesBitmap (OSCTXT* pctxt, utran_SynchronisationParameters_r4_sync_UL_CodesBitmap* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_TDD_FPACH_CCode16_r4 (OSCTXT* pctxt, utran_TDD_FPACH_CCode16_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TDD-FPACH-CCode16-r4");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Wi_LCR (OSCTXT* pctxt, utran_Wi_LCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Wi-LCR");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_FPACH_Info_r4 (OSCTXT* pctxt, utran_FPACH_Info_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FPACH-Info-r4");

   /* decode root elements */
   /* decode timeslot */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslot");

   stat = asn1PD_utran_TimeslotNumber_LCR_r4 (pctxt, &pvalue->timeslot);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode channelisationCode */
   RTXCTXTPUSHELEMNAME (pctxt, "channelisationCode");

   stat = asn1PD_utran_TDD_FPACH_CCode16_r4 (pctxt, &pvalue->channelisationCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleShiftAndBurstType */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_utran_MidambleShiftAndBurstType_LCR_r4 (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode wi */
   RTXCTXTPUSHELEMNAME (pctxt, "wi");

   stat = asn1PD_utran_Wi_LCR (pctxt, &pvalue->wi);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions (OSCTXT* pctxt, utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_SYNC_UL_Procedure_r4 (OSCTXT* pctxt, utran_SYNC_UL_Procedure_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SYNC-UL-Procedure-r4");

   /* decode root elements */
   /* decode max_SYNC_UL_Transmissions */
   RTXCTXTPUSHELEMNAME (pctxt, "max-SYNC-UL-Transmissions");

   stat = asn1PD_utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions (pctxt, &pvalue->max_SYNC_UL_Transmissions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerRampStep */
   RTXCTXTPUSHELEMNAME (pctxt, "powerRampStep");

   stat = pd_ConsUInt8 (pctxt, &pvalue->powerRampStep, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SynchronisationParameters_r4 (OSCTXT* pctxt, utran_SynchronisationParameters_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SynchronisationParameters-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode sync_UL_CodesBitmap */
   RTXCTXTPUSHELEMNAME (pctxt, "sync-UL-CodesBitmap");

   stat = asn1PD_utran_SynchronisationParameters_r4_sync_UL_CodesBitmap (pctxt, &pvalue->sync_UL_CodesBitmap);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode fpach_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "fpach-Info");

   stat = asn1PD_utran_FPACH_Info_r4 (pctxt, &pvalue->fpach_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode prxUpPCHdes */
   RTXCTXTPUSHELEMNAME (pctxt, "prxUpPCHdes");

   stat = pd_ConsUInt8 (pctxt, &pvalue->prxUpPCHdes, OSUINTCONST(0), OSUINTCONST(62));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sync_UL_Procedure */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sync-UL-Procedure");

      pvalue->m.sync_UL_ProcedurePresent = 1;

      stat = asn1PD_utran_SYNC_UL_Procedure_r4 (pctxt, &pvalue->sync_UL_Procedure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd128 (OSCTXT* pctxt, utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_SynchronisationParameters */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-SynchronisationParameters");

      pvalue->m.ul_SynchronisationParametersPresent = 1;

      stat = asn1PD_utran_UL_SynchronisationParameters_r4 (pctxt, &pvalue->ul_SynchronisationParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode synchronisationParameters */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "synchronisationParameters");

      pvalue->m.synchronisationParametersPresent = 1;

      stat = asn1PD_utran_SynchronisationParameters_r4 (pctxt, &pvalue->synchronisationParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl_r4_enabled_tddOption (OSCTXT* pctxt, utran_UL_TimingAdvanceControl_r4_enabled_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl_r4_enabled (OSCTXT* pctxt, utran_UL_TimingAdvanceControl_r4_enabled* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_UL_TimingAdvanceControl_r4_enabled_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl_r4 (OSCTXT* pctxt, utran_UL_TimingAdvanceControl_r4* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-TimingAdvanceControl-r4");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* disabled */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "disabled");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* enabled */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "enabled");

         pvalue->u.enabled = rtxMemAllocType (pctxt, 
            utran_UL_TimingAdvanceControl_r4_enabled);

         if (pvalue->u.enabled == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_TimingAdvanceControl_r4_enabled (pvalue->u.enabled);

         stat = asn1PD_utran_UL_TimingAdvanceControl_r4_enabled (pctxt, pvalue->u.enabled);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CCTrCH_r4_tddOption_tdd384 (OSCTXT* pctxt, utran_UL_CCTrCH_r4_tddOption_tdd384* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_CCTrCH_TimeslotsCodes */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCH-TimeslotsCodes");

      pvalue->m.ul_CCTrCH_TimeslotsCodesPresent = 1;

      stat = asn1PD_utran_UplinkTimeslotsCodes (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_consecutive (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_consecutive* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode numAdditionalTimeslots */
   RTXCTXTPUSHELEMNAME (pctxt, "numAdditionalTimeslots");

   stat = pd_ConsUInt8 (pctxt, &pvalue->numAdditionalTimeslots, OSUINTCONST(1), OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_LCR_r4_parameters_sameAsLast (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_LCR_r4_parameters_sameAsLast* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_LCR_r4_parameters_newParameters (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_LCR_r4_parameters_newParameters* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTimeslotInfo");

   stat = asn1PD_utran_IndividualTimeslotInfo_LCR_r4 (pctxt, &pvalue->individualTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TS_ChannelisationCodeList */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TS-ChannelisationCodeList");

   stat = asn1PD_utran_UL_TS_ChannelisationCodeList (pctxt, &pvalue->ul_TS_ChannelisationCodeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_LCR_r4_parameters (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_LCR_r4_parameters* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* sameAsLast */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsLast");

         pvalue->u.sameAsLast = rtxMemAllocTypeZ (pctxt, 
            utran_UplinkAdditionalTimeslots_LCR_r4_parameters_sameAsLast);

         if (pvalue->u.sameAsLast == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UplinkAdditionalTimeslots_LCR_r4_parameters_sameAsLast (pctxt, pvalue->u.sameAsLast);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* newParameters */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "newParameters");

         pvalue->u.newParameters = rtxMemAllocType (pctxt, 
            utran_UplinkAdditionalTimeslots_LCR_r4_parameters_newParameters);

         if (pvalue->u.newParameters == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UplinkAdditionalTimeslots_LCR_r4_parameters_newParameters (pvalue->u.newParameters);

         stat = asn1PD_utran_UplinkAdditionalTimeslots_LCR_r4_parameters_newParameters (pctxt, pvalue->u.newParameters);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_LCR_r4 (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_LCR_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkAdditionalTimeslots-LCR-r4");

   /* decode root elements */
   /* decode parameters */
   RTXCTXTPUSHELEMNAME (pctxt, "parameters");

   stat = asn1PD_utran_UplinkAdditionalTimeslots_LCR_r4_parameters (pctxt, &pvalue->parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(5), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UplinkAdditionalTimeslots_LCR_r4* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UplinkAdditionalTimeslots-LCR-r4", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UplinkAdditionalTimeslots_LCR_r4, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UplinkAdditionalTimeslots_LCR_r4 (pdata);

      stat = asn1PD_utran_UplinkAdditionalTimeslots_LCR_r4 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* consecutive */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "consecutive");

         pvalue->u.consecutive = rtxMemAllocTypeZ (pctxt, 
            utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_consecutive);

         if (pvalue->u.consecutive == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_consecutive (pctxt, pvalue->u.consecutive);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* timeslotList */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "timeslotList");

         pvalue->u.timeslotList = rtxMemAllocType (pctxt, 
            utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList);

         if (pvalue->u.timeslotList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList (pvalue->u.timeslotList);

         stat = asn1PD_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList (pctxt, pvalue->u.timeslotList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* noMore */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "noMore");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* additionalTimeslots */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "additionalTimeslots");

         pvalue->u.additionalTimeslots = rtxMemAllocType (pctxt, 
            utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots);

         if (pvalue->u.additionalTimeslots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots (pvalue->u.additionalTimeslots);

         stat = asn1PD_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots (pctxt, pvalue->u.additionalTimeslots);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_LCR_r4 (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_LCR_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkTimeslotsCodes-LCR-r4");

   /* decode root elements */
   /* decode dynamicSFusage */
   RTXCTXTPUSHELEMNAME (pctxt, "dynamicSFusage");

   stat = DEC_BIT (pctxt, &pvalue->dynamicSFusage);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode firstIndividualTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "firstIndividualTimeslotInfo");

   stat = asn1PD_utran_IndividualTimeslotInfo_LCR_r4 (pctxt, &pvalue->firstIndividualTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TS_ChannelisationCodeList */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TS-ChannelisationCodeList");

   stat = asn1PD_utran_UL_TS_ChannelisationCodeList (pctxt, &pvalue->ul_TS_ChannelisationCodeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode moreTimeslots */
   RTXCTXTPUSHELEMNAME (pctxt, "moreTimeslots");

   stat = asn1PD_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots (pctxt, &pvalue->moreTimeslots);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CCTrCH_r4_tddOption_tdd128 (OSCTXT* pctxt, utran_UL_CCTrCH_r4_tddOption_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_CCTrCH_TimeslotsCodes */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCH-TimeslotsCodes");

      pvalue->m.ul_CCTrCH_TimeslotsCodesPresent = 1;

      stat = asn1PD_utran_UplinkTimeslotsCodes_LCR_r4 (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_CCTrCH_r4_tddOption (OSCTXT* pctxt, utran_UL_CCTrCH_r4_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_UL_CCTrCH_r4_tddOption_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_CCTrCH_r4_tddOption_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_UL_CCTrCH_r4_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_UL_CCTrCH_r4_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_CCTrCH_r4_tddOption_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_UL_CCTrCH_r4_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_CCTrCH_r4 (OSCTXT* pctxt, utran_UL_CCTrCH_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CCTrCH-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tfcs_ID */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tfcs-ID");

      stat = asn1PD_utran_TFCS_IdentityPlain (pctxt, &pvalue->tfcs_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->tfcs_ID = 1;
   }

   /* decode ul_TargetSIR */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TargetSIR");

   stat = asn1PD_utran_UL_TargetSIR (pctxt, &pvalue->ul_TargetSIR);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "timeInfo");

   stat = asn1PD_utran_TimeInfo (pctxt, &pvalue->timeInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode commonTimeslotInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "commonTimeslotInfo");

      pvalue->m.commonTimeslotInfoPresent = 1;

      stat = asn1PD_utran_CommonTimeslotInfo (pctxt, &pvalue->commonTimeslotInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_UL_CCTrCH_r4_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CCTrCHList_r4 (OSCTXT* pctxt, utran_UL_CCTrCHList_r4* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CCTrCHList-r4");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UL_CCTrCH_r4* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-CCTrCH-r4", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UL_CCTrCH_r4, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UL_CCTrCH_r4 (pdata);

      stat = asn1PD_utran_UL_CCTrCH_r4 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r4_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_UL_DPCH_Info_r4_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TimingAdvance */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TimingAdvance");

      pvalue->m.ul_TimingAdvancePresent = 1;

      stat = asn1PD_utran_UL_TimingAdvanceControl_r4 (pctxt, &pvalue->ul_TimingAdvance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCHList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCHList");

      pvalue->m.ul_CCTrCHListPresent = 1;

      stat = asn1PD_utran_UL_CCTrCHList_r4 (pctxt, &pvalue->ul_CCTrCHList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCHListToRemove */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCHListToRemove");

      pvalue->m.ul_CCTrCHListToRemovePresent = 1;

      stat = asn1PD_utran_UL_CCTrCHListToRemove (pctxt, &pvalue->ul_CCTrCHListToRemove);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r4_modeSpecificInfo (OSCTXT* pctxt, utran_UL_DPCH_Info_r4_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r4_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r4_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_DPCH_Info_r4_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r4_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r4_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_DPCH_Info_r4_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r4 (OSCTXT* pctxt, utran_UL_DPCH_Info_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-Info-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-DPCH-PowerControlInfo");

      pvalue->m.ul_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r4 (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_UL_DPCH_Info_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_ChannelRequirement_r4 (OSCTXT* pctxt, utran_UL_ChannelRequirement_r4* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-ChannelRequirement-r4");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* ul_DPCH_Info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "ul-DPCH-Info");

         pvalue->u.ul_DPCH_Info = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r4);

         if (pvalue->u.ul_DPCH_Info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r4 (pvalue->u.ul_DPCH_Info);

         stat = asn1PD_utran_UL_DPCH_Info_r4 (pctxt, pvalue->u.ul_DPCH_Info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dummy */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dummy");

         pvalue->u.dummy = rtxMemAllocType (pctxt, utran_CPCH_SetInfo);

         if (pvalue->u.dummy == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_CPCH_SetInfo (pvalue->u.dummy);

         stat = asn1PD_utran_CPCH_SetInfo (pctxt, pvalue->u.dummy);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r4_cfnHandling_initialise (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r4_cfnHandling_initialise* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dummy */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy");

      pvalue->m.dummyPresent = 1;

      stat = asn1PD_utran_Cfntargetsfnframeoffset (pctxt, &pvalue->dummy);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r4_cfnHandling (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r4_cfnHandling* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* maintain */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "maintain");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* initialise */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "initialise");

         pvalue->u.initialise = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r4_cfnHandling_initialise);

         if (pvalue->u.initialise == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r4_cfnHandling_initialise (pvalue->u.initialise);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r4_cfnHandling_initialise (pctxt, pvalue->u.initialise);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-PowerControlInfo");

      pvalue->m.dl_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode powerOffsetPilot_pdpdch */
   RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetPilot-pdpdch");

   stat = asn1PD_utran_PowerOffsetPilot_pdpdch (pctxt, &pvalue->powerOffsetPilot_pdpdch);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_rate_matching_restriction */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-rate-matching-restriction");

      pvalue->m.dl_rate_matching_restrictionPresent = 1;

      stat = asn1PD_utran_Dl_rate_matching_restriction (pctxt, &pvalue->dl_rate_matching_restriction);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode spreadingFactorAndPilot */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactorAndPilot");

   stat = asn1PD_utran_SF512_AndPilot (pctxt, &pvalue->spreadingFactorAndPilot);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode positionFixedOrFlexible */
   RTXCTXTPUSHELEMNAME (pctxt, "positionFixedOrFlexible");

   stat = asn1PD_utran_PositionFixedOrFlexible (pctxt, &pvalue->positionFixedOrFlexible);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-PowerControlInfo");

      pvalue->m.dl_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MAC_d_HFN_initial_value (OSCTXT* pctxt, utran_MAC_d_HFN_initial_value* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-d-HFN-initial-value");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(24), OSUINTCONST(24), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(24), OSUINTCONST(24));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r4 (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DPCH-InfoCommon-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cfnHandling */
   RTXCTXTPUSHELEMNAME (pctxt, "cfnHandling");

   stat = asn1PD_utran_DL_DPCH_InfoCommon_r4_cfnHandling (pctxt, &pvalue->cfnHandling);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_d_HFN_initial_value */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-d-HFN-initial-value");

      pvalue->m.mac_d_HFN_initial_valuePresent = 1;

      stat = asn1PD_utran_MAC_d_HFN_initial_value (pctxt, &pvalue->mac_d_HFN_initial_value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SSDT_Information_r4 (OSCTXT* pctxt, utran_SSDT_Information_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SSDT-Information-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode s_Field */
   RTXCTXTPUSHELEMNAME (pctxt, "s-Field");

   stat = asn1PD_utran_S_Field (pctxt, &pvalue->s_Field);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode codeWordSet */
   RTXCTXTPUSHELEMNAME (pctxt, "codeWordSet");

   stat = asn1PD_utran_CodeWordSet (pctxt, &pvalue->codeWordSet);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ssdt_UL_r4 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ssdt-UL-r4");

      pvalue->m.ssdt_UL_r4Present = 1;

      stat = asn1PD_utran_SSDT_UL (pctxt, &pvalue->ssdt_UL_r4);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r4_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_CommonInformation_r4_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueFDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dpch_CompressedModeInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dpch-CompressedModeInfo");

      pvalue->m.dpch_CompressedModeInfoPresent = 1;

      stat = asn1PD_utran_DPCH_CompressedModeInfo (pctxt, &pvalue->dpch_CompressedModeInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tx_DiversityMode */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tx-DiversityMode");

      pvalue->m.tx_DiversityModePresent = 1;

      stat = asn1PD_utran_TX_DiversityMode (pctxt, &pvalue->tx_DiversityMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dummy */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy");

      pvalue->m.dummyPresent = 1;

      stat = asn1PD_utran_SSDT_Information_r4 (pctxt, &pvalue->dummy);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r4_modeSpecificInfo_tdd_tddOption_tdd128 (OSCTXT* pctxt, utran_DL_CommonInformation_r4_modeSpecificInfo_tdd_tddOption_tdd128* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tstd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "tstd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->tstd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r4_modeSpecificInfo_tdd_tddOption (OSCTXT* pctxt, utran_DL_CommonInformation_r4_modeSpecificInfo_tdd_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocTypeZ (pctxt, 
            utran_DL_CommonInformation_r4_modeSpecificInfo_tdd_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_CommonInformation_r4_modeSpecificInfo_tdd_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r4_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_CommonInformation_r4_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_DL_CommonInformation_r4_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueTDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r4_modeSpecificInfo (OSCTXT* pctxt, utran_DL_CommonInformation_r4_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r4_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r4_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_CommonInformation_r4_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r4_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r4_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_CommonInformation_r4_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r4 (OSCTXT* pctxt, utran_DL_CommonInformation_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CommonInformation-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_DPCH_InfoCommon */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoCommon");

      pvalue->m.dl_DPCH_InfoCommonPresent = 1;

      stat = asn1PD_utran_DL_DPCH_InfoCommon_r4 (pctxt, &pvalue->dl_DPCH_InfoCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_CommonInformation_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r4_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r4_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode primaryCPICH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCPICH-Info");

   stat = asn1PD_utran_PrimaryCPICH_Info (pctxt, &pvalue->primaryCPICH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dummy1 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy1");

      pvalue->m.dummy1Present = 1;

      stat = asn1PD_utran_PDSCH_SHO_DCH_Info (pctxt, &pvalue->dummy1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dummy2 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy2");

      pvalue->m.dummy2Present = 1;

      stat = asn1PD_utran_PDSCH_CodeMapping (pctxt, &pvalue->dummy2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info_r4_fdd (OSCTXT* pctxt, utran_PrimaryCCPCH_Info_r4_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tx_DiversityIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "tx-DiversityIndicator");

   stat = DEC_BIT (pctxt, &pvalue->tx_DiversityIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase_syncCase1 (OSCTXT* pctxt, utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase_syncCase1* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslot */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslot");

   stat = asn1PD_utran_TimeslotNumber (pctxt, &pvalue->timeslot);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase_syncCase2 (OSCTXT* pctxt, utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase_syncCase2* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslotSync2 */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotSync2");

   stat = asn1PD_utran_TimeslotSync2 (pctxt, &pvalue->timeslotSync2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase (OSCTXT* pctxt, utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* syncCase1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "syncCase1");

         pvalue->u.syncCase1 = rtxMemAllocTypeZ (pctxt, 
            utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase_syncCase1);

         if (pvalue->u.syncCase1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase_syncCase1 (pctxt, pvalue->u.syncCase1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* syncCase2 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "syncCase2");

         pvalue->u.syncCase2 = rtxMemAllocTypeZ (pctxt, 
            utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase_syncCase2);

         if (pvalue->u.syncCase2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase_syncCase2 (pctxt, pvalue->u.syncCase2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768 (OSCTXT* pctxt, utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode syncCase */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "syncCase");

      pvalue->m.syncCasePresent = 1;

      stat = asn1PD_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase (pctxt, &pvalue->syncCase);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd128 (OSCTXT* pctxt, utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd128* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tstd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "tstd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->tstd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info_r4_tdd_tddOption (OSCTXT* pctxt, utran_PrimaryCCPCH_Info_r4_tdd_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384_tdd768 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384-tdd768");

         pvalue->u.tdd384_tdd768 = rtxMemAllocType (pctxt, 
            utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768);

         if (pvalue->u.tdd384_tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768 (pvalue->u.tdd384_tdd768);

         stat = asn1PD_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768 (pctxt, pvalue->u.tdd384_tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocTypeZ (pctxt, 
            utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info_r4_tdd (OSCTXT* pctxt, utran_PrimaryCCPCH_Info_r4_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_PrimaryCCPCH_Info_r4_tdd_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellParametersID */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellParametersID");

      pvalue->m.cellParametersIDPresent = 1;

      stat = asn1PD_utran_CellParametersID (pctxt, &pvalue->cellParametersID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode sctd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "sctd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->sctd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_Info_r4 (OSCTXT* pctxt, utran_PrimaryCCPCH_Info_r4* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "PrimaryCCPCH-Info-r4");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocTypeZ (pctxt, 
            utran_PrimaryCCPCH_Info_r4_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_PrimaryCCPCH_Info_r4_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_PrimaryCCPCH_Info_r4_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_PrimaryCCPCH_Info_r4_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_PrimaryCCPCH_Info_r4_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r4_modeSpecificInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_r4_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r4_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r4_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_InformationPerRL_r4_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, utran_PrimaryCCPCH_Info_r4);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_PrimaryCCPCH_Info_r4 (pvalue->u.tdd);

         stat = asn1PD_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_r4_fdd (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_r4_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pCPICH_UsageForChannelEst */
   RTXCTXTPUSHELEMNAME (pctxt, "pCPICH-UsageForChannelEst");

   stat = asn1PD_utran_PCPICH_UsageForChannelEst (pctxt, &pvalue->pCPICH_UsageForChannelEst);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpch_FrameOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "dpch-FrameOffset");

   stat = asn1PD_utran_DPCH_FrameOffset (pctxt, &pvalue->dpch_FrameOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode secondaryCPICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "secondaryCPICH-Info");

      pvalue->m.secondaryCPICH_InfoPresent = 1;

      stat = asn1PD_utran_SecondaryCPICH_Info (pctxt, &pvalue->secondaryCPICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_ChannelisationCodeList */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-ChannelisationCodeList");

   stat = asn1PD_utran_DL_ChannelisationCodeList (pctxt, &pvalue->dl_ChannelisationCodeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tpc_CombinationIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-CombinationIndex");

   stat = asn1PD_utran_TPC_CombinationIndex (pctxt, &pvalue->tpc_CombinationIndex);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dummy */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy");

      pvalue->m.dummyPresent = 1;

      stat = asn1PD_utran_SSDT_CellIdentity (pctxt, &pvalue->dummy);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode closedLoopTimingAdjMode */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "closedLoopTimingAdjMode");

      pvalue->m.closedLoopTimingAdjModePresent = 1;

      stat = asn1PD_utran_ClosedLoopTimingAdjMode (pctxt, &pvalue->closedLoopTimingAdjMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_r4_tdd (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_r4_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_CCTrChListToEstablish */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-CCTrChListToEstablish");

      pvalue->m.dl_CCTrChListToEstablishPresent = 1;

      stat = asn1PD_utran_DL_CCTrChList_r4 (pctxt, &pvalue->dl_CCTrChListToEstablish);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_CCTrChListToRemove */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-CCTrChListToRemove");

      pvalue->m.dl_CCTrChListToRemovePresent = 1;

      stat = asn1PD_utran_DL_CCTrChListToRemove (pctxt, &pvalue->dl_CCTrChListToRemove);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_r4 (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_r4* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DPCH-InfoPerRL-r4");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoPerRL_r4_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoPerRL_r4_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_DPCH_InfoPerRL_r4_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoPerRL_r4_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoPerRL_r4_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_DPCH_InfoPerRL_r4_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode secondaryScramblingCode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "secondaryScramblingCode");

      pvalue->m.secondaryScramblingCodePresent = 1;

      stat = asn1PD_utran_SecondaryScramblingCode (pctxt, &pvalue->secondaryScramblingCode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode sttd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "sttd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->sttd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sf_AndCodeNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "sf-AndCodeNumber");

   stat = asn1PD_utran_SF256_AndCodeNumber (pctxt, &pvalue->sf_AndCodeNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pilotSymbolExistence */
   RTXCTXTPUSHELEMNAME (pctxt, "pilotSymbolExistence");

   stat = DEC_BIT (pctxt, &pvalue->pilotSymbolExistence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode positionFixedOrFlexible */
   RTXCTXTPUSHELEMNAME (pctxt, "positionFixedOrFlexible");

   stat = asn1PD_utran_PositionFixedOrFlexible (pctxt, &pvalue->positionFixedOrFlexible);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timingOffset */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timingOffset");

      stat = asn1PD_utran_TimingOffset (pctxt, &pvalue->timingOffset);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->timingOffset = 0;
   }

   return (stat);
}

EXTERN int asn1PD_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd384 (OSCTXT* pctxt, utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd384* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTimeslotInfo");

   stat = asn1PD_utran_IndividualTimeslotInfo (pctxt, &pvalue->individualTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd128 (OSCTXT* pctxt, utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd128* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTimeslotInfo");

   stat = asn1PD_utran_IndividualTimeslotInfo_LCR_r4 (pctxt, &pvalue->individualTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption (OSCTXT* pctxt, utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode commonTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "commonTimeslotInfo");

   stat = asn1PD_utran_CommonTimeslotInfoSCCPCH (pctxt, &pvalue->commonTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode channelisationCode */
   RTXCTXTPUSHELEMNAME (pctxt, "channelisationCode");

   stat = asn1PD_utran_SCCPCH_ChannelisationCodeList (pctxt, &pvalue->channelisationCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo (OSCTXT* pctxt, utran_SecondaryCCPCH_Info_r4_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_SecondaryCCPCH_Info_r4 (OSCTXT* pctxt, utran_SecondaryCCPCH_Info_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecondaryCCPCH-Info-r4");

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode sib_ReferenceListFACH */
   RTXCTXTPUSHELEMNAME (pctxt, "sib-ReferenceListFACH");

   stat = asn1PD_utran_SIB_ReferenceListFACH (pctxt, &pvalue->sib_ReferenceListFACH);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo (OSCTXT* pctxt, utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_SCCPCH_InfoForFACH_r4 (OSCTXT* pctxt, utran_SCCPCH_InfoForFACH_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SCCPCH-InfoForFACH-r4");

   /* decode root elements */
   /* decode secondaryCCPCH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "secondaryCCPCH-Info");

   stat = asn1PD_utran_SecondaryCCPCH_Info_r4 (pctxt, &pvalue->secondaryCCPCH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfcs */
   RTXCTXTPUSHELEMNAME (pctxt, "tfcs");

   stat = asn1PD_utran_TFCS (pctxt, &pvalue->tfcs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode fach_PCH_InformationList */
   RTXCTXTPUSHELEMNAME (pctxt, "fach-PCH-InformationList");

   stat = asn1PD_utran_FACH_PCH_InformationList (pctxt, &pvalue->fach_PCH_InformationList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r4 (OSCTXT* pctxt, utran_DL_InformationPerRL_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_InformationPerRL_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_DPCH_InfoPerRL */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoPerRL");

      pvalue->m.dl_DPCH_InfoPerRLPresent = 1;

      stat = asn1PD_utran_DL_DPCH_InfoPerRL_r4 (pctxt, &pvalue->dl_DPCH_InfoPerRL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dummy */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy");

      pvalue->m.dummyPresent = 1;

      stat = asn1PD_utran_SCCPCH_InfoForFACH_r4 (pctxt, &pvalue->dummy);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cell_id */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cell-id");

      pvalue->m.cell_idPresent = 1;

      stat = asn1PD_utran_CellIdentity (pctxt, &pvalue->cell_id);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_List_r4 (OSCTXT* pctxt, utran_DL_InformationPerRL_List_r4* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-List-r4");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_InformationPerRL_r4* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-InformationPerRL-r4", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_InformationPerRL_r4, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_InformationPerRL_r4 (pdata);

      stat = asn1PD_utran_DL_InformationPerRL_r4 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AM_RLC_Mode_r5 (OSCTXT* pctxt, utran_DL_AM_RLC_Mode_r5* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AM-RLC-Mode-r5");

   /* decode root elements */
   /* decode dl_RLC_PDU_size */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-RLC-PDU-size");

   stat = asn1PD_utran_OctetModeRLC_SizeInfoType1 (pctxt, &pvalue->dl_RLC_PDU_size);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode inSequenceDelivery */
   RTXCTXTPUSHELEMNAME (pctxt, "inSequenceDelivery");

   stat = DEC_BIT (pctxt, &pvalue->inSequenceDelivery);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode receivingWindowSize */
   RTXCTXTPUSHELEMNAME (pctxt, "receivingWindowSize");

   stat = asn1PD_utran_ReceivingWindowSize (pctxt, &pvalue->receivingWindowSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_RLC_StatusInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-RLC-StatusInfo");

   stat = asn1PD_utran_DL_RLC_StatusInfo (pctxt, &pvalue->dl_RLC_StatusInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_UM_RLC_LI_size (OSCTXT* pctxt, utran_DL_UM_RLC_LI_size* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-UM-RLC-LI-size");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_UM_RLC_Mode_r5 (OSCTXT* pctxt, utran_DL_UM_RLC_Mode_r5* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-UM-RLC-Mode-r5");

   /* decode root elements */
   /* decode dl_UM_RLC_LI_size */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-UM-RLC-LI-size");

   stat = asn1PD_utran_DL_UM_RLC_LI_size (pctxt, &pvalue->dl_UM_RLC_LI_size);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_RLC_Mode_r5 (OSCTXT* pctxt, utran_DL_RLC_Mode_r5* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-RLC-Mode-r5");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_AM_RLC_Mode */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-AM-RLC-Mode");

         pvalue->u.dl_AM_RLC_Mode = rtxMemAllocType (pctxt, 
            utran_DL_AM_RLC_Mode_r5);

         if (pvalue->u.dl_AM_RLC_Mode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_AM_RLC_Mode_r5 (pvalue->u.dl_AM_RLC_Mode);

         stat = asn1PD_utran_DL_AM_RLC_Mode_r5 (pctxt, pvalue->u.dl_AM_RLC_Mode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_UM_RLC_Mode */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-UM-RLC-Mode");

         pvalue->u.dl_UM_RLC_Mode = rtxMemAllocTypeZ (pctxt, 
            utran_DL_UM_RLC_Mode_r5);

         if (pvalue->u.dl_UM_RLC_Mode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_UM_RLC_Mode_r5 (pctxt, pvalue->u.dl_UM_RLC_Mode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_TM_RLC_Mode */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-TM-RLC-Mode");

         pvalue->u.dl_TM_RLC_Mode = rtxMemAllocTypeZ (pctxt, 
            utran_DL_TM_RLC_Mode);

         if (pvalue->u.dl_TM_RLC_Mode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_TM_RLC_Mode (pctxt, pvalue->u.dl_TM_RLC_Mode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RLC_Info_r5 (OSCTXT* pctxt, utran_RLC_Info_r5* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RLC-Info-r5");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_RLC_Mode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-RLC-Mode");

      pvalue->m.ul_RLC_ModePresent = 1;

      stat = asn1PD_utran_UL_RLC_Mode (pctxt, &pvalue->ul_RLC_Mode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_RLC_Mode */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-RLC-Mode");

      pvalue->m.dl_RLC_ModePresent = 1;

      stat = asn1PD_utran_DL_RLC_Mode_r5 (pctxt, &pvalue->dl_RLC_Mode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_OneSidedReEst */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-OneSidedReEst");

   stat = DEC_BIT (pctxt, &pvalue->rlc_OneSidedReEst);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_d_FlowIdentity (OSCTXT* pctxt, utran_MAC_d_FlowIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-d-FlowIdentity");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_d_FlowIdentityDCHandHSDSCH (OSCTXT* pctxt, utran_MAC_d_FlowIdentityDCHandHSDSCH* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-d-FlowIdentityDCHandHSDSCH");

   /* decode root elements */
   /* decode dch_transport_ch_id */
   RTXCTXTPUSHELEMNAME (pctxt, "dch-transport-ch-id");

   stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->dch_transport_ch_id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode hsdsch_mac_d_flow_id */
   RTXCTXTPUSHELEMNAME (pctxt, "hsdsch-mac-d-flow-id");

   stat = asn1PD_utran_MAC_d_FlowIdentity (pctxt, &pvalue->hsdsch_mac_d_flow_id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_TransportChannelType_r5 (OSCTXT* pctxt, utran_DL_TransportChannelType_r5* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-TransportChannelType-r5");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dch */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dch");

         stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->u.dch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* fach */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "fach");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dsch */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "dsch");

         stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->u.dsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dch_and_dsch */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "dch-and-dsch");

         pvalue->u.dch_and_dsch = rtxMemAllocTypeZ (pctxt, 
            utran_TransportChannelIdentityDCHandDSCH);

         if (pvalue->u.dch_and_dsch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_TransportChannelIdentityDCHandDSCH (pctxt, pvalue->u.dch_and_dsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* hsdsch */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "hsdsch");

         stat = asn1PD_utran_MAC_d_FlowIdentity (pctxt, &pvalue->u.hsdsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dch_and_hsdsch */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "dch-and-hsdsch");

         pvalue->u.dch_and_hsdsch = rtxMemAllocTypeZ (pctxt, 
            utran_MAC_d_FlowIdentityDCHandHSDSCH);

         if (pvalue->u.dch_and_hsdsch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_MAC_d_FlowIdentityDCHandHSDSCH (pctxt, pvalue->u.dch_and_hsdsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_LogicalChannelMapping_r5 (OSCTXT* pctxt, utran_DL_LogicalChannelMapping_r5* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-LogicalChannelMapping-r5");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TransportChannelType");

   stat = asn1PD_utran_DL_TransportChannelType_r5 (pctxt, &pvalue->dl_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode logicalChannelIdentity */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelIdentity");

      pvalue->m.logicalChannelIdentityPresent = 1;

      stat = asn1PD_utran_LogicalChannelIdentity (pctxt, &pvalue->logicalChannelIdentity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_LogicalChannelMappingList_r5 (OSCTXT* pctxt, utran_DL_LogicalChannelMappingList_r5* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-LogicalChannelMappingList-r5");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_LogicalChannelMapping_r5* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-LogicalChannelMapping-r5", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_LogicalChannelMapping_r5, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_LogicalChannelMapping_r5 (pdata);

      stat = asn1PD_utran_DL_LogicalChannelMapping_r5 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_MappingOption_r5 (OSCTXT* pctxt, utran_RB_MappingOption_r5* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-MappingOption-r5");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_LogicalChannelMappings */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-LogicalChannelMappings");

      pvalue->m.ul_LogicalChannelMappingsPresent = 1;

      stat = asn1PD_utran_UL_LogicalChannelMappings (pctxt, &pvalue->ul_LogicalChannelMappings);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_LogicalChannelMappingList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-LogicalChannelMappingList");

      pvalue->m.dl_LogicalChannelMappingListPresent = 1;

      stat = asn1PD_utran_DL_LogicalChannelMappingList_r5 (pctxt, &pvalue->dl_LogicalChannelMappingList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_MappingInfo_r5 (OSCTXT* pctxt, utran_RB_MappingInfo_r5* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-MappingInfo-r5");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_MappingOption_r5* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-MappingOption-r5", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_MappingOption_r5, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_MappingOption_r5 (pdata);

      stat = asn1PD_utran_RB_MappingOption_r5 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationReconfig_r5 (OSCTXT* pctxt, utran_RB_InformationReconfig_r5* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationReconfig-r5");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdcp_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Info");

      pvalue->m.pdcp_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_InfoReconfig_r4 (pctxt, &pvalue->pdcp_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pdcp_SN_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-SN-Info");

      pvalue->m.pdcp_SN_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_SN_Info (pctxt, &pvalue->pdcp_SN_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_Info */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlc-Info");

      pvalue->m.rlc_InfoPresent = 1;

      stat = asn1PD_utran_RLC_Info_r5 (pctxt, &pvalue->rlc_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_MappingInfo */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

      pvalue->m.rb_MappingInfoPresent = 1;

      stat = asn1PD_utran_RB_MappingInfo_r5 (pctxt, &pvalue->rb_MappingInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_StopContinue */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-StopContinue");

      pvalue->m.rb_StopContinuePresent = 1;

      stat = asn1PD_utran_RB_StopContinue (pctxt, &pvalue->rb_StopContinue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationReconfigList_r5 (OSCTXT* pctxt, utran_RB_InformationReconfigList_r5* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationReconfigList-r5");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationReconfig_r5* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationReconfig-r5", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationReconfig_r5, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationReconfig_r5 (pdata);

      stat = asn1PD_utran_RB_InformationReconfig_r5 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationAffected_r5 (OSCTXT* pctxt, utran_RB_InformationAffected_r5* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationAffected-r5");

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_MappingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

   stat = asn1PD_utran_RB_MappingInfo_r5 (pctxt, &pvalue->rb_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationAffectedList_r5 (OSCTXT* pctxt, utran_RB_InformationAffectedList_r5* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationAffectedList-r5");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationAffected_r5* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationAffected-r5", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationAffected_r5, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationAffected_r5 (pdata);

      stat = asn1PD_utran_RB_InformationAffected_r5 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_PDCPContextRelocation (OSCTXT* pctxt, utran_RB_PDCPContextRelocation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-PDCPContextRelocation");

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_RFC3095_Context_Relocation */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-RFC3095-Context-Relocation");

   stat = DEC_BIT (pctxt, &pvalue->dl_RFC3095_Context_Relocation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_RFC3095_Context_Relocation */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-RFC3095-Context-Relocation");

   stat = DEC_BIT (pctxt, &pvalue->ul_RFC3095_Context_Relocation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_PDCPContextRelocationList (OSCTXT* pctxt, utran_RB_PDCPContextRelocationList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-PDCPContextRelocationList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(27), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_PDCPContextRelocation* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-PDCPContextRelocation", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_PDCPContextRelocation, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_RB_PDCPContextRelocation (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CounterSynchronisationInfo_r5 (OSCTXT* pctxt, utran_DL_CounterSynchronisationInfo_r5* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CounterSynchronisationInfo-r5");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_WithPDCP_InfoList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-WithPDCP-InfoList");

      pvalue->m.rb_WithPDCP_InfoListPresent = 1;

      stat = asn1PD_utran_RB_WithPDCP_InfoList (pctxt, &pvalue->rb_WithPDCP_InfoList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_PDCPContextRelocationList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-PDCPContextRelocationList");

      pvalue->m.rb_PDCPContextRelocationListPresent = 1;

      stat = asn1PD_utran_RB_PDCPContextRelocationList (pctxt, &pvalue->rb_PDCPContextRelocationList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_TrCH_TypeId2_r5 (OSCTXT* pctxt, utran_DL_TrCH_TypeId2_r5* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-TrCH-TypeId2-r5");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dch */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dch");

         stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->u.dch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dsch */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dsch");

         stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->u.dsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* hsdsch */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "hsdsch");

         stat = asn1PD_utran_MAC_d_FlowIdentity (pctxt, &pvalue->u.hsdsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_TransportChannelIdentity_r5 (OSCTXT* pctxt, utran_DL_TransportChannelIdentity_r5* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-TransportChannelIdentity-r5");

   /* decode root elements */
   /* decode dl_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TransportChannelType");

   stat = asn1PD_utran_DL_TrCH_TypeId2_r5 (pctxt, &pvalue->dl_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DeletedTransChInfoList_r5 (OSCTXT* pctxt, utran_DL_DeletedTransChInfoList_r5* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DeletedTransChInfoList-r5");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_TransportChannelIdentity_r5* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-TransportChannelIdentity-r5", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_TransportChannelIdentity_r5, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_TransportChannelIdentity_r5 (pdata);

      stat = asn1PD_utran_DL_TransportChannelIdentity_r5 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_TrCH_TypeId1_r5 (OSCTXT* pctxt, utran_DL_TrCH_TypeId1_r5* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-TrCH-TypeId1-r5");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dch */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dch");

         stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->u.dch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dsch */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dsch");

         stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->u.dsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* hsdsch */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "hsdsch");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_T1_ReleaseTimer (OSCTXT* pctxt, utran_T1_ReleaseTimer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "T1-ReleaseTimer");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_hs_WindowSize (OSCTXT* pctxt, utran_MAC_hs_WindowSize* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-hs-WindowSize");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_d_PDUsizeInfo (OSCTXT* pctxt, utran_MAC_d_PDUsizeInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-d-PDUsizeInfo");

   /* decode root elements */
   /* decode mac_d_PDU_Size */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-d-PDU-Size");

   stat = pd_ConsUInt16 (pctxt, &pvalue->mac_d_PDU_Size, OSUINTCONST(1), OSUINTCONST(5000));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_d_PDU_Index */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-d-PDU-Index");

   stat = pd_ConsUInt8 (pctxt, &pvalue->mac_d_PDU_Index, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_d_PDU_SizeInfo_List (OSCTXT* pctxt, utran_MAC_d_PDU_SizeInfo_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-d-PDU-SizeInfo-List");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_MAC_d_PDUsizeInfo* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MAC-d-PDUsizeInfo", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_MAC_d_PDUsizeInfo, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_MAC_d_PDUsizeInfo (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_hs_AddReconfQueue (OSCTXT* pctxt, utran_MAC_hs_AddReconfQueue* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-hs-AddReconfQueue");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_hsQueueId */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-hsQueueId");

   stat = pd_ConsUInt8 (pctxt, &pvalue->mac_hsQueueId, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_dFlowId */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-dFlowId");

   stat = asn1PD_utran_MAC_d_FlowIdentity (pctxt, &pvalue->mac_dFlowId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reorderingReleaseTimer */
   RTXCTXTPUSHELEMNAME (pctxt, "reorderingReleaseTimer");

   stat = asn1PD_utran_T1_ReleaseTimer (pctxt, &pvalue->reorderingReleaseTimer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_hsWindowSize */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-hsWindowSize");

   stat = asn1PD_utran_MAC_hs_WindowSize (pctxt, &pvalue->mac_hsWindowSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_d_PDU_SizeInfo_List */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-d-PDU-SizeInfo-List");

      pvalue->m.mac_d_PDU_SizeInfo_ListPresent = 1;

      stat = asn1PD_utran_MAC_d_PDU_SizeInfo_List (pctxt, &pvalue->mac_d_PDU_SizeInfo_List);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_hs_AddReconfQueue_List (OSCTXT* pctxt, utran_MAC_hs_AddReconfQueue_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-hs-AddReconfQueue-List");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_MAC_hs_AddReconfQueue* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MAC-hs-AddReconfQueue", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_MAC_hs_AddReconfQueue, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_MAC_hs_AddReconfQueue (pdata);

      stat = asn1PD_utran_MAC_hs_AddReconfQueue (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_hs_DelQueue (OSCTXT* pctxt, utran_MAC_hs_DelQueue* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-hs-DelQueue");

   /* decode root elements */
   /* decode mac_hsQueueId */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-hsQueueId");

   stat = pd_ConsUInt8 (pctxt, &pvalue->mac_hsQueueId, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_hs_DelQueue_List (OSCTXT* pctxt, utran_MAC_hs_DelQueue_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-hs-DelQueue-List");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_MAC_hs_DelQueue* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MAC-hs-DelQueue", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_MAC_hs_DelQueue, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_MAC_hs_DelQueue (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AddOrReconfMAC_dFlow (OSCTXT* pctxt, utran_AddOrReconfMAC_dFlow* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "AddOrReconfMAC-dFlow");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_hs_AddReconfQueue_List */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-hs-AddReconfQueue-List");

      pvalue->m.mac_hs_AddReconfQueue_ListPresent = 1;

      stat = asn1PD_utran_MAC_hs_AddReconfQueue_List (pctxt, &pvalue->mac_hs_AddReconfQueue_List);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mac_hs_DelQueue_List */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-hs-DelQueue-List");

      pvalue->m.mac_hs_DelQueue_ListPresent = 1;

      stat = asn1PD_utran_MAC_hs_DelQueue_List (pctxt, &pvalue->mac_hs_DelQueue_List);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HSDSCH_Info (OSCTXT* pctxt, utran_HSDSCH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "HSDSCH-Info");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode harqInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "harqInfo");

      pvalue->m.harqInfoPresent = 1;

      stat = asn1PD_utran_HARQ_Info (pctxt, &pvalue->harqInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode addOrReconfMAC_dFlow */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "addOrReconfMAC-dFlow");

      pvalue->m.addOrReconfMAC_dFlowPresent = 1;

      stat = asn1PD_utran_AddOrReconfMAC_dFlow (pctxt, &pvalue->addOrReconfMAC_dFlow);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation_r5_tfs_SignallingMode (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation_r5_tfs_SignallingMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* explicit_config */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "explicit-config");

         pvalue->u.explicit_config = rtxMemAllocType (pctxt, 
            utran_TransportFormatSet);

         if (pvalue->u.explicit_config == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TransportFormatSet (pvalue->u.explicit_config);

         stat = asn1PD_utran_TransportFormatSet (pctxt, pvalue->u.explicit_config);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sameAsULTrCH */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsULTrCH");

         pvalue->u.sameAsULTrCH = rtxMemAllocTypeZ (pctxt, 
            utran_UL_TransportChannelIdentity);

         if (pvalue->u.sameAsULTrCH == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UL_TransportChannelIdentity (pctxt, pvalue->u.sameAsULTrCH);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* hsdsch */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "hsdsch");

         pvalue->u.hsdsch = rtxMemAllocType (pctxt, utran_HSDSCH_Info);

         if (pvalue->u.hsdsch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_HSDSCH_Info (pvalue->u.hsdsch);

         stat = asn1PD_utran_HSDSCH_Info (pctxt, pvalue->u.hsdsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation_r5 (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation_r5* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInformation-r5");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TransportChannelType");

   stat = asn1PD_utran_DL_TrCH_TypeId1_r5 (pctxt, &pvalue->dl_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfs_SignallingMode */
   RTXCTXTPUSHELEMNAME (pctxt, "tfs-SignallingMode");

   stat = asn1PD_utran_DL_AddReconfTransChInformation_r5_tfs_SignallingMode (pctxt, &pvalue->tfs_SignallingMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dch_QualityTarget */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dch-QualityTarget");

      pvalue->m.dch_QualityTargetPresent = 1;

      stat = asn1PD_utran_QualityTarget (pctxt, &pvalue->dch_QualityTarget);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInfoList_r5 (OSCTXT* pctxt, utran_DL_AddReconfTransChInfoList_r5* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInfoList-r5");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_AddReconfTransChInformation_r5* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-AddReconfTransChInformation-r5", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_AddReconfTransChInformation_r5, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_AddReconfTransChInformation_r5 (pdata);

      stat = asn1PD_utran_DL_AddReconfTransChInformation_r5 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ACK_NACK_repetitionFactor (OSCTXT* pctxt, utran_ACK_NACK_repetitionFactor* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ACK-NACK-repetitionFactor");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r5_fdd (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r5_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dpcch_PowerOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "dpcch-PowerOffset");

   stat = asn1PD_utran_DPCCH_PowerOffset (pctxt, &pvalue->dpcch_PowerOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pc_Preamble */
   RTXCTXTPUSHELEMNAME (pctxt, "pc-Preamble");

   stat = asn1PD_utran_PC_Preamble (pctxt, &pvalue->pc_Preamble);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sRB_delay */
   RTXCTXTPUSHELEMNAME (pctxt, "sRB-delay");

   stat = asn1PD_utran_SRB_delay (pctxt, &pvalue->sRB_delay);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerControlAlgorithm */
   RTXCTXTPUSHELEMNAME (pctxt, "powerControlAlgorithm");

   stat = asn1PD_utran_PowerControlAlgorithm (pctxt, &pvalue->powerControlAlgorithm);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaACK */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaACK");

      pvalue->m.deltaACKPresent = 1;

      stat = asn1PD_utran_DeltaACK (pctxt, &pvalue->deltaACK);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode deltaNACK */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaNACK");

      pvalue->m.deltaNACKPresent = 1;

      stat = asn1PD_utran_DeltaNACK (pctxt, &pvalue->deltaNACK);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ack_NACK_repetition_factor */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ack-NACK-repetition-factor");

      pvalue->m.ack_NACK_repetition_factorPresent = 1;

      stat = asn1PD_utran_ACK_NACK_repetitionFactor (pctxt, &pvalue->ack_NACK_repetition_factor);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTS_InterferenceList */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTS-InterferenceList");

   stat = asn1PD_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpch_ConstantValue */
   RTXCTXTPUSHELEMNAME (pctxt, "dpch-ConstantValue");

   stat = asn1PD_utran_ConstantValue (pctxt, &pvalue->dpch_ConstantValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tpc_StepSize */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-StepSize");

   stat = asn1PD_utran_TPC_StepSizeTDD (pctxt, &pvalue->tpc_StepSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocTypeZ (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode primaryCCPCH_TX_Power */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCCPCH-TX-Power");

   stat = asn1PD_utran_PrimaryCCPCH_TX_Power (pctxt, &pvalue->primaryCCPCH_TX_Power);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* broadcast_UL_OL_PC_info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "broadcast-UL-OL-PC-info");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* individuallySignalled */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "individuallySignalled");

         pvalue->u.individuallySignalled = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled);

         if (pvalue->u.individuallySignalled == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled (pvalue->u.individuallySignalled);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled (pctxt, pvalue->u.individuallySignalled);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r5_tdd (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r5_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TargetSIR */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TargetSIR");

      pvalue->m.ul_TargetSIRPresent = 1;

      stat = asn1PD_utran_UL_TargetSIR (pctxt, &pvalue->ul_TargetSIR);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_OL_PC_Signalling */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-OL-PC-Signalling");

   stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling (pctxt, &pvalue->ul_OL_PC_Signalling);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r5 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r5* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-PowerControlInfo-r5");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r5_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r5_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r5_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r5_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r5_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r5_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r5_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_UL_DPCH_Info_r5_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode scramblingCodeType */
   RTXCTXTPUSHELEMNAME (pctxt, "scramblingCodeType");

   stat = asn1PD_utran_ScramblingCodeType (pctxt, &pvalue->scramblingCodeType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode scramblingCode */
   RTXCTXTPUSHELEMNAME (pctxt, "scramblingCode");

   stat = asn1PD_utran_UL_ScramblingCode (pctxt, &pvalue->scramblingCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfDPDCH */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfDPDCH");

      stat = asn1PD_utran_NumberOfDPDCH (pctxt, &pvalue->numberOfDPDCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->numberOfDPDCH = 1;
   }

   /* decode spreadingFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactor");

   stat = asn1PD_utran_SpreadingFactor (pctxt, &pvalue->spreadingFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfFBI_Bits */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfFBI-Bits");

      pvalue->m.numberOfFBI_BitsPresent = 1;

      stat = asn1PD_utran_NumberOfFBI_Bits (pctxt, &pvalue->numberOfFBI_Bits);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode puncturingLimit */
   RTXCTXTPUSHELEMNAME (pctxt, "puncturingLimit");

   stat = asn1PD_utran_PuncturingLimit (pctxt, &pvalue->puncturingLimit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r5_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_UL_DPCH_Info_r5_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TimingAdvance */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TimingAdvance");

      pvalue->m.ul_TimingAdvancePresent = 1;

      stat = asn1PD_utran_UL_TimingAdvanceControl_r4 (pctxt, &pvalue->ul_TimingAdvance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCHList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCHList");

      pvalue->m.ul_CCTrCHListPresent = 1;

      stat = asn1PD_utran_UL_CCTrCHList_r4 (pctxt, &pvalue->ul_CCTrCHList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCHListToRemove */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCHListToRemove");

      pvalue->m.ul_CCTrCHListToRemovePresent = 1;

      stat = asn1PD_utran_UL_CCTrCHListToRemove (pctxt, &pvalue->ul_CCTrCHListToRemove);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r5_modeSpecificInfo (OSCTXT* pctxt, utran_UL_DPCH_Info_r5_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r5_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r5_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_DPCH_Info_r5_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r5_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r5_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_DPCH_Info_r5_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r5 (OSCTXT* pctxt, utran_UL_DPCH_Info_r5* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-Info-r5");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-DPCH-PowerControlInfo");

      pvalue->m.ul_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r5 (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_UL_DPCH_Info_r5_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_ChannelRequirement_r5 (OSCTXT* pctxt, utran_UL_ChannelRequirement_r5* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-ChannelRequirement-r5");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* ul_DPCH_Info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "ul-DPCH-Info");

         pvalue->u.ul_DPCH_Info = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r5);

         if (pvalue->u.ul_DPCH_Info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r5 (pvalue->u.ul_DPCH_Info);

         stat = asn1PD_utran_UL_DPCH_Info_r5 (pctxt, pvalue->u.ul_DPCH_Info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dummy */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dummy");

         pvalue->u.dummy = rtxMemAllocType (pctxt, utran_CPCH_SetInfo);

         if (pvalue->u.dummy == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_CPCH_SetInfo (pvalue->u.dummy);

         stat = asn1PD_utran_CPCH_SetInfo (pctxt, pvalue->u.dummy);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r5_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_CommonInformation_r5_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueFDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dpch_CompressedModeInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dpch-CompressedModeInfo");

      pvalue->m.dpch_CompressedModeInfoPresent = 1;

      stat = asn1PD_utran_DPCH_CompressedModeInfo (pctxt, &pvalue->dpch_CompressedModeInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tx_DiversityMode */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tx-DiversityMode");

      pvalue->m.tx_DiversityModePresent = 1;

      stat = asn1PD_utran_TX_DiversityMode (pctxt, &pvalue->tx_DiversityMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dummy */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy");

      pvalue->m.dummyPresent = 1;

      stat = asn1PD_utran_SSDT_Information_r4 (pctxt, &pvalue->dummy);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r5_modeSpecificInfo_tdd_tddOption_tdd128 (OSCTXT* pctxt, utran_DL_CommonInformation_r5_modeSpecificInfo_tdd_tddOption_tdd128* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tstd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "tstd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->tstd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r5_modeSpecificInfo_tdd_tddOption (OSCTXT* pctxt, utran_DL_CommonInformation_r5_modeSpecificInfo_tdd_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocTypeZ (pctxt, 
            utran_DL_CommonInformation_r5_modeSpecificInfo_tdd_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_CommonInformation_r5_modeSpecificInfo_tdd_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r5_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_CommonInformation_r5_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_DL_CommonInformation_r5_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueTDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r5_modeSpecificInfo (OSCTXT* pctxt, utran_DL_CommonInformation_r5_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r5_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r5_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_CommonInformation_r5_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r5_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r5_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_CommonInformation_r5_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r5_mac_hsResetIndicator (OSCTXT* pctxt, utran_DL_CommonInformation_r5_mac_hsResetIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__264; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r5 (OSCTXT* pctxt, utran_DL_CommonInformation_r5* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CommonInformation-r5");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_DPCH_InfoCommon */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoCommon");

      pvalue->m.dl_DPCH_InfoCommonPresent = 1;

      stat = asn1PD_utran_DL_DPCH_InfoCommon_r4 (pctxt, &pvalue->dl_DPCH_InfoCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_CommonInformation_r5_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_hsResetIndicator */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-hsResetIndicator");

      pvalue->m.mac_hsResetIndicatorPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r5_mac_hsResetIndicator (pctxt, &pvalue->mac_hsResetIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r5_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r5_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode primaryCPICH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCPICH-Info");

   stat = asn1PD_utran_PrimaryCPICH_Info (pctxt, &pvalue->primaryCPICH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dummy1 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy1");

      pvalue->m.dummy1Present = 1;

      stat = asn1PD_utran_PDSCH_SHO_DCH_Info (pctxt, &pvalue->dummy1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dummy2 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy2");

      pvalue->m.dummy2Present = 1;

      stat = asn1PD_utran_PDSCH_CodeMapping (pctxt, &pvalue->dummy2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode servingHSDSCH_RL_indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "servingHSDSCH-RL-indicator");

   stat = DEC_BIT (pctxt, &pvalue->servingHSDSCH_RL_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r5_modeSpecificInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_r5_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r5_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r5_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_InformationPerRL_r5_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, utran_PrimaryCCPCH_Info_r4);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_PrimaryCCPCH_Info_r4 (pvalue->u.tdd);

         stat = asn1PD_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r5 (OSCTXT* pctxt, utran_DL_InformationPerRL_r5* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-r5");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_InformationPerRL_r5_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_DPCH_InfoPerRL */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoPerRL");

      pvalue->m.dl_DPCH_InfoPerRLPresent = 1;

      stat = asn1PD_utran_DL_DPCH_InfoPerRL_r5 (pctxt, &pvalue->dl_DPCH_InfoPerRL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dummy */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy");

      pvalue->m.dummyPresent = 1;

      stat = asn1PD_utran_SCCPCH_InfoForFACH_r4 (pctxt, &pvalue->dummy);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cell_id */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cell-id");

      pvalue->m.cell_idPresent = 1;

      stat = asn1PD_utran_CellIdentity (pctxt, &pvalue->cell_id);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_List_r5 (OSCTXT* pctxt, utran_DL_InformationPerRL_List_r5* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-List-r5");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_InformationPerRL_r5* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-InformationPerRL-r5", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_InformationPerRL_r5, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_InformationPerRL_r5 (pdata);

      stat = asn1PD_utran_DL_InformationPerRL_r5 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_Reception_Window_Size_r6 (OSCTXT* pctxt, utran_DL_Reception_Window_Size_r6* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-Reception-Window-Size-r6");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_UM_RLC_Mode_r6 (OSCTXT* pctxt, utran_DL_UM_RLC_Mode_r6* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-UM-RLC-Mode-r6");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_UM_RLC_LI_size */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-UM-RLC-LI-size");

   stat = asn1PD_utran_DL_UM_RLC_LI_size (pctxt, &pvalue->dl_UM_RLC_LI_size);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_Reception_Window_Size */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-Reception-Window-Size");

      pvalue->m.dl_Reception_Window_SizePresent = 1;

      stat = asn1PD_utran_DL_Reception_Window_Size_r6 (pctxt, &pvalue->dl_Reception_Window_Size);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_RLC_Mode_r6 (OSCTXT* pctxt, utran_DL_RLC_Mode_r6* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-RLC-Mode-r6");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_AM_RLC_Mode */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-AM-RLC-Mode");

         pvalue->u.dl_AM_RLC_Mode = rtxMemAllocType (pctxt, 
            utran_DL_AM_RLC_Mode_r5);

         if (pvalue->u.dl_AM_RLC_Mode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_AM_RLC_Mode_r5 (pvalue->u.dl_AM_RLC_Mode);

         stat = asn1PD_utran_DL_AM_RLC_Mode_r5 (pctxt, pvalue->u.dl_AM_RLC_Mode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_UM_RLC_Mode */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-UM-RLC-Mode");

         pvalue->u.dl_UM_RLC_Mode = rtxMemAllocType (pctxt, 
            utran_DL_UM_RLC_Mode_r6);

         if (pvalue->u.dl_UM_RLC_Mode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_UM_RLC_Mode_r6 (pvalue->u.dl_UM_RLC_Mode);

         stat = asn1PD_utran_DL_UM_RLC_Mode_r6 (pctxt, pvalue->u.dl_UM_RLC_Mode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_TM_RLC_Mode */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-TM-RLC-Mode");

         pvalue->u.dl_TM_RLC_Mode = rtxMemAllocTypeZ (pctxt, 
            utran_DL_TM_RLC_Mode);

         if (pvalue->u.dl_TM_RLC_Mode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_TM_RLC_Mode (pctxt, pvalue->u.dl_TM_RLC_Mode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RLC_Info_r6_altE_bitInterpretation (OSCTXT* pctxt, utran_RLC_Info_r6_altE_bitInterpretation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__257; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_RLC_Info_r6 (OSCTXT* pctxt, utran_RLC_Info_r6* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "RLC-Info-r6");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_RLC_Mode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-RLC-Mode");

      pvalue->m.ul_RLC_ModePresent = 1;

      stat = asn1PD_utran_UL_RLC_Mode (pctxt, &pvalue->ul_RLC_Mode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_RLC_Mode */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-RLC-Mode");

      pvalue->m.dl_RLC_ModePresent = 1;

      stat = asn1PD_utran_DL_RLC_Mode_r6 (pctxt, &pvalue->dl_RLC_Mode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_OneSidedReEst */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-OneSidedReEst");

   stat = DEC_BIT (pctxt, &pvalue->rlc_OneSidedReEst);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode altE_bitInterpretation */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "altE-bitInterpretation");

      pvalue->m.altE_bitInterpretationPresent = 1;

      stat = asn1PD_utran_RLC_Info_r6_altE_bitInterpretation (pctxt, &pvalue->altE_bitInterpretation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch_rlc_SizeList (OSCTXT* pctxt, utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch_rlc_SizeList* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* allSizes */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "allSizes");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* configured */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "configured");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* explicitList */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "explicitList");

         pvalue->u.explicitList = rtxMemAllocType (pctxt, 
            utran_RLC_SizeExplicitList);

         if (pvalue->u.explicitList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_RLC_SizeExplicitList (pvalue->u.explicitList);

         stat = asn1PD_utran_RLC_SizeExplicitList (pctxt, pvalue->u.explicitList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch (OSCTXT* pctxt, utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TransportChannelType");

   stat = asn1PD_utran_UL_TransportChannelType (pctxt, &pvalue->ul_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode logicalChannelIdentity */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelIdentity");

      pvalue->m.logicalChannelIdentityPresent = 1;

      stat = asn1PD_utran_LogicalChannelIdentity (pctxt, &pvalue->logicalChannelIdentity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_SizeList */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-SizeList");

   stat = asn1PD_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch_rlc_SizeList (pctxt, &pvalue->rlc_SizeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_MAC_d_FlowIdentity (OSCTXT* pctxt, utran_E_DCH_MAC_d_FlowIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-MAC-d-FlowIdentity");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DDI (OSCTXT* pctxt, utran_DDI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DDI");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(62));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RLC_PDU_Size (OSCTXT* pctxt, utran_RLC_PDU_Size* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RLC-PDU-Size");

   stat = asn1PD_utran_OctetModeRLC_SizeInfoType1 (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RLC_PDU_SizeList (OSCTXT* pctxt, utran_RLC_PDU_SizeList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RLC-PDU-SizeList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RLC_PDU_Size* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RLC-PDU-Size", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RLC_PDU_Size, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RLC_PDU_Size (pdata);

      stat = asn1PD_utran_RLC_PDU_Size (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_e_dch (OSCTXT* pctxt, utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_e_dch* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode logicalChannelIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelIdentity");

   stat = asn1PD_utran_LogicalChannelIdentity (pctxt, &pvalue->logicalChannelIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_DCH_MAC_d_FlowIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "e-DCH-MAC-d-FlowIdentity");

   stat = asn1PD_utran_E_DCH_MAC_d_FlowIdentity (pctxt, &pvalue->e_DCH_MAC_d_FlowIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ddi */
   RTXCTXTPUSHELEMNAME (pctxt, "ddi");

   stat = asn1PD_utran_DDI (pctxt, &pvalue->ddi);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rlc_PDU_SizeList */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-PDU-SizeList");

   stat = asn1PD_utran_RLC_PDU_SizeList (pctxt, &pvalue->rlc_PDU_SizeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode includeInSchedulingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "includeInSchedulingInfo");

   stat = DEC_BIT (pctxt, &pvalue->includeInSchedulingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type (OSCTXT* pctxt, utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dch_rach_usch */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dch-rach-usch");

         pvalue->u.dch_rach_usch = rtxMemAllocType (pctxt, 
            utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch);

         if (pvalue->u.dch_rach_usch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch (pvalue->u.dch_rach_usch);

         stat = asn1PD_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch (pctxt, pvalue->u.dch_rach_usch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* e_dch */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "e-dch");

         pvalue->u.e_dch = rtxMemAllocType (pctxt, 
            utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_e_dch);

         if (pvalue->u.e_dch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_e_dch (pvalue->u.e_dch);

         stat = asn1PD_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_e_dch (pctxt, pvalue->u.e_dch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMapping_r6 (OSCTXT* pctxt, utran_UL_LogicalChannelMapping_r6* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-LogicalChannelMapping-r6");

   /* decode root elements */
   /* decode ul_TrCH_Type */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TrCH-Type");

   stat = asn1PD_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type (pctxt, &pvalue->ul_TrCH_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_LogicalChannelPriority */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-LogicalChannelPriority");

   stat = asn1PD_utran_MAC_LogicalChannelPriority (pctxt, &pvalue->mac_LogicalChannelPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMappingList_r6_ul_LogicalChannelMapping (OSCTXT* pctxt, utran_UL_LogicalChannelMappingList_r6_ul_LogicalChannelMapping* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UL_LogicalChannelMapping_r6* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-LogicalChannelMapping-r6", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UL_LogicalChannelMapping_r6, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UL_LogicalChannelMapping_r6 (pdata);

      stat = asn1PD_utran_UL_LogicalChannelMapping_r6 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMappingList_r6 (OSCTXT* pctxt, utran_UL_LogicalChannelMappingList_r6* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-LogicalChannelMappingList-r6");

   /* decode root elements */
   /* decode rlc_LogicalChannelMappingIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-LogicalChannelMappingIndicator");

   stat = DEC_BIT (pctxt, &pvalue->rlc_LogicalChannelMappingIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_LogicalChannelMapping */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-LogicalChannelMapping");

   stat = asn1PD_utran_UL_LogicalChannelMappingList_r6_ul_LogicalChannelMapping (pctxt, &pvalue->ul_LogicalChannelMapping);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMappings_r6 (OSCTXT* pctxt, utran_UL_LogicalChannelMappings_r6* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-LogicalChannelMappings-r6");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* oneLogicalChannel */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "oneLogicalChannel");

         pvalue->u.oneLogicalChannel = rtxMemAllocType (pctxt, 
            utran_UL_LogicalChannelMapping_r6);

         if (pvalue->u.oneLogicalChannel == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_LogicalChannelMapping_r6 (pvalue->u.oneLogicalChannel);

         stat = asn1PD_utran_UL_LogicalChannelMapping_r6 (pctxt, pvalue->u.oneLogicalChannel);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* twoLogicalChannels */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "twoLogicalChannels");

         pvalue->u.twoLogicalChannels = rtxMemAllocType (pctxt, 
            utran_UL_LogicalChannelMappingList_r6);

         if (pvalue->u.twoLogicalChannels == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_LogicalChannelMappingList_r6 (pvalue->u.twoLogicalChannels);

         stat = asn1PD_utran_UL_LogicalChannelMappingList_r6 (pctxt, pvalue->u.twoLogicalChannels);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_MappingOption_r6 (OSCTXT* pctxt, utran_RB_MappingOption_r6* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-MappingOption-r6");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_LogicalChannelMappings */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-LogicalChannelMappings");

      pvalue->m.ul_LogicalChannelMappingsPresent = 1;

      stat = asn1PD_utran_UL_LogicalChannelMappings_r6 (pctxt, &pvalue->ul_LogicalChannelMappings);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_LogicalChannelMappingList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-LogicalChannelMappingList");

      pvalue->m.dl_LogicalChannelMappingListPresent = 1;

      stat = asn1PD_utran_DL_LogicalChannelMappingList_r5 (pctxt, &pvalue->dl_LogicalChannelMappingList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_MappingInfo_r6 (OSCTXT* pctxt, utran_RB_MappingInfo_r6* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-MappingInfo-r6");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_MappingOption_r6* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-MappingOption-r6", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_MappingOption_r6, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_MappingOption_r6 (pdata);

      stat = asn1PD_utran_RB_MappingOption_r6 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationReconfig_r6 (OSCTXT* pctxt, utran_RB_InformationReconfig_r6* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationReconfig-r6");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdcp_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Info");

      pvalue->m.pdcp_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_InfoReconfig_r4 (pctxt, &pvalue->pdcp_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pdcp_SN_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-SN-Info");

      pvalue->m.pdcp_SN_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_SN_Info (pctxt, &pvalue->pdcp_SN_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_Info */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlc-Info");

      pvalue->m.rlc_InfoPresent = 1;

      stat = asn1PD_utran_RLC_Info_r6 (pctxt, &pvalue->rlc_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_MappingInfo */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

      pvalue->m.rb_MappingInfoPresent = 1;

      stat = asn1PD_utran_RB_MappingInfo_r6 (pctxt, &pvalue->rb_MappingInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_StopContinue */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-StopContinue");

      pvalue->m.rb_StopContinuePresent = 1;

      stat = asn1PD_utran_RB_StopContinue (pctxt, &pvalue->rb_StopContinue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationReconfigList_r6 (OSCTXT* pctxt, utran_RB_InformationReconfigList_r6* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationReconfigList-r6");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationReconfig_r6* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationReconfig-r6", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationReconfig_r6, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationReconfig_r6 (pdata);

      stat = asn1PD_utran_RB_InformationReconfig_r6 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationAffected_r6 (OSCTXT* pctxt, utran_RB_InformationAffected_r6* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationAffected-r6");

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_MappingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

   stat = asn1PD_utran_RB_MappingInfo_r6 (pctxt, &pvalue->rb_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationAffectedList_r6 (OSCTXT* pctxt, utran_RB_InformationAffectedList_r6* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationAffectedList-r6");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationAffected_r6* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationAffected-r6", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationAffected_r6, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationAffected_r6 (pdata);

      stat = asn1PD_utran_RB_InformationAffected_r6 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TransportChannelIdentity_r6_dch_usch (OSCTXT* pctxt, utran_UL_TransportChannelIdentity_r6_dch_usch* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ul_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TransportChannelType");

   stat = asn1PD_utran_UL_TrCH_Type (pctxt, &pvalue->ul_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TransportChannelIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TransportChannelIdentity");

   stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->ul_TransportChannelIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TransportChannelIdentity_r6 (OSCTXT* pctxt, utran_UL_TransportChannelIdentity_r6* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-TransportChannelIdentity-r6");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dch_usch */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dch-usch");

         pvalue->u.dch_usch = rtxMemAllocTypeZ (pctxt, 
            utran_UL_TransportChannelIdentity_r6_dch_usch);

         if (pvalue->u.dch_usch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UL_TransportChannelIdentity_r6_dch_usch (pctxt, pvalue->u.dch_usch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* e_dch */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "e-dch");

         stat = asn1PD_utran_E_DCH_MAC_d_FlowIdentity (pctxt, &pvalue->u.e_dch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DeletedTransChInfoList_r6 (OSCTXT* pctxt, utran_UL_DeletedTransChInfoList_r6* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DeletedTransChInfoList-r6");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UL_TransportChannelIdentity_r6* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-TransportChannelIdentity-r6", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UL_TransportChannelIdentity_r6, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UL_TransportChannelIdentity_r6 (pdata);

      stat = asn1PD_utran_UL_TransportChannelIdentity_r6 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r6_dch_usch (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r6_dch_usch* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ul_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TransportChannelType");

   stat = asn1PD_utran_UL_TrCH_Type (pctxt, &pvalue->ul_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportChannelIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "transportChannelIdentity");

   stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->transportChannelIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportFormatSet */
   RTXCTXTPUSHELEMNAME (pctxt, "transportFormatSet");

   stat = asn1PD_utran_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_TTI (OSCTXT* pctxt, utran_E_DCH_TTI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-TTI");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_MAC_d_FlowPowerOffset (OSCTXT* pctxt, utran_E_DCH_MAC_d_FlowPowerOffset* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-MAC-d-FlowPowerOffset");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_MAC_d_FlowMaxRetrans (OSCTXT* pctxt, utran_E_DCH_MAC_d_FlowMaxRetrans* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-MAC-d-FlowMaxRetrans");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_MAC_d_FlowMultiplexingList (OSCTXT* pctxt, utran_E_DCH_MAC_d_FlowMultiplexingList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-MAC-d-FlowMultiplexingList");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType_non_ScheduledTransGrantInfo (OSCTXT* pctxt, utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType_non_ScheduledTransGrantInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode maxMAC_e_PDUContents */
   RTXCTXTPUSHELEMNAME (pctxt, "maxMAC-e-PDUContents");

   stat = pd_ConsUInt16 (pctxt, &pvalue->maxMAC_e_PDUContents, OSUINTCONST(1), OSUINTCONST(19982));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ms2_NonSchedTransmGrantHARQAlloc */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ms2-NonSchedTransmGrantHARQAlloc");

      pvalue->m.ms2_NonSchedTransmGrantHARQAllocPresent = 1;

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

      stat = pd_BitString32 (pctxt, &pvalue->ms2_NonSchedTransmGrantHARQAlloc
         , OSUINTCONST(8), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType (OSCTXT* pctxt, utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* non_ScheduledTransGrantInfo */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "non-ScheduledTransGrantInfo");

         pvalue->u.non_ScheduledTransGrantInfo = rtxMemAllocType (pctxt, 
            utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType_non_ScheduledTransGrantInfo);

         if (pvalue->u.non_ScheduledTransGrantInfo == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType_non_ScheduledTransGrantInfo (pvalue->u.non_ScheduledTransGrantInfo);

         stat = asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType_non_ScheduledTransGrantInfo (pctxt, pvalue->u.non_ScheduledTransGrantInfo);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* scheduledTransmissionGrantInfo */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "scheduledTransmissionGrantInfo");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow (OSCTXT* pctxt, utran_E_DCH_AddReconf_MAC_d_Flow* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-AddReconf-MAC-d-Flow");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_d_FlowIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-d-FlowIdentity");

   stat = asn1PD_utran_E_DCH_MAC_d_FlowIdentity (pctxt, &pvalue->mac_d_FlowIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_d_FlowPowerOffset */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-d-FlowPowerOffset");

      pvalue->m.mac_d_FlowPowerOffsetPresent = 1;

      stat = asn1PD_utran_E_DCH_MAC_d_FlowPowerOffset (pctxt, &pvalue->mac_d_FlowPowerOffset);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mac_d_FlowMaxRetrans */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-d-FlowMaxRetrans");

      pvalue->m.mac_d_FlowMaxRetransPresent = 1;

      stat = asn1PD_utran_E_DCH_MAC_d_FlowMaxRetrans (pctxt, &pvalue->mac_d_FlowMaxRetrans);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mac_d_FlowMultiplexingList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-d-FlowMultiplexingList");

      pvalue->m.mac_d_FlowMultiplexingListPresent = 1;

      stat = asn1PD_utran_E_DCH_MAC_d_FlowMultiplexingList (pctxt, &pvalue->mac_d_FlowMultiplexingList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode transmissionGrantType */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "transmissionGrantType");

      pvalue->m.transmissionGrantTypePresent = 1;

      stat = asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType (pctxt, &pvalue->transmissionGrantType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_AddReconf_MAC_d_FlowList (OSCTXT* pctxt, utran_E_DCH_AddReconf_MAC_d_FlowList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-AddReconf-MAC-d-FlowList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_E_DCH_AddReconf_MAC_d_Flow* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "E-DCH-AddReconf-MAC-d-Flow", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_E_DCH_AddReconf_MAC_d_Flow, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow (pdata);

      stat = asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r6_e_dch (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r6_e_dch* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tti */
   RTXCTXTPUSHELEMNAME (pctxt, "tti");

   stat = asn1PD_utran_E_DCH_TTI (pctxt, &pvalue->tti);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode harq_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "harq-Info");

   stat = asn1PD_utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info (pctxt, &pvalue->harq_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode addReconf_MAC_d_FlowList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "addReconf-MAC-d-FlowList");

      pvalue->m.addReconf_MAC_d_FlowListPresent = 1;

      stat = asn1PD_utran_E_DCH_AddReconf_MAC_d_FlowList (pctxt, &pvalue->addReconf_MAC_d_FlowList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r6 (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r6* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-AddReconfTransChInformation-r6");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dch_usch */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dch-usch");

         pvalue->u.dch_usch = rtxMemAllocType (pctxt, 
            utran_UL_AddReconfTransChInformation_r6_dch_usch);

         if (pvalue->u.dch_usch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_AddReconfTransChInformation_r6_dch_usch (pvalue->u.dch_usch);

         stat = asn1PD_utran_UL_AddReconfTransChInformation_r6_dch_usch (pctxt, pvalue->u.dch_usch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* e_dch */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "e-dch");

         pvalue->u.e_dch = rtxMemAllocType (pctxt, 
            utran_UL_AddReconfTransChInformation_r6_e_dch);

         if (pvalue->u.e_dch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_AddReconfTransChInformation_r6_e_dch (pvalue->u.e_dch);

         stat = asn1PD_utran_UL_AddReconfTransChInformation_r6_e_dch (pctxt, pvalue->u.e_dch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInfoList_r6 (OSCTXT* pctxt, utran_UL_AddReconfTransChInfoList_r6* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-AddReconfTransChInfoList-r6");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UL_AddReconfTransChInformation_r6* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-AddReconfTransChInformation-r6", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UL_AddReconfTransChInformation_r6, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UL_AddReconfTransChInformation_r6 (pdata);

      stat = asn1PD_utran_UL_AddReconfTransChInformation_r6 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r6_fdd (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r6_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dpcch_PowerOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "dpcch-PowerOffset");

   stat = asn1PD_utran_DPCCH_PowerOffset (pctxt, &pvalue->dpcch_PowerOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pc_Preamble */
   RTXCTXTPUSHELEMNAME (pctxt, "pc-Preamble");

   stat = asn1PD_utran_PC_Preamble (pctxt, &pvalue->pc_Preamble);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sRB_delay */
   RTXCTXTPUSHELEMNAME (pctxt, "sRB-delay");

   stat = asn1PD_utran_SRB_delay (pctxt, &pvalue->sRB_delay);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerControlAlgorithm */
   RTXCTXTPUSHELEMNAME (pctxt, "powerControlAlgorithm");

   stat = asn1PD_utran_PowerControlAlgorithm (pctxt, &pvalue->powerControlAlgorithm);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaACK */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaACK");

      pvalue->m.deltaACKPresent = 1;

      stat = asn1PD_utran_DeltaACK (pctxt, &pvalue->deltaACK);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode deltaNACK */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaNACK");

      pvalue->m.deltaNACKPresent = 1;

      stat = asn1PD_utran_DeltaNACK (pctxt, &pvalue->deltaNACK);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ack_NACK_repetition_factor */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ack-NACK-repetition-factor");

      pvalue->m.ack_NACK_repetition_factorPresent = 1;

      stat = asn1PD_utran_ACK_NACK_repetitionFactor (pctxt, &pvalue->ack_NACK_repetition_factor);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode harq_Preamble_Mode */
   RTXCTXTPUSHELEMNAME (pctxt, "harq-Preamble-Mode");

   stat = asn1PD_utran_HARQ_Preamble_Mode (pctxt, &pvalue->harq_Preamble_Mode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTS_InterferenceList */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTS-InterferenceList");

   stat = asn1PD_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpch_ConstantValue */
   RTXCTXTPUSHELEMNAME (pctxt, "dpch-ConstantValue");

   stat = asn1PD_utran_ConstantValue (pctxt, &pvalue->dpch_ConstantValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode beaconPLEst */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "beaconPLEst");

      pvalue->m.beaconPLEstPresent = 1;

      stat = asn1PD_utran_BEACON_PL_Est (pctxt, &pvalue->beaconPLEst);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tpc_StepSize */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-StepSize");

   stat = asn1PD_utran_TPC_StepSizeTDD (pctxt, &pvalue->tpc_StepSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode primaryCCPCH_TX_Power */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCCPCH-TX-Power");

   stat = asn1PD_utran_PrimaryCCPCH_TX_Power (pctxt, &pvalue->primaryCCPCH_TX_Power);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* broadcast_UL_OL_PC_info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "broadcast-UL-OL-PC-info");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* individuallySignalled */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "individuallySignalled");

         pvalue->u.individuallySignalled = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled);

         if (pvalue->u.individuallySignalled == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled (pvalue->u.individuallySignalled);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled (pctxt, pvalue->u.individuallySignalled);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r6_tdd (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r6_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TargetSIR */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TargetSIR");

      pvalue->m.ul_TargetSIRPresent = 1;

      stat = asn1PD_utran_UL_TargetSIR (pctxt, &pvalue->ul_TargetSIR);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_OL_PC_Signalling */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-OL-PC-Signalling");

   stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling (pctxt, &pvalue->ul_OL_PC_Signalling);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r6 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r6* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-PowerControlInfo-r6");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r6_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r6_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r6_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r6_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r6_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r6_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence_present (OSCTXT* pctxt, utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence_present* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode numberOfDPDCH */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfDPDCH");

      stat = asn1PD_utran_NumberOfDPDCH (pctxt, &pvalue->numberOfDPDCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->numberOfDPDCH = 1;
   }

   /* decode spreadingFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactor");

   stat = asn1PD_utran_SpreadingFactor (pctxt, &pvalue->spreadingFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfFBI_Bits */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfFBI-Bits");

      pvalue->m.numberOfFBI_BitsPresent = 1;

      stat = asn1PD_utran_NumberOfFBI_Bits (pctxt, &pvalue->numberOfFBI_Bits);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode puncturingLimit */
   RTXCTXTPUSHELEMNAME (pctxt, "puncturingLimit");

   stat = asn1PD_utran_PuncturingLimit (pctxt, &pvalue->puncturingLimit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence_notPresent (OSCTXT* pctxt, utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence_notPresent* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfFBI_Bits */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfFBI-Bits");

      pvalue->m.numberOfFBI_BitsPresent = 1;

      stat = asn1PD_utran_NumberOfFBI_Bits (pctxt, &pvalue->numberOfFBI_Bits);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence (OSCTXT* pctxt, utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* present */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "present");

         pvalue->u.present = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence_present);

         if (pvalue->u.present == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence_present (pvalue->u.present);

         stat = asn1PD_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence_present (pctxt, pvalue->u.present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* notPresent */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "notPresent");

         pvalue->u.notPresent = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence_notPresent);

         if (pvalue->u.notPresent == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence_notPresent (pvalue->u.notPresent);

         stat = asn1PD_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence_notPresent (pctxt, pvalue->u.notPresent);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode scramblingCodeType */
   RTXCTXTPUSHELEMNAME (pctxt, "scramblingCodeType");

   stat = asn1PD_utran_ScramblingCodeType (pctxt, &pvalue->scramblingCodeType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode scramblingCode */
   RTXCTXTPUSHELEMNAME (pctxt, "scramblingCode");

   stat = asn1PD_utran_UL_ScramblingCode (pctxt, &pvalue->scramblingCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpdchPresence */
   RTXCTXTPUSHELEMNAME (pctxt, "dpdchPresence");

   stat = asn1PD_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence (pctxt, &pvalue->dpdchPresence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r6_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_UL_DPCH_Info_r6_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TimingAdvance */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TimingAdvance");

      pvalue->m.ul_TimingAdvancePresent = 1;

      stat = asn1PD_utran_UL_TimingAdvanceControl_r4 (pctxt, &pvalue->ul_TimingAdvance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCHList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCHList");

      pvalue->m.ul_CCTrCHListPresent = 1;

      stat = asn1PD_utran_UL_CCTrCHList_r4 (pctxt, &pvalue->ul_CCTrCHList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCHListToRemove */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCHListToRemove");

      pvalue->m.ul_CCTrCHListToRemovePresent = 1;

      stat = asn1PD_utran_UL_CCTrCHListToRemove (pctxt, &pvalue->ul_CCTrCHListToRemove);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r6_modeSpecificInfo (OSCTXT* pctxt, utran_UL_DPCH_Info_r6_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r6_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r6_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_DPCH_Info_r6_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r6 (OSCTXT* pctxt, utran_UL_DPCH_Info_r6* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-Info-r6");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-DPCH-PowerControlInfo");

      pvalue->m.ul_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r6 (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_UL_DPCH_Info_r6_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator (OSCTXT* pctxt, utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__303; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HappyBit_DelayCondition (OSCTXT* pctxt, utran_HappyBit_DelayCondition* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HappyBit-DelayCondition");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DPCCH_Info (OSCTXT* pctxt, utran_E_DPCCH_Info* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DPCCH-Info");

   /* decode root elements */
   /* decode e_DPCCH_DPCCH_PowerOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "e-DPCCH-DPCCH-PowerOffset");

   stat = asn1PD_utran_E_DPCCH_DPCCH_PowerOffset (pctxt, &pvalue->e_DPCCH_DPCCH_PowerOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode happyBit_DelayCondition */
   RTXCTXTPUSHELEMNAME (pctxt, "happyBit-DelayCondition");

   stat = asn1PD_utran_HappyBit_DelayCondition (pctxt, &pvalue->happyBit_DelayCondition);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DPDCH_MaxChannelisationCodes (OSCTXT* pctxt, utran_E_DPDCH_MaxChannelisationCodes* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DPDCH-MaxChannelisationCodes");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(9));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DPDCH_PL_NonMax (OSCTXT* pctxt, utran_E_DPDCH_PL_NonMax* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DPDCH-PL-NonMax");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(11), OSUINTCONST(25));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DPDCH_PeriodicyOfSchedInfo (OSCTXT* pctxt, utran_E_DPDCH_PeriodicyOfSchedInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DPDCH-PeriodicyOfSchedInfo");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DPDCH_SchedulingInfoConfiguration (OSCTXT* pctxt, utran_E_DPDCH_SchedulingInfoConfiguration* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "E-DPDCH-SchedulingInfoConfiguration");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode periodicityOfSchedInfo_NoGrant */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "periodicityOfSchedInfo-NoGrant");

      pvalue->m.periodicityOfSchedInfo_NoGrantPresent = 1;

      stat = asn1PD_utran_E_DPDCH_PeriodicyOfSchedInfo (pctxt, &pvalue->periodicityOfSchedInfo_NoGrant);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode periodicityOfSchedInfo_Grant */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "periodicityOfSchedInfo-Grant");

      pvalue->m.periodicityOfSchedInfo_GrantPresent = 1;

      stat = asn1PD_utran_E_DPDCH_PeriodicyOfSchedInfo (pctxt, &pvalue->periodicityOfSchedInfo_Grant);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode powerOffsetForSchedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetForSchedInfo");

   stat = pd_ConsUInt8 (pctxt, &pvalue->powerOffsetForSchedInfo, OSUINTCONST(0), OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DPDCH_Info (OSCTXT* pctxt, utran_E_DPDCH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "E-DPDCH-Info");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_TFCI_TableIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "e-TFCI-TableIndex");

   stat = asn1PD_utran_E_TFCI_TableIndex (pctxt, &pvalue->e_TFCI_TableIndex);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_DCH_MinimumSet_E_TFCI */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-DCH-MinimumSet-E-TFCI");

      pvalue->m.e_DCH_MinimumSet_E_TFCIPresent = 1;

      stat = asn1PD_utran_E_DCH_MinimumSet_E_TFCI (pctxt, &pvalue->e_DCH_MinimumSet_E_TFCI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode reference_E_TFCIs */
   RTXCTXTPUSHELEMNAME (pctxt, "reference-E-TFCIs");

   stat = asn1PD_utran_E_DPDCH_Reference_E_TFCIList (pctxt, &pvalue->reference_E_TFCIs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maxChannelisationCodes */
   RTXCTXTPUSHELEMNAME (pctxt, "maxChannelisationCodes");

   stat = asn1PD_utran_E_DPDCH_MaxChannelisationCodes (pctxt, &pvalue->maxChannelisationCodes);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pl_NonMax */
   RTXCTXTPUSHELEMNAME (pctxt, "pl-NonMax");

   stat = asn1PD_utran_E_DPDCH_PL_NonMax (pctxt, &pvalue->pl_NonMax);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode schedulingInfoConfiguration */
   RTXCTXTPUSHELEMNAME (pctxt, "schedulingInfoConfiguration");

   stat = asn1PD_utran_E_DPDCH_SchedulingInfoConfiguration (pctxt, &pvalue->schedulingInfoConfiguration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threeIndexStepThreshold */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "threeIndexStepThreshold");

      pvalue->m.threeIndexStepThresholdPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->threeIndexStepThreshold, OSUINTCONST(0), OSUINTCONST(37));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode twoIndexStepThreshold */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "twoIndexStepThreshold");

      pvalue->m.twoIndexStepThresholdPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->twoIndexStepThreshold, OSUINTCONST(0), OSUINTCONST(37));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector (OSCTXT* pctxt, utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant (OSCTXT* pctxt, utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_ConsUInt8 (pctxt, &pvalue->value, OSUINTCONST(0), OSUINTCONST(38));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode primary_Secondary_GrantSelector */
   RTXCTXTPUSHELEMNAME (pctxt, "primary-Secondary-GrantSelector");

   stat = asn1PD_utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector (pctxt, &pvalue->primary_Secondary_GrantSelector);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DPDCH_SchedulingTransmConfiguration (OSCTXT* pctxt, utran_E_DPDCH_SchedulingTransmConfiguration* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "E-DPDCH-SchedulingTransmConfiguration");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ms2_SchedTransmGrantHARQAlloc */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ms2-SchedTransmGrantHARQAlloc");

      pvalue->m.ms2_SchedTransmGrantHARQAllocPresent = 1;

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

      stat = pd_BitString32 (pctxt, &pvalue->ms2_SchedTransmGrantHARQAlloc
         , OSUINTCONST(8), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode servingGrant */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "servingGrant");

      pvalue->m.servingGrantPresent = 1;

      stat = asn1PD_utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant (pctxt, &pvalue->servingGrant);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r6 (OSCTXT* pctxt, utran_UL_EDCH_Information_r6* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-EDCH-Information-r6");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_es_e_resetIndicator */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-es-e-resetIndicator");

      pvalue->m.mac_es_e_resetIndicatorPresent = 1;

      stat = asn1PD_utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator (pctxt, &pvalue->mac_es_e_resetIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_DPCCH_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-DPCCH-Info");

      pvalue->m.e_DPCCH_InfoPresent = 1;

      stat = asn1PD_utran_E_DPCCH_Info (pctxt, &pvalue->e_DPCCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_DPDCH_Info */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-DPDCH-Info");

      pvalue->m.e_DPDCH_InfoPresent = 1;

      stat = asn1PD_utran_E_DPDCH_Info (pctxt, &pvalue->e_DPDCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode schedulingTransmConfiguration */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "schedulingTransmConfiguration");

      pvalue->m.schedulingTransmConfigurationPresent = 1;

      stat = asn1PD_utran_E_DPDCH_SchedulingTransmConfiguration (pctxt, &pvalue->schedulingTransmConfiguration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo (OSCTXT* pctxt, utran_HS_SCCH_Info_r6_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 4) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "HS-SCCH-Codes", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_HS_SCCH_Codes));
      stat = asn1PD_utran_HS_SCCH_Codes (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_HS_SCCH_Info_r6_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode hS_SCCHChannelisationCodeInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "hS-SCCHChannelisationCodeInfo");

   stat = asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo (pctxt, &pvalue->hS_SCCHChannelisationCodeInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_ScramblingCode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-ScramblingCode");

      pvalue->m.dl_ScramblingCodePresent = 1;

      stat = asn1PD_utran_SecondaryScramblingCode (pctxt, &pvalue->dl_ScramblingCode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (OSCTXT* pctxt, utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_HS_SCCH_TDD384_r6* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "HS-SCCH-TDD384-r6", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_HS_SCCH_TDD384_r6, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_HS_SCCH_TDD384_r6 (pdata);

      stat = asn1PD_utran_HS_SCCH_TDD384_r6 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384 (OSCTXT* pctxt, utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode nack_ack_power_offset */
   RTXCTXTPUSHELEMNAME (pctxt, "nack-ack-power-offset");

   stat = pd_ConsInt8 (pctxt, &pvalue->nack_ack_power_offset, OSINTCONST(-7), OSINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode hs_SICH_PowerControl_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "hs-SICH-PowerControl-Info");

   stat = asn1PD_utran_HS_SICH_Power_Control_Info_TDD384 (pctxt, &pvalue->hs_SICH_PowerControl_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dhs_sync */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dhs-sync");

      pvalue->m.dhs_syncPresent = 1;

      stat = asn1PD_utran_DHS_Sync (pctxt, &pvalue->dhs_sync);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode bler_target */
   RTXCTXTPUSHELEMNAME (pctxt, "bler-target");

   stat = asn1PD_utran_Bler_Target (pctxt, &pvalue->bler_target);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode hS_SCCH_SetConfiguration */
   RTXCTXTPUSHELEMNAME (pctxt, "hS-SCCH-SetConfiguration");

   stat = asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (pctxt, &pvalue->hS_SCCH_SetConfiguration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size (OSCTXT* pctxt, utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration (OSCTXT* pctxt, utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_HS_SCCH_TDD128_r6* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "HS-SCCH-TDD128-r6", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_HS_SCCH_TDD128_r6, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_HS_SCCH_TDD128_r6 (pdata);

      stat = asn1PD_utran_HS_SCCH_TDD128_r6 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128 (OSCTXT* pctxt, utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode nack_ack_power_offset */
   RTXCTXTPUSHELEMNAME (pctxt, "nack-ack-power-offset");

   stat = pd_ConsInt8 (pctxt, &pvalue->nack_ack_power_offset, OSINTCONST(-7), OSINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode power_level_HSSICH */
   RTXCTXTPUSHELEMNAME (pctxt, "power-level-HSSICH");

   stat = pd_ConsInt8 (pctxt, &pvalue->power_level_HSSICH, OSINTCONST(-120), OSINTCONST(-58));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tpc_step_size */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-step-size");

   stat = asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size (pctxt, &pvalue->tpc_step_size);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode bler_target */
   RTXCTXTPUSHELEMNAME (pctxt, "bler-target");

   stat = asn1PD_utran_Bler_Target (pctxt, &pvalue->bler_target);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode hS_SCCH_SetConfiguration */
   RTXCTXTPUSHELEMNAME (pctxt, "hS-SCCH-SetConfiguration");

   stat = asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration (pctxt, &pvalue->hS_SCCH_SetConfiguration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo (OSCTXT* pctxt, utran_HS_SCCH_Info_r6_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_HS_SCCH_Info_r6_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r6 (OSCTXT* pctxt, utran_HS_SCCH_Info_r6* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HS-SCCH-Info-r6");

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_HS_SCCH_Info_r6_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd384 (OSCTXT* pctxt, utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd384* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_HSPDSCH_TS_Configuration */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-HSPDSCH-TS-Configuration");

      pvalue->m.dl_HSPDSCH_TS_ConfigurationPresent = 1;

      stat = asn1PD_utran_DL_HSPDSCH_TS_Configuration (pctxt, &pvalue->dl_HSPDSCH_TS_Configuration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd128 (OSCTXT* pctxt, utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode hs_PDSCH_Midamble_Configuration_tdd128 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hs-PDSCH-Midamble-Configuration-tdd128");

      pvalue->m.hs_PDSCH_Midamble_Configuration_tdd128Present = 1;

      stat = asn1PD_utran_HS_PDSCH_Midamble_Configuration_TDD128 (pctxt, &pvalue->hs_PDSCH_Midamble_Configuration_tdd128);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo (OSCTXT* pctxt, utran_DL_HSPDSCH_Information_r6_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* fdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_HSPDSCH_Information_r6 (OSCTXT* pctxt, utran_DL_HSPDSCH_Information_r6* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-HSPDSCH-Information-r6");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode hs_scch_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hs-scch-Info");

      pvalue->m.hs_scch_InfoPresent = 1;

      stat = asn1PD_utran_HS_SCCH_Info_r6 (pctxt, &pvalue->hs_scch_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measurement_feedback_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measurement-feedback-Info");

      pvalue->m.measurement_feedback_InfoPresent = 1;

      stat = asn1PD_utran_Measurement_Feedback_Info (pctxt, &pvalue->measurement_feedback_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TimingMaintainedSynchInd (OSCTXT* pctxt, utran_TimingMaintainedSynchInd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "TimingMaintainedSynchInd");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_false_; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r6_cfnHandling_maintain (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r6_cfnHandling_maintain* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode timingmaintainedsynchind */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timingmaintainedsynchind");

      pvalue->m.timingmaintainedsynchindPresent = 1;

      stat = asn1PD_utran_TimingMaintainedSynchInd (pctxt, &pvalue->timingmaintainedsynchind);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r6_cfnHandling (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r6_cfnHandling* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* maintain */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "maintain");

         pvalue->u.maintain = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r6_cfnHandling_maintain);

         if (pvalue->u.maintain == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r6_cfnHandling_maintain (pvalue->u.maintain);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r6_cfnHandling_maintain (pctxt, pvalue->u.maintain);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* initialise */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "initialise");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-PowerControlInfo");

      pvalue->m.dl_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode powerOffsetPilot_pdpdch */
   RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetPilot-pdpdch");

   stat = asn1PD_utran_PowerOffsetPilot_pdpdch (pctxt, &pvalue->powerOffsetPilot_pdpdch);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_rate_matching_restriction */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-rate-matching-restriction");

      pvalue->m.dl_rate_matching_restrictionPresent = 1;

      stat = asn1PD_utran_Dl_rate_matching_restriction (pctxt, &pvalue->dl_rate_matching_restriction);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode spreadingFactorAndPilot */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactorAndPilot");

   stat = asn1PD_utran_SF512_AndPilot (pctxt, &pvalue->spreadingFactorAndPilot);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode positionFixedOrFlexible */
   RTXCTXTPUSHELEMNAME (pctxt, "positionFixedOrFlexible");

   stat = asn1PD_utran_PositionFixedOrFlexible (pctxt, &pvalue->positionFixedOrFlexible);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-PowerControlInfo");

      pvalue->m.dl_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r6 (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r6* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DPCH-InfoCommon-r6");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cfnHandling */
   RTXCTXTPUSHELEMNAME (pctxt, "cfnHandling");

   stat = asn1PD_utran_DL_DPCH_InfoCommon_r6_cfnHandling (pctxt, &pvalue->cfnHandling);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_d_HFN_initial_value */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-d-HFN-initial-value");

      pvalue->m.mac_d_HFN_initial_valuePresent = 1;

      stat = asn1PD_utran_MAC_d_HFN_initial_value (pctxt, &pvalue->mac_d_HFN_initial_value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_FDPCH_InfoCommon_r6_cfnHandling_maintain (OSCTXT* pctxt, utran_DL_FDPCH_InfoCommon_r6_cfnHandling_maintain* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode timingmaintainedsynchind */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timingmaintainedsynchind");

      pvalue->m.timingmaintainedsynchindPresent = 1;

      stat = asn1PD_utran_TimingMaintainedSynchInd (pctxt, &pvalue->timingmaintainedsynchind);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_FDPCH_InfoCommon_r6_cfnHandling (OSCTXT* pctxt, utran_DL_FDPCH_InfoCommon_r6_cfnHandling* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* maintain */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "maintain");

         pvalue->u.maintain = rtxMemAllocType (pctxt, 
            utran_DL_FDPCH_InfoCommon_r6_cfnHandling_maintain);

         if (pvalue->u.maintain == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_FDPCH_InfoCommon_r6_cfnHandling_maintain (pvalue->u.maintain);

         stat = asn1PD_utran_DL_FDPCH_InfoCommon_r6_cfnHandling_maintain (pctxt, pvalue->u.maintain);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* initialise */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "initialise");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_FDPCH_InfoCommon_r6 (OSCTXT* pctxt, utran_DL_FDPCH_InfoCommon_r6* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-FDPCH-InfoCommon-r6");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cfnHandling */
   RTXCTXTPUSHELEMNAME (pctxt, "cfnHandling");

   stat = asn1PD_utran_DL_FDPCH_InfoCommon_r6_cfnHandling (pctxt, &pvalue->cfnHandling);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_FDPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-FDPCH-PowerControlInfo");

      pvalue->m.dl_FDPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_FDPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_FDPCH_TPCcommandErrorRate */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-FDPCH-TPCcommandErrorRate");

      pvalue->m.dl_FDPCH_TPCcommandErrorRatePresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->dl_FDPCH_TPCcommandErrorRate, OSUINTCONST(1), OSUINTCONST(16));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r6_dl_dpchInfoCommon (OSCTXT* pctxt, utran_DL_CommonInformation_r6_dl_dpchInfoCommon* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_DPCH_InfoCommon */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoCommon");

         pvalue->u.dl_DPCH_InfoCommon = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r6);

         if (pvalue->u.dl_DPCH_InfoCommon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r6 (pvalue->u.dl_DPCH_InfoCommon);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_DPCH_InfoCommon);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_FDPCH_InfoCommon */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-FDPCH-InfoCommon");

         pvalue->u.dl_FDPCH_InfoCommon = rtxMemAllocType (pctxt, 
            utran_DL_FDPCH_InfoCommon_r6);

         if (pvalue->u.dl_FDPCH_InfoCommon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_FDPCH_InfoCommon_r6 (pvalue->u.dl_FDPCH_InfoCommon);

         stat = asn1PD_utran_DL_FDPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_FDPCH_InfoCommon);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r6_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_CommonInformation_r6_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueFDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dpch_CompressedModeInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dpch-CompressedModeInfo");

      pvalue->m.dpch_CompressedModeInfoPresent = 1;

      stat = asn1PD_utran_DPCH_CompressedModeInfo (pctxt, &pvalue->dpch_CompressedModeInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tx_DiversityMode */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tx-DiversityMode");

      pvalue->m.tx_DiversityModePresent = 1;

      stat = asn1PD_utran_TX_DiversityMode (pctxt, &pvalue->tx_DiversityMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r6_modeSpecificInfo_tdd_tddOption_tdd128 (OSCTXT* pctxt, utran_DL_CommonInformation_r6_modeSpecificInfo_tdd_tddOption_tdd128* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tstd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "tstd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->tstd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r6_modeSpecificInfo_tdd_tddOption (OSCTXT* pctxt, utran_DL_CommonInformation_r6_modeSpecificInfo_tdd_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocTypeZ (pctxt, 
            utran_DL_CommonInformation_r6_modeSpecificInfo_tdd_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_CommonInformation_r6_modeSpecificInfo_tdd_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r6_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_CommonInformation_r6_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_DL_CommonInformation_r6_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueTDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r6_modeSpecificInfo (OSCTXT* pctxt, utran_DL_CommonInformation_r6_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r6_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r6_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_CommonInformation_r6_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r6_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r6_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_CommonInformation_r6_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r6_mac_hsResetIndicator (OSCTXT* pctxt, utran_DL_CommonInformation_r6_mac_hsResetIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__265; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r6_postVerificationPeriod (OSCTXT* pctxt, utran_DL_CommonInformation_r6_postVerificationPeriod* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__266; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r6 (OSCTXT* pctxt, utran_DL_CommonInformation_r6* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CommonInformation-r6");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_dpchInfoCommon */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dpchInfoCommon");

      pvalue->m.dl_dpchInfoCommonPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r6_dl_dpchInfoCommon (pctxt, &pvalue->dl_dpchInfoCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_CommonInformation_r6_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_hsResetIndicator */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-hsResetIndicator");

      pvalue->m.mac_hsResetIndicatorPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r6_mac_hsResetIndicator (pctxt, &pvalue->mac_hsResetIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode postVerificationPeriod */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "postVerificationPeriod");

      pvalue->m.postVerificationPeriodPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r6_postVerificationPeriod (pctxt, &pvalue->postVerificationPeriod);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r6_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r6_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode primaryCPICH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCPICH-Info");

   stat = asn1PD_utran_PrimaryCPICH_Info (pctxt, &pvalue->primaryCPICH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode servingHSDSCH_RL_indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "servingHSDSCH-RL-indicator");

   stat = DEC_BIT (pctxt, &pvalue->servingHSDSCH_RL_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode servingEDCH_RL_indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "servingEDCH-RL-indicator");

   stat = DEC_BIT (pctxt, &pvalue->servingEDCH_RL_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r6_modeSpecificInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_r6_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocTypeZ (pctxt, 
            utran_DL_InformationPerRL_r6_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_InformationPerRL_r6_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, utran_PrimaryCCPCH_Info_r4);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_PrimaryCCPCH_Info_r4 (pvalue->u.tdd);

         stat = asn1PD_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_r6_fdd (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_r6_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pCPICH_UsageForChannelEst */
   RTXCTXTPUSHELEMNAME (pctxt, "pCPICH-UsageForChannelEst");

   stat = asn1PD_utran_PCPICH_UsageForChannelEst (pctxt, &pvalue->pCPICH_UsageForChannelEst);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpch_FrameOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "dpch-FrameOffset");

   stat = asn1PD_utran_DPCH_FrameOffset (pctxt, &pvalue->dpch_FrameOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode secondaryCPICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "secondaryCPICH-Info");

      pvalue->m.secondaryCPICH_InfoPresent = 1;

      stat = asn1PD_utran_SecondaryCPICH_Info (pctxt, &pvalue->secondaryCPICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_ChannelisationCodeList */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-ChannelisationCodeList");

   stat = asn1PD_utran_DL_ChannelisationCodeList (pctxt, &pvalue->dl_ChannelisationCodeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tpc_CombinationIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-CombinationIndex");

   stat = asn1PD_utran_TPC_CombinationIndex (pctxt, &pvalue->tpc_CombinationIndex);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerOffsetTPC_pdpdch */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetTPC-pdpdch");

      pvalue->m.powerOffsetTPC_pdpdchPresent = 1;

      stat = asn1PD_utran_PowerOffsetTPC_pdpdch (pctxt, &pvalue->powerOffsetTPC_pdpdch);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode closedLoopTimingAdjMode */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "closedLoopTimingAdjMode");

      pvalue->m.closedLoopTimingAdjModePresent = 1;

      stat = asn1PD_utran_ClosedLoopTimingAdjMode (pctxt, &pvalue->closedLoopTimingAdjMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_r6_tdd (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_r6_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_CCTrChListToEstablish */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-CCTrChListToEstablish");

      pvalue->m.dl_CCTrChListToEstablishPresent = 1;

      stat = asn1PD_utran_DL_CCTrChList_r4 (pctxt, &pvalue->dl_CCTrChListToEstablish);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_CCTrChListToRemove */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-CCTrChListToRemove");

      pvalue->m.dl_CCTrChListToRemovePresent = 1;

      stat = asn1PD_utran_DL_CCTrChListToRemove (pctxt, &pvalue->dl_CCTrChListToRemove);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_r6 (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_r6* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DPCH-InfoPerRL-r6");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoPerRL_r6_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoPerRL_r6_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_DPCH_InfoPerRL_r6_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoPerRL_r6_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoPerRL_r6_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_DPCH_InfoPerRL_r6_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r6_dl_dpchInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_r6_dl_dpchInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_DPCH_InfoPerRL */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoPerRL");

         pvalue->u.dl_DPCH_InfoPerRL = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoPerRL_r6);

         if (pvalue->u.dl_DPCH_InfoPerRL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoPerRL_r6 (pvalue->u.dl_DPCH_InfoPerRL);

         stat = asn1PD_utran_DL_DPCH_InfoPerRL_r6 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_FDPCH_InfoPerRL */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-FDPCH-InfoPerRL");

         pvalue->u.dl_FDPCH_InfoPerRL = rtxMemAllocType (pctxt, 
            utran_DL_FDPCH_InfoPerRL_r6);

         if (pvalue->u.dl_FDPCH_InfoPerRL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_FDPCH_InfoPerRL_r6 (pvalue->u.dl_FDPCH_InfoPerRL);

         stat = asn1PD_utran_DL_FDPCH_InfoPerRL_r6 (pctxt, pvalue->u.dl_FDPCH_InfoPerRL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r6_e_HICH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r6_e_HICH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* e_HICH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Information");

         pvalue->u.e_HICH_Information = rtxMemAllocTypeZ (pctxt, 
            utran_E_HICH_Information);

         if (pvalue->u.e_HICH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_E_HICH_Information (pctxt, pvalue->u.e_HICH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r6_e_RGCH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r6_e_RGCH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* e_RGCH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "e-RGCH-Information");

         pvalue->u.e_RGCH_Information = rtxMemAllocTypeZ (pctxt, 
            utran_E_RGCH_Information);

         if (pvalue->u.e_RGCH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_E_RGCH_Information (pctxt, pvalue->u.e_RGCH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r6 (OSCTXT* pctxt, utran_DL_InformationPerRL_r6* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-r6");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_InformationPerRL_r6_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_dpchInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dpchInfo");

      pvalue->m.dl_dpchInfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r6_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_AGCH_Information */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-Information");

      pvalue->m.e_AGCH_InformationPresent = 1;

      stat = asn1PD_utran_E_AGCH_Information (pctxt, &pvalue->e_AGCH_Information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_HICH_Info */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r6_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_RGCH_Info */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RGCH-Info");

      pvalue->m.e_RGCH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r6_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cell_id */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cell-id");

      pvalue->m.cell_idPresent = 1;

      stat = asn1PD_utran_CellIdentity (pctxt, &pvalue->cell_id);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_List_r6 (OSCTXT* pctxt, utran_DL_InformationPerRL_List_r6* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-List-r6");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_InformationPerRL_r6* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-InformationPerRL-r6", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_InformationPerRL_r6, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_InformationPerRL_r6 (pdata);

      stat = asn1PD_utran_DL_InformationPerRL_r6 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_v6b0ext (OSCTXT* pctxt, utran_DL_InformationPerRL_v6b0ext* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-v6b0ext");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode sttdIndication */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sttdIndication");

      pvalue->m.sttdIndicationPresent = 1;

      stat = asn1PD_utran_STTDIndication (pctxt, &pvalue->sttdIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_List_v6b0ext (OSCTXT* pctxt, utran_DL_InformationPerRL_List_v6b0ext* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-List-v6b0ext");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_InformationPerRL_v6b0ext* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-InformationPerRL-v6b0ext", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_InformationPerRL_v6b0ext, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_InformationPerRL_v6b0ext (pdata);

      stat = asn1PD_utran_DL_InformationPerRL_v6b0ext (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_IntegrityProtectionAlgorithm_r7 (OSCTXT* pctxt, utran_IntegrityProtectionAlgorithm_r7* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IntegrityProtectionAlgorithm-r7");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_IntegrityProtectionModeInfo_r7 (OSCTXT* pctxt, utran_IntegrityProtectionModeInfo_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "IntegrityProtectionModeInfo-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode integrityProtectionModeCommand */
   RTXCTXTPUSHELEMNAME (pctxt, "integrityProtectionModeCommand");

   stat = asn1PD_utran_IntegrityProtectionModeCommand (pctxt, &pvalue->integrityProtectionModeCommand);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode integrityProtectionAlgorithm */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "integrityProtectionAlgorithm");

      pvalue->m.integrityProtectionAlgorithmPresent = 1;

      stat = asn1PD_utran_IntegrityProtectionAlgorithm_r7 (pctxt, &pvalue->integrityProtectionAlgorithm);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CipheringAlgorithm_r7 (OSCTXT* pctxt, utran_CipheringAlgorithm_r7* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CipheringAlgorithm-r7");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CipheringModeCommand_r7 (OSCTXT* pctxt, utran_CipheringModeCommand_r7* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CipheringModeCommand-r7");

   /* decode root elements */
   /* decode startRestart */
   RTXCTXTPUSHELEMNAME (pctxt, "startRestart");

   stat = asn1PD_utran_CipheringAlgorithm_r7 (pctxt, &pvalue->startRestart);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CipheringModeInfo_r7 (OSCTXT* pctxt, utran_CipheringModeInfo_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "CipheringModeInfo-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cipheringModeCommand */
   RTXCTXTPUSHELEMNAME (pctxt, "cipheringModeCommand");

   stat = asn1PD_utran_CipheringModeCommand_r7 (pctxt, &pvalue->cipheringModeCommand);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode activationTimeForDPCH */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "activationTimeForDPCH");

      pvalue->m.activationTimeForDPCHPresent = 1;

      stat = asn1PD_utran_ActivationTime (pctxt, &pvalue->activationTimeForDPCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_DL_CiphActivationTimeInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-DL-CiphActivationTimeInfo");

      pvalue->m.rb_DL_CiphActivationTimeInfoPresent = 1;

      stat = asn1PD_utran_RB_ActivationTimeInfoList (pctxt, &pvalue->rb_DL_CiphActivationTimeInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_T_319 (OSCTXT* pctxt, utran_T_319* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "T-319");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UTRAN_DRX_CycleLengthCoefficient_r7 (OSCTXT* pctxt, utran_UTRAN_DRX_CycleLengthCoefficient_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "UTRAN-DRX-CycleLengthCoefficient-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode drx_CycleLengthCoefficient */
   RTXCTXTPUSHELEMNAME (pctxt, "drx-CycleLengthCoefficient");

   stat = pd_ConsUInt8 (pctxt, &pvalue->drx_CycleLengthCoefficient, OSUINTCONST(3), OSUINTCONST(9));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode drx_CycleLengthCoefficient2 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "drx-CycleLengthCoefficient2");

      pvalue->m.drx_CycleLengthCoefficient2Present = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->drx_CycleLengthCoefficient2, OSUINTCONST(3), OSUINTCONST(9));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode timeForDRXCycle2 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timeForDRXCycle2");

      pvalue->m.timeForDRXCycle2Present = 1;

      stat = asn1PD_utran_T_319 (pctxt, &pvalue->timeForDRXCycle2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_WaitTime (OSCTXT* pctxt, utran_WaitTime* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "WaitTime");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize (OSCTXT* pctxt, utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size (OSCTXT* pctxt, utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fixedSize */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fixedSize");

         pvalue->u.fixedSize = rtxMemAllocType (pctxt, 
            utran_OctetModeRLC_SizeInfoType1);

         if (pvalue->u.fixedSize == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_OctetModeRLC_SizeInfoType1 (pvalue->u.fixedSize);

         stat = asn1PD_utran_OctetModeRLC_SizeInfoType1 (pctxt, pvalue->u.fixedSize);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* flexibleSize */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "flexibleSize");

         stat = asn1PD_utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize (pctxt, &pvalue->u.flexibleSize);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_AM_RLC_Mode_r7 (OSCTXT* pctxt, utran_DL_AM_RLC_Mode_r7* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AM-RLC-Mode-r7");

   /* decode root elements */
   /* decode dl_RLC_PDU_size */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-RLC-PDU-size");

   stat = asn1PD_utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size (pctxt, &pvalue->dl_RLC_PDU_size);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode inSequenceDelivery */
   RTXCTXTPUSHELEMNAME (pctxt, "inSequenceDelivery");

   stat = DEC_BIT (pctxt, &pvalue->inSequenceDelivery);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode receivingWindowSize */
   RTXCTXTPUSHELEMNAME (pctxt, "receivingWindowSize");

   stat = asn1PD_utran_ReceivingWindowSize (pctxt, &pvalue->receivingWindowSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_RLC_StatusInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-RLC-StatusInfo");

   stat = asn1PD_utran_DL_RLC_StatusInfo (pctxt, &pvalue->dl_RLC_StatusInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_RLC_Mode_r7 (OSCTXT* pctxt, utran_DL_RLC_Mode_r7* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-RLC-Mode-r7");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_AM_RLC_Mode */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-AM-RLC-Mode");

         pvalue->u.dl_AM_RLC_Mode = rtxMemAllocType (pctxt, 
            utran_DL_AM_RLC_Mode_r7);

         if (pvalue->u.dl_AM_RLC_Mode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_AM_RLC_Mode_r7 (pvalue->u.dl_AM_RLC_Mode);

         stat = asn1PD_utran_DL_AM_RLC_Mode_r7 (pctxt, pvalue->u.dl_AM_RLC_Mode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_UM_RLC_Mode */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-UM-RLC-Mode");

         pvalue->u.dl_UM_RLC_Mode = rtxMemAllocType (pctxt, 
            utran_DL_UM_RLC_Mode_r6);

         if (pvalue->u.dl_UM_RLC_Mode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_UM_RLC_Mode_r6 (pvalue->u.dl_UM_RLC_Mode);

         stat = asn1PD_utran_DL_UM_RLC_Mode_r6 (pctxt, pvalue->u.dl_UM_RLC_Mode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_TM_RLC_Mode */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-TM-RLC-Mode");

         pvalue->u.dl_TM_RLC_Mode = rtxMemAllocTypeZ (pctxt, 
            utran_DL_TM_RLC_Mode);

         if (pvalue->u.dl_TM_RLC_Mode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_TM_RLC_Mode (pctxt, pvalue->u.dl_TM_RLC_Mode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RLC_Info_r7_altE_bitInterpretation (OSCTXT* pctxt, utran_RLC_Info_r7_altE_bitInterpretation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__258; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_RLC_Info_r7_useSpecialValueOfHEField (OSCTXT* pctxt, utran_RLC_Info_r7_useSpecialValueOfHEField* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__259; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_RLC_Info_r7 (OSCTXT* pctxt, utran_RLC_Info_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "RLC-Info-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_RLC_Mode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-RLC-Mode");

      pvalue->m.ul_RLC_ModePresent = 1;

      stat = asn1PD_utran_UL_RLC_Mode (pctxt, &pvalue->ul_RLC_Mode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_RLC_Mode */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-RLC-Mode");

      pvalue->m.dl_RLC_ModePresent = 1;

      stat = asn1PD_utran_DL_RLC_Mode_r7 (pctxt, &pvalue->dl_RLC_Mode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_OneSidedReEst */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-OneSidedReEst");

   stat = DEC_BIT (pctxt, &pvalue->rlc_OneSidedReEst);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode altE_bitInterpretation */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "altE-bitInterpretation");

      pvalue->m.altE_bitInterpretationPresent = 1;

      stat = asn1PD_utran_RLC_Info_r7_altE_bitInterpretation (pctxt, &pvalue->altE_bitInterpretation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode useSpecialValueOfHEField */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "useSpecialValueOfHEField");

      pvalue->m.useSpecialValueOfHEFieldPresent = 1;

      stat = asn1PD_utran_RLC_Info_r7_useSpecialValueOfHEField (pctxt, &pvalue->useSpecialValueOfHEField);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_ehs_QueueId (OSCTXT* pctxt, utran_MAC_ehs_QueueId* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-ehs-QueueId");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_TransportChannelType_r7_hsdsch (OSCTXT* pctxt, utran_DL_TransportChannelType_r7_hsdsch* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* mac_hs */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "mac-hs");

         stat = asn1PD_utran_MAC_d_FlowIdentity (pctxt, &pvalue->u.mac_hs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* mac_ehs */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs");

         stat = asn1PD_utran_MAC_ehs_QueueId (pctxt, &pvalue->u.mac_ehs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MAC_ehs_QueueIdDCHandHSDSCH (OSCTXT* pctxt, utran_MAC_ehs_QueueIdDCHandHSDSCH* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-ehs-QueueIdDCHandHSDSCH");

   /* decode root elements */
   /* decode dch_transport_ch_id */
   RTXCTXTPUSHELEMNAME (pctxt, "dch-transport-ch-id");

   stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->dch_transport_ch_id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode hsdsch_mac_ehs_QueueId */
   RTXCTXTPUSHELEMNAME (pctxt, "hsdsch-mac-ehs-QueueId");

   stat = asn1PD_utran_MAC_ehs_QueueId (pctxt, &pvalue->hsdsch_mac_ehs_QueueId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_TransportChannelType_r7_dch_and_hsdsch (OSCTXT* pctxt, utran_DL_TransportChannelType_r7_dch_and_hsdsch* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* mac_hs */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "mac-hs");

         pvalue->u.mac_hs = rtxMemAllocTypeZ (pctxt, 
            utran_MAC_d_FlowIdentityDCHandHSDSCH);

         if (pvalue->u.mac_hs == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_MAC_d_FlowIdentityDCHandHSDSCH (pctxt, pvalue->u.mac_hs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* mac_ehs */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs");

         pvalue->u.mac_ehs = rtxMemAllocTypeZ (pctxt, 
            utran_MAC_ehs_QueueIdDCHandHSDSCH);

         if (pvalue->u.mac_ehs == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_MAC_ehs_QueueIdDCHandHSDSCH (pctxt, pvalue->u.mac_ehs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_TransportChannelType_r7 (OSCTXT* pctxt, utran_DL_TransportChannelType_r7* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-TransportChannelType-r7");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dch */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dch");

         stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->u.dch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* fach */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "fach");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dsch */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "dsch");

         stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->u.dsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dch_and_dsch */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "dch-and-dsch");

         pvalue->u.dch_and_dsch = rtxMemAllocTypeZ (pctxt, 
            utran_TransportChannelIdentityDCHandDSCH);

         if (pvalue->u.dch_and_dsch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_TransportChannelIdentityDCHandDSCH (pctxt, pvalue->u.dch_and_dsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* hsdsch */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "hsdsch");

         pvalue->u.hsdsch = rtxMemAllocType (pctxt, 
            utran_DL_TransportChannelType_r7_hsdsch);

         if (pvalue->u.hsdsch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_TransportChannelType_r7_hsdsch (pvalue->u.hsdsch);

         stat = asn1PD_utran_DL_TransportChannelType_r7_hsdsch (pctxt, pvalue->u.hsdsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dch_and_hsdsch */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "dch-and-hsdsch");

         pvalue->u.dch_and_hsdsch = rtxMemAllocType (pctxt, 
            utran_DL_TransportChannelType_r7_dch_and_hsdsch);

         if (pvalue->u.dch_and_hsdsch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_TransportChannelType_r7_dch_and_hsdsch (pvalue->u.dch_and_hsdsch);

         stat = asn1PD_utran_DL_TransportChannelType_r7_dch_and_hsdsch (pctxt, pvalue->u.dch_and_hsdsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_LogicalChannelMapping_r7 (OSCTXT* pctxt, utran_DL_LogicalChannelMapping_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-LogicalChannelMapping-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TransportChannelType");

   stat = asn1PD_utran_DL_TransportChannelType_r7 (pctxt, &pvalue->dl_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode logicalChannelIdentity */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelIdentity");

      pvalue->m.logicalChannelIdentityPresent = 1;

      stat = asn1PD_utran_LogicalChannelIdentity (pctxt, &pvalue->logicalChannelIdentity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_LogicalChannelMappingList_r7 (OSCTXT* pctxt, utran_DL_LogicalChannelMappingList_r7* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-LogicalChannelMappingList-r7");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_LogicalChannelMapping_r7* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-LogicalChannelMapping-r7", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_LogicalChannelMapping_r7, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_LogicalChannelMapping_r7 (pdata);

      stat = asn1PD_utran_DL_LogicalChannelMapping_r7 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_MappingOption_r7 (OSCTXT* pctxt, utran_RB_MappingOption_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-MappingOption-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_LogicalChannelMappings */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-LogicalChannelMappings");

      pvalue->m.ul_LogicalChannelMappingsPresent = 1;

      stat = asn1PD_utran_UL_LogicalChannelMappings_r6 (pctxt, &pvalue->ul_LogicalChannelMappings);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_LogicalChannelMappingList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-LogicalChannelMappingList");

      pvalue->m.dl_LogicalChannelMappingListPresent = 1;

      stat = asn1PD_utran_DL_LogicalChannelMappingList_r7 (pctxt, &pvalue->dl_LogicalChannelMappingList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_MappingInfo_r7 (OSCTXT* pctxt, utran_RB_MappingInfo_r7* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-MappingInfo-r7");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_MappingOption_r7* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-MappingOption-r7", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_MappingOption_r7, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_MappingOption_r7 (pdata);

      stat = asn1PD_utran_RB_MappingOption_r7 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationReconfig_r7 (OSCTXT* pctxt, utran_RB_InformationReconfig_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationReconfig-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdcp_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Info");

      pvalue->m.pdcp_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_InfoReconfig_r4 (pctxt, &pvalue->pdcp_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pdcp_SN_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-SN-Info");

      pvalue->m.pdcp_SN_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_SN_Info (pctxt, &pvalue->pdcp_SN_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_Info */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlc-Info");

      pvalue->m.rlc_InfoPresent = 1;

      stat = asn1PD_utran_RLC_Info_r7 (pctxt, &pvalue->rlc_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_MappingInfo */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

      pvalue->m.rb_MappingInfoPresent = 1;

      stat = asn1PD_utran_RB_MappingInfo_r7 (pctxt, &pvalue->rb_MappingInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_StopContinue */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-StopContinue");

      pvalue->m.rb_StopContinuePresent = 1;

      stat = asn1PD_utran_RB_StopContinue (pctxt, &pvalue->rb_StopContinue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationReconfigList_r7 (OSCTXT* pctxt, utran_RB_InformationReconfigList_r7* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationReconfigList-r7");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationReconfig_r7* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationReconfig-r7", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationReconfig_r7, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationReconfig_r7 (pdata);

      stat = asn1PD_utran_RB_InformationReconfig_r7 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationAffected_r7 (OSCTXT* pctxt, utran_RB_InformationAffected_r7* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationAffected-r7");

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_MappingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

   stat = asn1PD_utran_RB_MappingInfo_r7 (pctxt, &pvalue->rb_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationAffectedList_r7 (OSCTXT* pctxt, utran_RB_InformationAffectedList_r7* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationAffectedList-r7");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationAffected_r7* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationAffected-r7", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationAffected_r7, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationAffected_r7 (pdata);

      stat = asn1PD_utran_RB_InformationAffected_r7 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r7_dch_usch (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r7_dch_usch* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ul_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TransportChannelType");

   stat = asn1PD_utran_UL_TrCH_Type (pctxt, &pvalue->ul_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportChannelIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "transportChannelIdentity");

   stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->transportChannelIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportFormatSet */
   RTXCTXTPUSHELEMNAME (pctxt, "transportFormatSet");

   stat = asn1PD_utran_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r7_e_dch_modeSpecific_fdd (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r7_e_dch_modeSpecific_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tti */
   RTXCTXTPUSHELEMNAME (pctxt, "tti");

   stat = asn1PD_utran_E_DCH_TTI (pctxt, &pvalue->tti);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r7_e_dch_modeSpecific (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r7_e_dch_modeSpecific* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocTypeZ (pctxt, 
            utran_UL_AddReconfTransChInformation_r7_e_dch_modeSpecific_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UL_AddReconfTransChInformation_r7_e_dch_modeSpecific_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_MAC_d_FlowRetransTimer (OSCTXT* pctxt, utran_E_DCH_MAC_d_FlowRetransTimer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-MAC-d-FlowRetransTimer");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(29));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode maxMAC_e_PDUContents */
   RTXCTXTPUSHELEMNAME (pctxt, "maxMAC-e-PDUContents");

   stat = pd_ConsUInt16 (pctxt, &pvalue->maxMAC_e_PDUContents, OSUINTCONST(1), OSUINTCONST(19982));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ms2_NonSchedTransmGrantHARQAlloc */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ms2-NonSchedTransmGrantHARQAlloc");

      pvalue->m.ms2_NonSchedTransmGrantHARQAllocPresent = 1;

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

      stat = pd_BitString32 (pctxt, &pvalue->ms2_NonSchedTransmGrantHARQAlloc
         , OSUINTCONST(8), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo (OSCTXT* pctxt, utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo (OSCTXT* pctxt, utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType (OSCTXT* pctxt, utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* non_ScheduledTransGrantInfo */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "non-ScheduledTransGrantInfo");

         pvalue->u.non_ScheduledTransGrantInfo = rtxMemAllocType (pctxt, 
            utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo);

         if (pvalue->u.non_ScheduledTransGrantInfo == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo (pvalue->u.non_ScheduledTransGrantInfo);

         stat = asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo (pctxt, pvalue->u.non_ScheduledTransGrantInfo);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* scheduledTransmissionGrantInfo */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "scheduledTransmissionGrantInfo");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow_r7 (OSCTXT* pctxt, utran_E_DCH_AddReconf_MAC_d_Flow_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-AddReconf-MAC-d-Flow-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_d_FlowIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-d-FlowIdentity");

   stat = asn1PD_utran_E_DCH_MAC_d_FlowIdentity (pctxt, &pvalue->mac_d_FlowIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_d_FlowPowerOffset */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-d-FlowPowerOffset");

      pvalue->m.mac_d_FlowPowerOffsetPresent = 1;

      stat = asn1PD_utran_E_DCH_MAC_d_FlowPowerOffset (pctxt, &pvalue->mac_d_FlowPowerOffset);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mac_d_FlowMaxRetrans */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-d-FlowMaxRetrans");

      pvalue->m.mac_d_FlowMaxRetransPresent = 1;

      stat = asn1PD_utran_E_DCH_MAC_d_FlowMaxRetrans (pctxt, &pvalue->mac_d_FlowMaxRetrans);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mac_d_FlowRetransTimer */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-d-FlowRetransTimer");

      pvalue->m.mac_d_FlowRetransTimerPresent = 1;

      stat = asn1PD_utran_E_DCH_MAC_d_FlowRetransTimer (pctxt, &pvalue->mac_d_FlowRetransTimer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mac_d_FlowMultiplexingList */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-d-FlowMultiplexingList");

      pvalue->m.mac_d_FlowMultiplexingListPresent = 1;

      stat = asn1PD_utran_E_DCH_MAC_d_FlowMultiplexingList (pctxt, &pvalue->mac_d_FlowMultiplexingList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode transmissionGrantType */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "transmissionGrantType");

      pvalue->m.transmissionGrantTypePresent = 1;

      stat = asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType (pctxt, &pvalue->transmissionGrantType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_AddReconf_MAC_d_FlowList_r7 (OSCTXT* pctxt, utran_E_DCH_AddReconf_MAC_d_FlowList_r7* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-AddReconf-MAC-d-FlowList-r7");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_E_DCH_AddReconf_MAC_d_Flow_r7* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "E-DCH-AddReconf-MAC-d-Flow-r7", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_E_DCH_AddReconf_MAC_d_Flow_r7, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow_r7 (pdata);

      stat = asn1PD_utran_E_DCH_AddReconf_MAC_d_Flow_r7 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r7_e_dch (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r7_e_dch* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode modeSpecific */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecific");

   stat = asn1PD_utran_UL_AddReconfTransChInformation_r7_e_dch_modeSpecific (pctxt, &pvalue->modeSpecific);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode harq_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "harq-Info");

   stat = asn1PD_utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info (pctxt, &pvalue->harq_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode addReconf_MAC_d_FlowList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "addReconf-MAC-d-FlowList");

      pvalue->m.addReconf_MAC_d_FlowListPresent = 1;

      stat = asn1PD_utran_E_DCH_AddReconf_MAC_d_FlowList_r7 (pctxt, &pvalue->addReconf_MAC_d_FlowList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r7 (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r7* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-AddReconfTransChInformation-r7");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dch_usch */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dch-usch");

         pvalue->u.dch_usch = rtxMemAllocType (pctxt, 
            utran_UL_AddReconfTransChInformation_r7_dch_usch);

         if (pvalue->u.dch_usch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_AddReconfTransChInformation_r7_dch_usch (pvalue->u.dch_usch);

         stat = asn1PD_utran_UL_AddReconfTransChInformation_r7_dch_usch (pctxt, pvalue->u.dch_usch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* e_dch */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "e-dch");

         pvalue->u.e_dch = rtxMemAllocType (pctxt, 
            utran_UL_AddReconfTransChInformation_r7_e_dch);

         if (pvalue->u.e_dch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_AddReconfTransChInformation_r7_e_dch (pvalue->u.e_dch);

         stat = asn1PD_utran_UL_AddReconfTransChInformation_r7_e_dch (pctxt, pvalue->u.e_dch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInfoList_r7 (OSCTXT* pctxt, utran_UL_AddReconfTransChInfoList_r7* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-AddReconfTransChInfoList-r7");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UL_AddReconfTransChInformation_r7* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-AddReconfTransChInformation-r7", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UL_AddReconfTransChInformation_r7, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UL_AddReconfTransChInformation_r7 (pdata);

      stat = asn1PD_utran_UL_AddReconfTransChInformation_r7 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_TrCH_TypeId2_r7_hsdsch (OSCTXT* pctxt, utran_DL_TrCH_TypeId2_r7_hsdsch* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* mac_hs */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "mac-hs");

         stat = asn1PD_utran_MAC_d_FlowIdentity (pctxt, &pvalue->u.mac_hs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* mac_ehs */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs");

         stat = asn1PD_utran_MAC_ehs_QueueId (pctxt, &pvalue->u.mac_ehs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_TrCH_TypeId2_r7 (OSCTXT* pctxt, utran_DL_TrCH_TypeId2_r7* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-TrCH-TypeId2-r7");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dch */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dch");

         stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->u.dch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dsch */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dsch");

         stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->u.dsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* hsdsch */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "hsdsch");

         pvalue->u.hsdsch = rtxMemAllocType (pctxt, 
            utran_DL_TrCH_TypeId2_r7_hsdsch);

         if (pvalue->u.hsdsch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_TrCH_TypeId2_r7_hsdsch (pvalue->u.hsdsch);

         stat = asn1PD_utran_DL_TrCH_TypeId2_r7_hsdsch (pctxt, pvalue->u.hsdsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_TransportChannelIdentity_r7 (OSCTXT* pctxt, utran_DL_TransportChannelIdentity_r7* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-TransportChannelIdentity-r7");

   /* decode root elements */
   /* decode dl_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TransportChannelType");

   stat = asn1PD_utran_DL_TrCH_TypeId2_r7 (pctxt, &pvalue->dl_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DeletedTransChInfoList_r7 (OSCTXT* pctxt, utran_DL_DeletedTransChInfoList_r7* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DeletedTransChInfoList-r7");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_TransportChannelIdentity_r7* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-TransportChannelIdentity-r7", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_TransportChannelIdentity_r7, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_TransportChannelIdentity_r7 (pdata);

      stat = asn1PD_utran_DL_TransportChannelIdentity_r7 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Treset_ResetTimer (OSCTXT* pctxt, utran_Treset_ResetTimer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Treset-ResetTimer");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_ehs_AddReconfReordQ (OSCTXT* pctxt, utran_MAC_ehs_AddReconfReordQ* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-ehs-AddReconfReordQ");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_ehs_QueueId */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs-QueueId");

   stat = asn1PD_utran_MAC_ehs_QueueId (pctxt, &pvalue->mac_ehs_QueueId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reorderingReleaseTimer */
   RTXCTXTPUSHELEMNAME (pctxt, "reorderingReleaseTimer");

   stat = asn1PD_utran_T1_ReleaseTimer (pctxt, &pvalue->reorderingReleaseTimer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reorderingResetTimer */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "reorderingResetTimer");

      pvalue->m.reorderingResetTimerPresent = 1;

      stat = asn1PD_utran_Treset_ResetTimer (pctxt, &pvalue->reorderingResetTimer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mac_ehsWindowSize */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-ehsWindowSize");

   stat = asn1PD_utran_MAC_hs_WindowSize (pctxt, &pvalue->mac_ehsWindowSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_ehs_AddReconfReordQ_List (OSCTXT* pctxt, utran_MAC_ehs_AddReconfReordQ_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-ehs-AddReconfReordQ-List");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_MAC_ehs_AddReconfReordQ* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MAC-ehs-AddReconfReordQ", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_MAC_ehs_AddReconfReordQ, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_MAC_ehs_AddReconfReordQ (pdata);

      stat = asn1PD_utran_MAC_ehs_AddReconfReordQ (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_ehs_DelReordQ (OSCTXT* pctxt, utran_MAC_ehs_DelReordQ* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-ehs-DelReordQ");

   /* decode root elements */
   /* decode mac_ehs_QueueId */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs-QueueId");

   stat = asn1PD_utran_MAC_ehs_QueueId (pctxt, &pvalue->mac_ehs_QueueId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_ehs_DelReordQ_List (OSCTXT* pctxt, utran_MAC_ehs_DelReordQ_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-ehs-DelReordQ-List");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_MAC_ehs_DelReordQ* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MAC-ehs-DelReordQ", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_MAC_ehs_DelReordQ, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_MAC_ehs_DelReordQ (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AddOrReconfMAC_ehs_ReordQ (OSCTXT* pctxt, utran_AddOrReconfMAC_ehs_ReordQ* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "AddOrReconfMAC-ehs-ReordQ");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_ehs_AddReconfQueue_List */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs-AddReconfQueue-List");

      pvalue->m.mac_ehs_AddReconfQueue_ListPresent = 1;

      stat = asn1PD_utran_MAC_ehs_AddReconfReordQ_List (pctxt, &pvalue->mac_ehs_AddReconfQueue_List);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dummy */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dummy");

      pvalue->m.dummyPresent = 1;

      stat = asn1PD_utran_MAC_ehs_DelReordQ_List (pctxt, &pvalue->dummy);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HSDSCH_Info_r7_dl_MAC_HeaderType (OSCTXT* pctxt, utran_HSDSCH_Info_r7_dl_MAC_HeaderType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* mac_hs */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "mac-hs");

         pvalue->u.mac_hs = rtxMemAllocType (pctxt, 
            utran_AddOrReconfMAC_dFlow);

         if (pvalue->u.mac_hs == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_AddOrReconfMAC_dFlow (pvalue->u.mac_hs);

         stat = asn1PD_utran_AddOrReconfMAC_dFlow (pctxt, pvalue->u.mac_hs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* mac_ehs */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs");

         pvalue->u.mac_ehs = rtxMemAllocType (pctxt, 
            utran_AddOrReconfMAC_ehs_ReordQ);

         if (pvalue->u.mac_ehs == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_AddOrReconfMAC_ehs_ReordQ (pvalue->u.mac_ehs);

         stat = asn1PD_utran_AddOrReconfMAC_ehs_ReordQ (pctxt, pvalue->u.mac_ehs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HSDSCH_Info_r7 (OSCTXT* pctxt, utran_HSDSCH_Info_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "HSDSCH-Info-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode harqInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "harqInfo");

      pvalue->m.harqInfoPresent = 1;

      stat = asn1PD_utran_HARQ_Info_r7 (pctxt, &pvalue->harqInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_MAC_HeaderType */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-MAC-HeaderType");

      pvalue->m.dl_MAC_HeaderTypePresent = 1;

      stat = asn1PD_utran_HSDSCH_Info_r7_dl_MAC_HeaderType (pctxt, &pvalue->dl_MAC_HeaderType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation_r7_tfs_SignallingMode (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation_r7_tfs_SignallingMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* explicit_config */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "explicit-config");

         pvalue->u.explicit_config = rtxMemAllocType (pctxt, 
            utran_TransportFormatSet);

         if (pvalue->u.explicit_config == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TransportFormatSet (pvalue->u.explicit_config);

         stat = asn1PD_utran_TransportFormatSet (pctxt, pvalue->u.explicit_config);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sameAsULTrCH */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsULTrCH");

         pvalue->u.sameAsULTrCH = rtxMemAllocTypeZ (pctxt, 
            utran_UL_TransportChannelIdentity);

         if (pvalue->u.sameAsULTrCH == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UL_TransportChannelIdentity (pctxt, pvalue->u.sameAsULTrCH);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* hsdsch */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "hsdsch");

         pvalue->u.hsdsch = rtxMemAllocType (pctxt, utran_HSDSCH_Info_r7);

         if (pvalue->u.hsdsch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_HSDSCH_Info_r7 (pvalue->u.hsdsch);

         stat = asn1PD_utran_HSDSCH_Info_r7 (pctxt, pvalue->u.hsdsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation_r7 (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInformation-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TransportChannelType");

   stat = asn1PD_utran_DL_TrCH_TypeId1_r5 (pctxt, &pvalue->dl_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfs_SignallingMode */
   RTXCTXTPUSHELEMNAME (pctxt, "tfs-SignallingMode");

   stat = asn1PD_utran_DL_AddReconfTransChInformation_r7_tfs_SignallingMode (pctxt, &pvalue->tfs_SignallingMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dch_QualityTarget */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dch-QualityTarget");

      pvalue->m.dch_QualityTargetPresent = 1;

      stat = asn1PD_utran_QualityTarget (pctxt, &pvalue->dch_QualityTarget);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInfoList_r7 (OSCTXT* pctxt, utran_DL_AddReconfTransChInfoList_r7* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInfoList-r7");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_AddReconfTransChInformation_r7* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-AddReconfTransChInformation-r7", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_AddReconfTransChInformation_r7, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_AddReconfTransChInformation_r7 (pdata);

      stat = asn1PD_utran_DL_AddReconfTransChInformation_r7 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UpPCHposition_LCR (OSCTXT* pctxt, utran_UpPCHposition_LCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UpPCHposition-LCR");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Multi_frequencyInfo_LCR_r7 (OSCTXT* pctxt, utran_Multi_frequencyInfo_LCR_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "Multi-frequencyInfo-LCR-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode secondFrequencyInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "secondFrequencyInfo");

      pvalue->m.secondFrequencyInfoPresent = 1;

      stat = asn1PD_utran_FrequencyInfoTDD (pctxt, &pvalue->secondFrequencyInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode fPachFrequencyInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "fPachFrequencyInfo");

      pvalue->m.fPachFrequencyInfoPresent = 1;

      stat = asn1PD_utran_FrequencyInfoTDD (pctxt, &pvalue->fPachFrequencyInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode upPCHpositionInfo */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "upPCHpositionInfo");

      pvalue->m.upPCHpositionInfoPresent = 1;

      stat = asn1PD_utran_UpPCHposition_LCR (pctxt, &pvalue->upPCHpositionInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r7_fdd (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r7_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dpcch_PowerOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "dpcch-PowerOffset");

   stat = asn1PD_utran_DPCCH_PowerOffset (pctxt, &pvalue->dpcch_PowerOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pc_Preamble */
   RTXCTXTPUSHELEMNAME (pctxt, "pc-Preamble");

   stat = asn1PD_utran_PC_Preamble (pctxt, &pvalue->pc_Preamble);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sRB_delay */
   RTXCTXTPUSHELEMNAME (pctxt, "sRB-delay");

   stat = asn1PD_utran_SRB_delay (pctxt, &pvalue->sRB_delay);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerControlAlgorithm */
   RTXCTXTPUSHELEMNAME (pctxt, "powerControlAlgorithm");

   stat = asn1PD_utran_PowerControlAlgorithm (pctxt, &pvalue->powerControlAlgorithm);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaACK */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaACK");

      pvalue->m.deltaACKPresent = 1;

      stat = asn1PD_utran_DeltaACK (pctxt, &pvalue->deltaACK);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode deltaNACK */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaNACK");

      pvalue->m.deltaNACKPresent = 1;

      stat = asn1PD_utran_DeltaNACK (pctxt, &pvalue->deltaNACK);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ack_NACK_repetition_factor */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ack-NACK-repetition-factor");

      pvalue->m.ack_NACK_repetition_factorPresent = 1;

      stat = asn1PD_utran_ACK_NACK_repetitionFactor (pctxt, &pvalue->ack_NACK_repetition_factor);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode harq_Preamble_Mode */
   RTXCTXTPUSHELEMNAME (pctxt, "harq-Preamble-Mode");

   stat = asn1PD_utran_HARQ_Preamble_Mode (pctxt, &pvalue->harq_Preamble_Mode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTS_InterferenceList */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTS-InterferenceList");

   stat = asn1PD_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpch_ConstantValue */
   RTXCTXTPUSHELEMNAME (pctxt, "dpch-ConstantValue");

   stat = asn1PD_utran_ConstantValue (pctxt, &pvalue->dpch_ConstantValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTS_InterferenceList */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTS-InterferenceList");

   stat = asn1PD_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpch_ConstantValue */
   RTXCTXTPUSHELEMNAME (pctxt, "dpch-ConstantValue");

   stat = asn1PD_utran_ConstantValue (pctxt, &pvalue->dpch_ConstantValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode beaconPLEst */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "beaconPLEst");

      pvalue->m.beaconPLEstPresent = 1;

      stat = asn1PD_utran_BEACON_PL_Est (pctxt, &pvalue->beaconPLEst);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tpc_StepSize */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-StepSize");

   stat = asn1PD_utran_TPC_StepSizeTDD (pctxt, &pvalue->tpc_StepSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         pvalue->u.tdd768 = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768);

         if (pvalue->u.tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768 (pvalue->u.tdd768);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768 (pctxt, pvalue->u.tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode primaryCCPCH_TX_Power */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCCPCH-TX-Power");

   stat = asn1PD_utran_PrimaryCCPCH_TX_Power (pctxt, &pvalue->primaryCCPCH_TX_Power);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* broadcast_UL_OL_PC_info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "broadcast-UL-OL-PC-info");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* individuallySignalled */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "individuallySignalled");

         pvalue->u.individuallySignalled = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled);

         if (pvalue->u.individuallySignalled == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled (pvalue->u.individuallySignalled);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled (pctxt, pvalue->u.individuallySignalled);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r7_tdd (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r7_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TargetSIR */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TargetSIR");

      pvalue->m.ul_TargetSIRPresent = 1;

      stat = asn1PD_utran_UL_TargetSIR (pctxt, &pvalue->ul_TargetSIR);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_OL_PC_Signalling */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-OL-PC-Signalling");

   stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling (pctxt, &pvalue->ul_OL_PC_Signalling);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r7 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r7* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-PowerControlInfo-r7");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r7_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r7_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r7_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r7_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r7_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r7_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_NumberOfTPC_Bits (OSCTXT* pctxt, utran_NumberOfTPC_Bits* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "NumberOfTPC-Bits");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_tpc4; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence_present (OSCTXT* pctxt, utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence_present* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode numberOfDPDCH */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfDPDCH");

      stat = asn1PD_utran_NumberOfDPDCH (pctxt, &pvalue->numberOfDPDCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->numberOfDPDCH = 1;
   }

   /* decode spreadingFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactor");

   stat = asn1PD_utran_SpreadingFactor (pctxt, &pvalue->spreadingFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfFBI_Bits */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfFBI-Bits");

      pvalue->m.numberOfFBI_BitsPresent = 1;

      stat = asn1PD_utran_NumberOfFBI_Bits (pctxt, &pvalue->numberOfFBI_Bits);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode numberOfTPC_Bits */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfTPC-Bits");

      pvalue->m.numberOfTPC_BitsPresent = 1;

      stat = asn1PD_utran_NumberOfTPC_Bits (pctxt, &pvalue->numberOfTPC_Bits);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode puncturingLimit */
   RTXCTXTPUSHELEMNAME (pctxt, "puncturingLimit");

   stat = asn1PD_utran_PuncturingLimit (pctxt, &pvalue->puncturingLimit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence_notPresent (OSCTXT* pctxt, utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence_notPresent* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfFBI_Bits */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfFBI-Bits");

      pvalue->m.numberOfFBI_BitsPresent = 1;

      stat = asn1PD_utran_NumberOfFBI_Bits (pctxt, &pvalue->numberOfFBI_Bits);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode numberOfTPC_Bits */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfTPC-Bits");

      pvalue->m.numberOfTPC_BitsPresent = 1;

      stat = asn1PD_utran_NumberOfTPC_Bits (pctxt, &pvalue->numberOfTPC_Bits);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence (OSCTXT* pctxt, utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* present */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "present");

         pvalue->u.present = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence_present);

         if (pvalue->u.present == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence_present (pvalue->u.present);

         stat = asn1PD_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence_present (pctxt, pvalue->u.present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* notPresent */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "notPresent");

         pvalue->u.notPresent = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence_notPresent);

         if (pvalue->u.notPresent == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence_notPresent (pvalue->u.notPresent);

         stat = asn1PD_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence_notPresent (pctxt, pvalue->u.notPresent);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode scramblingCodeType */
   RTXCTXTPUSHELEMNAME (pctxt, "scramblingCodeType");

   stat = asn1PD_utran_ScramblingCodeType (pctxt, &pvalue->scramblingCodeType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode scramblingCode */
   RTXCTXTPUSHELEMNAME (pctxt, "scramblingCode");

   stat = asn1PD_utran_UL_ScramblingCode (pctxt, &pvalue->scramblingCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpdchPresence */
   RTXCTXTPUSHELEMNAME (pctxt, "dpdchPresence");

   stat = asn1PD_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence (pctxt, &pvalue->dpdchPresence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_EXT_UL_TimingAdvance_modeSpecificInfo_tdd384 (OSCTXT* pctxt, utran_EXT_UL_TimingAdvance_modeSpecificInfo_tdd384* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ex_ul_TimingAdvance */
   RTXCTXTPUSHELEMNAME (pctxt, "ex-ul-TimingAdvance");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ex_ul_TimingAdvance, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_EXT_UL_TimingAdvance_modeSpecificInfo_tdd768 (OSCTXT* pctxt, utran_EXT_UL_TimingAdvance_modeSpecificInfo_tdd768* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ex_ul_TimingAdvance */
   RTXCTXTPUSHELEMNAME (pctxt, "ex-ul-TimingAdvance");

   stat = pd_ConsUInt16 (pctxt, &pvalue->ex_ul_TimingAdvance, OSUINTCONST(0), OSUINTCONST(511));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_EXT_UL_TimingAdvance_modeSpecificInfo (OSCTXT* pctxt, utran_EXT_UL_TimingAdvance_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocTypeZ (pctxt, 
            utran_EXT_UL_TimingAdvance_modeSpecificInfo_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_EXT_UL_TimingAdvance_modeSpecificInfo_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         pvalue->u.tdd768 = rtxMemAllocTypeZ (pctxt, 
            utran_EXT_UL_TimingAdvance_modeSpecificInfo_tdd768);

         if (pvalue->u.tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_EXT_UL_TimingAdvance_modeSpecificInfo_tdd768 (pctxt, pvalue->u.tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_EXT_UL_TimingAdvance (OSCTXT* pctxt, utran_EXT_UL_TimingAdvance* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EXT-UL-TimingAdvance");

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_EXT_UL_TimingAdvance_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd384 (OSCTXT* pctxt, utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd384* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TimingAdvance */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TimingAdvance");

      pvalue->m.ul_TimingAdvancePresent = 1;

      stat = asn1PD_utran_UL_TimingAdvance (pctxt, &pvalue->ul_TimingAdvance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ext_UL_TimingAdvance */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ext-UL-TimingAdvance");

      pvalue->m.ext_UL_TimingAdvancePresent = 1;

      stat = asn1PD_utran_EXT_UL_TimingAdvance (pctxt, &pvalue->ext_UL_TimingAdvance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode activationTime */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "activationTime");

      pvalue->m.activationTimePresent = 1;

      stat = asn1PD_utran_ActivationTime (pctxt, &pvalue->activationTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd768 (OSCTXT* pctxt, utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd768* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ext_UL_TimingAdvance */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ext-UL-TimingAdvance");

      pvalue->m.ext_UL_TimingAdvancePresent = 1;

      stat = asn1PD_utran_EXT_UL_TimingAdvance (pctxt, &pvalue->ext_UL_TimingAdvance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode activationTime */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "activationTime");

      pvalue->m.activationTimePresent = 1;

      stat = asn1PD_utran_ActivationTime (pctxt, &pvalue->activationTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd128 (OSCTXT* pctxt, utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_SynchronisationParameters */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-SynchronisationParameters");

      pvalue->m.ul_SynchronisationParametersPresent = 1;

      stat = asn1PD_utran_UL_SynchronisationParameters_r4 (pctxt, &pvalue->ul_SynchronisationParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode synchronisationParameters */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "synchronisationParameters");

      pvalue->m.synchronisationParametersPresent = 1;

      stat = asn1PD_utran_SynchronisationParameters_r4 (pctxt, &pvalue->synchronisationParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl_r7_enabled_tddOption (OSCTXT* pctxt, utran_UL_TimingAdvanceControl_r7_enabled_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         pvalue->u.tdd768 = rtxMemAllocType (pctxt, 
            utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd768);

         if (pvalue->u.tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd768 (pvalue->u.tdd768);

         stat = asn1PD_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd768 (pctxt, pvalue->u.tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl_r7_enabled (OSCTXT* pctxt, utran_UL_TimingAdvanceControl_r7_enabled* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_UL_TimingAdvanceControl_r7_enabled_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl_r7 (OSCTXT* pctxt, utran_UL_TimingAdvanceControl_r7* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-TimingAdvanceControl-r7");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* disabled */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "disabled");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* enabled */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "enabled");

         pvalue->u.enabled = rtxMemAllocType (pctxt, 
            utran_UL_TimingAdvanceControl_r7_enabled);

         if (pvalue->u.enabled == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_TimingAdvanceControl_r7_enabled (pvalue->u.enabled);

         stat = asn1PD_utran_UL_TimingAdvanceControl_r7_enabled (pctxt, pvalue->u.enabled);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CCTrCH_r7_tddOption_tdd384 (OSCTXT* pctxt, utran_UL_CCTrCH_r7_tddOption_tdd384* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_CCTrCH_TimeslotsCodes */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCH-TimeslotsCodes");

      pvalue->m.ul_CCTrCH_TimeslotsCodesPresent = 1;

      stat = asn1PD_utran_UplinkTimeslotsCodes (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode_ueSpecificMidamble (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode_ueSpecificMidamble* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleShift */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShift");

   stat = asn1PD_utran_MidambleShiftLong (pctxt, &pvalue->midambleShift);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* defaultMidamble */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* commonMidamble */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "commonMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueSpecificMidamble */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "ueSpecificMidamble");

         pvalue->u.ueSpecificMidamble = rtxMemAllocTypeZ (pctxt, 
            utran_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode_ueSpecificMidamble);

         if (pvalue->u.ueSpecificMidamble == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode_ueSpecificMidamble (pctxt, pvalue->u.ueSpecificMidamble);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type1 (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_VHCR_burstType_type1* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleConfigurationBurstType1and3 */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfigurationBurstType1and3");

   stat = asn1PD_utran_MidambleConfigurationBurstType1and3 (pctxt, &pvalue->midambleConfigurationBurstType1and3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleAllocationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode_ueSpecificMidamble (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode_ueSpecificMidamble* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleShift */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShift");

   stat = asn1PD_utran_MidambleShiftShort_VHCR (pctxt, &pvalue->midambleShift);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* defaultMidamble */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* commonMidamble */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "commonMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueSpecificMidamble */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "ueSpecificMidamble");

         pvalue->u.ueSpecificMidamble = rtxMemAllocTypeZ (pctxt, 
            utran_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode_ueSpecificMidamble);

         if (pvalue->u.ueSpecificMidamble == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode_ueSpecificMidamble (pctxt, pvalue->u.ueSpecificMidamble);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type2 (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_VHCR_burstType_type2* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleConfigurationBurstType2 */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfigurationBurstType2");

   stat = asn1PD_utran_MidambleConfigurationBurstType2_VHCR (pctxt, &pvalue->midambleConfigurationBurstType2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleAllocationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode_ueSpecificMidamble (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode_ueSpecificMidamble* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleShift */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShift");

   stat = asn1PD_utran_MidambleShiftLong (pctxt, &pvalue->midambleShift);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* defaultMidamble */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueSpecificMidamble */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ueSpecificMidamble");

         pvalue->u.ueSpecificMidamble = rtxMemAllocTypeZ (pctxt, 
            utran_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode_ueSpecificMidamble);

         if (pvalue->u.ueSpecificMidamble == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode_ueSpecificMidamble (pctxt, pvalue->u.ueSpecificMidamble);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type3 (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_VHCR_burstType_type3* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleConfigurationBurstType1and3 */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfigurationBurstType1and3");

   stat = asn1PD_utran_MidambleConfigurationBurstType1and3 (pctxt, &pvalue->midambleConfigurationBurstType1and3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleAllocationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_VHCR_burstType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* type1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "type1");

         pvalue->u.type1 = rtxMemAllocType (pctxt, 
            utran_MidambleShiftAndBurstType_VHCR_burstType_type1);

         if (pvalue->u.type1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_MidambleShiftAndBurstType_VHCR_burstType_type1 (pvalue->u.type1);

         stat = asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type1 (pctxt, pvalue->u.type1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* type2 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "type2");

         pvalue->u.type2 = rtxMemAllocType (pctxt, 
            utran_MidambleShiftAndBurstType_VHCR_burstType_type2);

         if (pvalue->u.type2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_MidambleShiftAndBurstType_VHCR_burstType_type2 (pvalue->u.type2);

         stat = asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type2 (pctxt, pvalue->u.type2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* type3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "type3");

         pvalue->u.type3 = rtxMemAllocType (pctxt, 
            utran_MidambleShiftAndBurstType_VHCR_burstType_type3);

         if (pvalue->u.type3 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_MidambleShiftAndBurstType_VHCR_burstType_type3 (pvalue->u.type3);

         stat = asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType_type3 (pctxt, pvalue->u.type3);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* mbsfnBurstType4 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "mbsfnBurstType4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_VHCR (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_VHCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MidambleShiftAndBurstType-VHCR");

   /* decode root elements */
   /* decode burstType */
   RTXCTXTPUSHELEMNAME (pctxt, "burstType");

   stat = asn1PD_utran_MidambleShiftAndBurstType_VHCR_burstType (pctxt, &pvalue->burstType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_IndividualTimeslotInfo_VHCR (OSCTXT* pctxt, utran_IndividualTimeslotInfo_VHCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IndividualTimeslotInfo-VHCR");

   /* decode root elements */
   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleShiftAndBurstType_VHCR */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShiftAndBurstType-VHCR");

   stat = asn1PD_utran_MidambleShiftAndBurstType_VHCR (pctxt, &pvalue->midambleShiftAndBurstType_VHCR);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TS_ChannelisationCode_VHCR (OSCTXT* pctxt, utran_UL_TS_ChannelisationCode_VHCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-TS-ChannelisationCode-VHCR");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(62));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TS_ChannelisationCodeList_VHCR (OSCTXT* pctxt, utran_UL_TS_ChannelisationCodeList_VHCR* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-TS-ChannelisationCodeList-VHCR");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 2) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-TS-ChannelisationCode-VHCR", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_UL_TS_ChannelisationCode_VHCR));
      stat = asn1PD_utran_UL_TS_ChannelisationCode_VHCR (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_consecutive (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_consecutive* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode numAdditionalTimeslots */
   RTXCTXTPUSHELEMNAME (pctxt, "numAdditionalTimeslots");

   stat = pd_ConsUInt8 (pctxt, &pvalue->numAdditionalTimeslots, OSUINTCONST(1), OSUINTCONST(13));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_VHCR_parameters_sameAsLast (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_VHCR_parameters_sameAsLast* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_VHCR_parameters_newParameters (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_VHCR_parameters_newParameters* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTimeslotInfo");

   stat = asn1PD_utran_IndividualTimeslotInfo_VHCR (pctxt, &pvalue->individualTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TS_ChannelisationCodeList */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TS-ChannelisationCodeList");

   stat = asn1PD_utran_UL_TS_ChannelisationCodeList (pctxt, &pvalue->ul_TS_ChannelisationCodeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_VHCR_parameters (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_VHCR_parameters* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* sameAsLast */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsLast");

         pvalue->u.sameAsLast = rtxMemAllocTypeZ (pctxt, 
            utran_UplinkAdditionalTimeslots_VHCR_parameters_sameAsLast);

         if (pvalue->u.sameAsLast == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UplinkAdditionalTimeslots_VHCR_parameters_sameAsLast (pctxt, pvalue->u.sameAsLast);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* newParameters */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "newParameters");

         pvalue->u.newParameters = rtxMemAllocType (pctxt, 
            utran_UplinkAdditionalTimeslots_VHCR_parameters_newParameters);

         if (pvalue->u.newParameters == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UplinkAdditionalTimeslots_VHCR_parameters_newParameters (pvalue->u.newParameters);

         stat = asn1PD_utran_UplinkAdditionalTimeslots_VHCR_parameters_newParameters (pctxt, pvalue->u.newParameters);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_VHCR (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_VHCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkAdditionalTimeslots-VHCR");

   /* decode root elements */
   /* decode parameters */
   RTXCTXTPUSHELEMNAME (pctxt, "parameters");

   stat = asn1PD_utran_UplinkAdditionalTimeslots_VHCR_parameters (pctxt, &pvalue->parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(13), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UplinkAdditionalTimeslots_VHCR* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UplinkAdditionalTimeslots-VHCR", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UplinkAdditionalTimeslots_VHCR, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UplinkAdditionalTimeslots_VHCR (pdata);

      stat = asn1PD_utran_UplinkAdditionalTimeslots_VHCR (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* consecutive */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "consecutive");

         pvalue->u.consecutive = rtxMemAllocTypeZ (pctxt, 
            utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_consecutive);

         if (pvalue->u.consecutive == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_consecutive (pctxt, pvalue->u.consecutive);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* timeslotList */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "timeslotList");

         pvalue->u.timeslotList = rtxMemAllocType (pctxt, 
            utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList);

         if (pvalue->u.timeslotList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList (pvalue->u.timeslotList);

         stat = asn1PD_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList (pctxt, pvalue->u.timeslotList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_VHCR_moreTimeslots* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* noMore */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "noMore");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* additionalTimeslots */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "additionalTimeslots");

         pvalue->u.additionalTimeslots = rtxMemAllocType (pctxt, 
            utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots);

         if (pvalue->u.additionalTimeslots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots (pvalue->u.additionalTimeslots);

         stat = asn1PD_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots (pctxt, pvalue->u.additionalTimeslots);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_VHCR (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_VHCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkTimeslotsCodes-VHCR");

   /* decode root elements */
   /* decode dynamicSFusage */
   RTXCTXTPUSHELEMNAME (pctxt, "dynamicSFusage");

   stat = DEC_BIT (pctxt, &pvalue->dynamicSFusage);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode firstIndividualTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "firstIndividualTimeslotInfo");

   stat = asn1PD_utran_IndividualTimeslotInfo_VHCR (pctxt, &pvalue->firstIndividualTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TS_ChannelisationCodeList */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TS-ChannelisationCodeList");

   stat = asn1PD_utran_UL_TS_ChannelisationCodeList_VHCR (pctxt, &pvalue->ul_TS_ChannelisationCodeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode moreTimeslots */
   RTXCTXTPUSHELEMNAME (pctxt, "moreTimeslots");

   stat = asn1PD_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots (pctxt, &pvalue->moreTimeslots);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CCTrCH_r7_tddOption_tdd768 (OSCTXT* pctxt, utran_UL_CCTrCH_r7_tddOption_tdd768* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_CCTrCH_TimeslotsCodes */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCH-TimeslotsCodes");

      pvalue->m.ul_CCTrCH_TimeslotsCodesPresent = 1;

      stat = asn1PD_utran_UplinkTimeslotsCodes_VHCR (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TPC_CommandTargetRate (OSCTXT* pctxt, utran_TPC_CommandTargetRate* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TPC-CommandTargetRate");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PLCCH_Info (OSCTXT* pctxt, utran_PLCCH_Info* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PLCCH-Info");

   /* decode root elements */
   /* decode plcchSequenceNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "plcchSequenceNumber");

   stat = pd_ConsUInt8 (pctxt, &pvalue->plcchSequenceNumber, OSUINTCONST(1), OSUINTCONST(14));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber_LCR_r4 (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode channelisationCode */
   RTXCTXTPUSHELEMNAME (pctxt, "channelisationCode");

   stat = asn1PD_utran_DL_TS_ChannelisationCode (pctxt, &pvalue->channelisationCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tpcCommandTargetRate */
   RTXCTXTPUSHELEMNAME (pctxt, "tpcCommandTargetRate");

   stat = asn1PD_utran_TPC_CommandTargetRate (pctxt, &pvalue->tpcCommandTargetRate);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TS_ChannelisationCodeList_r7_element (OSCTXT* pctxt, utran_UL_TS_ChannelisationCodeList_r7_element* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TS_Channelisation_Code */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TS-Channelisation-Code");

   stat = asn1PD_utran_UL_TS_ChannelisationCode (pctxt, &pvalue->ul_TS_Channelisation_Code);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode plcch_info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "plcch-info");

      pvalue->m.plcch_infoPresent = 1;

      stat = asn1PD_utran_PLCCH_Info (pctxt, &pvalue->plcch_info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_TS_ChannelisationCodeList_r7 (OSCTXT* pctxt, utran_UL_TS_ChannelisationCodeList_r7* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-TS-ChannelisationCodeList-r7");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UL_TS_ChannelisationCodeList_r7_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UL_TS_ChannelisationCodeList_r7_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UL_TS_ChannelisationCodeList_r7_element (pdata);

      stat = asn1PD_utran_UL_TS_ChannelisationCodeList_r7_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots_consecutive (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots_consecutive* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode numAdditionalTimeslots */
   RTXCTXTPUSHELEMNAME (pctxt, "numAdditionalTimeslots");

   stat = pd_ConsUInt8 (pctxt, &pvalue->numAdditionalTimeslots, OSUINTCONST(1), OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_LCR_r7_parameters_sameAsLast (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_LCR_r7_parameters_sameAsLast* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_LCR_r7_parameters_newParameters (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_LCR_r7_parameters_newParameters* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTimeslotInfo");

   stat = asn1PD_utran_IndividualTimeslotInfo_LCR_r4 (pctxt, &pvalue->individualTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TS_ChannelisationCodeList */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TS-ChannelisationCodeList");

   stat = asn1PD_utran_UL_TS_ChannelisationCodeList_r7 (pctxt, &pvalue->ul_TS_ChannelisationCodeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_LCR_r7_parameters (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_LCR_r7_parameters* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* sameAsLast */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsLast");

         pvalue->u.sameAsLast = rtxMemAllocTypeZ (pctxt, 
            utran_UplinkAdditionalTimeslots_LCR_r7_parameters_sameAsLast);

         if (pvalue->u.sameAsLast == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UplinkAdditionalTimeslots_LCR_r7_parameters_sameAsLast (pctxt, pvalue->u.sameAsLast);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* newParameters */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "newParameters");

         pvalue->u.newParameters = rtxMemAllocType (pctxt, 
            utran_UplinkAdditionalTimeslots_LCR_r7_parameters_newParameters);

         if (pvalue->u.newParameters == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UplinkAdditionalTimeslots_LCR_r7_parameters_newParameters (pvalue->u.newParameters);

         stat = asn1PD_utran_UplinkAdditionalTimeslots_LCR_r7_parameters_newParameters (pctxt, pvalue->u.newParameters);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkAdditionalTimeslots_LCR_r7 (OSCTXT* pctxt, utran_UplinkAdditionalTimeslots_LCR_r7* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkAdditionalTimeslots-LCR-r7");

   /* decode root elements */
   /* decode parameters */
   RTXCTXTPUSHELEMNAME (pctxt, "parameters");

   stat = asn1PD_utran_UplinkAdditionalTimeslots_LCR_r7_parameters (pctxt, &pvalue->parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots_timeslotList (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(5), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UplinkAdditionalTimeslots_LCR_r7* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UplinkAdditionalTimeslots-LCR-r7", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UplinkAdditionalTimeslots_LCR_r7, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UplinkAdditionalTimeslots_LCR_r7 (pdata);

      stat = asn1PD_utran_UplinkAdditionalTimeslots_LCR_r7 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* consecutive */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "consecutive");

         pvalue->u.consecutive = rtxMemAllocTypeZ (pctxt, 
            utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots_consecutive);

         if (pvalue->u.consecutive == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots_consecutive (pctxt, pvalue->u.consecutive);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* timeslotList */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "timeslotList");

         pvalue->u.timeslotList = rtxMemAllocType (pctxt, 
            utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots_timeslotList);

         if (pvalue->u.timeslotList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots_timeslotList (pvalue->u.timeslotList);

         stat = asn1PD_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots_timeslotList (pctxt, pvalue->u.timeslotList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* noMore */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "noMore");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* additionalTimeslots */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "additionalTimeslots");

         pvalue->u.additionalTimeslots = rtxMemAllocType (pctxt, 
            utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots);

         if (pvalue->u.additionalTimeslots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots (pvalue->u.additionalTimeslots);

         stat = asn1PD_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots (pctxt, pvalue->u.additionalTimeslots);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UplinkTimeslotsCodes_LCR_r7 (OSCTXT* pctxt, utran_UplinkTimeslotsCodes_LCR_r7* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkTimeslotsCodes-LCR-r7");

   /* decode root elements */
   /* decode dynamicSFusage */
   RTXCTXTPUSHELEMNAME (pctxt, "dynamicSFusage");

   stat = DEC_BIT (pctxt, &pvalue->dynamicSFusage);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode firstIndividualTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "firstIndividualTimeslotInfo");

   stat = asn1PD_utran_IndividualTimeslotInfo_LCR_r4 (pctxt, &pvalue->firstIndividualTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TS_ChannelisationCodeList */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TS-ChannelisationCodeList");

   stat = asn1PD_utran_UL_TS_ChannelisationCodeList_r7 (pctxt, &pvalue->ul_TS_ChannelisationCodeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode moreTimeslots */
   RTXCTXTPUSHELEMNAME (pctxt, "moreTimeslots");

   stat = asn1PD_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots (pctxt, &pvalue->moreTimeslots);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CCTrCH_r7_tddOption_tdd128 (OSCTXT* pctxt, utran_UL_CCTrCH_r7_tddOption_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_CCTrCH_TimeslotsCodes */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCH-TimeslotsCodes");

      pvalue->m.ul_CCTrCH_TimeslotsCodesPresent = 1;

      stat = asn1PD_utran_UplinkTimeslotsCodes_LCR_r7 (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_CCTrCH_r7_tddOption (OSCTXT* pctxt, utran_UL_CCTrCH_r7_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_UL_CCTrCH_r7_tddOption_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_CCTrCH_r7_tddOption_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_UL_CCTrCH_r7_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         pvalue->u.tdd768 = rtxMemAllocType (pctxt, 
            utran_UL_CCTrCH_r7_tddOption_tdd768);

         if (pvalue->u.tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_CCTrCH_r7_tddOption_tdd768 (pvalue->u.tdd768);

         stat = asn1PD_utran_UL_CCTrCH_r7_tddOption_tdd768 (pctxt, pvalue->u.tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_UL_CCTrCH_r7_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_CCTrCH_r7_tddOption_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_UL_CCTrCH_r7_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_CCTrCH_r7 (OSCTXT* pctxt, utran_UL_CCTrCH_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CCTrCH-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tfcs_ID */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tfcs-ID");

      stat = asn1PD_utran_TFCS_IdentityPlain (pctxt, &pvalue->tfcs_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->tfcs_ID = 1;
   }

   /* decode ul_TargetSIR */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TargetSIR");

   stat = asn1PD_utran_UL_TargetSIR (pctxt, &pvalue->ul_TargetSIR);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "timeInfo");

   stat = asn1PD_utran_TimeInfo (pctxt, &pvalue->timeInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode commonTimeslotInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "commonTimeslotInfo");

      pvalue->m.commonTimeslotInfoPresent = 1;

      stat = asn1PD_utran_CommonTimeslotInfo (pctxt, &pvalue->commonTimeslotInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_UL_CCTrCH_r7_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CCTrCHList_r7 (OSCTXT* pctxt, utran_UL_CCTrCHList_r7* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CCTrCHList-r7");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UL_CCTrCH_r7* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-CCTrCH-r7", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UL_CCTrCH_r7, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UL_CCTrCH_r7 (pdata);

      stat = asn1PD_utran_UL_CCTrCH_r7 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r7_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_UL_DPCH_Info_r7_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TimingAdvance */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TimingAdvance");

      pvalue->m.ul_TimingAdvancePresent = 1;

      stat = asn1PD_utran_UL_TimingAdvanceControl_r7 (pctxt, &pvalue->ul_TimingAdvance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCHList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCHList");

      pvalue->m.ul_CCTrCHListPresent = 1;

      stat = asn1PD_utran_UL_CCTrCHList_r7 (pctxt, &pvalue->ul_CCTrCHList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCHListToRemove */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCHListToRemove");

      pvalue->m.ul_CCTrCHListToRemovePresent = 1;

      stat = asn1PD_utran_UL_CCTrCHListToRemove (pctxt, &pvalue->ul_CCTrCHListToRemove);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r7_modeSpecificInfo (OSCTXT* pctxt, utran_UL_DPCH_Info_r7_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r7_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r7_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_DPCH_Info_r7_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r7 (OSCTXT* pctxt, utran_UL_DPCH_Info_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-Info-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-DPCH-PowerControlInfo");

      pvalue->m.ul_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r7 (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_UL_DPCH_Info_r7_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator (OSCTXT* pctxt, utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__304; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_DPCCH_Info_r7 (OSCTXT* pctxt, utran_E_DPCCH_Info_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "E-DPCCH-Info-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_DPCCH_DPCCH_PowerOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "e-DPCCH-DPCCH-PowerOffset");

   stat = asn1PD_utran_E_DPCCH_DPCCH_PowerOffset (pctxt, &pvalue->e_DPCCH_DPCCH_PowerOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode happyBit_DelayCondition */
   RTXCTXTPUSHELEMNAME (pctxt, "happyBit-DelayCondition");

   stat = asn1PD_utran_HappyBit_DelayCondition (pctxt, &pvalue->happyBit_DelayCondition);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_TFC_Boost_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-TFC-Boost-Info");

      pvalue->m.e_TFC_Boost_InfoPresent = 1;

      stat = asn1PD_utran_E_TFC_Boost_Info_r7 (pctxt, &pvalue->e_TFC_Boost_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_DPDCH_PowerInterpolation */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-DPDCH-PowerInterpolation");

      pvalue->m.e_DPDCH_PowerInterpolationPresent = 1;

      stat = asn1PD_utran_E_DPDCH_PowerInterpolation (pctxt, &pvalue->e_DPDCH_PowerInterpolation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DPDCH_Info_r7 (OSCTXT* pctxt, utran_E_DPDCH_Info_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "E-DPDCH-Info-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_TFCI_TableIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "e-TFCI-TableIndex");

   stat = asn1PD_utran_E_TFCI_TableIndex (pctxt, &pvalue->e_TFCI_TableIndex);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_DCH_MinimumSet_E_TFCI */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-DCH-MinimumSet-E-TFCI");

      pvalue->m.e_DCH_MinimumSet_E_TFCIPresent = 1;

      stat = asn1PD_utran_E_DCH_MinimumSet_E_TFCI (pctxt, &pvalue->e_DCH_MinimumSet_E_TFCI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode reference_E_TFCIs */
   RTXCTXTPUSHELEMNAME (pctxt, "reference-E-TFCIs");

   stat = asn1PD_utran_E_DPDCH_Reference_E_TFCIList_r7 (pctxt, &pvalue->reference_E_TFCIs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maxChannelisationCodes */
   RTXCTXTPUSHELEMNAME (pctxt, "maxChannelisationCodes");

   stat = asn1PD_utran_E_DPDCH_MaxChannelisationCodes (pctxt, &pvalue->maxChannelisationCodes);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pl_NonMax */
   RTXCTXTPUSHELEMNAME (pctxt, "pl-NonMax");

   stat = asn1PD_utran_E_DPDCH_PL_NonMax (pctxt, &pvalue->pl_NonMax);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode schedulingInfoConfiguration */
   RTXCTXTPUSHELEMNAME (pctxt, "schedulingInfoConfiguration");

   stat = asn1PD_utran_E_DPDCH_SchedulingInfoConfiguration (pctxt, &pvalue->schedulingInfoConfiguration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threeIndexStepThreshold */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "threeIndexStepThreshold");

      pvalue->m.threeIndexStepThresholdPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->threeIndexStepThreshold, OSUINTCONST(0), OSUINTCONST(37));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode twoIndexStepThreshold */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "twoIndexStepThreshold");

      pvalue->m.twoIndexStepThresholdPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->twoIndexStepThreshold, OSUINTCONST(0), OSUINTCONST(37));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r7_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_UL_EDCH_Information_r7_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_DPCCH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-DPCCH-Info");

      pvalue->m.e_DPCCH_InfoPresent = 1;

      stat = asn1PD_utran_E_DPCCH_Info_r7 (pctxt, &pvalue->e_DPCCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_DPDCH_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-DPDCH-Info");

      pvalue->m.e_DPDCH_InfoPresent = 1;

      stat = asn1PD_utran_E_DPDCH_Info_r7 (pctxt, &pvalue->e_DPDCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode schedulingTransmConfiguration */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "schedulingTransmConfiguration");

      pvalue->m.schedulingTransmConfigurationPresent = 1;

      stat = asn1PD_utran_E_DPDCH_SchedulingTransmConfiguration (pctxt, &pvalue->schedulingTransmConfiguration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_16QAM_Settings */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-16QAM-Settings");

      pvalue->m.ul_16QAM_SettingsPresent = 1;

      stat = asn1PD_utran_UL_16QAM_Settings (pctxt, &pvalue->ul_16QAM_Settings);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_PersistenceScalingFactor (OSCTXT* pctxt, utran_PersistenceScalingFactor* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PersistenceScalingFactor");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_SF16Codes (OSCTXT* pctxt, utran_SF16Codes* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SF16Codes");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384_sF16 (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384_sF16* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 8) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SF16Codes", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_SF16Codes));
      stat = asn1PD_utran_SF16Codes (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_SF8Codes (OSCTXT* pctxt, utran_SF8Codes* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SF8Codes");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384_sF8 (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384_sF8* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 8) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SF8Codes", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_SF8Codes));
      stat = asn1PD_utran_SF8Codes (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384 (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* sF16 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "sF16");

         pvalue->u.sF16 = rtxMemAllocType (pctxt, 
            utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384_sF16);

         if (pvalue->u.sF16 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384_sF16 (pvalue->u.sF16);

         stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384_sF16 (pctxt, pvalue->u.sF16);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sF8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sF8");

         pvalue->u.sF8 = rtxMemAllocType (pctxt, 
            utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384_sF8);

         if (pvalue->u.sF8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384_sF8 (pvalue->u.sF8);

         stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384_sF8 (pctxt, pvalue->u.sF8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_SF32Codes (OSCTXT* pctxt, utran_SF32Codes* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SF32Codes");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768_sF32 (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768_sF32* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 16) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SF32Codes", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_SF32Codes));
      stat = asn1PD_utran_SF32Codes (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_SF16Codes2 (OSCTXT* pctxt, utran_SF16Codes2* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SF16Codes2");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768_sF816 (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768_sF816* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 16) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SF16Codes2", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_SF16Codes2));
      stat = asn1PD_utran_SF16Codes2 (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768 (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* sF32 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "sF32");

         pvalue->u.sF32 = rtxMemAllocType (pctxt, 
            utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768_sF32);

         if (pvalue->u.sF32 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768_sF32 (pvalue->u.sF32);

         stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768_sF32 (pctxt, pvalue->u.sF32);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sF816 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sF816");

         pvalue->u.sF816 = rtxMemAllocType (pctxt, 
            utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768_sF816);

         if (pvalue->u.sF816 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768_sF816 (pvalue->u.sF816);

         stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768_sF816 (pctxt, pvalue->u.sF816);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         pvalue->u.tdd768 = rtxMemAllocType (pctxt, 
            utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768);

         if (pvalue->u.tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768 (pvalue->u.tdd768);

         stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768 (pctxt, pvalue->u.tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768 (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_RUCCH_ConstantValue */
   RTXCTXTPUSHELEMNAME (pctxt, "e-RUCCH-ConstantValue");

   stat = pd_ConsInt8 (pctxt, &pvalue->e_RUCCH_ConstantValue, OSINTCONST(-35), OSINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_RUCCH_PersistenceScalingFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "e-RUCCH-PersistenceScalingFactor");

   stat = asn1PD_utran_PersistenceScalingFactor (pctxt, &pvalue->e_RUCCH_PersistenceScalingFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t_RUCCH */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-RUCCH");

      pvalue->m.t_RUCCHPresent = 1;

      stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH (pctxt, &pvalue->t_RUCCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_RUCCH_TS_Number */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RUCCH-TS-Number");

      pvalue->m.e_RUCCH_TS_NumberPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->e_RUCCH_TS_Number, OSUINTCONST(0), OSUINTCONST(14));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_RUCCH_Midamble */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RUCCH-Midamble");

      pvalue->m.e_RUCCH_MidamblePresent = 1;

      stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble (pctxt, &pvalue->e_RUCCH_Midamble);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode t_adv */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-adv");

      pvalue->m.t_advPresent = 1;

      stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv (pctxt, &pvalue->t_adv);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode t_SCHED */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-SCHED");

      pvalue->m.t_SCHEDPresent = 1;

      stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED (pctxt, &pvalue->t_SCHED);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_AccessServiceClass_TDD_LCR_r4_availableSYNC_UlCodesIndics (OSCTXT* pctxt, utran_AccessServiceClass_TDD_LCR_r4_availableSYNC_UlCodesIndics* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels (OSCTXT* pctxt, utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2 (OSCTXT* pctxt, utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode subchannels */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "subchannels");

      pvalue->m.subchannelsPresent = 1;

      stat = asn1PD_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels (pctxt, &pvalue->subchannels);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4_subchannels (OSCTXT* pctxt, utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4_subchannels* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4 (OSCTXT* pctxt, utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode subchannels */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "subchannels");

      pvalue->m.subchannelsPresent = 1;

      stat = asn1PD_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4_subchannels (pctxt, &pvalue->subchannels);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8_subchannels (OSCTXT* pctxt, utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8_subchannels* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8 (OSCTXT* pctxt, utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode subchannels */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "subchannels");

      pvalue->m.subchannelsPresent = 1;

      stat = asn1PD_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8_subchannels (pctxt, &pvalue->subchannels);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize (OSCTXT* pctxt, utran_AccessServiceClass_TDD_LCR_r4_subchannelSize* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* size1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "size1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* size2 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "size2");

         pvalue->u.size2 = rtxMemAllocType (pctxt, 
            utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2);

         if (pvalue->u.size2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2 (pvalue->u.size2);

         stat = asn1PD_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2 (pctxt, pvalue->u.size2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* size4 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "size4");

         pvalue->u.size4 = rtxMemAllocType (pctxt, 
            utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4);

         if (pvalue->u.size4 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4 (pvalue->u.size4);

         stat = asn1PD_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4 (pctxt, pvalue->u.size4);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* size8 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "size8");

         pvalue->u.size8 = rtxMemAllocType (pctxt, 
            utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8);

         if (pvalue->u.size8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8 (pvalue->u.size8);

         stat = asn1PD_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8 (pctxt, pvalue->u.size8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_AccessServiceClass_TDD_LCR_r4 (OSCTXT* pctxt, utran_AccessServiceClass_TDD_LCR_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AccessServiceClass-TDD-LCR-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode availableSYNC_UlCodesIndics */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "availableSYNC-UlCodesIndics");

      pvalue->m.availableSYNC_UlCodesIndicsPresent = 1;

      stat = asn1PD_utran_AccessServiceClass_TDD_LCR_r4_availableSYNC_UlCodesIndics (pctxt, &pvalue->availableSYNC_UlCodesIndics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode subchannelSize */
   RTXCTXTPUSHELEMNAME (pctxt, "subchannelSize");

   stat = asn1PD_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize (pctxt, &pvalue->subchannelSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ASCSetting_TDD_LCR_r4 (OSCTXT* pctxt, utran_ASCSetting_TDD_LCR_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ASCSetting-TDD-LCR-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode accessServiceClass_TDD_LCR */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "accessServiceClass-TDD-LCR");

      pvalue->m.accessServiceClass_TDD_LCRPresent = 1;

      stat = asn1PD_utran_AccessServiceClass_TDD_LCR_r4 (pctxt, &pvalue->accessServiceClass_TDD_LCR);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PRACH_Partitioning_LCR_r4 (OSCTXT* pctxt, utran_PRACH_Partitioning_LCR_r4* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PRACH-Partitioning-LCR-r4");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_ASCSetting_TDD_LCR_r4* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ASCSetting-TDD-LCR-r4", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_ASCSetting_TDD_LCR_r4, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_ASCSetting_TDD_LCR_r4 (pdata);

      stat = asn1PD_utran_ASCSetting_TDD_LCR_r4 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_AccessServiceClass (OSCTXT* pctxt, utran_E_RUCCH_AccessServiceClass* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-RUCCH-AccessServiceClass");

   stat = asn1PD_utran_PRACH_Partitioning_LCR_r4 (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PersistenceScalingFactorList (OSCTXT* pctxt, utran_PersistenceScalingFactorList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PersistenceScalingFactorList");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 6) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PersistenceScalingFactor", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_PersistenceScalingFactor));
      stat = asn1PD_utran_PersistenceScalingFactor (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions (OSCTXT* pctxt, utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_Sync_UL_Codes_Bitmap (OSCTXT* pctxt, utran_Sync_UL_Codes_Bitmap* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Sync-UL-Codes-Bitmap");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SYNC_UL_InfoForE_RUCCH (OSCTXT* pctxt, utran_SYNC_UL_InfoForE_RUCCH* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "SYNC-UL-InfoForE-RUCCH");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode prxUpPCHdes */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "prxUpPCHdes");

      pvalue->m.prxUpPCHdesPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->prxUpPCHdes, OSUINTCONST(0), OSUINTCONST(62));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode powerRampStep */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerRampStep");

      pvalue->m.powerRampStepPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->powerRampStep, OSUINTCONST(0), OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode max_SYNC_UL_Transmissions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "max-SYNC-UL-Transmissions");

      pvalue->m.max_SYNC_UL_TransmissionsPresent = 1;

      stat = asn1PD_utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions (pctxt, &pvalue->max_SYNC_UL_Transmissions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_RUCCH_Sync_UL_Codes_Bitmap */
   RTXCTXTPUSHELEMNAME (pctxt, "e-RUCCH-Sync-UL-Codes-Bitmap");

   stat = asn1PD_utran_Sync_UL_Codes_Bitmap (pctxt, &pvalue->e_RUCCH_Sync_UL_Codes_Bitmap);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mmax */
   RTXCTXTPUSHELEMNAME (pctxt, "mmax");

   stat = pd_ConsUInt8 (pctxt, &pvalue->mmax, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TimeslotNumber_PRACH_LCR_r4 (OSCTXT* pctxt, utran_TimeslotNumber_PRACH_LCR_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeslotNumber-PRACH-LCR-r4");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TDD_PRACH_CCode_LCR_r4 (OSCTXT* pctxt, utran_TDD_PRACH_CCode_LCR_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TDD-PRACH-CCode-LCR-r4");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(27));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PRACH_ChanCodes_List_LCR (OSCTXT* pctxt, utran_PRACH_ChanCodes_List_LCR* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PRACH-ChanCodes-List-LCR");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 2) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TDD-PRACH-CCode-LCR-r4", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_TDD_PRACH_CCode_LCR_r4));
      stat = asn1PD_utran_TDD_PRACH_CCode_LCR_r4 (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PRACH_Information_LCR (OSCTXT* pctxt, utran_PRACH_Information_LCR* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PRACH-Information-LCR");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode timeslot */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslot");

   stat = asn1PD_utran_TimeslotNumber_PRACH_LCR_r4 (pctxt, &pvalue->timeslot);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode prach_ChanCodes_list_LCR */
   RTXCTXTPUSHELEMNAME (pctxt, "prach-ChanCodes-list-LCR");

   stat = asn1PD_utran_PRACH_ChanCodes_List_LCR (pctxt, &pvalue->prach_ChanCodes_list_LCR);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleShiftAndBurstType */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_utran_MidambleShiftAndBurstType_LCR_r4 (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode fpach_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "fpach-Info");

      pvalue->m.fpach_InfoPresent = 1;

      stat = asn1PD_utran_FPACH_Info_r4 (pctxt, &pvalue->fpach_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PRACH_Information_LCR_List (OSCTXT* pctxt, utran_PRACH_Information_LCR_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PRACH-Information-LCR-List");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_PRACH_Information_LCR* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PRACH-Information-LCR", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_PRACH_Information_LCR, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_PRACH_Information_LCR (pdata);

      stat = asn1PD_utran_PRACH_Information_LCR (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd128 (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[9];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 9; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode t_RUCCH */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-RUCCH");

      pvalue->m.t_RUCCHPresent = 1;

      stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH (pctxt, &pvalue->t_RUCCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode n_RUCCH */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "n-RUCCH");

      pvalue->m.n_RUCCHPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->n_RUCCH, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode t_WAIT */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-WAIT");

      pvalue->m.t_WAITPresent = 1;

      stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT (pctxt, &pvalue->t_WAIT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode t_SI */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-SI");

      pvalue->m.t_SIPresent = 1;

      stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI (pctxt, &pvalue->t_SI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extendedEstimationWindow */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "extendedEstimationWindow");

      pvalue->m.extendedEstimationWindowPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->extendedEstimationWindow, OSUINTCONST(2), OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_RUCCH_AccessServiceClass */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RUCCH-AccessServiceClass");

      pvalue->m.e_RUCCH_AccessServiceClassPresent = 1;

      stat = asn1PD_utran_E_RUCCH_AccessServiceClass (pctxt, &pvalue->e_RUCCH_AccessServiceClass);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_RUCCH_PersistenceScalingFactor */
   if (optbits[6]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RUCCH-PersistenceScalingFactor");

      pvalue->m.e_RUCCH_PersistenceScalingFactorPresent = 1;

      stat = asn1PD_utran_PersistenceScalingFactorList (pctxt, &pvalue->e_RUCCH_PersistenceScalingFactor);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode sync_UL_InfoForE_RUCCH */
   if (optbits[7]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sync-UL-InfoForE-RUCCH");

      pvalue->m.sync_UL_InfoForE_RUCCHPresent = 1;

      stat = asn1PD_utran_SYNC_UL_InfoForE_RUCCH (pctxt, &pvalue->sync_UL_InfoForE_RUCCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode prach_information */
   if (optbits[8]) {
      RTXCTXTPUSHELEMNAME (pctxt, "prach-information");

      pvalue->m.prach_informationPresent = 1;

      stat = asn1PD_utran_PRACH_Information_LCR_List (pctxt, &pvalue->prach_information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info_modeSpecificInfo (OSCTXT* pctxt, utran_E_RUCCH_Info_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384_tdd768 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384-tdd768");

         pvalue->u.tdd384_tdd768 = rtxMemAllocType (pctxt, 
            utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768);

         if (pvalue->u.tdd384_tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768 (pvalue->u.tdd384_tdd768);

         stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768 (pctxt, pvalue->u.tdd384_tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_E_RUCCH_Info_modeSpecificInfo_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_RUCCH_Info (OSCTXT* pctxt, utran_E_RUCCH_Info* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-RUCCH-Info");

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_E_RUCCH_Info_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Reference_Beta_QPSK (OSCTXT* pctxt, utran_Reference_Beta_QPSK* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Reference-Beta-QPSK");

   /* decode root elements */
   /* decode reference_Code_Rate */
   RTXCTXTPUSHELEMNAME (pctxt, "reference-Code-Rate");

   stat = pd_ConsUInt8 (pctxt, &pvalue->reference_Code_Rate, OSUINTCONST(0), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reference_Beta */
   RTXCTXTPUSHELEMNAME (pctxt, "reference-Beta");

   stat = pd_ConsInt8 (pctxt, &pvalue->reference_Beta, OSINTCONST(-15), OSINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_TFCS_Info_reference_Beta_QPSK_List (OSCTXT* pctxt, utran_E_TFCS_Info_reference_Beta_QPSK_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_Reference_Beta_QPSK* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Reference-Beta-QPSK", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_Reference_Beta_QPSK, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_Reference_Beta_QPSK (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_Reference_Beta_16QAM (OSCTXT* pctxt, utran_Reference_Beta_16QAM* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Reference-Beta-16QAM");

   /* decode root elements */
   /* decode reference_Code_Rate */
   RTXCTXTPUSHELEMNAME (pctxt, "reference-Code-Rate");

   stat = pd_ConsUInt8 (pctxt, &pvalue->reference_Code_Rate, OSUINTCONST(0), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reference_Beta */
   RTXCTXTPUSHELEMNAME (pctxt, "reference-Beta");

   stat = pd_ConsInt8 (pctxt, &pvalue->reference_Beta, OSINTCONST(-15), OSINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_TFCS_Info_reference_Beta_16QAM_List (OSCTXT* pctxt, utran_E_TFCS_Info_reference_Beta_16QAM_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_Reference_Beta_16QAM* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Reference-Beta-16QAM", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_Reference_Beta_16QAM, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_Reference_Beta_16QAM (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_TFCS_Info (OSCTXT* pctxt, utran_E_TFCS_Info* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-TFCS-Info");

   /* decode root elements */
   /* decode reference_Beta_QPSK_List */
   RTXCTXTPUSHELEMNAME (pctxt, "reference-Beta-QPSK-List");

   stat = asn1PD_utran_E_TFCS_Info_reference_Beta_QPSK_List (pctxt, &pvalue->reference_Beta_QPSK_List);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reference_Beta_16QAM_List */
   RTXCTXTPUSHELEMNAME (pctxt, "reference-Beta-16QAM-List");

   stat = asn1PD_utran_E_TFCS_Info_reference_Beta_16QAM_List (pctxt, &pvalue->reference_Beta_16QAM_List);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleConfigurationBurstType1 (OSCTXT* pctxt, utran_MidambleConfigurationBurstType1* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MidambleConfigurationBurstType1");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_EDCH_burstType_type1_midambleAllocationMode_ueSpecificMidamble (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_EDCH_burstType_type1_midambleAllocationMode_ueSpecificMidamble* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleShift */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShift");

   stat = asn1PD_utran_MidambleShiftLong (pctxt, &pvalue->midambleShift);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_EDCH_burstType_type1_midambleAllocationMode (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_EDCH_burstType_type1_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* defaultMidamble */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* commonMidamble */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "commonMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueSpecificMidamble */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "ueSpecificMidamble");

         pvalue->u.ueSpecificMidamble = rtxMemAllocTypeZ (pctxt, 
            utran_MidambleShiftAndBurstType_EDCH_burstType_type1_midambleAllocationMode_ueSpecificMidamble);

         if (pvalue->u.ueSpecificMidamble == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_MidambleShiftAndBurstType_EDCH_burstType_type1_midambleAllocationMode_ueSpecificMidamble (pctxt, pvalue->u.ueSpecificMidamble);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_EDCH_burstType_type1 (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_EDCH_burstType_type1* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleConfigurationBurstType1 */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfigurationBurstType1");

   stat = asn1PD_utran_MidambleConfigurationBurstType1 (pctxt, &pvalue->midambleConfigurationBurstType1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleAllocationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_utran_MidambleShiftAndBurstType_EDCH_burstType_type1_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_EDCH_burstType_type2_midambleAllocationMode_ueSpecificMidamble (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_EDCH_burstType_type2_midambleAllocationMode_ueSpecificMidamble* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleShift */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShift");

   stat = asn1PD_utran_MidambleShiftShort (pctxt, &pvalue->midambleShift);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_EDCH_burstType_type2_midambleAllocationMode (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_EDCH_burstType_type2_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* defaultMidamble */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* commonMidamble */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "commonMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueSpecificMidamble */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "ueSpecificMidamble");

         pvalue->u.ueSpecificMidamble = rtxMemAllocTypeZ (pctxt, 
            utran_MidambleShiftAndBurstType_EDCH_burstType_type2_midambleAllocationMode_ueSpecificMidamble);

         if (pvalue->u.ueSpecificMidamble == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_MidambleShiftAndBurstType_EDCH_burstType_type2_midambleAllocationMode_ueSpecificMidamble (pctxt, pvalue->u.ueSpecificMidamble);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_EDCH_burstType_type2 (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_EDCH_burstType_type2* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleConfigurationBurstType2 */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfigurationBurstType2");

   stat = asn1PD_utran_MidambleConfigurationBurstType2 (pctxt, &pvalue->midambleConfigurationBurstType2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleAllocationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_utran_MidambleShiftAndBurstType_EDCH_burstType_type2_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_EDCH_burstType (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_EDCH_burstType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* type1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "type1");

         pvalue->u.type1 = rtxMemAllocType (pctxt, 
            utran_MidambleShiftAndBurstType_EDCH_burstType_type1);

         if (pvalue->u.type1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_MidambleShiftAndBurstType_EDCH_burstType_type1 (pvalue->u.type1);

         stat = asn1PD_utran_MidambleShiftAndBurstType_EDCH_burstType_type1 (pctxt, pvalue->u.type1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* type2 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "type2");

         pvalue->u.type2 = rtxMemAllocType (pctxt, 
            utran_MidambleShiftAndBurstType_EDCH_burstType_type2);

         if (pvalue->u.type2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_MidambleShiftAndBurstType_EDCH_burstType_type2 (pvalue->u.type2);

         stat = asn1PD_utran_MidambleShiftAndBurstType_EDCH_burstType_type2 (pctxt, pvalue->u.type2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_EDCH (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_EDCH* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MidambleShiftAndBurstType-EDCH");

   /* decode root elements */
   /* decode burstType */
   RTXCTXTPUSHELEMNAME (pctxt, "burstType");

   stat = asn1PD_utran_MidambleShiftAndBurstType_EDCH_burstType (pctxt, &pvalue->burstType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_PUCH_TS_Slots (OSCTXT* pctxt, utran_E_PUCH_TS_Slots* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-PUCH-TS-Slots");

   /* decode root elements */
   /* decode ts_Number */
   RTXCTXTPUSHELEMNAME (pctxt, "ts-Number");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ts_Number, OSUINTCONST(0), OSUINTCONST(14));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleShiftAndBurstType */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_utran_MidambleShiftAndBurstType_EDCH (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768_e_PUCH_TS_ConfigurationList (OSCTXT* pctxt, utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768_e_PUCH_TS_ConfigurationList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(12), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_E_PUCH_TS_Slots* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "E-PUCH-TS-Slots", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_E_PUCH_TS_Slots, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_E_PUCH_TS_Slots (pdata);

      stat = asn1PD_utran_E_PUCH_TS_Slots (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768 (OSCTXT* pctxt, utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode noSlotsForTFCIandTPC */
   RTXCTXTPUSHELEMNAME (pctxt, "noSlotsForTFCIandTPC");

   stat = pd_ConsUInt8 (pctxt, &pvalue->noSlotsForTFCIandTPC, OSUINTCONST(1), OSUINTCONST(12));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_PUCH_ContantValue */
   RTXCTXTPUSHELEMNAME (pctxt, "e-PUCH-ContantValue");

   stat = pd_ConsInt8 (pctxt, &pvalue->e_PUCH_ContantValue, OSINTCONST(-35), OSINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_PUCH_TS_ConfigurationList */
   RTXCTXTPUSHELEMNAME (pctxt, "e-PUCH-TS-ConfigurationList");

   stat = asn1PD_utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768_e_PUCH_TS_ConfigurationList (pctxt, &pvalue->e_PUCH_TS_ConfigurationList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_PUCH_CodeHopping */
   RTXCTXTPUSHELEMNAME (pctxt, "e-PUCH-CodeHopping");

   stat = DEC_BIT (pctxt, &pvalue->e_PUCH_CodeHopping);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_PUCH_TPC_Step_Size */
   RTXCTXTPUSHELEMNAME (pctxt, "e-PUCH-TPC-Step-Size");

   stat = pd_ConsUInt8 (pctxt, &pvalue->e_PUCH_TPC_Step_Size, OSUINTCONST(1), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode minimum_Allowed_Code_Rate */
   RTXCTXTPUSHELEMNAME (pctxt, "minimum-Allowed-Code-Rate");

   stat = pd_ConsUInt8 (pctxt, &pvalue->minimum_Allowed_Code_Rate, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maximum_Allowed_Code_Rate */
   RTXCTXTPUSHELEMNAME (pctxt, "maximum-Allowed-Code-Rate");

   stat = pd_ConsUInt8 (pctxt, &pvalue->maximum_Allowed_Code_Rate, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType (OSCTXT* pctxt, utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_E_PUCH_TS_Slots_LCR_midambleAllocationMode (OSCTXT* pctxt, utran_E_PUCH_TS_Slots_LCR_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* defaultMidamble */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueSpecificMidamble */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ueSpecificMidamble");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.ueSpecificMidamble, OSUINTCONST(0), OSUINTCONST(15));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_PUCH_TS_Slots_LCR (OSCTXT* pctxt, utran_E_PUCH_TS_Slots_LCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-PUCH-TS-Slots-LCR");

   /* decode root elements */
   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber_LCR_r4 (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleAllocationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_utran_E_PUCH_TS_Slots_LCR_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleConfiguration */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfiguration");

   stat = pd_ConsUInt8 (pctxt, &pvalue->midambleConfiguration, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_PUCH_Info_modeSpecificInfo_tdd128_e_PUCH_TS_ConfigurationList (OSCTXT* pctxt, utran_E_PUCH_Info_modeSpecificInfo_tdd128_e_PUCH_TS_ConfigurationList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(5), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_E_PUCH_TS_Slots_LCR* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "E-PUCH-TS-Slots-LCR", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_E_PUCH_TS_Slots_LCR, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_E_PUCH_TS_Slots_LCR (pdata);

      stat = asn1PD_utran_E_PUCH_TS_Slots_LCR (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo (OSCTXT* pctxt, utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(29));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_E_PUCH_Info_modeSpecificInfo_tdd128 (OSCTXT* pctxt, utran_E_PUCH_Info_modeSpecificInfo_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode snpl_ReportType */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "snpl-ReportType");

      pvalue->m.snpl_ReportTypePresent = 1;

      stat = asn1PD_utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType (pctxt, &pvalue->snpl_ReportType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode prxdes_base */
   RTXCTXTPUSHELEMNAME (pctxt, "prxdes-base");

   stat = pd_ConsInt8 (pctxt, &pvalue->prxdes_base, OSINTCONST(-112), OSINTCONST(-50));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode beaconPLEst */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "beaconPLEst");

      pvalue->m.beaconPLEstPresent = 1;

      stat = DEC_BIT (pctxt, &pvalue->beaconPLEst);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tpc_StepSize */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-StepSize");

   stat = asn1PD_utran_TPC_StepSizeTDD (pctxt, &pvalue->tpc_StepSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pebase_PowerControlGAP */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pebase-PowerControlGAP");

      pvalue->m.pebase_PowerControlGAPPresent = 1;

      stat = asn1PD_utran_PowerControlGAP (pctxt, &pvalue->pebase_PowerControlGAP);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_SynchronisationParameters */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-SynchronisationParameters");

      pvalue->m.ul_SynchronisationParametersPresent = 1;

      stat = asn1PD_utran_UL_SynchronisationParameters_r4 (pctxt, &pvalue->ul_SynchronisationParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_PUCH_TS_ConfigurationList */
   RTXCTXTPUSHELEMNAME (pctxt, "e-PUCH-TS-ConfigurationList");

   stat = asn1PD_utran_E_PUCH_Info_modeSpecificInfo_tdd128_e_PUCH_TS_ConfigurationList (pctxt, &pvalue->e_PUCH_TS_ConfigurationList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode minimum_Allowed_Code_Rate */
   RTXCTXTPUSHELEMNAME (pctxt, "minimum-Allowed-Code-Rate");

   stat = pd_ConsUInt8 (pctxt, &pvalue->minimum_Allowed_Code_Rate, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maximum_Allowed_Code_Rate */
   RTXCTXTPUSHELEMNAME (pctxt, "maximum-Allowed-Code-Rate");

   stat = pd_ConsUInt8 (pctxt, &pvalue->maximum_Allowed_Code_Rate, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maximumNumOfRetransSchedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "maximumNumOfRetransSchedInfo");

   stat = pd_ConsUInt8 (pctxt, &pvalue->maximumNumOfRetransSchedInfo, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode retransTimerForSchedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "retransTimerForSchedInfo");

   stat = asn1PD_utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo (pctxt, &pvalue->retransTimerForSchedInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_PUCH_Info_modeSpecificInfo (OSCTXT* pctxt, utran_E_PUCH_Info_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd348_tdd768 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd348-tdd768");

         pvalue->u.tdd348_tdd768 = rtxMemAllocType (pctxt, 
            utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768);

         if (pvalue->u.tdd348_tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768 (pvalue->u.tdd348_tdd768);

         stat = asn1PD_utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768 (pctxt, pvalue->u.tdd348_tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_E_PUCH_Info_modeSpecificInfo_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_PUCH_Info_modeSpecificInfo_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_E_PUCH_Info_modeSpecificInfo_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_PUCH_Info (OSCTXT* pctxt, utran_E_PUCH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "E-PUCH-Info");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_TFCS_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "e-TFCS-Info");

   stat = asn1PD_utran_E_TFCS_Info (pctxt, &pvalue->e_TFCS_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_E_PUCH_Info_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerOffsetForSchedInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetForSchedInfo");

      pvalue->m.powerOffsetForSchedInfoPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->powerOffsetForSchedInfo, OSUINTCONST(0), OSUINTCONST(6));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Non_ScheduledTransGrantInfoTDD_tdd384_768 (OSCTXT* pctxt, utran_Non_ScheduledTransGrantInfoTDD_tdd384_768* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode timeslotResourceRelatedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotResourceRelatedInfo");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(13), OSUINTCONST(13), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->timeslotResourceRelatedInfo
      , OSUINTCONST(13), OSUINTCONST(13));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerResourceRelatedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "powerResourceRelatedInfo");

   stat = pd_ConsUInt8 (pctxt, &pvalue->powerResourceRelatedInfo, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode activationTime */
   RTXCTXTPUSHELEMNAME (pctxt, "activationTime");

   stat = asn1PD_utran_ActivationTime (pctxt, &pvalue->activationTime);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode repetitionPeriodAndLength */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "repetitionPeriodAndLength");

      pvalue->m.repetitionPeriodAndLengthPresent = 1;

      stat = asn1PD_utran_RepetitionPeriodAndLength (pctxt, &pvalue->repetitionPeriodAndLength);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode codeResourceInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "codeResourceInfo");

   stat = asn1PD_utran_UL_TS_ChannelisationCode (pctxt, &pvalue->codeResourceInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Non_ScheduledTransGrantInfoTDD_tdd128_e_HICH_Info_midambleAllocationMode (OSCTXT* pctxt, utran_Non_ScheduledTransGrantInfoTDD_tdd128_e_HICH_Info_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* defaultMidamble */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueSpecificMidamble */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ueSpecificMidamble");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.ueSpecificMidamble, OSUINTCONST(0), OSUINTCONST(15));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_Non_ScheduledTransGrantInfoTDD_tdd128_e_HICH_Info (OSCTXT* pctxt, utran_Non_ScheduledTransGrantInfoTDD_tdd128_e_HICH_Info* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber_LCR_r4 (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode channelisation_Code */
   RTXCTXTPUSHELEMNAME (pctxt, "channelisation-Code");

   stat = asn1PD_utran_HS_ChannelisationCode_LCR (pctxt, &pvalue->channelisation_Code);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleAllocationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD_tdd128_e_HICH_Info_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleConfiguration */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfiguration");

   stat = pd_ConsUInt8 (pctxt, &pvalue->midambleConfiguration, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode signatureSequenceGroupIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "signatureSequenceGroupIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->signatureSequenceGroupIndex, OSUINTCONST(0), OSUINTCONST(19));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Non_ScheduledTransGrantInfoTDD_tdd128 (OSCTXT* pctxt, utran_Non_ScheduledTransGrantInfoTDD_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode n_E_UCCH */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "n-E-UCCH");

      pvalue->m.n_E_UCCHPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->n_E_UCCH, OSUINTCONST(1), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode n_E_HICH */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "n-E-HICH");

      pvalue->m.n_E_HICHPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->n_E_HICH, OSUINTCONST(4), OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode timeslotResourceRelatedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotResourceRelatedInfo");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->timeslotResourceRelatedInfo
      , OSUINTCONST(5), OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerResourceRelatedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "powerResourceRelatedInfo");

   stat = pd_ConsUInt8 (pctxt, &pvalue->powerResourceRelatedInfo, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode activationTime */
   RTXCTXTPUSHELEMNAME (pctxt, "activationTime");

   stat = asn1PD_utran_ActivationTime (pctxt, &pvalue->activationTime);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sfnNum */
   RTXCTXTPUSHELEMNAME (pctxt, "sfnNum");

   stat = pd_ConsUInt8 (pctxt, &pvalue->sfnNum, OSUINTCONST(0), OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode repetitionPeriodAndLength */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "repetitionPeriodAndLength");

      pvalue->m.repetitionPeriodAndLengthPresent = 1;

      stat = asn1PD_utran_RepetitionPeriodAndLength (pctxt, &pvalue->repetitionPeriodAndLength);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode codeResourceInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "codeResourceInfo");

   stat = asn1PD_utran_UL_TS_ChannelisationCode (pctxt, &pvalue->codeResourceInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_HICH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

   stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD_tdd128_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Non_ScheduledTransGrantInfoTDD (OSCTXT* pctxt, utran_Non_ScheduledTransGrantInfoTDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "Non-ScheduledTransGrantInfoTDD");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384_768 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384-768");

         pvalue->u.tdd384_768 = rtxMemAllocType (pctxt, 
            utran_Non_ScheduledTransGrantInfoTDD_tdd384_768);

         if (pvalue->u.tdd384_768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_Non_ScheduledTransGrantInfoTDD_tdd384_768 (pvalue->u.tdd384_768);

         stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD_tdd384_768 (pctxt, pvalue->u.tdd384_768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_Non_ScheduledTransGrantInfoTDD_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_Non_ScheduledTransGrantInfoTDD_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r7_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_UL_EDCH_Information_r7_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_RUCCH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RUCCH-Info");

      pvalue->m.e_RUCCH_InfoPresent = 1;

      stat = asn1PD_utran_E_RUCCH_Info (pctxt, &pvalue->e_RUCCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_PUCH_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-PUCH-Info");

      pvalue->m.e_PUCH_InfoPresent = 1;

      stat = asn1PD_utran_E_PUCH_Info (pctxt, &pvalue->e_PUCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode non_ScheduledTransGrantInfo */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "non-ScheduledTransGrantInfo");

      pvalue->m.non_ScheduledTransGrantInfoPresent = 1;

      stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD (pctxt, &pvalue->non_ScheduledTransGrantInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r7_modeSpecificInfo (OSCTXT* pctxt, utran_UL_EDCH_Information_r7_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_EDCH_Information_r7_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_EDCH_Information_r7_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_EDCH_Information_r7_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_EDCH_Information_r7_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_EDCH_Information_r7_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_EDCH_Information_r7_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r7 (OSCTXT* pctxt, utran_UL_EDCH_Information_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-EDCH-Information-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_es_e_resetIndicator */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-es-e-resetIndicator");

      pvalue->m.mac_es_e_resetIndicatorPresent = 1;

      stat = asn1PD_utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator (pctxt, &pvalue->mac_es_e_resetIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_UL_EDCH_Information_r7_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r7_dl_dpchInfoCommon (OSCTXT* pctxt, utran_DL_CommonInformation_r7_dl_dpchInfoCommon* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_DPCH_InfoCommon */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoCommon");

         pvalue->u.dl_DPCH_InfoCommon = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r6);

         if (pvalue->u.dl_DPCH_InfoCommon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r6 (pvalue->u.dl_DPCH_InfoCommon);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_DPCH_InfoCommon);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_FDPCH_InfoCommon */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-FDPCH-InfoCommon");

         pvalue->u.dl_FDPCH_InfoCommon = rtxMemAllocType (pctxt, 
            utran_DL_FDPCH_InfoCommon_r6);

         if (pvalue->u.dl_FDPCH_InfoCommon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_FDPCH_InfoCommon_r6 (pvalue->u.dl_FDPCH_InfoCommon);

         stat = asn1PD_utran_DL_FDPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_FDPCH_InfoCommon);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r7_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_CommonInformation_r7_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueFDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dpch_CompressedModeInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dpch-CompressedModeInfo");

      pvalue->m.dpch_CompressedModeInfoPresent = 1;

      stat = asn1PD_utran_DPCH_CompressedModeInfo (pctxt, &pvalue->dpch_CompressedModeInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tx_DiversityMode */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tx-DiversityMode");

      pvalue->m.tx_DiversityModePresent = 1;

      stat = asn1PD_utran_TX_DiversityMode (pctxt, &pvalue->tx_DiversityMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r7_modeSpecificInfo_tdd_tddOption_tdd128 (OSCTXT* pctxt, utran_DL_CommonInformation_r7_modeSpecificInfo_tdd_tddOption_tdd128* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tstd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "tstd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->tstd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r7_modeSpecificInfo_tdd_tddOption (OSCTXT* pctxt, utran_DL_CommonInformation_r7_modeSpecificInfo_tdd_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocTypeZ (pctxt, 
            utran_DL_CommonInformation_r7_modeSpecificInfo_tdd_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_CommonInformation_r7_modeSpecificInfo_tdd_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r7_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_CommonInformation_r7_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_DL_CommonInformation_r7_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueTDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r7_modeSpecificInfo (OSCTXT* pctxt, utran_DL_CommonInformation_r7_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r7_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r7_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_CommonInformation_r7_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r7_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r7_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_CommonInformation_r7_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r7_mac_hsResetIndicator (OSCTXT* pctxt, utran_DL_CommonInformation_r7_mac_hsResetIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__267; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r7_postVerificationPeriod (OSCTXT* pctxt, utran_DL_CommonInformation_r7_postVerificationPeriod* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__268; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r7 (OSCTXT* pctxt, utran_DL_CommonInformation_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CommonInformation-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_dpchInfoCommon */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dpchInfoCommon");

      pvalue->m.dl_dpchInfoCommonPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r7_dl_dpchInfoCommon (pctxt, &pvalue->dl_dpchInfoCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_CommonInformation_r7_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_hsResetIndicator */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-hsResetIndicator");

      pvalue->m.mac_hsResetIndicatorPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r7_mac_hsResetIndicator (pctxt, &pvalue->mac_hsResetIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode postVerificationPeriod */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "postVerificationPeriod");

      pvalue->m.postVerificationPeriodPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r7_postVerificationPeriod (pctxt, &pvalue->postVerificationPeriod);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r7_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode primaryCPICH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCPICH-Info");

   stat = asn1PD_utran_PrimaryCPICH_Info (pctxt, &pvalue->primaryCPICH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode servingHSDSCH_RL_indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "servingHSDSCH-RL-indicator");

   stat = DEC_BIT (pctxt, &pvalue->servingHSDSCH_RL_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode servingEDCH_RL_indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "servingEDCH-RL-indicator");

   stat = DEC_BIT (pctxt, &pvalue->servingEDCH_RL_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_r7_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocTypeZ (pctxt, 
            utran_DL_InformationPerRL_r7_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, utran_PrimaryCCPCH_Info_r4);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_PrimaryCCPCH_Info_r4 (pvalue->u.tdd);

         stat = asn1PD_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_r7_fdd (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_r7_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pCPICH_UsageForChannelEst */
   RTXCTXTPUSHELEMNAME (pctxt, "pCPICH-UsageForChannelEst");

   stat = asn1PD_utran_PCPICH_UsageForChannelEst (pctxt, &pvalue->pCPICH_UsageForChannelEst);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpch_FrameOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "dpch-FrameOffset");

   stat = asn1PD_utran_DPCH_FrameOffset (pctxt, &pvalue->dpch_FrameOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode secondaryCPICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "secondaryCPICH-Info");

      pvalue->m.secondaryCPICH_InfoPresent = 1;

      stat = asn1PD_utran_SecondaryCPICH_Info (pctxt, &pvalue->secondaryCPICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_ChannelisationCodeList */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-ChannelisationCodeList");

   stat = asn1PD_utran_DL_ChannelisationCodeList (pctxt, &pvalue->dl_ChannelisationCodeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tpc_CombinationIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-CombinationIndex");

   stat = asn1PD_utran_TPC_CombinationIndex (pctxt, &pvalue->tpc_CombinationIndex);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerOffsetTPC_pdpdch */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetTPC-pdpdch");

      pvalue->m.powerOffsetTPC_pdpdchPresent = 1;

      stat = asn1PD_utran_PowerOffsetTPC_pdpdch (pctxt, &pvalue->powerOffsetTPC_pdpdch);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode closedLoopTimingAdjMode */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "closedLoopTimingAdjMode");

      pvalue->m.closedLoopTimingAdjModePresent = 1;

      stat = asn1PD_utran_ClosedLoopTimingAdjMode (pctxt, &pvalue->closedLoopTimingAdjMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode_ueSpecificMidamble (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode_ueSpecificMidamble* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleShift */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShift");

   stat = asn1PD_utran_MidambleShiftLong (pctxt, &pvalue->midambleShift);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* defaultMidamble */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* commonMidamble */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "commonMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueSpecificMidamble */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "ueSpecificMidamble");

         pvalue->u.ueSpecificMidamble = rtxMemAllocTypeZ (pctxt, 
            utran_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode_ueSpecificMidamble);

         if (pvalue->u.ueSpecificMidamble == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode_ueSpecificMidamble (pctxt, pvalue->u.ueSpecificMidamble);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type1 (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_r7_burstType_type1* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleConfigurationBurstType1and3 */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfigurationBurstType1and3");

   stat = asn1PD_utran_MidambleConfigurationBurstType1and3 (pctxt, &pvalue->midambleConfigurationBurstType1and3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleAllocationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode_ueSpecificMidamble (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode_ueSpecificMidamble* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleShift */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShift");

   stat = asn1PD_utran_MidambleShiftShort (pctxt, &pvalue->midambleShift);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* defaultMidamble */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* commonMidamble */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "commonMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueSpecificMidamble */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "ueSpecificMidamble");

         pvalue->u.ueSpecificMidamble = rtxMemAllocTypeZ (pctxt, 
            utran_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode_ueSpecificMidamble);

         if (pvalue->u.ueSpecificMidamble == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode_ueSpecificMidamble (pctxt, pvalue->u.ueSpecificMidamble);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type2 (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_r7_burstType_type2* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleConfigurationBurstType2 */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfigurationBurstType2");

   stat = asn1PD_utran_MidambleConfigurationBurstType2 (pctxt, &pvalue->midambleConfigurationBurstType2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleAllocationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode_ueSpecificMidamble (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode_ueSpecificMidamble* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleShift */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShift");

   stat = asn1PD_utran_MidambleShiftLong (pctxt, &pvalue->midambleShift);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* defaultMidamble */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueSpecificMidamble */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ueSpecificMidamble");

         pvalue->u.ueSpecificMidamble = rtxMemAllocTypeZ (pctxt, 
            utran_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode_ueSpecificMidamble);

         if (pvalue->u.ueSpecificMidamble == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode_ueSpecificMidamble (pctxt, pvalue->u.ueSpecificMidamble);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type3 (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_r7_burstType_type3* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode midambleConfigurationBurstType1and3 */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfigurationBurstType1and3");

   stat = asn1PD_utran_MidambleConfigurationBurstType1and3 (pctxt, &pvalue->midambleConfigurationBurstType1and3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleAllocationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_r7_burstType (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_r7_burstType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* type1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "type1");

         pvalue->u.type1 = rtxMemAllocType (pctxt, 
            utran_MidambleShiftAndBurstType_r7_burstType_type1);

         if (pvalue->u.type1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_MidambleShiftAndBurstType_r7_burstType_type1 (pvalue->u.type1);

         stat = asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type1 (pctxt, pvalue->u.type1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* type2 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "type2");

         pvalue->u.type2 = rtxMemAllocType (pctxt, 
            utran_MidambleShiftAndBurstType_r7_burstType_type2);

         if (pvalue->u.type2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_MidambleShiftAndBurstType_r7_burstType_type2 (pvalue->u.type2);

         stat = asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type2 (pctxt, pvalue->u.type2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* type3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "type3");

         pvalue->u.type3 = rtxMemAllocType (pctxt, 
            utran_MidambleShiftAndBurstType_r7_burstType_type3);

         if (pvalue->u.type3 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_MidambleShiftAndBurstType_r7_burstType_type3 (pvalue->u.type3);

         stat = asn1PD_utran_MidambleShiftAndBurstType_r7_burstType_type3 (pctxt, pvalue->u.type3);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* mbsfnBurstType4 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "mbsfnBurstType4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MidambleShiftAndBurstType_r7 (OSCTXT* pctxt, utran_MidambleShiftAndBurstType_r7* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MidambleShiftAndBurstType-r7");

   /* decode root elements */
   /* decode burstType */
   RTXCTXTPUSHELEMNAME (pctxt, "burstType");

   stat = asn1PD_utran_MidambleShiftAndBurstType_r7_burstType (pctxt, &pvalue->burstType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_IndividualTimeslotInfo_r7 (OSCTXT* pctxt, utran_IndividualTimeslotInfo_r7* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IndividualTimeslotInfo-r7");

   /* decode root elements */
   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleShiftAndBurstType */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_utran_MidambleShiftAndBurstType_r7 (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkAdditionalTimeslots_r7_parameters_sameAsLast (OSCTXT* pctxt, utran_DownlinkAdditionalTimeslots_r7_parameters_sameAsLast* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkAdditionalTimeslots_r7_parameters_newParameters (OSCTXT* pctxt, utran_DownlinkAdditionalTimeslots_r7_parameters_newParameters* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTimeslotInfo");

   stat = asn1PD_utran_IndividualTimeslotInfo_r7 (pctxt, &pvalue->individualTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_TS_ChannelisationCodesShort */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TS-ChannelisationCodesShort");

   stat = asn1PD_utran_DL_TS_ChannelisationCodesShort (pctxt, &pvalue->dl_TS_ChannelisationCodesShort);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkAdditionalTimeslots_r7_parameters (OSCTXT* pctxt, utran_DownlinkAdditionalTimeslots_r7_parameters* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* sameAsLast */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsLast");

         pvalue->u.sameAsLast = rtxMemAllocTypeZ (pctxt, 
            utran_DownlinkAdditionalTimeslots_r7_parameters_sameAsLast);

         if (pvalue->u.sameAsLast == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DownlinkAdditionalTimeslots_r7_parameters_sameAsLast (pctxt, pvalue->u.sameAsLast);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* newParameters */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "newParameters");

         pvalue->u.newParameters = rtxMemAllocType (pctxt, 
            utran_DownlinkAdditionalTimeslots_r7_parameters_newParameters);

         if (pvalue->u.newParameters == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DownlinkAdditionalTimeslots_r7_parameters_newParameters (pvalue->u.newParameters);

         stat = asn1PD_utran_DownlinkAdditionalTimeslots_r7_parameters_newParameters (pctxt, pvalue->u.newParameters);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkAdditionalTimeslots_r7 (OSCTXT* pctxt, utran_DownlinkAdditionalTimeslots_r7* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkAdditionalTimeslots-r7");

   /* decode root elements */
   /* decode parameters */
   RTXCTXTPUSHELEMNAME (pctxt, "parameters");

   stat = asn1PD_utran_DownlinkAdditionalTimeslots_r7_parameters (pctxt, &pvalue->parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots_timeslotList (OSCTXT* pctxt, utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(13), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DownlinkAdditionalTimeslots_r7* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DownlinkAdditionalTimeslots-r7", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DownlinkAdditionalTimeslots_r7, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DownlinkAdditionalTimeslots_r7 (pdata);

      stat = asn1PD_utran_DownlinkAdditionalTimeslots_r7 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots (OSCTXT* pctxt, utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* consecutive */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "consecutive");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.consecutive, OSUINTCONST(1), OSUINTCONST(13));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* timeslotList */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "timeslotList");

         pvalue->u.timeslotList = rtxMemAllocType (pctxt, 
            utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots_timeslotList);

         if (pvalue->u.timeslotList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots_timeslotList (pvalue->u.timeslotList);

         stat = asn1PD_utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots_timeslotList (pctxt, pvalue->u.timeslotList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkTimeslotsCodes_r7_moreTimeslots (OSCTXT* pctxt, utran_DownlinkTimeslotsCodes_r7_moreTimeslots* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* noMore */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "noMore");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* additionalTimeslots */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "additionalTimeslots");

         pvalue->u.additionalTimeslots = rtxMemAllocType (pctxt, 
            utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots);

         if (pvalue->u.additionalTimeslots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots (pvalue->u.additionalTimeslots);

         stat = asn1PD_utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots (pctxt, pvalue->u.additionalTimeslots);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkTimeslotsCodes_r7 (OSCTXT* pctxt, utran_DownlinkTimeslotsCodes_r7* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkTimeslotsCodes-r7");

   /* decode root elements */
   /* decode firstIndividualTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "firstIndividualTimeslotInfo");

   stat = asn1PD_utran_IndividualTimeslotInfo_r7 (pctxt, &pvalue->firstIndividualTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_TS_ChannelisationCodesShort */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TS-ChannelisationCodesShort");

   stat = asn1PD_utran_DL_TS_ChannelisationCodesShort (pctxt, &pvalue->dl_TS_ChannelisationCodesShort);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode moreTimeslots */
   RTXCTXTPUSHELEMNAME (pctxt, "moreTimeslots");

   stat = asn1PD_utran_DownlinkTimeslotsCodes_r7_moreTimeslots (pctxt, &pvalue->moreTimeslots);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CCTrCh_r7_tddOption_tdd384 (OSCTXT* pctxt, utran_DL_CCTrCh_r7_tddOption_tdd384* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_CCTrCH_TimeslotsCodes */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-CCTrCH-TimeslotsCodes");

      pvalue->m.dl_CCTrCH_TimeslotsCodesPresent = 1;

      stat = asn1PD_utran_DownlinkTimeslotsCodes_r7 (pctxt, &pvalue->dl_CCTrCH_TimeslotsCodes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation_consecutive (OSCTXT* pctxt, utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation_consecutive* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode firstChannelisationCode */
   RTXCTXTPUSHELEMNAME (pctxt, "firstChannelisationCode");

   stat = asn1PD_utran_DL_TS_ChannelisationCode_VHCR (pctxt, &pvalue->firstChannelisationCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode lastChannelisationCode */
   RTXCTXTPUSHELEMNAME (pctxt, "lastChannelisationCode");

   stat = asn1PD_utran_DL_TS_ChannelisationCode_VHCR (pctxt, &pvalue->lastChannelisationCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation_bitmap (OSCTXT* pctxt, utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation_bitmap* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(32), OSUINTCONST(32), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation (OSCTXT* pctxt, utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* consecutive */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "consecutive");

         pvalue->u.consecutive = rtxMemAllocTypeZ (pctxt, 
            utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation_consecutive);

         if (pvalue->u.consecutive == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation_consecutive (pctxt, pvalue->u.consecutive);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* bitmap */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "bitmap");

         pvalue->u.bitmap = rtxMemAllocType (pctxt, 
            utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation_bitmap);

         if (pvalue->u.bitmap == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation_bitmap (pvalue->u.bitmap);

         stat = asn1PD_utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation_bitmap (pctxt, pvalue->u.bitmap);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_TS_ChannelisationCodesShort_VHCR (OSCTXT* pctxt, utran_DL_TS_ChannelisationCodesShort_VHCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-TS-ChannelisationCodesShort-VHCR");

   /* decode root elements */
   /* decode codesRepresentation */
   RTXCTXTPUSHELEMNAME (pctxt, "codesRepresentation");

   stat = asn1PD_utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation (pctxt, &pvalue->codesRepresentation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkAdditionalTimeslots_VHCR_parameters_sameAsLast (OSCTXT* pctxt, utran_DownlinkAdditionalTimeslots_VHCR_parameters_sameAsLast* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkAdditionalTimeslots_VHCR_parameters_newParameters (OSCTXT* pctxt, utran_DownlinkAdditionalTimeslots_VHCR_parameters_newParameters* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTimeslotInfo");

   stat = asn1PD_utran_IndividualTimeslotInfo_VHCR (pctxt, &pvalue->individualTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_TS_ChannelisationCodesShort */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TS-ChannelisationCodesShort");

   stat = asn1PD_utran_DL_TS_ChannelisationCodesShort_VHCR (pctxt, &pvalue->dl_TS_ChannelisationCodesShort);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkAdditionalTimeslots_VHCR_parameters (OSCTXT* pctxt, utran_DownlinkAdditionalTimeslots_VHCR_parameters* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* sameAsLast */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsLast");

         pvalue->u.sameAsLast = rtxMemAllocTypeZ (pctxt, 
            utran_DownlinkAdditionalTimeslots_VHCR_parameters_sameAsLast);

         if (pvalue->u.sameAsLast == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DownlinkAdditionalTimeslots_VHCR_parameters_sameAsLast (pctxt, pvalue->u.sameAsLast);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* newParameters */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "newParameters");

         pvalue->u.newParameters = rtxMemAllocType (pctxt, 
            utran_DownlinkAdditionalTimeslots_VHCR_parameters_newParameters);

         if (pvalue->u.newParameters == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DownlinkAdditionalTimeslots_VHCR_parameters_newParameters (pvalue->u.newParameters);

         stat = asn1PD_utran_DownlinkAdditionalTimeslots_VHCR_parameters_newParameters (pctxt, pvalue->u.newParameters);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkAdditionalTimeslots_VHCR (OSCTXT* pctxt, utran_DownlinkAdditionalTimeslots_VHCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkAdditionalTimeslots-VHCR");

   /* decode root elements */
   /* decode parameters */
   RTXCTXTPUSHELEMNAME (pctxt, "parameters");

   stat = asn1PD_utran_DownlinkAdditionalTimeslots_VHCR_parameters (pctxt, &pvalue->parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList (OSCTXT* pctxt, utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(13), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DownlinkAdditionalTimeslots_VHCR* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DownlinkAdditionalTimeslots-VHCR", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DownlinkAdditionalTimeslots_VHCR, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DownlinkAdditionalTimeslots_VHCR (pdata);

      stat = asn1PD_utran_DownlinkAdditionalTimeslots_VHCR (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots (OSCTXT* pctxt, utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* consecutive */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "consecutive");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.consecutive, OSUINTCONST(1), OSUINTCONST(13));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* timeslotList */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "timeslotList");

         pvalue->u.timeslotList = rtxMemAllocType (pctxt, 
            utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList);

         if (pvalue->u.timeslotList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList (pvalue->u.timeslotList);

         stat = asn1PD_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList (pctxt, pvalue->u.timeslotList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots (OSCTXT* pctxt, utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* noMore */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "noMore");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* additionalTimeslots */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "additionalTimeslots");

         pvalue->u.additionalTimeslots = rtxMemAllocType (pctxt, 
            utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots);

         if (pvalue->u.additionalTimeslots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots (pvalue->u.additionalTimeslots);

         stat = asn1PD_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots (pctxt, pvalue->u.additionalTimeslots);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DownlinkTimeslotsCodes_VHCR (OSCTXT* pctxt, utran_DownlinkTimeslotsCodes_VHCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkTimeslotsCodes-VHCR");

   /* decode root elements */
   /* decode firstIndividualTimeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "firstIndividualTimeslotInfo");

   stat = asn1PD_utran_IndividualTimeslotInfo_VHCR (pctxt, &pvalue->firstIndividualTimeslotInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_TS_ChannelisationCodesShort */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TS-ChannelisationCodesShort");

   stat = asn1PD_utran_DL_TS_ChannelisationCodesShort_VHCR (pctxt, &pvalue->dl_TS_ChannelisationCodesShort);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode moreTimeslots */
   RTXCTXTPUSHELEMNAME (pctxt, "moreTimeslots");

   stat = asn1PD_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots (pctxt, &pvalue->moreTimeslots);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CCTrCh_r7_tddOption_tdd768 (OSCTXT* pctxt, utran_DL_CCTrCh_r7_tddOption_tdd768* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_CCTrCH_TimeslotsCodes */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-CCTrCH-TimeslotsCodes");

      pvalue->m.dl_CCTrCH_TimeslotsCodesPresent = 1;

      stat = asn1PD_utran_DownlinkTimeslotsCodes_VHCR (pctxt, &pvalue->dl_CCTrCH_TimeslotsCodes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CCTrCh_r7_tddOption_tdd128 (OSCTXT* pctxt, utran_DL_CCTrCh_r7_tddOption_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_CCTrCH_TimeslotsCodes */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-CCTrCH-TimeslotsCodes");

      pvalue->m.dl_CCTrCH_TimeslotsCodesPresent = 1;

      stat = asn1PD_utran_DownlinkTimeslotsCodes_LCR_r4 (pctxt, &pvalue->dl_CCTrCH_TimeslotsCodes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CCTrCh_r7_tddOption (OSCTXT* pctxt, utran_DL_CCTrCh_r7_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_DL_CCTrCh_r7_tddOption_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CCTrCh_r7_tddOption_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_DL_CCTrCh_r7_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         pvalue->u.tdd768 = rtxMemAllocType (pctxt, 
            utran_DL_CCTrCh_r7_tddOption_tdd768);

         if (pvalue->u.tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CCTrCh_r7_tddOption_tdd768 (pvalue->u.tdd768);

         stat = asn1PD_utran_DL_CCTrCh_r7_tddOption_tdd768 (pctxt, pvalue->u.tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_DL_CCTrCh_r7_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CCTrCh_r7_tddOption_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_DL_CCTrCh_r7_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CCTrCh_r7 (OSCTXT* pctxt, utran_DL_CCTrCh_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CCTrCh-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tfcs_ID */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tfcs-ID");

      stat = asn1PD_utran_TFCS_IdentityPlain (pctxt, &pvalue->tfcs_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->tfcs_ID = 1;
   }

   /* decode timeInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "timeInfo");

   stat = asn1PD_utran_TimeInfo (pctxt, &pvalue->timeInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode commonTimeslotInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "commonTimeslotInfo");

      pvalue->m.commonTimeslotInfoPresent = 1;

      stat = asn1PD_utran_CommonTimeslotInfo (pctxt, &pvalue->commonTimeslotInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_DL_CCTrCh_r7_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_CCTrChTPCList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrChTPCList");

      pvalue->m.ul_CCTrChTPCListPresent = 1;

      stat = asn1PD_utran_UL_CCTrChTPCList (pctxt, &pvalue->ul_CCTrChTPCList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CCTrChList_r7 (OSCTXT* pctxt, utran_DL_CCTrChList_r7* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CCTrChList-r7");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_CCTrCh_r7* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-CCTrCh-r7", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_CCTrCh_r7, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_CCTrCh_r7 (pdata);

      stat = asn1PD_utran_DL_CCTrCh_r7 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_r7_tdd (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_r7_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_CCTrChListToEstablish */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-CCTrChListToEstablish");

      pvalue->m.dl_CCTrChListToEstablishPresent = 1;

      stat = asn1PD_utran_DL_CCTrChList_r7 (pctxt, &pvalue->dl_CCTrChListToEstablish);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_CCTrChListToRemove */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-CCTrChListToRemove");

      pvalue->m.dl_CCTrChListToRemovePresent = 1;

      stat = asn1PD_utran_DL_CCTrChListToRemove (pctxt, &pvalue->dl_CCTrChListToRemove);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_r7 (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_r7* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DPCH-InfoPerRL-r7");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoPerRL_r7_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoPerRL_r7_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_DPCH_InfoPerRL_r7_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoPerRL_r7_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoPerRL_r7_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_DPCH_InfoPerRL_r7_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r7_dl_dpchInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_r7_dl_dpchInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_DPCH_InfoPerRL */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoPerRL");

         pvalue->u.dl_DPCH_InfoPerRL = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoPerRL_r7);

         if (pvalue->u.dl_DPCH_InfoPerRL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoPerRL_r7 (pvalue->u.dl_DPCH_InfoPerRL);

         stat = asn1PD_utran_DL_DPCH_InfoPerRL_r7 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_FDPCH_InfoPerRL */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-FDPCH-InfoPerRL");

         pvalue->u.dl_FDPCH_InfoPerRL = rtxMemAllocType (pctxt, 
            utran_DL_FDPCH_InfoPerRL_r7);

         if (pvalue->u.dl_FDPCH_InfoPerRL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_FDPCH_InfoPerRL_r7 (pvalue->u.dl_FDPCH_InfoPerRL);

         stat = asn1PD_utran_DL_FDPCH_InfoPerRL_r7 (pctxt, pvalue->u.dl_FDPCH_InfoPerRL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_r7_modeSpecific_fdd (OSCTXT* pctxt, utran_E_AGCH_Information_r7_modeSpecific_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode e_AGCH_ChannelisationCode */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-ChannelisationCode");

   stat = asn1PD_utran_E_AGCH_ChannelisationCode (pctxt, &pvalue->e_AGCH_ChannelisationCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Individual (OSCTXT* pctxt, utran_E_AGCH_Individual* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-AGCH-Individual");

   /* decode root elements */
   /* decode tS_number */
   RTXCTXTPUSHELEMNAME (pctxt, "tS-number");

   stat = pd_ConsUInt8 (pctxt, &pvalue->tS_number, OSUINTCONST(0), OSUINTCONST(14));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode channelisation_code */
   RTXCTXTPUSHELEMNAME (pctxt, "channelisation-code");

   stat = asn1PD_utran_DL_TS_ChannelisationCode (pctxt, &pvalue->channelisation_code);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleShiftAndBurstType */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_utran_MidambleShiftAndBurstType_EDCH (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Set_Config (OSCTXT* pctxt, utran_E_AGCH_Set_Config* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-AGCH-Set-Config");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_E_AGCH_Individual* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "E-AGCH-Individual", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_E_AGCH_Individual, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_E_AGCH_Individual (pdata);

      stat = asn1PD_utran_E_AGCH_Individual (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd384 (OSCTXT* pctxt, utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd384* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode long_Term_Grant_Indicator */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "long-Term-Grant-Indicator");

      pvalue->m.long_Term_Grant_IndicatorPresent = 1;

      stat = DEC_BIT (pctxt, &pvalue->long_Term_Grant_Indicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode length_of_TTRI_field */
   RTXCTXTPUSHELEMNAME (pctxt, "length-of-TTRI-field");

   stat = pd_ConsUInt8 (pctxt, &pvalue->length_of_TTRI_field, OSUINTCONST(1), OSUINTCONST(12));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_Set_Config */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-Set-Config");

   stat = asn1PD_utran_E_AGCH_Set_Config (pctxt, &pvalue->e_AGCH_Set_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_BLER_Target */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-BLER-Target");

   stat = asn1PD_utran_Bler_Target (pctxt, &pvalue->e_AGCH_BLER_Target);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Individual_VHCR (OSCTXT* pctxt, utran_E_AGCH_Individual_VHCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-AGCH-Individual-VHCR");

   /* decode root elements */
   /* decode tS_number */
   RTXCTXTPUSHELEMNAME (pctxt, "tS-number");

   stat = pd_ConsUInt8 (pctxt, &pvalue->tS_number, OSUINTCONST(0), OSUINTCONST(14));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode channelisation_code */
   RTXCTXTPUSHELEMNAME (pctxt, "channelisation-code");

   stat = asn1PD_utran_DL_TS_ChannelisationCode_VHCR (pctxt, &pvalue->channelisation_code);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleShiftAndBurstType */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShiftAndBurstType");

   stat = asn1PD_utran_MidambleShiftAndBurstType_EDCH (pctxt, &pvalue->midambleShiftAndBurstType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Set_Config_VHCR (OSCTXT* pctxt, utran_E_AGCH_Set_Config_VHCR* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-AGCH-Set-Config-VHCR");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_E_AGCH_Individual_VHCR* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "E-AGCH-Individual-VHCR", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_E_AGCH_Individual_VHCR, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_E_AGCH_Individual_VHCR (pdata);

      stat = asn1PD_utran_E_AGCH_Individual_VHCR (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd768 (OSCTXT* pctxt, utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd768* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode long_Term_Grant_Indicator */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "long-Term-Grant-Indicator");

      pvalue->m.long_Term_Grant_IndicatorPresent = 1;

      stat = DEC_BIT (pctxt, &pvalue->long_Term_Grant_Indicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode length_of_TTRI_field */
   RTXCTXTPUSHELEMNAME (pctxt, "length-of-TTRI-field");

   stat = pd_ConsUInt8 (pctxt, &pvalue->length_of_TTRI_field, OSUINTCONST(1), OSUINTCONST(12));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_Set_Config */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-Set-Config");

   stat = asn1PD_utran_E_AGCH_Set_Config_VHCR (pctxt, &pvalue->e_AGCH_Set_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_BLER_Target */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-BLER-Target");

   stat = asn1PD_utran_Bler_Target (pctxt, &pvalue->e_AGCH_BLER_Target);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Individual_LCR_midambleAllocationMode (OSCTXT* pctxt, utran_E_AGCH_Individual_LCR_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* defaultMidamble */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* commonMidamble */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "commonMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueSpecificMidamble */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "ueSpecificMidamble");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.ueSpecificMidamble, OSUINTCONST(0), OSUINTCONST(15));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Individual_LCR (OSCTXT* pctxt, utran_E_AGCH_Individual_LCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-AGCH-Individual-LCR");

   /* decode root elements */
   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber_LCR_r4 (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode firstChannelisationCode */
   RTXCTXTPUSHELEMNAME (pctxt, "firstChannelisationCode");

   stat = asn1PD_utran_HS_ChannelisationCode_LCR (pctxt, &pvalue->firstChannelisationCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode secondChannelisationCode */
   RTXCTXTPUSHELEMNAME (pctxt, "secondChannelisationCode");

   stat = asn1PD_utran_HS_ChannelisationCode_LCR (pctxt, &pvalue->secondChannelisationCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleAllocationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_utran_E_AGCH_Individual_LCR_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleConfiguration */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfiguration");

   stat = pd_ConsUInt8 (pctxt, &pvalue->midambleConfiguration, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Set_Config_LCR (OSCTXT* pctxt, utran_E_AGCH_Set_Config_LCR* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-AGCH-Set-Config-LCR");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_E_AGCH_Individual_LCR* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "E-AGCH-Individual-LCR", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_E_AGCH_Individual_LCR, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_E_AGCH_Individual_LCR (pdata);

      stat = asn1PD_utran_E_AGCH_Individual_LCR (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd128 (OSCTXT* pctxt, utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd128* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode rdi_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "rdi-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->rdi_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tpc_StepSize */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-StepSize");

   stat = asn1PD_utran_TPC_StepSizeTDD (pctxt, &pvalue->tpc_StepSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_Set_Config */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-Set-Config");

   stat = asn1PD_utran_E_AGCH_Set_Config_LCR (pctxt, &pvalue->e_AGCH_Set_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_BLER_Target */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-BLER-Target");

   stat = asn1PD_utran_Bler_Target (pctxt, &pvalue->e_AGCH_BLER_Target);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_r7_modeSpecific_tdd (OSCTXT* pctxt, utran_E_AGCH_Information_r7_modeSpecific_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         pvalue->u.tdd768 = rtxMemAllocType (pctxt, 
            utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd768);

         if (pvalue->u.tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd768 (pvalue->u.tdd768);

         stat = asn1PD_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd768 (pctxt, pvalue->u.tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_r7_modeSpecific (OSCTXT* pctxt, utran_E_AGCH_Information_r7_modeSpecific* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocTypeZ (pctxt, 
            utran_E_AGCH_Information_r7_modeSpecific_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_E_AGCH_Information_r7_modeSpecific_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_E_AGCH_Information_r7_modeSpecific_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_AGCH_Information_r7_modeSpecific_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_E_AGCH_Information_r7_modeSpecific_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_r7 (OSCTXT* pctxt, utran_E_AGCH_Information_r7* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-AGCH-Information-r7");

   /* decode root elements */
   /* decode modeSpecific */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecific");

   stat = asn1PD_utran_E_AGCH_Information_r7_modeSpecific (pctxt, &pvalue->modeSpecific);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_HICH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* e_HICH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Information");

         pvalue->u.e_HICH_Information = rtxMemAllocTypeZ (pctxt, 
            utran_E_HICH_Information);

         if (pvalue->u.e_HICH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_E_HICH_Information (pctxt, pvalue->u.e_HICH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_RGCH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* e_RGCH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "e-RGCH-Information");

         pvalue->u.e_RGCH_Information = rtxMemAllocTypeZ (pctxt, 
            utran_E_RGCH_Information);

         if (pvalue->u.e_RGCH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_E_RGCH_Information (pctxt, pvalue->u.e_RGCH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_RGCH_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RGCH-Info");

      pvalue->m.e_RGCH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_HICH_Information_TDD384_768_modeSpecificInfo (OSCTXT* pctxt, utran_E_HICH_Information_TDD384_768_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         stat = asn1PD_utran_DL_TS_ChannelisationCode (pctxt, &pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         stat = asn1PD_utran_DL_TS_ChannelisationCode_VHCR (pctxt, &pvalue->u.tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_HICH_Information_TDD384_768_burst_Type (OSCTXT* pctxt, utran_E_HICH_Information_TDD384_768_burst_Type* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode (OSCTXT* pctxt, utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_E_HICH_Information_TDD384_768 (OSCTXT* pctxt, utran_E_HICH_Information_TDD384_768* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-HICH-Information-TDD384-768");

   /* decode root elements */
   /* decode n_E_HICH */
   RTXCTXTPUSHELEMNAME (pctxt, "n-E-HICH");

   stat = pd_ConsUInt8 (pctxt, &pvalue->n_E_HICH, OSUINTCONST(4), OSUINTCONST(44));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tS_Number */
   RTXCTXTPUSHELEMNAME (pctxt, "tS-Number");

   stat = pd_ConsUInt8 (pctxt, &pvalue->tS_Number, OSUINTCONST(0), OSUINTCONST(14));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_E_HICH_Information_TDD384_768_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode burst_Type */
   RTXCTXTPUSHELEMNAME (pctxt, "burst-Type");

   stat = asn1PD_utran_E_HICH_Information_TDD384_768_burst_Type (pctxt, &pvalue->burst_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midamble_Allocation_Mode */
   RTXCTXTPUSHELEMNAME (pctxt, "midamble-Allocation-Mode");

   stat = asn1PD_utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode (pctxt, &pvalue->midamble_Allocation_Mode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd384_tdd768 (OSCTXT* pctxt, utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd384_tdd768* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_E_HICH_Information_TDD384_768 (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_HICH_Information_LCR_midambleAllocationMode (OSCTXT* pctxt, utran_E_HICH_Information_LCR_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* defaultMidamble */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueSpecificMidamble */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ueSpecificMidamble");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.ueSpecificMidamble, OSUINTCONST(0), OSUINTCONST(15));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_HICH_Information_LCR (OSCTXT* pctxt, utran_E_HICH_Information_LCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-HICH-Information-LCR");

   /* decode root elements */
   /* decode ei */
   RTXCTXTPUSHELEMNAME (pctxt, "ei");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ei, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber_LCR_r4 (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode channelisation_Code */
   RTXCTXTPUSHELEMNAME (pctxt, "channelisation-Code");

   stat = asn1PD_utran_HS_ChannelisationCode_LCR (pctxt, &pvalue->channelisation_Code);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleAllocationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_utran_E_HICH_Information_LCR_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleConfiguration */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfiguration");

   stat = pd_ConsUInt8 (pctxt, &pvalue->midambleConfiguration, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_HICH_Information_LCR_List (OSCTXT* pctxt, utran_E_HICH_Information_LCR_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-HICH-Information-LCR-List");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_E_HICH_Information_LCR* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "E-HICH-Information-LCR", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_E_HICH_Information_LCR, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_E_HICH_Information_LCR (pdata);

      stat = asn1PD_utran_E_HICH_Information_LCR (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_HICH_Information_TDD128 (OSCTXT* pctxt, utran_E_HICH_Information_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-HICH-Information-TDD128");

   /* decode root elements */
   /* decode n_E_HICH */
   RTXCTXTPUSHELEMNAME (pctxt, "n-E-HICH");

   stat = pd_ConsUInt8 (pctxt, &pvalue->n_E_HICH, OSUINTCONST(4), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_HICH_InfoList */
   RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-InfoList");

   stat = asn1PD_utran_E_HICH_Information_LCR_List (pctxt, &pvalue->e_HICH_InfoList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd128 (OSCTXT* pctxt, utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_E_HICH_Information_TDD128 (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384_tdd768 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384-tdd768");

         pvalue->u.tdd384_tdd768 = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd384_tdd768);

         if (pvalue->u.tdd384_tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd384_tdd768 (pvalue->u.tdd384_tdd768);

         stat = asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd384_tdd768 (pctxt, pvalue->u.tdd384_tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo2 (OSCTXT* pctxt, utran_DL_InformationPerRL_r7_modeSpecificInfo2* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r7 (OSCTXT* pctxt, utran_DL_InformationPerRL_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_dpchInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dpchInfo");

      pvalue->m.dl_dpchInfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r7_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_AGCH_Information */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-Information");

      pvalue->m.e_AGCH_InformationPresent = 1;

      stat = asn1PD_utran_E_AGCH_Information_r7 (pctxt, &pvalue->e_AGCH_Information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo2 */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo2");

   stat = asn1PD_utran_DL_InformationPerRL_r7_modeSpecificInfo2 (pctxt, &pvalue->modeSpecificInfo2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cell_id */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cell-id");

      pvalue->m.cell_idPresent = 1;

      stat = asn1PD_utran_CellIdentity (pctxt, &pvalue->cell_id);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_List_r7 (OSCTXT* pctxt, utran_DL_InformationPerRL_List_r7* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-List-r7");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_InformationPerRL_r7* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-InformationPerRL-r7", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_InformationPerRL_r7, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_InformationPerRL_r7 (pdata);

      stat = asn1PD_utran_DL_InformationPerRL_r7 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MBMS_SessionIdentity (OSCTXT* pctxt, utran_MBMS_SessionIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMS-SessionIdentity");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_Info_r7_mbms_ServiceIdentity (OSCTXT* pctxt, utran_RAB_Info_r7_mbms_ServiceIdentity* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_Info_r7 (OSCTXT* pctxt, utran_RAB_Info_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-Info-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rab_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rab-Identity");

   stat = asn1PD_utran_RAB_Identity (pctxt, &pvalue->rab_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mbms_SessionIdentity */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mbms-SessionIdentity");

      pvalue->m.mbms_SessionIdentityPresent = 1;

      stat = asn1PD_utran_MBMS_SessionIdentity (pctxt, &pvalue->mbms_SessionIdentity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mbms_ServiceIdentity */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mbms-ServiceIdentity");

      pvalue->m.mbms_ServiceIdentityPresent = 1;

      stat = asn1PD_utran_RAB_Info_r7_mbms_ServiceIdentity (pctxt, &pvalue->mbms_ServiceIdentity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cn_DomainIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "cn-DomainIdentity");

   stat = asn1PD_utran_CN_DomainIdentity (pctxt, &pvalue->cn_DomainIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nas_Synchronisation_Indicator */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nas-Synchronisation-Indicator");

      pvalue->m.nas_Synchronisation_IndicatorPresent = 1;

      stat = asn1PD_utran_NAS_Synchronisation_Indicator (pctxt, &pvalue->nas_Synchronisation_Indicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode re_EstablishmentTimer */
   RTXCTXTPUSHELEMNAME (pctxt, "re-EstablishmentTimer");

   stat = asn1PD_utran_Re_EstablishmentTimer (pctxt, &pvalue->re_EstablishmentTimer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RLC_InfoChoice_r7 (OSCTXT* pctxt, utran_RLC_InfoChoice_r7* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "RLC-InfoChoice-r7");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rlc_Info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rlc-Info");

         pvalue->u.rlc_Info = rtxMemAllocType (pctxt, utran_RLC_Info_r7);

         if (pvalue->u.rlc_Info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_RLC_Info_r7 (pvalue->u.rlc_Info);

         stat = asn1PD_utran_RLC_Info_r7 (pctxt, pvalue->u.rlc_Info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* same_as_RB */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "same-as-RB");

         stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->u.same_as_RB);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationSetup_r7 (OSCTXT* pctxt, utran_RB_InformationSetup_r7* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationSetup-r7");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdcp_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Info");

      pvalue->m.pdcp_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_Info_r4 (pctxt, &pvalue->pdcp_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_InfoChoice */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-InfoChoice");

   stat = asn1PD_utran_RLC_InfoChoice_r7 (pctxt, &pvalue->rlc_InfoChoice);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_MappingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

   stat = asn1PD_utran_RB_MappingInfo_r7 (pctxt, &pvalue->rb_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationSetupList_r7 (OSCTXT* pctxt, utran_RB_InformationSetupList_r7* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationSetupList-r7");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationSetup_r7* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationSetup-r7", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationSetup_r7, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationSetup_r7 (pdata);

      stat = asn1PD_utran_RB_InformationSetup_r7 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_InformationSetup_r7 (OSCTXT* pctxt, utran_RAB_InformationSetup_r7* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-InformationSetup-r7");

   /* decode root elements */
   /* decode rab_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "rab-Info");

   stat = asn1PD_utran_RAB_Info_r7 (pctxt, &pvalue->rab_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_InformationSetupList */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-InformationSetupList");

   stat = asn1PD_utran_RB_InformationSetupList_r7 (pctxt, &pvalue->rb_InformationSetupList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AMR_Rate (OSCTXT* pctxt, utran_UL_AMR_Rate* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-AMR-Rate");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MaxCS_Delay (OSCTXT* pctxt, utran_MaxCS_Delay* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MaxCS-Delay");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(18));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CS_HSPA_Information (OSCTXT* pctxt, utran_CS_HSPA_Information* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CS-HSPA-Information");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_AMR_Rate */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-AMR-Rate");

      pvalue->m.ul_AMR_RatePresent = 1;

      stat = asn1PD_utran_UL_AMR_Rate (pctxt, &pvalue->ul_AMR_Rate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode maxCS_Delay */
   RTXCTXTPUSHELEMNAME (pctxt, "maxCS-Delay");

   stat = asn1PD_utran_MaxCS_Delay (pctxt, &pvalue->maxCS_Delay);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_InformationSetup_v820ext (OSCTXT* pctxt, utran_RAB_InformationSetup_v820ext* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-InformationSetup-v820ext");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cs_HSPA_Information */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cs-HSPA-Information");

      pvalue->m.cs_HSPA_InformationPresent = 1;

      stat = asn1PD_utran_CS_HSPA_Information (pctxt, &pvalue->cs_HSPA_Information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DefaultConfigMode (OSCTXT* pctxt, utran_DefaultConfigMode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DefaultConfigMode");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DefaultConfigIdForCellFACH (OSCTXT* pctxt, utran_DefaultConfigIdForCellFACH* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DefaultConfigIdForCellFACH");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DefaultConfigForCellFACH (OSCTXT* pctxt, utran_DefaultConfigForCellFACH* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DefaultConfigForCellFACH");

   /* decode root elements */
   /* decode defaultConfigMode */
   RTXCTXTPUSHELEMNAME (pctxt, "defaultConfigMode");

   stat = asn1PD_utran_DefaultConfigMode (pctxt, &pvalue->defaultConfigMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode defaultConfigIdForCellFACH */
   RTXCTXTPUSHELEMNAME (pctxt, "defaultConfigIdForCellFACH");

   stat = asn1PD_utran_DefaultConfigIdForCellFACH (pctxt, &pvalue->defaultConfigIdForCellFACH);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_InfoReplace (OSCTXT* pctxt, utran_RAB_InfoReplace* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-InfoReplace");

   /* decode root elements */
   /* decode rab_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rab-Identity");

   stat = asn1PD_utran_RAB_Identity (pctxt, &pvalue->rab_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cn_DomainIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "cn-DomainIdentity");

   stat = asn1PD_utran_CN_DomainIdentity (pctxt, &pvalue->cn_DomainIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch_rlc_SizeList (OSCTXT* pctxt, utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch_rlc_SizeList* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* allSizes */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "allSizes");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* configured */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "configured");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* explicitList */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "explicitList");

         pvalue->u.explicitList = rtxMemAllocType (pctxt, 
            utran_RLC_SizeExplicitList);

         if (pvalue->u.explicitList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_RLC_SizeExplicitList (pvalue->u.explicitList);

         stat = asn1PD_utran_RLC_SizeExplicitList (pctxt, pvalue->u.explicitList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch (OSCTXT* pctxt, utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TransportChannelType");

   stat = asn1PD_utran_UL_TransportChannelType (pctxt, &pvalue->ul_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode logicalChannelIdentity */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelIdentity");

      pvalue->m.logicalChannelIdentityPresent = 1;

      stat = asn1PD_utran_LogicalChannelIdentity (pctxt, &pvalue->logicalChannelIdentity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_SizeList */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-SizeList");

   stat = asn1PD_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch_rlc_SizeList (pctxt, &pvalue->rlc_SizeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size_fixedSize (OSCTXT* pctxt, utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size_fixedSize* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ddi */
   RTXCTXTPUSHELEMNAME (pctxt, "ddi");

   stat = asn1PD_utran_DDI (pctxt, &pvalue->ddi);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rlc_PDU_SizeList */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-PDU-SizeList");

   stat = asn1PD_utran_RLC_PDU_SizeList (pctxt, &pvalue->rlc_PDU_SizeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RLC_PDU_SizeConstraint_lengthIndicatorSize (OSCTXT* pctxt, utran_RLC_PDU_SizeConstraint_lengthIndicatorSize* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_RLC_PDU_SizeConstraint (OSCTXT* pctxt, utran_RLC_PDU_SizeConstraint* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RLC-PDU-SizeConstraint");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lengthIndicatorSize */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lengthIndicatorSize");

      pvalue->m.lengthIndicatorSizePresent = 1;

      stat = asn1PD_utran_RLC_PDU_SizeConstraint_lengthIndicatorSize (pctxt, &pvalue->lengthIndicatorSize);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode minRLC_PDU_Size */
   RTXCTXTPUSHELEMNAME (pctxt, "minRLC-PDU-Size");

   stat = pd_ConsUInt16 (pctxt, &pvalue->minRLC_PDU_Size, OSUINTCONST(0), OSUINTCONST(1503));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode largestRLC_PDU_Size */
   RTXCTXTPUSHELEMNAME (pctxt, "largestRLC-PDU-Size");

   stat = pd_ConsUInt16 (pctxt, &pvalue->largestRLC_PDU_Size, OSUINTCONST(0), OSUINTCONST(1503));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size (OSCTXT* pctxt, utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fixedSize */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fixedSize");

         pvalue->u.fixedSize = rtxMemAllocType (pctxt, 
            utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size_fixedSize);

         if (pvalue->u.fixedSize == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size_fixedSize (pvalue->u.fixedSize);

         stat = asn1PD_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size_fixedSize (pctxt, pvalue->u.fixedSize);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* flexibleSize */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "flexibleSize");

         pvalue->u.flexibleSize = rtxMemAllocType (pctxt, 
            utran_RLC_PDU_SizeConstraint);

         if (pvalue->u.flexibleSize == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_RLC_PDU_SizeConstraint (pvalue->u.flexibleSize);

         stat = asn1PD_utran_RLC_PDU_SizeConstraint (pctxt, pvalue->u.flexibleSize);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch (OSCTXT* pctxt, utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode logicalChannelIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelIdentity");

   stat = asn1PD_utran_LogicalChannelIdentity (pctxt, &pvalue->logicalChannelIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_DCH_MAC_d_FlowIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "e-DCH-MAC-d-FlowIdentity");

   stat = asn1PD_utran_E_DCH_MAC_d_FlowIdentity (pctxt, &pvalue->e_DCH_MAC_d_FlowIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rlc_PDU_Size */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-PDU-Size");

   stat = asn1PD_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size (pctxt, &pvalue->rlc_PDU_Size);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode includeInSchedulingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "includeInSchedulingInfo");

   stat = DEC_BIT (pctxt, &pvalue->includeInSchedulingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type (OSCTXT* pctxt, utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dch_rach_usch */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dch-rach-usch");

         pvalue->u.dch_rach_usch = rtxMemAllocType (pctxt, 
            utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch);

         if (pvalue->u.dch_rach_usch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch (pvalue->u.dch_rach_usch);

         stat = asn1PD_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch (pctxt, pvalue->u.dch_rach_usch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* e_dch */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "e-dch");

         pvalue->u.e_dch = rtxMemAllocType (pctxt, 
            utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch);

         if (pvalue->u.e_dch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch (pvalue->u.e_dch);

         stat = asn1PD_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch (pctxt, pvalue->u.e_dch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMapping_r8 (OSCTXT* pctxt, utran_UL_LogicalChannelMapping_r8* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-LogicalChannelMapping-r8");

   /* decode root elements */
   /* decode ul_TrCH_Type */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TrCH-Type");

   stat = asn1PD_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type (pctxt, &pvalue->ul_TrCH_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_LogicalChannelPriority */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-LogicalChannelPriority");

   stat = asn1PD_utran_MAC_LogicalChannelPriority (pctxt, &pvalue->mac_LogicalChannelPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMappingList_r8_ul_LogicalChannelMapping (OSCTXT* pctxt, utran_UL_LogicalChannelMappingList_r8_ul_LogicalChannelMapping* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UL_LogicalChannelMapping_r8* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-LogicalChannelMapping-r8", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UL_LogicalChannelMapping_r8, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UL_LogicalChannelMapping_r8 (pdata);

      stat = asn1PD_utran_UL_LogicalChannelMapping_r8 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMappingList_r8 (OSCTXT* pctxt, utran_UL_LogicalChannelMappingList_r8* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-LogicalChannelMappingList-r8");

   /* decode root elements */
   /* decode rlc_LogicalChannelMappingIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-LogicalChannelMappingIndicator");

   stat = DEC_BIT (pctxt, &pvalue->rlc_LogicalChannelMappingIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_LogicalChannelMapping */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-LogicalChannelMapping");

   stat = asn1PD_utran_UL_LogicalChannelMappingList_r8_ul_LogicalChannelMapping (pctxt, &pvalue->ul_LogicalChannelMapping);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_LogicalChannelMappings_r8 (OSCTXT* pctxt, utran_UL_LogicalChannelMappings_r8* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-LogicalChannelMappings-r8");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* oneLogicalChannel */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "oneLogicalChannel");

         pvalue->u.oneLogicalChannel = rtxMemAllocType (pctxt, 
            utran_UL_LogicalChannelMapping_r8);

         if (pvalue->u.oneLogicalChannel == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_LogicalChannelMapping_r8 (pvalue->u.oneLogicalChannel);

         stat = asn1PD_utran_UL_LogicalChannelMapping_r8 (pctxt, pvalue->u.oneLogicalChannel);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* twoLogicalChannels */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "twoLogicalChannels");

         pvalue->u.twoLogicalChannels = rtxMemAllocType (pctxt, 
            utran_UL_LogicalChannelMappingList_r8);

         if (pvalue->u.twoLogicalChannels == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_LogicalChannelMappingList_r8 (pvalue->u.twoLogicalChannels);

         stat = asn1PD_utran_UL_LogicalChannelMappingList_r8 (pctxt, pvalue->u.twoLogicalChannels);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_MappingOption_r8 (OSCTXT* pctxt, utran_RB_MappingOption_r8* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-MappingOption-r8");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_LogicalChannelMappings */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-LogicalChannelMappings");

      pvalue->m.ul_LogicalChannelMappingsPresent = 1;

      stat = asn1PD_utran_UL_LogicalChannelMappings_r8 (pctxt, &pvalue->ul_LogicalChannelMappings);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_LogicalChannelMappingList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-LogicalChannelMappingList");

      pvalue->m.dl_LogicalChannelMappingListPresent = 1;

      stat = asn1PD_utran_DL_LogicalChannelMappingList_r7 (pctxt, &pvalue->dl_LogicalChannelMappingList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_MappingInfo_r8 (OSCTXT* pctxt, utran_RB_MappingInfo_r8* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-MappingInfo-r8");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_MappingOption_r8* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-MappingOption-r8", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_MappingOption_r8, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_MappingOption_r8 (pdata);

      stat = asn1PD_utran_RB_MappingOption_r8 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationSetup_r8 (OSCTXT* pctxt, utran_RB_InformationSetup_r8* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationSetup-r8");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdcp_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Info");

      pvalue->m.pdcp_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_Info_r4 (pctxt, &pvalue->pdcp_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_InfoChoice */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-InfoChoice");

   stat = asn1PD_utran_RLC_InfoChoice_r7 (pctxt, &pvalue->rlc_InfoChoice);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_MappingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

   stat = asn1PD_utran_RB_MappingInfo_r8 (pctxt, &pvalue->rb_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationSetupList_r8 (OSCTXT* pctxt, utran_RB_InformationSetupList_r8* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationSetupList-r8");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationSetup_r8* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationSetup-r8", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationSetup_r8, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationSetup_r8 (pdata);

      stat = asn1PD_utran_RB_InformationSetup_r8 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_InformationSetup_r8 (OSCTXT* pctxt, utran_RAB_InformationSetup_r8* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-InformationSetup-r8");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rab_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "rab-Info");

   stat = asn1PD_utran_RAB_Info_r7 (pctxt, &pvalue->rab_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cs_HSPA_Information */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cs-HSPA-Information");

      pvalue->m.cs_HSPA_InformationPresent = 1;

      stat = asn1PD_utran_CS_HSPA_Information (pctxt, &pvalue->cs_HSPA_Information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rab_InfoReplace */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rab-InfoReplace");

      pvalue->m.rab_InfoReplacePresent = 1;

      stat = asn1PD_utran_RAB_InfoReplace (pctxt, &pvalue->rab_InfoReplace);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_InformationSetupList */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-InformationSetupList");

   stat = asn1PD_utran_RB_InformationSetupList_r8 (pctxt, &pvalue->rb_InformationSetupList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationReconfig_r8 (OSCTXT* pctxt, utran_RB_InformationReconfig_r8* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationReconfig-r8");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdcp_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Info");

      pvalue->m.pdcp_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_InfoReconfig_r4 (pctxt, &pvalue->pdcp_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pdcp_SN_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-SN-Info");

      pvalue->m.pdcp_SN_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_SN_Info (pctxt, &pvalue->pdcp_SN_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_Info */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlc-Info");

      pvalue->m.rlc_InfoPresent = 1;

      stat = asn1PD_utran_RLC_Info_r7 (pctxt, &pvalue->rlc_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_MappingInfo */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

      pvalue->m.rb_MappingInfoPresent = 1;

      stat = asn1PD_utran_RB_MappingInfo_r8 (pctxt, &pvalue->rb_MappingInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_StopContinue */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-StopContinue");

      pvalue->m.rb_StopContinuePresent = 1;

      stat = asn1PD_utran_RB_StopContinue (pctxt, &pvalue->rb_StopContinue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationReconfigList_r8 (OSCTXT* pctxt, utran_RB_InformationReconfigList_r8* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationReconfigList-r8");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationReconfig_r8* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationReconfig-r8", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationReconfig_r8, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationReconfig_r8 (pdata);

      stat = asn1PD_utran_RB_InformationReconfig_r8 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationAffected_r8 (OSCTXT* pctxt, utran_RB_InformationAffected_r8* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationAffected-r8");

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_MappingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

   stat = asn1PD_utran_RB_MappingInfo_r8 (pctxt, &pvalue->rb_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationAffectedList_r8 (OSCTXT* pctxt, utran_RB_InformationAffectedList_r8* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationAffectedList-r8");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationAffected_r8* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationAffected-r8", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationAffected_r8, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationAffected_r8 (pdata);

      stat = asn1PD_utran_RB_InformationAffected_r8 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r8_dch_usch (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r8_dch_usch* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ul_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TransportChannelType");

   stat = asn1PD_utran_UL_TrCH_Type (pctxt, &pvalue->ul_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportChannelIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "transportChannelIdentity");

   stat = asn1PD_utran_TransportChannelIdentity (pctxt, &pvalue->transportChannelIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportFormatSet */
   RTXCTXTPUSHELEMNAME (pctxt, "transportFormatSet");

   stat = asn1PD_utran_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_mac_iis; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r8_e_dch_modeSpecific_fdd (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r8_e_dch_modeSpecific_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tti */
   RTXCTXTPUSHELEMNAME (pctxt, "tti");

   stat = asn1PD_utran_E_DCH_TTI (pctxt, &pvalue->tti);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r8_e_dch_modeSpecific (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r8_e_dch_modeSpecific* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocTypeZ (pctxt, 
            utran_UL_AddReconfTransChInformation_r8_e_dch_modeSpecific_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UL_AddReconfTransChInformation_r8_e_dch_modeSpecific_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r8_e_dch (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r8_e_dch* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_MAC_HeaderType */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-MAC-HeaderType");

      pvalue->m.ul_MAC_HeaderTypePresent = 1;

      stat = asn1PD_utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType (pctxt, &pvalue->ul_MAC_HeaderType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecific */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecific");

   stat = asn1PD_utran_UL_AddReconfTransChInformation_r8_e_dch_modeSpecific (pctxt, &pvalue->modeSpecific);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode harq_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "harq-Info");

   stat = asn1PD_utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info (pctxt, &pvalue->harq_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode addReconf_MAC_d_FlowList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "addReconf-MAC-d-FlowList");

      pvalue->m.addReconf_MAC_d_FlowListPresent = 1;

      stat = asn1PD_utran_E_DCH_AddReconf_MAC_d_FlowList_r7 (pctxt, &pvalue->addReconf_MAC_d_FlowList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInformation_r8 (OSCTXT* pctxt, utran_UL_AddReconfTransChInformation_r8* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-AddReconfTransChInformation-r8");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dch_usch */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dch-usch");

         pvalue->u.dch_usch = rtxMemAllocType (pctxt, 
            utran_UL_AddReconfTransChInformation_r8_dch_usch);

         if (pvalue->u.dch_usch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_AddReconfTransChInformation_r8_dch_usch (pvalue->u.dch_usch);

         stat = asn1PD_utran_UL_AddReconfTransChInformation_r8_dch_usch (pctxt, pvalue->u.dch_usch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* e_dch */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "e-dch");

         pvalue->u.e_dch = rtxMemAllocType (pctxt, 
            utran_UL_AddReconfTransChInformation_r8_e_dch);

         if (pvalue->u.e_dch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_AddReconfTransChInformation_r8_e_dch (pvalue->u.e_dch);

         stat = asn1PD_utran_UL_AddReconfTransChInformation_r8_e_dch (pctxt, pvalue->u.e_dch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_AddReconfTransChInfoList_r8 (OSCTXT* pctxt, utran_UL_AddReconfTransChInfoList_r8* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-AddReconfTransChInfoList-r8");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UL_AddReconfTransChInformation_r8* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-AddReconfTransChInformation-r8", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UL_AddReconfTransChInformation_r8, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UL_AddReconfTransChInformation_r8 (pdata);

      stat = asn1PD_utran_UL_AddReconfTransChInformation_r8 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator (OSCTXT* pctxt, utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__305; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_DPDCH_Info_r8 (OSCTXT* pctxt, utran_E_DPDCH_Info_r8* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "E-DPDCH-Info-r8");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_TFCI_TableIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "e-TFCI-TableIndex");

   stat = asn1PD_utran_E_TFCI_TableIndex (pctxt, &pvalue->e_TFCI_TableIndex);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_DCH_MinimumSet_E_TFCI */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-DCH-MinimumSet-E-TFCI");

      pvalue->m.e_DCH_MinimumSet_E_TFCIPresent = 1;

      stat = asn1PD_utran_E_DCH_MinimumSet_E_TFCI (pctxt, &pvalue->e_DCH_MinimumSet_E_TFCI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode reference_E_TFCIs */
   RTXCTXTPUSHELEMNAME (pctxt, "reference-E-TFCIs");

   stat = asn1PD_utran_E_DPDCH_Reference_E_TFCIList_r7 (pctxt, &pvalue->reference_E_TFCIs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode minReduced_E_DPDCH_GainFactor */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "minReduced-E-DPDCH-GainFactor");

      pvalue->m.minReduced_E_DPDCH_GainFactorPresent = 1;

      stat = asn1PD_utran_MinReduced_E_DPDCH_GainFactor (pctxt, &pvalue->minReduced_E_DPDCH_GainFactor);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode maxChannelisationCodes */
   RTXCTXTPUSHELEMNAME (pctxt, "maxChannelisationCodes");

   stat = asn1PD_utran_E_DPDCH_MaxChannelisationCodes (pctxt, &pvalue->maxChannelisationCodes);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pl_NonMax */
   RTXCTXTPUSHELEMNAME (pctxt, "pl-NonMax");

   stat = asn1PD_utran_E_DPDCH_PL_NonMax (pctxt, &pvalue->pl_NonMax);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode schedulingInfoConfiguration */
   RTXCTXTPUSHELEMNAME (pctxt, "schedulingInfoConfiguration");

   stat = asn1PD_utran_E_DPDCH_SchedulingInfoConfiguration (pctxt, &pvalue->schedulingInfoConfiguration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threeIndexStepThreshold */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "threeIndexStepThreshold");

      pvalue->m.threeIndexStepThresholdPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->threeIndexStepThreshold, OSUINTCONST(0), OSUINTCONST(37));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode twoIndexStepThreshold */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "twoIndexStepThreshold");

      pvalue->m.twoIndexStepThresholdPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->twoIndexStepThreshold, OSUINTCONST(0), OSUINTCONST(37));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r8_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_UL_EDCH_Information_r8_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_DPCCH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-DPCCH-Info");

      pvalue->m.e_DPCCH_InfoPresent = 1;

      stat = asn1PD_utran_E_DPCCH_Info_r7 (pctxt, &pvalue->e_DPCCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_DPDCH_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-DPDCH-Info");

      pvalue->m.e_DPDCH_InfoPresent = 1;

      stat = asn1PD_utran_E_DPDCH_Info_r8 (pctxt, &pvalue->e_DPDCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode schedulingTransmConfiguration */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "schedulingTransmConfiguration");

      pvalue->m.schedulingTransmConfigurationPresent = 1;

      stat = asn1PD_utran_E_DPDCH_SchedulingTransmConfiguration (pctxt, &pvalue->schedulingTransmConfiguration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_16QAM_Settings */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-16QAM-Settings");

      pvalue->m.ul_16QAM_SettingsPresent = 1;

      stat = asn1PD_utran_UL_16QAM_Settings (pctxt, &pvalue->ul_16QAM_Settings);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r8_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_UL_EDCH_Information_r8_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_RUCCH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RUCCH-Info");

      pvalue->m.e_RUCCH_InfoPresent = 1;

      stat = asn1PD_utran_E_RUCCH_Info (pctxt, &pvalue->e_RUCCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_PUCH_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-PUCH-Info");

      pvalue->m.e_PUCH_InfoPresent = 1;

      stat = asn1PD_utran_E_PUCH_Info (pctxt, &pvalue->e_PUCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode non_ScheduledTransGrantInfo */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "non-ScheduledTransGrantInfo");

      pvalue->m.non_ScheduledTransGrantInfoPresent = 1;

      stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD (pctxt, &pvalue->non_ScheduledTransGrantInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r8_modeSpecificInfo (OSCTXT* pctxt, utran_UL_EDCH_Information_r8_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_EDCH_Information_r8_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_EDCH_Information_r8_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_EDCH_Information_r8_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_EDCH_Information_r8_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_EDCH_Information_r8_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_EDCH_Information_r8_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r8 (OSCTXT* pctxt, utran_UL_EDCH_Information_r8* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-EDCH-Information-r8");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_es_e_resetIndicator */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-es-e-resetIndicator");

      pvalue->m.mac_es_e_resetIndicatorPresent = 1;

      stat = asn1PD_utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator (pctxt, &pvalue->mac_es_e_resetIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_UL_EDCH_Information_r8_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r8_dl_dpchInfoCommon (OSCTXT* pctxt, utran_DL_CommonInformation_r8_dl_dpchInfoCommon* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_DPCH_InfoCommon */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoCommon");

         pvalue->u.dl_DPCH_InfoCommon = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r6);

         if (pvalue->u.dl_DPCH_InfoCommon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r6 (pvalue->u.dl_DPCH_InfoCommon);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_DPCH_InfoCommon);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_FDPCH_InfoCommon */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-FDPCH-InfoCommon");

         pvalue->u.dl_FDPCH_InfoCommon = rtxMemAllocType (pctxt, 
            utran_DL_FDPCH_InfoCommon_r6);

         if (pvalue->u.dl_FDPCH_InfoCommon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_FDPCH_InfoCommon_r6 (pvalue->u.dl_FDPCH_InfoCommon);

         stat = asn1PD_utran_DL_FDPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_FDPCH_InfoCommon);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TGP_Sequence_r8_tgps_Status_activate (OSCTXT* pctxt, utran_TGP_Sequence_r8_tgps_Status_activate* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tgcfn */
   RTXCTXTPUSHELEMNAME (pctxt, "tgcfn");

   stat = asn1PD_utran_TGCFN (pctxt, &pvalue->tgcfn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGP_Sequence_r8_tgps_Status (OSCTXT* pctxt, utran_TGP_Sequence_r8_tgps_Status* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* activate */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "activate");

         pvalue->u.activate = rtxMemAllocTypeZ (pctxt, 
            utran_TGP_Sequence_r8_tgps_Status_activate);

         if (pvalue->u.activate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_TGP_Sequence_r8_tgps_Status_activate (pctxt, pvalue->u.activate);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* deactivate */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "deactivate");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TGMP_r8 (OSCTXT* pctxt, utran_TGMP_r8* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TGMP-r8");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGPS_ConfigurationParams_r8 (OSCTXT* pctxt, utran_TGPS_ConfigurationParams_r8* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "TGPS-ConfigurationParams-r8");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tgmp */
   RTXCTXTPUSHELEMNAME (pctxt, "tgmp");

   stat = asn1PD_utran_TGMP_r8 (pctxt, &pvalue->tgmp);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgprc */
   RTXCTXTPUSHELEMNAME (pctxt, "tgprc");

   stat = asn1PD_utran_TGPRC (pctxt, &pvalue->tgprc);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgsn */
   RTXCTXTPUSHELEMNAME (pctxt, "tgsn");

   stat = asn1PD_utran_TGSN (pctxt, &pvalue->tgsn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgl1 */
   RTXCTXTPUSHELEMNAME (pctxt, "tgl1");

   stat = asn1PD_utran_TGL (pctxt, &pvalue->tgl1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgl2 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tgl2");

      pvalue->m.tgl2Present = 1;

      stat = asn1PD_utran_TGL (pctxt, &pvalue->tgl2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tgd */
   RTXCTXTPUSHELEMNAME (pctxt, "tgd");

   stat = asn1PD_utran_TGD (pctxt, &pvalue->tgd);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgpl1 */
   RTXCTXTPUSHELEMNAME (pctxt, "tgpl1");

   stat = asn1PD_utran_TGPL (pctxt, &pvalue->tgpl1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rpp */
   RTXCTXTPUSHELEMNAME (pctxt, "rpp");

   stat = asn1PD_utran_RPP (pctxt, &pvalue->rpp);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode itp */
   RTXCTXTPUSHELEMNAME (pctxt, "itp");

   stat = asn1PD_utran_ITP (pctxt, &pvalue->itp);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_DL_Mode */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-DL-Mode");

   stat = asn1PD_utran_UL_DL_Mode (pctxt, &pvalue->ul_DL_Mode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_FrameType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-FrameType");

   stat = asn1PD_utran_DL_FrameType (pctxt, &pvalue->dl_FrameType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaSIR1 */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaSIR1");

   stat = asn1PD_utran_DeltaSIR (pctxt, &pvalue->deltaSIR1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaSIRAfter1 */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaSIRAfter1");

   stat = asn1PD_utran_DeltaSIR (pctxt, &pvalue->deltaSIRAfter1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaSIR2 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaSIR2");

      pvalue->m.deltaSIR2Present = 1;

      stat = asn1PD_utran_DeltaSIR (pctxt, &pvalue->deltaSIR2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode deltaSIRAfter2 */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaSIRAfter2");

      pvalue->m.deltaSIRAfter2Present = 1;

      stat = asn1PD_utran_DeltaSIR (pctxt, &pvalue->deltaSIRAfter2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nidentifyAbort */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nidentifyAbort");

      pvalue->m.nidentifyAbortPresent = 1;

      stat = asn1PD_utran_NidentifyAbort (pctxt, &pvalue->nidentifyAbort);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode treconfirmAbort */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "treconfirmAbort");

      pvalue->m.treconfirmAbortPresent = 1;

      stat = asn1PD_utran_TreconfirmAbort (pctxt, &pvalue->treconfirmAbort);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGP_Sequence_r8 (OSCTXT* pctxt, utran_TGP_Sequence_r8* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TGP-Sequence-r8");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tgpsi */
   RTXCTXTPUSHELEMNAME (pctxt, "tgpsi");

   stat = asn1PD_utran_TGPSI (pctxt, &pvalue->tgpsi);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgps_Status */
   RTXCTXTPUSHELEMNAME (pctxt, "tgps-Status");

   stat = asn1PD_utran_TGP_Sequence_r8_tgps_Status (pctxt, &pvalue->tgps_Status);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgps_ConfigurationParams */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tgps-ConfigurationParams");

      pvalue->m.tgps_ConfigurationParamsPresent = 1;

      stat = asn1PD_utran_TGPS_ConfigurationParams_r8 (pctxt, &pvalue->tgps_ConfigurationParams);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGP_SequenceList_r8 (OSCTXT* pctxt, utran_TGP_SequenceList_r8* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TGP-SequenceList-r8");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(6), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_TGP_Sequence_r8* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TGP-Sequence-r8", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_TGP_Sequence_r8, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_TGP_Sequence_r8 (pdata);

      stat = asn1PD_utran_TGP_Sequence_r8 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DPCH_CompressedModeInfo_r8 (OSCTXT* pctxt, utran_DPCH_CompressedModeInfo_r8* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DPCH-CompressedModeInfo-r8");

   /* decode root elements */
   /* decode tgp_SequenceList */
   RTXCTXTPUSHELEMNAME (pctxt, "tgp-SequenceList");

   stat = asn1PD_utran_TGP_SequenceList_r8 (pctxt, &pvalue->tgp_SequenceList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r8_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_CommonInformation_r8_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueFDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dpch_CompressedModeInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dpch-CompressedModeInfo");

      pvalue->m.dpch_CompressedModeInfoPresent = 1;

      stat = asn1PD_utran_DPCH_CompressedModeInfo_r8 (pctxt, &pvalue->dpch_CompressedModeInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tx_DiversityMode */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tx-DiversityMode");

      pvalue->m.tx_DiversityModePresent = 1;

      stat = asn1PD_utran_TX_DiversityMode (pctxt, &pvalue->tx_DiversityMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r8_modeSpecificInfo_tdd_tddOption_tdd128 (OSCTXT* pctxt, utran_DL_CommonInformation_r8_modeSpecificInfo_tdd_tddOption_tdd128* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tstd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "tstd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->tstd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r8_modeSpecificInfo_tdd_tddOption (OSCTXT* pctxt, utran_DL_CommonInformation_r8_modeSpecificInfo_tdd_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocTypeZ (pctxt, 
            utran_DL_CommonInformation_r8_modeSpecificInfo_tdd_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_CommonInformation_r8_modeSpecificInfo_tdd_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r8_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_CommonInformation_r8_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_DL_CommonInformation_r8_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueTDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r8_modeSpecificInfo (OSCTXT* pctxt, utran_DL_CommonInformation_r8_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r8_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r8_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_CommonInformation_r8_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r8_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r8_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_CommonInformation_r8_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r8_mac_hsResetIndicator (OSCTXT* pctxt, utran_DL_CommonInformation_r8_mac_hsResetIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__269; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r8_postVerificationPeriod (OSCTXT* pctxt, utran_DL_CommonInformation_r8_postVerificationPeriod* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__270; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r8 (OSCTXT* pctxt, utran_DL_CommonInformation_r8* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CommonInformation-r8");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_dpchInfoCommon */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dpchInfoCommon");

      pvalue->m.dl_dpchInfoCommonPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r8_dl_dpchInfoCommon (pctxt, &pvalue->dl_dpchInfoCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_CommonInformation_r8_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_hsResetIndicator */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-hsResetIndicator");

      pvalue->m.mac_hsResetIndicatorPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r8_mac_hsResetIndicator (pctxt, &pvalue->mac_hsResetIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode postVerificationPeriod */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "postVerificationPeriod");

      pvalue->m.postVerificationPeriodPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r8_postVerificationPeriod (pctxt, &pvalue->postVerificationPeriod);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r8_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode primaryCPICH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCPICH-Info");

   stat = asn1PD_utran_PrimaryCPICH_Info (pctxt, &pvalue->primaryCPICH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode servingHSDSCH_RL_indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "servingHSDSCH-RL-indicator");

   stat = DEC_BIT (pctxt, &pvalue->servingHSDSCH_RL_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode servingEDCH_RL_indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "servingEDCH-RL-indicator");

   stat = DEC_BIT (pctxt, &pvalue->servingEDCH_RL_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_r8_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocTypeZ (pctxt, 
            utran_DL_InformationPerRL_r8_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, utran_PrimaryCCPCH_Info_r4);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_PrimaryCCPCH_Info_r4 (pvalue->u.tdd);

         stat = asn1PD_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r8_dl_dpchInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_r8_dl_dpchInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_DPCH_InfoPerRL */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoPerRL");

         pvalue->u.dl_DPCH_InfoPerRL = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoPerRL_r7);

         if (pvalue->u.dl_DPCH_InfoPerRL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoPerRL_r7 (pvalue->u.dl_DPCH_InfoPerRL);

         stat = asn1PD_utran_DL_DPCH_InfoPerRL_r7 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_FDPCH_InfoPerRL */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-FDPCH-InfoPerRL");

         pvalue->u.dl_FDPCH_InfoPerRL = rtxMemAllocType (pctxt, 
            utran_DL_FDPCH_InfoPerRL_r7);

         if (pvalue->u.dl_FDPCH_InfoPerRL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_FDPCH_InfoPerRL_r7 (pvalue->u.dl_FDPCH_InfoPerRL);

         stat = asn1PD_utran_DL_FDPCH_InfoPerRL_r7 (pctxt, pvalue->u.dl_FDPCH_InfoPerRL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_r8_modeSpecific_fdd (OSCTXT* pctxt, utran_E_AGCH_Information_r8_modeSpecific_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode e_AGCH_ChannelisationCode */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-ChannelisationCode");

   stat = asn1PD_utran_E_AGCH_ChannelisationCode (pctxt, &pvalue->e_AGCH_ChannelisationCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd384 (OSCTXT* pctxt, utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd384* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode long_Term_Grant_Indicator */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "long-Term-Grant-Indicator");

      pvalue->m.long_Term_Grant_IndicatorPresent = 1;

      stat = DEC_BIT (pctxt, &pvalue->long_Term_Grant_Indicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode length_of_TTRI_field */
   RTXCTXTPUSHELEMNAME (pctxt, "length-of-TTRI-field");

   stat = pd_ConsUInt8 (pctxt, &pvalue->length_of_TTRI_field, OSUINTCONST(1), OSUINTCONST(12));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_Set_Config */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-Set-Config");

   stat = asn1PD_utran_E_AGCH_Set_Config (pctxt, &pvalue->e_AGCH_Set_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_BLER_Target */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-BLER-Target");

   stat = asn1PD_utran_Bler_Target (pctxt, &pvalue->e_AGCH_BLER_Target);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd768 (OSCTXT* pctxt, utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd768* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode long_Term_Grant_Indicator */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "long-Term-Grant-Indicator");

      pvalue->m.long_Term_Grant_IndicatorPresent = 1;

      stat = DEC_BIT (pctxt, &pvalue->long_Term_Grant_Indicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode length_of_TTRI_field */
   RTXCTXTPUSHELEMNAME (pctxt, "length-of-TTRI-field");

   stat = pd_ConsUInt8 (pctxt, &pvalue->length_of_TTRI_field, OSUINTCONST(1), OSUINTCONST(12));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_Set_Config */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-Set-Config");

   stat = asn1PD_utran_E_AGCH_Set_Config_VHCR (pctxt, &pvalue->e_AGCH_Set_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_BLER_Target */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-BLER-Target");

   stat = asn1PD_utran_Bler_Target (pctxt, &pvalue->e_AGCH_BLER_Target);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_InactivityMonitorThreshold_TDD128 (OSCTXT* pctxt, utran_E_AGCH_InactivityMonitorThreshold_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-AGCH-InactivityMonitorThreshold-TDD128");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd128 (OSCTXT* pctxt, utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rdi_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "rdi-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->rdi_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tpc_StepSize */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-StepSize");

   stat = asn1PD_utran_TPC_StepSizeTDD (pctxt, &pvalue->tpc_StepSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_Set_Config */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-Set-Config");

   stat = asn1PD_utran_E_AGCH_Set_Config_LCR (pctxt, &pvalue->e_AGCH_Set_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_BLER_Target */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-BLER-Target");

   stat = asn1PD_utran_Bler_Target (pctxt, &pvalue->e_AGCH_BLER_Target);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_InactivityMonitorThreshold */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-InactivityMonitorThreshold");

      pvalue->m.e_AGCH_InactivityMonitorThresholdPresent = 1;

      stat = asn1PD_utran_E_AGCH_InactivityMonitorThreshold_TDD128 (pctxt, &pvalue->e_AGCH_InactivityMonitorThreshold);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_r8_modeSpecific_tdd (OSCTXT* pctxt, utran_E_AGCH_Information_r8_modeSpecific_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         pvalue->u.tdd768 = rtxMemAllocType (pctxt, 
            utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd768);

         if (pvalue->u.tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd768 (pvalue->u.tdd768);

         stat = asn1PD_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd768 (pctxt, pvalue->u.tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_r8_modeSpecific (OSCTXT* pctxt, utran_E_AGCH_Information_r8_modeSpecific* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocTypeZ (pctxt, 
            utran_E_AGCH_Information_r8_modeSpecific_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_E_AGCH_Information_r8_modeSpecific_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_E_AGCH_Information_r8_modeSpecific_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_AGCH_Information_r8_modeSpecific_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_E_AGCH_Information_r8_modeSpecific_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_r8 (OSCTXT* pctxt, utran_E_AGCH_Information_r8* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-AGCH-Information-r8");

   /* decode root elements */
   /* decode modeSpecific */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecific");

   stat = asn1PD_utran_E_AGCH_Information_r8_modeSpecific (pctxt, &pvalue->modeSpecific);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_HICH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* e_HICH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Information");

         pvalue->u.e_HICH_Information = rtxMemAllocTypeZ (pctxt, 
            utran_E_HICH_Information);

         if (pvalue->u.e_HICH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_E_HICH_Information (pctxt, pvalue->u.e_HICH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_RGCH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* e_RGCH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "e-RGCH-Information");

         pvalue->u.e_RGCH_Information = rtxMemAllocTypeZ (pctxt, 
            utran_E_RGCH_Information);

         if (pvalue->u.e_RGCH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_E_RGCH_Information (pctxt, pvalue->u.e_RGCH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_RGCH_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RGCH-Info");

      pvalue->m.e_RGCH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd384_tdd768 (OSCTXT* pctxt, utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd384_tdd768* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_E_HICH_Information_TDD384_768 (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd128 (OSCTXT* pctxt, utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_E_HICH_Information_TDD128 (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384_tdd768 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384-tdd768");

         pvalue->u.tdd384_tdd768 = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd384_tdd768);

         if (pvalue->u.tdd384_tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd384_tdd768 (pvalue->u.tdd384_tdd768);

         stat = asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd384_tdd768 (pctxt, pvalue->u.tdd384_tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo2 (OSCTXT* pctxt, utran_DL_InformationPerRL_r8_modeSpecificInfo2* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r8 (OSCTXT* pctxt, utran_DL_InformationPerRL_r8* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-r8");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_dpchInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dpchInfo");

      pvalue->m.dl_dpchInfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r8_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_AGCH_Information */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-Information");

      pvalue->m.e_AGCH_InformationPresent = 1;

      stat = asn1PD_utran_E_AGCH_Information_r8 (pctxt, &pvalue->e_AGCH_Information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo2 */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo2");

   stat = asn1PD_utran_DL_InformationPerRL_r8_modeSpecificInfo2 (pctxt, &pvalue->modeSpecificInfo2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cell_id */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cell-id");

      pvalue->m.cell_idPresent = 1;

      stat = asn1PD_utran_CellIdentity (pctxt, &pvalue->cell_id);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_List_r8 (OSCTXT* pctxt, utran_DL_InformationPerRL_List_r8* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-List-r8");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_InformationPerRL_r8* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-InformationPerRL-r8", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_InformationPerRL_r8, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_InformationPerRL_r8 (pdata);

      stat = asn1PD_utran_DL_InformationPerRL_r8 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_EnablingDelay_TDD128 (OSCTXT* pctxt, utran_EnablingDelay_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EnablingDelay-TDD128");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_continue_ (OSCTXT* pctxt, utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_continue_* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode enablingDelay */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "enablingDelay");

      pvalue->m.enablingDelayPresent = 1;

      stat = asn1PD_utran_EnablingDelay_TDD128 (pctxt, &pvalue->enablingDelay);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_ControlChannelDRXCycle_TDD128 (OSCTXT* pctxt, utran_ControlChannelDRXCycle_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ControlChannelDRXCycle-TDD128");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_DRX_InactivityThreshold_TDD128 (OSCTXT* pctxt, utran_HS_SCCH_DRX_InactivityThreshold_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HS-SCCH-DRX-InactivityThreshold-TDD128");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_DRX_Info_TDD128 (OSCTXT* pctxt, utran_HS_SCCH_DRX_Info_TDD128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "HS-SCCH-DRX-Info-TDD128");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode hS_SCCH_DRX_Cycle */
   RTXCTXTPUSHELEMNAME (pctxt, "hS-SCCH-DRX-Cycle");

   stat = asn1PD_utran_ControlChannelDRXCycle_TDD128 (pctxt, &pvalue->hS_SCCH_DRX_Cycle);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode hS_SCCH_DRX_InactivityThreshold */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hS-SCCH-DRX-InactivityThreshold");

      pvalue->m.hS_SCCH_DRX_InactivityThresholdPresent = 1;

      stat = asn1PD_utran_HS_SCCH_DRX_InactivityThreshold_TDD128 (pctxt, &pvalue->hS_SCCH_DRX_InactivityThreshold);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode hS_SCCH_DRX_Offset */
   RTXCTXTPUSHELEMNAME (pctxt, "hS-SCCH-DRX-Offset");

   stat = pd_ConsUInt8 (pctxt, &pvalue->hS_SCCH_DRX_Offset, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType_e_AGCH_DRX_Parameters (OSCTXT* pctxt, utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType_e_AGCH_DRX_Parameters* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_AGCH_DRX_Cycle */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-DRX-Cycle");

   stat = asn1PD_utran_ControlChannelDRXCycle_TDD128 (pctxt, &pvalue->e_AGCH_DRX_Cycle);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_InactivityMonitorThreshold */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-InactivityMonitorThreshold");

      pvalue->m.e_AGCH_InactivityMonitorThresholdPresent = 1;

      stat = asn1PD_utran_E_AGCH_InactivityMonitorThreshold_TDD128 (pctxt, &pvalue->e_AGCH_InactivityMonitorThreshold);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_AGCH_DRX_Offset */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-DRX-Offset");

   stat = pd_ConsUInt8 (pctxt, &pvalue->e_AGCH_DRX_Offset, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType (OSCTXT* pctxt, utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* sameAsHS_SCCH */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsHS-SCCH");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* e_AGCH_DRX_Parameters */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-DRX-Parameters");

         pvalue->u.e_AGCH_DRX_Parameters = rtxMemAllocType (pctxt, 
            utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType_e_AGCH_DRX_Parameters);

         if (pvalue->u.e_AGCH_DRX_Parameters == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType_e_AGCH_DRX_Parameters (pvalue->u.e_AGCH_DRX_Parameters);

         stat = asn1PD_utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType_e_AGCH_DRX_Parameters (pctxt, pvalue->u.e_AGCH_DRX_Parameters);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_DRX_Info_TDD128 (OSCTXT* pctxt, utran_E_AGCH_DRX_Info_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-AGCH-DRX-Info-TDD128");

   /* decode root elements */
   /* decode e_AGCH_DRX_InfoType */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-DRX-InfoType");

   stat = asn1PD_utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType (pctxt, &pvalue->e_AGCH_DRX_InfoType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_newOperation (OSCTXT* pctxt, utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_newOperation* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode hS_SCCH_Drx_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "hS-SCCH-Drx-Info");

   stat = asn1PD_utran_HS_SCCH_DRX_Info_TDD128 (pctxt, &pvalue->hS_SCCH_Drx_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_Drx_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-Drx-Info");

      pvalue->m.e_AGCH_Drx_InfoPresent = 1;

      stat = asn1PD_utran_E_AGCH_DRX_Info_TDD128 (pctxt, &pvalue->e_AGCH_Drx_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode enablingDelay */
   RTXCTXTPUSHELEMNAME (pctxt, "enablingDelay");

   stat = asn1PD_utran_EnablingDelay_TDD128 (pctxt, &pvalue->enablingDelay);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation (OSCTXT* pctxt, utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* continue_ */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "continue");

         pvalue->u.continue_ = rtxMemAllocType (pctxt, 
            utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_continue_);

         if (pvalue->u.continue_ == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_continue_ (pvalue->u.continue_);

         stat = asn1PD_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_continue_ (pctxt, pvalue->u.continue_);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* newOperation */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "newOperation");

         pvalue->u.newOperation = rtxMemAllocType (pctxt, 
            utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_newOperation);

         if (pvalue->u.newOperation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_newOperation (pvalue->u.newOperation);

         stat = asn1PD_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_newOperation (pctxt, pvalue->u.newOperation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_ControlChannelDRXInfo_TDD128_r8 (OSCTXT* pctxt, utran_ControlChannelDRXInfo_TDD128_r8* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ControlChannelDRXInfo-TDD128-r8");

   /* decode root elements */
   /* decode controlChannelDrxOperation */
   RTXCTXTPUSHELEMNAME (pctxt, "controlChannelDrxOperation");

   stat = asn1PD_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation (pctxt, &pvalue->controlChannelDrxOperation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_HICH_Information_For_SPS_TDD128_configurationmode_implicit (OSCTXT* pctxt, utran_E_HICH_Information_For_SPS_TDD128_configurationmode_implicit* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ei */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ei");

      pvalue->m.eiPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->ei, OSUINTCONST(0), OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_HICH_Information_For_SPS_TDD128_configurationmode_explicit__midambleAllocationMode (OSCTXT* pctxt, utran_E_HICH_Information_For_SPS_TDD128_configurationmode_explicit__midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* defaultMidamble */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueSpecificMidamble */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ueSpecificMidamble");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.ueSpecificMidamble, OSUINTCONST(0), OSUINTCONST(15));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_HICH_Information_For_SPS_TDD128_configurationmode_explicit_ (OSCTXT* pctxt, utran_E_HICH_Information_For_SPS_TDD128_configurationmode_explicit_* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber_LCR_r4 (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode channelisation_Code */
   RTXCTXTPUSHELEMNAME (pctxt, "channelisation-Code");

   stat = asn1PD_utran_HS_ChannelisationCode_LCR (pctxt, &pvalue->channelisation_Code);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleAllocationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_utran_E_HICH_Information_For_SPS_TDD128_configurationmode_explicit__midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleConfiguration */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfiguration");

   stat = pd_ConsUInt8 (pctxt, &pvalue->midambleConfiguration, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_HICH_Information_For_SPS_TDD128_configurationmode (OSCTXT* pctxt, utran_E_HICH_Information_For_SPS_TDD128_configurationmode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* implicit */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "implicit");

         pvalue->u.implicit = rtxMemAllocType (pctxt, 
            utran_E_HICH_Information_For_SPS_TDD128_configurationmode_implicit);

         if (pvalue->u.implicit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_HICH_Information_For_SPS_TDD128_configurationmode_implicit (pvalue->u.implicit);

         stat = asn1PD_utran_E_HICH_Information_For_SPS_TDD128_configurationmode_implicit (pctxt, pvalue->u.implicit);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* explicit_ */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "explicit");

         pvalue->u.explicit_ = rtxMemAllocType (pctxt, 
            utran_E_HICH_Information_For_SPS_TDD128_configurationmode_explicit_);

         if (pvalue->u.explicit_ == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_HICH_Information_For_SPS_TDD128_configurationmode_explicit_ (pvalue->u.explicit_);

         stat = asn1PD_utran_E_HICH_Information_For_SPS_TDD128_configurationmode_explicit_ (pctxt, pvalue->u.explicit_);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_HICH_Information_For_SPS_TDD128 (OSCTXT* pctxt, utran_E_HICH_Information_For_SPS_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-HICH-Information-For-SPS-TDD128");

   /* decode root elements */
   /* decode configurationmode */
   RTXCTXTPUSHELEMNAME (pctxt, "configurationmode");

   stat = asn1PD_utran_E_HICH_Information_For_SPS_TDD128_configurationmode (pctxt, &pvalue->configurationmode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode signatureSequenceGroupIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "signatureSequenceGroupIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->signatureSequenceGroupIndex, OSUINTCONST(0), OSUINTCONST(19));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RepetitionPeriodAndLengthForSPS (OSCTXT* pctxt, utran_RepetitionPeriodAndLengthForSPS* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "RepetitionPeriodAndLengthForSPS");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* repetitionPeriod1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "repetitionPeriod1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* repetitionPeriod2 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "repetitionPeriod2");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.repetitionPeriod2, OSUINTCONST(1), OSUINTCONST(1));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* repetitionPeriod4 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "repetitionPeriod4");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.repetitionPeriod4, OSUINTCONST(1), OSUINTCONST(3));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* repetitionPeriod8 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "repetitionPeriod8");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.repetitionPeriod8, OSUINTCONST(1), OSUINTCONST(7));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* repetitionPeriod16 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "repetitionPeriod16");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.repetitionPeriod16, OSUINTCONST(1), OSUINTCONST(15));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* repetitionPeriod32 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "repetitionPeriod32");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.repetitionPeriod32, OSUINTCONST(1), OSUINTCONST(31));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_TxPatternList_TDD128_element (OSCTXT* pctxt, utran_E_DCH_TxPatternList_TDD128_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode repetitionPeriodAndLength */
   RTXCTXTPUSHELEMNAME (pctxt, "repetitionPeriodAndLength");

   stat = asn1PD_utran_RepetitionPeriodAndLengthForSPS (pctxt, &pvalue->repetitionPeriodAndLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_TxPatternList_TDD128 (OSCTXT* pctxt, utran_E_DCH_TxPatternList_TDD128* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-TxPatternList-TDD128");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_E_DCH_TxPatternList_TDD128_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_E_DCH_TxPatternList_TDD128_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_E_DCH_TxPatternList_TDD128_element (pdata);

      stat = asn1PD_utran_E_DCH_TxPatternList_TDD128_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_SPS_NewOperation_TDD128_initialSPSInfoForEDCH (OSCTXT* pctxt, utran_E_DCH_SPS_NewOperation_TDD128_initialSPSInfoForEDCH* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode n_E_UCCH */
   RTXCTXTPUSHELEMNAME (pctxt, "n-E-UCCH");

   stat = pd_ConsUInt8 (pctxt, &pvalue->n_E_UCCH, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode codeResourceInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "codeResourceInfo");

   stat = asn1PD_utran_UL_TS_ChannelisationCode (pctxt, &pvalue->codeResourceInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeslotResourceRelatedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotResourceRelatedInfo");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->timeslotResourceRelatedInfo
      , OSUINTCONST(5), OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerResourceRelatedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "powerResourceRelatedInfo");

   stat = pd_ConsUInt8 (pctxt, &pvalue->powerResourceRelatedInfo, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode activationTime */
   RTXCTXTPUSHELEMNAME (pctxt, "activationTime");

   stat = asn1PD_utran_ActivationTime (pctxt, &pvalue->activationTime);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode subframeNum */
   RTXCTXTPUSHELEMNAME (pctxt, "subframeNum");

   stat = pd_ConsUInt8 (pctxt, &pvalue->subframeNum, OSUINTCONST(0), OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode initialTxPatternIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "initialTxPatternIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->initialTxPatternIndex, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_SPS_NewOperation_TDD128 (OSCTXT* pctxt, utran_E_DCH_SPS_NewOperation_TDD128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-SPS-NewOperation-TDD128");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_hich_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "e-hich-Info");

   stat = asn1PD_utran_E_HICH_Information_For_SPS_TDD128 (pctxt, &pvalue->e_hich_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_dch_TxPattern */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-dch-TxPattern");

      pvalue->m.e_dch_TxPatternPresent = 1;

      stat = asn1PD_utran_E_DCH_TxPatternList_TDD128 (pctxt, &pvalue->e_dch_TxPattern);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode initialSPSInfoForEDCH */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "initialSPSInfoForEDCH");

      pvalue->m.initialSPSInfoForEDCHPresent = 1;

      stat = asn1PD_utran_E_DCH_SPS_NewOperation_TDD128_initialSPSInfoForEDCH (pctxt, &pvalue->initialSPSInfoForEDCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_SPS_Information_TDD128_e_dch_SPS_Operation (OSCTXT* pctxt, utran_E_DCH_SPS_Information_TDD128_e_dch_SPS_Operation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* continue_ */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "continue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* newOperation */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "newOperation");

         pvalue->u.newOperation = rtxMemAllocType (pctxt, 
            utran_E_DCH_SPS_NewOperation_TDD128);

         if (pvalue->u.newOperation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_DCH_SPS_NewOperation_TDD128 (pvalue->u.newOperation);

         stat = asn1PD_utran_E_DCH_SPS_NewOperation_TDD128 (pctxt, pvalue->u.newOperation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_DCH_SPS_Information_TDD128 (OSCTXT* pctxt, utran_E_DCH_SPS_Information_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-SPS-Information-TDD128");

   /* decode root elements */
   /* decode e_dch_SPS_Operation */
   RTXCTXTPUSHELEMNAME (pctxt, "e-dch-SPS-Operation");

   stat = asn1PD_utran_E_DCH_SPS_Information_TDD128_e_dch_SPS_Operation (pctxt, &pvalue->e_dch_SPS_Operation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_DSCH_TbsList_TDD128_element (OSCTXT* pctxt, utran_HS_DSCH_TbsList_TDD128_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode hs_dsch_TBSizeIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "hs-dsch-TBSizeIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->hs_dsch_TBSizeIndex, OSUINTCONST(1), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_DSCH_TbsList_TDD128 (OSCTXT* pctxt, utran_HS_DSCH_TbsList_TDD128* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HS-DSCH-TbsList-TDD128");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_HS_DSCH_TbsList_TDD128_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_HS_DSCH_TbsList_TDD128_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_HS_DSCH_TbsList_TDD128_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_DSCH_RxPatternList_TDD128_element (OSCTXT* pctxt, utran_HS_DSCH_RxPatternList_TDD128_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode repetitionPeriodAndLength */
   RTXCTXTPUSHELEMNAME (pctxt, "repetitionPeriodAndLength");

   stat = asn1PD_utran_RepetitionPeriodAndLengthForSPS (pctxt, &pvalue->repetitionPeriodAndLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_DSCH_RxPatternList_TDD128 (OSCTXT* pctxt, utran_HS_DSCH_RxPatternList_TDD128* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HS-DSCH-RxPatternList-TDD128");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_HS_DSCH_RxPatternList_TDD128_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_HS_DSCH_RxPatternList_TDD128_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_HS_DSCH_RxPatternList_TDD128_element (pdata);

      stat = asn1PD_utran_HS_DSCH_RxPatternList_TDD128_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_DSCH_SPS_NewOperation_TDD128_hARQInfoForSPS (OSCTXT* pctxt, utran_HS_DSCH_SPS_NewOperation_TDD128_hARQInfoForSPS* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode numberOfProcesses */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfProcesses");

   stat = pd_ConsUInt8 (pctxt, &pvalue->numberOfProcesses, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode memorySize */
   RTXCTXTPUSHELEMNAME (pctxt, "memorySize");

   stat = asn1PD_utran_HARQMemorySize (pctxt, &pvalue->memorySize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_SICH_List_TDD128_element_implicit (OSCTXT* pctxt, utran_HS_SICH_List_TDD128_element_implicit* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode hS_SCCH_Index */
   RTXCTXTPUSHELEMNAME (pctxt, "hS-SCCH-Index");

   stat = pd_ConsUInt8 (pctxt, &pvalue->hS_SCCH_Index, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_SICH_List_TDD128_element_explicit_ (OSCTXT* pctxt, utran_HS_SICH_List_TDD128_element_explicit_* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode hS_SICH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "hS-SICH-Info");

   stat = asn1PD_utran_HS_SICH_Configuration_TDD128_r6 (pctxt, &pvalue->hS_SICH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_SICH_List_TDD128_element (OSCTXT* pctxt, utran_HS_SICH_List_TDD128_element* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* implicit */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "implicit");

         pvalue->u.implicit = rtxMemAllocTypeZ (pctxt, 
            utran_HS_SICH_List_TDD128_element_implicit);

         if (pvalue->u.implicit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_HS_SICH_List_TDD128_element_implicit (pctxt, pvalue->u.implicit);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* explicit_ */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "explicit");

         pvalue->u.explicit_ = rtxMemAllocType (pctxt, 
            utran_HS_SICH_List_TDD128_element_explicit_);

         if (pvalue->u.explicit_ == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_HS_SICH_List_TDD128_element_explicit_ (pvalue->u.explicit_);

         stat = asn1PD_utran_HS_SICH_List_TDD128_element_explicit_ (pctxt, pvalue->u.explicit_);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HS_SICH_List_TDD128 (OSCTXT* pctxt, utran_HS_SICH_List_TDD128* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HS-SICH-List-TDD128");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_HS_SICH_List_TDD128_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CHOICE", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_HS_SICH_List_TDD128_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_HS_SICH_List_TDD128_element (pdata);

      stat = asn1PD_utran_HS_SICH_List_TDD128_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_ChannelisationCodeSetInfo_LCR (OSCTXT* pctxt, utran_HS_ChannelisationCodeSetInfo_LCR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HS-ChannelisationCodeSetInfo-LCR");

   /* decode root elements */
   /* decode startCode */
   RTXCTXTPUSHELEMNAME (pctxt, "startCode");

   stat = asn1PD_utran_HS_ChannelisationCode_LCR (pctxt, &pvalue->startCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode stopCode */
   RTXCTXTPUSHELEMNAME (pctxt, "stopCode");

   stat = asn1PD_utran_HS_ChannelisationCode_LCR (pctxt, &pvalue->stopCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation (OSCTXT* pctxt, utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH (OSCTXT* pctxt, utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslotInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotInfo");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->timeslotInfo
      , OSUINTCONST(5), OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode codeResourceInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "codeResourceInfo");

   stat = asn1PD_utran_HS_ChannelisationCodeSetInfo_LCR (pctxt, &pvalue->codeResourceInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode activationTime */
   RTXCTXTPUSHELEMNAME (pctxt, "activationTime");

   stat = asn1PD_utran_ActivationTime (pctxt, &pvalue->activationTime);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sfnNum */
   RTXCTXTPUSHELEMNAME (pctxt, "sfnNum");

   stat = pd_ConsUInt8 (pctxt, &pvalue->sfnNum, OSUINTCONST(0), OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode initialRxPatternIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "initialRxPatternIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->initialRxPatternIndex, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode initialTfsIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "initialTfsIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->initialTfsIndex, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode modulation */
   RTXCTXTPUSHELEMNAME (pctxt, "modulation");

   stat = asn1PD_utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation (pctxt, &pvalue->modulation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode hs_sich_Index */
   RTXCTXTPUSHELEMNAME (pctxt, "hs-sich-Index");

   stat = pd_ConsUInt8 (pctxt, &pvalue->hs_sich_Index, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_DSCH_SPS_NewOperation_TDD128 (OSCTXT* pctxt, utran_HS_DSCH_SPS_NewOperation_TDD128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "HS-DSCH-SPS-NewOperation-TDD128");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode hs_dsch_TbsList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hs-dsch-TbsList");

      pvalue->m.hs_dsch_TbsListPresent = 1;

      stat = asn1PD_utran_HS_DSCH_TbsList_TDD128 (pctxt, &pvalue->hs_dsch_TbsList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode hs_dsch_RxPatternList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hs-dsch-RxPatternList");

      pvalue->m.hs_dsch_RxPatternListPresent = 1;

      stat = asn1PD_utran_HS_DSCH_RxPatternList_TDD128 (pctxt, &pvalue->hs_dsch_RxPatternList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode hARQInfoForSPS */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hARQInfoForSPS");

      pvalue->m.hARQInfoForSPSPresent = 1;

      stat = asn1PD_utran_HS_DSCH_SPS_NewOperation_TDD128_hARQInfoForSPS (pctxt, &pvalue->hARQInfoForSPS);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode hs_sich_List */
   RTXCTXTPUSHELEMNAME (pctxt, "hs-sich-List");

   stat = asn1PD_utran_HS_SICH_List_TDD128 (pctxt, &pvalue->hs_sich_List);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode initialSPSInfoForHSDSCH */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "initialSPSInfoForHSDSCH");

      pvalue->m.initialSPSInfoForHSDSCHPresent = 1;

      stat = asn1PD_utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH (pctxt, &pvalue->initialSPSInfoForHSDSCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_DSCH_SPS_Information_TDD128_hs_dsch_SPS_Operation (OSCTXT* pctxt, utran_HS_DSCH_SPS_Information_TDD128_hs_dsch_SPS_Operation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* continue_ */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "continue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* newOperation */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "newOperation");

         pvalue->u.newOperation = rtxMemAllocType (pctxt, 
            utran_HS_DSCH_SPS_NewOperation_TDD128);

         if (pvalue->u.newOperation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_HS_DSCH_SPS_NewOperation_TDD128 (pvalue->u.newOperation);

         stat = asn1PD_utran_HS_DSCH_SPS_NewOperation_TDD128 (pctxt, pvalue->u.newOperation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HS_DSCH_SPS_Information_TDD128 (OSCTXT* pctxt, utran_HS_DSCH_SPS_Information_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HS-DSCH-SPS-Information-TDD128");

   /* decode root elements */
   /* decode hs_dsch_SPS_Operation */
   RTXCTXTPUSHELEMNAME (pctxt, "hs-dsch-SPS-Operation");

   stat = asn1PD_utran_HS_DSCH_SPS_Information_TDD128_hs_dsch_SPS_Operation (pctxt, &pvalue->hs_dsch_SPS_Operation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SPS_Information_TDD128_r8 (OSCTXT* pctxt, utran_SPS_Information_TDD128_r8* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SPS-Information-TDD128-r8");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_dch_SPS_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-dch-SPS-Info");

      pvalue->m.e_dch_SPS_InfoPresent = 1;

      stat = asn1PD_utran_E_DCH_SPS_Information_TDD128 (pctxt, &pvalue->e_dch_SPS_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode hs_dsch_SPS_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hs-dsch-SPS-Info");

      pvalue->m.hs_dsch_SPS_InfoPresent = 1;

      stat = asn1PD_utran_HS_DSCH_SPS_Information_TDD128 (pctxt, &pvalue->hs_dsch_SPS_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst (OSCTXT* pctxt, utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128 (OSCTXT* pctxt, utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode t_SI_nst */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-SI-nst");

      pvalue->m.t_SI_nstPresent = 1;

      stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst (pctxt, &pvalue->t_SI_nst);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_Non_ScheduledTransGrantInfoTDD_ext (OSCTXT* pctxt, utran_Non_ScheduledTransGrantInfoTDD_ext* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "Non-ScheduledTransGrantInfoTDD-ext");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384_768 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384-768");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_ext_tdd (OSCTXT* pctxt, utran_UL_EDCH_Information_ext_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode non_ScheduledTransGrantInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "non-ScheduledTransGrantInfo");

      pvalue->m.non_ScheduledTransGrantInfoPresent = 1;

      stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD_ext (pctxt, &pvalue->non_ScheduledTransGrantInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_ext (OSCTXT* pctxt, utran_UL_EDCH_Information_ext* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-EDCH-Information-ext");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_EDCH_Information_ext_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_EDCH_Information_ext_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_EDCH_Information_ext_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd_tdd128 (OSCTXT* pctxt, utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode outofSyncWindow */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "outofSyncWindow");

      pvalue->m.outofSyncWindowPresent = 1;

      stat = asn1PD_utran_OutofSyncWindow (pctxt, &pvalue->outofSyncWindow);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo (OSCTXT* pctxt, utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* fdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_HSPDSCH_Information_r8_ext (OSCTXT* pctxt, utran_DL_HSPDSCH_Information_r8_ext* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-HSPDSCH-Information-r8-ext");

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size (OSCTXT* pctxt, utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128 (OSCTXT* pctxt, utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode hS_SCCH_tpc_step_size */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hS-SCCH-tpc-step-size");

      pvalue->m.hS_SCCH_tpc_step_sizePresent = 1;

      stat = asn1PD_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size (pctxt, &pvalue->hS_SCCH_tpc_step_size);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo (OSCTXT* pctxt, utran_HS_SCCH_Info_r8_ext_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HS_SCCH_Info_r8_ext (OSCTXT* pctxt, utran_HS_SCCH_Info_r8_ext* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HS-SCCH-Info-r8-ext");

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_HSPDSCH_Information_r8_ext2 (OSCTXT* pctxt, utran_DL_HSPDSCH_Information_r8_ext2* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-HSPDSCH-Information-r8-ext2");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode hs_scch_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hs-scch-Info");

      pvalue->m.hs_scch_InfoPresent = 1;

      stat = asn1PD_utran_HS_SCCH_Info_r8_ext (pctxt, &pvalue->hs_scch_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_hs_WindowSize_r9 (OSCTXT* pctxt, utran_MAC_hs_WindowSize_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-hs-WindowSize-r9");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_ehs_AddReconfReordQ_r9 (OSCTXT* pctxt, utran_MAC_ehs_AddReconfReordQ_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-ehs-AddReconfReordQ-r9");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_ehs_QueueId */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs-QueueId");

   stat = asn1PD_utran_MAC_ehs_QueueId (pctxt, &pvalue->mac_ehs_QueueId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reorderingReleaseTimer */
   RTXCTXTPUSHELEMNAME (pctxt, "reorderingReleaseTimer");

   stat = asn1PD_utran_T1_ReleaseTimer (pctxt, &pvalue->reorderingReleaseTimer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reorderingResetTimer */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "reorderingResetTimer");

      pvalue->m.reorderingResetTimerPresent = 1;

      stat = asn1PD_utran_Treset_ResetTimer (pctxt, &pvalue->reorderingResetTimer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mac_ehsWindowSize */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-ehsWindowSize");

   stat = asn1PD_utran_MAC_hs_WindowSize_r9 (pctxt, &pvalue->mac_ehsWindowSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_ehs_AddReconfReordQ_List_r9 (OSCTXT* pctxt, utran_MAC_ehs_AddReconfReordQ_List_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-ehs-AddReconfReordQ-List-r9");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_MAC_ehs_AddReconfReordQ_r9* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MAC-ehs-AddReconfReordQ-r9", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_MAC_ehs_AddReconfReordQ_r9, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_MAC_ehs_AddReconfReordQ_r9 (pdata);

      stat = asn1PD_utran_MAC_ehs_AddReconfReordQ_r9 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AddOrReconfMAC_ehs_ReordQ_r9 (OSCTXT* pctxt, utran_AddOrReconfMAC_ehs_ReordQ_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AddOrReconfMAC-ehs-ReordQ-r9");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_ehs_AddReconfQueue_List */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs-AddReconfQueue-List");

      pvalue->m.mac_ehs_AddReconfQueue_ListPresent = 1;

      stat = asn1PD_utran_MAC_ehs_AddReconfReordQ_List_r9 (pctxt, &pvalue->mac_ehs_AddReconfQueue_List);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HSDSCH_Info_r9_dl_MAC_HeaderType (OSCTXT* pctxt, utran_HSDSCH_Info_r9_dl_MAC_HeaderType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* mac_hs */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "mac-hs");

         pvalue->u.mac_hs = rtxMemAllocType (pctxt, 
            utran_AddOrReconfMAC_dFlow);

         if (pvalue->u.mac_hs == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_AddOrReconfMAC_dFlow (pvalue->u.mac_hs);

         stat = asn1PD_utran_AddOrReconfMAC_dFlow (pctxt, pvalue->u.mac_hs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* mac_ehs */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs");

         pvalue->u.mac_ehs = rtxMemAllocType (pctxt, 
            utran_AddOrReconfMAC_ehs_ReordQ_r9);

         if (pvalue->u.mac_ehs == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_AddOrReconfMAC_ehs_ReordQ_r9 (pvalue->u.mac_ehs);

         stat = asn1PD_utran_AddOrReconfMAC_ehs_ReordQ_r9 (pctxt, pvalue->u.mac_ehs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HSDSCH_Info_r9 (OSCTXT* pctxt, utran_HSDSCH_Info_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "HSDSCH-Info-r9");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode harqInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "harqInfo");

      pvalue->m.harqInfoPresent = 1;

      stat = asn1PD_utran_HARQ_Info_r7 (pctxt, &pvalue->harqInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_MAC_HeaderType */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-MAC-HeaderType");

      pvalue->m.dl_MAC_HeaderTypePresent = 1;

      stat = asn1PD_utran_HSDSCH_Info_r9_dl_MAC_HeaderType (pctxt, &pvalue->dl_MAC_HeaderType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation_r9_tfs_SignallingMode (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation_r9_tfs_SignallingMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* explicit_config */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "explicit-config");

         pvalue->u.explicit_config = rtxMemAllocType (pctxt, 
            utran_TransportFormatSet);

         if (pvalue->u.explicit_config == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TransportFormatSet (pvalue->u.explicit_config);

         stat = asn1PD_utran_TransportFormatSet (pctxt, pvalue->u.explicit_config);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sameAsULTrCH */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsULTrCH");

         pvalue->u.sameAsULTrCH = rtxMemAllocTypeZ (pctxt, 
            utran_UL_TransportChannelIdentity);

         if (pvalue->u.sameAsULTrCH == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UL_TransportChannelIdentity (pctxt, pvalue->u.sameAsULTrCH);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* hsdsch */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "hsdsch");

         pvalue->u.hsdsch = rtxMemAllocType (pctxt, utran_HSDSCH_Info_r9);

         if (pvalue->u.hsdsch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_HSDSCH_Info_r9 (pvalue->u.hsdsch);

         stat = asn1PD_utran_HSDSCH_Info_r9 (pctxt, pvalue->u.hsdsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation_r9 (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInformation-r9");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TransportChannelType");

   stat = asn1PD_utran_DL_TrCH_TypeId1_r5 (pctxt, &pvalue->dl_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfs_SignallingMode */
   RTXCTXTPUSHELEMNAME (pctxt, "tfs-SignallingMode");

   stat = asn1PD_utran_DL_AddReconfTransChInformation_r9_tfs_SignallingMode (pctxt, &pvalue->tfs_SignallingMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dch_QualityTarget */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dch-QualityTarget");

      pvalue->m.dch_QualityTargetPresent = 1;

      stat = asn1PD_utran_QualityTarget (pctxt, &pvalue->dch_QualityTarget);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInfoList_r9 (OSCTXT* pctxt, utran_DL_AddReconfTransChInfoList_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInfoList-r9");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_AddReconfTransChInformation_r9* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-AddReconfTransChInformation-r9", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_AddReconfTransChInformation_r9, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_AddReconfTransChInformation_r9 (pdata);

      stat = asn1PD_utran_DL_AddReconfTransChInformation_r9 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator (OSCTXT* pctxt, utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__306; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r9_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_UL_EDCH_Information_r9_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_DPCCH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-DPCCH-Info");

      pvalue->m.e_DPCCH_InfoPresent = 1;

      stat = asn1PD_utran_E_DPCCH_Info_r7 (pctxt, &pvalue->e_DPCCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_DPDCH_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-DPDCH-Info");

      pvalue->m.e_DPDCH_InfoPresent = 1;

      stat = asn1PD_utran_E_DPDCH_Info_r8 (pctxt, &pvalue->e_DPDCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode schedulingTransmConfiguration */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "schedulingTransmConfiguration");

      pvalue->m.schedulingTransmConfigurationPresent = 1;

      stat = asn1PD_utran_E_DPDCH_SchedulingTransmConfiguration (pctxt, &pvalue->schedulingTransmConfiguration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_16QAM_Settings */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-16QAM-Settings");

      pvalue->m.ul_16QAM_SettingsPresent = 1;

      stat = asn1PD_utran_UL_16QAM_Settings (pctxt, &pvalue->ul_16QAM_Settings);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd384_768 (OSCTXT* pctxt, utran_Non_ScheduledTransGrantInfoTDD_r9_tdd384_768* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode timeslotResourceRelatedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotResourceRelatedInfo");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(13), OSUINTCONST(13), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->timeslotResourceRelatedInfo
      , OSUINTCONST(13), OSUINTCONST(13));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerResourceRelatedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "powerResourceRelatedInfo");

   stat = pd_ConsUInt8 (pctxt, &pvalue->powerResourceRelatedInfo, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode activationTime */
   RTXCTXTPUSHELEMNAME (pctxt, "activationTime");

   stat = asn1PD_utran_ActivationTime (pctxt, &pvalue->activationTime);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode repetitionPeriodAndLength */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "repetitionPeriodAndLength");

      pvalue->m.repetitionPeriodAndLengthPresent = 1;

      stat = asn1PD_utran_RepetitionPeriodAndLength (pctxt, &pvalue->repetitionPeriodAndLength);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode codeResourceInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "codeResourceInfo");

   stat = asn1PD_utran_UL_TS_ChannelisationCode (pctxt, &pvalue->codeResourceInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_e_HICH_Info_midambleAllocationMode (OSCTXT* pctxt, utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_e_HICH_Info_midambleAllocationMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* defaultMidamble */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultMidamble");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueSpecificMidamble */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ueSpecificMidamble");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.ueSpecificMidamble, OSUINTCONST(0), OSUINTCONST(15));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_e_HICH_Info (OSCTXT* pctxt, utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_e_HICH_Info* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslotNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotNumber");

   stat = asn1PD_utran_TimeslotNumber_LCR_r4 (pctxt, &pvalue->timeslotNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode channelisation_Code */
   RTXCTXTPUSHELEMNAME (pctxt, "channelisation-Code");

   stat = asn1PD_utran_HS_ChannelisationCode_LCR (pctxt, &pvalue->channelisation_Code);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleAllocationMode */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleAllocationMode");

   stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_e_HICH_Info_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleConfiguration */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfiguration");

   stat = pd_ConsUInt8 (pctxt, &pvalue->midambleConfiguration, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode signatureSequenceGroupIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "signatureSequenceGroupIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->signatureSequenceGroupIndex, OSUINTCONST(0), OSUINTCONST(19));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst (OSCTXT* pctxt, utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128 (OSCTXT* pctxt, utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode n_E_UCCH */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "n-E-UCCH");

      pvalue->m.n_E_UCCHPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->n_E_UCCH, OSUINTCONST(1), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode n_E_HICH */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "n-E-HICH");

      pvalue->m.n_E_HICHPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->n_E_HICH, OSUINTCONST(4), OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode timeslotResourceRelatedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotResourceRelatedInfo");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->timeslotResourceRelatedInfo
      , OSUINTCONST(5), OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerResourceRelatedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "powerResourceRelatedInfo");

   stat = pd_ConsUInt8 (pctxt, &pvalue->powerResourceRelatedInfo, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode activationTime */
   RTXCTXTPUSHELEMNAME (pctxt, "activationTime");

   stat = asn1PD_utran_ActivationTime (pctxt, &pvalue->activationTime);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sfnNum */
   RTXCTXTPUSHELEMNAME (pctxt, "sfnNum");

   stat = pd_ConsUInt8 (pctxt, &pvalue->sfnNum, OSUINTCONST(0), OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode repetitionPeriodAndLength */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "repetitionPeriodAndLength");

      pvalue->m.repetitionPeriodAndLengthPresent = 1;

      stat = asn1PD_utran_RepetitionPeriodAndLength (pctxt, &pvalue->repetitionPeriodAndLength);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode codeResourceInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "codeResourceInfo");

   stat = asn1PD_utran_UL_TS_ChannelisationCode (pctxt, &pvalue->codeResourceInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_HICH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

   stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t_SI_nst */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-SI-nst");

      pvalue->m.t_SI_nstPresent = 1;

      stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst (pctxt, &pvalue->t_SI_nst);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_Non_ScheduledTransGrantInfoTDD_r9 (OSCTXT* pctxt, utran_Non_ScheduledTransGrantInfoTDD_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "Non-ScheduledTransGrantInfoTDD-r9");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384_768 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384-768");

         pvalue->u.tdd384_768 = rtxMemAllocType (pctxt, 
            utran_Non_ScheduledTransGrantInfoTDD_r9_tdd384_768);

         if (pvalue->u.tdd384_768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd384_768 (pvalue->u.tdd384_768);

         stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd384_768 (pctxt, pvalue->u.tdd384_768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r9_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_UL_EDCH_Information_r9_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_RUCCH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RUCCH-Info");

      pvalue->m.e_RUCCH_InfoPresent = 1;

      stat = asn1PD_utran_E_RUCCH_Info (pctxt, &pvalue->e_RUCCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_PUCH_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-PUCH-Info");

      pvalue->m.e_PUCH_InfoPresent = 1;

      stat = asn1PD_utran_E_PUCH_Info (pctxt, &pvalue->e_PUCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode non_ScheduledTransGrantInfo */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "non-ScheduledTransGrantInfo");

      pvalue->m.non_ScheduledTransGrantInfoPresent = 1;

      stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD_r9 (pctxt, &pvalue->non_ScheduledTransGrantInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r9_modeSpecificInfo (OSCTXT* pctxt, utran_UL_EDCH_Information_r9_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_EDCH_Information_r9_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_EDCH_Information_r9_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_EDCH_Information_r9_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_EDCH_Information_r9_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_EDCH_Information_r9_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_EDCH_Information_r9_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r9 (OSCTXT* pctxt, utran_UL_EDCH_Information_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-EDCH-Information-r9");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_es_e_resetIndicator */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-es-e-resetIndicator");

      pvalue->m.mac_es_e_resetIndicatorPresent = 1;

      stat = asn1PD_utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator (pctxt, &pvalue->mac_es_e_resetIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_UL_EDCH_Information_r9_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CellDCHMeasOccasionPattern_LCR_statusFlag (OSCTXT* pctxt, utran_CellDCHMeasOccasionPattern_LCR_statusFlag* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_MeasurementOccasionPatternParameter (OSCTXT* pctxt, utran_MeasurementOccasionPatternParameter* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementOccasionPatternParameter");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode measurement_Occasion_Coeff */
   RTXCTXTPUSHELEMNAME (pctxt, "measurement-Occasion-Coeff");

   stat = pd_ConsUInt8 (pctxt, &pvalue->measurement_Occasion_Coeff, OSUINTCONST(1), OSUINTCONST(9));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measurement_Occasion_Offset */
   RTXCTXTPUSHELEMNAME (pctxt, "measurement-Occasion-Offset");

   stat = pd_ConsUInt16 (pctxt, &pvalue->measurement_Occasion_Offset, OSUINTCONST(0), OSUINTCONST(511));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measurement_Occasion_Length */
   RTXCTXTPUSHELEMNAME (pctxt, "measurement-Occasion-Length");

   stat = pd_ConsUInt16 (pctxt, &pvalue->measurement_Occasion_Length, OSUINTCONST(1), OSUINTCONST(512));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeslotBitmap */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timeslotBitmap");

      pvalue->m.timeslotBitmapPresent = 1;

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(7), OSUINTCONST(7), 0, 0);

      stat = pd_BitString32 (pctxt, &pvalue->timeslotBitmap
         , OSUINTCONST(7), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CellDCHMeasOccasionPattern_LCR (OSCTXT* pctxt, utran_CellDCHMeasOccasionPattern_LCR* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "CellDCHMeasOccasionPattern-LCR");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode patternIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "patternIdentifier");

   stat = pd_ConsUInt8 (pctxt, &pvalue->patternIdentifier, OSUINTCONST(0), OSUINTCONST(4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode statusFlag */
   RTXCTXTPUSHELEMNAME (pctxt, "statusFlag");

   stat = asn1PD_utran_CellDCHMeasOccasionPattern_LCR_statusFlag (pctxt, &pvalue->statusFlag);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measurementPurpose */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measurementPurpose");

      pvalue->m.measurementPurposePresent = 1;

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 0, 0);

      stat = pd_BitString32 (pctxt, &pvalue->measurementPurpose
         , OSUINTCONST(5), OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measurementOccasionPatternParameter */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measurementOccasionPatternParameter");

      pvalue->m.measurementOccasionPatternParameterPresent = 1;

      stat = asn1PD_utran_MeasurementOccasionPatternParameter (pctxt, &pvalue->measurementOccasionPatternParameter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CellDCHMeasOccasionInfo_TDD128_r9_cellDCHMeasOccasionSequenceList (OSCTXT* pctxt, utran_CellDCHMeasOccasionInfo_TDD128_r9_cellDCHMeasOccasionSequenceList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(5), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_CellDCHMeasOccasionPattern_LCR* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellDCHMeasOccasionPattern-LCR", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_CellDCHMeasOccasionPattern_LCR, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_CellDCHMeasOccasionPattern_LCR (pdata);

      stat = asn1PD_utran_CellDCHMeasOccasionPattern_LCR (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_CellDCHMeasOccasionInfo_TDD128_r9 (OSCTXT* pctxt, utran_CellDCHMeasOccasionInfo_TDD128_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellDCHMeasOccasionInfo-TDD128-r9");

   /* decode root elements */
   /* decode cellDCHMeasOccasionSequenceList */
   RTXCTXTPUSHELEMNAME (pctxt, "cellDCHMeasOccasionSequenceList");

   stat = asn1PD_utran_CellDCHMeasOccasionInfo_TDD128_r9_cellDCHMeasOccasionSequenceList (pctxt, &pvalue->cellDCHMeasOccasionSequenceList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_ehs_WindowSize_TDD128_v9c0ext (OSCTXT* pctxt, utran_MAC_ehs_WindowSize_TDD128_v9c0ext* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-ehs-WindowSize-TDD128-v9c0ext");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_ehs_AddReconfReordQ_TDD128_v9c0ext (OSCTXT* pctxt, utran_MAC_ehs_AddReconfReordQ_TDD128_v9c0ext* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-ehs-AddReconfReordQ-TDD128-v9c0ext");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_ehsWindowSize_extension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-ehsWindowSize-extension");

      pvalue->m.mac_ehsWindowSize_extensionPresent = 1;

      stat = asn1PD_utran_MAC_ehs_WindowSize_TDD128_v9c0ext (pctxt, &pvalue->mac_ehsWindowSize_extension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_ehs_AddReconfReordQ_List_TDD128_v9c0ext (OSCTXT* pctxt, utran_MAC_ehs_AddReconfReordQ_List_TDD128_v9c0ext* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-ehs-AddReconfReordQ-List-TDD128-v9c0ext");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_MAC_ehs_AddReconfReordQ_TDD128_v9c0ext* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MAC-ehs-AddReconfReordQ-TDD128-v9c0ext", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_MAC_ehs_AddReconfReordQ_TDD128_v9c0ext, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_MAC_ehs_AddReconfReordQ_TDD128_v9c0ext (pdata);

      stat = asn1PD_utran_MAC_ehs_AddReconfReordQ_TDD128_v9c0ext (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AddOrReconfMAC_ehs_ReordQ_TDD128_v9c0ext (OSCTXT* pctxt, utran_AddOrReconfMAC_ehs_ReordQ_TDD128_v9c0ext* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AddOrReconfMAC-ehs-ReordQ-TDD128-v9c0ext");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_ehs_AddReconfQueue_List */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs-AddReconfQueue-List");

      pvalue->m.mac_ehs_AddReconfQueue_ListPresent = 1;

      stat = asn1PD_utran_MAC_ehs_AddReconfReordQ_List_TDD128_v9c0ext (pctxt, &pvalue->mac_ehs_AddReconfQueue_List);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HSDSCH_Info_TDD128_v9c0ext (OSCTXT* pctxt, utran_HSDSCH_Info_TDD128_v9c0ext* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "HSDSCH-Info-TDD128-v9c0ext");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_ehs */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs");

      pvalue->m.mac_ehsPresent = 1;

      stat = asn1PD_utran_AddOrReconfMAC_ehs_ReordQ_TDD128_v9c0ext (pctxt, &pvalue->mac_ehs);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation_TDD128_v9c0ext (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation_TDD128_v9c0ext* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInformation-TDD128-v9c0ext");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode hsdsch */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hsdsch");

      pvalue->m.hsdschPresent = 1;

      stat = asn1PD_utran_HSDSCH_Info_TDD128_v9c0ext (pctxt, &pvalue->hsdsch);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInfoList_TDD128_v9c0ext (OSCTXT* pctxt, utran_DL_AddReconfTransChInfoList_TDD128_v9c0ext* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInfoList-TDD128-v9c0ext");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_AddReconfTransChInformation_TDD128_v9c0ext* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-AddReconfTransChInformation-TDD128-v9c0ext", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_AddReconfTransChInformation_TDD128_v9c0ext, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_AddReconfTransChInformation_TDD128_v9c0ext (pdata);

      stat = asn1PD_utran_DL_AddReconfTransChInformation_TDD128_v9c0ext (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SR_VCC_Info_nonce (OSCTXT* pctxt, utran_SR_VCC_Info_nonce* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(128), OSUINTCONST(128), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_SR_VCC_Info (OSCTXT* pctxt, utran_SR_VCC_Info* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SR-VCC-Info");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode nonce */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonce");

      pvalue->m.noncePresent = 1;

      stat = asn1PD_utran_SR_VCC_Info_nonce (pctxt, &pvalue->nonce);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length (OSCTXT* pctxt, utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_tsn_14bits; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_PUCH_Info_MulticarrierEDCH_TDD128_e_PUCH_TS_ConfigurationList (OSCTXT* pctxt, utran_E_PUCH_Info_MulticarrierEDCH_TDD128_e_PUCH_TS_ConfigurationList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(5), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_E_PUCH_TS_Slots_LCR* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "E-PUCH-TS-Slots-LCR", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_E_PUCH_TS_Slots_LCR, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_E_PUCH_TS_Slots_LCR (pdata);

      stat = asn1PD_utran_E_PUCH_TS_Slots_LCR (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_E_PUCH_Info_MulticarrierEDCH_TDD128 (OSCTXT* pctxt, utran_E_PUCH_Info_MulticarrierEDCH_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-PUCH-Info-MulticarrierEDCH-TDD128");

   /* decode root elements */
   /* decode e_PUCH_TS_ConfigurationList */
   RTXCTXTPUSHELEMNAME (pctxt, "e-PUCH-TS-ConfigurationList");

   stat = asn1PD_utran_E_PUCH_Info_MulticarrierEDCH_TDD128_e_PUCH_TS_ConfigurationList (pctxt, &pvalue->e_PUCH_TS_ConfigurationList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_E_AGCH_Information_TDD128 (OSCTXT* pctxt, utran_E_AGCH_Information_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-AGCH-Information-TDD128");

   /* decode root elements */
   /* decode rdi_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "rdi-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->rdi_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tpc_StepSize */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-StepSize");

   stat = asn1PD_utran_TPC_StepSizeTDD (pctxt, &pvalue->tpc_StepSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_Set_Config */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-Set-Config");

   stat = asn1PD_utran_E_AGCH_Set_Config_LCR (pctxt, &pvalue->e_AGCH_Set_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_AGCH_BLER_Target */
   RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-BLER-Target");

   stat = asn1PD_utran_Bler_Target (pctxt, &pvalue->e_AGCH_BLER_Target);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_MulticarrierEDCH_InfolistItem_TDD128 (OSCTXT* pctxt, utran_UL_MulticarrierEDCH_InfolistItem_TDD128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-MulticarrierEDCH-InfolistItem-TDD128");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode uarfcn */
   RTXCTXTPUSHELEMNAME (pctxt, "uarfcn");

   stat = asn1PD_utran_UARFCN (pctxt, &pvalue->uarfcn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode prxdes_base */
   RTXCTXTPUSHELEMNAME (pctxt, "prxdes-base");

   stat = pd_ConsInt8 (pctxt, &pvalue->prxdes_base, OSINTCONST(-112), OSINTCONST(-50));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_PUCH_info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-PUCH-info");

      pvalue->m.e_PUCH_infoPresent = 1;

      stat = asn1PD_utran_E_PUCH_Info_MulticarrierEDCH_TDD128 (pctxt, &pvalue->e_PUCH_info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_AGCH_info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-info");

      pvalue->m.e_AGCH_infoPresent = 1;

      stat = asn1PD_utran_E_AGCH_Information_TDD128 (pctxt, &pvalue->e_AGCH_info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_HICH_info */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-info");

      pvalue->m.e_HICH_infoPresent = 1;

      stat = asn1PD_utran_E_HICH_Information_TDD128 (pctxt, &pvalue->e_HICH_info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_MulticarrierEDCH_Infolist_TDD128 (OSCTXT* pctxt, utran_UL_MulticarrierEDCH_Infolist_TDD128* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-MulticarrierEDCH-Infolist-TDD128");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(5), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_UL_MulticarrierEDCH_InfolistItem_TDD128* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-MulticarrierEDCH-InfolistItem-TDD128", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_UL_MulticarrierEDCH_InfolistItem_TDD128, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_UL_MulticarrierEDCH_InfolistItem_TDD128 (pdata);

      stat = asn1PD_utran_UL_MulticarrierEDCH_InfolistItem_TDD128 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_MulticarrierEDCH_Deletelist_TDD128 (OSCTXT* pctxt, utran_UL_MulticarrierEDCH_Deletelist_TDD128* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-MulticarrierEDCH-Deletelist-TDD128");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 5) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UARFCN", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_UARFCN));
      stat = asn1PD_utran_UARFCN (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128 (OSCTXT* pctxt, utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-MulticarrierEDCH-NewConfigurationInfo-TDD128");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tsn_Length */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tsn-Length");

      pvalue->m.tsn_LengthPresent = 1;

      stat = asn1PD_utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length (pctxt, &pvalue->tsn_Length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_MulticarrierEDCH_Infolist */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-MulticarrierEDCH-Infolist");

      pvalue->m.ul_MulticarrierEDCH_InfolistPresent = 1;

      stat = asn1PD_utran_UL_MulticarrierEDCH_Infolist_TDD128 (pctxt, &pvalue->ul_MulticarrierEDCH_Infolist);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_MulticarrierEDCH_Deletelist */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-MulticarrierEDCH-Deletelist");

      pvalue->m.ul_MulticarrierEDCH_DeletelistPresent = 1;

      stat = asn1PD_utran_UL_MulticarrierEDCH_Deletelist_TDD128 (pctxt, &pvalue->ul_MulticarrierEDCH_Deletelist);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_MulticarrierEDCHInfo_TDD128_configuration_info (OSCTXT* pctxt, utran_UL_MulticarrierEDCHInfo_TDD128_configuration_info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* continue_ */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "continue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* newConfiguration */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "newConfiguration");

         pvalue->u.newConfiguration = rtxMemAllocType (pctxt, 
            utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128);

         if (pvalue->u.newConfiguration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128 (pvalue->u.newConfiguration);

         stat = asn1PD_utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128 (pctxt, pvalue->u.newConfiguration);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_MulticarrierEDCHInfo_TDD128 (OSCTXT* pctxt, utran_UL_MulticarrierEDCHInfo_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-MulticarrierEDCHInfo-TDD128");

   /* decode root elements */
   /* decode configuration_info */
   RTXCTXTPUSHELEMNAME (pctxt, "configuration-info");

   stat = asn1PD_utran_UL_MulticarrierEDCHInfo_TDD128_configuration_info (pctxt, &pvalue->configuration_info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r10_dl_dpchInfoCommon (OSCTXT* pctxt, utran_DL_CommonInformation_r10_dl_dpchInfoCommon* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_DPCH_InfoCommon */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoCommon");

         pvalue->u.dl_DPCH_InfoCommon = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r6);

         if (pvalue->u.dl_DPCH_InfoCommon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r6 (pvalue->u.dl_DPCH_InfoCommon);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_DPCH_InfoCommon);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_FDPCH_InfoCommon */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-FDPCH-InfoCommon");

         pvalue->u.dl_FDPCH_InfoCommon = rtxMemAllocType (pctxt, 
            utran_DL_FDPCH_InfoCommon_r6);

         if (pvalue->u.dl_FDPCH_InfoCommon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_FDPCH_InfoCommon_r6 (pvalue->u.dl_FDPCH_InfoCommon);

         stat = asn1PD_utran_DL_FDPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_FDPCH_InfoCommon);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TGP_Sequence_r10_tgps_Status_activate (OSCTXT* pctxt, utran_TGP_Sequence_r10_tgps_Status_activate* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tgcfn */
   RTXCTXTPUSHELEMNAME (pctxt, "tgcfn");

   stat = asn1PD_utran_TGCFN (pctxt, &pvalue->tgcfn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGP_Sequence_r10_tgps_Status (OSCTXT* pctxt, utran_TGP_Sequence_r10_tgps_Status* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* activate */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "activate");

         pvalue->u.activate = rtxMemAllocTypeZ (pctxt, 
            utran_TGP_Sequence_r10_tgps_Status_activate);

         if (pvalue->u.activate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_TGP_Sequence_r10_tgps_Status_activate (pctxt, pvalue->u.activate);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* deactivate */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "deactivate");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode (OSCTXT* pctxt, utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__300; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TGPS_ConfigurationParams_r10 (OSCTXT* pctxt, utran_TGPS_ConfigurationParams_r10* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[6];

   RTXCTXTPUSHTYPENAME (pctxt, "TGPS-ConfigurationParams-r10");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tgmp */
   RTXCTXTPUSHELEMNAME (pctxt, "tgmp");

   stat = asn1PD_utran_TGMP_r8 (pctxt, &pvalue->tgmp);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode freqSpecificCompressedMode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "freqSpecificCompressedMode");

      pvalue->m.freqSpecificCompressedModePresent = 1;

      stat = asn1PD_utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode (pctxt, &pvalue->freqSpecificCompressedMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tgprc */
   RTXCTXTPUSHELEMNAME (pctxt, "tgprc");

   stat = asn1PD_utran_TGPRC (pctxt, &pvalue->tgprc);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgsn */
   RTXCTXTPUSHELEMNAME (pctxt, "tgsn");

   stat = asn1PD_utran_TGSN (pctxt, &pvalue->tgsn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgl1 */
   RTXCTXTPUSHELEMNAME (pctxt, "tgl1");

   stat = asn1PD_utran_TGL (pctxt, &pvalue->tgl1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgl2 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tgl2");

      pvalue->m.tgl2Present = 1;

      stat = asn1PD_utran_TGL (pctxt, &pvalue->tgl2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tgd */
   RTXCTXTPUSHELEMNAME (pctxt, "tgd");

   stat = asn1PD_utran_TGD (pctxt, &pvalue->tgd);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgpl1 */
   RTXCTXTPUSHELEMNAME (pctxt, "tgpl1");

   stat = asn1PD_utran_TGPL (pctxt, &pvalue->tgpl1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rpp */
   RTXCTXTPUSHELEMNAME (pctxt, "rpp");

   stat = asn1PD_utran_RPP (pctxt, &pvalue->rpp);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode itp */
   RTXCTXTPUSHELEMNAME (pctxt, "itp");

   stat = asn1PD_utran_ITP (pctxt, &pvalue->itp);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_DL_Mode */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-DL-Mode");

   stat = asn1PD_utran_UL_DL_Mode (pctxt, &pvalue->ul_DL_Mode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_FrameType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-FrameType");

   stat = asn1PD_utran_DL_FrameType (pctxt, &pvalue->dl_FrameType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaSIR1 */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaSIR1");

   stat = asn1PD_utran_DeltaSIR (pctxt, &pvalue->deltaSIR1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaSIRAfter1 */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaSIRAfter1");

   stat = asn1PD_utran_DeltaSIR (pctxt, &pvalue->deltaSIRAfter1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaSIR2 */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaSIR2");

      pvalue->m.deltaSIR2Present = 1;

      stat = asn1PD_utran_DeltaSIR (pctxt, &pvalue->deltaSIR2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode deltaSIRAfter2 */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaSIRAfter2");

      pvalue->m.deltaSIRAfter2Present = 1;

      stat = asn1PD_utran_DeltaSIR (pctxt, &pvalue->deltaSIRAfter2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nidentifyAbort */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nidentifyAbort");

      pvalue->m.nidentifyAbortPresent = 1;

      stat = asn1PD_utran_NidentifyAbort (pctxt, &pvalue->nidentifyAbort);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode treconfirmAbort */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "treconfirmAbort");

      pvalue->m.treconfirmAbortPresent = 1;

      stat = asn1PD_utran_TreconfirmAbort (pctxt, &pvalue->treconfirmAbort);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGP_Sequence_r10 (OSCTXT* pctxt, utran_TGP_Sequence_r10* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TGP-Sequence-r10");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tgpsi */
   RTXCTXTPUSHELEMNAME (pctxt, "tgpsi");

   stat = asn1PD_utran_TGPSI (pctxt, &pvalue->tgpsi);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgps_Status */
   RTXCTXTPUSHELEMNAME (pctxt, "tgps-Status");

   stat = asn1PD_utran_TGP_Sequence_r10_tgps_Status (pctxt, &pvalue->tgps_Status);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tgps_ConfigurationParams */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tgps-ConfigurationParams");

      pvalue->m.tgps_ConfigurationParamsPresent = 1;

      stat = asn1PD_utran_TGPS_ConfigurationParams_r10 (pctxt, &pvalue->tgps_ConfigurationParams);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TGP_SequenceList_r10 (OSCTXT* pctxt, utran_TGP_SequenceList_r10* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TGP-SequenceList-r10");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(6), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_TGP_Sequence_r10* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TGP-Sequence-r10", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_TGP_Sequence_r10, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_TGP_Sequence_r10 (pdata);

      stat = asn1PD_utran_TGP_Sequence_r10 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DPCH_CompressedModeInfo_r10 (OSCTXT* pctxt, utran_DPCH_CompressedModeInfo_r10* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DPCH-CompressedModeInfo-r10");

   /* decode root elements */
   /* decode tgp_SequenceList */
   RTXCTXTPUSHELEMNAME (pctxt, "tgp-SequenceList");

   stat = asn1PD_utran_TGP_SequenceList_r10 (pctxt, &pvalue->tgp_SequenceList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r10_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_CommonInformation_r10_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueFDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dpch_CompressedModeInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dpch-CompressedModeInfo");

      pvalue->m.dpch_CompressedModeInfoPresent = 1;

      stat = asn1PD_utran_DPCH_CompressedModeInfo_r10 (pctxt, &pvalue->dpch_CompressedModeInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tx_DiversityMode */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tx-DiversityMode");

      pvalue->m.tx_DiversityModePresent = 1;

      stat = asn1PD_utran_TX_DiversityMode (pctxt, &pvalue->tx_DiversityMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r10_modeSpecificInfo_tdd_tddOption_tdd128 (OSCTXT* pctxt, utran_DL_CommonInformation_r10_modeSpecificInfo_tdd_tddOption_tdd128* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tstd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "tstd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->tstd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r10_modeSpecificInfo_tdd_tddOption (OSCTXT* pctxt, utran_DL_CommonInformation_r10_modeSpecificInfo_tdd_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocTypeZ (pctxt, 
            utran_DL_CommonInformation_r10_modeSpecificInfo_tdd_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_CommonInformation_r10_modeSpecificInfo_tdd_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r10_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_CommonInformation_r10_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_DL_CommonInformation_r10_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueTDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r10_modeSpecificInfo (OSCTXT* pctxt, utran_DL_CommonInformation_r10_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r10_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r10_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_CommonInformation_r10_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r10_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r10_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_CommonInformation_r10_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r10_mac_hsResetIndicator (OSCTXT* pctxt, utran_DL_CommonInformation_r10_mac_hsResetIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__271; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r10_postVerificationPeriod (OSCTXT* pctxt, utran_DL_CommonInformation_r10_postVerificationPeriod* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__272; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r10 (OSCTXT* pctxt, utran_DL_CommonInformation_r10* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CommonInformation-r10");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_dpchInfoCommon */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dpchInfoCommon");

      pvalue->m.dl_dpchInfoCommonPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r10_dl_dpchInfoCommon (pctxt, &pvalue->dl_dpchInfoCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_CommonInformation_r10_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_hsResetIndicator */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-hsResetIndicator");

      pvalue->m.mac_hsResetIndicatorPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r10_mac_hsResetIndicator (pctxt, &pvalue->mac_hsResetIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode postVerificationPeriod */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "postVerificationPeriod");

      pvalue->m.postVerificationPeriodPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r10_postVerificationPeriod (pctxt, &pvalue->postVerificationPeriod);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MU_MIMO_Operation (OSCTXT* pctxt, utran_MU_MIMO_Operation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MU-MIMO-Operation");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_StandaloneMidambleInfo_TDD128_repetitionPeriod (OSCTXT* pctxt, utran_StandaloneMidambleInfo_TDD128_repetitionPeriod* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_StandaloneMidambleInfo_TDD128 (OSCTXT* pctxt, utran_StandaloneMidambleInfo_TDD128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "StandaloneMidambleInfo-TDD128");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode midambleConfiguration */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleConfiguration");

   stat = pd_ConsUInt8 (pctxt, &pvalue->midambleConfiguration, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode midambleShift */
   RTXCTXTPUSHELEMNAME (pctxt, "midambleShift");

   stat = pd_ConsUInt8 (pctxt, &pvalue->midambleShift, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeSlotInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "timeSlotInformation");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->timeSlotInformation
      , OSUINTCONST(5), OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode activationTime */
   RTXCTXTPUSHELEMNAME (pctxt, "activationTime");

   stat = asn1PD_utran_ActivationTime (pctxt, &pvalue->activationTime);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode subframeNum */
   RTXCTXTPUSHELEMNAME (pctxt, "subframeNum");

   stat = pd_ConsUInt8 (pctxt, &pvalue->subframeNum, OSUINTCONST(0), OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode repetitionPeriod */
   RTXCTXTPUSHELEMNAME (pctxt, "repetitionPeriod");

   stat = asn1PD_utran_StandaloneMidambleInfo_TDD128_repetitionPeriod (pctxt, &pvalue->repetitionPeriod);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode referenceBeta */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "referenceBeta");

      pvalue->m.referenceBetaPresent = 1;

      stat = pd_ConsInt8 (pctxt, &pvalue->referenceBeta, OSINTCONST(-15), OSINTCONST(16));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MU_MIMO_Info_TDD128_newConfiguration (OSCTXT* pctxt, utran_MU_MIMO_Info_TDD128_newConfiguration* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mu_MIMO_Operation */
   RTXCTXTPUSHELEMNAME (pctxt, "mu-MIMO-Operation");

   stat = asn1PD_utran_MU_MIMO_Operation (pctxt, &pvalue->mu_MIMO_Operation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode standaloneMidambleInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "standaloneMidambleInfo");

      pvalue->m.standaloneMidambleInfoPresent = 1;

      stat = asn1PD_utran_StandaloneMidambleInfo_TDD128 (pctxt, &pvalue->standaloneMidambleInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_MU_MIMO_Info_TDD128 (OSCTXT* pctxt, utran_MU_MIMO_Info_TDD128* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "MU-MIMO-Info-TDD128");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* continue_ */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "continue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* newConfiguration */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "newConfiguration");

         pvalue->u.newConfiguration = rtxMemAllocType (pctxt, 
            utran_MU_MIMO_Info_TDD128_newConfiguration);

         if (pvalue->u.newConfiguration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_MU_MIMO_Info_TDD128_newConfiguration (pvalue->u.newConfiguration);

         stat = asn1PD_utran_MU_MIMO_Info_TDD128_newConfiguration (pctxt, pvalue->u.newConfiguration);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize (OSCTXT* pctxt, utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size (OSCTXT* pctxt, utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fixedSize */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fixedSize");

         pvalue->u.fixedSize = rtxMemAllocType (pctxt, 
            utran_OctetModeRLC_SizeInfoType1);

         if (pvalue->u.fixedSize == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_OctetModeRLC_SizeInfoType1 (pvalue->u.fixedSize);

         stat = asn1PD_utran_OctetModeRLC_SizeInfoType1 (pctxt, pvalue->u.fixedSize);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* flexibleSize */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "flexibleSize");

         stat = asn1PD_utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize (pctxt, &pvalue->u.flexibleSize);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TimerReordering (OSCTXT* pctxt, utran_TimerReordering* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimerReordering");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_RLC_StatusInfo_r11 (OSCTXT* pctxt, utran_DL_RLC_StatusInfo_r11* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-RLC-StatusInfo-r11");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode timerStatusProhibit */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timerStatusProhibit");

      pvalue->m.timerStatusProhibitPresent = 1;

      stat = asn1PD_utran_TimerStatusProhibit (pctxt, &pvalue->timerStatusProhibit);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode missingPDU_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "missingPDU-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->missingPDU_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timerStatusPeriodic */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timerStatusPeriodic");

      pvalue->m.timerStatusPeriodicPresent = 1;

      stat = asn1PD_utran_TimerStatusPeriodic (pctxt, &pvalue->timerStatusPeriodic);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode timerReordering */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timerReordering");

      pvalue->m.timerReorderingPresent = 1;

      stat = asn1PD_utran_TimerReordering (pctxt, &pvalue->timerReordering);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AM_RLC_Mode_r11 (OSCTXT* pctxt, utran_DL_AM_RLC_Mode_r11* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AM-RLC-Mode-r11");

   /* decode root elements */
   /* decode dl_RLC_PDU_size */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-RLC-PDU-size");

   stat = asn1PD_utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size (pctxt, &pvalue->dl_RLC_PDU_size);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode inSequenceDelivery */
   RTXCTXTPUSHELEMNAME (pctxt, "inSequenceDelivery");

   stat = DEC_BIT (pctxt, &pvalue->inSequenceDelivery);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode receivingWindowSize */
   RTXCTXTPUSHELEMNAME (pctxt, "receivingWindowSize");

   stat = asn1PD_utran_ReceivingWindowSize (pctxt, &pvalue->receivingWindowSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_RLC_StatusInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-RLC-StatusInfo");

   stat = asn1PD_utran_DL_RLC_StatusInfo_r11 (pctxt, &pvalue->dl_RLC_StatusInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_RLC_Mode_r11 (OSCTXT* pctxt, utran_DL_RLC_Mode_r11* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-RLC-Mode-r11");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_AM_RLC_Mode */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-AM-RLC-Mode");

         pvalue->u.dl_AM_RLC_Mode = rtxMemAllocType (pctxt, 
            utran_DL_AM_RLC_Mode_r11);

         if (pvalue->u.dl_AM_RLC_Mode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_AM_RLC_Mode_r11 (pvalue->u.dl_AM_RLC_Mode);

         stat = asn1PD_utran_DL_AM_RLC_Mode_r11 (pctxt, pvalue->u.dl_AM_RLC_Mode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_UM_RLC_Mode */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-UM-RLC-Mode");

         pvalue->u.dl_UM_RLC_Mode = rtxMemAllocType (pctxt, 
            utran_DL_UM_RLC_Mode_r6);

         if (pvalue->u.dl_UM_RLC_Mode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_UM_RLC_Mode_r6 (pvalue->u.dl_UM_RLC_Mode);

         stat = asn1PD_utran_DL_UM_RLC_Mode_r6 (pctxt, pvalue->u.dl_UM_RLC_Mode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_TM_RLC_Mode */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-TM-RLC-Mode");

         pvalue->u.dl_TM_RLC_Mode = rtxMemAllocTypeZ (pctxt, 
            utran_DL_TM_RLC_Mode);

         if (pvalue->u.dl_TM_RLC_Mode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_TM_RLC_Mode (pctxt, pvalue->u.dl_TM_RLC_Mode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RLC_Info_r11_altE_bitInterpretation (OSCTXT* pctxt, utran_RLC_Info_r11_altE_bitInterpretation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__260; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_RLC_Info_r11_useSpecialValueOfHEField (OSCTXT* pctxt, utran_RLC_Info_r11_useSpecialValueOfHEField* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__261; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_RLC_Info_r11 (OSCTXT* pctxt, utran_RLC_Info_r11* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "RLC-Info-r11");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_RLC_Mode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-RLC-Mode");

      pvalue->m.ul_RLC_ModePresent = 1;

      stat = asn1PD_utran_UL_RLC_Mode (pctxt, &pvalue->ul_RLC_Mode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_RLC_Mode */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-RLC-Mode");

      pvalue->m.dl_RLC_ModePresent = 1;

      stat = asn1PD_utran_DL_RLC_Mode_r11 (pctxt, &pvalue->dl_RLC_Mode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_OneSidedReEst */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-OneSidedReEst");

   stat = DEC_BIT (pctxt, &pvalue->rlc_OneSidedReEst);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode altE_bitInterpretation */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "altE-bitInterpretation");

      pvalue->m.altE_bitInterpretationPresent = 1;

      stat = asn1PD_utran_RLC_Info_r11_altE_bitInterpretation (pctxt, &pvalue->altE_bitInterpretation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode useSpecialValueOfHEField */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "useSpecialValueOfHEField");

      pvalue->m.useSpecialValueOfHEFieldPresent = 1;

      stat = asn1PD_utran_RLC_Info_r11_useSpecialValueOfHEField (pctxt, &pvalue->useSpecialValueOfHEField);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationReconfig_r11 (OSCTXT* pctxt, utran_RB_InformationReconfig_r11* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationReconfig-r11");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdcp_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Info");

      pvalue->m.pdcp_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_InfoReconfig_r4 (pctxt, &pvalue->pdcp_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pdcp_SN_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-SN-Info");

      pvalue->m.pdcp_SN_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_SN_Info (pctxt, &pvalue->pdcp_SN_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_Info */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlc-Info");

      pvalue->m.rlc_InfoPresent = 1;

      stat = asn1PD_utran_RLC_Info_r11 (pctxt, &pvalue->rlc_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_MappingInfo */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

      pvalue->m.rb_MappingInfoPresent = 1;

      stat = asn1PD_utran_RB_MappingInfo_r8 (pctxt, &pvalue->rb_MappingInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_StopContinue */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-StopContinue");

      pvalue->m.rb_StopContinuePresent = 1;

      stat = asn1PD_utran_RB_StopContinue (pctxt, &pvalue->rb_StopContinue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationReconfigList_r11 (OSCTXT* pctxt, utran_RB_InformationReconfigList_r11* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationReconfigList-r11");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationReconfig_r11* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationReconfig-r11", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationReconfig_r11, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationReconfig_r11 (pdata);

      stat = asn1PD_utran_RB_InformationReconfig_r11 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_hs_WindowSize_r11 (OSCTXT* pctxt, utran_MAC_hs_WindowSize_r11* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-hs-WindowSize-r11");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_ehs_AddReconfReordQ_r11 (OSCTXT* pctxt, utran_MAC_ehs_AddReconfReordQ_r11* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-ehs-AddReconfReordQ-r11");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_ehs_QueueId */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs-QueueId");

   stat = asn1PD_utran_MAC_ehs_QueueId (pctxt, &pvalue->mac_ehs_QueueId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reorderingReleaseTimer */
   RTXCTXTPUSHELEMNAME (pctxt, "reorderingReleaseTimer");

   stat = asn1PD_utran_T1_ReleaseTimer (pctxt, &pvalue->reorderingReleaseTimer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reorderingResetTimer */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "reorderingResetTimer");

      pvalue->m.reorderingResetTimerPresent = 1;

      stat = asn1PD_utran_Treset_ResetTimer (pctxt, &pvalue->reorderingResetTimer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mac_ehsWindowSize */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-ehsWindowSize");

   stat = asn1PD_utran_MAC_hs_WindowSize_r11 (pctxt, &pvalue->mac_ehsWindowSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_ehsWindowSize_extension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-ehsWindowSize-extension");

      pvalue->m.mac_ehsWindowSize_extensionPresent = 1;

      stat = asn1PD_utran_MAC_ehs_WindowSize_TDD128_v9c0ext (pctxt, &pvalue->mac_ehsWindowSize_extension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_MAC_ehs_AddReconfReordQ_List_r11 (OSCTXT* pctxt, utran_MAC_ehs_AddReconfReordQ_List_r11* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-ehs-AddReconfReordQ-List-r11");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_MAC_ehs_AddReconfReordQ_r11* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MAC-ehs-AddReconfReordQ-r11", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_MAC_ehs_AddReconfReordQ_r11, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_MAC_ehs_AddReconfReordQ_r11 (pdata);

      stat = asn1PD_utran_MAC_ehs_AddReconfReordQ_r11 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_AddOrReconfMAC_ehs_ReordQ_r11 (OSCTXT* pctxt, utran_AddOrReconfMAC_ehs_ReordQ_r11* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AddOrReconfMAC-ehs-ReordQ-r11");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_ehs_AddReconfQueue_List */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs-AddReconfQueue-List");

      pvalue->m.mac_ehs_AddReconfQueue_ListPresent = 1;

      stat = asn1PD_utran_MAC_ehs_AddReconfReordQ_List_r11 (pctxt, &pvalue->mac_ehs_AddReconfQueue_List);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HSDSCH_Info_r11_dl_MAC_HeaderType (OSCTXT* pctxt, utran_HSDSCH_Info_r11_dl_MAC_HeaderType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* mac_hs */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "mac-hs");

         pvalue->u.mac_hs = rtxMemAllocType (pctxt, 
            utran_AddOrReconfMAC_dFlow);

         if (pvalue->u.mac_hs == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_AddOrReconfMAC_dFlow (pvalue->u.mac_hs);

         stat = asn1PD_utran_AddOrReconfMAC_dFlow (pctxt, pvalue->u.mac_hs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* mac_ehs */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs");

         pvalue->u.mac_ehs = rtxMemAllocType (pctxt, 
            utran_AddOrReconfMAC_ehs_ReordQ_r11);

         if (pvalue->u.mac_ehs == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_AddOrReconfMAC_ehs_ReordQ_r11 (pvalue->u.mac_ehs);

         stat = asn1PD_utran_AddOrReconfMAC_ehs_ReordQ_r11 (pctxt, pvalue->u.mac_ehs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HSDSCH_Info_r11 (OSCTXT* pctxt, utran_HSDSCH_Info_r11* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "HSDSCH-Info-r11");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode harqInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "harqInfo");

      pvalue->m.harqInfoPresent = 1;

      stat = asn1PD_utran_HARQ_Info_r11 (pctxt, &pvalue->harqInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_MAC_HeaderType */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-MAC-HeaderType");

      pvalue->m.dl_MAC_HeaderTypePresent = 1;

      stat = asn1PD_utran_HSDSCH_Info_r11_dl_MAC_HeaderType (pctxt, &pvalue->dl_MAC_HeaderType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation_r11_tfs_SignallingMode (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation_r11_tfs_SignallingMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* explicit_config */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "explicit-config");

         pvalue->u.explicit_config = rtxMemAllocType (pctxt, 
            utran_TransportFormatSet);

         if (pvalue->u.explicit_config == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TransportFormatSet (pvalue->u.explicit_config);

         stat = asn1PD_utran_TransportFormatSet (pctxt, pvalue->u.explicit_config);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sameAsULTrCH */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsULTrCH");

         pvalue->u.sameAsULTrCH = rtxMemAllocTypeZ (pctxt, 
            utran_UL_TransportChannelIdentity);

         if (pvalue->u.sameAsULTrCH == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UL_TransportChannelIdentity (pctxt, pvalue->u.sameAsULTrCH);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* hsdsch */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "hsdsch");

         pvalue->u.hsdsch = rtxMemAllocType (pctxt, utran_HSDSCH_Info_r11);

         if (pvalue->u.hsdsch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_HSDSCH_Info_r11 (pvalue->u.hsdsch);

         stat = asn1PD_utran_HSDSCH_Info_r11 (pctxt, pvalue->u.hsdsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation_r11 (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation_r11* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInformation-r11");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TransportChannelType");

   stat = asn1PD_utran_DL_TrCH_TypeId1_r5 (pctxt, &pvalue->dl_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfs_SignallingMode */
   RTXCTXTPUSHELEMNAME (pctxt, "tfs-SignallingMode");

   stat = asn1PD_utran_DL_AddReconfTransChInformation_r11_tfs_SignallingMode (pctxt, &pvalue->tfs_SignallingMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dch_QualityTarget */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dch-QualityTarget");

      pvalue->m.dch_QualityTargetPresent = 1;

      stat = asn1PD_utran_QualityTarget (pctxt, &pvalue->dch_QualityTarget);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInfoList_r11 (OSCTXT* pctxt, utran_DL_AddReconfTransChInfoList_r11* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInfoList-r11");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_AddReconfTransChInformation_r11* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-AddReconfTransChInformation-r11", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_AddReconfTransChInformation_r11, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_AddReconfTransChInformation_r11 (pdata);

      stat = asn1PD_utran_DL_AddReconfTransChInformation_r11 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r11_fdd (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r11_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dpcch_PowerOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "dpcch-PowerOffset");

   stat = asn1PD_utran_DPCCH_PowerOffset (pctxt, &pvalue->dpcch_PowerOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pc_Preamble */
   RTXCTXTPUSHELEMNAME (pctxt, "pc-Preamble");

   stat = asn1PD_utran_PC_Preamble (pctxt, &pvalue->pc_Preamble);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sRB_delay */
   RTXCTXTPUSHELEMNAME (pctxt, "sRB-delay");

   stat = asn1PD_utran_SRB_delay (pctxt, &pvalue->sRB_delay);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerControlAlgorithm */
   RTXCTXTPUSHELEMNAME (pctxt, "powerControlAlgorithm");

   stat = asn1PD_utran_PowerControlAlgorithm (pctxt, &pvalue->powerControlAlgorithm);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaACK */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaACK");

      pvalue->m.deltaACKPresent = 1;

      stat = asn1PD_utran_DeltaACK_r11 (pctxt, &pvalue->deltaACK);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode deltaNACK */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaNACK");

      pvalue->m.deltaNACKPresent = 1;

      stat = asn1PD_utran_DeltaNACK_r11 (pctxt, &pvalue->deltaNACK);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ack_NACK_repetition_factor */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ack-NACK-repetition-factor");

      pvalue->m.ack_NACK_repetition_factorPresent = 1;

      stat = asn1PD_utran_ACK_NACK_repetitionFactor (pctxt, &pvalue->ack_NACK_repetition_factor);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ack_NACK_repetition_factor_assisting */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ack-NACK-repetition-factor-assisting");

      pvalue->m.ack_NACK_repetition_factor_assistingPresent = 1;

      stat = asn1PD_utran_ACK_NACK_repetitionFactor (pctxt, &pvalue->ack_NACK_repetition_factor_assisting);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode harq_Preamble_Mode */
   RTXCTXTPUSHELEMNAME (pctxt, "harq-Preamble-Mode");

   stat = asn1PD_utran_HARQ_Preamble_Mode (pctxt, &pvalue->harq_Preamble_Mode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTS_InterferenceList */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTS-InterferenceList");

   stat = asn1PD_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpch_ConstantValue */
   RTXCTXTPUSHELEMNAME (pctxt, "dpch-ConstantValue");

   stat = asn1PD_utran_ConstantValue (pctxt, &pvalue->dpch_ConstantValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode individualTS_InterferenceList */
   RTXCTXTPUSHELEMNAME (pctxt, "individualTS-InterferenceList");

   stat = asn1PD_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpch_ConstantValue */
   RTXCTXTPUSHELEMNAME (pctxt, "dpch-ConstantValue");

   stat = asn1PD_utran_ConstantValue (pctxt, &pvalue->dpch_ConstantValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode beaconPLEst */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "beaconPLEst");

      pvalue->m.beaconPLEstPresent = 1;

      stat = asn1PD_utran_BEACON_PL_Est (pctxt, &pvalue->beaconPLEst);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tpc_StepSize */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-StepSize");

   stat = asn1PD_utran_TPC_StepSizeTDD (pctxt, &pvalue->tpc_StepSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         pvalue->u.tdd384 = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384);

         if (pvalue->u.tdd384 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pvalue->u.tdd384);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         pvalue->u.tdd768 = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768);

         if (pvalue->u.tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768 (pvalue->u.tdd768);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768 (pctxt, pvalue->u.tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode primaryCCPCH_TX_Power */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCCPCH-TX-Power");

   stat = asn1PD_utran_PrimaryCCPCH_TX_Power (pctxt, &pvalue->primaryCCPCH_TX_Power);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* broadcast_UL_OL_PC_info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "broadcast-UL-OL-PC-info");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* individuallySignalled */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "individuallySignalled");

         pvalue->u.individuallySignalled = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled);

         if (pvalue->u.individuallySignalled == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled (pvalue->u.individuallySignalled);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled (pctxt, pvalue->u.individuallySignalled);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r11_tdd (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r11_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TargetSIR */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TargetSIR");

      pvalue->m.ul_TargetSIRPresent = 1;

      stat = asn1PD_utran_UL_TargetSIR (pctxt, &pvalue->ul_TargetSIR);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_OL_PC_Signalling */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-OL-PC-Signalling");

   stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling (pctxt, &pvalue->ul_OL_PC_Signalling);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfo_r11 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfo_r11* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-PowerControlInfo-r11");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r11_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r11_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r11_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_PowerControlInfo_r11_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_PowerControlInfo_r11_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r11_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence_present (OSCTXT* pctxt, utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence_present* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode numberOfDPDCH */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfDPDCH");

      stat = asn1PD_utran_NumberOfDPDCH (pctxt, &pvalue->numberOfDPDCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->numberOfDPDCH = 1;
   }

   /* decode spreadingFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactor");

   stat = asn1PD_utran_SpreadingFactor (pctxt, &pvalue->spreadingFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfFBI_Bits */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfFBI-Bits");

      pvalue->m.numberOfFBI_BitsPresent = 1;

      stat = asn1PD_utran_NumberOfFBI_Bits (pctxt, &pvalue->numberOfFBI_Bits);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode numberOfTPC_Bits */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfTPC-Bits");

      pvalue->m.numberOfTPC_BitsPresent = 1;

      stat = asn1PD_utran_NumberOfTPC_Bits (pctxt, &pvalue->numberOfTPC_Bits);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode puncturingLimit */
   RTXCTXTPUSHELEMNAME (pctxt, "puncturingLimit");

   stat = asn1PD_utran_PuncturingLimit (pctxt, &pvalue->puncturingLimit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence_notPresent (OSCTXT* pctxt, utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence_notPresent* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfFBI_Bits */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfFBI-Bits");

      pvalue->m.numberOfFBI_BitsPresent = 1;

      stat = asn1PD_utran_NumberOfFBI_Bits (pctxt, &pvalue->numberOfFBI_Bits);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode numberOfTPC_Bits */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "numberOfTPC-Bits");

      pvalue->m.numberOfTPC_BitsPresent = 1;

      stat = asn1PD_utran_NumberOfTPC_Bits (pctxt, &pvalue->numberOfTPC_Bits);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence (OSCTXT* pctxt, utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* present */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "present");

         pvalue->u.present = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence_present);

         if (pvalue->u.present == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence_present (pvalue->u.present);

         stat = asn1PD_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence_present (pctxt, pvalue->u.present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* notPresent */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "notPresent");

         pvalue->u.notPresent = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence_notPresent);

         if (pvalue->u.notPresent == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence_notPresent (pvalue->u.notPresent);

         stat = asn1PD_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence_notPresent (pctxt, pvalue->u.notPresent);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode scramblingCodeType */
   RTXCTXTPUSHELEMNAME (pctxt, "scramblingCodeType");

   stat = asn1PD_utran_ScramblingCodeType (pctxt, &pvalue->scramblingCodeType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode scramblingCode */
   RTXCTXTPUSHELEMNAME (pctxt, "scramblingCode");

   stat = asn1PD_utran_UL_ScramblingCode (pctxt, &pvalue->scramblingCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpdchPresence */
   RTXCTXTPUSHELEMNAME (pctxt, "dpdchPresence");

   stat = asn1PD_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence (pctxt, &pvalue->dpdchPresence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r11_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_UL_DPCH_Info_r11_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_TimingAdvance */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TimingAdvance");

      pvalue->m.ul_TimingAdvancePresent = 1;

      stat = asn1PD_utran_UL_TimingAdvanceControl_r7 (pctxt, &pvalue->ul_TimingAdvance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCHList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCHList");

      pvalue->m.ul_CCTrCHListPresent = 1;

      stat = asn1PD_utran_UL_CCTrCHList_r7 (pctxt, &pvalue->ul_CCTrCHList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCHListToRemove */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCHListToRemove");

      pvalue->m.ul_CCTrCHListToRemovePresent = 1;

      stat = asn1PD_utran_UL_CCTrCHListToRemove (pctxt, &pvalue->ul_CCTrCHListToRemove);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r11_modeSpecificInfo (OSCTXT* pctxt, utran_UL_DPCH_Info_r11_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_DPCH_Info_r11_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_DPCH_Info_r11_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_DPCH_Info_r11_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_Info_r11 (OSCTXT* pctxt, utran_UL_DPCH_Info_r11* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-Info-r11");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-DPCH-PowerControlInfo");

      pvalue->m.ul_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_UL_DPCH_PowerControlInfo_r11 (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_UL_DPCH_Info_r11_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator (OSCTXT* pctxt, utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__307; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r11_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_UL_EDCH_Information_r11_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[6];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_DPCCH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-DPCCH-Info");

      pvalue->m.e_DPCCH_InfoPresent = 1;

      stat = asn1PD_utran_E_DPCCH_Info_r7 (pctxt, &pvalue->e_DPCCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_DPDCH_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-DPDCH-Info");

      pvalue->m.e_DPDCH_InfoPresent = 1;

      stat = asn1PD_utran_E_DPDCH_Info_r8 (pctxt, &pvalue->e_DPDCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_MIMO_Info */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-MIMO-Info");

      pvalue->m.ul_MIMO_InfoPresent = 1;

      stat = asn1PD_utran_UL_MIMO_InfoFDD (pctxt, &pvalue->ul_MIMO_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode schedulingTransmConfiguration */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "schedulingTransmConfiguration");

      pvalue->m.schedulingTransmConfigurationPresent = 1;

      stat = asn1PD_utran_E_DPDCH_SchedulingTransmConfiguration (pctxt, &pvalue->schedulingTransmConfiguration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_16QAM_Settings */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-16QAM-Settings");

      pvalue->m.ul_16QAM_SettingsPresent = 1;

      stat = asn1PD_utran_UL_16QAM_Settings (pctxt, &pvalue->ul_16QAM_Settings);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_64QAM_Settings */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-64QAM-Settings");

      pvalue->m.ul_64QAM_SettingsPresent = 1;

      stat = asn1PD_utran_UL_64QAM_Settings (pctxt, &pvalue->ul_64QAM_Settings);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r11_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_UL_EDCH_Information_r11_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_RUCCH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RUCCH-Info");

      pvalue->m.e_RUCCH_InfoPresent = 1;

      stat = asn1PD_utran_E_RUCCH_Info (pctxt, &pvalue->e_RUCCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_PUCH_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-PUCH-Info");

      pvalue->m.e_PUCH_InfoPresent = 1;

      stat = asn1PD_utran_E_PUCH_Info (pctxt, &pvalue->e_PUCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode non_ScheduledTransGrantInfo */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "non-ScheduledTransGrantInfo");

      pvalue->m.non_ScheduledTransGrantInfoPresent = 1;

      stat = asn1PD_utran_Non_ScheduledTransGrantInfoTDD_r9 (pctxt, &pvalue->non_ScheduledTransGrantInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r11_modeSpecificInfo (OSCTXT* pctxt, utran_UL_EDCH_Information_r11_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_EDCH_Information_r11_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_EDCH_Information_r11_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_EDCH_Information_r11_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_EDCH_Information_r11_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_EDCH_Information_r11_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_EDCH_Information_r11_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_EDCH_Information_r11 (OSCTXT* pctxt, utran_UL_EDCH_Information_r11* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-EDCH-Information-r11");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mac_es_e_resetIndicator */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-es-e-resetIndicator");

      pvalue->m.mac_es_e_resetIndicatorPresent = 1;

      stat = asn1PD_utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator (pctxt, &pvalue->mac_es_e_resetIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_UL_EDCH_Information_r11_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r11_dl_dpchInfoCommon (OSCTXT* pctxt, utran_DL_CommonInformation_r11_dl_dpchInfoCommon* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_DPCH_InfoCommon */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoCommon");

         pvalue->u.dl_DPCH_InfoCommon = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r6);

         if (pvalue->u.dl_DPCH_InfoCommon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r6 (pvalue->u.dl_DPCH_InfoCommon);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_DPCH_InfoCommon);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_FDPCH_InfoCommon */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-FDPCH-InfoCommon");

         pvalue->u.dl_FDPCH_InfoCommon = rtxMemAllocType (pctxt, 
            utran_DL_FDPCH_InfoCommon_r6);

         if (pvalue->u.dl_FDPCH_InfoCommon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_FDPCH_InfoCommon_r6 (pvalue->u.dl_FDPCH_InfoCommon);

         stat = asn1PD_utran_DL_FDPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_FDPCH_InfoCommon);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r11_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_CommonInformation_r11_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueFDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dpch_CompressedModeInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dpch-CompressedModeInfo");

      pvalue->m.dpch_CompressedModeInfoPresent = 1;

      stat = asn1PD_utran_DPCH_CompressedModeInfo_r10 (pctxt, &pvalue->dpch_CompressedModeInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tx_DiversityMode */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tx-DiversityMode");

      pvalue->m.tx_DiversityModePresent = 1;

      stat = asn1PD_utran_TX_DiversityMode (pctxt, &pvalue->tx_DiversityMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r11_modeSpecificInfo_tdd_tddOption_tdd128 (OSCTXT* pctxt, utran_DL_CommonInformation_r11_modeSpecificInfo_tdd_tddOption_tdd128* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tstd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "tstd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->tstd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r11_modeSpecificInfo_tdd_tddOption (OSCTXT* pctxt, utran_DL_CommonInformation_r11_modeSpecificInfo_tdd_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocTypeZ (pctxt, 
            utran_DL_CommonInformation_r11_modeSpecificInfo_tdd_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_CommonInformation_r11_modeSpecificInfo_tdd_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r11_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_CommonInformation_r11_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_DL_CommonInformation_r11_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueTDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r11_modeSpecificInfo (OSCTXT* pctxt, utran_DL_CommonInformation_r11_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r11_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r11_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_CommonInformation_r11_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r11_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r11_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_CommonInformation_r11_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r11_mac_hsResetIndicator (OSCTXT* pctxt, utran_DL_CommonInformation_r11_mac_hsResetIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__273; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r11_postVerificationPeriod (OSCTXT* pctxt, utran_DL_CommonInformation_r11_postVerificationPeriod* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__274; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting (OSCTXT* pctxt, utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__275; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r11 (OSCTXT* pctxt, utran_DL_CommonInformation_r11* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CommonInformation-r11");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_dpchInfoCommon */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dpchInfoCommon");

      pvalue->m.dl_dpchInfoCommonPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r11_dl_dpchInfoCommon (pctxt, &pvalue->dl_dpchInfoCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_CommonInformation_r11_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_hsResetIndicator */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-hsResetIndicator");

      pvalue->m.mac_hsResetIndicatorPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r11_mac_hsResetIndicator (pctxt, &pvalue->mac_hsResetIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode postVerificationPeriod */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "postVerificationPeriod");

      pvalue->m.postVerificationPeriodPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r11_postVerificationPeriod (pctxt, &pvalue->postVerificationPeriod);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mac_hsResetIndicator_assisting */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-hsResetIndicator-assisting");

      pvalue->m.mac_hsResetIndicator_assistingPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting (pctxt, &pvalue->mac_hsResetIndicator_assisting);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r11_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode primaryCPICH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCPICH-Info");

   stat = asn1PD_utran_PrimaryCPICH_Info (pctxt, &pvalue->primaryCPICH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode servingHSDSCH_RL_indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "servingHSDSCH-RL-indicator");

   stat = DEC_BIT (pctxt, &pvalue->servingHSDSCH_RL_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode servingEDCH_RL_indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "servingEDCH-RL-indicator");

   stat = DEC_BIT (pctxt, &pvalue->servingEDCH_RL_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_r11_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocTypeZ (pctxt, 
            utran_DL_InformationPerRL_r11_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, utran_PrimaryCCPCH_Info_r4);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_PrimaryCCPCH_Info_r4 (pvalue->u.tdd);

         stat = asn1PD_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r11_dl_dpchInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_r11_dl_dpchInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_DPCH_InfoPerRL */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoPerRL");

         pvalue->u.dl_DPCH_InfoPerRL = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoPerRL_r7);

         if (pvalue->u.dl_DPCH_InfoPerRL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoPerRL_r7 (pvalue->u.dl_DPCH_InfoPerRL);

         stat = asn1PD_utran_DL_DPCH_InfoPerRL_r7 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_FDPCH_InfoPerRL */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-FDPCH-InfoPerRL");

         pvalue->u.dl_FDPCH_InfoPerRL = rtxMemAllocType (pctxt, 
            utran_DL_FDPCH_InfoPerRL_r7);

         if (pvalue->u.dl_FDPCH_InfoPerRL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_FDPCH_InfoPerRL_r7 (pvalue->u.dl_FDPCH_InfoPerRL);

         stat = asn1PD_utran_DL_FDPCH_InfoPerRL_r7 (pctxt, pvalue->u.dl_FDPCH_InfoPerRL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_HICH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* e_HICH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Information");

         pvalue->u.e_HICH_Information = rtxMemAllocType (pctxt, 
            utran_E_HICH_Information_r11);

         if (pvalue->u.e_HICH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_HICH_Information_r11 (pvalue->u.e_HICH_Information);

         stat = asn1PD_utran_E_HICH_Information_r11 (pctxt, pvalue->u.e_HICH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* secondaryReleaseIndicator */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "secondaryReleaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_RGCH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* e_RGCH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "e-RGCH-Information");

         pvalue->u.e_RGCH_Information = rtxMemAllocTypeZ (pctxt, 
            utran_E_RGCH_Information);

         if (pvalue->u.e_RGCH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_E_RGCH_Information (pctxt, pvalue->u.e_RGCH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_f_TPICH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_f_TPICH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* f_TPICH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "f-TPICH-Information");

         pvalue->u.f_TPICH_Information = rtxMemAllocTypeZ (pctxt, 
            utran_F_TPICH_Information);

         if (pvalue->u.f_TPICH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_F_TPICH_Information (pctxt, pvalue->u.f_TPICH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_RGCH_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RGCH-Info");

      pvalue->m.e_RGCH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode f_TPICH_Info */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "f-TPICH-Info");

      pvalue->m.f_TPICH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_f_TPICH_Info (pctxt, &pvalue->f_TPICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd384_tdd768 (OSCTXT* pctxt, utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd384_tdd768* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_E_HICH_Information_TDD384_768 (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd128 (OSCTXT* pctxt, utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_E_HICH_Information_TDD128 (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384_tdd768 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384-tdd768");

         pvalue->u.tdd384_tdd768 = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd384_tdd768);

         if (pvalue->u.tdd384_tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd384_tdd768 (pvalue->u.tdd384_tdd768);

         stat = asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd384_tdd768 (pctxt, pvalue->u.tdd384_tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2 (OSCTXT* pctxt, utran_DL_InformationPerRL_r11_modeSpecificInfo2* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r11 (OSCTXT* pctxt, utran_DL_InformationPerRL_r11* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-r11");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_dpchInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dpchInfo");

      pvalue->m.dl_dpchInfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r11_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_AGCH_Information */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-Information");

      pvalue->m.e_AGCH_InformationPresent = 1;

      stat = asn1PD_utran_E_AGCH_Information_r8 (pctxt, &pvalue->e_AGCH_Information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_ROCH_Information */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-ROCH-Information");

      pvalue->m.e_ROCH_InformationPresent = 1;

      stat = asn1PD_utran_E_ROCH_Information (pctxt, &pvalue->e_ROCH_Information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo2 */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo2");

   stat = asn1PD_utran_DL_InformationPerRL_r11_modeSpecificInfo2 (pctxt, &pvalue->modeSpecificInfo2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cell_id */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cell-id");

      pvalue->m.cell_idPresent = 1;

      stat = asn1PD_utran_CellIdentity (pctxt, &pvalue->cell_id);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_List_r11 (OSCTXT* pctxt, utran_DL_InformationPerRL_List_r11* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-List-r11");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_InformationPerRL_r11* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-InformationPerRL-r11", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_InformationPerRL_r11, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_InformationPerRL_r11 (pdata);

      stat = asn1PD_utran_DL_InformationPerRL_r11 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CommonERGCHChannelConfig (OSCTXT* pctxt, utran_CommonERGCHChannelConfig* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "CommonERGCHChannelConfig");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode channelisationCode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "channelisationCode");

      pvalue->m.channelisationCodePresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->channelisationCode, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode signatureSequence */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "signatureSequence");

      pvalue->m.signatureSequencePresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->signatureSequence, OSUINTCONST(0), OSUINTCONST(39));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration_commonERGCHChannelConfigList (OSCTXT* pctxt, utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration_commonERGCHChannelConfigList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_CommonERGCHChannelConfig* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CommonERGCHChannelConfig", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_CommonERGCHChannelConfig, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_CommonERGCHChannelConfig (pdata);

      stat = asn1PD_utran_CommonERGCHChannelConfig (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_ReportingRange (OSCTXT* pctxt, utran_ReportingRange* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportingRange");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(29));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_FilterCoefficient (OSCTXT* pctxt, utran_FilterCoefficient* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FilterCoefficient");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration (OSCTXT* pctxt, utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode eRGCHNeighbourCellList */
   RTXCTXTPUSHELEMNAME (pctxt, "eRGCHNeighbourCellList");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(32), OSUINTCONST(32), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->eRGCHNeighbourCellList
      , OSUINTCONST(32), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode commonERGCHChannelConfigList */
   RTXCTXTPUSHELEMNAME (pctxt, "commonERGCHChannelConfigList");

   stat = asn1PD_utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration_commonERGCHChannelConfigList (pctxt, &pvalue->commonERGCHChannelConfigList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode minimumServingGrantValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "minimumServingGrantValue");

      pvalue->m.minimumServingGrantValuePresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->minimumServingGrantValue, OSUINTCONST(0), OSUINTCONST(37));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode reportingRange */
   RTXCTXTPUSHELEMNAME (pctxt, "reportingRange");

   stat = asn1PD_utran_ReportingRange (pctxt, &pvalue->reportingRange);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode filterCoefficient */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "filterCoefficient");

      stat = asn1PD_utran_FilterCoefficient (pctxt, &pvalue->filterCoefficient);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->filterCoefficient = utran_fc0_3;
   }

   return (stat);
}

EXTERN int asn1PD_utran_CommonERGCHInfoFDD_configurationInfo (OSCTXT* pctxt, utran_CommonERGCHInfoFDD_configurationInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* continue_ */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "continue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* newConfiguration */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "newConfiguration");

         pvalue->u.newConfiguration = rtxMemAllocType (pctxt, 
            utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration);

         if (pvalue->u.newConfiguration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration (pvalue->u.newConfiguration);

         stat = asn1PD_utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration (pctxt, pvalue->u.newConfiguration);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_CommonERGCHInfoFDD (OSCTXT* pctxt, utran_CommonERGCHInfoFDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CommonERGCHInfoFDD");

   /* decode root elements */
   /* decode configurationInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "configurationInfo");

   stat = asn1PD_utran_CommonERGCHInfoFDD_configurationInfo (pctxt, &pvalue->configurationInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_GainFactorInformation_10msMode_signalledGainFactors (OSCTXT* pctxt, utran_GainFactorInformation_10msMode_signalledGainFactors* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode gainFactorBetaC */
   RTXCTXTPUSHELEMNAME (pctxt, "gainFactorBetaC");

   stat = asn1PD_utran_GainFactor (pctxt, &pvalue->gainFactorBetaC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode gainFactorBetaD */
   RTXCTXTPUSHELEMNAME (pctxt, "gainFactorBetaD");

   stat = asn1PD_utran_GainFactor (pctxt, &pvalue->gainFactorBetaD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode referenceTFC_ID */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "referenceTFC-ID");

      pvalue->m.referenceTFC_IDPresent = 1;

      stat = asn1PD_utran_ReferenceTFC_ID (pctxt, &pvalue->referenceTFC_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_GainFactorInformation_10msMode (OSCTXT* pctxt, utran_GainFactorInformation_10msMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "GainFactorInformation-10msMode");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* signalledGainFactors */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "signalledGainFactors");

         pvalue->u.signalledGainFactors = rtxMemAllocType (pctxt, 
            utran_GainFactorInformation_10msMode_signalledGainFactors);

         if (pvalue->u.signalledGainFactors == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_GainFactorInformation_10msMode_signalledGainFactors (pvalue->u.signalledGainFactors);

         stat = asn1PD_utran_GainFactorInformation_10msMode_signalledGainFactors (pctxt, pvalue->u.signalledGainFactors);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* computedGainFactors */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "computedGainFactors");

         stat = asn1PD_utran_ReferenceTFC_ID (pctxt, &pvalue->u.computedGainFactors);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PowerOffsetInformation_10msMode (OSCTXT* pctxt, utran_PowerOffsetInformation_10msMode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PowerOffsetInformation-10msMode");

   /* decode root elements */
   /* decode gainFactorInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "gainFactorInformation");

   stat = asn1PD_utran_GainFactorInformation_10msMode (pctxt, &pvalue->gainFactorInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit_element (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit_element* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ctfc2 */
   RTXCTXTPUSHELEMNAME (pctxt, "ctfc2");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ctfc2, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerOffsetInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetInformation");

      pvalue->m.powerOffsetInformationPresent = 1;

      stat = asn1PD_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode powerOffsetInformation_10msMode */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetInformation-10msMode");

      pvalue->m.powerOffsetInformation_10msModePresent = 1;

      stat = asn1PD_utran_PowerOffsetInformation_10msMode (pctxt, &pvalue->powerOffsetInformation_10msMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit_element (pdata);

      stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit_element (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit_element* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ctfc4 */
   RTXCTXTPUSHELEMNAME (pctxt, "ctfc4");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ctfc4, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerOffsetInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetInformation");

      pvalue->m.powerOffsetInformationPresent = 1;

      stat = asn1PD_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode powerOffsetInformation_10msMode */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetInformation-10msMode");

      pvalue->m.powerOffsetInformation_10msModePresent = 1;

      stat = asn1PD_utran_PowerOffsetInformation_10msMode (pctxt, &pvalue->powerOffsetInformation_10msMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit_element (pdata);

      stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit_element (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit_element* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ctfc6 */
   RTXCTXTPUSHELEMNAME (pctxt, "ctfc6");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ctfc6, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerOffsetInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetInformation");

      pvalue->m.powerOffsetInformationPresent = 1;

      stat = asn1PD_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode powerOffsetInformation_10msMode */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetInformation-10msMode");

      pvalue->m.powerOffsetInformation_10msModePresent = 1;

      stat = asn1PD_utran_PowerOffsetInformation_10msMode (pctxt, &pvalue->powerOffsetInformation_10msMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit_element (pdata);

      stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit_element (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit_element* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ctfc8 */
   RTXCTXTPUSHELEMNAME (pctxt, "ctfc8");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ctfc8, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerOffsetInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetInformation");

      pvalue->m.powerOffsetInformationPresent = 1;

      stat = asn1PD_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode powerOffsetInformation_10msMode */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetInformation-10msMode");

      pvalue->m.powerOffsetInformation_10msModePresent = 1;

      stat = asn1PD_utran_PowerOffsetInformation_10msMode (pctxt, &pvalue->powerOffsetInformation_10msMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit_element (pdata);

      stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit_element (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit_element* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ctfc12 */
   RTXCTXTPUSHELEMNAME (pctxt, "ctfc12");

   stat = pd_ConsUInt16 (pctxt, &pvalue->ctfc12, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerOffsetInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetInformation");

      pvalue->m.powerOffsetInformationPresent = 1;

      stat = asn1PD_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode powerOffsetInformation_10msMode */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetInformation-10msMode");

      pvalue->m.powerOffsetInformation_10msModePresent = 1;

      stat = asn1PD_utran_PowerOffsetInformation_10msMode (pctxt, &pvalue->powerOffsetInformation_10msMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit_element (pdata);

      stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit_element (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit_element* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ctfc16 */
   RTXCTXTPUSHELEMNAME (pctxt, "ctfc16");

   stat = pd_ConsUInt16 (pctxt, &pvalue->ctfc16, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerOffsetInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetInformation");

      pvalue->m.powerOffsetInformationPresent = 1;

      stat = asn1PD_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode powerOffsetInformation_10msMode */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetInformation-10msMode");

      pvalue->m.powerOffsetInformation_10msModePresent = 1;

      stat = asn1PD_utran_PowerOffsetInformation_10msMode (pctxt, &pvalue->powerOffsetInformation_10msMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit_element (pdata);

      stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit_element (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit_element* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ctfc24 */
   RTXCTXTPUSHELEMNAME (pctxt, "ctfc24");

   stat = pd_ConsUnsigned (pctxt, &pvalue->ctfc24, OSUINTCONST(0), OSUINTCONST(16777215));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerOffsetInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetInformation");

      pvalue->m.powerOffsetInformationPresent = 1;

      stat = asn1PD_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode powerOffsetInformation_10msMode */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetInformation-10msMode");

      pvalue->m.powerOffsetInformation_10msModePresent = 1;

      stat = asn1PD_utran_PowerOffsetInformation_10msMode (pctxt, &pvalue->powerOffsetInformation_10msMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit_element (pdata);

      stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12_ctfcSize* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* ctfc2Bit */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "ctfc2Bit");

         pvalue->u.ctfc2Bit = rtxMemAllocType (pctxt, 
            utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit);

         if (pvalue->u.ctfc2Bit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit (pvalue->u.ctfc2Bit);

         stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit (pctxt, pvalue->u.ctfc2Bit);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ctfc4Bit */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ctfc4Bit");

         pvalue->u.ctfc4Bit = rtxMemAllocType (pctxt, 
            utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit);

         if (pvalue->u.ctfc4Bit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit (pvalue->u.ctfc4Bit);

         stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit (pctxt, pvalue->u.ctfc4Bit);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ctfc6Bit */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "ctfc6Bit");

         pvalue->u.ctfc6Bit = rtxMemAllocType (pctxt, 
            utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit);

         if (pvalue->u.ctfc6Bit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit (pvalue->u.ctfc6Bit);

         stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit (pctxt, pvalue->u.ctfc6Bit);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ctfc8Bit */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "ctfc8Bit");

         pvalue->u.ctfc8Bit = rtxMemAllocType (pctxt, 
            utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit);

         if (pvalue->u.ctfc8Bit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit (pvalue->u.ctfc8Bit);

         stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit (pctxt, pvalue->u.ctfc8Bit);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ctfc12Bit */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "ctfc12Bit");

         pvalue->u.ctfc12Bit = rtxMemAllocType (pctxt, 
            utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit);

         if (pvalue->u.ctfc12Bit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit (pvalue->u.ctfc12Bit);

         stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit (pctxt, pvalue->u.ctfc12Bit);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ctfc16Bit */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "ctfc16Bit");

         pvalue->u.ctfc16Bit = rtxMemAllocType (pctxt, 
            utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit);

         if (pvalue->u.ctfc16Bit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit (pvalue->u.ctfc16Bit);

         stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit (pctxt, pvalue->u.ctfc16Bit);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ctfc24Bit */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "ctfc24Bit");

         pvalue->u.ctfc24Bit = rtxMemAllocType (pctxt, 
            utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit);

         if (pvalue->u.ctfc24Bit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit (pvalue->u.ctfc24Bit);

         stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit (pctxt, pvalue->u.ctfc24Bit);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_ReconfAdd_r12 (OSCTXT* pctxt, utran_TFCS_ReconfAdd_r12* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TFCS-ReconfAdd-r12");

   /* decode root elements */
   /* decode ctfcSize */
   RTXCTXTPUSHELEMNAME (pctxt, "ctfcSize");

   stat = asn1PD_utran_TFCS_ReconfAdd_r12_ctfcSize (pctxt, &pvalue->ctfcSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ExplicitTFCS_Configuration_r12_replacement (OSCTXT* pctxt, utran_ExplicitTFCS_Configuration_r12_replacement* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tfcsRemoval */
   RTXCTXTPUSHELEMNAME (pctxt, "tfcsRemoval");

   stat = asn1PD_utran_TFCS_RemovalList (pctxt, &pvalue->tfcsRemoval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfcsAdd */
   RTXCTXTPUSHELEMNAME (pctxt, "tfcsAdd");

   stat = asn1PD_utran_TFCS_ReconfAdd_r12 (pctxt, &pvalue->tfcsAdd);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ExplicitTFCS_Configuration_r12 (OSCTXT* pctxt, utran_ExplicitTFCS_Configuration_r12* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "ExplicitTFCS-Configuration-r12");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* complete */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "complete");

         pvalue->u.complete = rtxMemAllocType (pctxt, 
            utran_TFCS_ReconfAdd_r12);

         if (pvalue->u.complete == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TFCS_ReconfAdd_r12 (pvalue->u.complete);

         stat = asn1PD_utran_TFCS_ReconfAdd_r12 (pctxt, pvalue->u.complete);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* addition */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "addition");

         pvalue->u.addition = rtxMemAllocType (pctxt, 
            utran_TFCS_ReconfAdd_r12);

         if (pvalue->u.addition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TFCS_ReconfAdd_r12 (pvalue->u.addition);

         stat = asn1PD_utran_TFCS_ReconfAdd_r12 (pctxt, pvalue->u.addition);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* removal */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "removal");

         pvalue->u.removal = rtxMemAllocType (pctxt, utran_TFCS_RemovalList);

         if (pvalue->u.removal == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TFCS_RemovalList (pvalue->u.removal);

         stat = asn1PD_utran_TFCS_RemovalList (pctxt, pvalue->u.removal);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* replacement */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "replacement");

         pvalue->u.replacement = rtxMemAllocType (pctxt, 
            utran_ExplicitTFCS_Configuration_r12_replacement);

         if (pvalue->u.replacement == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_ExplicitTFCS_Configuration_r12_replacement (pvalue->u.replacement);

         stat = asn1PD_utran_ExplicitTFCS_Configuration_r12_replacement (pctxt, pvalue->u.replacement);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TFCS_r12 (OSCTXT* pctxt, utran_TFCS_r12* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "TFCS-r12");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* normalTFCI_Signalling */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "normalTFCI-Signalling");

         pvalue->u.normalTFCI_Signalling = rtxMemAllocType (pctxt, 
            utran_ExplicitTFCS_Configuration_r12);

         if (pvalue->u.normalTFCI_Signalling == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_ExplicitTFCS_Configuration_r12 (pvalue->u.normalTFCI_Signalling);

         stat = asn1PD_utran_ExplicitTFCS_Configuration_r12 (pctxt, pvalue->u.normalTFCI_Signalling);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CommonTransChInfo_r12_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_UL_CommonTransChInfo_r12_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ul_TFCS */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TFCS");

   stat = asn1PD_utran_TFCS_r12 (pctxt, &pvalue->ul_TFCS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_CommonTransChInfo_r12_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_UL_CommonTransChInfo_r12_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode individualUL_CCTrCH_InfoList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "individualUL-CCTrCH-InfoList");

      pvalue->m.individualUL_CCTrCH_InfoListPresent = 1;

      stat = asn1PD_utran_IndividualUL_CCTrCH_InfoList (pctxt, &pvalue->individualUL_CCTrCH_InfoList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_CommonTransChInfo_r12_modeSpecificInfo (OSCTXT* pctxt, utran_UL_CommonTransChInfo_r12_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_UL_CommonTransChInfo_r12_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_CommonTransChInfo_r12_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_UL_CommonTransChInfo_r12_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_UL_CommonTransChInfo_r12_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_CommonTransChInfo_r12_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_UL_CommonTransChInfo_r12_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_CommonTransChInfo_r12 (OSCTXT* pctxt, utran_UL_CommonTransChInfo_r12* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CommonTransChInfo-r12");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tfc_Subset */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tfc-Subset");

      pvalue->m.tfc_SubsetPresent = 1;

      stat = asn1PD_utran_TFC_Subset (pctxt, &pvalue->tfc_Subset);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode prach_TFCS */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "prach-TFCS");

      pvalue->m.prach_TFCSPresent = 1;

      stat = asn1PD_utran_TFCS (pctxt, &pvalue->prach_TFCS);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

      pvalue->m.modeSpecificInfoPresent = 1;

      stat = asn1PD_utran_UL_CommonTransChInfo_r12_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tfc_SubsetList */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tfc-SubsetList");

      pvalue->m.tfc_SubsetListPresent = 1;

      stat = asn1PD_utran_TFC_SubsetList (pctxt, &pvalue->tfc_SubsetList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_OtherTTIConfiguration_Information_configurationInfo_newConfiguration (OSCTXT* pctxt, utran_UL_OtherTTIConfiguration_Information_configurationInfo_newConfiguration* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_EDCH_Information */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-EDCH-Information");

   stat = asn1PD_utran_UL_EDCH_Information_r11 (pctxt, &pvalue->ul_EDCH_Information);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_AddReconfTransChInfoList */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-AddReconfTransChInfoList");

   stat = asn1PD_utran_UL_AddReconfTransChInfoList_r8 (pctxt, &pvalue->ul_AddReconfTransChInfoList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dtx_drx_TimingInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dtx-drx-TimingInfo");

      pvalue->m.dtx_drx_TimingInfoPresent = 1;

      stat = asn1PD_utran_DTX_DRX_TimingInfo_r7 (pctxt, &pvalue->dtx_drx_TimingInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dtx_drx_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dtx-drx-Info");

      pvalue->m.dtx_drx_InfoPresent = 1;

      stat = asn1PD_utran_DTX_DRX_Info_r12 (pctxt, &pvalue->dtx_drx_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_OtherTTIConfiguration_Information_configurationInfo (OSCTXT* pctxt, utran_UL_OtherTTIConfiguration_Information_configurationInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* continue_ */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "continue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* newConfiguration */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "newConfiguration");

         pvalue->u.newConfiguration = rtxMemAllocType (pctxt, 
            utran_UL_OtherTTIConfiguration_Information_configurationInfo_newConfiguration);

         if (pvalue->u.newConfiguration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_OtherTTIConfiguration_Information_configurationInfo_newConfiguration (pvalue->u.newConfiguration);

         stat = asn1PD_utran_UL_OtherTTIConfiguration_Information_configurationInfo_newConfiguration (pctxt, pvalue->u.newConfiguration);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_ActivationDelay (OSCTXT* pctxt, utran_ActivationDelay* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActivationDelay");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_OtherTTIConfiguration_Information (OSCTXT* pctxt, utran_UL_OtherTTIConfiguration_Information* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-OtherTTIConfiguration-Information");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode configurationInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "configurationInfo");

   stat = asn1PD_utran_UL_OtherTTIConfiguration_Information_configurationInfo (pctxt, &pvalue->configurationInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode activationDelay */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "activationDelay");

      pvalue->m.activationDelayPresent = 1;

      stat = asn1PD_utran_ActivationDelay (pctxt, &pvalue->activationDelay);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_TimeToTrigger (OSCTXT* pctxt, utran_TimeToTrigger* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeToTrigger");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Hysteresis (OSCTXT* pctxt, utran_Hysteresis* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Hysteresis");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UE_PowerHeadroomThreshold (OSCTXT* pctxt, utran_UE_PowerHeadroomThreshold* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-PowerHeadroomThreshold");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-50), OSINTCONST(33));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_FilteredUEPowerHeadroomReportInfo (OSCTXT* pctxt, utran_FilteredUEPowerHeadroomReportInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "FilteredUEPowerHeadroomReportInfo");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode timeToTrigger */
   RTXCTXTPUSHELEMNAME (pctxt, "timeToTrigger");

   stat = asn1PD_utran_TimeToTrigger (pctxt, &pvalue->timeToTrigger);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode hysteresis1 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hysteresis1");

      pvalue->m.hysteresis1Present = 1;

      stat = asn1PD_utran_Hysteresis (pctxt, &pvalue->hysteresis1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode hysteresis2 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hysteresis2");

      pvalue->m.hysteresis2Present = 1;

      stat = asn1PD_utran_Hysteresis (pctxt, &pvalue->hysteresis2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uePowerHeadroomThreshold1 */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uePowerHeadroomThreshold1");

      pvalue->m.uePowerHeadroomThreshold1Present = 1;

      stat = asn1PD_utran_UE_PowerHeadroomThreshold (pctxt, &pvalue->uePowerHeadroomThreshold1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uePowerHeadroomThreshold2 */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uePowerHeadroomThreshold2");

      pvalue->m.uePowerHeadroomThreshold2Present = 1;

      stat = asn1PD_utran_UE_PowerHeadroomThreshold (pctxt, &pvalue->uePowerHeadroomThreshold2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode filterCoefficient */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "filterCoefficient");

      pvalue->m.filterCoefficientPresent = 1;

      stat = asn1PD_utran_FilterCoefficient (pctxt, &pvalue->filterCoefficient);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r12_cfnHandling_maintain (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r12_cfnHandling_maintain* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode timingmaintainedsynchind */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timingmaintainedsynchind");

      pvalue->m.timingmaintainedsynchindPresent = 1;

      stat = asn1PD_utran_TimingMaintainedSynchInd (pctxt, &pvalue->timingmaintainedsynchind);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r12_cfnHandling (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r12_cfnHandling* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* maintain */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "maintain");

         pvalue->u.maintain = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r12_cfnHandling_maintain);

         if (pvalue->u.maintain == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r12_cfnHandling_maintain (pvalue->u.maintain);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r12_cfnHandling_maintain (pctxt, pvalue->u.maintain);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* initialise */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "initialise");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_PilotBits128_r12 (OSCTXT* pctxt, utran_PilotBits128_r12* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PilotBits128-r12");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PilotBits256_r12 (OSCTXT* pctxt, utran_PilotBits256_r12* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PilotBits256-r12");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SF512_AndPilot_r12 (OSCTXT* pctxt, utran_SF512_AndPilot_r12* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "SF512-AndPilot-r12");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* sfd4 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sfd8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd8");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sfd16 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd16");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sfd32 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd32");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sfd64 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd64");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sfd128 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd128");

         stat = asn1PD_utran_PilotBits128_r12 (pctxt, &pvalue->u.sfd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sfd256 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd256");

         stat = asn1PD_utran_PilotBits256_r12 (pctxt, &pvalue->u.sfd256);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sfd512 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "sfd512");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-PowerControlInfo");

      pvalue->m.dl_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode powerOffsetPilot_pdpdch */
   RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetPilot-pdpdch");

   stat = asn1PD_utran_PowerOffsetPilot_pdpdch (pctxt, &pvalue->powerOffsetPilot_pdpdch);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_rate_matching_restriction */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-rate-matching-restriction");

      pvalue->m.dl_rate_matching_restrictionPresent = 1;

      stat = asn1PD_utran_Dl_rate_matching_restriction (pctxt, &pvalue->dl_rate_matching_restriction);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode spreadingFactorAndPilot */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactorAndPilot");

   stat = asn1PD_utran_SF512_AndPilot_r12 (pctxt, &pvalue->spreadingFactorAndPilot);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode positionFixedOrFlexible */
   RTXCTXTPUSHELEMNAME (pctxt, "positionFixedOrFlexible");

   stat = asn1PD_utran_PositionFixedOrFlexible (pctxt, &pvalue->positionFixedOrFlexible);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfci_Existence */
   RTXCTXTPUSHELEMNAME (pctxt, "tfci-Existence");

   stat = DEC_BIT (pctxt, &pvalue->tfci_Existence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-PowerControlInfo");

      pvalue->m.dl_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommon_r12 (OSCTXT* pctxt, utran_DL_DPCH_InfoCommon_r12* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DPCH-InfoCommon-r12");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cfnHandling */
   RTXCTXTPUSHELEMNAME (pctxt, "cfnHandling");

   stat = asn1PD_utran_DL_DPCH_InfoCommon_r12_cfnHandling (pctxt, &pvalue->cfnHandling);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_d_HFN_initial_value */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-d-HFN-initial-value");

      pvalue->m.mac_d_HFN_initial_valuePresent = 1;

      stat = asn1PD_utran_MAC_d_HFN_initial_value (pctxt, &pvalue->mac_d_HFN_initial_value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r12_dl_dpchInfoCommon (OSCTXT* pctxt, utran_DL_CommonInformation_r12_dl_dpchInfoCommon* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_DPCH_InfoCommon */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoCommon");

         pvalue->u.dl_DPCH_InfoCommon = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoCommon_r12);

         if (pvalue->u.dl_DPCH_InfoCommon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoCommon_r12 (pvalue->u.dl_DPCH_InfoCommon);

         stat = asn1PD_utran_DL_DPCH_InfoCommon_r12 (pctxt, pvalue->u.dl_DPCH_InfoCommon);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_FDPCH_InfoCommon */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-FDPCH-InfoCommon");

         pvalue->u.dl_FDPCH_InfoCommon = rtxMemAllocType (pctxt, 
            utran_DL_FDPCH_InfoCommon_r6);

         if (pvalue->u.dl_FDPCH_InfoCommon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_FDPCH_InfoCommon_r6 (pvalue->u.dl_FDPCH_InfoCommon);

         stat = asn1PD_utran_DL_FDPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_FDPCH_InfoCommon);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r12_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_CommonInformation_r12_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueFDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dpch_CompressedModeInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dpch-CompressedModeInfo");

      pvalue->m.dpch_CompressedModeInfoPresent = 1;

      stat = asn1PD_utran_DPCH_CompressedModeInfo_r10 (pctxt, &pvalue->dpch_CompressedModeInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tx_DiversityMode */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tx-DiversityMode");

      pvalue->m.tx_DiversityModePresent = 1;

      stat = asn1PD_utran_TX_DiversityMode (pctxt, &pvalue->tx_DiversityMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r12_modeSpecificInfo_tdd_tddOption_tdd128 (OSCTXT* pctxt, utran_DL_CommonInformation_r12_modeSpecificInfo_tdd_tddOption_tdd128* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tstd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "tstd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->tstd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r12_modeSpecificInfo_tdd_tddOption (OSCTXT* pctxt, utran_DL_CommonInformation_r12_modeSpecificInfo_tdd_tddOption* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd768 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd768");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocTypeZ (pctxt, 
            utran_DL_CommonInformation_r12_modeSpecificInfo_tdd_tddOption_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_CommonInformation_r12_modeSpecificInfo_tdd_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r12_modeSpecificInfo_tdd (OSCTXT* pctxt, utran_DL_CommonInformation_r12_modeSpecificInfo_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tddOption */
   RTXCTXTPUSHELEMNAME (pctxt, "tddOption");

   stat = asn1PD_utran_DL_CommonInformation_r12_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode defaultDPCH_OffsetValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "defaultDPCH-OffsetValue");

      pvalue->m.defaultDPCH_OffsetValuePresent = 1;

      stat = asn1PD_utran_DefaultDPCH_OffsetValueTDD (pctxt, &pvalue->defaultDPCH_OffsetValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r12_modeSpecificInfo (OSCTXT* pctxt, utran_DL_CommonInformation_r12_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r12_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r12_modeSpecificInfo_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_CommonInformation_r12_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_CommonInformation_r12_modeSpecificInfo_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_CommonInformation_r12_modeSpecificInfo_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_CommonInformation_r12_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r12_mac_hsResetIndicator (OSCTXT* pctxt, utran_DL_CommonInformation_r12_mac_hsResetIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__276; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r12_postVerificationPeriod (OSCTXT* pctxt, utran_DL_CommonInformation_r12_postVerificationPeriod* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__277; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting (OSCTXT* pctxt, utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__278; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformation_r12 (OSCTXT* pctxt, utran_DL_CommonInformation_r12* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CommonInformation-r12");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_dpchInfoCommon */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dpchInfoCommon");

      pvalue->m.dl_dpchInfoCommonPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r12_dl_dpchInfoCommon (pctxt, &pvalue->dl_dpchInfoCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_CommonInformation_r12_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_hsResetIndicator */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-hsResetIndicator");

      pvalue->m.mac_hsResetIndicatorPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r12_mac_hsResetIndicator (pctxt, &pvalue->mac_hsResetIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode postVerificationPeriod */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "postVerificationPeriod");

      pvalue->m.postVerificationPeriodPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r12_postVerificationPeriod (pctxt, &pvalue->postVerificationPeriod);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mac_hsResetIndicator_assisting */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-hsResetIndicator-assisting");

      pvalue->m.mac_hsResetIndicator_assistingPresent = 1;

      stat = asn1PD_utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting (pctxt, &pvalue->mac_hsResetIndicator_assisting);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r12_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode primaryCPICH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCPICH-Info");

   stat = asn1PD_utran_PrimaryCPICH_Info (pctxt, &pvalue->primaryCPICH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode servingHSDSCH_RL_indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "servingHSDSCH-RL-indicator");

   stat = DEC_BIT (pctxt, &pvalue->servingHSDSCH_RL_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode servingEDCH_RL_indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "servingEDCH-RL-indicator");

   stat = DEC_BIT (pctxt, &pvalue->servingEDCH_RL_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_r12_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocTypeZ (pctxt, 
            utran_DL_InformationPerRL_r12_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, utran_PrimaryCCPCH_Info_r4);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_PrimaryCCPCH_Info_r4 (pvalue->u.tdd);

         stat = asn1PD_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_r12_fdd (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_r12_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pCPICH_UsageForChannelEst */
   RTXCTXTPUSHELEMNAME (pctxt, "pCPICH-UsageForChannelEst");

   stat = asn1PD_utran_PCPICH_UsageForChannelEst (pctxt, &pvalue->pCPICH_UsageForChannelEst);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dpch_FrameOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "dpch-FrameOffset");

   stat = asn1PD_utran_DPCH_FrameOffset (pctxt, &pvalue->dpch_FrameOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode secondaryCPICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "secondaryCPICH-Info");

      pvalue->m.secondaryCPICH_InfoPresent = 1;

      stat = asn1PD_utran_SecondaryCPICH_Info (pctxt, &pvalue->secondaryCPICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_ChannelisationCodeList */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-ChannelisationCodeList");

   stat = asn1PD_utran_DL_ChannelisationCodeList (pctxt, &pvalue->dl_ChannelisationCodeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tpc_CombinationIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-CombinationIndex");

   stat = asn1PD_utran_TPC_CombinationIndex (pctxt, &pvalue->tpc_CombinationIndex);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerOffsetTPC_pdpdch */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetTPC-pdpdch");

      pvalue->m.powerOffsetTPC_pdpdchPresent = 1;

      stat = asn1PD_utran_PowerOffsetTPC_pdpdch (pctxt, &pvalue->powerOffsetTPC_pdpdch);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode powerOffsetPO_SRB */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "powerOffsetPO-SRB");

      pvalue->m.powerOffsetPO_SRBPresent = 1;

      stat = asn1PD_utran_PowerOffsetPO_SRB (pctxt, &pvalue->powerOffsetPO_SRB);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode closedLoopTimingAdjMode */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "closedLoopTimingAdjMode");

      pvalue->m.closedLoopTimingAdjModePresent = 1;

      stat = asn1PD_utran_ClosedLoopTimingAdjMode (pctxt, &pvalue->closedLoopTimingAdjMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_r12_tdd (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_r12_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_CCTrChListToEstablish */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-CCTrChListToEstablish");

      pvalue->m.dl_CCTrChListToEstablishPresent = 1;

      stat = asn1PD_utran_DL_CCTrChList_r7 (pctxt, &pvalue->dl_CCTrChListToEstablish);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_CCTrChListToRemove */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-CCTrChListToRemove");

      pvalue->m.dl_CCTrChListToRemovePresent = 1;

      stat = asn1PD_utran_DL_CCTrChListToRemove (pctxt, &pvalue->dl_CCTrChListToRemove);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_r12 (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_r12* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DPCH-InfoPerRL-r12");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoPerRL_r12_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoPerRL_r12_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_DPCH_InfoPerRL_r12_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoPerRL_r12_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoPerRL_r12_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_DPCH_InfoPerRL_r12_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r12_dl_dpchInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_r12_dl_dpchInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_DPCH_InfoPerRL */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoPerRL");

         pvalue->u.dl_DPCH_InfoPerRL = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoPerRL_r12);

         if (pvalue->u.dl_DPCH_InfoPerRL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoPerRL_r12 (pvalue->u.dl_DPCH_InfoPerRL);

         stat = asn1PD_utran_DL_DPCH_InfoPerRL_r12 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_FDPCH_InfoPerRL */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-FDPCH-InfoPerRL");

         pvalue->u.dl_FDPCH_InfoPerRL = rtxMemAllocType (pctxt, 
            utran_DL_FDPCH_InfoPerRL_r7);

         if (pvalue->u.dl_FDPCH_InfoPerRL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_FDPCH_InfoPerRL_r7 (pvalue->u.dl_FDPCH_InfoPerRL);

         stat = asn1PD_utran_DL_FDPCH_InfoPerRL_r7 (pctxt, pvalue->u.dl_FDPCH_InfoPerRL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* radioLinkswithoutDPCHFDPCHInfo */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "radioLinkswithoutDPCHFDPCHInfo");

         pvalue->u.radioLinkswithoutDPCHFDPCHInfo = rtxMemAllocTypeZ (pctxt, 
            utran_RadioLinkswithoutDPCHFDPCHInfo);

         if (pvalue->u.radioLinkswithoutDPCHFDPCHInfo == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_RadioLinkswithoutDPCHFDPCHInfo (pctxt, pvalue->u.radioLinkswithoutDPCHFDPCHInfo);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_HICH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* e_HICH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Information");

         pvalue->u.e_HICH_Information = rtxMemAllocType (pctxt, 
            utran_E_HICH_Information_r11);

         if (pvalue->u.e_HICH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_HICH_Information_r11 (pvalue->u.e_HICH_Information);

         stat = asn1PD_utran_E_HICH_Information_r11 (pctxt, pvalue->u.e_HICH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* secondaryReleaseIndicator */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "secondaryReleaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_RGCH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* e_RGCH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "e-RGCH-Information");

         pvalue->u.e_RGCH_Information = rtxMemAllocTypeZ (pctxt, 
            utran_E_RGCH_Information);

         if (pvalue->u.e_RGCH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_E_RGCH_Information (pctxt, pvalue->u.e_RGCH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_f_TPICH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_f_TPICH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* f_TPICH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "f-TPICH-Information");

         pvalue->u.f_TPICH_Information = rtxMemAllocTypeZ (pctxt, 
            utran_F_TPICH_Information);

         if (pvalue->u.f_TPICH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_F_TPICH_Information (pctxt, pvalue->u.f_TPICH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_RGCH_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RGCH-Info");

      pvalue->m.e_RGCH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode f_TPICH_Info */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "f-TPICH-Info");

      pvalue->m.f_TPICH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_f_TPICH_Info (pctxt, &pvalue->f_TPICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd384_tdd768 (OSCTXT* pctxt, utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd384_tdd768* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_E_HICH_Information_TDD384_768 (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd128 (OSCTXT* pctxt, utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_E_HICH_Information_TDD128 (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384_tdd768 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384-tdd768");

         pvalue->u.tdd384_tdd768 = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd384_tdd768);

         if (pvalue->u.tdd384_tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd384_tdd768 (pvalue->u.tdd384_tdd768);

         stat = asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd384_tdd768 (pctxt, pvalue->u.tdd384_tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2 (OSCTXT* pctxt, utran_DL_InformationPerRL_r12_modeSpecificInfo2* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r12 (OSCTXT* pctxt, utran_DL_InformationPerRL_r12* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-r12");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_dpchInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dpchInfo");

      pvalue->m.dl_dpchInfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r12_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_AGCH_Information */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-Information");

      pvalue->m.e_AGCH_InformationPresent = 1;

      stat = asn1PD_utran_E_AGCH_Information_r8 (pctxt, &pvalue->e_AGCH_Information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_ROCH_Information */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-ROCH-Information");

      pvalue->m.e_ROCH_InformationPresent = 1;

      stat = asn1PD_utran_E_ROCH_Information (pctxt, &pvalue->e_ROCH_Information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo2 */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo2");

   stat = asn1PD_utran_DL_InformationPerRL_r12_modeSpecificInfo2 (pctxt, &pvalue->modeSpecificInfo2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cell_id */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cell-id");

      pvalue->m.cell_idPresent = 1;

      stat = asn1PD_utran_CellIdentity (pctxt, &pvalue->cell_id);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_List_r12 (OSCTXT* pctxt, utran_DL_InformationPerRL_List_r12* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-List-r12");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_InformationPerRL_r12* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-InformationPerRL-r12", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_InformationPerRL_r12, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_InformationPerRL_r12 (pdata);

      stat = asn1PD_utran_DL_InformationPerRL_r12 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Non_rectResAllocInd_TDD128 (OSCTXT* pctxt, utran_Non_rectResAllocInd_TDD128* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "Non-rectResAllocInd-TDD128");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__294; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_Non_rectResSpecTSset_TDD128 (OSCTXT* pctxt, utran_Non_rectResSpecTSset_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Non-rectResSpecTSset-TDD128");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(7), OSUINTCONST(7), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(7), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_T_330 (OSCTXT* pctxt, utran_T_330* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "T-330");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_WLANThreshServingRSCP (OSCTXT* pctxt, utran_WLANThreshServingRSCP* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "WLANThreshServingRSCP");

   /* decode root elements */
   /* decode threshServingLow */
   RTXCTXTPUSHELEMNAME (pctxt, "threshServingLow");

   stat = pd_ConsInt8 (pctxt, &pvalue->threshServingLow, OSINTCONST(-60), OSINTCONST(-13));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshServingHigh */
   RTXCTXTPUSHELEMNAME (pctxt, "threshServingHigh");

   stat = pd_ConsInt8 (pctxt, &pvalue->threshServingHigh, OSINTCONST(-60), OSINTCONST(-13));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_WLANThreshServingECNO (OSCTXT* pctxt, utran_WLANThreshServingECNO* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "WLANThreshServingECNO");

   /* decode root elements */
   /* decode threshServingLow2 */
   RTXCTXTPUSHELEMNAME (pctxt, "threshServingLow2");

   stat = pd_ConsInt8 (pctxt, &pvalue->threshServingLow2, OSINTCONST(-24), OSINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshServingHigh2 */
   RTXCTXTPUSHELEMNAME (pctxt, "threshServingHigh2");

   stat = pd_ConsInt8 (pctxt, &pvalue->threshServingHigh2, OSINTCONST(-24), OSINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_WLANThreshChannelUtilization (OSCTXT* pctxt, utran_WLANThreshChannelUtilization* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "WLANThreshChannelUtilization");

   /* decode root elements */
   /* decode threshChannelUtilizationLow */
   RTXCTXTPUSHELEMNAME (pctxt, "threshChannelUtilizationLow");

   stat = pd_ConsUInt8 (pctxt, &pvalue->threshChannelUtilizationLow, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshChannelUtilizationHigh */
   RTXCTXTPUSHELEMNAME (pctxt, "threshChannelUtilizationHigh");

   stat = pd_ConsUInt8 (pctxt, &pvalue->threshChannelUtilizationHigh, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_WLANThreshBackhaulRate (OSCTXT* pctxt, utran_WLANThreshBackhaulRate* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "WLANThreshBackhaulRate");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(31));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_WLANThreshBackhaulBandwidth (OSCTXT* pctxt, utran_WLANThreshBackhaulBandwidth* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "WLANThreshBackhaulBandwidth");

   /* decode root elements */
   /* decode threshBackhaulDLBandwidthLow */
   RTXCTXTPUSHELEMNAME (pctxt, "threshBackhaulDLBandwidthLow");

   stat = asn1PD_utran_WLANThreshBackhaulRate (pctxt, &pvalue->threshBackhaulDLBandwidthLow);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshBackhaulDLBandwidthHigh */
   RTXCTXTPUSHELEMNAME (pctxt, "threshBackhaulDLBandwidthHigh");

   stat = asn1PD_utran_WLANThreshBackhaulRate (pctxt, &pvalue->threshBackhaulDLBandwidthHigh);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshBackhaulULBandwidthLow */
   RTXCTXTPUSHELEMNAME (pctxt, "threshBackhaulULBandwidthLow");

   stat = asn1PD_utran_WLANThreshBackhaulRate (pctxt, &pvalue->threshBackhaulULBandwidthLow);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshBackhaulULBandwidthHigh */
   RTXCTXTPUSHELEMNAME (pctxt, "threshBackhaulULBandwidthHigh");

   stat = asn1PD_utran_WLANThreshBackhaulRate (pctxt, &pvalue->threshBackhaulULBandwidthHigh);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_WLANThreshBeaconRSSI (OSCTXT* pctxt, utran_WLANThreshBeaconRSSI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "WLANThreshBeaconRSSI");

   /* decode root elements */
   /* decode threshBeaconRSSILow */
   RTXCTXTPUSHELEMNAME (pctxt, "threshBeaconRSSILow");

   stat = pd_ConsUInt8 (pctxt, &pvalue->threshBeaconRSSILow, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshBeaconRSSIHigh */
   RTXCTXTPUSHELEMNAME (pctxt, "threshBeaconRSSIHigh");

   stat = pd_ConsUInt8 (pctxt, &pvalue->threshBeaconRSSIHigh, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_T_Reselection_S (OSCTXT* pctxt, utran_T_Reselection_S* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "T-Reselection-S");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(31));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_WLANOffloadConfig (OSCTXT* pctxt, utran_WLANOffloadConfig* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[7];

   RTXCTXTPUSHTYPENAME (pctxt, "WLANOffloadConfig");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode threshServingRSCP */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "threshServingRSCP");

      pvalue->m.threshServingRSCPPresent = 1;

      stat = asn1PD_utran_WLANThreshServingRSCP (pctxt, &pvalue->threshServingRSCP);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode threshServingECNO */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "threshServingECNO");

      pvalue->m.threshServingECNOPresent = 1;

      stat = asn1PD_utran_WLANThreshServingECNO (pctxt, &pvalue->threshServingECNO);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode threshChannelUtilization */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "threshChannelUtilization");

      pvalue->m.threshChannelUtilizationPresent = 1;

      stat = asn1PD_utran_WLANThreshChannelUtilization (pctxt, &pvalue->threshChannelUtilization);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode threshBackhaulBandwidth */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "threshBackhaulBandwidth");

      pvalue->m.threshBackhaulBandwidthPresent = 1;

      stat = asn1PD_utran_WLANThreshBackhaulBandwidth (pctxt, &pvalue->threshBackhaulBandwidth);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode threshBeaconRSSI */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "threshBeaconRSSI");

      pvalue->m.threshBeaconRSSIPresent = 1;

      stat = asn1PD_utran_WLANThreshBeaconRSSI (pctxt, &pvalue->threshBeaconRSSI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode offloadPreferenceIndicator */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "offloadPreferenceIndicator");

      pvalue->m.offloadPreferenceIndicatorPresent = 1;

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

      stat = pd_BitString32 (pctxt, &pvalue->offloadPreferenceIndicator
         , OSUINTCONST(16), OSUINTCONST(16));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode t_SteeringWLAN */
   if (optbits[6]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-SteeringWLAN");

      pvalue->m.t_SteeringWLANPresent = 1;

      stat = asn1PD_utran_T_Reselection_S (pctxt, &pvalue->t_SteeringWLAN);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_WLANIdentifier_ssid (OSCTXT* pctxt, utran_WLANIdentifier_ssid* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_WLANIdentifier_bssid (OSCTXT* pctxt, utran_WLANIdentifier_bssid* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_WLANIdentifier_hessid (OSCTXT* pctxt, utran_WLANIdentifier_hessid* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_WLANIdentifier (OSCTXT* pctxt, utran_WLANIdentifier* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "WLANIdentifier");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ssid */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ssid");

      pvalue->m.ssidPresent = 1;

      stat = asn1PD_utran_WLANIdentifier_ssid (pctxt, &pvalue->ssid);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode bssid */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "bssid");

      pvalue->m.bssidPresent = 1;

      stat = asn1PD_utran_WLANIdentifier_bssid (pctxt, &pvalue->bssid);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode hessid */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hessid");

      pvalue->m.hessidPresent = 1;

      stat = asn1PD_utran_WLANIdentifier_hessid (pctxt, &pvalue->hessid);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_WLANIdentifierList (OSCTXT* pctxt, utran_WLANIdentifierList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "WLANIdentifierList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_WLANIdentifier* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "WLANIdentifier", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_WLANIdentifier, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_WLANIdentifier (pdata);

      stat = asn1PD_utran_WLANIdentifier (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_WLANOffloadInformation (OSCTXT* pctxt, utran_WLANOffloadInformation* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "WLANOffloadInformation");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode wlanOffloadConfig */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "wlanOffloadConfig");

      pvalue->m.wlanOffloadConfigPresent = 1;

      stat = asn1PD_utran_WLANOffloadConfig (pctxt, &pvalue->wlanOffloadConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode wlanIdentifierList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "wlanIdentifierList");

      pvalue->m.wlanIdentifierListPresent = 1;

      stat = asn1PD_utran_WLANIdentifierList (pctxt, &pvalue->wlanIdentifierList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DedicatedWLANOffloadInformation_configurationInfo_newConfiguration (OSCTXT* pctxt, utran_DedicatedWLANOffloadInformation_configurationInfo_newConfiguration* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode t_330 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-330");

      pvalue->m.t_330Present = 1;

      stat = asn1PD_utran_T_330 (pctxt, &pvalue->t_330);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode wlanOffloadInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "wlanOffloadInformation");

   stat = asn1PD_utran_WLANOffloadInformation (pctxt, &pvalue->wlanOffloadInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DedicatedWLANOffloadInformation_configurationInfo (OSCTXT* pctxt, utran_DedicatedWLANOffloadInformation_configurationInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* continue_ */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "continue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* newConfiguration */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "newConfiguration");

         pvalue->u.newConfiguration = rtxMemAllocType (pctxt, 
            utran_DedicatedWLANOffloadInformation_configurationInfo_newConfiguration);

         if (pvalue->u.newConfiguration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DedicatedWLANOffloadInformation_configurationInfo_newConfiguration (pvalue->u.newConfiguration);

         stat = asn1PD_utran_DedicatedWLANOffloadInformation_configurationInfo_newConfiguration (pctxt, pvalue->u.newConfiguration);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DedicatedWLANOffloadInformation (OSCTXT* pctxt, utran_DedicatedWLANOffloadInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DedicatedWLANOffloadInformation");

   /* decode root elements */
   /* decode configurationInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "configurationInfo");

   stat = asn1PD_utran_DedicatedWLANOffloadInformation_configurationInfo (pctxt, &pvalue->configurationInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RLC_InfoChoice_r11 (OSCTXT* pctxt, utran_RLC_InfoChoice_r11* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "RLC-InfoChoice-r11");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rlc_Info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rlc-Info");

         pvalue->u.rlc_Info = rtxMemAllocType (pctxt, utran_RLC_Info_r11);

         if (pvalue->u.rlc_Info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_RLC_Info_r11 (pvalue->u.rlc_Info);

         stat = asn1PD_utran_RLC_Info_r11 (pctxt, pvalue->u.rlc_Info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* same_as_RB */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "same-as-RB");

         stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->u.same_as_RB);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationSetup_r11 (OSCTXT* pctxt, utran_RB_InformationSetup_r11* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationSetup-r11");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdcp_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Info");

      pvalue->m.pdcp_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_Info_r4 (pctxt, &pvalue->pdcp_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_InfoChoice */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-InfoChoice");

   stat = asn1PD_utran_RLC_InfoChoice_r11 (pctxt, &pvalue->rlc_InfoChoice);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_MappingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

   stat = asn1PD_utran_RB_MappingInfo_r8 (pctxt, &pvalue->rb_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationSetupList_r11 (OSCTXT* pctxt, utran_RB_InformationSetupList_r11* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationSetupList-r11");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationSetup_r11* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationSetup-r11", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationSetup_r11, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationSetup_r11 (pdata);

      stat = asn1PD_utran_RB_InformationSetup_r11 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_InformationSetup_r11 (OSCTXT* pctxt, utran_RAB_InformationSetup_r11* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-InformationSetup-r11");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rab_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "rab-Info");

   stat = asn1PD_utran_RAB_Info_r7 (pctxt, &pvalue->rab_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cs_HSPA_Information */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cs-HSPA-Information");

      pvalue->m.cs_HSPA_InformationPresent = 1;

      stat = asn1PD_utran_CS_HSPA_Information (pctxt, &pvalue->cs_HSPA_Information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rab_InfoReplace */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rab-InfoReplace");

      pvalue->m.rab_InfoReplacePresent = 1;

      stat = asn1PD_utran_RAB_InfoReplace (pctxt, &pvalue->rab_InfoReplace);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_InformationSetupList */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-InformationSetupList");

   stat = asn1PD_utran_RB_InformationSetupList_r11 (pctxt, &pvalue->rb_InformationSetupList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RetrievableConfigIdentity (OSCTXT* pctxt, utran_RetrievableConfigIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RetrievableConfigIdentity");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RetrievableConfigListToRemove (OSCTXT* pctxt, utran_RetrievableConfigListToRemove* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RetrievableConfigListToRemove");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 8) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RetrievableConfigIdentity", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_RetrievableConfigIdentity));
      stat = asn1PD_utran_RetrievableConfigIdentity (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SRB_InformationSetup_r11 (OSCTXT* pctxt, utran_SRB_InformationSetup_r11* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-InformationSetup-r11");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

      pvalue->m.rb_IdentityPresent = 1;

      stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_InfoChoice */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-InfoChoice");

   stat = asn1PD_utran_RLC_InfoChoice_r11 (pctxt, &pvalue->rlc_InfoChoice);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_MappingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

   stat = asn1PD_utran_RB_MappingInfo_r8 (pctxt, &pvalue->rb_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SRB_InformationSetupList_r11 (OSCTXT* pctxt, utran_SRB_InformationSetupList_r11* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-InformationSetupList-r11");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_SRB_InformationSetup_r11* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SRB-InformationSetup-r11", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_SRB_InformationSetup_r11, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_SRB_InformationSetup_r11 (pdata);

      stat = asn1PD_utran_SRB_InformationSetup_r11 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_InformationSetupList_r11 (OSCTXT* pctxt, utran_RAB_InformationSetupList_r11* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-InformationSetupList-r11");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RAB_InformationSetup_r11* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAB-InformationSetup-r11", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RAB_InformationSetup_r11, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RAB_InformationSetup_r11 (pdata);

      stat = asn1PD_utran_RAB_InformationSetup_r11 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HARQ_Info_r13_numberOfProcesses (OSCTXT* pctxt, utran_HARQ_Info_r13_numberOfProcesses* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(13));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_HARQ_Info_r13_memoryPartitioning_explicit__memorySize (OSCTXT* pctxt, utran_HARQ_Info_r13_memoryPartitioning_explicit__memorySize* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 8) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "HARQMemorySize", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_HARQMemorySize));
      stat = asn1PD_utran_HARQMemorySize (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesForMIMO (OSCTXT* pctxt, utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesForMIMO* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 8) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "HARQMemorySize", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_HARQMemorySize));
      stat = asn1PD_utran_HARQMemorySize (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesThirdMIMOStream (OSCTXT* pctxt, utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesThirdMIMOStream* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 8) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "HARQMemorySize", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_HARQMemorySize));
      stat = asn1PD_utran_HARQMemorySize (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesFourthMIMOStream (OSCTXT* pctxt, utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesFourthMIMOStream* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 8) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "HARQMemorySize", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_HARQMemorySize));
      stat = asn1PD_utran_HARQMemorySize (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HARQ_Info_r13_memoryPartitioning_explicit_ (OSCTXT* pctxt, utran_HARQ_Info_r13_memoryPartitioning_explicit_* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode memorySize */
   RTXCTXTPUSHELEMNAME (pctxt, "memorySize");

   stat = asn1PD_utran_HARQ_Info_r13_memoryPartitioning_explicit__memorySize (pctxt, &pvalue->memorySize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode additionalMemorySizesForMIMO */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalMemorySizesForMIMO");

      pvalue->m.additionalMemorySizesForMIMOPresent = 1;

      stat = asn1PD_utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesForMIMO (pctxt, &pvalue->additionalMemorySizesForMIMO);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode additionalMemorySizesThirdMIMOStream */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalMemorySizesThirdMIMOStream");

      pvalue->m.additionalMemorySizesThirdMIMOStreamPresent = 1;

      stat = asn1PD_utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesThirdMIMOStream (pctxt, &pvalue->additionalMemorySizesThirdMIMOStream);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode additionalMemorySizesFourthMIMOStream */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalMemorySizesFourthMIMOStream");

      pvalue->m.additionalMemorySizesFourthMIMOStreamPresent = 1;

      stat = asn1PD_utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesFourthMIMOStream (pctxt, &pvalue->additionalMemorySizesFourthMIMOStream);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HARQ_Info_r13_memoryPartitioning (OSCTXT* pctxt, utran_HARQ_Info_r13_memoryPartitioning* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* implicit */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "implicit");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* explicit_ */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "explicit");

         pvalue->u.explicit_ = rtxMemAllocType (pctxt, 
            utran_HARQ_Info_r13_memoryPartitioning_explicit_);

         if (pvalue->u.explicit_ == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_HARQ_Info_r13_memoryPartitioning_explicit_ (pvalue->u.explicit_);

         stat = asn1PD_utran_HARQ_Info_r13_memoryPartitioning_explicit_ (pctxt, pvalue->u.explicit_);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA (OSCTXT* pctxt, utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = utran_true__262; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HARQ_Info_r13 (OSCTXT* pctxt, utran_HARQ_Info_r13* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "HARQ-Info-r13");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode numberOfProcesses */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfProcesses");

   stat = asn1PD_utran_HARQ_Info_r13_numberOfProcesses (pctxt, &pvalue->numberOfProcesses);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode memoryPartitioning */
   RTXCTXTPUSHELEMNAME (pctxt, "memoryPartitioning");

   stat = asn1PD_utran_HARQ_Info_r13_memoryPartitioning (pctxt, &pvalue->memoryPartitioning);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode blindHARQRetransmissionsForHSDPA */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "blindHARQRetransmissionsForHSDPA");

      pvalue->m.blindHARQRetransmissionsForHSDPAPresent = 1;

      stat = asn1PD_utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA (pctxt, &pvalue->blindHARQRetransmissionsForHSDPA);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_HSDSCH_Info_r13_dl_MAC_HeaderType (OSCTXT* pctxt, utran_HSDSCH_Info_r13_dl_MAC_HeaderType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* mac_hs */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "mac-hs");

         pvalue->u.mac_hs = rtxMemAllocType (pctxt, 
            utran_AddOrReconfMAC_dFlow);

         if (pvalue->u.mac_hs == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_AddOrReconfMAC_dFlow (pvalue->u.mac_hs);

         stat = asn1PD_utran_AddOrReconfMAC_dFlow (pctxt, pvalue->u.mac_hs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* mac_ehs */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "mac-ehs");

         pvalue->u.mac_ehs = rtxMemAllocType (pctxt, 
            utran_AddOrReconfMAC_ehs_ReordQ_r11);

         if (pvalue->u.mac_ehs == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_AddOrReconfMAC_ehs_ReordQ_r11 (pvalue->u.mac_ehs);

         stat = asn1PD_utran_AddOrReconfMAC_ehs_ReordQ_r11 (pctxt, pvalue->u.mac_ehs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_HSDSCH_Info_r13 (OSCTXT* pctxt, utran_HSDSCH_Info_r13* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "HSDSCH-Info-r13");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode harqInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "harqInfo");

      pvalue->m.harqInfoPresent = 1;

      stat = asn1PD_utran_HARQ_Info_r13 (pctxt, &pvalue->harqInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_MAC_HeaderType */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-MAC-HeaderType");

      pvalue->m.dl_MAC_HeaderTypePresent = 1;

      stat = asn1PD_utran_HSDSCH_Info_r13_dl_MAC_HeaderType (pctxt, &pvalue->dl_MAC_HeaderType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation_r13_tfs_SignallingMode (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation_r13_tfs_SignallingMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* explicit_config */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "explicit-config");

         pvalue->u.explicit_config = rtxMemAllocType (pctxt, 
            utran_TransportFormatSet);

         if (pvalue->u.explicit_config == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_TransportFormatSet (pvalue->u.explicit_config);

         stat = asn1PD_utran_TransportFormatSet (pctxt, pvalue->u.explicit_config);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sameAsULTrCH */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sameAsULTrCH");

         pvalue->u.sameAsULTrCH = rtxMemAllocTypeZ (pctxt, 
            utran_UL_TransportChannelIdentity);

         if (pvalue->u.sameAsULTrCH == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_UL_TransportChannelIdentity (pctxt, pvalue->u.sameAsULTrCH);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* hsdsch */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "hsdsch");

         pvalue->u.hsdsch = rtxMemAllocType (pctxt, utran_HSDSCH_Info_r13);

         if (pvalue->u.hsdsch == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_HSDSCH_Info_r13 (pvalue->u.hsdsch);

         stat = asn1PD_utran_HSDSCH_Info_r13 (pctxt, pvalue->u.hsdsch);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInformation_r13 (OSCTXT* pctxt, utran_DL_AddReconfTransChInformation_r13* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInformation-r13");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_TransportChannelType */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-TransportChannelType");

   stat = asn1PD_utran_DL_TrCH_TypeId1_r5 (pctxt, &pvalue->dl_TransportChannelType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tfs_SignallingMode */
   RTXCTXTPUSHELEMNAME (pctxt, "tfs-SignallingMode");

   stat = asn1PD_utran_DL_AddReconfTransChInformation_r13_tfs_SignallingMode (pctxt, &pvalue->tfs_SignallingMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dch_QualityTarget */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dch-QualityTarget");

      pvalue->m.dch_QualityTargetPresent = 1;

      stat = asn1PD_utran_QualityTarget (pctxt, &pvalue->dch_QualityTarget);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_AddReconfTransChInfoList_r13 (OSCTXT* pctxt, utran_DL_AddReconfTransChInfoList_r13* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AddReconfTransChInfoList-r13");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_AddReconfTransChInformation_r13* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-AddReconfTransChInformation-r13", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_AddReconfTransChInformation_r13, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_AddReconfTransChInformation_r13 (pdata);

      stat = asn1PD_utran_DL_AddReconfTransChInformation_r13 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RetrievableConfigData (OSCTXT* pctxt, utran_RetrievableConfigData* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[17];

   RTXCTXTPUSHTYPENAME (pctxt, "RetrievableConfigData");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 17; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode srb_InformationSetupList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "srb-InformationSetupList");

      pvalue->m.srb_InformationSetupListPresent = 1;

      stat = asn1PD_utran_SRB_InformationSetupList_r11 (pctxt, &pvalue->srb_InformationSetupList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rab_InformationSetupList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rab-InformationSetupList");

      pvalue->m.rab_InformationSetupListPresent = 1;

      stat = asn1PD_utran_RAB_InformationSetupList_r11 (pctxt, &pvalue->rab_InformationSetupList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rb_InformationReconfigList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-InformationReconfigList");

      pvalue->m.rb_InformationReconfigListPresent = 1;

      stat = asn1PD_utran_RB_InformationReconfigList_r11 (pctxt, &pvalue->rb_InformationReconfigList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CommonTransChInfo */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CommonTransChInfo");

      pvalue->m.ul_CommonTransChInfoPresent = 1;

      stat = asn1PD_utran_UL_CommonTransChInfo_r12 (pctxt, &pvalue->ul_CommonTransChInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_TransChInfoList */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TransChInfoList");

      pvalue->m.ul_TransChInfoListPresent = 1;

      stat = asn1PD_utran_UL_AddReconfTransChInfoList_r8 (pctxt, &pvalue->ul_TransChInfoList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_CommonTransChInfo */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-CommonTransChInfo");

      pvalue->m.dl_CommonTransChInfoPresent = 1;

      stat = asn1PD_utran_DL_CommonTransChInfo_r4 (pctxt, &pvalue->dl_CommonTransChInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_TransChInfoList */
   if (optbits[6]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-TransChInfoList");

      pvalue->m.dl_TransChInfoListPresent = 1;

      stat = asn1PD_utran_DL_AddReconfTransChInfoList_r13 (pctxt, &pvalue->dl_TransChInfoList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dtx_drx_Info */
   if (optbits[7]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dtx-drx-Info");

      pvalue->m.dtx_drx_InfoPresent = 1;

      stat = asn1PD_utran_DTX_DRX_Info_r12 (pctxt, &pvalue->dtx_drx_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode hs_scch_LessInfo */
   if (optbits[8]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hs-scch-LessInfo");

      pvalue->m.hs_scch_LessInfoPresent = 1;

      stat = asn1PD_utran_HS_SCCH_LessInfo_r7 (pctxt, &pvalue->hs_scch_LessInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mimoParameters */
   if (optbits[9]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mimoParameters");

      pvalue->m.mimoParametersPresent = 1;

      stat = asn1PD_utran_MIMO_Parameters_r9 (pctxt, &pvalue->mimoParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mimo4x4Parameters */
   if (optbits[10]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mimo4x4Parameters");

      pvalue->m.mimo4x4ParametersPresent = 1;

      stat = asn1PD_utran_MIMO4x4_Parameters (pctxt, &pvalue->mimo4x4Parameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dch_Enhancements_Info_FDD */
   if (optbits[11]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dch-Enhancements-Info-FDD");

      pvalue->m.dch_Enhancements_Info_FDDPresent = 1;

      stat = asn1PD_utran_DCH_Enhancements_Info_FDD (pctxt, &pvalue->dch_Enhancements_Info_FDD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_EDCH_Information */
   if (optbits[12]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-EDCH-Information");

      pvalue->m.ul_EDCH_InformationPresent = 1;

      stat = asn1PD_utran_UL_EDCH_Information_r11 (pctxt, &pvalue->ul_EDCH_Information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_HSPDSCH_Information */
   if (optbits[13]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-HSPDSCH-Information");

      pvalue->m.dl_HSPDSCH_InformationPresent = 1;

      stat = asn1PD_utran_DL_HSPDSCH_Information_r12 (pctxt, &pvalue->dl_HSPDSCH_Information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_SecondaryCellInfoFDD */
   if (optbits[14]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-SecondaryCellInfoFDD");

      pvalue->m.dl_SecondaryCellInfoFDDPresent = 1;

      stat = asn1PD_utran_DL_SecondaryCellInfoFDD_r11 (pctxt, &pvalue->dl_SecondaryCellInfoFDD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode additionalDLSecCellInfoListFDD */
   if (optbits[15]) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalDLSecCellInfoListFDD");

      pvalue->m.additionalDLSecCellInfoListFDDPresent = 1;

      stat = asn1PD_utran_AdditionalDLSecCellInfoListFDD_r11 (pctxt, &pvalue->additionalDLSecCellInfoListFDD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode additionalDLSecCellInfoListFDD2 */
   if (optbits[16]) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalDLSecCellInfoListFDD2");

      pvalue->m.additionalDLSecCellInfoListFDD2Present = 1;

      stat = asn1PD_utran_AdditionalDLSecCellInfoListFDD2 (pctxt, &pvalue->additionalDLSecCellInfoListFDD2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RetrievableConfig (OSCTXT* pctxt, utran_RetrievableConfig* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RetrievableConfig");

   /* decode root elements */
   /* decode retrievableConfigIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "retrievableConfigIdentity");

   stat = asn1PD_utran_RetrievableConfigIdentity (pctxt, &pvalue->retrievableConfigIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode retrievableConfigData */
   RTXCTXTPUSHELEMNAME (pctxt, "retrievableConfigData");

   stat = asn1PD_utran_RetrievableConfigData (pctxt, &pvalue->retrievableConfigData);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RetrievableConfig_List (OSCTXT* pctxt, utran_RetrievableConfig_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RetrievableConfig-List");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RetrievableConfig* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RetrievableConfig", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RetrievableConfig, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RetrievableConfig (pdata);

      stat = asn1PD_utran_RetrievableConfig (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RetrievableConfigInfo (OSCTXT* pctxt, utran_RetrievableConfigInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "RetrievableConfigInfo");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode retrievableConfigToBeInvoked */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "retrievableConfigToBeInvoked");

      pvalue->m.retrievableConfigToBeInvokedPresent = 1;

      stat = asn1PD_utran_RetrievableConfigIdentity (pctxt, &pvalue->retrievableConfigToBeInvoked);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode retrievableConfigToBeStored */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "retrievableConfigToBeStored");

      pvalue->m.retrievableConfigToBeStoredPresent = 1;

      stat = asn1PD_utran_RetrievableConfigIdentity (pctxt, &pvalue->retrievableConfigToBeStored);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode retrievableConfigToBeRemoved */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "retrievableConfigToBeRemoved");

      pvalue->m.retrievableConfigToBeRemovedPresent = 1;

      stat = asn1PD_utran_RetrievableConfigListToRemove (pctxt, &pvalue->retrievableConfigToBeRemoved);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode preconfiguredRetrievableConfig */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "preconfiguredRetrievableConfig");

      pvalue->m.preconfiguredRetrievableConfigPresent = 1;

      stat = asn1PD_utran_RetrievableConfig_List (pctxt, &pvalue->preconfiguredRetrievableConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_OtherStateConfigIdentity (OSCTXT* pctxt, utran_OtherStateConfigIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OtherStateConfigIdentity");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_OtherStateConfigData_rntis_new_ (OSCTXT* pctxt, utran_OtherStateConfigData_rntis_new_* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode new_C_RNTI */
   RTXCTXTPUSHELEMNAME (pctxt, "new-C-RNTI");

   stat = asn1PD_utran_C_RNTI (pctxt, &pvalue->new_C_RNTI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode new_H_RNTI */
   RTXCTXTPUSHELEMNAME (pctxt, "new-H-RNTI");

   stat = asn1PD_utran_H_RNTI (pctxt, &pvalue->new_H_RNTI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode newPrimary_E_RNTI */
   RTXCTXTPUSHELEMNAME (pctxt, "newPrimary-E-RNTI");

   stat = asn1PD_utran_E_RNTI (pctxt, &pvalue->newPrimary_E_RNTI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_OtherStateConfigData_rntis (OSCTXT* pctxt, utran_OtherStateConfigData_rntis* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* clear */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "clear");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* continue_ */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "continue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* new_ */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "new");

         pvalue->u.new_ = rtxMemAllocType (pctxt, 
            utran_OtherStateConfigData_rntis_new_);

         if (pvalue->u.new_ == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_OtherStateConfigData_rntis_new_ (pvalue->u.new_);

         stat = asn1PD_utran_OtherStateConfigData_rntis_new_ (pctxt, pvalue->u.new_);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_OtherStateConfigData_configuration (OSCTXT* pctxt, utran_OtherStateConfigData_configuration* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* id */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "id");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.id, OSUINTCONST(0), OSUINTCONST(7));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* full */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "full");

         pvalue->u.full = rtxMemAllocType (pctxt, 
            utran_RetrievableConfigData);

         if (pvalue->u.full == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_RetrievableConfigData (pvalue->u.full);

         stat = asn1PD_utran_RetrievableConfigData (pctxt, pvalue->u.full);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_OtherStateConfigData (OSCTXT* pctxt, utran_OtherStateConfigData* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "OtherStateConfigData");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode otherStateConfigIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "otherStateConfigIdentity");

   stat = asn1PD_utran_OtherStateConfigIdentity (pctxt, &pvalue->otherStateConfigIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode source_rrc_StateIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "source-rrc-StateIndicator");

   stat = asn1PD_utran_RRC_StateIndicator (pctxt, &pvalue->source_rrc_StateIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode target_rrc_StateIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "target-rrc-StateIndicator");

   stat = asn1PD_utran_RRC_StateIndicator (pctxt, &pvalue->target_rrc_StateIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ura_Identity */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ura-Identity");

      pvalue->m.ura_IdentityPresent = 1;

      stat = asn1PD_utran_URA_Identity (pctxt, &pvalue->ura_Identity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rntis */
   RTXCTXTPUSHELEMNAME (pctxt, "rntis");

   stat = asn1PD_utran_OtherStateConfigData_rntis (pctxt, &pvalue->rntis);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode configuration */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "configuration");

      pvalue->m.configurationPresent = 1;

      stat = asn1PD_utran_OtherStateConfigData_configuration (pctxt, &pvalue->configuration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_OtherStateConfigList (OSCTXT* pctxt, utran_OtherStateConfigList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OtherStateConfigList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_OtherStateConfigData* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OtherStateConfigData", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_OtherStateConfigData, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_OtherStateConfigData (pdata);

      stat = asn1PD_utran_OtherStateConfigData (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_OtherStateRemoveList (OSCTXT* pctxt, utran_OtherStateRemoveList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OtherStateRemoveList");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 4) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OtherStateConfigIdentity", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (utran_OtherStateConfigIdentity));
      stat = asn1PD_utran_OtherStateConfigIdentity (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_OtherStateConfig (OSCTXT* pctxt, utran_OtherStateConfig* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "OtherStateConfig");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode otherStateConfigList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "otherStateConfigList");

      pvalue->m.otherStateConfigListPresent = 1;

      stat = asn1PD_utran_OtherStateConfigList (pctxt, &pvalue->otherStateConfigList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode otherStateRemoveList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "otherStateRemoveList");

      pvalue->m.otherStateRemoveListPresent = 1;

      stat = asn1PD_utran_OtherStateRemoveList (pctxt, &pvalue->otherStateRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo_fdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r13_modeSpecificInfo_fdd* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode primaryCPICH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCPICH-Info");

   stat = asn1PD_utran_PrimaryCPICH_Info (pctxt, &pvalue->primaryCPICH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode servingHSDSCH_RL_indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "servingHSDSCH-RL-indicator");

   stat = DEC_BIT (pctxt, &pvalue->servingHSDSCH_RL_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode servingEDCH_RL_indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "servingEDCH-RL-indicator");

   stat = DEC_BIT (pctxt, &pvalue->servingEDCH_RL_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_r13_modeSpecificInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocTypeZ (pctxt, 
            utran_DL_InformationPerRL_r13_modeSpecificInfo_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, utran_PrimaryCCPCH_Info_r4);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_PrimaryCCPCH_Info_r4 (pvalue->u.tdd);

         stat = asn1PD_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r13_dl_dpchInfo (OSCTXT* pctxt, utran_DL_InformationPerRL_r13_dl_dpchInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dl_DPCH_InfoPerRL */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoPerRL");

         pvalue->u.dl_DPCH_InfoPerRL = rtxMemAllocType (pctxt, 
            utran_DL_DPCH_InfoPerRL_r12);

         if (pvalue->u.dl_DPCH_InfoPerRL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_DPCH_InfoPerRL_r12 (pvalue->u.dl_DPCH_InfoPerRL);

         stat = asn1PD_utran_DL_DPCH_InfoPerRL_r12 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dl_FDPCH_InfoPerRL */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dl-FDPCH-InfoPerRL");

         pvalue->u.dl_FDPCH_InfoPerRL = rtxMemAllocType (pctxt, 
            utran_DL_FDPCH_InfoPerRL_r13);

         if (pvalue->u.dl_FDPCH_InfoPerRL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_FDPCH_InfoPerRL_r13 (pvalue->u.dl_FDPCH_InfoPerRL);

         stat = asn1PD_utran_DL_FDPCH_InfoPerRL_r13 (pctxt, pvalue->u.dl_FDPCH_InfoPerRL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* radioLinkswithoutDPCHFDPCHInfo */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "radioLinkswithoutDPCHFDPCHInfo");

         pvalue->u.radioLinkswithoutDPCHFDPCHInfo = rtxMemAllocTypeZ (pctxt, 
            utran_RadioLinkswithoutDPCHFDPCHInfo);

         if (pvalue->u.radioLinkswithoutDPCHFDPCHInfo == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_RadioLinkswithoutDPCHFDPCHInfo (pctxt, pvalue->u.radioLinkswithoutDPCHFDPCHInfo);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_HICH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* e_HICH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Information");

         pvalue->u.e_HICH_Information = rtxMemAllocType (pctxt, 
            utran_E_HICH_Information_r11);

         if (pvalue->u.e_HICH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_E_HICH_Information_r11 (pvalue->u.e_HICH_Information);

         stat = asn1PD_utran_E_HICH_Information_r11 (pctxt, pvalue->u.e_HICH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* secondaryReleaseIndicator */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "secondaryReleaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_RGCH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* e_RGCH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "e-RGCH-Information");

         pvalue->u.e_RGCH_Information = rtxMemAllocTypeZ (pctxt, 
            utran_E_RGCH_Information);

         if (pvalue->u.e_RGCH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_E_RGCH_Information (pctxt, pvalue->u.e_RGCH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_f_TPICH_Info (OSCTXT* pctxt, utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_f_TPICH_Info* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* f_TPICH_Information */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "f-TPICH-Information");

         pvalue->u.f_TPICH_Information = rtxMemAllocTypeZ (pctxt, 
            utran_F_TPICH_Information);

         if (pvalue->u.f_TPICH_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_F_TPICH_Information (pctxt, pvalue->u.f_TPICH_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* releaseIndicator */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "releaseIndicator");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_RGCH_Info */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RGCH-Info");

      pvalue->m.e_RGCH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode f_TPICH_Info */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "f-TPICH-Info");

      pvalue->m.f_TPICH_InfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_f_TPICH_Info (pctxt, &pvalue->f_TPICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd384_tdd768 (OSCTXT* pctxt, utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd384_tdd768* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_E_HICH_Information_TDD384_768 (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd128 (OSCTXT* pctxt, utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_HICH_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-HICH-Info");

      pvalue->m.e_HICH_InfoPresent = 1;

      stat = asn1PD_utran_E_HICH_Information_TDD128 (pctxt, &pvalue->e_HICH_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd (OSCTXT* pctxt, utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* tdd384_tdd768 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd384-tdd768");

         pvalue->u.tdd384_tdd768 = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd384_tdd768);

         if (pvalue->u.tdd384_tdd768 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd384_tdd768 (pvalue->u.tdd384_tdd768);

         stat = asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd384_tdd768 (pctxt, pvalue->u.tdd384_tdd768);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd128 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd128");

         pvalue->u.tdd128 = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd128);

         if (pvalue->u.tdd128 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd128 (pvalue->u.tdd128);

         stat = asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd128 (pctxt, pvalue->u.tdd128);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2 (OSCTXT* pctxt, utran_DL_InformationPerRL_r13_modeSpecificInfo2* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         pvalue->u.fdd = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd);

         if (pvalue->u.fdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd (pvalue->u.fdd);

         stat = asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         pvalue->u.tdd = rtxMemAllocType (pctxt, 
            utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd);

         if (pvalue->u.tdd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd (pvalue->u.tdd);

         stat = asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_r13 (OSCTXT* pctxt, utran_DL_InformationPerRL_r13* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-r13");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode modeSpecificInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo");

   stat = asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_dpchInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dpchInfo");

      pvalue->m.dl_dpchInfoPresent = 1;

      stat = asn1PD_utran_DL_InformationPerRL_r13_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_AGCH_Information */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-AGCH-Information");

      pvalue->m.e_AGCH_InformationPresent = 1;

      stat = asn1PD_utran_E_AGCH_Information_r8 (pctxt, &pvalue->e_AGCH_Information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_ROCH_Information */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-ROCH-Information");

      pvalue->m.e_ROCH_InformationPresent = 1;

      stat = asn1PD_utran_E_ROCH_Information (pctxt, &pvalue->e_ROCH_Information);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode modeSpecificInfo2 */
   RTXCTXTPUSHELEMNAME (pctxt, "modeSpecificInfo2");

   stat = asn1PD_utran_DL_InformationPerRL_r13_modeSpecificInfo2 (pctxt, &pvalue->modeSpecificInfo2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cell_id */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cell-id");

      pvalue->m.cell_idPresent = 1;

      stat = asn1PD_utran_CellIdentity (pctxt, &pvalue->cell_id);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_List_r13 (OSCTXT* pctxt, utran_DL_InformationPerRL_List_r13* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-List-r13");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_InformationPerRL_r13* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-InformationPerRL-r13", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_InformationPerRL_r13, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_InformationPerRL_r13 (pdata);

      stat = asn1PD_utran_DL_InformationPerRL_r13 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_COUNT_C_MSB (OSCTXT* pctxt, utran_COUNT_C_MSB* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "COUNT-C-MSB");

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(33554431));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_COUNT_C_MSB_Information (OSCTXT* pctxt, utran_RB_COUNT_C_MSB_Information* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-COUNT-C-MSB-Information");

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode count_C_MSB_UL */
   RTXCTXTPUSHELEMNAME (pctxt, "count-C-MSB-UL");

   stat = asn1PD_utran_COUNT_C_MSB (pctxt, &pvalue->count_C_MSB_UL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode count_C_MSB_DL */
   RTXCTXTPUSHELEMNAME (pctxt, "count-C-MSB-DL");

   stat = asn1PD_utran_COUNT_C_MSB (pctxt, &pvalue->count_C_MSB_DL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_COUNT_C_MSB_InformationList (OSCTXT* pctxt, utran_RB_COUNT_C_MSB_InformationList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-COUNT-C-MSB-InformationList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(27), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_COUNT_C_MSB_Information* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-COUNT-C-MSB-Information", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_COUNT_C_MSB_Information, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_RB_COUNT_C_MSB_Information (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_COUNT_C (OSCTXT* pctxt, utran_COUNT_C* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "COUNT-C");

   stat = pd_ConsUnsigned (pctxt, pvalue, OSUINTCONST(0), OSUINT32_MAX);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_COUNT_C_Information (OSCTXT* pctxt, utran_RB_COUNT_C_Information* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-COUNT-C-Information");

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode count_C_UL */
   RTXCTXTPUSHELEMNAME (pctxt, "count-C-UL");

   stat = asn1PD_utran_COUNT_C (pctxt, &pvalue->count_C_UL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode count_C_DL */
   RTXCTXTPUSHELEMNAME (pctxt, "count-C-DL");

   stat = asn1PD_utran_COUNT_C (pctxt, &pvalue->count_C_DL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_COUNT_C_InformationList (OSCTXT* pctxt, utran_RB_COUNT_C_InformationList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-COUNT-C-InformationList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(27), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_COUNT_C_Information* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-COUNT-C-Information", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_COUNT_C_Information, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_utran_RB_COUNT_C_Information (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_NAS_Message (OSCTXT* pctxt, utran_NAS_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NAS-Message");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4095), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ETWS_Information_warningType (OSCTXT* pctxt, utran_ETWS_Information_warningType* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_ETWS_Information_messageIdentifier (OSCTXT* pctxt, utran_ETWS_Information_messageIdentifier* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_ETWS_Information_serialNumber (OSCTXT* pctxt, utran_ETWS_Information_serialNumber* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_utran_ETWS_Information (OSCTXT* pctxt, utran_ETWS_Information* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ETWS-Information");

   /* decode root elements */
   /* decode warningType */
   RTXCTXTPUSHELEMNAME (pctxt, "warningType");

   stat = asn1PD_utran_ETWS_Information_warningType (pctxt, &pvalue->warningType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode messageIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "messageIdentifier");

   stat = asn1PD_utran_ETWS_Information_messageIdentifier (pctxt, &pvalue->messageIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode serialNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "serialNumber");

   stat = asn1PD_utran_ETWS_Information_serialNumber (pctxt, &pvalue->serialNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ETWS_WarningSecurityInfo (OSCTXT* pctxt, utran_ETWS_WarningSecurityInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ETWS-WarningSecurityInfo");

   stat = pd_DynOctetString (pctxt, (OSDynOctStr*)pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_S_RNTI_2 (OSCTXT* pctxt, utran_S_RNTI_2* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "S-RNTI-2");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(10), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(10), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_U_RNTI_Short (OSCTXT* pctxt, utran_U_RNTI_Short* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "U-RNTI-Short");

   /* decode root elements */
   /* decode srnc_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "srnc-Identity");

   stat = asn1PD_utran_SRNC_Identity (pctxt, &pvalue->srnc_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode s_RNTI_2 */
   RTXCTXTPUSHELEMNAME (pctxt, "s-RNTI-2");

   stat = asn1PD_utran_S_RNTI_2 (pctxt, &pvalue->s_RNTI_2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RLC_InfoChoice (OSCTXT* pctxt, utran_RLC_InfoChoice* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "RLC-InfoChoice");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rlc_Info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rlc-Info");

         pvalue->u.rlc_Info = rtxMemAllocType (pctxt, utran_RLC_Info);

         if (pvalue->u.rlc_Info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_RLC_Info (pvalue->u.rlc_Info);

         stat = asn1PD_utran_RLC_Info (pctxt, pvalue->u.rlc_Info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* same_as_RB */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "same-as-RB");

         stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->u.same_as_RB);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SRB_InformationSetup (OSCTXT* pctxt, utran_SRB_InformationSetup* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-InformationSetup");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

      pvalue->m.rb_IdentityPresent = 1;

      stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_InfoChoice */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-InfoChoice");

   stat = asn1PD_utran_RLC_InfoChoice (pctxt, &pvalue->rlc_InfoChoice);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_MappingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

   stat = asn1PD_utran_RB_MappingInfo (pctxt, &pvalue->rb_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SRB_InformationSetupList (OSCTXT* pctxt, utran_SRB_InformationSetupList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-InformationSetupList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_SRB_InformationSetup* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SRB-InformationSetup", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_SRB_InformationSetup, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_SRB_InformationSetup (pdata);

      stat = asn1PD_utran_SRB_InformationSetup (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationSetup (OSCTXT* pctxt, utran_RB_InformationSetup* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationSetup");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdcp_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Info");

      pvalue->m.pdcp_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_Info (pctxt, &pvalue->pdcp_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_InfoChoice */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-InfoChoice");

   stat = asn1PD_utran_RLC_InfoChoice (pctxt, &pvalue->rlc_InfoChoice);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_MappingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

   stat = asn1PD_utran_RB_MappingInfo (pctxt, &pvalue->rb_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationSetupList (OSCTXT* pctxt, utran_RB_InformationSetupList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationSetupList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationSetup* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationSetup", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationSetup, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationSetup (pdata);

      stat = asn1PD_utran_RB_InformationSetup (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_InformationSetup (OSCTXT* pctxt, utran_RAB_InformationSetup* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-InformationSetup");

   /* decode root elements */
   /* decode rab_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "rab-Info");

   stat = asn1PD_utran_RAB_Info (pctxt, &pvalue->rab_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_InformationSetupList */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-InformationSetupList");

   stat = asn1PD_utran_RB_InformationSetupList (pctxt, &pvalue->rb_InformationSetupList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_InformationSetupList (OSCTXT* pctxt, utran_RAB_InformationSetupList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-InformationSetupList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RAB_InformationSetup* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAB-InformationSetup", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RAB_InformationSetup, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RAB_InformationSetup (pdata);

      stat = asn1PD_utran_RAB_InformationSetup (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DefaultConfigIdentity (OSCTXT* pctxt, utran_DefaultConfigIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DefaultConfigIdentity");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_Info_Post (OSCTXT* pctxt, utran_RAB_Info_Post* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-Info-Post");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rab_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rab-Identity");

   stat = asn1PD_utran_RAB_Identity (pctxt, &pvalue->rab_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cn_DomainIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "cn-DomainIdentity");

   stat = asn1PD_utran_CN_DomainIdentity (pctxt, &pvalue->cn_DomainIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nas_Synchronisation_Indicator */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nas-Synchronisation-Indicator");

      pvalue->m.nas_Synchronisation_IndicatorPresent = 1;

      stat = asn1PD_utran_NAS_Synchronisation_Indicator (pctxt, &pvalue->nas_Synchronisation_Indicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DPCCH_PowerOffset2 (OSCTXT* pctxt, utran_DPCCH_PowerOffset2* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DPCCH-PowerOffset2");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-28), OSINTCONST(-13));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfoPostFDD (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfoPostFDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-PowerControlInfoPostFDD");

   /* decode root elements */
   /* decode dpcch_PowerOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "dpcch-PowerOffset");

   stat = asn1PD_utran_DPCCH_PowerOffset2 (pctxt, &pvalue->dpcch_PowerOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pc_Preamble */
   RTXCTXTPUSHELEMNAME (pctxt, "pc-Preamble");

   stat = asn1PD_utran_PC_Preamble (pctxt, &pvalue->pc_Preamble);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sRB_delay */
   RTXCTXTPUSHELEMNAME (pctxt, "sRB-delay");

   stat = asn1PD_utran_SRB_delay (pctxt, &pvalue->sRB_delay);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_ReducedScramblingCodeNumber (OSCTXT* pctxt, utran_ReducedScramblingCodeNumber* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReducedScramblingCodeNumber");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(8191));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_InfoPostFDD (OSCTXT* pctxt, utran_UL_DPCH_InfoPostFDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-InfoPostFDD");

   /* decode root elements */
   /* decode ul_DPCH_PowerControlInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-DPCH-PowerControlInfo");

   stat = asn1PD_utran_UL_DPCH_PowerControlInfoPostFDD (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode scramblingCodeType */
   RTXCTXTPUSHELEMNAME (pctxt, "scramblingCodeType");

   stat = asn1PD_utran_ScramblingCodeType (pctxt, &pvalue->scramblingCodeType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reducedScramblingCodeNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "reducedScramblingCodeNumber");

   stat = asn1PD_utran_ReducedScramblingCodeNumber (pctxt, &pvalue->reducedScramblingCodeNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode spreadingFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "spreadingFactor");

   stat = asn1PD_utran_SpreadingFactor (pctxt, &pvalue->spreadingFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoCommonPost (OSCTXT* pctxt, utran_DL_DPCH_InfoCommonPost* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DPCH-InfoCommonPost");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_DPCH_PowerControlInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-PowerControlInfo");

      pvalue->m.dl_DPCH_PowerControlInfoPresent = 1;

      stat = asn1PD_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_CommonInformationPost (OSCTXT* pctxt, utran_DL_CommonInformationPost* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CommonInformationPost");

   /* decode root elements */
   /* decode dl_DPCH_InfoCommon */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoCommon");

   stat = asn1PD_utran_DL_DPCH_InfoCommonPost (pctxt, &pvalue->dl_DPCH_InfoCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_PostFDD (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_PostFDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DPCH-InfoPerRL-PostFDD");

   /* decode root elements */
   /* decode pCPICH_UsageForChannelEst */
   RTXCTXTPUSHELEMNAME (pctxt, "pCPICH-UsageForChannelEst");

   stat = asn1PD_utran_PCPICH_UsageForChannelEst (pctxt, &pvalue->pCPICH_UsageForChannelEst);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_ChannelisationCode */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-ChannelisationCode");

   stat = asn1PD_utran_DL_ChannelisationCode (pctxt, &pvalue->dl_ChannelisationCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tpc_CombinationIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-CombinationIndex");

   stat = asn1PD_utran_TPC_CombinationIndex (pctxt, &pvalue->tpc_CombinationIndex);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_PostFDD (OSCTXT* pctxt, utran_DL_InformationPerRL_PostFDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-PostFDD");

   /* decode root elements */
   /* decode primaryCPICH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCPICH-Info");

   stat = asn1PD_utran_PrimaryCPICH_Info (pctxt, &pvalue->primaryCPICH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_DPCH_InfoPerRL */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoPerRL");

   stat = asn1PD_utran_DL_DPCH_InfoPerRL_PostFDD (pctxt, &pvalue->dl_DPCH_InfoPerRL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_ListPostFDD (OSCTXT* pctxt, utran_DL_InformationPerRL_ListPostFDD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-ListPostFDD");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_DL_InformationPerRL_PostFDD* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DL-InformationPerRL-PostFDD", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_DL_InformationPerRL_PostFDD, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_DL_InformationPerRL_PostFDD (pdata);

      stat = asn1PD_utran_DL_InformationPerRL_PostFDD (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfoPostTDD (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfoPostTDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-PowerControlInfoPostTDD");

   /* decode root elements */
   /* decode ul_TargetSIR */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TargetSIR");

   stat = asn1PD_utran_UL_TargetSIR (pctxt, &pvalue->ul_TargetSIR);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TimeslotInterference */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TimeslotInterference");

   stat = asn1PD_utran_TDD_UL_Interference (pctxt, &pvalue->ul_TimeslotInterference);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_InfoPostTDD (OSCTXT* pctxt, utran_UL_DPCH_InfoPostTDD* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-InfoPostTDD");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_DPCH_PowerControlInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-DPCH-PowerControlInfo");

   stat = asn1PD_utran_UL_DPCH_PowerControlInfoPostTDD (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TimingAdvance */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TimingAdvance");

      pvalue->m.ul_TimingAdvancePresent = 1;

      stat = asn1PD_utran_UL_TimingAdvanceControl (pctxt, &pvalue->ul_TimingAdvance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCH_TimeslotsCodes */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCH-TimeslotsCodes");

   stat = asn1PD_utran_UplinkTimeslotsCodes (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_InfoPost_syncCase_syncCase1 (OSCTXT* pctxt, utran_PrimaryCCPCH_InfoPost_syncCase_syncCase1* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslot */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslot");

   stat = asn1PD_utran_TimeslotNumber (pctxt, &pvalue->timeslot);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_InfoPost_syncCase_syncCase2 (OSCTXT* pctxt, utran_PrimaryCCPCH_InfoPost_syncCase_syncCase2* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode timeslotSync2 */
   RTXCTXTPUSHELEMNAME (pctxt, "timeslotSync2");

   stat = asn1PD_utran_TimeslotSync2 (pctxt, &pvalue->timeslotSync2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_InfoPost_syncCase (OSCTXT* pctxt, utran_PrimaryCCPCH_InfoPost_syncCase* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* syncCase1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "syncCase1");

         pvalue->u.syncCase1 = rtxMemAllocTypeZ (pctxt, 
            utran_PrimaryCCPCH_InfoPost_syncCase_syncCase1);

         if (pvalue->u.syncCase1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_PrimaryCCPCH_InfoPost_syncCase_syncCase1 (pctxt, pvalue->u.syncCase1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* syncCase2 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "syncCase2");

         pvalue->u.syncCase2 = rtxMemAllocTypeZ (pctxt, 
            utran_PrimaryCCPCH_InfoPost_syncCase_syncCase2);

         if (pvalue->u.syncCase2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_utran_PrimaryCCPCH_InfoPost_syncCase_syncCase2 (pctxt, pvalue->u.syncCase2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_InfoPost (OSCTXT* pctxt, utran_PrimaryCCPCH_InfoPost* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PrimaryCCPCH-InfoPost");

   /* decode root elements */
   /* decode syncCase */
   RTXCTXTPUSHELEMNAME (pctxt, "syncCase");

   stat = asn1PD_utran_PrimaryCCPCH_InfoPost_syncCase (pctxt, &pvalue->syncCase);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellParametersID */
   RTXCTXTPUSHELEMNAME (pctxt, "cellParametersID");

   stat = asn1PD_utran_CellParametersID (pctxt, &pvalue->cellParametersID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sctd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "sctd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->sctd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_PostTDD (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_PostTDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DPCH-InfoPerRL-PostTDD");

   /* decode root elements */
   /* decode dl_DPCH_TimeslotsCodes */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-TimeslotsCodes");

   stat = asn1PD_utran_DownlinkTimeslotsCodes (pctxt, &pvalue->dl_DPCH_TimeslotsCodes);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_PostTDD (OSCTXT* pctxt, utran_DL_InformationPerRL_PostTDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-PostTDD");

   /* decode root elements */
   /* decode primaryCCPCH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCCPCH-Info");

   stat = asn1PD_utran_PrimaryCCPCH_InfoPost (pctxt, &pvalue->primaryCCPCH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_DPCH_InfoPerRL */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoPerRL");

   stat = asn1PD_utran_DL_DPCH_InfoPerRL_PostTDD (pctxt, &pvalue->dl_DPCH_InfoPerRL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationSetup_r4 (OSCTXT* pctxt, utran_RB_InformationSetup_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationSetup-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdcp_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Info");

      pvalue->m.pdcp_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_Info_r4 (pctxt, &pvalue->pdcp_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_InfoChoice */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-InfoChoice");

   stat = asn1PD_utran_RLC_InfoChoice (pctxt, &pvalue->rlc_InfoChoice);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_MappingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

   stat = asn1PD_utran_RB_MappingInfo (pctxt, &pvalue->rb_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationSetupList_r4 (OSCTXT* pctxt, utran_RB_InformationSetupList_r4* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationSetupList-r4");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationSetup_r4* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationSetup-r4", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationSetup_r4, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationSetup_r4 (pdata);

      stat = asn1PD_utran_RB_InformationSetup_r4 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_InformationSetup_r4 (OSCTXT* pctxt, utran_RAB_InformationSetup_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-InformationSetup-r4");

   /* decode root elements */
   /* decode rab_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "rab-Info");

   stat = asn1PD_utran_RAB_Info (pctxt, &pvalue->rab_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_InformationSetupList */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-InformationSetupList");

   stat = asn1PD_utran_RB_InformationSetupList_r4 (pctxt, &pvalue->rb_InformationSetupList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_InformationSetupList_r4 (OSCTXT* pctxt, utran_RAB_InformationSetupList_r4* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-InformationSetupList-r4");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RAB_InformationSetup_r4* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAB-InformationSetup-r4", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RAB_InformationSetup_r4, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RAB_InformationSetup_r4 (pdata);

      stat = asn1PD_utran_RAB_InformationSetup_r4 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DefaultConfigIdentity_r4 (OSCTXT* pctxt, utran_DefaultConfigIdentity_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DefaultConfigIdentity-r4");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(12));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_PowerControlInfoPostTDD_LCR_r4 (OSCTXT* pctxt, utran_UL_DPCH_PowerControlInfoPostTDD_LCR_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-PowerControlInfoPostTDD-LCR-r4");

   /* decode root elements */
   /* decode ul_TargetSIR */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-TargetSIR");

   stat = asn1PD_utran_UL_TargetSIR (pctxt, &pvalue->ul_TargetSIR);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl_LCR_r4_enabled (OSCTXT* pctxt, utran_UL_TimingAdvanceControl_LCR_r4_enabled* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_SynchronisationParameters */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-SynchronisationParameters");

      pvalue->m.ul_SynchronisationParametersPresent = 1;

      stat = asn1PD_utran_UL_SynchronisationParameters_r4 (pctxt, &pvalue->ul_SynchronisationParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode synchronisationParameters */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "synchronisationParameters");

      pvalue->m.synchronisationParametersPresent = 1;

      stat = asn1PD_utran_SynchronisationParameters_r4 (pctxt, &pvalue->synchronisationParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_utran_UL_TimingAdvanceControl_LCR_r4 (OSCTXT* pctxt, utran_UL_TimingAdvanceControl_LCR_r4* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-TimingAdvanceControl-LCR-r4");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* disabled */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "disabled");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* enabled */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "enabled");

         pvalue->u.enabled = rtxMemAllocType (pctxt, 
            utran_UL_TimingAdvanceControl_LCR_r4_enabled);

         if (pvalue->u.enabled == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_UL_TimingAdvanceControl_LCR_r4_enabled (pvalue->u.enabled);

         stat = asn1PD_utran_UL_TimingAdvanceControl_LCR_r4_enabled (pctxt, pvalue->u.enabled);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_UL_DPCH_InfoPostTDD_LCR_r4 (OSCTXT* pctxt, utran_UL_DPCH_InfoPostTDD_LCR_r4* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DPCH-InfoPostTDD-LCR-r4");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_DPCH_PowerControlInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-DPCH-PowerControlInfo");

   stat = asn1PD_utran_UL_DPCH_PowerControlInfoPostTDD_LCR_r4 (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_TimingAdvance */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-TimingAdvance");

      pvalue->m.ul_TimingAdvancePresent = 1;

      stat = asn1PD_utran_UL_TimingAdvanceControl_LCR_r4 (pctxt, &pvalue->ul_TimingAdvance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CCTrCH_TimeslotsCodes */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-CCTrCH-TimeslotsCodes");

   stat = asn1PD_utran_UplinkTimeslotsCodes_LCR_r4 (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_PrimaryCCPCH_InfoPostTDD_LCR_r4 (OSCTXT* pctxt, utran_PrimaryCCPCH_InfoPostTDD_LCR_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PrimaryCCPCH-InfoPostTDD-LCR-r4");

   /* decode root elements */
   /* decode tstd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "tstd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->tstd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellParametersID */
   RTXCTXTPUSHELEMNAME (pctxt, "cellParametersID");

   stat = asn1PD_utran_CellParametersID (pctxt, &pvalue->cellParametersID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sctd_Indicator */
   RTXCTXTPUSHELEMNAME (pctxt, "sctd-Indicator");

   stat = DEC_BIT (pctxt, &pvalue->sctd_Indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_DPCH_InfoPerRL_PostTDD_LCR_r4 (OSCTXT* pctxt, utran_DL_DPCH_InfoPerRL_PostTDD_LCR_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DPCH-InfoPerRL-PostTDD-LCR-r4");

   /* decode root elements */
   /* decode dl_CCTrCH_TimeslotsCodes */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-CCTrCH-TimeslotsCodes");

   stat = asn1PD_utran_DownlinkTimeslotsCodes_LCR_r4 (pctxt, &pvalue->dl_CCTrCH_TimeslotsCodes);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DL_InformationPerRL_PostTDD_LCR_r4 (OSCTXT* pctxt, utran_DL_InformationPerRL_PostTDD_LCR_r4* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-InformationPerRL-PostTDD-LCR-r4");

   /* decode root elements */
   /* decode primaryCCPCH_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "primaryCCPCH-Info");

   stat = asn1PD_utran_PrimaryCCPCH_InfoPostTDD_LCR_r4 (pctxt, &pvalue->primaryCCPCH_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_DPCH_InfoPerRL */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-DPCH-InfoPerRL");

   stat = asn1PD_utran_DL_DPCH_InfoPerRL_PostTDD_LCR_r4 (pctxt, &pvalue->dl_DPCH_InfoPerRL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RLC_InfoChoice_r5 (OSCTXT* pctxt, utran_RLC_InfoChoice_r5* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "RLC-InfoChoice-r5");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rlc_Info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rlc-Info");

         pvalue->u.rlc_Info = rtxMemAllocType (pctxt, utran_RLC_Info_r5);

         if (pvalue->u.rlc_Info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_RLC_Info_r5 (pvalue->u.rlc_Info);

         stat = asn1PD_utran_RLC_Info_r5 (pctxt, pvalue->u.rlc_Info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* same_as_RB */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "same-as-RB");

         stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->u.same_as_RB);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SRB_InformationSetup_r5 (OSCTXT* pctxt, utran_SRB_InformationSetup_r5* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-InformationSetup-r5");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

      pvalue->m.rb_IdentityPresent = 1;

      stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_InfoChoice */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-InfoChoice");

   stat = asn1PD_utran_RLC_InfoChoice_r5 (pctxt, &pvalue->rlc_InfoChoice);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_MappingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

   stat = asn1PD_utran_RB_MappingInfo_r5 (pctxt, &pvalue->rb_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_SRB_InformationSetupList_r5 (OSCTXT* pctxt, utran_SRB_InformationSetupList_r5* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-InformationSetupList-r5");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_SRB_InformationSetup_r5* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SRB-InformationSetup-r5", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_SRB_InformationSetup_r5, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_SRB_InformationSetup_r5 (pdata);

      stat = asn1PD_utran_SRB_InformationSetup_r5 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationSetup_r5 (OSCTXT* pctxt, utran_RB_InformationSetup_r5* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationSetup-r5");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-Identity");

   stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->rb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdcp_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Info");

      pvalue->m.pdcp_InfoPresent = 1;

      stat = asn1PD_utran_PDCP_Info_r4 (pctxt, &pvalue->pdcp_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_InfoChoice */
   RTXCTXTPUSHELEMNAME (pctxt, "rlc-InfoChoice");

   stat = asn1PD_utran_RLC_InfoChoice_r5 (pctxt, &pvalue->rlc_InfoChoice);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_MappingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-MappingInfo");

   stat = asn1PD_utran_RB_MappingInfo_r5 (pctxt, &pvalue->rb_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RB_InformationSetupList_r5 (OSCTXT* pctxt, utran_RB_InformationSetupList_r5* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RB-InformationSetupList-r5");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RB_InformationSetup_r5* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RB-InformationSetup-r5", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RB_InformationSetup_r5, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RB_InformationSetup_r5 (pdata);

      stat = asn1PD_utran_RB_InformationSetup_r5 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_InformationSetup_r5 (OSCTXT* pctxt, utran_RAB_InformationSetup_r5* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-InformationSetup-r5");

   /* decode root elements */
   /* decode rab_Info */
   RTXCTXTPUSHELEMNAME (pctxt, "rab-Info");

   stat = asn1PD_utran_RAB_Info (pctxt, &pvalue->rab_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rb_InformationSetupList */
   RTXCTXTPUSHELEMNAME (pctxt, "rb-InformationSetupList");

   stat = asn1PD_utran_RB_InformationSetupList_r5 (pctxt, &pvalue->rb_InformationSetupList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RAB_InformationSetupList_r5 (OSCTXT* pctxt, utran_RAB_InformationSetupList_r5* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-InformationSetupList-r5");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      utran_RAB_InformationSetup_r5* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAB-InformationSetup-r5", xx1);

      rtxDListAllocNodeAndData (pctxt, utran_RAB_InformationSetup_r5, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_utran_RAB_InformationSetup_r5 (pdata);

      stat = asn1PD_utran_RAB_InformationSetup_r5 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_DefaultConfigIdentity_r5 (OSCTXT* pctxt, utran_DefaultConfigIdentity_r5* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DefaultConfigIdentity-r5");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(13));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_utran_RLC_InfoChoice_r6 (OSCTXT* pctxt, utran_RLC_InfoChoice_r6* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "RLC-InfoChoice-r6");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rlc_Info */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rlc-Info");

         pvalue->u.rlc_Info = rtxMemAllocType (pctxt, utran_RLC_Info_r6);

         if (pvalue->u.rlc_Info == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_utran_RLC_Info_r6 (pvalue->u.rlc_Info);

         stat = asn1PD_utran_RLC_Info_r6 (pctxt, pvalue->u.rlc_Info);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* same_as_RB */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "same-as-RB");

         stat = asn1PD_utran_RB_Identity (pctxt, &pvalue->u.same_as_RB);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

