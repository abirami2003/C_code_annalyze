/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.1.0, Date: 24-Jan-2017.
 */
#include "lppa_asn_enc_dec_3gpp.h"
#include "rtsrc/rtPrint.h"
#include "rtsrc/rtPrintToString.h"
#include "rtsrc/rtPrintToStream.h"
#include "rtxsrc/rtxCharStr.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PE_lppa_ProcedureCode (OSCTXT* pctxt, lppa_ProcedureCode value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProcedureCode");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ProcedureCode (OSCTXT* pctxt, lppa_ProcedureCode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProcedureCode");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem lppa_Criticality_ENUMTAB[] = {
   { OSUTF8("ignore"), 1, 6, 2 },
   { OSUTF8("notify"), 2, 6, 0 },
   { OSUTF8("reject"), 0, 6, 1 }
} ;
#define lppa_Criticality_ENUMTABSIZE 3

const OSUTF8CHAR* lppa_Criticality_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_Criticality_ENUMTABSIZE) {
      return lppa_Criticality_ENUMTAB
         [lppa_Criticality_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_Criticality_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_Criticality* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_Criticality_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_Criticality_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, lppa_Criticality* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, lppa_Criticality_ENUMTAB, 
      lppa_Criticality_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_Criticality)lppa_Criticality_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_Criticality (OSCTXT* pctxt, lppa_Criticality value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Criticality");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_Criticality (OSCTXT* pctxt, lppa_Criticality* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Criticality");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_LPPATransactionID (OSCTXT* pctxt, lppa_LPPATransactionID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LPPATransactionID");

   if ( value <= 32767 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 32767);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_LPPATransactionID (OSCTXT* pctxt, lppa_LPPATransactionID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LPPATransactionID");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 32767);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_ProtocolIE_ID (OSCTXT* pctxt, lppa_ProtocolIE_ID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolIE-ID");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ProtocolIE_ID (OSCTXT* pctxt, lppa_ProtocolIE_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolIE-ID");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem lppa_TriggeringMessage_ENUMTAB[] = {
   { OSUTF8("initiating-message"), 0, 18, 0 },
   { OSUTF8("successful-outcome"), 1, 18, 1 },
   { OSUTF8("unsuccessful-outcome"), 2, 20, 2 }
} ;
#define lppa_TriggeringMessage_ENUMTABSIZE 3

const OSUTF8CHAR* lppa_TriggeringMessage_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_TriggeringMessage_ENUMTABSIZE) {
      return lppa_TriggeringMessage_ENUMTAB
         [lppa_TriggeringMessage_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_TriggeringMessage_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_TriggeringMessage* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_TriggeringMessage_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_TriggeringMessage_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, lppa_TriggeringMessage* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_TriggeringMessage_ENUMTAB, lppa_TriggeringMessage_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_TriggeringMessage)
         lppa_TriggeringMessage_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_TriggeringMessage (OSCTXT* pctxt, lppa_TriggeringMessage value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TriggeringMessage");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_TriggeringMessage (OSCTXT* pctxt, lppa_TriggeringMessage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TriggeringMessage");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_PrivateIE_ID (OSCTXT* pctxt, lppa_PrivateIE_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateIE-ID");

   /* Encode choice index value */

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* local */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "local");

         stat = pe_ConsUnsigned (pctxt, pvalue->u.local, 0, 65535);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* global */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "global");

         stat = pe_ObjectIdentifier (pctxt, pvalue->u.global);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_PrivateIE_ID (OSCTXT* pctxt, lppa_PrivateIE_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateIE-ID");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* local */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "local");

         stat = pd_ConsUInt16 (pctxt, &pvalue->u.local, 0, 65535);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* global */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "global");

         pvalue->u.global = rtxMemAllocType (pctxt, ASN1OBJID);

         if (pvalue->u.global == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.global->numids = 0;

         stat = pd_ObjectIdentifier (pctxt, pvalue->u.global);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

OSBOOL asn1Equals_lppa_PrivateIE_ID (const lppa_PrivateIE_ID* pvalue1, const lppa_PrivateIE_ID* pvalue2)
{
   if (pvalue1->t == pvalue2->t) {
      switch (pvalue1->t) {
         case T_lppa_PrivateIE_ID_local:
            return (pvalue1->u.local == pvalue2->u.local);

         case T_lppa_PrivateIE_ID_global:
            return (rtOIDsEqual (pvalue1->u.global, pvalue2->u.global));

         default:;
      }
   }

   return FALSE;
}
int asn1Init_lppa_PrivateIE_ID (lppa_PrivateIE_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_lppa_PrivateIE_ID (OSCTXT *pctxt, lppa_PrivateIE_ID* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.global) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.global);
            pvalue->u.global = 0;
         }
         break;

   }
}

static const OSEnumItem lppa_Presence_ENUMTAB[] = {
   { OSUTF8("conditional"), 1, 11, 2 },
   { OSUTF8("mandatory"), 2, 9, 0 },
   { OSUTF8("optional"), 0, 8, 1 }
} ;
#define lppa_Presence_ENUMTABSIZE 3

const OSUTF8CHAR* lppa_Presence_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_Presence_ENUMTABSIZE) {
      return lppa_Presence_ENUMTAB[lppa_Presence_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_Presence_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_Presence* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_Presence_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_Presence_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, lppa_Presence* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, lppa_Presence_ENUMTAB, 
      lppa_Presence_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_Presence)lppa_Presence_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_Presence (OSCTXT* pctxt, lppa_Presence value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Presence");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_Presence (OSCTXT* pctxt, lppa_Presence* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Presence");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Print_lppa_ProcedureCode 
   (const char* name, const lppa_ProcedureCode* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_Criticality 
   (const char* name, const lppa_Criticality* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("reject\n"); break;
      case 1: printf ("ignore\n"); break;
      case 2: printf ("notify\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_lppa_LPPATransactionID 
   (const char* name, const lppa_LPPATransactionID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_ProtocolIE_ID 
   (const char* name, const lppa_ProtocolIE_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_TriggeringMessage 
   (const char* name, const lppa_TriggeringMessage* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("initiating-message\n"); break;
      case 1: printf ("successful-outcome\n"); break;
      case 2: printf ("unsuccessful-outcome\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_lppa_PrivateIE_ID 
   (const char* name, const lppa_PrivateIE_ID* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* local */
      case 1:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("local", pvalue->u.local);
         break;
      }
      /* global */
      case 2:
      {
         rtxPrintIndent ();
         rtPrintOID ("global", pvalue->u.global);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_Presence (const char* name, const lppa_Presence* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("optional\n"); break;
      case 1: printf ("conditional\n"); break;
      case 2: printf ("mandatory\n"); break;
      default: printf ("???\n");
   }
}

int asn1PrtToStr_lppa_ProcedureCode (const char* name, 
   lppa_ProcedureCode* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_Criticality (const char* name, lppa_Criticality* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = reject\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = ignore\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = notify\n", buffer, bufSize);
         break;

      default:
      stat = rtPrintToString (" = ???\n", buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_LPPATransactionID (const char* name, 
   lppa_LPPATransactionID* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_ProtocolIE_ID (const char* name, 
   lppa_ProtocolIE_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_TriggeringMessage (const char* name, 
   lppa_TriggeringMessage* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = initiating-message\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = successful-outcome\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = unsuccessful-outcome\n", buffer, bufSize);
         break;

      default:
      stat = rtPrintToString (" = ???\n", buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_PrivateIE_ID (const char* name, 
   lppa_PrivateIE_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->t) {
      /* local */
      case 1:
      {
         if (rtPrintToStringIndent (buffer, bufSize) < 0) {
            return -1;
         }
         if (rtPrintToStringUnsigned ("local", pvalue->u.local, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* global */
      case 2:
      {
         if(rtPrintToStringIndent (buffer, bufSize) < 0)
         {
            return -1;
         }
         if(rtPrintToStringOID ("global", pvalue->u.global, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default:;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_Presence (const char* name, lppa_Presence* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = optional\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = conditional\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = mandatory\n", buffer, bufSize);
         break;

      default:
      stat = rtPrintToString (" = ???\n", buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStrm_lppa_ProcedureCode (OSCTXT *pctxt, 
   const char* name, const lppa_ProcedureCode* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_Criticality (OSCTXT *pctxt, 
   const char* name, const lppa_Criticality* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = reject\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = ignore\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = notify\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_lppa_LPPATransactionID (OSCTXT *pctxt, 
   const char* name, const lppa_LPPATransactionID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_ProtocolIE_ID (OSCTXT *pctxt, 
   const char* name, const lppa_ProtocolIE_ID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_TriggeringMessage (OSCTXT *pctxt, 
   const char* name, const lppa_TriggeringMessage* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = initiating-message\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = successful-outcome\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = unsuccessful-outcome\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_lppa_PrivateIE_ID (OSCTXT *pctxt, 
   const char* name, const lppa_PrivateIE_ID* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* local */
      case 1:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamUnsigned (pctxt, "local", pvalue->u.local);
         break;
      }
      /* global */
      case 2:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamOID (pctxt, "global", pvalue->u.global);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_Presence (OSCTXT *pctxt, 
   const char* name, const lppa_Presence* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = optional\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = conditional\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = mandatory\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

EXTERN int asn1PE_lppa_Measurement_ID (OSCTXT* pctxt, lppa_Measurement_ID value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Measurement-ID");

   if ( (value >= 1 && value <= 15) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 1, 15);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_Measurement_ID (OSCTXT* pctxt, lppa_Measurement_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Measurement-ID");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 1, 15);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem lppa_ReportCharacteristics_ENUMTAB[] = {
   { OSUTF8("onDemand"), 0, 8, 0 },
   { OSUTF8("periodic"), 1, 8, 1 }
} ;
#define lppa_ReportCharacteristics_ENUMTABSIZE 2

const OSUTF8CHAR* lppa_ReportCharacteristics_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_ReportCharacteristics_ENUMTABSIZE) {
      return lppa_ReportCharacteristics_ENUMTAB
         [lppa_ReportCharacteristics_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_ReportCharacteristics_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_ReportCharacteristics* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_ReportCharacteristics_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_ReportCharacteristics_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      lppa_ReportCharacteristics* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_ReportCharacteristics_ENUMTAB, 
      lppa_ReportCharacteristics_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_ReportCharacteristics)
         lppa_ReportCharacteristics_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_ReportCharacteristics (OSCTXT* pctxt, lppa_ReportCharacteristics value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportCharacteristics");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ReportCharacteristics (OSCTXT* pctxt, lppa_ReportCharacteristics* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportCharacteristics");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem lppa_MeasurementPeriodicity_ENUMTAB[] = {
   { OSUTF8("min1"), 8, 4, 7 },
   { OSUTF8("min12"), 10, 5, 9 },
   { OSUTF8("min30"), 11, 5, 10 },
   { OSUTF8("min6"), 9, 4, 12 },
   { OSUTF8("min60"), 12, 5, 5 },
   { OSUTF8("ms1024"), 4, 6, 8 },
   { OSUTF8("ms10240"), 7, 7, 11 },
   { OSUTF8("ms120"), 0, 5, 6 },
   { OSUTF8("ms2048"), 5, 6, 0 },
   { OSUTF8("ms240"), 1, 5, 3 },
   { OSUTF8("ms480"), 2, 5, 1 },
   { OSUTF8("ms5120"), 6, 6, 2 },
   { OSUTF8("ms640"), 3, 5, 4 }
} ;
#define lppa_MeasurementPeriodicity_ENUMTABSIZE 13

const OSUTF8CHAR* lppa_MeasurementPeriodicity_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_MeasurementPeriodicity_ENUMTABSIZE) {
      return lppa_MeasurementPeriodicity_ENUMTAB
         [lppa_MeasurementPeriodicity_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_MeasurementPeriodicity_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_MeasurementPeriodicity* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_MeasurementPeriodicity_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_MeasurementPeriodicity_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      lppa_MeasurementPeriodicity* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_MeasurementPeriodicity_ENUMTAB, 
      lppa_MeasurementPeriodicity_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_MeasurementPeriodicity)
         lppa_MeasurementPeriodicity_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_MeasurementPeriodicity (OSCTXT* pctxt, lppa_MeasurementPeriodicity value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementPeriodicity");

   if (value >= 13) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(12));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_MeasurementPeriodicity (OSCTXT* pctxt, lppa_MeasurementPeriodicity* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementPeriodicity");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(12));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem lppa_MeasurementQuantitiesValue_ENUMTAB[] = {
   { OSUTF8("angleOfArrival"), 1, 14, 1 },
   { OSUTF8("cell-ID"), 0, 7, 0 },
   { OSUTF8("rSRP"), 4, 4, 4 },
   { OSUTF8("rSRQ"), 5, 4, 5 },
   { OSUTF8("timingAdvanceType1"), 2, 18, 2 },
   { OSUTF8("timingAdvanceType2"), 3, 18, 3 }
} ;
#define lppa_MeasurementQuantitiesValue_ENUMTABSIZE 6

const OSUTF8CHAR* lppa_MeasurementQuantitiesValue_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_MeasurementQuantitiesValue_ENUMTABSIZE) {
      return lppa_MeasurementQuantitiesValue_ENUMTAB
         [lppa_MeasurementQuantitiesValue_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_MeasurementQuantitiesValue_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_MeasurementQuantitiesValue* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_MeasurementQuantitiesValue_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_MeasurementQuantitiesValue_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      lppa_MeasurementQuantitiesValue* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_MeasurementQuantitiesValue_ENUMTAB, 
      lppa_MeasurementQuantitiesValue_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_MeasurementQuantitiesValue)
         lppa_MeasurementQuantitiesValue_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_MeasurementQuantitiesValue (OSCTXT* pctxt, lppa_MeasurementQuantitiesValue value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementQuantitiesValue");

   if (value >= 6) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_MeasurementQuantitiesValue (OSCTXT* pctxt, lppa_MeasurementQuantitiesValue* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementQuantitiesValue");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_MeasurementQuantities_Item_iE_Extensions_element (OSCTXT* pctxt, lppa_MeasurementQuantities_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode extensionValue */

   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pe_OpenType (pctxt, pvalue->extensionValue.numocts, pvalue->extensionValue.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_MeasurementQuantities_Item_iE_Extensions_element (OSCTXT* pctxt, lppa_MeasurementQuantities_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_MeasurementQuantities_Item_iE_Extensions_element (
   lppa_MeasurementQuantities_Item_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->extensionValue.numocts = 0;
   pvalue->extensionValue.data = 0;
   return 0;
}

void asn1Free_lppa_MeasurementQuantities_Item_iE_Extensions_element (OSCTXT *pctxt, 
   lppa_MeasurementQuantities_Item_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->extensionValue.data);
   }
}

EXTERN int asn1PE_lppa_MeasurementQuantities_Item_iE_Extensions (OSCTXT* pctxt, lppa_MeasurementQuantities_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_MeasurementQuantities_Item_iE_Extensions_element (pctxt, ((lppa_MeasurementQuantities_Item_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_MeasurementQuantities_Item_iE_Extensions (OSCTXT* pctxt, lppa_MeasurementQuantities_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_MeasurementQuantities_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_MeasurementQuantities_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_MeasurementQuantities_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_MeasurementQuantities_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_MeasurementQuantities_Item_iE_Extensions (
   lppa_MeasurementQuantities_Item_iE_Extensions* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_MeasurementQuantities_Item_iE_Extensions (OSCTXT *pctxt, 
   lppa_MeasurementQuantities_Item_iE_Extensions* pvalue)
{
   if (0 == pvalue) return;
   { lppa_MeasurementQuantities_Item_iE_Extensions_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_MeasurementQuantities_Item_iE_Extensions_element*)pnode->data;
      asn1Free_lppa_MeasurementQuantities_Item_iE_Extensions_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_MeasurementQuantities_Item (OSCTXT* pctxt, lppa_MeasurementQuantities_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementQuantities-Item");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measurementQuantitiesValue */

   RTXCTXTPUSHELEMNAME (pctxt, "measurementQuantitiesValue");

   stat = asn1PE_lppa_MeasurementQuantitiesValue (pctxt, pvalue->measurementQuantitiesValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_lppa_MeasurementQuantities_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_MeasurementQuantities_Item (OSCTXT* pctxt, lppa_MeasurementQuantities_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementQuantities-Item");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode measurementQuantitiesValue */
   RTXCTXTPUSHELEMNAME (pctxt, "measurementQuantitiesValue");

   stat = asn1PD_lppa_MeasurementQuantitiesValue (pctxt, &pvalue->measurementQuantitiesValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_lppa_MeasurementQuantities_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_MeasurementQuantities_Item (
   lppa_MeasurementQuantities_Item* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_lppa_MeasurementQuantities_Item_iE_Extensions (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_MeasurementQuantities_Item (OSCTXT *pctxt, 
   lppa_MeasurementQuantities_Item* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_lppa_MeasurementQuantities_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_MeasurementQuantities_element (OSCTXT* pctxt, lppa_MeasurementQuantities_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = asn1PE_lppa_MeasurementQuantities_Item (pctxt, &pvalue->value);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_MeasurementQuantities_element (OSCTXT* pctxt, lppa_MeasurementQuantities_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   stat = asn1PD_lppa_MeasurementQuantities_Item (pctxt, &pvalue->value);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (stat != 0) return LOG_RTERR (pctxt, stat);
   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_MeasurementQuantities_element (
   lppa_MeasurementQuantities_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_MeasurementQuantities_element (OSCTXT *pctxt, 
   lppa_MeasurementQuantities_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_MeasurementQuantities_Item (pctxt, &pvalue->value);
}

lppa_MeasurementQuantities_element* asn1Get_lppa_MeasurementQuantities 
   (lppa_ProtocolIE_ID id, lppa_MeasurementQuantities* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_MeasurementQuantities_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_MeasurementQuantities_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_MeasurementQuantities (OSCTXT* pctxt, lppa_MeasurementQuantities* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementQuantities");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(63), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_MeasurementQuantities_element (pctxt, ((lppa_MeasurementQuantities_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_MeasurementQuantities (OSCTXT* pctxt, lppa_MeasurementQuantities* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementQuantities");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(63), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_MeasurementQuantities_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_MeasurementQuantities_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_MeasurementQuantities_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_MeasurementQuantities_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_MeasurementQuantities (lppa_MeasurementQuantities* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_MeasurementQuantities (OSCTXT *pctxt, 
   lppa_MeasurementQuantities* pvalue)
{
   if (0 == pvalue) return;
   { lppa_MeasurementQuantities_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_MeasurementQuantities_element*)pnode->data;
      asn1Free_lppa_MeasurementQuantities_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem lppa_InterRATMeasurementQuantitiesValue_ENUMTAB[] = {
   { OSUTF8("geran"), 0, 5, 0 },
   { OSUTF8("utran"), 1, 5, 1 }
} ;
#define lppa_InterRATMeasurementQuantitiesValue_ENUMTABSIZE 2

const OSUTF8CHAR* lppa_InterRATMeasurementQuantitiesValue_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_InterRATMeasurementQuantitiesValue_ENUMTABSIZE) {
      return lppa_InterRATMeasurementQuantitiesValue_ENUMTAB
         [lppa_InterRATMeasurementQuantitiesValue_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_InterRATMeasurementQuantitiesValue_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_InterRATMeasurementQuantitiesValue* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_InterRATMeasurementQuantitiesValue_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_InterRATMeasurementQuantitiesValue_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      lppa_InterRATMeasurementQuantitiesValue* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_InterRATMeasurementQuantitiesValue_ENUMTAB, 
      lppa_InterRATMeasurementQuantitiesValue_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_InterRATMeasurementQuantitiesValue)
         lppa_InterRATMeasurementQuantitiesValue_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_InterRATMeasurementQuantitiesValue (OSCTXT* pctxt, lppa_InterRATMeasurementQuantitiesValue value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterRATMeasurementQuantitiesValue");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_InterRATMeasurementQuantitiesValue (OSCTXT* pctxt, lppa_InterRATMeasurementQuantitiesValue* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InterRATMeasurementQuantitiesValue");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element (OSCTXT* pctxt, lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode extensionValue */

   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pe_OpenType (pctxt, pvalue->extensionValue.numocts, pvalue->extensionValue.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element (OSCTXT* pctxt, lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element (
   lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->extensionValue.numocts = 0;
   pvalue->extensionValue.data = 0;
   return 0;
}

void asn1Free_lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element (OSCTXT *pctxt, 
   lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->extensionValue.data);
   }
}

EXTERN int asn1PE_lppa_InterRATMeasurementQuantities_Item_iE_Extensions (OSCTXT* pctxt, lppa_InterRATMeasurementQuantities_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element (pctxt, ((lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_InterRATMeasurementQuantities_Item_iE_Extensions (OSCTXT* pctxt, lppa_InterRATMeasurementQuantities_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_InterRATMeasurementQuantities_Item_iE_Extensions (
   lppa_InterRATMeasurementQuantities_Item_iE_Extensions* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_InterRATMeasurementQuantities_Item_iE_Extensions (OSCTXT *pctxt, 
   lppa_InterRATMeasurementQuantities_Item_iE_Extensions* pvalue)
{
   if (0 == pvalue) return;
   { lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element*)pnode->data;
      asn1Free_lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_InterRATMeasurementQuantities_Item (OSCTXT* pctxt, lppa_InterRATMeasurementQuantities_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InterRATMeasurementQuantities-Item");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode interRATMeasurementQuantitiesValue */

   RTXCTXTPUSHELEMNAME (pctxt, "interRATMeasurementQuantitiesValue");

   stat = asn1PE_lppa_InterRATMeasurementQuantitiesValue (pctxt, pvalue->interRATMeasurementQuantitiesValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_lppa_InterRATMeasurementQuantities_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_InterRATMeasurementQuantities_Item (OSCTXT* pctxt, lppa_InterRATMeasurementQuantities_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "InterRATMeasurementQuantities-Item");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode interRATMeasurementQuantitiesValue */
   RTXCTXTPUSHELEMNAME (pctxt, "interRATMeasurementQuantitiesValue");

   stat = asn1PD_lppa_InterRATMeasurementQuantitiesValue (pctxt, &pvalue->interRATMeasurementQuantitiesValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_lppa_InterRATMeasurementQuantities_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_InterRATMeasurementQuantities_Item (
   lppa_InterRATMeasurementQuantities_Item* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_lppa_InterRATMeasurementQuantities_Item_iE_Extensions (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_InterRATMeasurementQuantities_Item (OSCTXT *pctxt, 
   lppa_InterRATMeasurementQuantities_Item* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_lppa_InterRATMeasurementQuantities_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_InterRATMeasurementQuantities_element (OSCTXT* pctxt, lppa_InterRATMeasurementQuantities_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = asn1PE_lppa_InterRATMeasurementQuantities_Item (pctxt, &pvalue->value);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_InterRATMeasurementQuantities_element (OSCTXT* pctxt, lppa_InterRATMeasurementQuantities_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   stat = asn1PD_lppa_InterRATMeasurementQuantities_Item (pctxt, &pvalue->value);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (stat != 0) return LOG_RTERR (pctxt, stat);
   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_InterRATMeasurementQuantities_element (
   lppa_InterRATMeasurementQuantities_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_InterRATMeasurementQuantities_element (OSCTXT *pctxt, 
   lppa_InterRATMeasurementQuantities_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_InterRATMeasurementQuantities_Item (pctxt, &pvalue->value);
}

lppa_InterRATMeasurementQuantities_element* 
   asn1Get_lppa_InterRATMeasurementQuantities (lppa_ProtocolIE_ID id, 
   lppa_InterRATMeasurementQuantities* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_InterRATMeasurementQuantities_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_InterRATMeasurementQuantities_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_InterRATMeasurementQuantities (OSCTXT* pctxt, lppa_InterRATMeasurementQuantities* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "InterRATMeasurementQuantities");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(63), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_InterRATMeasurementQuantities_element (pctxt, ((lppa_InterRATMeasurementQuantities_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_InterRATMeasurementQuantities (OSCTXT* pctxt, lppa_InterRATMeasurementQuantities* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterRATMeasurementQuantities");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(63), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_InterRATMeasurementQuantities_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_InterRATMeasurementQuantities_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_InterRATMeasurementQuantities_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_InterRATMeasurementQuantities_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_InterRATMeasurementQuantities (
   lppa_InterRATMeasurementQuantities* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_InterRATMeasurementQuantities (OSCTXT *pctxt, 
   lppa_InterRATMeasurementQuantities* pvalue)
{
   if (0 == pvalue) return;
   { lppa_InterRATMeasurementQuantities_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_InterRATMeasurementQuantities_element*)pnode->data;
      asn1Free_lppa_InterRATMeasurementQuantities_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem lppa_OTDOA_Information_Item_ENUMTAB[] = {
   { OSUTF8("cellid"), 1, 6, 6 },
   { OSUTF8("cpLength"), 6, 8, 0 },
   { OSUTF8("e-UTRANAccessPointPosition"), 10, 26, 11 },
   { OSUTF8("earfcn"), 3, 6, 3 },
   { OSUTF8("noAntennaPorts"), 8, 14, 7 },
   { OSUTF8("noDlFrames"), 7, 10, 8 },
   { OSUTF8("pci"), 0, 3, 1 },
   { OSUTF8("prsBandwidth"), 4, 12, 5 },
   { OSUTF8("prsConfigIndex"), 5, 14, 4 },
   { OSUTF8("prsmutingconfiguration"), 11, 22, 10 },
   { OSUTF8("sFNInitTime"), 9, 11, 2 },
   { OSUTF8("tac"), 2, 3, 9 }
} ;
#define lppa_OTDOA_Information_Item_ENUMTABSIZE 12

const OSUTF8CHAR* lppa_OTDOA_Information_Item_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_OTDOA_Information_Item_ENUMTABSIZE) {
      return lppa_OTDOA_Information_Item_ENUMTAB
         [lppa_OTDOA_Information_Item_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_OTDOA_Information_Item_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_OTDOA_Information_Item* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_OTDOA_Information_Item_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_OTDOA_Information_Item_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      lppa_OTDOA_Information_Item* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_OTDOA_Information_Item_ENUMTAB, 
      lppa_OTDOA_Information_Item_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_OTDOA_Information_Item)
         lppa_OTDOA_Information_Item_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_OTDOA_Information_Item (OSCTXT* pctxt, lppa_OTDOA_Information_Item value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOA-Information-Item");

   if (value >= 12) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   extbit = (value > OSUINTCONST(9));

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, value - 10);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(9));
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOA_Information_Item (OSCTXT* pctxt, lppa_OTDOA_Information_Item* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOA-Information-Item");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = lppa_e_UTRANAccessPointPosition; break;
         case 1: *pvalue = lppa_prsmutingconfiguration; break;
         default: *pvalue = 0x7fffffff;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(9));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_RequestedSRSTransmissionCharacteristics (OSCTXT* pctxt, lppa_RequestedSRSTransmissionCharacteristics* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestedSRSTransmissionCharacteristics");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode numberOfTransmissions */

   RTXCTXTPUSHELEMNAME (pctxt, "numberOfTransmissions");

   if ( pvalue->numberOfTransmissions <= 500 ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, pvalue->numberOfTransmissions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, pvalue->numberOfTransmissions, 0, 500);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode bandwidth */

   RTXCTXTPUSHELEMNAME (pctxt, "bandwidth");

   if ( (pvalue->bandwidth >= 1 && pvalue->bandwidth <= 100) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, pvalue->bandwidth);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, pvalue->bandwidth, 1, 100);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_RequestedSRSTransmissionCharacteristics (OSCTXT* pctxt, lppa_RequestedSRSTransmissionCharacteristics* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestedSRSTransmissionCharacteristics");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode numberOfTransmissions */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfTransmissions");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, &pvalue->numberOfTransmissions, 0, 500);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, &pvalue->numberOfTransmissions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode bandwidth */
   RTXCTXTPUSHELEMNAME (pctxt, "bandwidth");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, &pvalue->bandwidth, 1, 100);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, &pvalue->bandwidth);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_RequestedSRSTransmissionCharacteristics (
   lppa_RequestedSRSTransmissionCharacteristics* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_RequestedSRSTransmissionCharacteristics (OSCTXT *pctxt, 
   lppa_RequestedSRSTransmissionCharacteristics* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

static const OSEnumItem lppa_CauseRadioNetwork_ENUMTAB[] = {
   { OSUTF8("requested-item-not-supported"), 1, 28, 2 },
   { OSUTF8("requested-item-temporarily-not-available"), 2, 40, 0 },
   { OSUTF8("unspecified"), 0, 11, 1 }
} ;
#define lppa_CauseRadioNetwork_ENUMTABSIZE 3

const OSUTF8CHAR* lppa_CauseRadioNetwork_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_CauseRadioNetwork_ENUMTABSIZE) {
      return lppa_CauseRadioNetwork_ENUMTAB
         [lppa_CauseRadioNetwork_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_CauseRadioNetwork_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_CauseRadioNetwork* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_CauseRadioNetwork_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_CauseRadioNetwork_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, lppa_CauseRadioNetwork* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_CauseRadioNetwork_ENUMTAB, lppa_CauseRadioNetwork_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_CauseRadioNetwork)
         lppa_CauseRadioNetwork_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_CauseRadioNetwork (OSCTXT* pctxt, lppa_CauseRadioNetwork value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseRadioNetwork");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_CauseRadioNetwork (OSCTXT* pctxt, lppa_CauseRadioNetwork* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseRadioNetwork");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem lppa_CauseProtocol_ENUMTAB[] = {
   { OSUTF8("abstract-syntax-error-falsely-constructed-message"), 6, 49, 5 },
   { OSUTF8("abstract-syntax-error-ignore-and-notify"), 2, 39, 2 },
   { OSUTF8("abstract-syntax-error-reject"), 1, 28, 1 },
   { OSUTF8("message-not-compatible-with-receiver-state"), 3, 42, 3 },
   { OSUTF8("semantic-error"), 4, 14, 4 },
   { OSUTF8("transfer-syntax-error"), 0, 21, 6 },
   { OSUTF8("unspecified"), 5, 11, 0 }
} ;
#define lppa_CauseProtocol_ENUMTABSIZE 7

const OSUTF8CHAR* lppa_CauseProtocol_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_CauseProtocol_ENUMTABSIZE) {
      return lppa_CauseProtocol_ENUMTAB
         [lppa_CauseProtocol_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_CauseProtocol_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_CauseProtocol* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_CauseProtocol_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_CauseProtocol_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, lppa_CauseProtocol* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, lppa_CauseProtocol_ENUMTAB, 
      lppa_CauseProtocol_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_CauseProtocol)lppa_CauseProtocol_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_CauseProtocol (OSCTXT* pctxt, lppa_CauseProtocol value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseProtocol");

   if (value >= 7) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_CauseProtocol (OSCTXT* pctxt, lppa_CauseProtocol* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseProtocol");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem lppa_CauseMisc_ENUMTAB[] = {
   { OSUTF8("unspecified"), 0, 11, 0 }
} ;
#define lppa_CauseMisc_ENUMTABSIZE 1

const OSUTF8CHAR* lppa_CauseMisc_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, lppa_CauseMisc_ENUMTAB, 
      lppa_CauseMisc_ENUMTABSIZE);

   if (idx >= 0 && idx < lppa_CauseMisc_ENUMTABSIZE) {
      return lppa_CauseMisc_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_CauseMisc_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_CauseMisc* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_CauseMisc_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_CauseMisc_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, lppa_CauseMisc* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, lppa_CauseMisc_ENUMTAB, 
      lppa_CauseMisc_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_CauseMisc)lppa_CauseMisc_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_CauseMisc (OSCTXT* pctxt, lppa_CauseMisc value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseMisc");

   switch (value) {
      case lppa_unspecified: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_CauseMisc (OSCTXT* pctxt, lppa_CauseMisc* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseMisc");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = lppa_unspecified; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_Cause (OSCTXT* pctxt, lppa_Cause* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Cause");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 3);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* radioNetwork */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "radioNetwork");

            stat = asn1PE_lppa_CauseRadioNetwork (pctxt, pvalue->u.radioNetwork);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* protocol */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "protocol");

            stat = asn1PE_lppa_CauseProtocol (pctxt, pvalue->u.protocol);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* misc */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "misc");

            stat = asn1PE_lppa_CauseMisc (pctxt, pvalue->u.misc);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_Cause (OSCTXT* pctxt, lppa_Cause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "Cause");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* radioNetwork */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "radioNetwork");

            stat = asn1PD_lppa_CauseRadioNetwork (pctxt, &pvalue->u.radioNetwork);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* protocol */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "protocol");

            stat = asn1PD_lppa_CauseProtocol (pctxt, &pvalue->u.protocol);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* misc */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "misc");

            stat = asn1PD_lppa_CauseMisc (pctxt, &pvalue->u.misc);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_Cause (lppa_Cause* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_lppa_Cause (OSCTXT *pctxt, lppa_Cause* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_lppa_PLMN_Identity (OSCTXT* pctxt, lppa_PLMN_Identity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMN-Identity");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_PLMN_Identity (OSCTXT* pctxt, lppa_PLMN_Identity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMN-Identity");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_PLMN_Identity (lppa_PLMN_Identity* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_lppa_EUTRANCellIdentifier (OSCTXT* pctxt, lppa_EUTRANCellIdentifier value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EUTRANCellIdentifier");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(28), OSUINTCONST(28), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(28), OSUINTCONST(28));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_EUTRANCellIdentifier (OSCTXT* pctxt, lppa_EUTRANCellIdentifier* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EUTRANCellIdentifier");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(28), OSUINTCONST(28), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(28), OSUINTCONST(28));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_EUTRANCellIdentifier (lppa_EUTRANCellIdentifier* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_lppa_ECGI_iE_Extensions_element (OSCTXT* pctxt, lppa_ECGI_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode extensionValue */

   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pe_OpenType (pctxt, pvalue->extensionValue.numocts, pvalue->extensionValue.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ECGI_iE_Extensions_element (OSCTXT* pctxt, lppa_ECGI_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ECGI_iE_Extensions_element (
   lppa_ECGI_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->extensionValue.numocts = 0;
   pvalue->extensionValue.data = 0;
   return 0;
}

void asn1Free_lppa_ECGI_iE_Extensions_element (OSCTXT *pctxt, 
   lppa_ECGI_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->extensionValue.data);
   }
}

EXTERN int asn1PE_lppa_ECGI_iE_Extensions (OSCTXT* pctxt, lppa_ECGI_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_ECGI_iE_Extensions_element (pctxt, ((lppa_ECGI_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_ECGI_iE_Extensions (OSCTXT* pctxt, lppa_ECGI_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_ECGI_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_ECGI_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_ECGI_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_ECGI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_ECGI_iE_Extensions (lppa_ECGI_iE_Extensions* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_ECGI_iE_Extensions (OSCTXT *pctxt, 
   lppa_ECGI_iE_Extensions* pvalue)
{
   if (0 == pvalue) return;
   { lppa_ECGI_iE_Extensions_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_ECGI_iE_Extensions_element*)pnode->data;
      asn1Free_lppa_ECGI_iE_Extensions_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_ECGI (OSCTXT* pctxt, lppa_ECGI* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ECGI");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMN_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMN-Identity");

   stat = asn1PE_lppa_PLMN_Identity (pctxt, &pvalue->pLMN_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode eUTRANcellIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "eUTRANcellIdentifier");

   stat = asn1PE_lppa_EUTRANCellIdentifier (pctxt, pvalue->eUTRANcellIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_lppa_ECGI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ECGI (OSCTXT* pctxt, lppa_ECGI* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ECGI");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pLMN_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMN-Identity");

   stat = asn1PD_lppa_PLMN_Identity (pctxt, &pvalue->pLMN_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode eUTRANcellIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "eUTRANcellIdentifier");

   stat = asn1PD_lppa_EUTRANCellIdentifier (pctxt, &pvalue->eUTRANcellIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_lppa_ECGI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ECGI (lppa_ECGI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_lppa_PLMN_Identity (&pvalue->pLMN_Identity);
   asn1Init_lppa_EUTRANCellIdentifier (&pvalue->eUTRANcellIdentifier);
   asn1Init_lppa_ECGI_iE_Extensions (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_ECGI (OSCTXT *pctxt, lppa_ECGI* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_lppa_ECGI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_TAC (OSCTXT* pctxt, lppa_TAC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TAC");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_TAC (OSCTXT* pctxt, lppa_TAC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TAC");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_TAC (lppa_TAC* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

static const OSEnumItem lppa_E_UTRANAccessPointPosition_latitudeSign_ENUMTAB[] = {
   { OSUTF8("north"), 0, 5, 0 },
   { OSUTF8("south"), 1, 5, 1 }
} ;
#define lppa_E_UTRANAccessPointPosition_latitudeSign_ENUMTABSIZE 2

const OSUTF8CHAR* lppa_E_UTRANAccessPointPosition_latitudeSign_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_E_UTRANAccessPointPosition_latitudeSign_ENUMTABSIZE) {
      return lppa_E_UTRANAccessPointPosition_latitudeSign_ENUMTAB
         [lppa_E_UTRANAccessPointPosition_latitudeSign_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_E_UTRANAccessPointPosition_latitudeSign_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      lppa_E_UTRANAccessPointPosition_latitudeSign* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_E_UTRANAccessPointPosition_latitudeSign_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_E_UTRANAccessPointPosition_latitudeSign_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      lppa_E_UTRANAccessPointPosition_latitudeSign* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_E_UTRANAccessPointPosition_latitudeSign_ENUMTAB, 
      lppa_E_UTRANAccessPointPosition_latitudeSign_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_E_UTRANAccessPointPosition_latitudeSign)
         lppa_E_UTRANAccessPointPosition_latitudeSign_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_E_UTRANAccessPointPosition_latitudeSign (OSCTXT* pctxt, lppa_E_UTRANAccessPointPosition_latitudeSign value)
{
   int stat = 0;

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_lppa_E_UTRANAccessPointPosition_latitudeSign (OSCTXT* pctxt, lppa_E_UTRANAccessPointPosition_latitudeSign* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem lppa_E_UTRANAccessPointPosition_directionOfAltitude_ENUMTAB[] = {
   { OSUTF8("depth"), 1, 5, 1 },
   { OSUTF8("height"), 0, 6, 0 }
} ;
#define lppa_E_UTRANAccessPointPosition_directionOfAltitude_ENUMTABSIZE 2

const OSUTF8CHAR* lppa_E_UTRANAccessPointPosition_directionOfAltitude_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_E_UTRANAccessPointPosition_directionOfAltitude_ENUMTABSIZE) {
      return lppa_E_UTRANAccessPointPosition_directionOfAltitude_ENUMTAB
         [lppa_E_UTRANAccessPointPosition_directionOfAltitude_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_E_UTRANAccessPointPosition_directionOfAltitude_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      lppa_E_UTRANAccessPointPosition_directionOfAltitude* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_E_UTRANAccessPointPosition_directionOfAltitude_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_E_UTRANAccessPointPosition_directionOfAltitude_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      lppa_E_UTRANAccessPointPosition_directionOfAltitude* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_E_UTRANAccessPointPosition_directionOfAltitude_ENUMTAB, 
      lppa_E_UTRANAccessPointPosition_directionOfAltitude_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_E_UTRANAccessPointPosition_directionOfAltitude)
         lppa_E_UTRANAccessPointPosition_directionOfAltitude_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_E_UTRANAccessPointPosition_directionOfAltitude (OSCTXT* pctxt, lppa_E_UTRANAccessPointPosition_directionOfAltitude value)
{
   int stat = 0;

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_lppa_E_UTRANAccessPointPosition_directionOfAltitude (OSCTXT* pctxt, lppa_E_UTRANAccessPointPosition_directionOfAltitude* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_lppa_E_UTRANAccessPointPosition (OSCTXT* pctxt, lppa_E_UTRANAccessPointPosition* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-UTRANAccessPointPosition");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode latitudeSign */

   RTXCTXTPUSHELEMNAME (pctxt, "latitudeSign");

   stat = asn1PE_lppa_E_UTRANAccessPointPosition_latitudeSign (pctxt, pvalue->latitudeSign);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode latitude */

   RTXCTXTPUSHELEMNAME (pctxt, "latitude");

   if ( pvalue->latitude <= 8388607 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->latitude, 0, 8388607);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->latitude);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode longitude */

   RTXCTXTPUSHELEMNAME (pctxt, "longitude");

   if ( (pvalue->longitude >= -8388608 && pvalue->longitude <= 8388607) ) {
      stat = pe_ConsInteger (pctxt, pvalue->longitude, -8388608, 8388607);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->longitude);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode directionOfAltitude */

   RTXCTXTPUSHELEMNAME (pctxt, "directionOfAltitude");

   stat = asn1PE_lppa_E_UTRANAccessPointPosition_directionOfAltitude (pctxt, pvalue->directionOfAltitude);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode altitude */

   RTXCTXTPUSHELEMNAME (pctxt, "altitude");

   if ( pvalue->altitude <= 32767 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->altitude, 0, 32767);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->altitude);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uncertaintySemi_major */

   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintySemi-major");

   if ( pvalue->uncertaintySemi_major <= 127 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->uncertaintySemi_major, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->uncertaintySemi_major);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uncertaintySemi_minor */

   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintySemi-minor");

   if ( pvalue->uncertaintySemi_minor <= 127 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->uncertaintySemi_minor, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->uncertaintySemi_minor);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode orientationOfMajorAxis */

   RTXCTXTPUSHELEMNAME (pctxt, "orientationOfMajorAxis");

   if ( pvalue->orientationOfMajorAxis <= 179 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->orientationOfMajorAxis, 0, 179);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->orientationOfMajorAxis);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uncertaintyAltitude */

   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintyAltitude");

   if ( pvalue->uncertaintyAltitude <= 127 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->uncertaintyAltitude, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->uncertaintyAltitude);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode confidence */

   RTXCTXTPUSHELEMNAME (pctxt, "confidence");

   if ( pvalue->confidence <= 100 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->confidence, 0, 100);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->confidence);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_E_UTRANAccessPointPosition (OSCTXT* pctxt, lppa_E_UTRANAccessPointPosition* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-UTRANAccessPointPosition");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode latitudeSign */
   RTXCTXTPUSHELEMNAME (pctxt, "latitudeSign");

   stat = asn1PD_lppa_E_UTRANAccessPointPosition_latitudeSign (pctxt, &pvalue->latitudeSign);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode latitude */
   RTXCTXTPUSHELEMNAME (pctxt, "latitude");

   stat = pd_ConsUnsigned (pctxt, &pvalue->latitude, 0, 8388607);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode longitude */
   RTXCTXTPUSHELEMNAME (pctxt, "longitude");

   stat = pd_ConsInteger (pctxt, &pvalue->longitude, -8388608, 8388607);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode directionOfAltitude */
   RTXCTXTPUSHELEMNAME (pctxt, "directionOfAltitude");

   stat = asn1PD_lppa_E_UTRANAccessPointPosition_directionOfAltitude (pctxt, &pvalue->directionOfAltitude);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode altitude */
   RTXCTXTPUSHELEMNAME (pctxt, "altitude");

   stat = pd_ConsUInt16 (pctxt, &pvalue->altitude, 0, 32767);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uncertaintySemi_major */
   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintySemi-major");

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintySemi_major, 0, 127);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uncertaintySemi_minor */
   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintySemi-minor");

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintySemi_minor, 0, 127);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode orientationOfMajorAxis */
   RTXCTXTPUSHELEMNAME (pctxt, "orientationOfMajorAxis");

   stat = pd_ConsUInt8 (pctxt, &pvalue->orientationOfMajorAxis, 0, 179);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uncertaintyAltitude */
   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintyAltitude");

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintyAltitude, 0, 127);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode confidence */
   RTXCTXTPUSHELEMNAME (pctxt, "confidence");

   stat = pd_ConsUInt8 (pctxt, &pvalue->confidence, 0, 100);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_E_UTRANAccessPointPosition (
   lppa_E_UTRANAccessPointPosition* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_E_UTRANAccessPointPosition (OSCTXT *pctxt, 
   lppa_E_UTRANAccessPointPosition* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_PCI (OSCTXT* pctxt, lppa_PCI value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PCI");

   if ( value <= 503 ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, 503);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_PCI (OSCTXT* pctxt, lppa_PCI* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PCI");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 503);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_EARFCN (OSCTXT* pctxt, lppa_EARFCN value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "EARFCN");

   if ( value <= 65535 ) {
      extbit = 0;
   }
   else if ( (value >= 65536 && value <= 262143) ) {
      extbit = 1;
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_EARFCN (OSCTXT* pctxt, lppa_EARFCN* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "EARFCN");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 65535);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_ValueRSRP (OSCTXT* pctxt, lppa_ValueRSRP value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ValueRSRP");

   if ( value <= 97 ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, 97);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ValueRSRP (OSCTXT* pctxt, lppa_ValueRSRP* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ValueRSRP");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 97);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_ResultRSRP_Item_iE_Extensions_element (OSCTXT* pctxt, lppa_ResultRSRP_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode extensionValue */

   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pe_OpenType (pctxt, pvalue->extensionValue.numocts, pvalue->extensionValue.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ResultRSRP_Item_iE_Extensions_element (OSCTXT* pctxt, lppa_ResultRSRP_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ResultRSRP_Item_iE_Extensions_element (
   lppa_ResultRSRP_Item_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->extensionValue.numocts = 0;
   pvalue->extensionValue.data = 0;
   return 0;
}

void asn1Free_lppa_ResultRSRP_Item_iE_Extensions_element (OSCTXT *pctxt, 
   lppa_ResultRSRP_Item_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->extensionValue.data);
   }
}

EXTERN int asn1PE_lppa_ResultRSRP_Item_iE_Extensions (OSCTXT* pctxt, lppa_ResultRSRP_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_ResultRSRP_Item_iE_Extensions_element (pctxt, ((lppa_ResultRSRP_Item_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_ResultRSRP_Item_iE_Extensions (OSCTXT* pctxt, lppa_ResultRSRP_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_ResultRSRP_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_ResultRSRP_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_ResultRSRP_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_ResultRSRP_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_ResultRSRP_Item_iE_Extensions (
   lppa_ResultRSRP_Item_iE_Extensions* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_ResultRSRP_Item_iE_Extensions (OSCTXT *pctxt, 
   lppa_ResultRSRP_Item_iE_Extensions* pvalue)
{
   if (0 == pvalue) return;
   { lppa_ResultRSRP_Item_iE_Extensions_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_ResultRSRP_Item_iE_Extensions_element*)pnode->data;
      asn1Free_lppa_ResultRSRP_Item_iE_Extensions_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_ResultRSRP_Item (OSCTXT* pctxt, lppa_ResultRSRP_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ResultRSRP-Item");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.eCGIPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pCI */

   RTXCTXTPUSHELEMNAME (pctxt, "pCI");

   stat = asn1PE_lppa_PCI (pctxt, pvalue->pCI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode eARFCN */

   RTXCTXTPUSHELEMNAME (pctxt, "eARFCN");

   stat = asn1PE_lppa_EARFCN (pctxt, pvalue->eARFCN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode eCGI */

   if (pvalue->m.eCGIPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "eCGI");

      stat = asn1PE_lppa_ECGI (pctxt, &pvalue->eCGI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode valueRSRP */

   RTXCTXTPUSHELEMNAME (pctxt, "valueRSRP");

   stat = asn1PE_lppa_ValueRSRP (pctxt, pvalue->valueRSRP);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_lppa_ResultRSRP_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ResultRSRP_Item (OSCTXT* pctxt, lppa_ResultRSRP_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "ResultRSRP-Item");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pCI */
   RTXCTXTPUSHELEMNAME (pctxt, "pCI");

   stat = asn1PD_lppa_PCI (pctxt, &pvalue->pCI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode eARFCN */
   RTXCTXTPUSHELEMNAME (pctxt, "eARFCN");

   stat = asn1PD_lppa_EARFCN (pctxt, &pvalue->eARFCN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode eCGI */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "eCGI");

      pvalue->m.eCGIPresent = 1;

      stat = asn1PD_lppa_ECGI (pctxt, &pvalue->eCGI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode valueRSRP */
   RTXCTXTPUSHELEMNAME (pctxt, "valueRSRP");

   stat = asn1PD_lppa_ValueRSRP (pctxt, &pvalue->valueRSRP);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_lppa_ResultRSRP_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ResultRSRP_Item (lppa_ResultRSRP_Item* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_lppa_ECGI (&pvalue->eCGI);
   asn1Init_lppa_ResultRSRP_Item_iE_Extensions (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_ResultRSRP_Item (OSCTXT *pctxt, 
   lppa_ResultRSRP_Item* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.eCGIPresent) {
      asn1Free_lppa_ECGI (pctxt, &pvalue->eCGI);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_lppa_ResultRSRP_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_ResultRSRP (OSCTXT* pctxt, lppa_ResultRSRP* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "ResultRSRP");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(9), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ResultRSRP-Item", xx1);

      stat = asn1PE_lppa_ResultRSRP_Item (pctxt, ((lppa_ResultRSRP_Item*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ResultRSRP (OSCTXT* pctxt, lppa_ResultRSRP* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ResultRSRP");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(9), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_ResultRSRP_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ResultRSRP-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_ResultRSRP_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_ResultRSRP_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_ResultRSRP_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ResultRSRP (lppa_ResultRSRP* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_ResultRSRP (OSCTXT *pctxt, lppa_ResultRSRP* pvalue)
{
   if (0 == pvalue) return;
   { lppa_ResultRSRP_Item* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_ResultRSRP_Item*)pnode->data;
      asn1Free_lppa_ResultRSRP_Item (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_ValueRSRQ (OSCTXT* pctxt, lppa_ValueRSRQ value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ValueRSRQ");

   if ( value <= 34 ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, 34);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ValueRSRQ (OSCTXT* pctxt, lppa_ValueRSRQ* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ValueRSRQ");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 34);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_ResultRSRQ_Item_iE_Extensions_element (OSCTXT* pctxt, lppa_ResultRSRQ_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode extensionValue */

   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pe_OpenType (pctxt, pvalue->extensionValue.numocts, pvalue->extensionValue.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ResultRSRQ_Item_iE_Extensions_element (OSCTXT* pctxt, lppa_ResultRSRQ_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ResultRSRQ_Item_iE_Extensions_element (
   lppa_ResultRSRQ_Item_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->extensionValue.numocts = 0;
   pvalue->extensionValue.data = 0;
   return 0;
}

void asn1Free_lppa_ResultRSRQ_Item_iE_Extensions_element (OSCTXT *pctxt, 
   lppa_ResultRSRQ_Item_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->extensionValue.data);
   }
}

EXTERN int asn1PE_lppa_ResultRSRQ_Item_iE_Extensions (OSCTXT* pctxt, lppa_ResultRSRQ_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_ResultRSRQ_Item_iE_Extensions_element (pctxt, ((lppa_ResultRSRQ_Item_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_ResultRSRQ_Item_iE_Extensions (OSCTXT* pctxt, lppa_ResultRSRQ_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_ResultRSRQ_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_ResultRSRQ_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_ResultRSRQ_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_ResultRSRQ_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_ResultRSRQ_Item_iE_Extensions (
   lppa_ResultRSRQ_Item_iE_Extensions* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_ResultRSRQ_Item_iE_Extensions (OSCTXT *pctxt, 
   lppa_ResultRSRQ_Item_iE_Extensions* pvalue)
{
   if (0 == pvalue) return;
   { lppa_ResultRSRQ_Item_iE_Extensions_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_ResultRSRQ_Item_iE_Extensions_element*)pnode->data;
      asn1Free_lppa_ResultRSRQ_Item_iE_Extensions_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_ResultRSRQ_Item (OSCTXT* pctxt, lppa_ResultRSRQ_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ResultRSRQ-Item");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.eCGIPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pCI */

   RTXCTXTPUSHELEMNAME (pctxt, "pCI");

   stat = asn1PE_lppa_PCI (pctxt, pvalue->pCI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode eARFCN */

   RTXCTXTPUSHELEMNAME (pctxt, "eARFCN");

   stat = asn1PE_lppa_EARFCN (pctxt, pvalue->eARFCN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode eCGI */

   if (pvalue->m.eCGIPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "eCGI");

      stat = asn1PE_lppa_ECGI (pctxt, &pvalue->eCGI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode valueRSRQ */

   RTXCTXTPUSHELEMNAME (pctxt, "valueRSRQ");

   stat = asn1PE_lppa_ValueRSRQ (pctxt, pvalue->valueRSRQ);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_lppa_ResultRSRQ_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ResultRSRQ_Item (OSCTXT* pctxt, lppa_ResultRSRQ_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "ResultRSRQ-Item");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pCI */
   RTXCTXTPUSHELEMNAME (pctxt, "pCI");

   stat = asn1PD_lppa_PCI (pctxt, &pvalue->pCI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode eARFCN */
   RTXCTXTPUSHELEMNAME (pctxt, "eARFCN");

   stat = asn1PD_lppa_EARFCN (pctxt, &pvalue->eARFCN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode eCGI */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "eCGI");

      pvalue->m.eCGIPresent = 1;

      stat = asn1PD_lppa_ECGI (pctxt, &pvalue->eCGI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode valueRSRQ */
   RTXCTXTPUSHELEMNAME (pctxt, "valueRSRQ");

   stat = asn1PD_lppa_ValueRSRQ (pctxt, &pvalue->valueRSRQ);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_lppa_ResultRSRQ_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ResultRSRQ_Item (lppa_ResultRSRQ_Item* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_lppa_ECGI (&pvalue->eCGI);
   asn1Init_lppa_ResultRSRQ_Item_iE_Extensions (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_ResultRSRQ_Item (OSCTXT *pctxt, 
   lppa_ResultRSRQ_Item* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.eCGIPresent) {
      asn1Free_lppa_ECGI (pctxt, &pvalue->eCGI);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_lppa_ResultRSRQ_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_ResultRSRQ (OSCTXT* pctxt, lppa_ResultRSRQ* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "ResultRSRQ");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(9), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ResultRSRQ-Item", xx1);

      stat = asn1PE_lppa_ResultRSRQ_Item (pctxt, ((lppa_ResultRSRQ_Item*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ResultRSRQ (OSCTXT* pctxt, lppa_ResultRSRQ* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ResultRSRQ");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(9), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_ResultRSRQ_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ResultRSRQ-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_ResultRSRQ_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_ResultRSRQ_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_ResultRSRQ_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ResultRSRQ (lppa_ResultRSRQ* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_ResultRSRQ (OSCTXT *pctxt, lppa_ResultRSRQ* pvalue)
{
   if (0 == pvalue) return;
   { lppa_ResultRSRQ_Item* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_ResultRSRQ_Item*)pnode->data;
      asn1Free_lppa_ResultRSRQ_Item (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_MeasuredResultsValue (OSCTXT* pctxt, lppa_MeasuredResultsValue* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasuredResultsValue");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 5);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 4);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* valueAngleOfArrival */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "valueAngleOfArrival");

            if ( pvalue->u.valueAngleOfArrival <= 719 ) {
               stat = pe_ConsUnsigned (pctxt, pvalue->u.valueAngleOfArrival, 0, 719);
               if (stat != 0) return LOG_RTERR (pctxt, stat);
            }
            else {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddUIntParm (pctxt, pvalue->u.valueAngleOfArrival);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* valueTimingAdvanceType1 */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "valueTimingAdvanceType1");

            if ( pvalue->u.valueTimingAdvanceType1 <= 7690 ) {
               stat = pe_ConsUnsigned (pctxt, pvalue->u.valueTimingAdvanceType1, 0, 7690);
               if (stat != 0) return LOG_RTERR (pctxt, stat);
            }
            else {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddUIntParm (pctxt, pvalue->u.valueTimingAdvanceType1);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* valueTimingAdvanceType2 */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "valueTimingAdvanceType2");

            if ( pvalue->u.valueTimingAdvanceType2 <= 7690 ) {
               stat = pe_ConsUnsigned (pctxt, pvalue->u.valueTimingAdvanceType2, 0, 7690);
               if (stat != 0) return LOG_RTERR (pctxt, stat);
            }
            else {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddUIntParm (pctxt, pvalue->u.valueTimingAdvanceType2);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* resultRSRP */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "resultRSRP");

            stat = asn1PE_lppa_ResultRSRP (pctxt, pvalue->u.resultRSRP);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* resultRSRQ */
         case 5:
            RTXCTXTPUSHELEMNAME (pctxt, "resultRSRQ");

            stat = asn1PE_lppa_ResultRSRQ (pctxt, pvalue->u.resultRSRQ);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 6);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_MeasuredResultsValue (OSCTXT* pctxt, lppa_MeasuredResultsValue* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasuredResultsValue");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* valueAngleOfArrival */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "valueAngleOfArrival");

            stat = pd_ConsUInt16 (pctxt, &pvalue->u.valueAngleOfArrival, 0, 719);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* valueTimingAdvanceType1 */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "valueTimingAdvanceType1");

            stat = pd_ConsUInt16 (pctxt, &pvalue->u.valueTimingAdvanceType1, 0, 7690);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* valueTimingAdvanceType2 */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "valueTimingAdvanceType2");

            stat = pd_ConsUInt16 (pctxt, &pvalue->u.valueTimingAdvanceType2, 0, 7690);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* resultRSRP */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "resultRSRP");

            pvalue->u.resultRSRP = rtxMemAllocType (pctxt, lppa_ResultRSRP);

            if (pvalue->u.resultRSRP == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_lppa_ResultRSRP (pvalue->u.resultRSRP);

            stat = asn1PD_lppa_ResultRSRP (pctxt, pvalue->u.resultRSRP);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* resultRSRQ */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "resultRSRQ");

            pvalue->u.resultRSRQ = rtxMemAllocType (pctxt, lppa_ResultRSRQ);

            if (pvalue->u.resultRSRQ == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_lppa_ResultRSRQ (pvalue->u.resultRSRQ);

            stat = asn1PD_lppa_ResultRSRQ (pctxt, pvalue->u.resultRSRQ);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 6;

      if (pvalue->t < 6) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_MeasuredResultsValue (lppa_MeasuredResultsValue* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_lppa_MeasuredResultsValue (OSCTXT *pctxt, 
   lppa_MeasuredResultsValue* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         break;

      case 4:
         if (0 != pvalue->u.resultRSRP) {
            asn1Free_lppa_ResultRSRP (pctxt, pvalue->u.resultRSRP);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.resultRSRP);
            pvalue->u.resultRSRP = 0;
         }
         break;

      case 5:
         if (0 != pvalue->u.resultRSRQ) {
            asn1Free_lppa_ResultRSRQ (pctxt, pvalue->u.resultRSRQ);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.resultRSRQ);
            pvalue->u.resultRSRQ = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_lppa_MeasuredResults (OSCTXT* pctxt, lppa_MeasuredResults* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasuredResults");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(63), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasuredResultsValue", xx1);

      stat = asn1PE_lppa_MeasuredResultsValue (pctxt, ((lppa_MeasuredResultsValue*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_MeasuredResults (OSCTXT* pctxt, lppa_MeasuredResults* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasuredResults");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(63), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_MeasuredResultsValue* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasuredResultsValue", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_MeasuredResultsValue, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_MeasuredResultsValue (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_MeasuredResultsValue (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_MeasuredResults (lppa_MeasuredResults* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_MeasuredResults (OSCTXT *pctxt, 
   lppa_MeasuredResults* pvalue)
{
   if (0 == pvalue) return;
   { lppa_MeasuredResultsValue* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_MeasuredResultsValue*)pnode->data;
      asn1Free_lppa_MeasuredResultsValue (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_E_CID_MeasurementResult (OSCTXT* pctxt, lppa_E_CID_MeasurementResult* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-CID-MeasurementResult");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.e_UTRANAccessPointPositionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measuredResultsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode servingCell_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "servingCell-ID");

   stat = asn1PE_lppa_ECGI (pctxt, &pvalue->servingCell_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode servingCellTAC */

   RTXCTXTPUSHELEMNAME (pctxt, "servingCellTAC");

   stat = asn1PE_lppa_TAC (pctxt, &pvalue->servingCellTAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode e_UTRANAccessPointPosition */

   if (pvalue->m.e_UTRANAccessPointPositionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-UTRANAccessPointPosition");

      stat = asn1PE_lppa_E_UTRANAccessPointPosition (pctxt, &pvalue->e_UTRANAccessPointPosition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode measuredResults */

   if (pvalue->m.measuredResultsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "measuredResults");

      stat = asn1PE_lppa_MeasuredResults (pctxt, &pvalue->measuredResults);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_E_CID_MeasurementResult (OSCTXT* pctxt, lppa_E_CID_MeasurementResult* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "E-CID-MeasurementResult");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode servingCell_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "servingCell-ID");

   stat = asn1PD_lppa_ECGI (pctxt, &pvalue->servingCell_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode servingCellTAC */
   RTXCTXTPUSHELEMNAME (pctxt, "servingCellTAC");

   stat = asn1PD_lppa_TAC (pctxt, &pvalue->servingCellTAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_UTRANAccessPointPosition */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-UTRANAccessPointPosition");

      pvalue->m.e_UTRANAccessPointPositionPresent = 1;

      stat = asn1PD_lppa_E_UTRANAccessPointPosition (pctxt, &pvalue->e_UTRANAccessPointPosition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measuredResults */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measuredResults");

      pvalue->m.measuredResultsPresent = 1;

      stat = asn1PD_lppa_MeasuredResults (pctxt, &pvalue->measuredResults);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_E_CID_MeasurementResult (
   lppa_E_CID_MeasurementResult* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_lppa_ECGI (&pvalue->servingCell_ID);
   asn1Init_lppa_TAC (&pvalue->servingCellTAC);
   asn1Init_lppa_E_UTRANAccessPointPosition (&pvalue->e_UTRANAccessPointPosition);
   asn1Init_lppa_MeasuredResults (&pvalue->measuredResults);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_E_CID_MeasurementResult (OSCTXT *pctxt, 
   lppa_E_CID_MeasurementResult* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_ECGI (pctxt, &pvalue->servingCell_ID);
   if (pvalue->m.e_UTRANAccessPointPositionPresent) {
      asn1Free_lppa_E_UTRANAccessPointPosition (pctxt, &pvalue->e_UTRANAccessPointPosition);
   }
   if (pvalue->m.measuredResultsPresent) {
      asn1Free_lppa_MeasuredResults (pctxt, &pvalue->measuredResults);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_Cell_Portion_ID (OSCTXT* pctxt, lppa_Cell_Portion_ID value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Cell-Portion-ID");

   if ( value <= 255 ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, 255);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_Cell_Portion_ID (OSCTXT* pctxt, lppa_Cell_Portion_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Cell-Portion-ID");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 255);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem lppa_TypeOfError_ENUMTAB[] = {
   { OSUTF8("missing"), 1, 7, 1 },
   { OSUTF8("not-understood"), 0, 14, 0 }
} ;
#define lppa_TypeOfError_ENUMTABSIZE 2

const OSUTF8CHAR* lppa_TypeOfError_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_TypeOfError_ENUMTABSIZE) {
      return lppa_TypeOfError_ENUMTAB
         [lppa_TypeOfError_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_TypeOfError_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_TypeOfError* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_TypeOfError_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_TypeOfError_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, lppa_TypeOfError* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, lppa_TypeOfError_ENUMTAB, 
      lppa_TypeOfError_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_TypeOfError)lppa_TypeOfError_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_TypeOfError (OSCTXT* pctxt, lppa_TypeOfError value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TypeOfError");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_TypeOfError (OSCTXT* pctxt, lppa_TypeOfError* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TypeOfError");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (OSCTXT* pctxt, lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode extensionValue */

   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pe_OpenType (pctxt, pvalue->extensionValue.numocts, pvalue->extensionValue.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (OSCTXT* pctxt, lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (
   lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->extensionValue.numocts = 0;
   pvalue->extensionValue.data = 0;
   return 0;
}

void asn1Free_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (OSCTXT *pctxt, 
   lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->extensionValue.data);
   }
}

EXTERN int asn1PE_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions (OSCTXT* pctxt, lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (pctxt, ((lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions (OSCTXT* pctxt, lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions (
   lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions (OSCTXT *pctxt, 
   lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions* pvalue)
{
   if (0 == pvalue) return;
   { lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element*)pnode->data;
      asn1Free_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_CriticalityDiagnostics_IE_List_element (OSCTXT* pctxt, lppa_CriticalityDiagnostics_IE_List_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iECriticality */

   RTXCTXTPUSHELEMNAME (pctxt, "iECriticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->iECriticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "iE-ID");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->iE_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode typeOfError */

   RTXCTXTPUSHELEMNAME (pctxt, "typeOfError");

   stat = asn1PE_lppa_TypeOfError (pctxt, pvalue->typeOfError);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_lppa_CriticalityDiagnostics_IE_List_element (OSCTXT* pctxt, lppa_CriticalityDiagnostics_IE_List_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode iECriticality */
   RTXCTXTPUSHELEMNAME (pctxt, "iECriticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->iECriticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "iE-ID");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->iE_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode typeOfError */
   RTXCTXTPUSHELEMNAME (pctxt, "typeOfError");

   stat = asn1PD_lppa_TypeOfError (pctxt, &pvalue->typeOfError);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_lppa_CriticalityDiagnostics_IE_List_element (
   lppa_CriticalityDiagnostics_IE_List_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_CriticalityDiagnostics_IE_List_element (OSCTXT *pctxt, 
   lppa_CriticalityDiagnostics_IE_List_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_CriticalityDiagnostics_IE_List (OSCTXT* pctxt, lppa_CriticalityDiagnostics_IE_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CriticalityDiagnostics-IE-List");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_CriticalityDiagnostics_IE_List_element (pctxt, ((lppa_CriticalityDiagnostics_IE_List_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_CriticalityDiagnostics_IE_List (OSCTXT* pctxt, lppa_CriticalityDiagnostics_IE_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CriticalityDiagnostics-IE-List");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_CriticalityDiagnostics_IE_List_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_CriticalityDiagnostics_IE_List_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_CriticalityDiagnostics_IE_List_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_CriticalityDiagnostics_IE_List_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_CriticalityDiagnostics_IE_List (
   lppa_CriticalityDiagnostics_IE_List* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_CriticalityDiagnostics_IE_List (OSCTXT *pctxt, 
   lppa_CriticalityDiagnostics_IE_List* pvalue)
{
   if (0 == pvalue) return;
   { lppa_CriticalityDiagnostics_IE_List_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_CriticalityDiagnostics_IE_List_element*)pnode->data;
      asn1Free_lppa_CriticalityDiagnostics_IE_List_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_CriticalityDiagnostics_iE_Extensions_element (OSCTXT* pctxt, lppa_CriticalityDiagnostics_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode extensionValue */

   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pe_OpenType (pctxt, pvalue->extensionValue.numocts, pvalue->extensionValue.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_CriticalityDiagnostics_iE_Extensions_element (OSCTXT* pctxt, lppa_CriticalityDiagnostics_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_CriticalityDiagnostics_iE_Extensions_element (
   lppa_CriticalityDiagnostics_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->extensionValue.numocts = 0;
   pvalue->extensionValue.data = 0;
   return 0;
}

void asn1Free_lppa_CriticalityDiagnostics_iE_Extensions_element (OSCTXT *pctxt, 
   lppa_CriticalityDiagnostics_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->extensionValue.data);
   }
}

EXTERN int asn1PE_lppa_CriticalityDiagnostics_iE_Extensions (OSCTXT* pctxt, lppa_CriticalityDiagnostics_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_CriticalityDiagnostics_iE_Extensions_element (pctxt, ((lppa_CriticalityDiagnostics_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_CriticalityDiagnostics_iE_Extensions (OSCTXT* pctxt, lppa_CriticalityDiagnostics_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_CriticalityDiagnostics_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_CriticalityDiagnostics_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_CriticalityDiagnostics_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_CriticalityDiagnostics_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_CriticalityDiagnostics_iE_Extensions (
   lppa_CriticalityDiagnostics_iE_Extensions* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_CriticalityDiagnostics_iE_Extensions (OSCTXT *pctxt, 
   lppa_CriticalityDiagnostics_iE_Extensions* pvalue)
{
   if (0 == pvalue) return;
   { lppa_CriticalityDiagnostics_iE_Extensions_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_CriticalityDiagnostics_iE_Extensions_element*)pnode->data;
      asn1Free_lppa_CriticalityDiagnostics_iE_Extensions_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_CriticalityDiagnostics (OSCTXT* pctxt, lppa_CriticalityDiagnostics* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CriticalityDiagnostics");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.procedureCodePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.triggeringMessagePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.procedureCriticalityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lppatransactionIDPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iEsCriticalityDiagnosticsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode procedureCode */

   if (pvalue->m.procedureCodePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

      stat = asn1PE_lppa_ProcedureCode (pctxt, pvalue->procedureCode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode triggeringMessage */

   if (pvalue->m.triggeringMessagePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "triggeringMessage");

      stat = asn1PE_lppa_TriggeringMessage (pctxt, pvalue->triggeringMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode procedureCriticality */

   if (pvalue->m.procedureCriticalityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "procedureCriticality");

      stat = asn1PE_lppa_Criticality (pctxt, pvalue->procedureCriticality);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode lppatransactionID */

   if (pvalue->m.lppatransactionIDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lppatransactionID");

      stat = asn1PE_lppa_LPPATransactionID (pctxt, pvalue->lppatransactionID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iEsCriticalityDiagnostics */

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iEsCriticalityDiagnostics");

      stat = asn1PE_lppa_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_lppa_CriticalityDiagnostics_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_CriticalityDiagnostics (OSCTXT* pctxt, lppa_CriticalityDiagnostics* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[6];

   RTXCTXTPUSHTYPENAME (pctxt, "CriticalityDiagnostics");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode procedureCode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

      pvalue->m.procedureCodePresent = 1;

      stat = asn1PD_lppa_ProcedureCode (pctxt, &pvalue->procedureCode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode triggeringMessage */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "triggeringMessage");

      pvalue->m.triggeringMessagePresent = 1;

      stat = asn1PD_lppa_TriggeringMessage (pctxt, &pvalue->triggeringMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode procedureCriticality */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "procedureCriticality");

      pvalue->m.procedureCriticalityPresent = 1;

      stat = asn1PD_lppa_Criticality (pctxt, &pvalue->procedureCriticality);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode lppatransactionID */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lppatransactionID");

      pvalue->m.lppatransactionIDPresent = 1;

      stat = asn1PD_lppa_LPPATransactionID (pctxt, &pvalue->lppatransactionID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iEsCriticalityDiagnostics */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iEsCriticalityDiagnostics");

      pvalue->m.iEsCriticalityDiagnosticsPresent = 1;

      stat = asn1PD_lppa_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_lppa_CriticalityDiagnostics_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_CriticalityDiagnostics (lppa_CriticalityDiagnostics* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_lppa_CriticalityDiagnostics_IE_List (&pvalue->iEsCriticalityDiagnostics);
   asn1Init_lppa_CriticalityDiagnostics_iE_Extensions (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_CriticalityDiagnostics (OSCTXT *pctxt, 
   lppa_CriticalityDiagnostics* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      asn1Free_lppa_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_lppa_CriticalityDiagnostics_iE_Extensions (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

static const OSEnumItem lppa_SRSConfigurationForOneCell_ul_bandwidth_ENUMTAB[] = {
   { OSUTF8("n100"), 5, 4, 4 },
   { OSUTF8("n15"), 1, 3, 1 },
   { OSUTF8("n25"), 2, 3, 2 },
   { OSUTF8("n50"), 3, 3, 3 },
   { OSUTF8("n6"), 0, 2, 5 },
   { OSUTF8("n75"), 4, 3, 0 }
} ;
#define lppa_SRSConfigurationForOneCell_ul_bandwidth_ENUMTABSIZE 6

const OSUTF8CHAR* lppa_SRSConfigurationForOneCell_ul_bandwidth_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_SRSConfigurationForOneCell_ul_bandwidth_ENUMTABSIZE) {
      return lppa_SRSConfigurationForOneCell_ul_bandwidth_ENUMTAB
         [lppa_SRSConfigurationForOneCell_ul_bandwidth_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_SRSConfigurationForOneCell_ul_bandwidth_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      lppa_SRSConfigurationForOneCell_ul_bandwidth* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_SRSConfigurationForOneCell_ul_bandwidth_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_SRSConfigurationForOneCell_ul_bandwidth_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      lppa_SRSConfigurationForOneCell_ul_bandwidth* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_SRSConfigurationForOneCell_ul_bandwidth_ENUMTAB, 
      lppa_SRSConfigurationForOneCell_ul_bandwidth_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_SRSConfigurationForOneCell_ul_bandwidth)
         lppa_SRSConfigurationForOneCell_ul_bandwidth_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_SRSConfigurationForOneCell_ul_bandwidth (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell_ul_bandwidth value)
{
   int stat = 0;

   if (value >= 6) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_lppa_SRSConfigurationForOneCell_ul_bandwidth (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell_ul_bandwidth* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem lppa_CPLength_ENUMTAB[] = {
   { OSUTF8("extended"), 1, 8, 1 },
   { OSUTF8("normal"), 0, 6, 0 }
} ;
#define lppa_CPLength_ENUMTABSIZE 2

const OSUTF8CHAR* lppa_CPLength_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_CPLength_ENUMTABSIZE) {
      return lppa_CPLength_ENUMTAB[lppa_CPLength_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_CPLength_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_CPLength* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_CPLength_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_CPLength_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, lppa_CPLength* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, lppa_CPLength_ENUMTAB, 
      lppa_CPLength_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_CPLength)lppa_CPLength_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_CPLength (OSCTXT* pctxt, lppa_CPLength value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CPLength");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_CPLength (OSCTXT* pctxt, lppa_CPLength* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CPLength");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem lppa_SRSConfigurationForOneCell_srs_BandwidthConfig_ENUMTAB[] = {
   { OSUTF8("bw0"), 0, 3, 0 },
   { OSUTF8("bw1"), 1, 3, 1 },
   { OSUTF8("bw2"), 2, 3, 2 },
   { OSUTF8("bw3"), 3, 3, 3 },
   { OSUTF8("bw4"), 4, 3, 4 },
   { OSUTF8("bw5"), 5, 3, 5 },
   { OSUTF8("bw6"), 6, 3, 6 },
   { OSUTF8("bw7"), 7, 3, 7 }
} ;
#define lppa_SRSConfigurationForOneCell_srs_BandwidthConfig_ENUMTABSIZE 8

const OSUTF8CHAR* lppa_SRSConfigurationForOneCell_srs_BandwidthConfig_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_SRSConfigurationForOneCell_srs_BandwidthConfig_ENUMTABSIZE) {
      return lppa_SRSConfigurationForOneCell_srs_BandwidthConfig_ENUMTAB
         [lppa_SRSConfigurationForOneCell_srs_BandwidthConfig_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_SRSConfigurationForOneCell_srs_BandwidthConfig_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      lppa_SRSConfigurationForOneCell_srs_BandwidthConfig* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_SRSConfigurationForOneCell_srs_BandwidthConfig_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_SRSConfigurationForOneCell_srs_BandwidthConfig_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      lppa_SRSConfigurationForOneCell_srs_BandwidthConfig* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_SRSConfigurationForOneCell_srs_BandwidthConfig_ENUMTAB, 
      lppa_SRSConfigurationForOneCell_srs_BandwidthConfig_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_SRSConfigurationForOneCell_srs_BandwidthConfig)
         lppa_SRSConfigurationForOneCell_srs_BandwidthConfig_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_SRSConfigurationForOneCell_srs_BandwidthConfig (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell_srs_BandwidthConfig value)
{
   int stat = 0;

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_lppa_SRSConfigurationForOneCell_srs_BandwidthConfig (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell_srs_BandwidthConfig* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem lppa_SRSConfigurationForOneCell_srs_Bandwidth_ENUMTAB[] = {
   { OSUTF8("bw0"), 0, 3, 0 },
   { OSUTF8("bw1"), 1, 3, 1 },
   { OSUTF8("bw2"), 2, 3, 2 },
   { OSUTF8("bw3"), 3, 3, 3 }
} ;
#define lppa_SRSConfigurationForOneCell_srs_Bandwidth_ENUMTABSIZE 4

const OSUTF8CHAR* lppa_SRSConfigurationForOneCell_srs_Bandwidth_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_SRSConfigurationForOneCell_srs_Bandwidth_ENUMTABSIZE) {
      return lppa_SRSConfigurationForOneCell_srs_Bandwidth_ENUMTAB
         [lppa_SRSConfigurationForOneCell_srs_Bandwidth_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_SRSConfigurationForOneCell_srs_Bandwidth_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      lppa_SRSConfigurationForOneCell_srs_Bandwidth* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_SRSConfigurationForOneCell_srs_Bandwidth_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_SRSConfigurationForOneCell_srs_Bandwidth_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      lppa_SRSConfigurationForOneCell_srs_Bandwidth* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_SRSConfigurationForOneCell_srs_Bandwidth_ENUMTAB, 
      lppa_SRSConfigurationForOneCell_srs_Bandwidth_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_SRSConfigurationForOneCell_srs_Bandwidth)
         lppa_SRSConfigurationForOneCell_srs_Bandwidth_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_SRSConfigurationForOneCell_srs_Bandwidth (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell_srs_Bandwidth value)
{
   int stat = 0;

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_lppa_SRSConfigurationForOneCell_srs_Bandwidth (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell_srs_Bandwidth* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem lppa_SRSConfigurationForOneCell_srs_AntennaPort_ENUMTAB[] = {
   { OSUTF8("an1"), 0, 3, 0 },
   { OSUTF8("an2"), 1, 3, 1 },
   { OSUTF8("an4"), 2, 3, 2 }
} ;
#define lppa_SRSConfigurationForOneCell_srs_AntennaPort_ENUMTABSIZE 3

const OSUTF8CHAR* lppa_SRSConfigurationForOneCell_srs_AntennaPort_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_SRSConfigurationForOneCell_srs_AntennaPort_ENUMTABSIZE) {
      return lppa_SRSConfigurationForOneCell_srs_AntennaPort_ENUMTAB
         [lppa_SRSConfigurationForOneCell_srs_AntennaPort_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_SRSConfigurationForOneCell_srs_AntennaPort_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      lppa_SRSConfigurationForOneCell_srs_AntennaPort* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_SRSConfigurationForOneCell_srs_AntennaPort_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_SRSConfigurationForOneCell_srs_AntennaPort_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      lppa_SRSConfigurationForOneCell_srs_AntennaPort* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_SRSConfigurationForOneCell_srs_AntennaPort_ENUMTAB, 
      lppa_SRSConfigurationForOneCell_srs_AntennaPort_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_SRSConfigurationForOneCell_srs_AntennaPort)
         lppa_SRSConfigurationForOneCell_srs_AntennaPort_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_SRSConfigurationForOneCell_srs_AntennaPort (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell_srs_AntennaPort value)
{
   int stat = 0;

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_lppa_SRSConfigurationForOneCell_srs_AntennaPort (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell_srs_AntennaPort* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

static const OSEnumItem lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth_ENUMTAB[] = {
   { OSUTF8("hbw0"), 0, 4, 0 },
   { OSUTF8("hbw1"), 1, 4, 1 },
   { OSUTF8("hbw2"), 2, 4, 2 },
   { OSUTF8("hbw3"), 3, 4, 3 }
} ;
#define lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth_ENUMTABSIZE 4

const OSUTF8CHAR* lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth_ENUMTABSIZE) {
      return lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth_ENUMTAB
         [lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth_ENUMTAB, 
      lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth)
         lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth value)
{
   int stat = 0;

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem lppa_SRSConfigurationForOneCell_srs_cyclicShift_ENUMTAB[] = {
   { OSUTF8("cs0"), 0, 3, 0 },
   { OSUTF8("cs1"), 1, 3, 1 },
   { OSUTF8("cs2"), 2, 3, 2 },
   { OSUTF8("cs3"), 3, 3, 3 },
   { OSUTF8("cs4"), 4, 3, 4 },
   { OSUTF8("cs5"), 5, 3, 5 },
   { OSUTF8("cs6"), 6, 3, 6 },
   { OSUTF8("cs7"), 7, 3, 7 }
} ;
#define lppa_SRSConfigurationForOneCell_srs_cyclicShift_ENUMTABSIZE 8

const OSUTF8CHAR* lppa_SRSConfigurationForOneCell_srs_cyclicShift_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_SRSConfigurationForOneCell_srs_cyclicShift_ENUMTABSIZE) {
      return lppa_SRSConfigurationForOneCell_srs_cyclicShift_ENUMTAB
         [lppa_SRSConfigurationForOneCell_srs_cyclicShift_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_SRSConfigurationForOneCell_srs_cyclicShift_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      lppa_SRSConfigurationForOneCell_srs_cyclicShift* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_SRSConfigurationForOneCell_srs_cyclicShift_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_SRSConfigurationForOneCell_srs_cyclicShift_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      lppa_SRSConfigurationForOneCell_srs_cyclicShift* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_SRSConfigurationForOneCell_srs_cyclicShift_ENUMTAB, 
      lppa_SRSConfigurationForOneCell_srs_cyclicShift_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_SRSConfigurationForOneCell_srs_cyclicShift)
         lppa_SRSConfigurationForOneCell_srs_cyclicShift_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_SRSConfigurationForOneCell_srs_cyclicShift (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell_srs_cyclicShift value)
{
   int stat = 0;

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_lppa_SRSConfigurationForOneCell_srs_cyclicShift (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell_srs_cyclicShift* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem lppa_SRSConfigurationForOneCell_maxUpPts_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define lppa_SRSConfigurationForOneCell_maxUpPts_ENUMTABSIZE 1

const OSUTF8CHAR* lppa_SRSConfigurationForOneCell_maxUpPts_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      lppa_SRSConfigurationForOneCell_maxUpPts_ENUMTAB, 
      lppa_SRSConfigurationForOneCell_maxUpPts_ENUMTABSIZE);

   if (idx >= 0 && idx < lppa_SRSConfigurationForOneCell_maxUpPts_ENUMTABSIZE) {
      return lppa_SRSConfigurationForOneCell_maxUpPts_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_SRSConfigurationForOneCell_maxUpPts_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_SRSConfigurationForOneCell_maxUpPts* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_SRSConfigurationForOneCell_maxUpPts_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_SRSConfigurationForOneCell_maxUpPts_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      lppa_SRSConfigurationForOneCell_maxUpPts* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_SRSConfigurationForOneCell_maxUpPts_ENUMTAB, 
      lppa_SRSConfigurationForOneCell_maxUpPts_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_SRSConfigurationForOneCell_maxUpPts)
         lppa_SRSConfigurationForOneCell_maxUpPts_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_SRSConfigurationForOneCell_maxUpPts (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell_maxUpPts value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case lppa_true_: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_lppa_SRSConfigurationForOneCell_maxUpPts (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell_maxUpPts* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = lppa_true_; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PE_lppa_SFNInitialisationTime (OSCTXT* pctxt, lppa_SFNInitialisationTime* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SFNInitialisationTime");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(64), OSUINTCONST(64), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_SFNInitialisationTime (OSCTXT* pctxt, lppa_SFNInitialisationTime* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SFNInitialisationTime");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(64), OSUINTCONST(64), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_SFNInitialisationTime (lppa_SFNInitialisationTime* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_lppa_SRSConfigurationForOneCell (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SRSConfigurationForOneCell");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.maxUpPtsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.deltaSSPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pci */

   RTXCTXTPUSHELEMNAME (pctxt, "pci");

   stat = asn1PE_lppa_PCI (pctxt, pvalue->pci);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ul_earfcn */

   RTXCTXTPUSHELEMNAME (pctxt, "ul-earfcn");

   stat = asn1PE_lppa_EARFCN (pctxt, pvalue->ul_earfcn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ul_bandwidth */

   RTXCTXTPUSHELEMNAME (pctxt, "ul-bandwidth");

   stat = asn1PE_lppa_SRSConfigurationForOneCell_ul_bandwidth (pctxt, pvalue->ul_bandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ul_cyclicPrefixLength */

   RTXCTXTPUSHELEMNAME (pctxt, "ul-cyclicPrefixLength");

   stat = asn1PE_lppa_CPLength (pctxt, pvalue->ul_cyclicPrefixLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode srs_BandwidthConfig */

   RTXCTXTPUSHELEMNAME (pctxt, "srs-BandwidthConfig");

   stat = asn1PE_lppa_SRSConfigurationForOneCell_srs_BandwidthConfig (pctxt, pvalue->srs_BandwidthConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode srs_Bandwidth */

   RTXCTXTPUSHELEMNAME (pctxt, "srs-Bandwidth");

   stat = asn1PE_lppa_SRSConfigurationForOneCell_srs_Bandwidth (pctxt, pvalue->srs_Bandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode srs_AntennaPort */

   RTXCTXTPUSHELEMNAME (pctxt, "srs-AntennaPort");

   stat = asn1PE_lppa_SRSConfigurationForOneCell_srs_AntennaPort (pctxt, pvalue->srs_AntennaPort);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode srs_HoppingBandwidth */

   RTXCTXTPUSHELEMNAME (pctxt, "srs-HoppingBandwidth");

   stat = asn1PE_lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth (pctxt, pvalue->srs_HoppingBandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode srs_cyclicShift */

   RTXCTXTPUSHELEMNAME (pctxt, "srs-cyclicShift");

   stat = asn1PE_lppa_SRSConfigurationForOneCell_srs_cyclicShift (pctxt, pvalue->srs_cyclicShift);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode srs_ConfigIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "srs-ConfigIndex");

   if ( pvalue->srs_ConfigIndex <= 1023 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->srs_ConfigIndex, 0, 1023);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->srs_ConfigIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode maxUpPts */

   if (pvalue->m.maxUpPtsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "maxUpPts");

      stat = asn1PE_lppa_SRSConfigurationForOneCell_maxUpPts (pctxt, pvalue->maxUpPts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode transmissionComb */

   RTXCTXTPUSHELEMNAME (pctxt, "transmissionComb");

   if ( pvalue->transmissionComb <= 1 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->transmissionComb, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->transmissionComb);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode freqDomainPosition */

   RTXCTXTPUSHELEMNAME (pctxt, "freqDomainPosition");

   if ( pvalue->freqDomainPosition <= 23 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->freqDomainPosition, 0, 23);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->freqDomainPosition);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode groupHoppingEnabled */

   RTXCTXTPUSHELEMNAME (pctxt, "groupHoppingEnabled");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->groupHoppingEnabled);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode deltaSS */

   if (pvalue->m.deltaSSPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaSS");

      if ( pvalue->deltaSS <= 29 ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->deltaSS, 0, 29);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->deltaSS);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode sfnInitialisationTime */

   RTXCTXTPUSHELEMNAME (pctxt, "sfnInitialisationTime");

   stat = asn1PE_lppa_SFNInitialisationTime (pctxt, &pvalue->sfnInitialisationTime);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_SRSConfigurationForOneCell (OSCTXT* pctxt, lppa_SRSConfigurationForOneCell* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SRSConfigurationForOneCell");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pci */
   RTXCTXTPUSHELEMNAME (pctxt, "pci");

   stat = asn1PD_lppa_PCI (pctxt, &pvalue->pci);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_earfcn */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-earfcn");

   stat = asn1PD_lppa_EARFCN (pctxt, &pvalue->ul_earfcn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_bandwidth */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-bandwidth");

   stat = asn1PD_lppa_SRSConfigurationForOneCell_ul_bandwidth (pctxt, &pvalue->ul_bandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_cyclicPrefixLength */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-cyclicPrefixLength");

   stat = asn1PD_lppa_CPLength (pctxt, &pvalue->ul_cyclicPrefixLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode srs_BandwidthConfig */
   RTXCTXTPUSHELEMNAME (pctxt, "srs-BandwidthConfig");

   stat = asn1PD_lppa_SRSConfigurationForOneCell_srs_BandwidthConfig (pctxt, &pvalue->srs_BandwidthConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode srs_Bandwidth */
   RTXCTXTPUSHELEMNAME (pctxt, "srs-Bandwidth");

   stat = asn1PD_lppa_SRSConfigurationForOneCell_srs_Bandwidth (pctxt, &pvalue->srs_Bandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode srs_AntennaPort */
   RTXCTXTPUSHELEMNAME (pctxt, "srs-AntennaPort");

   stat = asn1PD_lppa_SRSConfigurationForOneCell_srs_AntennaPort (pctxt, &pvalue->srs_AntennaPort);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode srs_HoppingBandwidth */
   RTXCTXTPUSHELEMNAME (pctxt, "srs-HoppingBandwidth");

   stat = asn1PD_lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth (pctxt, &pvalue->srs_HoppingBandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode srs_cyclicShift */
   RTXCTXTPUSHELEMNAME (pctxt, "srs-cyclicShift");

   stat = asn1PD_lppa_SRSConfigurationForOneCell_srs_cyclicShift (pctxt, &pvalue->srs_cyclicShift);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode srs_ConfigIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "srs-ConfigIndex");

   stat = pd_ConsUInt16 (pctxt, &pvalue->srs_ConfigIndex, 0, 1023);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maxUpPts */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "maxUpPts");

      pvalue->m.maxUpPtsPresent = 1;

      stat = asn1PD_lppa_SRSConfigurationForOneCell_maxUpPts (pctxt, &pvalue->maxUpPts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode transmissionComb */
   RTXCTXTPUSHELEMNAME (pctxt, "transmissionComb");

   stat = pd_ConsUInt8 (pctxt, &pvalue->transmissionComb, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode freqDomainPosition */
   RTXCTXTPUSHELEMNAME (pctxt, "freqDomainPosition");

   stat = pd_ConsUInt8 (pctxt, &pvalue->freqDomainPosition, 0, 23);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode groupHoppingEnabled */
   RTXCTXTPUSHELEMNAME (pctxt, "groupHoppingEnabled");

   stat = DEC_BIT (pctxt, &pvalue->groupHoppingEnabled);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaSS */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deltaSS");

      pvalue->m.deltaSSPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->deltaSS, 0, 29);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode sfnInitialisationTime */
   RTXCTXTPUSHELEMNAME (pctxt, "sfnInitialisationTime");

   stat = asn1PD_lppa_SFNInitialisationTime (pctxt, &pvalue->sfnInitialisationTime);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_SRSConfigurationForOneCell (
   lppa_SRSConfigurationForOneCell* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_lppa_SFNInitialisationTime (&pvalue->sfnInitialisationTime);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_SRSConfigurationForOneCell (OSCTXT *pctxt, 
   lppa_SRSConfigurationForOneCell* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_SRSConfigurationForAllCells (OSCTXT* pctxt, lppa_SRSConfigurationForAllCells* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SRSConfigurationForAllCells");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(5), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SRSConfigurationForOneCell", xx1);

      stat = asn1PE_lppa_SRSConfigurationForOneCell (pctxt, ((lppa_SRSConfigurationForOneCell*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_SRSConfigurationForAllCells (OSCTXT* pctxt, lppa_SRSConfigurationForAllCells* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SRSConfigurationForAllCells");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(5), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_SRSConfigurationForOneCell* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SRSConfigurationForOneCell", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_SRSConfigurationForOneCell, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_SRSConfigurationForOneCell (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_SRSConfigurationForOneCell (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_SRSConfigurationForAllCells (
   lppa_SRSConfigurationForAllCells* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_SRSConfigurationForAllCells (OSCTXT *pctxt, 
   lppa_SRSConfigurationForAllCells* pvalue)
{
   if (0 == pvalue) return;
   { lppa_SRSConfigurationForOneCell* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_SRSConfigurationForOneCell*)pnode->data;
      asn1Free_lppa_SRSConfigurationForOneCell (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_ULConfiguration (OSCTXT* pctxt, lppa_ULConfiguration* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ULConfiguration");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.timingAdvanceType1Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.timingAdvanceType2Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pci */

   RTXCTXTPUSHELEMNAME (pctxt, "pci");

   stat = asn1PE_lppa_PCI (pctxt, pvalue->pci);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ul_earfcn */

   RTXCTXTPUSHELEMNAME (pctxt, "ul-earfcn");

   stat = asn1PE_lppa_EARFCN (pctxt, pvalue->ul_earfcn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode timingAdvanceType1 */

   if (pvalue->m.timingAdvanceType1Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "timingAdvanceType1");

      if ( pvalue->timingAdvanceType1 <= 7690 ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->timingAdvanceType1, 0, 7690);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->timingAdvanceType1);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode timingAdvanceType2 */

   if (pvalue->m.timingAdvanceType2Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "timingAdvanceType2");

      if ( pvalue->timingAdvanceType2 <= 7690 ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->timingAdvanceType2, 0, 7690);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->timingAdvanceType2);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode numberOfTransmissions */

   RTXCTXTPUSHELEMNAME (pctxt, "numberOfTransmissions");

   if ( pvalue->numberOfTransmissions <= 500 ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, pvalue->numberOfTransmissions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, pvalue->numberOfTransmissions, 0, 500);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode srsConfiguration */

   RTXCTXTPUSHELEMNAME (pctxt, "srsConfiguration");

   stat = asn1PE_lppa_SRSConfigurationForAllCells (pctxt, &pvalue->srsConfiguration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ULConfiguration (OSCTXT* pctxt, lppa_ULConfiguration* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "ULConfiguration");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pci */
   RTXCTXTPUSHELEMNAME (pctxt, "pci");

   stat = asn1PD_lppa_PCI (pctxt, &pvalue->pci);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_earfcn */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-earfcn");

   stat = asn1PD_lppa_EARFCN (pctxt, &pvalue->ul_earfcn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timingAdvanceType1 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timingAdvanceType1");

      pvalue->m.timingAdvanceType1Present = 1;

      stat = pd_ConsUInt16 (pctxt, &pvalue->timingAdvanceType1, 0, 7690);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode timingAdvanceType2 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timingAdvanceType2");

      pvalue->m.timingAdvanceType2Present = 1;

      stat = pd_ConsUInt16 (pctxt, &pvalue->timingAdvanceType2, 0, 7690);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode numberOfTransmissions */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfTransmissions");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, &pvalue->numberOfTransmissions, 0, 500);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, &pvalue->numberOfTransmissions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode srsConfiguration */
   RTXCTXTPUSHELEMNAME (pctxt, "srsConfiguration");

   stat = asn1PD_lppa_SRSConfigurationForAllCells (pctxt, &pvalue->srsConfiguration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ULConfiguration (lppa_ULConfiguration* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_lppa_SRSConfigurationForAllCells (&pvalue->srsConfiguration);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_ULConfiguration (OSCTXT *pctxt, 
   lppa_ULConfiguration* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_SRSConfigurationForAllCells (pctxt, &pvalue->srsConfiguration);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_BCCH (OSCTXT* pctxt, lppa_BCCH value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "BCCH");

   if ( value <= 1023 ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, 1023);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_BCCH (OSCTXT* pctxt, lppa_BCCH* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "BCCH");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 1023);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_PhysCellIDGERAN (OSCTXT* pctxt, lppa_PhysCellIDGERAN value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIDGERAN");

   if ( value <= 63 ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, 63);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_PhysCellIDGERAN (OSCTXT* pctxt, lppa_PhysCellIDGERAN* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIDGERAN");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 63);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_RSSI (OSCTXT* pctxt, lppa_RSSI value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RSSI");

   if ( value <= 63 ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, 63);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_RSSI (OSCTXT* pctxt, lppa_RSSI* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RSSI");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 63);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_ResultGERAN_Item_iE_Extensions_element (OSCTXT* pctxt, lppa_ResultGERAN_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode extensionValue */

   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pe_OpenType (pctxt, pvalue->extensionValue.numocts, pvalue->extensionValue.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ResultGERAN_Item_iE_Extensions_element (OSCTXT* pctxt, lppa_ResultGERAN_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ResultGERAN_Item_iE_Extensions_element (
   lppa_ResultGERAN_Item_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->extensionValue.numocts = 0;
   pvalue->extensionValue.data = 0;
   return 0;
}

void asn1Free_lppa_ResultGERAN_Item_iE_Extensions_element (OSCTXT *pctxt, 
   lppa_ResultGERAN_Item_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->extensionValue.data);
   }
}

EXTERN int asn1PE_lppa_ResultGERAN_Item_iE_Extensions (OSCTXT* pctxt, lppa_ResultGERAN_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_ResultGERAN_Item_iE_Extensions_element (pctxt, ((lppa_ResultGERAN_Item_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_ResultGERAN_Item_iE_Extensions (OSCTXT* pctxt, lppa_ResultGERAN_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_ResultGERAN_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_ResultGERAN_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_ResultGERAN_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_ResultGERAN_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_ResultGERAN_Item_iE_Extensions (
   lppa_ResultGERAN_Item_iE_Extensions* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_ResultGERAN_Item_iE_Extensions (OSCTXT *pctxt, 
   lppa_ResultGERAN_Item_iE_Extensions* pvalue)
{
   if (0 == pvalue) return;
   { lppa_ResultGERAN_Item_iE_Extensions_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_ResultGERAN_Item_iE_Extensions_element*)pnode->data;
      asn1Free_lppa_ResultGERAN_Item_iE_Extensions_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_ResultGERAN_Item (OSCTXT* pctxt, lppa_ResultGERAN_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ResultGERAN-Item");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bCCH */

   RTXCTXTPUSHELEMNAME (pctxt, "bCCH");

   stat = asn1PE_lppa_BCCH (pctxt, pvalue->bCCH);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode physCellIDGERAN */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellIDGERAN");

   stat = asn1PE_lppa_PhysCellIDGERAN (pctxt, pvalue->physCellIDGERAN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rSSI */

   RTXCTXTPUSHELEMNAME (pctxt, "rSSI");

   stat = asn1PE_lppa_RSSI (pctxt, pvalue->rSSI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_lppa_ResultGERAN_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ResultGERAN_Item (OSCTXT* pctxt, lppa_ResultGERAN_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ResultGERAN-Item");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode bCCH */
   RTXCTXTPUSHELEMNAME (pctxt, "bCCH");

   stat = asn1PD_lppa_BCCH (pctxt, &pvalue->bCCH);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode physCellIDGERAN */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellIDGERAN");

   stat = asn1PD_lppa_PhysCellIDGERAN (pctxt, &pvalue->physCellIDGERAN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rSSI */
   RTXCTXTPUSHELEMNAME (pctxt, "rSSI");

   stat = asn1PD_lppa_RSSI (pctxt, &pvalue->rSSI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_lppa_ResultGERAN_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ResultGERAN_Item (lppa_ResultGERAN_Item* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_lppa_ResultGERAN_Item_iE_Extensions (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_ResultGERAN_Item (OSCTXT *pctxt, 
   lppa_ResultGERAN_Item* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_lppa_ResultGERAN_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_ResultGERAN (OSCTXT* pctxt, lppa_ResultGERAN* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "ResultGERAN");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ResultGERAN-Item", xx1);

      stat = asn1PE_lppa_ResultGERAN_Item (pctxt, ((lppa_ResultGERAN_Item*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ResultGERAN (OSCTXT* pctxt, lppa_ResultGERAN* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ResultGERAN");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_ResultGERAN_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ResultGERAN-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_ResultGERAN_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_ResultGERAN_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_ResultGERAN_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ResultGERAN (lppa_ResultGERAN* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_ResultGERAN (OSCTXT *pctxt, lppa_ResultGERAN* pvalue)
{
   if (0 == pvalue) return;
   { lppa_ResultGERAN_Item* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_ResultGERAN_Item*)pnode->data;
      asn1Free_lppa_ResultGERAN_Item (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_UARFCN (OSCTXT* pctxt, lppa_UARFCN value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UARFCN");

   if ( value <= 16383 ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, 16383);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_UARFCN (OSCTXT* pctxt, lppa_UARFCN* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UARFCN");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 16383);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_PhysCellIDUTRA_FDD (OSCTXT* pctxt, lppa_PhysCellIDUTRA_FDD value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIDUTRA-FDD");

   if ( value <= 511 ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, 511);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_PhysCellIDUTRA_FDD (OSCTXT* pctxt, lppa_PhysCellIDUTRA_FDD* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIDUTRA-FDD");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 511);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_PhysCellIDUTRA_TDD (OSCTXT* pctxt, lppa_PhysCellIDUTRA_TDD value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIDUTRA-TDD");

   if ( value <= 127 ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_PhysCellIDUTRA_TDD (OSCTXT* pctxt, lppa_PhysCellIDUTRA_TDD* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIDUTRA-TDD");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_ResultUTRAN_Item_physCellIDUTRAN (OSCTXT* pctxt, lppa_ResultUTRAN_Item_physCellIDUTRAN* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* physCellIDUTRA_FDD */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "physCellIDUTRA-FDD");

         stat = asn1PE_lppa_PhysCellIDUTRA_FDD (pctxt, pvalue->u.physCellIDUTRA_FDD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* physCellIDUTRA_TDD */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "physCellIDUTRA-TDD");

         stat = asn1PE_lppa_PhysCellIDUTRA_TDD (pctxt, pvalue->u.physCellIDUTRA_TDD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_ResultUTRAN_Item_physCellIDUTRAN (OSCTXT* pctxt, lppa_ResultUTRAN_Item_physCellIDUTRAN* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* physCellIDUTRA_FDD */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "physCellIDUTRA-FDD");

         stat = asn1PD_lppa_PhysCellIDUTRA_FDD (pctxt, &pvalue->u.physCellIDUTRA_FDD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* physCellIDUTRA_TDD */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "physCellIDUTRA-TDD");

         stat = asn1PD_lppa_PhysCellIDUTRA_TDD (pctxt, &pvalue->u.physCellIDUTRA_TDD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

int asn1Init_lppa_ResultUTRAN_Item_physCellIDUTRAN (
   lppa_ResultUTRAN_Item_physCellIDUTRAN* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

EXTERN int asn1PE_lppa_UTRA_RSCP (OSCTXT* pctxt, lppa_UTRA_RSCP value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UTRA-RSCP");

   if ( (value >= -5 && value <= 91) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, -5, 91);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_UTRA_RSCP (OSCTXT* pctxt, lppa_UTRA_RSCP* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UTRA-RSCP");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, -5, 91);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_UTRA_EcN0 (OSCTXT* pctxt, lppa_UTRA_EcN0 value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UTRA-EcN0");

   if ( value <= 49 ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, 49);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_UTRA_EcN0 (OSCTXT* pctxt, lppa_UTRA_EcN0* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UTRA-EcN0");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 49);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_ResultUTRAN_Item_iE_Extensions_element (OSCTXT* pctxt, lppa_ResultUTRAN_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode extensionValue */

   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pe_OpenType (pctxt, pvalue->extensionValue.numocts, pvalue->extensionValue.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ResultUTRAN_Item_iE_Extensions_element (OSCTXT* pctxt, lppa_ResultUTRAN_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ResultUTRAN_Item_iE_Extensions_element (
   lppa_ResultUTRAN_Item_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->extensionValue.numocts = 0;
   pvalue->extensionValue.data = 0;
   return 0;
}

void asn1Free_lppa_ResultUTRAN_Item_iE_Extensions_element (OSCTXT *pctxt, 
   lppa_ResultUTRAN_Item_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->extensionValue.data);
   }
}

EXTERN int asn1PE_lppa_ResultUTRAN_Item_iE_Extensions (OSCTXT* pctxt, lppa_ResultUTRAN_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_ResultUTRAN_Item_iE_Extensions_element (pctxt, ((lppa_ResultUTRAN_Item_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_ResultUTRAN_Item_iE_Extensions (OSCTXT* pctxt, lppa_ResultUTRAN_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_ResultUTRAN_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_ResultUTRAN_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_ResultUTRAN_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_ResultUTRAN_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_ResultUTRAN_Item_iE_Extensions (
   lppa_ResultUTRAN_Item_iE_Extensions* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_ResultUTRAN_Item_iE_Extensions (OSCTXT *pctxt, 
   lppa_ResultUTRAN_Item_iE_Extensions* pvalue)
{
   if (0 == pvalue) return;
   { lppa_ResultUTRAN_Item_iE_Extensions_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_ResultUTRAN_Item_iE_Extensions_element*)pnode->data;
      asn1Free_lppa_ResultUTRAN_Item_iE_Extensions_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_ResultUTRAN_Item (OSCTXT* pctxt, lppa_ResultUTRAN_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ResultUTRAN-Item");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uTRA_RSCPPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uTRA_EcN0Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode uARFCN */

   RTXCTXTPUSHELEMNAME (pctxt, "uARFCN");

   stat = asn1PE_lppa_UARFCN (pctxt, pvalue->uARFCN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode physCellIDUTRAN */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellIDUTRAN");

   stat = asn1PE_lppa_ResultUTRAN_Item_physCellIDUTRAN (pctxt, &pvalue->physCellIDUTRAN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uTRA_RSCP */

   if (pvalue->m.uTRA_RSCPPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "uTRA-RSCP");

      stat = asn1PE_lppa_UTRA_RSCP (pctxt, pvalue->uTRA_RSCP);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode uTRA_EcN0 */

   if (pvalue->m.uTRA_EcN0Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "uTRA-EcN0");

      stat = asn1PE_lppa_UTRA_EcN0 (pctxt, pvalue->uTRA_EcN0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_lppa_ResultUTRAN_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ResultUTRAN_Item (OSCTXT* pctxt, lppa_ResultUTRAN_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "ResultUTRAN-Item");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode uARFCN */
   RTXCTXTPUSHELEMNAME (pctxt, "uARFCN");

   stat = asn1PD_lppa_UARFCN (pctxt, &pvalue->uARFCN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode physCellIDUTRAN */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellIDUTRAN");

   stat = asn1PD_lppa_ResultUTRAN_Item_physCellIDUTRAN (pctxt, &pvalue->physCellIDUTRAN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uTRA_RSCP */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uTRA-RSCP");

      pvalue->m.uTRA_RSCPPresent = 1;

      stat = asn1PD_lppa_UTRA_RSCP (pctxt, &pvalue->uTRA_RSCP);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uTRA_EcN0 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uTRA-EcN0");

      pvalue->m.uTRA_EcN0Present = 1;

      stat = asn1PD_lppa_UTRA_EcN0 (pctxt, &pvalue->uTRA_EcN0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_lppa_ResultUTRAN_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ResultUTRAN_Item (lppa_ResultUTRAN_Item* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_lppa_ResultUTRAN_Item_physCellIDUTRAN (&pvalue->physCellIDUTRAN);
   asn1Init_lppa_ResultUTRAN_Item_iE_Extensions (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_ResultUTRAN_Item (OSCTXT *pctxt, 
   lppa_ResultUTRAN_Item* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_lppa_ResultUTRAN_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_ResultUTRAN (OSCTXT* pctxt, lppa_ResultUTRAN* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "ResultUTRAN");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ResultUTRAN-Item", xx1);

      stat = asn1PE_lppa_ResultUTRAN_Item (pctxt, ((lppa_ResultUTRAN_Item*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ResultUTRAN (OSCTXT* pctxt, lppa_ResultUTRAN* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ResultUTRAN");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_ResultUTRAN_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ResultUTRAN-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_ResultUTRAN_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_ResultUTRAN_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_ResultUTRAN_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ResultUTRAN (lppa_ResultUTRAN* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_ResultUTRAN (OSCTXT *pctxt, lppa_ResultUTRAN* pvalue)
{
   if (0 == pvalue) return;
   { lppa_ResultUTRAN_Item* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_ResultUTRAN_Item*)pnode->data;
      asn1Free_lppa_ResultUTRAN_Item (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_InterRATMeasuredResultsValue (OSCTXT* pctxt, lppa_InterRATMeasuredResultsValue* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InterRATMeasuredResultsValue");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* resultGERAN */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "resultGERAN");

            stat = asn1PE_lppa_ResultGERAN (pctxt, pvalue->u.resultGERAN);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* resultUTRAN */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "resultUTRAN");

            stat = asn1PE_lppa_ResultUTRAN (pctxt, pvalue->u.resultUTRAN);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_InterRATMeasuredResultsValue (OSCTXT* pctxt, lppa_InterRATMeasuredResultsValue* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "InterRATMeasuredResultsValue");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* resultGERAN */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "resultGERAN");

            pvalue->u.resultGERAN = rtxMemAllocType (pctxt, lppa_ResultGERAN);

            if (pvalue->u.resultGERAN == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_lppa_ResultGERAN (pvalue->u.resultGERAN);

            stat = asn1PD_lppa_ResultGERAN (pctxt, pvalue->u.resultGERAN);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* resultUTRAN */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "resultUTRAN");

            pvalue->u.resultUTRAN = rtxMemAllocType (pctxt, lppa_ResultUTRAN);

            if (pvalue->u.resultUTRAN == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_lppa_ResultUTRAN (pvalue->u.resultUTRAN);

            stat = asn1PD_lppa_ResultUTRAN (pctxt, pvalue->u.resultUTRAN);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_InterRATMeasuredResultsValue (
   lppa_InterRATMeasuredResultsValue* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_lppa_InterRATMeasuredResultsValue (OSCTXT *pctxt, 
   lppa_InterRATMeasuredResultsValue* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.resultGERAN) {
            asn1Free_lppa_ResultGERAN (pctxt, pvalue->u.resultGERAN);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.resultGERAN);
            pvalue->u.resultGERAN = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.resultUTRAN) {
            asn1Free_lppa_ResultUTRAN (pctxt, pvalue->u.resultUTRAN);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.resultUTRAN);
            pvalue->u.resultUTRAN = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_lppa_InterRATMeasurementResult (OSCTXT* pctxt, lppa_InterRATMeasurementResult* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "InterRATMeasurementResult");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(63), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InterRATMeasuredResultsValue", xx1);

      stat = asn1PE_lppa_InterRATMeasuredResultsValue (pctxt, ((lppa_InterRATMeasuredResultsValue*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_InterRATMeasurementResult (OSCTXT* pctxt, lppa_InterRATMeasurementResult* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterRATMeasurementResult");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(63), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_InterRATMeasuredResultsValue* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InterRATMeasuredResultsValue", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_InterRATMeasuredResultsValue, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_InterRATMeasuredResultsValue (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_InterRATMeasuredResultsValue (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_InterRATMeasurementResult (
   lppa_InterRATMeasurementResult* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_InterRATMeasurementResult (OSCTXT *pctxt, 
   lppa_InterRATMeasurementResult* pvalue)
{
   if (0 == pvalue) return;
   { lppa_InterRATMeasuredResultsValue* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_InterRATMeasuredResultsValue*)pnode->data;
      asn1Free_lppa_InterRATMeasuredResultsValue (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem lppa_PRS_Bandwidth_ENUMTAB[] = {
   { OSUTF8("bw100"), 5, 5, 4 },
   { OSUTF8("bw15"), 1, 4, 1 },
   { OSUTF8("bw25"), 2, 4, 2 },
   { OSUTF8("bw50"), 3, 4, 3 },
   { OSUTF8("bw6"), 0, 3, 5 },
   { OSUTF8("bw75"), 4, 4, 0 }
} ;
#define lppa_PRS_Bandwidth_ENUMTABSIZE 6

const OSUTF8CHAR* lppa_PRS_Bandwidth_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_PRS_Bandwidth_ENUMTABSIZE) {
      return lppa_PRS_Bandwidth_ENUMTAB
         [lppa_PRS_Bandwidth_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_PRS_Bandwidth_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_PRS_Bandwidth* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_PRS_Bandwidth_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_PRS_Bandwidth_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, lppa_PRS_Bandwidth* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, lppa_PRS_Bandwidth_ENUMTAB, 
      lppa_PRS_Bandwidth_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_PRS_Bandwidth)lppa_PRS_Bandwidth_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_PRS_Bandwidth (OSCTXT* pctxt, lppa_PRS_Bandwidth value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PRS-Bandwidth");

   if (value >= 6) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_PRS_Bandwidth (OSCTXT* pctxt, lppa_PRS_Bandwidth* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PRS-Bandwidth");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_PRS_Configuration_Index (OSCTXT* pctxt, lppa_PRS_Configuration_Index value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PRS-Configuration-Index");

   if ( value <= 4095 ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, 4095);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_PRS_Configuration_Index (OSCTXT* pctxt, lppa_PRS_Configuration_Index* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PRS-Configuration-Index");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 4095);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem lppa_NumberOfDlFrames_ENUMTAB[] = {
   { OSUTF8("sf1"), 0, 3, 0 },
   { OSUTF8("sf2"), 1, 3, 1 },
   { OSUTF8("sf4"), 2, 3, 2 },
   { OSUTF8("sf6"), 3, 3, 3 }
} ;
#define lppa_NumberOfDlFrames_ENUMTABSIZE 4

const OSUTF8CHAR* lppa_NumberOfDlFrames_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_NumberOfDlFrames_ENUMTABSIZE) {
      return lppa_NumberOfDlFrames_ENUMTAB
         [lppa_NumberOfDlFrames_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_NumberOfDlFrames_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_NumberOfDlFrames* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_NumberOfDlFrames_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_NumberOfDlFrames_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, lppa_NumberOfDlFrames* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_NumberOfDlFrames_ENUMTAB, lppa_NumberOfDlFrames_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_NumberOfDlFrames)
         lppa_NumberOfDlFrames_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_NumberOfDlFrames (OSCTXT* pctxt, lppa_NumberOfDlFrames value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NumberOfDlFrames");

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_NumberOfDlFrames (OSCTXT* pctxt, lppa_NumberOfDlFrames* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NumberOfDlFrames");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem lppa_NumberOfAntennaPorts_ENUMTAB[] = {
   { OSUTF8("n1-or-n2"), 0, 8, 0 },
   { OSUTF8("n4"), 1, 2, 1 }
} ;
#define lppa_NumberOfAntennaPorts_ENUMTABSIZE 2

const OSUTF8CHAR* lppa_NumberOfAntennaPorts_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < lppa_NumberOfAntennaPorts_ENUMTABSIZE) {
      return lppa_NumberOfAntennaPorts_ENUMTAB
         [lppa_NumberOfAntennaPorts_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int lppa_NumberOfAntennaPorts_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, lppa_NumberOfAntennaPorts* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return lppa_NumberOfAntennaPorts_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int lppa_NumberOfAntennaPorts_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, lppa_NumberOfAntennaPorts* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      lppa_NumberOfAntennaPorts_ENUMTAB, 
      lppa_NumberOfAntennaPorts_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (lppa_NumberOfAntennaPorts)
         lppa_NumberOfAntennaPorts_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_lppa_NumberOfAntennaPorts (OSCTXT* pctxt, lppa_NumberOfAntennaPorts value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NumberOfAntennaPorts");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_NumberOfAntennaPorts (OSCTXT* pctxt, lppa_NumberOfAntennaPorts* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NumberOfAntennaPorts");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_lppa_PRSMutingConfiguration (OSCTXT* pctxt, lppa_PRSMutingConfiguration* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PRSMutingConfiguration");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 4);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* two */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "two");

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

            stat = pe_BitString32 (pctxt, pvalue->u.two, OSUINTCONST(2), OSUINTCONST(2));
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* four */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "four");

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

            stat = pe_BitString32 (pctxt, pvalue->u.four, OSUINTCONST(4), OSUINTCONST(4));
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* eight */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "eight");

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

            stat = pe_BitString32 (pctxt, pvalue->u.eight, OSUINTCONST(8), OSUINTCONST(8));
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* sixteen */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "sixteen");

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

            stat = pe_BitString32 (pctxt, pvalue->u.sixteen, OSUINTCONST(16), OSUINTCONST(16));
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_PRSMutingConfiguration (OSCTXT* pctxt, lppa_PRSMutingConfiguration* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "PRSMutingConfiguration");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* two */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "two");

            pvalue->u.two = rtxMemAllocType (pctxt, ASN1BitStr32);

            if (pvalue->u.two == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.two->numbits = 0;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

            stat = pd_BitString32 (pctxt, pvalue->u.two
               , OSUINTCONST(2), OSUINTCONST(2));
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* four */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "four");

            pvalue->u.four = rtxMemAllocType (pctxt, ASN1BitStr32);

            if (pvalue->u.four == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.four->numbits = 0;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

            stat = pd_BitString32 (pctxt, pvalue->u.four
               , OSUINTCONST(4), OSUINTCONST(4));
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* eight */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "eight");

            pvalue->u.eight = rtxMemAllocType (pctxt, ASN1BitStr32);

            if (pvalue->u.eight == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.eight->numbits = 0;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

            stat = pd_BitString32 (pctxt, pvalue->u.eight
               , OSUINTCONST(8), OSUINTCONST(8));
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* sixteen */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "sixteen");

            pvalue->u.sixteen = rtxMemAllocType (pctxt, ASN1BitStr32);

            if (pvalue->u.sixteen == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.sixteen->numbits = 0;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

            stat = pd_BitString32 (pctxt, pvalue->u.sixteen
               , OSUINTCONST(16), OSUINTCONST(16));
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_PRSMutingConfiguration (lppa_PRSMutingConfiguration* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_lppa_PRSMutingConfiguration (OSCTXT *pctxt, 
   lppa_PRSMutingConfiguration* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.two) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.two);
            pvalue->u.two = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.four) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.four);
            pvalue->u.four = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.eight) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.eight);
            pvalue->u.eight = 0;
         }
         break;

      case 4:
         if (0 != pvalue->u.sixteen) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sixteen);
            pvalue->u.sixteen = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_lppa_OTDOACell_Information_Item (OSCTXT* pctxt, lppa_OTDOACell_Information_Item* pvalue)
{
   int stat = 0;
   OSUINT32 pos;
   void* pPerField;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOACell-Information-Item");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 11);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 10);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* pCI */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "pCI");

            stat = asn1PE_lppa_PCI (pctxt, pvalue->u.pCI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* cellId */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "cellId");

            stat = asn1PE_lppa_ECGI (pctxt, pvalue->u.cellId);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* tAC */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "tAC");

            stat = asn1PE_lppa_TAC (pctxt, pvalue->u.tAC);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* eARFCN */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "eARFCN");

            stat = asn1PE_lppa_EARFCN (pctxt, pvalue->u.eARFCN);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* pRS_Bandwidth */
         case 5:
            RTXCTXTPUSHELEMNAME (pctxt, "pRS-Bandwidth");

            stat = asn1PE_lppa_PRS_Bandwidth (pctxt, pvalue->u.pRS_Bandwidth);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* pRS_ConfigurationIndex */
         case 6:
            RTXCTXTPUSHELEMNAME (pctxt, "pRS-ConfigurationIndex");

            stat = asn1PE_lppa_PRS_Configuration_Index (pctxt, pvalue->u.pRS_ConfigurationIndex);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* cPLength */
         case 7:
            RTXCTXTPUSHELEMNAME (pctxt, "cPLength");

            stat = asn1PE_lppa_CPLength (pctxt, pvalue->u.cPLength);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* numberOfDlFrames */
         case 8:
            RTXCTXTPUSHELEMNAME (pctxt, "numberOfDlFrames");

            stat = asn1PE_lppa_NumberOfDlFrames (pctxt, pvalue->u.numberOfDlFrames);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* numberOfAntennaPorts */
         case 9:
            RTXCTXTPUSHELEMNAME (pctxt, "numberOfAntennaPorts");

            stat = asn1PE_lppa_NumberOfAntennaPorts (pctxt, pvalue->u.numberOfAntennaPorts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* sFNInitialisationTime */
         case 10:
            RTXCTXTPUSHELEMNAME (pctxt, "sFNInitialisationTime");

            stat = asn1PE_lppa_SFNInitialisationTime (pctxt, pvalue->u.sFNInitialisationTime);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* e_UTRANAccessPointPosition */
         case 11:
            RTXCTXTPUSHELEMNAME (pctxt, "e-UTRANAccessPointPosition");

            stat = asn1PE_lppa_E_UTRANAccessPointPosition (pctxt, pvalue->u.e_UTRANAccessPointPosition);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 12);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->t)
      {
         /* pRSMutingConfiguration */
         case 12:
            stat = asn1PE_lppa_PRSMutingConfiguration (pctxt, pvalue->u.pRSMutingConfiguration);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         default:
            stat = rtxEncBitsFromByteArray (pctxt, pvalue->u.extElem1->data, pvalue->u.extElem1->numocts * 8);
      }

      stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOACell_Information_Item (OSCTXT* pctxt, lppa_OTDOACell_Information_Item* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;
   OSINT16 savedBitOffset = 0;
   OSBOOL fragmented = FALSE;
   OSCTXT lctxt;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOACell-Information-Item");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(10));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* pCI */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "pCI");

            stat = asn1PD_lppa_PCI (pctxt, &pvalue->u.pCI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* cellId */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "cellId");

            pvalue->u.cellId = rtxMemAllocType (pctxt, lppa_ECGI);

            if (pvalue->u.cellId == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_lppa_ECGI (pvalue->u.cellId);

            stat = asn1PD_lppa_ECGI (pctxt, pvalue->u.cellId);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* tAC */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "tAC");

            pvalue->u.tAC = rtxMemAllocType (pctxt, lppa_TAC);

            if (pvalue->u.tAC == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_lppa_TAC (pvalue->u.tAC);

            stat = asn1PD_lppa_TAC (pctxt, pvalue->u.tAC);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* eARFCN */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "eARFCN");

            stat = asn1PD_lppa_EARFCN (pctxt, &pvalue->u.eARFCN);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* pRS_Bandwidth */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "pRS-Bandwidth");

            stat = asn1PD_lppa_PRS_Bandwidth (pctxt, &pvalue->u.pRS_Bandwidth);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* pRS_ConfigurationIndex */
         case 5:
            RTXCTXTPUSHELEMNAME (pctxt, "pRS-ConfigurationIndex");

            stat = asn1PD_lppa_PRS_Configuration_Index (pctxt, &pvalue->u.pRS_ConfigurationIndex);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* cPLength */
         case 6:
            RTXCTXTPUSHELEMNAME (pctxt, "cPLength");

            stat = asn1PD_lppa_CPLength (pctxt, &pvalue->u.cPLength);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* numberOfDlFrames */
         case 7:
            RTXCTXTPUSHELEMNAME (pctxt, "numberOfDlFrames");

            stat = asn1PD_lppa_NumberOfDlFrames (pctxt, &pvalue->u.numberOfDlFrames);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* numberOfAntennaPorts */
         case 8:
            RTXCTXTPUSHELEMNAME (pctxt, "numberOfAntennaPorts");

            stat = asn1PD_lppa_NumberOfAntennaPorts (pctxt, &pvalue->u.numberOfAntennaPorts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* sFNInitialisationTime */
         case 9:
            RTXCTXTPUSHELEMNAME (pctxt, "sFNInitialisationTime");

            pvalue->u.sFNInitialisationTime = rtxMemAllocType (pctxt, 
               lppa_SFNInitialisationTime);

            if (pvalue->u.sFNInitialisationTime == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_lppa_SFNInitialisationTime (pvalue->u.sFNInitialisationTime);

            stat = asn1PD_lppa_SFNInitialisationTime (pctxt, pvalue->u.sFNInitialisationTime);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* e_UTRANAccessPointPosition */
         case 10:
            RTXCTXTPUSHELEMNAME (pctxt, "e-UTRANAccessPointPosition");

            pvalue->u.e_UTRANAccessPointPosition = rtxMemAllocType (pctxt, 
               lppa_E_UTRANAccessPointPosition);

            if (pvalue->u.e_UTRANAccessPointPosition == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_lppa_E_UTRANAccessPointPosition (pvalue->u.e_UTRANAccessPointPosition);

            stat = asn1PD_lppa_E_UTRANAccessPointPosition (pctxt, pvalue->u.e_UTRANAccessPointPosition);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 12;

      if (pvalue->t < 12) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      if (pd_isFragmented (pctxt)) {
         fragmented = TRUE;
         RTXCTXTPUSHELEMNAME (pctxt, "...");

         stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         rtxCopyContext (&lctxt, pctxt);
         rtxCtxtSetFlag (pctxt, OSDISSTRM);
         stat = rtxInitContextBuffer (pctxt,
            (OSOCTET*)openType.data, openType.numocts);
      }
      else if (pvalue->t < 13) {
         stat = pd_Length64 (pctxt, &openType.numocts);
         if (stat != 0 && stat != ASN_OK_FRAG) return LOG_RTERR (pctxt, stat);

         pd_OpenTypeStart (pctxt, &openType.numocts, &savedBitOffset);
      }
      else openType.numocts = 0;

      switch (pvalue->t) {
         /* pRSMutingConfiguration */
         case 12:
            RTXCTXTPUSHELEMNAME (pctxt, "pRSMutingConfiguration");

            pvalue->u.pRSMutingConfiguration = rtxMemAllocType (pctxt, 
               lppa_PRSMutingConfiguration);

            if (pvalue->u.pRSMutingConfiguration == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_lppa_PRSMutingConfiguration (pvalue->u.pRSMutingConfiguration);

            stat = asn1PD_lppa_PRSMutingConfiguration (pctxt, pvalue->u.pRSMutingConfiguration);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            RTXCTXTPUSHELEMNAME (pctxt, "...");

            pvalue->u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
            if (fragmented) {
               openType.data = 0; /* protect from release */
            }
            else {
               stat = pd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
               if (stat != 0) return LOG_RTERR (pctxt, stat);
            }

            RTXCTXTPOPELEMNAME (pctxt);

      }

      if (fragmented) {
         rtxCopyContext (pctxt, &lctxt);
         rtxMemFreePtr (pctxt, openType.data);
      }
      else if (pvalue->t < 13) {
         stat = pd_OpenTypeEnd (pctxt, openType.numocts, savedBitOffset);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_OTDOACell_Information_Item (
   lppa_OTDOACell_Information_Item* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_lppa_OTDOACell_Information_Item (OSCTXT *pctxt, 
   lppa_OTDOACell_Information_Item* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.cellId) {
            asn1Free_lppa_ECGI (pctxt, pvalue->u.cellId);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.cellId);
            pvalue->u.cellId = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.tAC) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tAC);
            pvalue->u.tAC = 0;
         }
         break;

      case 4:
         break;

      case 5:
         break;

      case 6:
         break;

      case 7:
         break;

      case 8:
         break;

      case 9:
         break;

      case 10:
         if (0 != pvalue->u.sFNInitialisationTime) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sFNInitialisationTime);
            pvalue->u.sFNInitialisationTime = 0;
         }
         break;

      case 11:
         if (0 != pvalue->u.e_UTRANAccessPointPosition) {
            asn1Free_lppa_E_UTRANAccessPointPosition (pctxt, pvalue->u.e_UTRANAccessPointPosition);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_UTRANAccessPointPosition);
            pvalue->u.e_UTRANAccessPointPosition = 0;
         }
         break;

      case 12:
         if (0 != pvalue->u.pRSMutingConfiguration) {
            asn1Free_lppa_PRSMutingConfiguration (pctxt, pvalue->u.pRSMutingConfiguration);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.pRSMutingConfiguration);
            pvalue->u.pRSMutingConfiguration = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_lppa_OTDOACell_Information (OSCTXT* pctxt, lppa_OTDOACell_Information* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOACell-Information");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(63), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OTDOACell-Information-Item", xx1);

      stat = asn1PE_lppa_OTDOACell_Information_Item (pctxt, ((lppa_OTDOACell_Information_Item*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOACell_Information (OSCTXT* pctxt, lppa_OTDOACell_Information* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOACell-Information");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(63), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_OTDOACell_Information_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OTDOACell-Information-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_OTDOACell_Information_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_OTDOACell_Information_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_OTDOACell_Information_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_OTDOACell_Information (lppa_OTDOACell_Information* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_OTDOACell_Information (OSCTXT *pctxt, 
   lppa_OTDOACell_Information* pvalue)
{
   if (0 == pvalue) return;
   { lppa_OTDOACell_Information_Item* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_OTDOACell_Information_Item*)pnode->data;
      asn1Free_lppa_OTDOACell_Information_Item (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_OTDOACells_element_iE_Extensions_element (OSCTXT* pctxt, lppa_OTDOACells_element_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode extensionValue */

   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pe_OpenType (pctxt, pvalue->extensionValue.numocts, pvalue->extensionValue.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOACells_element_iE_Extensions_element (OSCTXT* pctxt, lppa_OTDOACells_element_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_OTDOACells_element_iE_Extensions_element (
   lppa_OTDOACells_element_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->extensionValue.numocts = 0;
   pvalue->extensionValue.data = 0;
   return 0;
}

void asn1Free_lppa_OTDOACells_element_iE_Extensions_element (OSCTXT *pctxt, 
   lppa_OTDOACells_element_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->extensionValue.data);
   }
}

EXTERN int asn1PE_lppa_OTDOACells_element_iE_Extensions (OSCTXT* pctxt, lppa_OTDOACells_element_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_OTDOACells_element_iE_Extensions_element (pctxt, ((lppa_OTDOACells_element_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOACells_element_iE_Extensions (OSCTXT* pctxt, lppa_OTDOACells_element_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_OTDOACells_element_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_OTDOACells_element_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_OTDOACells_element_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_OTDOACells_element_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_OTDOACells_element_iE_Extensions (
   lppa_OTDOACells_element_iE_Extensions* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_OTDOACells_element_iE_Extensions (OSCTXT *pctxt, 
   lppa_OTDOACells_element_iE_Extensions* pvalue)
{
   if (0 == pvalue) return;
   { lppa_OTDOACells_element_iE_Extensions_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_OTDOACells_element_iE_Extensions_element*)pnode->data;
      asn1Free_lppa_OTDOACells_element_iE_Extensions_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_OTDOACells_element (OSCTXT* pctxt, lppa_OTDOACells_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode oTDOACellInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "oTDOACellInfo");

   stat = asn1PE_lppa_OTDOACell_Information (pctxt, &pvalue->oTDOACellInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_lppa_OTDOACells_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOACells_element (OSCTXT* pctxt, lppa_OTDOACells_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode oTDOACellInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "oTDOACellInfo");

   stat = asn1PD_lppa_OTDOACell_Information (pctxt, &pvalue->oTDOACellInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_lppa_OTDOACells_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_lppa_OTDOACells_element (lppa_OTDOACells_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_lppa_OTDOACell_Information (&pvalue->oTDOACellInfo);
   asn1Init_lppa_OTDOACells_element_iE_Extensions (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_OTDOACells_element (OSCTXT *pctxt, 
   lppa_OTDOACells_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_OTDOACell_Information (pctxt, &pvalue->oTDOACellInfo);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_lppa_OTDOACells_element_iE_Extensions (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_OTDOACells (OSCTXT* pctxt, lppa_OTDOACells* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOACells");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_OTDOACells_element (pctxt, ((lppa_OTDOACells_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOACells (OSCTXT* pctxt, lppa_OTDOACells* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOACells");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_OTDOACells_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_OTDOACells_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_OTDOACells_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_OTDOACells_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_OTDOACells (lppa_OTDOACells* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_OTDOACells (OSCTXT *pctxt, lppa_OTDOACells* pvalue)
{
   if (0 == pvalue) return;
   { lppa_OTDOACells_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_OTDOACells_element*)pnode->data;
      asn1Free_lppa_OTDOACells_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Print_lppa_Measurement_ID 
   (const char* name, const lppa_Measurement_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_ReportCharacteristics 
   (const char* name, const lppa_ReportCharacteristics* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("onDemand\n"); break;
      case 1: printf ("periodic\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_lppa_MeasurementPeriodicity 
   (const char* name, const lppa_MeasurementPeriodicity* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms120\n"); break;
      case 1: printf ("ms240\n"); break;
      case 2: printf ("ms480\n"); break;
      case 3: printf ("ms640\n"); break;
      case 4: printf ("ms1024\n"); break;
      case 5: printf ("ms2048\n"); break;
      case 6: printf ("ms5120\n"); break;
      case 7: printf ("ms10240\n"); break;
      case 8: printf ("min1\n"); break;
      case 9: printf ("min6\n"); break;
      case 10: printf ("min12\n"); break;
      case 11: printf ("min30\n"); break;
      case 12: printf ("min60\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_lppa_MeasurementQuantitiesValue 
   (const char* name, const lppa_MeasurementQuantitiesValue* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("cell-ID\n"); break;
      case 1: printf ("angleOfArrival\n"); break;
      case 2: printf ("timingAdvanceType1\n"); break;
      case 3: printf ("timingAdvanceType2\n"); break;
      case 4: printf ("rSRP\n"); break;
      case 5: printf ("rSRQ\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_lppa_MeasurementQuantities_Item_iE_Extensions_element 
   (const char* name, const lppa_MeasurementQuantities_Item_iE_Extensions_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("extensionValue", pvalue->extensionValue.numocts,
   pvalue->extensionValue.data);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_MeasurementQuantities_Item_iE_Extensions 
   (const char* name, const lppa_MeasurementQuantities_Item_iE_Extensions* pvalue)
{
   lppa_MeasurementQuantities_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_MeasurementQuantities_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_MeasurementQuantities_Item_iE_Extensions_element (
         namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_MeasurementQuantities_Item 
   (const char* name, const lppa_MeasurementQuantities_Item* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_MeasurementQuantitiesValue ("measurementQuantitiesValue", &
      pvalue->measurementQuantitiesValue);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_lppa_MeasurementQuantities_Item_iE_Extensions (
         "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_MeasurementQuantities_element 
   (const char* name, const lppa_MeasurementQuantities_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   asn1Print_lppa_MeasurementQuantities_Item ("value", &pvalue->value);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_MeasurementQuantities 
   (const char* name, const lppa_MeasurementQuantities* pvalue)
{
   lppa_MeasurementQuantities_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_MeasurementQuantities_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_MeasurementQuantities_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_InterRATMeasurementQuantitiesValue 
   (const char* name, const lppa_InterRATMeasurementQuantitiesValue* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("geran\n"); break;
      case 1: printf ("utran\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element 
   (const char* name, const lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("extensionValue", pvalue->extensionValue.numocts,
   pvalue->extensionValue.data);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_InterRATMeasurementQuantities_Item_iE_Extensions 
   (const char* name, const lppa_InterRATMeasurementQuantities_Item_iE_Extensions* pvalue)
{
   lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element (
         namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_InterRATMeasurementQuantities_Item 
   (const char* name, const lppa_InterRATMeasurementQuantities_Item* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_InterRATMeasurementQuantitiesValue (
      "interRATMeasurementQuantitiesValue", &pvalue->
      interRATMeasurementQuantitiesValue);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_lppa_InterRATMeasurementQuantities_Item_iE_Extensions (
         "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_InterRATMeasurementQuantities_element 
   (const char* name, const lppa_InterRATMeasurementQuantities_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   asn1Print_lppa_InterRATMeasurementQuantities_Item ("value", &pvalue->value
      );

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_InterRATMeasurementQuantities 
   (const char* name, const lppa_InterRATMeasurementQuantities* pvalue)
{
   lppa_InterRATMeasurementQuantities_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_InterRATMeasurementQuantities_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_InterRATMeasurementQuantities_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_OTDOA_Information_Item 
   (const char* name, const lppa_OTDOA_Information_Item* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("pci\n"); break;
      case 1: printf ("cellid\n"); break;
      case 2: printf ("tac\n"); break;
      case 3: printf ("earfcn\n"); break;
      case 4: printf ("prsBandwidth\n"); break;
      case 5: printf ("prsConfigIndex\n"); break;
      case 6: printf ("cpLength\n"); break;
      case 7: printf ("noDlFrames\n"); break;
      case 8: printf ("noAntennaPorts\n"); break;
      case 9: printf ("sFNInitTime\n"); break;
      case 10: printf ("e-UTRANAccessPointPosition\n"); break;
      case 11: printf ("prsmutingconfiguration\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_lppa_RequestedSRSTransmissionCharacteristics 
   (const char* name, const lppa_RequestedSRSTransmissionCharacteristics* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("numberOfTransmissions", pvalue->numberOfTransmissions);

   rtxPrintIndent ();
   rtxPrintUnsigned ("bandwidth", pvalue->bandwidth);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_CauseRadioNetwork 
   (const char* name, const lppa_CauseRadioNetwork* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("unspecified\n"); break;
      case 1: printf ("requested-item-not-supported\n"); break;
      case 2: printf ("requested-item-temporarily-not-available\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_lppa_CauseProtocol 
   (const char* name, const lppa_CauseProtocol* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("transfer-syntax-error\n"); break;
      case 1: printf ("abstract-syntax-error-reject\n"); break;
      case 2: printf ("abstract-syntax-error-ignore-and-notify\n"); break;
      case 3: printf ("message-not-compatible-with-receiver-state\n"); break;
      case 4: printf ("semantic-error\n"); break;
      case 5: printf ("unspecified\n"); break;
      case 6: printf ("abstract-syntax-error-falsely-constructed-message\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_lppa_CauseMisc (const char* name, const lppa_CauseMisc* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("unspecified\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_lppa_Cause (const char* name, const lppa_Cause* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* radioNetwork */
      case 1:
      {
         asn1Print_lppa_CauseRadioNetwork ("radioNetwork", &pvalue->
            u.radioNetwork);
         break;
      }
      /* protocol */
      case 2:
      {
         asn1Print_lppa_CauseProtocol ("protocol", &pvalue->u.protocol);
         break;
      }
      /* misc */
      case 3:
      {
         asn1Print_lppa_CauseMisc ("misc", &pvalue->u.misc);
         break;
      }
      /* extElem1 */
      case 4:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_PLMN_Identity 
   (const char* name, const lppa_PLMN_Identity* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_lppa_EUTRANCellIdentifier 
   (const char* name, const lppa_EUTRANCellIdentifier* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_lppa_ECGI_iE_Extensions_element 
   (const char* name, const lppa_ECGI_iE_Extensions_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("extensionValue", pvalue->extensionValue.numocts,
   pvalue->extensionValue.data);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_ECGI_iE_Extensions 
   (const char* name, const lppa_ECGI_iE_Extensions* pvalue)
{
   lppa_ECGI_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ECGI_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_ECGI_iE_Extensions_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_ECGI (const char* name, const lppa_ECGI* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_PLMN_Identity ("pLMN_Identity", &pvalue->pLMN_Identity);

   asn1Print_lppa_EUTRANCellIdentifier ("eUTRANcellIdentifier", &pvalue->
      eUTRANcellIdentifier);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_lppa_ECGI_iE_Extensions ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_TAC (const char* name, const lppa_TAC* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_lppa_E_UTRANAccessPointPosition_latitudeSign 
   (const char* name, const lppa_E_UTRANAccessPointPosition_latitudeSign* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("north\n"); break;
      case 1: printf ("south\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_lppa_E_UTRANAccessPointPosition_directionOfAltitude 
   (const char* name, const lppa_E_UTRANAccessPointPosition_directionOfAltitude* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("height\n"); break;
      case 1: printf ("depth\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_lppa_E_UTRANAccessPointPosition 
   (const char* name, const lppa_E_UTRANAccessPointPosition* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_E_UTRANAccessPointPosition_latitudeSign ("latitudeSign", &
      pvalue->latitudeSign);

   rtxPrintIndent ();
   rtxPrintUnsigned ("latitude", pvalue->latitude);

   rtxPrintIndent ();
   rtxPrintInteger ("longitude", pvalue->longitude);

   asn1Print_lppa_E_UTRANAccessPointPosition_directionOfAltitude (
      "directionOfAltitude", &pvalue->directionOfAltitude);

   rtxPrintIndent ();
   rtxPrintUnsigned ("altitude", pvalue->altitude);

   rtxPrintIndent ();
   rtxPrintUnsigned ("uncertaintySemi_major", pvalue->uncertaintySemi_major);

   rtxPrintIndent ();
   rtxPrintUnsigned ("uncertaintySemi_minor", pvalue->uncertaintySemi_minor);

   rtxPrintIndent ();
   rtxPrintUnsigned ("orientationOfMajorAxis", pvalue->orientationOfMajorAxis);

   rtxPrintIndent ();
   rtxPrintUnsigned ("uncertaintyAltitude", pvalue->uncertaintyAltitude);

   rtxPrintIndent ();
   rtxPrintUnsigned ("confidence", pvalue->confidence);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_PCI (const char* name, const lppa_PCI* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_EARFCN (const char* name, const lppa_EARFCN* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_ValueRSRP (const char* name, const lppa_ValueRSRP* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_ResultRSRP_Item_iE_Extensions_element 
   (const char* name, const lppa_ResultRSRP_Item_iE_Extensions_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("extensionValue", pvalue->extensionValue.numocts,
   pvalue->extensionValue.data);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_ResultRSRP_Item_iE_Extensions 
   (const char* name, const lppa_ResultRSRP_Item_iE_Extensions* pvalue)
{
   lppa_ResultRSRP_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultRSRP_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_ResultRSRP_Item_iE_Extensions_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_ResultRSRP_Item 
   (const char* name, const lppa_ResultRSRP_Item* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_PCI ("pCI", &pvalue->pCI);

   asn1Print_lppa_EARFCN ("eARFCN", &pvalue->eARFCN);

   if (pvalue->m.eCGIPresent) {
      asn1Print_lppa_ECGI ("eCGI", &pvalue->eCGI);
   }

   asn1Print_lppa_ValueRSRP ("valueRSRP", &pvalue->valueRSRP);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_lppa_ResultRSRP_Item_iE_Extensions ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_ResultRSRP 
   (const char* name, const lppa_ResultRSRP* pvalue)
{
   lppa_ResultRSRP_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultRSRP_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_ResultRSRP_Item (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_ValueRSRQ (const char* name, const lppa_ValueRSRQ* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_ResultRSRQ_Item_iE_Extensions_element 
   (const char* name, const lppa_ResultRSRQ_Item_iE_Extensions_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("extensionValue", pvalue->extensionValue.numocts,
   pvalue->extensionValue.data);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_ResultRSRQ_Item_iE_Extensions 
   (const char* name, const lppa_ResultRSRQ_Item_iE_Extensions* pvalue)
{
   lppa_ResultRSRQ_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultRSRQ_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_ResultRSRQ_Item_iE_Extensions_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_ResultRSRQ_Item 
   (const char* name, const lppa_ResultRSRQ_Item* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_PCI ("pCI", &pvalue->pCI);

   asn1Print_lppa_EARFCN ("eARFCN", &pvalue->eARFCN);

   if (pvalue->m.eCGIPresent) {
      asn1Print_lppa_ECGI ("eCGI", &pvalue->eCGI);
   }

   asn1Print_lppa_ValueRSRQ ("valueRSRQ", &pvalue->valueRSRQ);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_lppa_ResultRSRQ_Item_iE_Extensions ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_ResultRSRQ 
   (const char* name, const lppa_ResultRSRQ* pvalue)
{
   lppa_ResultRSRQ_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultRSRQ_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_ResultRSRQ_Item (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_MeasuredResultsValue 
   (const char* name, const lppa_MeasuredResultsValue* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* valueAngleOfArrival */
      case 1:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("valueAngleOfArrival", pvalue->u.valueAngleOfArrival);
         break;
      }
      /* valueTimingAdvanceType1 */
      case 2:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("valueTimingAdvanceType1", pvalue->u.valueTimingAdvanceType1);
         break;
      }
      /* valueTimingAdvanceType2 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("valueTimingAdvanceType2", pvalue->u.valueTimingAdvanceType2);
         break;
      }
      /* resultRSRP */
      case 4:
      {
         asn1Print_lppa_ResultRSRP ("resultRSRP", pvalue->u.resultRSRP);
         break;
      }
      /* resultRSRQ */
      case 5:
      {
         asn1Print_lppa_ResultRSRQ ("resultRSRQ", pvalue->u.resultRSRQ);
         break;
      }
      /* extElem1 */
      case 6:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_MeasuredResults 
   (const char* name, const lppa_MeasuredResults* pvalue)
{
   lppa_MeasuredResultsValue* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_MeasuredResultsValue*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_MeasuredResultsValue (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_E_CID_MeasurementResult 
   (const char* name, const lppa_E_CID_MeasurementResult* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ECGI ("servingCell_ID", &pvalue->servingCell_ID);

   asn1Print_lppa_TAC ("servingCellTAC", &pvalue->servingCellTAC);

   if (pvalue->m.e_UTRANAccessPointPositionPresent) {
      asn1Print_lppa_E_UTRANAccessPointPosition ("e_UTRANAccessPointPosition", 
         &pvalue->e_UTRANAccessPointPosition);
   }

   if (pvalue->m.measuredResultsPresent) {
      asn1Print_lppa_MeasuredResults ("measuredResults", &pvalue->
         measuredResults);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_Cell_Portion_ID 
   (const char* name, const lppa_Cell_Portion_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_TypeOfError 
   (const char* name, const lppa_TypeOfError* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("not-understood\n"); break;
      case 1: printf ("missing\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element 
   (const char* name, const lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("extensionValue", pvalue->extensionValue.numocts,
   pvalue->extensionValue.data);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions 
   (const char* name, const lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions* pvalue)
{
   lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (
         namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_CriticalityDiagnostics_IE_List_element 
   (const char* name, const lppa_CriticalityDiagnostics_IE_List_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_Criticality ("iECriticality", &pvalue->iECriticality);

   asn1Print_lppa_ProtocolIE_ID ("iE_ID", &pvalue->iE_ID);

   asn1Print_lppa_TypeOfError ("typeOfError", &pvalue->typeOfError);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions (
         "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_CriticalityDiagnostics_IE_List 
   (const char* name, const lppa_CriticalityDiagnostics_IE_List* pvalue)
{
   lppa_CriticalityDiagnostics_IE_List_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_CriticalityDiagnostics_IE_List_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_CriticalityDiagnostics_IE_List_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_CriticalityDiagnostics_iE_Extensions_element 
   (const char* name, const lppa_CriticalityDiagnostics_iE_Extensions_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("extensionValue", pvalue->extensionValue.numocts,
   pvalue->extensionValue.data);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_CriticalityDiagnostics_iE_Extensions 
   (const char* name, const lppa_CriticalityDiagnostics_iE_Extensions* pvalue)
{
   lppa_CriticalityDiagnostics_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_CriticalityDiagnostics_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_CriticalityDiagnostics_iE_Extensions_element (namebuf, 
         pdata0);
      xx1++;
   }
}

void asn1Print_lppa_CriticalityDiagnostics 
   (const char* name, const lppa_CriticalityDiagnostics* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.procedureCodePresent) {
      asn1Print_lppa_ProcedureCode ("procedureCode", &pvalue->procedureCode);
   }

   if (pvalue->m.triggeringMessagePresent) {
      asn1Print_lppa_TriggeringMessage ("triggeringMessage", &pvalue->
         triggeringMessage);
   }

   if (pvalue->m.procedureCriticalityPresent) {
      asn1Print_lppa_Criticality ("procedureCriticality", &pvalue->
         procedureCriticality);
   }

   if (pvalue->m.lppatransactionIDPresent) {
      asn1Print_lppa_LPPATransactionID ("lppatransactionID", &pvalue->
         lppatransactionID);
   }

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      asn1Print_lppa_CriticalityDiagnostics_IE_List (
         "iEsCriticalityDiagnostics", &pvalue->iEsCriticalityDiagnostics);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_lppa_CriticalityDiagnostics_iE_Extensions ("iE_Extensions", &
         pvalue->iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_SRSConfigurationForOneCell_ul_bandwidth 
   (const char* name, const lppa_SRSConfigurationForOneCell_ul_bandwidth* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n6\n"); break;
      case 1: printf ("n15\n"); break;
      case 2: printf ("n25\n"); break;
      case 3: printf ("n50\n"); break;
      case 4: printf ("n75\n"); break;
      case 5: printf ("n100\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_lppa_CPLength (const char* name, const lppa_CPLength* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("normal\n"); break;
      case 1: printf ("extended\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_lppa_SRSConfigurationForOneCell_srs_BandwidthConfig 
   (const char* name, const lppa_SRSConfigurationForOneCell_srs_BandwidthConfig* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("bw0\n"); break;
      case 1: printf ("bw1\n"); break;
      case 2: printf ("bw2\n"); break;
      case 3: printf ("bw3\n"); break;
      case 4: printf ("bw4\n"); break;
      case 5: printf ("bw5\n"); break;
      case 6: printf ("bw6\n"); break;
      case 7: printf ("bw7\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_lppa_SRSConfigurationForOneCell_srs_Bandwidth 
   (const char* name, const lppa_SRSConfigurationForOneCell_srs_Bandwidth* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("bw0\n"); break;
      case 1: printf ("bw1\n"); break;
      case 2: printf ("bw2\n"); break;
      case 3: printf ("bw3\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_lppa_SRSConfigurationForOneCell_srs_AntennaPort 
   (const char* name, const lppa_SRSConfigurationForOneCell_srs_AntennaPort* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("an1\n"); break;
      case 1: printf ("an2\n"); break;
      case 2: printf ("an4\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth 
   (const char* name, const lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("hbw0\n"); break;
      case 1: printf ("hbw1\n"); break;
      case 2: printf ("hbw2\n"); break;
      case 3: printf ("hbw3\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_lppa_SRSConfigurationForOneCell_srs_cyclicShift 
   (const char* name, const lppa_SRSConfigurationForOneCell_srs_cyclicShift* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("cs0\n"); break;
      case 1: printf ("cs1\n"); break;
      case 2: printf ("cs2\n"); break;
      case 3: printf ("cs3\n"); break;
      case 4: printf ("cs4\n"); break;
      case 5: printf ("cs5\n"); break;
      case 6: printf ("cs6\n"); break;
      case 7: printf ("cs7\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_lppa_SRSConfigurationForOneCell_maxUpPts 
   (const char* name, const lppa_SRSConfigurationForOneCell_maxUpPts* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("true\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_lppa_SFNInitialisationTime 
   (const char* name, const lppa_SFNInitialisationTime* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_lppa_SRSConfigurationForOneCell 
   (const char* name, const lppa_SRSConfigurationForOneCell* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_PCI ("pci", &pvalue->pci);

   asn1Print_lppa_EARFCN ("ul_earfcn", &pvalue->ul_earfcn);

   asn1Print_lppa_SRSConfigurationForOneCell_ul_bandwidth ("ul_bandwidth", &
      pvalue->ul_bandwidth);

   asn1Print_lppa_CPLength ("ul_cyclicPrefixLength", &pvalue->
      ul_cyclicPrefixLength);

   asn1Print_lppa_SRSConfigurationForOneCell_srs_BandwidthConfig (
      "srs_BandwidthConfig", &pvalue->srs_BandwidthConfig);

   asn1Print_lppa_SRSConfigurationForOneCell_srs_Bandwidth ("srs_Bandwidth", &
      pvalue->srs_Bandwidth);

   asn1Print_lppa_SRSConfigurationForOneCell_srs_AntennaPort (
      "srs_AntennaPort", &pvalue->srs_AntennaPort);

   asn1Print_lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth (
      "srs_HoppingBandwidth", &pvalue->srs_HoppingBandwidth);

   asn1Print_lppa_SRSConfigurationForOneCell_srs_cyclicShift (
      "srs_cyclicShift", &pvalue->srs_cyclicShift);

   rtxPrintIndent ();
   rtxPrintUnsigned ("srs_ConfigIndex", pvalue->srs_ConfigIndex);

   if (pvalue->m.maxUpPtsPresent) {
      asn1Print_lppa_SRSConfigurationForOneCell_maxUpPts ("maxUpPts", &pvalue->
         maxUpPts);
   }

   rtxPrintIndent ();
   rtxPrintUnsigned ("transmissionComb", pvalue->transmissionComb);

   rtxPrintIndent ();
   rtxPrintUnsigned ("freqDomainPosition", pvalue->freqDomainPosition);

   rtxPrintIndent ();
   rtxPrintBoolean ("groupHoppingEnabled", pvalue->groupHoppingEnabled);

   if (pvalue->m.deltaSSPresent) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("deltaSS", pvalue->deltaSS);
   }

   asn1Print_lppa_SFNInitialisationTime ("sfnInitialisationTime", &pvalue->
      sfnInitialisationTime);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_SRSConfigurationForAllCells 
   (const char* name, const lppa_SRSConfigurationForAllCells* pvalue)
{
   lppa_SRSConfigurationForOneCell* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_SRSConfigurationForOneCell*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_SRSConfigurationForOneCell (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_ULConfiguration 
   (const char* name, const lppa_ULConfiguration* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_PCI ("pci", &pvalue->pci);

   asn1Print_lppa_EARFCN ("ul_earfcn", &pvalue->ul_earfcn);

   if (pvalue->m.timingAdvanceType1Present) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("timingAdvanceType1", pvalue->timingAdvanceType1);
   }

   if (pvalue->m.timingAdvanceType2Present) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("timingAdvanceType2", pvalue->timingAdvanceType2);
   }

   rtxPrintIndent ();
   rtxPrintUnsigned ("numberOfTransmissions", pvalue->numberOfTransmissions);

   asn1Print_lppa_SRSConfigurationForAllCells ("srsConfiguration", &pvalue->
      srsConfiguration);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_BCCH (const char* name, const lppa_BCCH* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_PhysCellIDGERAN 
   (const char* name, const lppa_PhysCellIDGERAN* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_RSSI (const char* name, const lppa_RSSI* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_ResultGERAN_Item_iE_Extensions_element 
   (const char* name, const lppa_ResultGERAN_Item_iE_Extensions_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("extensionValue", pvalue->extensionValue.numocts,
   pvalue->extensionValue.data);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_ResultGERAN_Item_iE_Extensions 
   (const char* name, const lppa_ResultGERAN_Item_iE_Extensions* pvalue)
{
   lppa_ResultGERAN_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultGERAN_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_ResultGERAN_Item_iE_Extensions_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_ResultGERAN_Item 
   (const char* name, const lppa_ResultGERAN_Item* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_BCCH ("bCCH", &pvalue->bCCH);

   asn1Print_lppa_PhysCellIDGERAN ("physCellIDGERAN", &pvalue->physCellIDGERAN
      );

   asn1Print_lppa_RSSI ("rSSI", &pvalue->rSSI);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_lppa_ResultGERAN_Item_iE_Extensions ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_ResultGERAN 
   (const char* name, const lppa_ResultGERAN* pvalue)
{
   lppa_ResultGERAN_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultGERAN_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_ResultGERAN_Item (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_UARFCN (const char* name, const lppa_UARFCN* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_PhysCellIDUTRA_FDD 
   (const char* name, const lppa_PhysCellIDUTRA_FDD* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_PhysCellIDUTRA_TDD 
   (const char* name, const lppa_PhysCellIDUTRA_TDD* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_ResultUTRAN_Item_physCellIDUTRAN 
   (const char* name, const lppa_ResultUTRAN_Item_physCellIDUTRAN* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* physCellIDUTRA-FDD */
      case 1:
      {
         asn1Print_lppa_PhysCellIDUTRA_FDD ("physCellIDUTRA-FDD", &pvalue->
            u.physCellIDUTRA_FDD);
         break;
      }
      /* physCellIDUTRA-TDD */
      case 2:
      {
         asn1Print_lppa_PhysCellIDUTRA_TDD ("physCellIDUTRA-TDD", &pvalue->
            u.physCellIDUTRA_TDD);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_UTRA_RSCP (const char* name, const lppa_UTRA_RSCP* pvalue)
{
   rtxPrintIndent ();
   rtxPrintInteger (name, *pvalue);
}

void asn1Print_lppa_UTRA_EcN0 (const char* name, const lppa_UTRA_EcN0* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_ResultUTRAN_Item_iE_Extensions_element 
   (const char* name, const lppa_ResultUTRAN_Item_iE_Extensions_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("extensionValue", pvalue->extensionValue.numocts,
   pvalue->extensionValue.data);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_ResultUTRAN_Item_iE_Extensions 
   (const char* name, const lppa_ResultUTRAN_Item_iE_Extensions* pvalue)
{
   lppa_ResultUTRAN_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultUTRAN_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_ResultUTRAN_Item_iE_Extensions_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_ResultUTRAN_Item 
   (const char* name, const lppa_ResultUTRAN_Item* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_UARFCN ("uARFCN", &pvalue->uARFCN);

   asn1Print_lppa_ResultUTRAN_Item_physCellIDUTRAN ("physCellIDUTRAN", &pvalue
      ->physCellIDUTRAN);

   if (pvalue->m.uTRA_RSCPPresent) {
      asn1Print_lppa_UTRA_RSCP ("uTRA_RSCP", &pvalue->uTRA_RSCP);
   }

   if (pvalue->m.uTRA_EcN0Present) {
      asn1Print_lppa_UTRA_EcN0 ("uTRA_EcN0", &pvalue->uTRA_EcN0);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_lppa_ResultUTRAN_Item_iE_Extensions ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_ResultUTRAN 
   (const char* name, const lppa_ResultUTRAN* pvalue)
{
   lppa_ResultUTRAN_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultUTRAN_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_ResultUTRAN_Item (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_InterRATMeasuredResultsValue 
   (const char* name, const lppa_InterRATMeasuredResultsValue* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* resultGERAN */
      case 1:
      {
         asn1Print_lppa_ResultGERAN ("resultGERAN", pvalue->u.resultGERAN);
         break;
      }
      /* resultUTRAN */
      case 2:
      {
         asn1Print_lppa_ResultUTRAN ("resultUTRAN", pvalue->u.resultUTRAN);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_InterRATMeasurementResult 
   (const char* name, const lppa_InterRATMeasurementResult* pvalue)
{
   lppa_InterRATMeasuredResultsValue* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_InterRATMeasuredResultsValue*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_InterRATMeasuredResultsValue (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_PRS_Bandwidth 
   (const char* name, const lppa_PRS_Bandwidth* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("bw6\n"); break;
      case 1: printf ("bw15\n"); break;
      case 2: printf ("bw25\n"); break;
      case 3: printf ("bw50\n"); break;
      case 4: printf ("bw75\n"); break;
      case 5: printf ("bw100\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_lppa_PRS_Configuration_Index 
   (const char* name, const lppa_PRS_Configuration_Index* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_lppa_NumberOfDlFrames 
   (const char* name, const lppa_NumberOfDlFrames* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sf1\n"); break;
      case 1: printf ("sf2\n"); break;
      case 2: printf ("sf4\n"); break;
      case 3: printf ("sf6\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_lppa_NumberOfAntennaPorts 
   (const char* name, const lppa_NumberOfAntennaPorts* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n1-or-n2\n"); break;
      case 1: printf ("n4\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_lppa_PRSMutingConfiguration 
   (const char* name, const lppa_PRSMutingConfiguration* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* two */
      case 1:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("two", pvalue->u.two->numbits, pvalue->u.two->data);
         break;
      }
      /* four */
      case 2:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("four", pvalue->u.four->numbits, pvalue->u.four->data);
         break;
      }
      /* eight */
      case 3:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("eight", pvalue->u.eight->numbits, pvalue->u.eight->data);
         break;
      }
      /* sixteen */
      case 4:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("sixteen", pvalue->u.sixteen->numbits, pvalue->u.sixteen->data);
         break;
      }
      /* extElem1 */
      case 5:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_OTDOACell_Information_Item 
   (const char* name, const lppa_OTDOACell_Information_Item* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* pCI */
      case 1:
      {
         asn1Print_lppa_PCI ("pCI", &pvalue->u.pCI);
         break;
      }
      /* cellId */
      case 2:
      {
         asn1Print_lppa_ECGI ("cellId", pvalue->u.cellId);
         break;
      }
      /* tAC */
      case 3:
      {
         asn1Print_lppa_TAC ("tAC", pvalue->u.tAC);
         break;
      }
      /* eARFCN */
      case 4:
      {
         asn1Print_lppa_EARFCN ("eARFCN", &pvalue->u.eARFCN);
         break;
      }
      /* pRS-Bandwidth */
      case 5:
      {
         asn1Print_lppa_PRS_Bandwidth ("pRS-Bandwidth", &pvalue->
            u.pRS_Bandwidth);
         break;
      }
      /* pRS-ConfigurationIndex */
      case 6:
      {
         asn1Print_lppa_PRS_Configuration_Index ("pRS-ConfigurationIndex", &
            pvalue->u.pRS_ConfigurationIndex);
         break;
      }
      /* cPLength */
      case 7:
      {
         asn1Print_lppa_CPLength ("cPLength", &pvalue->u.cPLength);
         break;
      }
      /* numberOfDlFrames */
      case 8:
      {
         asn1Print_lppa_NumberOfDlFrames ("numberOfDlFrames", &pvalue->
            u.numberOfDlFrames);
         break;
      }
      /* numberOfAntennaPorts */
      case 9:
      {
         asn1Print_lppa_NumberOfAntennaPorts ("numberOfAntennaPorts", &pvalue->
            u.numberOfAntennaPorts);
         break;
      }
      /* sFNInitialisationTime */
      case 10:
      {
         asn1Print_lppa_SFNInitialisationTime ("sFNInitialisationTime", pvalue
            ->u.sFNInitialisationTime);
         break;
      }
      /* e-UTRANAccessPointPosition */
      case 11:
      {
         asn1Print_lppa_E_UTRANAccessPointPosition (
            "e-UTRANAccessPointPosition", pvalue->u.e_UTRANAccessPointPosition
            );
         break;
      }
      /* pRSMutingConfiguration */
      case 12:
      {
         asn1Print_lppa_PRSMutingConfiguration ("pRSMutingConfiguration", 
            pvalue->u.pRSMutingConfiguration);
         break;
      }
      /* extElem1 */
      case 13:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_OTDOACell_Information 
   (const char* name, const lppa_OTDOACell_Information* pvalue)
{
   lppa_OTDOACell_Information_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOACell_Information_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_OTDOACell_Information_Item (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_OTDOACells_element_iE_Extensions_element 
   (const char* name, const lppa_OTDOACells_element_iE_Extensions_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("extensionValue", pvalue->extensionValue.numocts,
   pvalue->extensionValue.data);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_OTDOACells_element_iE_Extensions 
   (const char* name, const lppa_OTDOACells_element_iE_Extensions* pvalue)
{
   lppa_OTDOACells_element_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOACells_element_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_OTDOACells_element_iE_Extensions_element (namebuf, pdata0
         );
      xx1++;
   }
}

void asn1Print_lppa_OTDOACells_element 
   (const char* name, const lppa_OTDOACells_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_OTDOACell_Information ("oTDOACellInfo", &pvalue->
      oTDOACellInfo);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_lppa_OTDOACells_element_iE_Extensions ("iE_Extensions", &pvalue
         ->iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_OTDOACells 
   (const char* name, const lppa_OTDOACells* pvalue)
{
   lppa_OTDOACells_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOACells_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_OTDOACells_element (namebuf, pdata0);
      xx1++;
   }
}

int asn1PrtToStr_lppa_Measurement_ID (const char* name, 
   lppa_Measurement_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_ReportCharacteristics (const char* name, 
   lppa_ReportCharacteristics* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = onDemand\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = periodic\n", buffer, bufSize);
         break;

      default: stat = rtPrintToStringUnsigned ("", *pvalue, buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_MeasurementPeriodicity (const char* name, 
   lppa_MeasurementPeriodicity* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = ms120\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = ms240\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = ms480\n", buffer, bufSize);
         break;

      case 3:
         stat = rtPrintToString (" = ms640\n", buffer, bufSize);
         break;

      case 4:
         stat = rtPrintToString (" = ms1024\n", buffer, bufSize);
         break;

      case 5:
         stat = rtPrintToString (" = ms2048\n", buffer, bufSize);
         break;

      case 6:
         stat = rtPrintToString (" = ms5120\n", buffer, bufSize);
         break;

      case 7:
         stat = rtPrintToString (" = ms10240\n", buffer, bufSize);
         break;

      case 8:
         stat = rtPrintToString (" = min1\n", buffer, bufSize);
         break;

      case 9:
         stat = rtPrintToString (" = min6\n", buffer, bufSize);
         break;

      case 10:
         stat = rtPrintToString (" = min12\n", buffer, bufSize);
         break;

      case 11:
         stat = rtPrintToString (" = min30\n", buffer, bufSize);
         break;

      case 12:
         stat = rtPrintToString (" = min60\n", buffer, bufSize);
         break;

      default: stat = rtPrintToStringUnsigned ("", *pvalue, buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_MeasurementQuantitiesValue (const char* name, 
   lppa_MeasurementQuantitiesValue* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = cell-ID\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = angleOfArrival\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = timingAdvanceType1\n", buffer, bufSize);
         break;

      case 3:
         stat = rtPrintToString (" = timingAdvanceType2\n", buffer, bufSize);
         break;

      case 4:
         stat = rtPrintToString (" = rSRP\n", buffer, bufSize);
         break;

      case 5:
         stat = rtPrintToString (" = rSRQ\n", buffer, bufSize);
         break;

      default: stat = rtPrintToStringUnsigned ("", *pvalue, buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_MeasurementQuantities_Item_iE_Extensions_element (
   const char* name, 
   lppa_MeasurementQuantities_Item_iE_Extensions_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringHexStr ("extensionValue", pvalue->extensionValue.numocts, pvalue->extensionValue.data, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_MeasurementQuantities_Item_iE_Extensions (
   const char* name, lppa_MeasurementQuantities_Item_iE_Extensions* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   lppa_MeasurementQuantities_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_MeasurementQuantities_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_MeasurementQuantities_Item_iE_Extensions_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_MeasurementQuantities_Item (const char* name, 
   lppa_MeasurementQuantities_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_MeasurementQuantitiesValue ("measurementQuantitiesValue", &pvalue->measurementQuantitiesValue, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      if (asn1PrtToStr_lppa_MeasurementQuantities_Item_iE_Extensions ("iE_Extensions", &pvalue->iE_Extensions, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_MeasurementQuantities_element (const char* name, 
   lppa_MeasurementQuantities_element* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_MeasurementQuantities_Item ("value", &pvalue->value, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_MeasurementQuantities (const char* name, 
   lppa_MeasurementQuantities* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_MeasurementQuantities_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_MeasurementQuantities_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_MeasurementQuantities_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_InterRATMeasurementQuantitiesValue (const char* name, 
   lppa_InterRATMeasurementQuantitiesValue* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = geran\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = utran\n", buffer, bufSize);
         break;

      default: stat = rtPrintToStringUnsigned ("", *pvalue, buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element (
   const char* name, 
   lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringHexStr ("extensionValue", pvalue->extensionValue.numocts, pvalue->extensionValue.data, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_InterRATMeasurementQuantities_Item_iE_Extensions (
   const char* name, 
   lppa_InterRATMeasurementQuantities_Item_iE_Extensions* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_InterRATMeasurementQuantities_Item (const char* name, 
   lppa_InterRATMeasurementQuantities_Item* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_InterRATMeasurementQuantitiesValue ("interRATMeasurementQuantitiesValue", &pvalue->interRATMeasurementQuantitiesValue, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      if (asn1PrtToStr_lppa_InterRATMeasurementQuantities_Item_iE_Extensions ("iE_Extensions", &pvalue->iE_Extensions, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_InterRATMeasurementQuantities_element (const char* name, 
   lppa_InterRATMeasurementQuantities_element* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_InterRATMeasurementQuantities_Item ("value", &pvalue->value, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_InterRATMeasurementQuantities (const char* name, 
   lppa_InterRATMeasurementQuantities* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_InterRATMeasurementQuantities_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_InterRATMeasurementQuantities_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_InterRATMeasurementQuantities_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_OTDOA_Information_Item (const char* name, 
   lppa_OTDOA_Information_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = pci\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = cellid\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = tac\n", buffer, bufSize);
         break;

      case 3:
         stat = rtPrintToString (" = earfcn\n", buffer, bufSize);
         break;

      case 4:
         stat = rtPrintToString (" = prsBandwidth\n", buffer, bufSize);
         break;

      case 5:
         stat = rtPrintToString (" = prsConfigIndex\n", buffer, bufSize);
         break;

      case 6:
         stat = rtPrintToString (" = cpLength\n", buffer, bufSize);
         break;

      case 7:
         stat = rtPrintToString (" = noDlFrames\n", buffer, bufSize);
         break;

      case 8:
         stat = rtPrintToString (" = noAntennaPorts\n", buffer, bufSize);
         break;

      case 9:
         stat = rtPrintToString (" = sFNInitTime\n", buffer, bufSize);
         break;

      case 10:
         stat = rtPrintToString (" = e-UTRANAccessPointPosition\n", buffer, bufSize);
         break;

      case 11:
         stat = rtPrintToString (" = prsmutingconfiguration\n", buffer, bufSize);
         break;

      default: stat = rtPrintToStringUnsigned ("", *pvalue, buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_RequestedSRSTransmissionCharacteristics (
   const char* name, lppa_RequestedSRSTransmissionCharacteristics* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned ("numberOfTransmissions", pvalue->numberOfTransmissions, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned ("bandwidth", pvalue->bandwidth, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_CauseRadioNetwork (const char* name, 
   lppa_CauseRadioNetwork* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = unspecified\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = requested-item-not-supported\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = requested-item-temporarily-not-available\n", buffer, bufSize);
         break;

      default: stat = rtPrintToStringUnsigned ("", *pvalue, buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_CauseProtocol (const char* name, 
   lppa_CauseProtocol* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = transfer-syntax-error\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = abstract-syntax-error-reject\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = abstract-syntax-error-ignore-and-notify\n", buffer, bufSize);
         break;

      case 3:
         stat = rtPrintToString (" = message-not-compatible-with-receiver-state\n", buffer, bufSize);
         break;

      case 4:
         stat = rtPrintToString (" = semantic-error\n", buffer, bufSize);
         break;

      case 5:
         stat = rtPrintToString (" = unspecified\n", buffer, bufSize);
         break;

      case 6:
         stat = rtPrintToString (" = abstract-syntax-error-falsely-constructed-message\n", buffer, bufSize);
         break;

      default: stat = rtPrintToStringUnsigned ("", *pvalue, buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_CauseMisc (const char* name, lppa_CauseMisc* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = unspecified\n", buffer, bufSize);
         break;

      default: stat = rtPrintToStringUnsigned ("", *pvalue, buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_Cause (const char* name, lppa_Cause* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->t) {
      /* radioNetwork */
      case 1:
      {
         if (asn1PrtToStr_lppa_CauseRadioNetwork ("radioNetwork", &pvalue->u.radioNetwork, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* protocol */
      case 2:
      {
         if (asn1PrtToStr_lppa_CauseProtocol ("protocol", &pvalue->u.protocol, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* misc */
      case 3:
      {
         if (asn1PrtToStr_lppa_CauseMisc ("misc", &pvalue->u.misc, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* extElem1 */
      case 4:
      {
         if(rtPrintToStringIndent (buffer, bufSize) < 0)
         {
            return -1;
         }
         if(rtPrintToStringHexStr ("extElem1", pvalue->u.extElem1->numocts, pvalue->u.extElem1->data, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default:;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_PLMN_Identity (const char* name, 
   lppa_PLMN_Identity* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if (rtPrintToStringHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_EUTRANCellIdentifier (const char* name, 
   lppa_EUTRANCellIdentifier* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringBitStrBraceText (name, pvalue->numbits, pvalue->data, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_ECGI_iE_Extensions_element (const char* name, 
   lppa_ECGI_iE_Extensions_element* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringHexStr ("extensionValue", pvalue->extensionValue.numocts, pvalue->extensionValue.data, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_ECGI_iE_Extensions (const char* name, 
   lppa_ECGI_iE_Extensions* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_ECGI_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ECGI_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_ECGI_iE_Extensions_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_ECGI (const char* name, lppa_ECGI* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_PLMN_Identity ("pLMN_Identity", &pvalue->pLMN_Identity, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_EUTRANCellIdentifier ("eUTRANcellIdentifier", &pvalue->eUTRANcellIdentifier, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      if (asn1PrtToStr_lppa_ECGI_iE_Extensions ("iE_Extensions", &pvalue->iE_Extensions, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_TAC (const char* name, lppa_TAC* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if (rtPrintToStringHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_E_UTRANAccessPointPosition_latitudeSign (
   const char* name, lppa_E_UTRANAccessPointPosition_latitudeSign* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = north\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = south\n", buffer, bufSize);
         break;

      default:
      stat = rtPrintToString (" = ???\n", buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_E_UTRANAccessPointPosition_directionOfAltitude (
   const char* name, 
   lppa_E_UTRANAccessPointPosition_directionOfAltitude* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = height\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = depth\n", buffer, bufSize);
         break;

      default:
      stat = rtPrintToString (" = ???\n", buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_E_UTRANAccessPointPosition (const char* name, 
   lppa_E_UTRANAccessPointPosition* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_E_UTRANAccessPointPosition_latitudeSign ("latitudeSign", &pvalue->latitudeSign, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned ("latitude", pvalue->latitude, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringInteger ("longitude", pvalue->longitude, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_E_UTRANAccessPointPosition_directionOfAltitude ("directionOfAltitude", &pvalue->directionOfAltitude, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned ("altitude", pvalue->altitude, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned ("uncertaintySemi_major", pvalue->uncertaintySemi_major, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned ("uncertaintySemi_minor", pvalue->uncertaintySemi_minor, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned ("orientationOfMajorAxis", pvalue->orientationOfMajorAxis, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned ("uncertaintyAltitude", pvalue->uncertaintyAltitude, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned ("confidence", pvalue->confidence, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_PCI (const char* name, lppa_PCI* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_EARFCN (const char* name, lppa_EARFCN* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_ValueRSRP (const char* name, lppa_ValueRSRP* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_ResultRSRP_Item_iE_Extensions_element (const char* name, 
   lppa_ResultRSRP_Item_iE_Extensions_element* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringHexStr ("extensionValue", pvalue->extensionValue.numocts, pvalue->extensionValue.data, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_ResultRSRP_Item_iE_Extensions (const char* name, 
   lppa_ResultRSRP_Item_iE_Extensions* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_ResultRSRP_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultRSRP_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_ResultRSRP_Item_iE_Extensions_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_ResultRSRP_Item (const char* name, 
   lppa_ResultRSRP_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_PCI ("pCI", &pvalue->pCI, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_EARFCN ("eARFCN", &pvalue->eARFCN, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.eCGIPresent) {
      if (asn1PrtToStr_lppa_ECGI ("eCGI", &pvalue->eCGI, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (asn1PrtToStr_lppa_ValueRSRP ("valueRSRP", &pvalue->valueRSRP, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      if (asn1PrtToStr_lppa_ResultRSRP_Item_iE_Extensions ("iE_Extensions", &pvalue->iE_Extensions, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_ResultRSRP (const char* name, lppa_ResultRSRP* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   lppa_ResultRSRP_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultRSRP_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_ResultRSRP_Item (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_ValueRSRQ (const char* name, lppa_ValueRSRQ* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_ResultRSRQ_Item_iE_Extensions_element (const char* name, 
   lppa_ResultRSRQ_Item_iE_Extensions_element* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringHexStr ("extensionValue", pvalue->extensionValue.numocts, pvalue->extensionValue.data, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_ResultRSRQ_Item_iE_Extensions (const char* name, 
   lppa_ResultRSRQ_Item_iE_Extensions* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_ResultRSRQ_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultRSRQ_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_ResultRSRQ_Item_iE_Extensions_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_ResultRSRQ_Item (const char* name, 
   lppa_ResultRSRQ_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_PCI ("pCI", &pvalue->pCI, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_EARFCN ("eARFCN", &pvalue->eARFCN, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.eCGIPresent) {
      if (asn1PrtToStr_lppa_ECGI ("eCGI", &pvalue->eCGI, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (asn1PrtToStr_lppa_ValueRSRQ ("valueRSRQ", &pvalue->valueRSRQ, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      if (asn1PrtToStr_lppa_ResultRSRQ_Item_iE_Extensions ("iE_Extensions", &pvalue->iE_Extensions, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_ResultRSRQ (const char* name, lppa_ResultRSRQ* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   lppa_ResultRSRQ_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultRSRQ_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_ResultRSRQ_Item (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_MeasuredResultsValue (const char* name, 
   lppa_MeasuredResultsValue* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->t) {
      /* valueAngleOfArrival */
      case 1:
      {
         if (rtPrintToStringIndent (buffer, bufSize) < 0) {
            return -1;
         }
         if (rtPrintToStringUnsigned ("valueAngleOfArrival", pvalue->u.valueAngleOfArrival, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* valueTimingAdvanceType1 */
      case 2:
      {
         if (rtPrintToStringIndent (buffer, bufSize) < 0) {
            return -1;
         }
         if (rtPrintToStringUnsigned ("valueTimingAdvanceType1", pvalue->u.valueTimingAdvanceType1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* valueTimingAdvanceType2 */
      case 3:
      {
         if (rtPrintToStringIndent (buffer, bufSize) < 0) {
            return -1;
         }
         if (rtPrintToStringUnsigned ("valueTimingAdvanceType2", pvalue->u.valueTimingAdvanceType2, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* resultRSRP */
      case 4:
      {
         if (asn1PrtToStr_lppa_ResultRSRP ("resultRSRP", pvalue->u.resultRSRP, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* resultRSRQ */
      case 5:
      {
         if (asn1PrtToStr_lppa_ResultRSRQ ("resultRSRQ", pvalue->u.resultRSRQ, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* extElem1 */
      case 6:
      {
         if(rtPrintToStringIndent (buffer, bufSize) < 0)
         {
            return -1;
         }
         if(rtPrintToStringHexStr ("extElem1", pvalue->u.extElem1->numocts, pvalue->u.extElem1->data, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default:;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_MeasuredResults (const char* name, 
   lppa_MeasuredResults* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_MeasuredResultsValue* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_MeasuredResultsValue*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_MeasuredResultsValue (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_E_CID_MeasurementResult (const char* name, 
   lppa_E_CID_MeasurementResult* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ECGI ("servingCell_ID", &pvalue->servingCell_ID, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_TAC ("servingCellTAC", &pvalue->servingCellTAC, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.e_UTRANAccessPointPositionPresent) {
      if (asn1PrtToStr_lppa_E_UTRANAccessPointPosition ("e_UTRANAccessPointPosition", &pvalue->e_UTRANAccessPointPosition, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (pvalue->m.measuredResultsPresent) {
      if (asn1PrtToStr_lppa_MeasuredResults ("measuredResults", &pvalue->measuredResults, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_Cell_Portion_ID (const char* name, 
   lppa_Cell_Portion_ID* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_TypeOfError (const char* name, lppa_TypeOfError* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = not-understood\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = missing\n", buffer, bufSize);
         break;

      default: stat = rtPrintToStringUnsigned ("", *pvalue, buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (
   const char* name, 
   lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringHexStr ("extensionValue", pvalue->extensionValue.numocts, pvalue->extensionValue.data, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions (
   const char* name, 
   lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_CriticalityDiagnostics_IE_List_element (
   const char* name, lppa_CriticalityDiagnostics_IE_List_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("iECriticality", &pvalue->iECriticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("iE_ID", &pvalue->iE_ID, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_TypeOfError ("typeOfError", &pvalue->typeOfError, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      if (asn1PrtToStr_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions ("iE_Extensions", &pvalue->iE_Extensions, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_CriticalityDiagnostics_IE_List (const char* name, 
   lppa_CriticalityDiagnostics_IE_List* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_CriticalityDiagnostics_IE_List_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_CriticalityDiagnostics_IE_List_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_CriticalityDiagnostics_IE_List_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_CriticalityDiagnostics_iE_Extensions_element (
   const char* name, 
   lppa_CriticalityDiagnostics_iE_Extensions_element* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringHexStr ("extensionValue", pvalue->extensionValue.numocts, pvalue->extensionValue.data, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_CriticalityDiagnostics_iE_Extensions (const char* name, 
   lppa_CriticalityDiagnostics_iE_Extensions* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   lppa_CriticalityDiagnostics_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_CriticalityDiagnostics_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_CriticalityDiagnostics_iE_Extensions_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_CriticalityDiagnostics (const char* name, 
   lppa_CriticalityDiagnostics* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.procedureCodePresent) {
      if (asn1PrtToStr_lppa_ProcedureCode ("procedureCode", &pvalue->procedureCode, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (pvalue->m.triggeringMessagePresent) {
      if (asn1PrtToStr_lppa_TriggeringMessage ("triggeringMessage", &pvalue->triggeringMessage, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (pvalue->m.procedureCriticalityPresent) {
      if (asn1PrtToStr_lppa_Criticality ("procedureCriticality", &pvalue->procedureCriticality, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (pvalue->m.lppatransactionIDPresent) {
      if (asn1PrtToStr_lppa_LPPATransactionID ("lppatransactionID", &pvalue->lppatransactionID, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      if (asn1PrtToStr_lppa_CriticalityDiagnostics_IE_List ("iEsCriticalityDiagnostics", &pvalue->iEsCriticalityDiagnostics, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      if (asn1PrtToStr_lppa_CriticalityDiagnostics_iE_Extensions ("iE_Extensions", &pvalue->iE_Extensions, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_SRSConfigurationForOneCell_ul_bandwidth (
   const char* name, lppa_SRSConfigurationForOneCell_ul_bandwidth* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = n6\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = n15\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = n25\n", buffer, bufSize);
         break;

      case 3:
         stat = rtPrintToString (" = n50\n", buffer, bufSize);
         break;

      case 4:
         stat = rtPrintToString (" = n75\n", buffer, bufSize);
         break;

      case 5:
         stat = rtPrintToString (" = n100\n", buffer, bufSize);
         break;

      default:
      stat = rtPrintToString (" = ???\n", buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_CPLength (const char* name, lppa_CPLength* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = normal\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = extended\n", buffer, bufSize);
         break;

      default: stat = rtPrintToStringUnsigned ("", *pvalue, buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_SRSConfigurationForOneCell_srs_BandwidthConfig (
   const char* name, 
   lppa_SRSConfigurationForOneCell_srs_BandwidthConfig* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = bw0\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = bw1\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = bw2\n", buffer, bufSize);
         break;

      case 3:
         stat = rtPrintToString (" = bw3\n", buffer, bufSize);
         break;

      case 4:
         stat = rtPrintToString (" = bw4\n", buffer, bufSize);
         break;

      case 5:
         stat = rtPrintToString (" = bw5\n", buffer, bufSize);
         break;

      case 6:
         stat = rtPrintToString (" = bw6\n", buffer, bufSize);
         break;

      case 7:
         stat = rtPrintToString (" = bw7\n", buffer, bufSize);
         break;

      default:
      stat = rtPrintToString (" = ???\n", buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_SRSConfigurationForOneCell_srs_Bandwidth (
   const char* name, lppa_SRSConfigurationForOneCell_srs_Bandwidth* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = bw0\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = bw1\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = bw2\n", buffer, bufSize);
         break;

      case 3:
         stat = rtPrintToString (" = bw3\n", buffer, bufSize);
         break;

      default:
      stat = rtPrintToString (" = ???\n", buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_SRSConfigurationForOneCell_srs_AntennaPort (
   const char* name, lppa_SRSConfigurationForOneCell_srs_AntennaPort* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = an1\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = an2\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = an4\n", buffer, bufSize);
         break;

      default: stat = rtPrintToStringUnsigned ("", *pvalue, buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth (
   const char* name, 
   lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = hbw0\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = hbw1\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = hbw2\n", buffer, bufSize);
         break;

      case 3:
         stat = rtPrintToString (" = hbw3\n", buffer, bufSize);
         break;

      default:
      stat = rtPrintToString (" = ???\n", buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_SRSConfigurationForOneCell_srs_cyclicShift (
   const char* name, lppa_SRSConfigurationForOneCell_srs_cyclicShift* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = cs0\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = cs1\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = cs2\n", buffer, bufSize);
         break;

      case 3:
         stat = rtPrintToString (" = cs3\n", buffer, bufSize);
         break;

      case 4:
         stat = rtPrintToString (" = cs4\n", buffer, bufSize);
         break;

      case 5:
         stat = rtPrintToString (" = cs5\n", buffer, bufSize);
         break;

      case 6:
         stat = rtPrintToString (" = cs6\n", buffer, bufSize);
         break;

      case 7:
         stat = rtPrintToString (" = cs7\n", buffer, bufSize);
         break;

      default:
      stat = rtPrintToString (" = ???\n", buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_SRSConfigurationForOneCell_maxUpPts (const char* name, 
   lppa_SRSConfigurationForOneCell_maxUpPts* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = true\n", buffer, bufSize);
         break;

      default:
      stat = rtPrintToString (" = ???\n", buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_SFNInitialisationTime (const char* name, 
   lppa_SFNInitialisationTime* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringBitStrBraceText (name, pvalue->numbits, pvalue->data, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_SRSConfigurationForOneCell (const char* name, 
   lppa_SRSConfigurationForOneCell* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_PCI ("pci", &pvalue->pci, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_EARFCN ("ul_earfcn", &pvalue->ul_earfcn, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_SRSConfigurationForOneCell_ul_bandwidth ("ul_bandwidth", &pvalue->ul_bandwidth, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_CPLength ("ul_cyclicPrefixLength", &pvalue->ul_cyclicPrefixLength, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_SRSConfigurationForOneCell_srs_BandwidthConfig ("srs_BandwidthConfig", &pvalue->srs_BandwidthConfig, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_SRSConfigurationForOneCell_srs_Bandwidth ("srs_Bandwidth", &pvalue->srs_Bandwidth, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_SRSConfigurationForOneCell_srs_AntennaPort ("srs_AntennaPort", &pvalue->srs_AntennaPort, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth ("srs_HoppingBandwidth", &pvalue->srs_HoppingBandwidth, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_SRSConfigurationForOneCell_srs_cyclicShift ("srs_cyclicShift", &pvalue->srs_cyclicShift, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned ("srs_ConfigIndex", pvalue->srs_ConfigIndex, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.maxUpPtsPresent) {
      if (asn1PrtToStr_lppa_SRSConfigurationForOneCell_maxUpPts ("maxUpPts", &pvalue->maxUpPts, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned ("transmissionComb", pvalue->transmissionComb, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned ("freqDomainPosition", pvalue->freqDomainPosition, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringBoolean ("groupHoppingEnabled", pvalue->groupHoppingEnabled, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.deltaSSPresent) {
      if (rtPrintToStringIndent (buffer, bufSize) < 0) {
         return -1;
      }
      if (rtPrintToStringUnsigned ("deltaSS", pvalue->deltaSS, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (asn1PrtToStr_lppa_SFNInitialisationTime ("sfnInitialisationTime", &pvalue->sfnInitialisationTime, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_SRSConfigurationForAllCells (const char* name, 
   lppa_SRSConfigurationForAllCells* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_SRSConfigurationForOneCell* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_SRSConfigurationForOneCell*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_SRSConfigurationForOneCell (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_ULConfiguration (const char* name, 
   lppa_ULConfiguration* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_PCI ("pci", &pvalue->pci, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_EARFCN ("ul_earfcn", &pvalue->ul_earfcn, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.timingAdvanceType1Present) {
      if (rtPrintToStringIndent (buffer, bufSize) < 0) {
         return -1;
      }
      if (rtPrintToStringUnsigned ("timingAdvanceType1", pvalue->timingAdvanceType1, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (pvalue->m.timingAdvanceType2Present) {
      if (rtPrintToStringIndent (buffer, bufSize) < 0) {
         return -1;
      }
      if (rtPrintToStringUnsigned ("timingAdvanceType2", pvalue->timingAdvanceType2, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned ("numberOfTransmissions", pvalue->numberOfTransmissions, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_SRSConfigurationForAllCells ("srsConfiguration", &pvalue->srsConfiguration, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_BCCH (const char* name, lppa_BCCH* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_PhysCellIDGERAN (const char* name, 
   lppa_PhysCellIDGERAN* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_RSSI (const char* name, lppa_RSSI* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_ResultGERAN_Item_iE_Extensions_element (
   const char* name, lppa_ResultGERAN_Item_iE_Extensions_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringHexStr ("extensionValue", pvalue->extensionValue.numocts, pvalue->extensionValue.data, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_ResultGERAN_Item_iE_Extensions (const char* name, 
   lppa_ResultGERAN_Item_iE_Extensions* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_ResultGERAN_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultGERAN_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_ResultGERAN_Item_iE_Extensions_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_ResultGERAN_Item (const char* name, 
   lppa_ResultGERAN_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_BCCH ("bCCH", &pvalue->bCCH, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_PhysCellIDGERAN ("physCellIDGERAN", &pvalue->physCellIDGERAN, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_RSSI ("rSSI", &pvalue->rSSI, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      if (asn1PrtToStr_lppa_ResultGERAN_Item_iE_Extensions ("iE_Extensions", &pvalue->iE_Extensions, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_ResultGERAN (const char* name, lppa_ResultGERAN* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   lppa_ResultGERAN_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultGERAN_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_ResultGERAN_Item (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_UARFCN (const char* name, lppa_UARFCN* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_PhysCellIDUTRA_FDD (const char* name, 
   lppa_PhysCellIDUTRA_FDD* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_PhysCellIDUTRA_TDD (const char* name, 
   lppa_PhysCellIDUTRA_TDD* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_ResultUTRAN_Item_physCellIDUTRAN (const char* name, 
   lppa_ResultUTRAN_Item_physCellIDUTRAN* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->t) {
      /* physCellIDUTRA-FDD */
      case 1:
      {
         if (asn1PrtToStr_lppa_PhysCellIDUTRA_FDD ("physCellIDUTRA-FDD", &pvalue->u.physCellIDUTRA_FDD, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* physCellIDUTRA-TDD */
      case 2:
      {
         if (asn1PrtToStr_lppa_PhysCellIDUTRA_TDD ("physCellIDUTRA-TDD", &pvalue->u.physCellIDUTRA_TDD, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default:;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_UTRA_RSCP (const char* name, lppa_UTRA_RSCP* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringInteger (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_UTRA_EcN0 (const char* name, lppa_UTRA_EcN0* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_ResultUTRAN_Item_iE_Extensions_element (
   const char* name, lppa_ResultUTRAN_Item_iE_Extensions_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringHexStr ("extensionValue", pvalue->extensionValue.numocts, pvalue->extensionValue.data, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_ResultUTRAN_Item_iE_Extensions (const char* name, 
   lppa_ResultUTRAN_Item_iE_Extensions* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_ResultUTRAN_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultUTRAN_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_ResultUTRAN_Item_iE_Extensions_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_ResultUTRAN_Item (const char* name, 
   lppa_ResultUTRAN_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_UARFCN ("uARFCN", &pvalue->uARFCN, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ResultUTRAN_Item_physCellIDUTRAN ("physCellIDUTRAN", &pvalue->physCellIDUTRAN, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.uTRA_RSCPPresent) {
      if (asn1PrtToStr_lppa_UTRA_RSCP ("uTRA_RSCP", &pvalue->uTRA_RSCP, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (pvalue->m.uTRA_EcN0Present) {
      if (asn1PrtToStr_lppa_UTRA_EcN0 ("uTRA_EcN0", &pvalue->uTRA_EcN0, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      if (asn1PrtToStr_lppa_ResultUTRAN_Item_iE_Extensions ("iE_Extensions", &pvalue->iE_Extensions, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_ResultUTRAN (const char* name, lppa_ResultUTRAN* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   lppa_ResultUTRAN_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultUTRAN_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_ResultUTRAN_Item (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_InterRATMeasuredResultsValue (const char* name, 
   lppa_InterRATMeasuredResultsValue* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->t) {
      /* resultGERAN */
      case 1:
      {
         if (asn1PrtToStr_lppa_ResultGERAN ("resultGERAN", pvalue->u.resultGERAN, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* resultUTRAN */
      case 2:
      {
         if (asn1PrtToStr_lppa_ResultUTRAN ("resultUTRAN", pvalue->u.resultUTRAN, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* extElem1 */
      case 3:
      {
         if(rtPrintToStringIndent (buffer, bufSize) < 0)
         {
            return -1;
         }
         if(rtPrintToStringHexStr ("extElem1", pvalue->u.extElem1->numocts, pvalue->u.extElem1->data, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default:;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_InterRATMeasurementResult (const char* name, 
   lppa_InterRATMeasurementResult* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_InterRATMeasuredResultsValue* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_InterRATMeasuredResultsValue*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_InterRATMeasuredResultsValue (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_PRS_Bandwidth (const char* name, 
   lppa_PRS_Bandwidth* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = bw6\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = bw15\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = bw25\n", buffer, bufSize);
         break;

      case 3:
         stat = rtPrintToString (" = bw50\n", buffer, bufSize);
         break;

      case 4:
         stat = rtPrintToString (" = bw75\n", buffer, bufSize);
         break;

      case 5:
         stat = rtPrintToString (" = bw100\n", buffer, bufSize);
         break;

      default: stat = rtPrintToStringUnsigned ("", *pvalue, buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_PRS_Configuration_Index (const char* name, 
   lppa_PRS_Configuration_Index* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringIndent (buffer, bufSize) < 0) {
      return -1;
   }
   if (rtPrintToStringUnsigned (name, *pvalue, buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_NumberOfDlFrames (const char* name, 
   lppa_NumberOfDlFrames* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = sf1\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = sf2\n", buffer, bufSize);
         break;

      case 2:
         stat = rtPrintToString (" = sf4\n", buffer, bufSize);
         break;

      case 3:
         stat = rtPrintToString (" = sf6\n", buffer, bufSize);
         break;

      default: stat = rtPrintToStringUnsigned ("", *pvalue, buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_NumberOfAntennaPorts (const char* name, 
   lppa_NumberOfAntennaPorts* pvalue, char* buffer, OSSIZE bufSize)
{
   int stat;
   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToString (name, buffer, bufSize) < 0)
   {
      return -1;
   }
   switch (*pvalue) {
      case 0:
         stat = rtPrintToString (" = n1-or-n2\n", buffer, bufSize);
         break;

      case 1:
         stat = rtPrintToString (" = n4\n", buffer, bufSize);
         break;

      default: stat = rtPrintToStringUnsigned ("", *pvalue, buffer, bufSize);
   }

   if(stat < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_PRSMutingConfiguration (const char* name, 
   lppa_PRSMutingConfiguration* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->t) {
      /* two */
      case 1:
      {
         if (rtPrintToStringIndent (buffer, bufSize) < 0) {
            return -1;
         }
         if (rtPrintToStringBitStrBraceText ("two", pvalue->u.two->numbits, pvalue->u.two->data, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* four */
      case 2:
      {
         if (rtPrintToStringIndent (buffer, bufSize) < 0) {
            return -1;
         }
         if (rtPrintToStringBitStrBraceText ("four", pvalue->u.four->numbits, pvalue->u.four->data, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* eight */
      case 3:
      {
         if (rtPrintToStringIndent (buffer, bufSize) < 0) {
            return -1;
         }
         if (rtPrintToStringBitStrBraceText ("eight", pvalue->u.eight->numbits, pvalue->u.eight->data, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* sixteen */
      case 4:
      {
         if (rtPrintToStringIndent (buffer, bufSize) < 0) {
            return -1;
         }
         if (rtPrintToStringBitStrBraceText ("sixteen", pvalue->u.sixteen->numbits, pvalue->u.sixteen->data, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* extElem1 */
      case 5:
      {
         if(rtPrintToStringIndent (buffer, bufSize) < 0)
         {
            return -1;
         }
         if(rtPrintToStringHexStr ("extElem1", pvalue->u.extElem1->numocts, pvalue->u.extElem1->data, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default:;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_OTDOACell_Information_Item (const char* name, 
   lppa_OTDOACell_Information_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->t) {
      /* pCI */
      case 1:
      {
         if (asn1PrtToStr_lppa_PCI ("pCI", &pvalue->u.pCI, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* cellId */
      case 2:
      {
         if (asn1PrtToStr_lppa_ECGI ("cellId", pvalue->u.cellId, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* tAC */
      case 3:
      {
         if (asn1PrtToStr_lppa_TAC ("tAC", pvalue->u.tAC, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* eARFCN */
      case 4:
      {
         if (asn1PrtToStr_lppa_EARFCN ("eARFCN", &pvalue->u.eARFCN, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* pRS-Bandwidth */
      case 5:
      {
         if (asn1PrtToStr_lppa_PRS_Bandwidth ("pRS-Bandwidth", &pvalue->u.pRS_Bandwidth, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* pRS-ConfigurationIndex */
      case 6:
      {
         if (asn1PrtToStr_lppa_PRS_Configuration_Index ("pRS-ConfigurationIndex", &pvalue->u.pRS_ConfigurationIndex, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* cPLength */
      case 7:
      {
         if (asn1PrtToStr_lppa_CPLength ("cPLength", &pvalue->u.cPLength, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* numberOfDlFrames */
      case 8:
      {
         if (asn1PrtToStr_lppa_NumberOfDlFrames ("numberOfDlFrames", &pvalue->u.numberOfDlFrames, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* numberOfAntennaPorts */
      case 9:
      {
         if (asn1PrtToStr_lppa_NumberOfAntennaPorts ("numberOfAntennaPorts", &pvalue->u.numberOfAntennaPorts, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* sFNInitialisationTime */
      case 10:
      {
         if (asn1PrtToStr_lppa_SFNInitialisationTime ("sFNInitialisationTime", pvalue->u.sFNInitialisationTime, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* e-UTRANAccessPointPosition */
      case 11:
      {
         if (asn1PrtToStr_lppa_E_UTRANAccessPointPosition ("e-UTRANAccessPointPosition", pvalue->u.e_UTRANAccessPointPosition, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* pRSMutingConfiguration */
      case 12:
      {
         if (asn1PrtToStr_lppa_PRSMutingConfiguration ("pRSMutingConfiguration", pvalue->u.pRSMutingConfiguration, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* extElem1 */
      case 13:
      {
         if(rtPrintToStringIndent (buffer, bufSize) < 0)
         {
            return -1;
         }
         if(rtPrintToStringHexStr ("extElem1", pvalue->u.extElem1->numocts, pvalue->u.extElem1->data, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default:;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStr_lppa_OTDOACell_Information (const char* name, 
   lppa_OTDOACell_Information* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_OTDOACell_Information_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOACell_Information_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_OTDOACell_Information_Item (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_OTDOACells_element_iE_Extensions_element (
   const char* name, lppa_OTDOACells_element_iE_Extensions_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringHexStr ("extensionValue", pvalue->extensionValue.numocts, pvalue->extensionValue.data, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_OTDOACells_element_iE_Extensions (const char* name, 
   lppa_OTDOACells_element_iE_Extensions* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_OTDOACells_element_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOACells_element_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_OTDOACells_element_iE_Extensions_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_OTDOACells_element (const char* name, 
   lppa_OTDOACells_element* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_OTDOACell_Information ("oTDOACellInfo", &pvalue->oTDOACellInfo, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      if (asn1PrtToStr_lppa_OTDOACells_element_iE_Extensions ("iE_Extensions", &pvalue->iE_Extensions, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_OTDOACells (const char* name, lppa_OTDOACells* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   lppa_OTDOACells_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOACells_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_OTDOACells_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_Measurement_ID (OSCTXT *pctxt, 
   const char* name, const lppa_Measurement_ID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_ReportCharacteristics (OSCTXT *pctxt, 
   const char* name, const lppa_ReportCharacteristics* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = onDemand\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = periodic\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_lppa_MeasurementPeriodicity (OSCTXT *pctxt, 
   const char* name, const lppa_MeasurementPeriodicity* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = ms120\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = ms240\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = ms480\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = ms640\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = ms1024\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = ms2048\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = ms5120\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = ms10240\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = min1\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = min6\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = min12\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = min30\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = min60\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_lppa_MeasurementQuantitiesValue (OSCTXT *pctxt, 
   const char* name, const lppa_MeasurementQuantitiesValue* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = cell-ID\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = angleOfArrival\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = timingAdvanceType1\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = timingAdvanceType2\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = rSRP\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = rSRQ\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_lppa_MeasurementQuantities_Item_iE_Extensions_element (OSCTXT *pctxt, 
   const char* name, const lppa_MeasurementQuantities_Item_iE_Extensions_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "extensionValue",
      pvalue->extensionValue.numocts, pvalue->extensionValue.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_MeasurementQuantities_Item_iE_Extensions (OSCTXT *pctxt, 
   const char* name, const lppa_MeasurementQuantities_Item_iE_Extensions* pvalue)
{
   lppa_MeasurementQuantities_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_MeasurementQuantities_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_MeasurementQuantities_Item_iE_Extensions_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_MeasurementQuantities_Item (OSCTXT *pctxt, 
   const char* name, const lppa_MeasurementQuantities_Item* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_MeasurementQuantitiesValue (pctxt, "measurementQuantitiesValue", &pvalue->measurementQuantitiesValue);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1PrtToStrm_lppa_MeasurementQuantities_Item_iE_Extensions (pctxt, "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_MeasurementQuantities_element (OSCTXT *pctxt, 
   const char* name, const lppa_MeasurementQuantities_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   asn1PrtToStrm_lppa_MeasurementQuantities_Item (pctxt, "value", &pvalue->value);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_MeasurementQuantities (OSCTXT *pctxt, 
   const char* name, const lppa_MeasurementQuantities* pvalue)
{
   lppa_MeasurementQuantities_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_MeasurementQuantities_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_MeasurementQuantities_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_InterRATMeasurementQuantitiesValue (OSCTXT *pctxt, 
   const char* name, const lppa_InterRATMeasurementQuantitiesValue* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = geran\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = utran\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element (OSCTXT *pctxt, 
   const char* name, const lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "extensionValue",
      pvalue->extensionValue.numocts, pvalue->extensionValue.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_InterRATMeasurementQuantities_Item_iE_Extensions (OSCTXT *pctxt, 
   const char* name, const lppa_InterRATMeasurementQuantities_Item_iE_Extensions* pvalue)
{
   lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_InterRATMeasurementQuantities_Item_iE_Extensions_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_InterRATMeasurementQuantities_Item (OSCTXT *pctxt, 
   const char* name, const lppa_InterRATMeasurementQuantities_Item* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_InterRATMeasurementQuantitiesValue (pctxt, "interRATMeasurementQuantitiesValue", &pvalue->interRATMeasurementQuantitiesValue);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1PrtToStrm_lppa_InterRATMeasurementQuantities_Item_iE_Extensions (pctxt, "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_InterRATMeasurementQuantities_element (OSCTXT *pctxt, 
   const char* name, const lppa_InterRATMeasurementQuantities_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   asn1PrtToStrm_lppa_InterRATMeasurementQuantities_Item (pctxt, "value", &pvalue->value);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_InterRATMeasurementQuantities (OSCTXT *pctxt, 
   const char* name, const lppa_InterRATMeasurementQuantities* pvalue)
{
   lppa_InterRATMeasurementQuantities_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_InterRATMeasurementQuantities_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_InterRATMeasurementQuantities_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_OTDOA_Information_Item (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOA_Information_Item* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = pci\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = cellid\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = tac\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = earfcn\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = prsBandwidth\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = prsConfigIndex\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = cpLength\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = noDlFrames\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = noAntennaPorts\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = sFNInitTime\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = e-UTRANAccessPointPosition\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = prsmutingconfiguration\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_lppa_RequestedSRSTransmissionCharacteristics (OSCTXT *pctxt, 
   const char* name, const lppa_RequestedSRSTransmissionCharacteristics* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "numberOfTransmissions", pvalue->numberOfTransmissions);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "bandwidth", pvalue->bandwidth);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_CauseRadioNetwork (OSCTXT *pctxt, 
   const char* name, const lppa_CauseRadioNetwork* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unspecified\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = requested-item-not-supported\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = requested-item-temporarily-not-available\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_lppa_CauseProtocol (OSCTXT *pctxt, 
   const char* name, const lppa_CauseProtocol* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = transfer-syntax-error\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = abstract-syntax-error-reject\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = abstract-syntax-error-ignore-and-notify\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = message-not-compatible-with-receiver-state\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = semantic-error\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = unspecified\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = abstract-syntax-error-falsely-constructed-message\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_lppa_CauseMisc (OSCTXT *pctxt, 
   const char* name, const lppa_CauseMisc* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unspecified\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_lppa_Cause (OSCTXT *pctxt, 
   const char* name, const lppa_Cause* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* radioNetwork */
      case 1:
      {
         asn1PrtToStrm_lppa_CauseRadioNetwork (pctxt, "radioNetwork", &pvalue->u.radioNetwork);
         break;
      }
      /* protocol */
      case 2:
      {
         asn1PrtToStrm_lppa_CauseProtocol (pctxt, "protocol", &pvalue->u.protocol);
         break;
      }
      /* misc */
      case 3:
      {
         asn1PrtToStrm_lppa_CauseMisc (pctxt, "misc", &pvalue->u.misc);
         break;
      }
      /* extElem1 */
      case 4:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamHexStr (pctxt, "extElem1",
            pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_PLMN_Identity (OSCTXT *pctxt, 
   const char* name, const lppa_PLMN_Identity* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
   return 0;
}

int asn1PrtToStrm_lppa_EUTRANCellIdentifier (OSCTXT *pctxt, 
   const char* name, const lppa_EUTRANCellIdentifier* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, pvalue->numbits, pvalue->data);
   return 0;
}

int asn1PrtToStrm_lppa_ECGI_iE_Extensions_element (OSCTXT *pctxt, 
   const char* name, const lppa_ECGI_iE_Extensions_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "extensionValue",
      pvalue->extensionValue.numocts, pvalue->extensionValue.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_ECGI_iE_Extensions (OSCTXT *pctxt, 
   const char* name, const lppa_ECGI_iE_Extensions* pvalue)
{
   lppa_ECGI_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ECGI_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_ECGI_iE_Extensions_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_ECGI (OSCTXT *pctxt, 
   const char* name, const lppa_ECGI* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_PLMN_Identity (pctxt, "pLMN_Identity", &pvalue->pLMN_Identity);

   asn1PrtToStrm_lppa_EUTRANCellIdentifier (pctxt, "eUTRANcellIdentifier", &pvalue->eUTRANcellIdentifier);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1PrtToStrm_lppa_ECGI_iE_Extensions (pctxt, "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_TAC (OSCTXT *pctxt, 
   const char* name, const lppa_TAC* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
   return 0;
}

int asn1PrtToStrm_lppa_E_UTRANAccessPointPosition_latitudeSign (OSCTXT *pctxt, 
   const char* name, const lppa_E_UTRANAccessPointPosition_latitudeSign* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = north\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = south\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_lppa_E_UTRANAccessPointPosition_directionOfAltitude (OSCTXT *pctxt, 
   const char* name, const lppa_E_UTRANAccessPointPosition_directionOfAltitude* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = height\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = depth\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_lppa_E_UTRANAccessPointPosition (OSCTXT *pctxt, 
   const char* name, const lppa_E_UTRANAccessPointPosition* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_E_UTRANAccessPointPosition_latitudeSign (pctxt, "latitudeSign", &pvalue->latitudeSign);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "latitude", pvalue->latitude);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, "longitude", pvalue->longitude);

   asn1PrtToStrm_lppa_E_UTRANAccessPointPosition_directionOfAltitude (pctxt, "directionOfAltitude", &pvalue->directionOfAltitude);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "altitude", pvalue->altitude);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "uncertaintySemi_major", pvalue->uncertaintySemi_major);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "uncertaintySemi_minor", pvalue->uncertaintySemi_minor);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "orientationOfMajorAxis", pvalue->orientationOfMajorAxis);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "uncertaintyAltitude", pvalue->uncertaintyAltitude);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "confidence", pvalue->confidence);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_PCI (OSCTXT *pctxt, 
   const char* name, const lppa_PCI* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_EARFCN (OSCTXT *pctxt, 
   const char* name, const lppa_EARFCN* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_ValueRSRP (OSCTXT *pctxt, 
   const char* name, const lppa_ValueRSRP* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_ResultRSRP_Item_iE_Extensions_element (OSCTXT *pctxt, 
   const char* name, const lppa_ResultRSRP_Item_iE_Extensions_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "extensionValue",
      pvalue->extensionValue.numocts, pvalue->extensionValue.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_ResultRSRP_Item_iE_Extensions (OSCTXT *pctxt, 
   const char* name, const lppa_ResultRSRP_Item_iE_Extensions* pvalue)
{
   lppa_ResultRSRP_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultRSRP_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_ResultRSRP_Item_iE_Extensions_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_ResultRSRP_Item (OSCTXT *pctxt, 
   const char* name, const lppa_ResultRSRP_Item* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_PCI (pctxt, "pCI", &pvalue->pCI);

   asn1PrtToStrm_lppa_EARFCN (pctxt, "eARFCN", &pvalue->eARFCN);

   if (pvalue->m.eCGIPresent) {
      asn1PrtToStrm_lppa_ECGI (pctxt, "eCGI", &pvalue->eCGI);
   }

   asn1PrtToStrm_lppa_ValueRSRP (pctxt, "valueRSRP", &pvalue->valueRSRP);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1PrtToStrm_lppa_ResultRSRP_Item_iE_Extensions (pctxt, "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_ResultRSRP (OSCTXT *pctxt, 
   const char* name, const lppa_ResultRSRP* pvalue)
{
   lppa_ResultRSRP_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultRSRP_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_ResultRSRP_Item (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_ValueRSRQ (OSCTXT *pctxt, 
   const char* name, const lppa_ValueRSRQ* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_ResultRSRQ_Item_iE_Extensions_element (OSCTXT *pctxt, 
   const char* name, const lppa_ResultRSRQ_Item_iE_Extensions_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "extensionValue",
      pvalue->extensionValue.numocts, pvalue->extensionValue.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_ResultRSRQ_Item_iE_Extensions (OSCTXT *pctxt, 
   const char* name, const lppa_ResultRSRQ_Item_iE_Extensions* pvalue)
{
   lppa_ResultRSRQ_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultRSRQ_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_ResultRSRQ_Item_iE_Extensions_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_ResultRSRQ_Item (OSCTXT *pctxt, 
   const char* name, const lppa_ResultRSRQ_Item* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_PCI (pctxt, "pCI", &pvalue->pCI);

   asn1PrtToStrm_lppa_EARFCN (pctxt, "eARFCN", &pvalue->eARFCN);

   if (pvalue->m.eCGIPresent) {
      asn1PrtToStrm_lppa_ECGI (pctxt, "eCGI", &pvalue->eCGI);
   }

   asn1PrtToStrm_lppa_ValueRSRQ (pctxt, "valueRSRQ", &pvalue->valueRSRQ);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1PrtToStrm_lppa_ResultRSRQ_Item_iE_Extensions (pctxt, "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_ResultRSRQ (OSCTXT *pctxt, 
   const char* name, const lppa_ResultRSRQ* pvalue)
{
   lppa_ResultRSRQ_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultRSRQ_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_ResultRSRQ_Item (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_MeasuredResultsValue (OSCTXT *pctxt, 
   const char* name, const lppa_MeasuredResultsValue* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* valueAngleOfArrival */
      case 1:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamUnsigned (pctxt, "valueAngleOfArrival", pvalue->u.valueAngleOfArrival);
         break;
      }
      /* valueTimingAdvanceType1 */
      case 2:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamUnsigned (pctxt, "valueTimingAdvanceType1", pvalue->u.valueTimingAdvanceType1);
         break;
      }
      /* valueTimingAdvanceType2 */
      case 3:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamUnsigned (pctxt, "valueTimingAdvanceType2", pvalue->u.valueTimingAdvanceType2);
         break;
      }
      /* resultRSRP */
      case 4:
      {
         asn1PrtToStrm_lppa_ResultRSRP (pctxt, "resultRSRP", pvalue->u.resultRSRP);
         break;
      }
      /* resultRSRQ */
      case 5:
      {
         asn1PrtToStrm_lppa_ResultRSRQ (pctxt, "resultRSRQ", pvalue->u.resultRSRQ);
         break;
      }
      /* extElem1 */
      case 6:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamHexStr (pctxt, "extElem1",
            pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_MeasuredResults (OSCTXT *pctxt, 
   const char* name, const lppa_MeasuredResults* pvalue)
{
   lppa_MeasuredResultsValue* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_MeasuredResultsValue*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_MeasuredResultsValue (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_E_CID_MeasurementResult (OSCTXT *pctxt, 
   const char* name, const lppa_E_CID_MeasurementResult* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ECGI (pctxt, "servingCell_ID", &pvalue->servingCell_ID);

   asn1PrtToStrm_lppa_TAC (pctxt, "servingCellTAC", &pvalue->servingCellTAC);

   if (pvalue->m.e_UTRANAccessPointPositionPresent) {
      asn1PrtToStrm_lppa_E_UTRANAccessPointPosition (pctxt, "e_UTRANAccessPointPosition", &pvalue->e_UTRANAccessPointPosition);
   }

   if (pvalue->m.measuredResultsPresent) {
      asn1PrtToStrm_lppa_MeasuredResults (pctxt, "measuredResults", &pvalue->measuredResults);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_Cell_Portion_ID (OSCTXT *pctxt, 
   const char* name, const lppa_Cell_Portion_ID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_TypeOfError (OSCTXT *pctxt, 
   const char* name, const lppa_TypeOfError* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = not-understood\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = missing\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (OSCTXT *pctxt, 
   const char* name, const lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "extensionValue",
      pvalue->extensionValue.numocts, pvalue->extensionValue.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions (OSCTXT *pctxt, 
   const char* name, const lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions* pvalue)
{
   lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_CriticalityDiagnostics_IE_List_element (OSCTXT *pctxt, 
   const char* name, const lppa_CriticalityDiagnostics_IE_List_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_Criticality (pctxt, "iECriticality", &pvalue->iECriticality);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "iE_ID", &pvalue->iE_ID);

   asn1PrtToStrm_lppa_TypeOfError (pctxt, "typeOfError", &pvalue->typeOfError);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1PrtToStrm_lppa_CriticalityDiagnostics_IE_List_element_iE_Extensions (pctxt, "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_CriticalityDiagnostics_IE_List (OSCTXT *pctxt, 
   const char* name, const lppa_CriticalityDiagnostics_IE_List* pvalue)
{
   lppa_CriticalityDiagnostics_IE_List_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_CriticalityDiagnostics_IE_List_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_CriticalityDiagnostics_IE_List_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_CriticalityDiagnostics_iE_Extensions_element (OSCTXT *pctxt, 
   const char* name, const lppa_CriticalityDiagnostics_iE_Extensions_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "extensionValue",
      pvalue->extensionValue.numocts, pvalue->extensionValue.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_CriticalityDiagnostics_iE_Extensions (OSCTXT *pctxt, 
   const char* name, const lppa_CriticalityDiagnostics_iE_Extensions* pvalue)
{
   lppa_CriticalityDiagnostics_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_CriticalityDiagnostics_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_CriticalityDiagnostics_iE_Extensions_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_CriticalityDiagnostics (OSCTXT *pctxt, 
   const char* name, const lppa_CriticalityDiagnostics* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.procedureCodePresent) {
      asn1PrtToStrm_lppa_ProcedureCode (pctxt, "procedureCode", &pvalue->procedureCode);
   }

   if (pvalue->m.triggeringMessagePresent) {
      asn1PrtToStrm_lppa_TriggeringMessage (pctxt, "triggeringMessage", &pvalue->triggeringMessage);
   }

   if (pvalue->m.procedureCriticalityPresent) {
      asn1PrtToStrm_lppa_Criticality (pctxt, "procedureCriticality", &pvalue->procedureCriticality);
   }

   if (pvalue->m.lppatransactionIDPresent) {
      asn1PrtToStrm_lppa_LPPATransactionID (pctxt, "lppatransactionID", &pvalue->lppatransactionID);
   }

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      asn1PrtToStrm_lppa_CriticalityDiagnostics_IE_List (pctxt, "iEsCriticalityDiagnostics", &pvalue->iEsCriticalityDiagnostics);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1PrtToStrm_lppa_CriticalityDiagnostics_iE_Extensions (pctxt, "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_SRSConfigurationForOneCell_ul_bandwidth (OSCTXT *pctxt, 
   const char* name, const lppa_SRSConfigurationForOneCell_ul_bandwidth* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = n6\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = n15\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = n25\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = n50\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = n75\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = n100\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_lppa_CPLength (OSCTXT *pctxt, 
   const char* name, const lppa_CPLength* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = normal\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = extended\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_lppa_SRSConfigurationForOneCell_srs_BandwidthConfig (OSCTXT *pctxt, 
   const char* name, const lppa_SRSConfigurationForOneCell_srs_BandwidthConfig* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = bw0\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = bw1\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = bw2\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = bw3\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = bw4\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = bw5\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = bw6\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = bw7\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_lppa_SRSConfigurationForOneCell_srs_Bandwidth (OSCTXT *pctxt, 
   const char* name, const lppa_SRSConfigurationForOneCell_srs_Bandwidth* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = bw0\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = bw1\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = bw2\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = bw3\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_lppa_SRSConfigurationForOneCell_srs_AntennaPort (OSCTXT *pctxt, 
   const char* name, const lppa_SRSConfigurationForOneCell_srs_AntennaPort* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = an1\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = an2\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = an4\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth (OSCTXT *pctxt, 
   const char* name, const lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = hbw0\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = hbw1\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = hbw2\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = hbw3\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_lppa_SRSConfigurationForOneCell_srs_cyclicShift (OSCTXT *pctxt, 
   const char* name, const lppa_SRSConfigurationForOneCell_srs_cyclicShift* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = cs0\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = cs1\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = cs2\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = cs3\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = cs4\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = cs5\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = cs6\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = cs7\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_lppa_SRSConfigurationForOneCell_maxUpPts (OSCTXT *pctxt, 
   const char* name, const lppa_SRSConfigurationForOneCell_maxUpPts* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = true\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_lppa_SFNInitialisationTime (OSCTXT *pctxt, 
   const char* name, const lppa_SFNInitialisationTime* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, pvalue->numbits, pvalue->data);
   return 0;
}

int asn1PrtToStrm_lppa_SRSConfigurationForOneCell (OSCTXT *pctxt, 
   const char* name, const lppa_SRSConfigurationForOneCell* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_PCI (pctxt, "pci", &pvalue->pci);

   asn1PrtToStrm_lppa_EARFCN (pctxt, "ul_earfcn", &pvalue->ul_earfcn);

   asn1PrtToStrm_lppa_SRSConfigurationForOneCell_ul_bandwidth (pctxt, "ul_bandwidth", &pvalue->ul_bandwidth);

   asn1PrtToStrm_lppa_CPLength (pctxt, "ul_cyclicPrefixLength", &pvalue->ul_cyclicPrefixLength);

   asn1PrtToStrm_lppa_SRSConfigurationForOneCell_srs_BandwidthConfig (pctxt, "srs_BandwidthConfig", &pvalue->srs_BandwidthConfig);

   asn1PrtToStrm_lppa_SRSConfigurationForOneCell_srs_Bandwidth (pctxt, "srs_Bandwidth", &pvalue->srs_Bandwidth);

   asn1PrtToStrm_lppa_SRSConfigurationForOneCell_srs_AntennaPort (pctxt, "srs_AntennaPort", &pvalue->srs_AntennaPort);

   asn1PrtToStrm_lppa_SRSConfigurationForOneCell_srs_HoppingBandwidth (pctxt, "srs_HoppingBandwidth", &pvalue->srs_HoppingBandwidth);

   asn1PrtToStrm_lppa_SRSConfigurationForOneCell_srs_cyclicShift (pctxt, "srs_cyclicShift", &pvalue->srs_cyclicShift);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "srs_ConfigIndex", pvalue->srs_ConfigIndex);

   if (pvalue->m.maxUpPtsPresent) {
      asn1PrtToStrm_lppa_SRSConfigurationForOneCell_maxUpPts (pctxt, "maxUpPts", &pvalue->maxUpPts);
   }

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "transmissionComb", pvalue->transmissionComb);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "freqDomainPosition", pvalue->freqDomainPosition);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBoolean (pctxt, "groupHoppingEnabled", pvalue->groupHoppingEnabled);

   if (pvalue->m.deltaSSPresent) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamUnsigned (pctxt, "deltaSS", pvalue->deltaSS);
   }

   asn1PrtToStrm_lppa_SFNInitialisationTime (pctxt, "sfnInitialisationTime", &pvalue->sfnInitialisationTime);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_SRSConfigurationForAllCells (OSCTXT *pctxt, 
   const char* name, const lppa_SRSConfigurationForAllCells* pvalue)
{
   lppa_SRSConfigurationForOneCell* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_SRSConfigurationForOneCell*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_SRSConfigurationForOneCell (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_ULConfiguration (OSCTXT *pctxt, 
   const char* name, const lppa_ULConfiguration* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_PCI (pctxt, "pci", &pvalue->pci);

   asn1PrtToStrm_lppa_EARFCN (pctxt, "ul_earfcn", &pvalue->ul_earfcn);

   if (pvalue->m.timingAdvanceType1Present) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamUnsigned (pctxt, "timingAdvanceType1", pvalue->timingAdvanceType1);
   }

   if (pvalue->m.timingAdvanceType2Present) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamUnsigned (pctxt, "timingAdvanceType2", pvalue->timingAdvanceType2);
   }

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "numberOfTransmissions", pvalue->numberOfTransmissions);

   asn1PrtToStrm_lppa_SRSConfigurationForAllCells (pctxt, "srsConfiguration", &pvalue->srsConfiguration);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_BCCH (OSCTXT *pctxt, 
   const char* name, const lppa_BCCH* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_PhysCellIDGERAN (OSCTXT *pctxt, 
   const char* name, const lppa_PhysCellIDGERAN* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_RSSI (OSCTXT *pctxt, 
   const char* name, const lppa_RSSI* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_ResultGERAN_Item_iE_Extensions_element (OSCTXT *pctxt, 
   const char* name, const lppa_ResultGERAN_Item_iE_Extensions_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "extensionValue",
      pvalue->extensionValue.numocts, pvalue->extensionValue.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_ResultGERAN_Item_iE_Extensions (OSCTXT *pctxt, 
   const char* name, const lppa_ResultGERAN_Item_iE_Extensions* pvalue)
{
   lppa_ResultGERAN_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultGERAN_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_ResultGERAN_Item_iE_Extensions_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_ResultGERAN_Item (OSCTXT *pctxt, 
   const char* name, const lppa_ResultGERAN_Item* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_BCCH (pctxt, "bCCH", &pvalue->bCCH);

   asn1PrtToStrm_lppa_PhysCellIDGERAN (pctxt, "physCellIDGERAN", &pvalue->physCellIDGERAN);

   asn1PrtToStrm_lppa_RSSI (pctxt, "rSSI", &pvalue->rSSI);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1PrtToStrm_lppa_ResultGERAN_Item_iE_Extensions (pctxt, "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_ResultGERAN (OSCTXT *pctxt, 
   const char* name, const lppa_ResultGERAN* pvalue)
{
   lppa_ResultGERAN_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultGERAN_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_ResultGERAN_Item (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_UARFCN (OSCTXT *pctxt, 
   const char* name, const lppa_UARFCN* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_PhysCellIDUTRA_FDD (OSCTXT *pctxt, 
   const char* name, const lppa_PhysCellIDUTRA_FDD* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_PhysCellIDUTRA_TDD (OSCTXT *pctxt, 
   const char* name, const lppa_PhysCellIDUTRA_TDD* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_ResultUTRAN_Item_physCellIDUTRAN (OSCTXT *pctxt, 
   const char* name, const lppa_ResultUTRAN_Item_physCellIDUTRAN* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* physCellIDUTRA-FDD */
      case 1:
      {
         asn1PrtToStrm_lppa_PhysCellIDUTRA_FDD (pctxt, "physCellIDUTRA-FDD", &pvalue->u.physCellIDUTRA_FDD);
         break;
      }
      /* physCellIDUTRA-TDD */
      case 2:
      {
         asn1PrtToStrm_lppa_PhysCellIDUTRA_TDD (pctxt, "physCellIDUTRA-TDD", &pvalue->u.physCellIDUTRA_TDD);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_UTRA_RSCP (OSCTXT *pctxt, 
   const char* name, const lppa_UTRA_RSCP* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_UTRA_EcN0 (OSCTXT *pctxt, 
   const char* name, const lppa_UTRA_EcN0* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_ResultUTRAN_Item_iE_Extensions_element (OSCTXT *pctxt, 
   const char* name, const lppa_ResultUTRAN_Item_iE_Extensions_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "extensionValue",
      pvalue->extensionValue.numocts, pvalue->extensionValue.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_ResultUTRAN_Item_iE_Extensions (OSCTXT *pctxt, 
   const char* name, const lppa_ResultUTRAN_Item_iE_Extensions* pvalue)
{
   lppa_ResultUTRAN_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultUTRAN_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_ResultUTRAN_Item_iE_Extensions_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_ResultUTRAN_Item (OSCTXT *pctxt, 
   const char* name, const lppa_ResultUTRAN_Item* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_UARFCN (pctxt, "uARFCN", &pvalue->uARFCN);

   asn1PrtToStrm_lppa_ResultUTRAN_Item_physCellIDUTRAN (pctxt, "physCellIDUTRAN", &pvalue->physCellIDUTRAN);

   if (pvalue->m.uTRA_RSCPPresent) {
      asn1PrtToStrm_lppa_UTRA_RSCP (pctxt, "uTRA_RSCP", &pvalue->uTRA_RSCP);
   }

   if (pvalue->m.uTRA_EcN0Present) {
      asn1PrtToStrm_lppa_UTRA_EcN0 (pctxt, "uTRA_EcN0", &pvalue->uTRA_EcN0);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1PrtToStrm_lppa_ResultUTRAN_Item_iE_Extensions (pctxt, "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_ResultUTRAN (OSCTXT *pctxt, 
   const char* name, const lppa_ResultUTRAN* pvalue)
{
   lppa_ResultUTRAN_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ResultUTRAN_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_ResultUTRAN_Item (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_InterRATMeasuredResultsValue (OSCTXT *pctxt, 
   const char* name, const lppa_InterRATMeasuredResultsValue* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* resultGERAN */
      case 1:
      {
         asn1PrtToStrm_lppa_ResultGERAN (pctxt, "resultGERAN", pvalue->u.resultGERAN);
         break;
      }
      /* resultUTRAN */
      case 2:
      {
         asn1PrtToStrm_lppa_ResultUTRAN (pctxt, "resultUTRAN", pvalue->u.resultUTRAN);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamHexStr (pctxt, "extElem1",
            pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_InterRATMeasurementResult (OSCTXT *pctxt, 
   const char* name, const lppa_InterRATMeasurementResult* pvalue)
{
   lppa_InterRATMeasuredResultsValue* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_InterRATMeasuredResultsValue*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_InterRATMeasuredResultsValue (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_PRS_Bandwidth (OSCTXT *pctxt, 
   const char* name, const lppa_PRS_Bandwidth* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = bw6\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = bw15\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = bw25\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = bw50\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = bw75\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = bw100\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_lppa_PRS_Configuration_Index (OSCTXT *pctxt, 
   const char* name, const lppa_PRS_Configuration_Index* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_lppa_NumberOfDlFrames (OSCTXT *pctxt, 
   const char* name, const lppa_NumberOfDlFrames* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = sf1\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = sf2\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = sf4\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = sf6\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_lppa_NumberOfAntennaPorts (OSCTXT *pctxt, 
   const char* name, const lppa_NumberOfAntennaPorts* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = n1-or-n2\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = n4\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_lppa_PRSMutingConfiguration (OSCTXT *pctxt, 
   const char* name, const lppa_PRSMutingConfiguration* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* two */
      case 1:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamBitStrBraceText (pctxt, "two", pvalue->u.two->numbits, pvalue->u.two->data);
         break;
      }
      /* four */
      case 2:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamBitStrBraceText (pctxt, "four", pvalue->u.four->numbits, pvalue->u.four->data);
         break;
      }
      /* eight */
      case 3:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamBitStrBraceText (pctxt, "eight", pvalue->u.eight->numbits, pvalue->u.eight->data);
         break;
      }
      /* sixteen */
      case 4:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamBitStrBraceText (pctxt, "sixteen", pvalue->u.sixteen->numbits, pvalue->u.sixteen->data);
         break;
      }
      /* extElem1 */
      case 5:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamHexStr (pctxt, "extElem1",
            pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_OTDOACell_Information_Item (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOACell_Information_Item* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* pCI */
      case 1:
      {
         asn1PrtToStrm_lppa_PCI (pctxt, "pCI", &pvalue->u.pCI);
         break;
      }
      /* cellId */
      case 2:
      {
         asn1PrtToStrm_lppa_ECGI (pctxt, "cellId", pvalue->u.cellId);
         break;
      }
      /* tAC */
      case 3:
      {
         asn1PrtToStrm_lppa_TAC (pctxt, "tAC", pvalue->u.tAC);
         break;
      }
      /* eARFCN */
      case 4:
      {
         asn1PrtToStrm_lppa_EARFCN (pctxt, "eARFCN", &pvalue->u.eARFCN);
         break;
      }
      /* pRS-Bandwidth */
      case 5:
      {
         asn1PrtToStrm_lppa_PRS_Bandwidth (pctxt, "pRS-Bandwidth", &pvalue->u.pRS_Bandwidth);
         break;
      }
      /* pRS-ConfigurationIndex */
      case 6:
      {
         asn1PrtToStrm_lppa_PRS_Configuration_Index (pctxt, "pRS-ConfigurationIndex", &pvalue->u.pRS_ConfigurationIndex);
         break;
      }
      /* cPLength */
      case 7:
      {
         asn1PrtToStrm_lppa_CPLength (pctxt, "cPLength", &pvalue->u.cPLength);
         break;
      }
      /* numberOfDlFrames */
      case 8:
      {
         asn1PrtToStrm_lppa_NumberOfDlFrames (pctxt, "numberOfDlFrames", &pvalue->u.numberOfDlFrames);
         break;
      }
      /* numberOfAntennaPorts */
      case 9:
      {
         asn1PrtToStrm_lppa_NumberOfAntennaPorts (pctxt, "numberOfAntennaPorts", &pvalue->u.numberOfAntennaPorts);
         break;
      }
      /* sFNInitialisationTime */
      case 10:
      {
         asn1PrtToStrm_lppa_SFNInitialisationTime (pctxt, "sFNInitialisationTime", pvalue->u.sFNInitialisationTime);
         break;
      }
      /* e-UTRANAccessPointPosition */
      case 11:
      {
         asn1PrtToStrm_lppa_E_UTRANAccessPointPosition (pctxt, "e-UTRANAccessPointPosition", pvalue->u.e_UTRANAccessPointPosition);
         break;
      }
      /* pRSMutingConfiguration */
      case 12:
      {
         asn1PrtToStrm_lppa_PRSMutingConfiguration (pctxt, "pRSMutingConfiguration", pvalue->u.pRSMutingConfiguration);
         break;
      }
      /* extElem1 */
      case 13:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamHexStr (pctxt, "extElem1",
            pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_OTDOACell_Information (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOACell_Information* pvalue)
{
   lppa_OTDOACell_Information_Item* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOACell_Information_Item*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_OTDOACell_Information_Item (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_OTDOACells_element_iE_Extensions_element (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOACells_element_iE_Extensions_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "extensionValue",
      pvalue->extensionValue.numocts, pvalue->extensionValue.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_OTDOACells_element_iE_Extensions (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOACells_element_iE_Extensions* pvalue)
{
   lppa_OTDOACells_element_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOACells_element_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_OTDOACells_element_iE_Extensions_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_OTDOACells_element (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOACells_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_OTDOACell_Information (pctxt, "oTDOACellInfo", &pvalue->oTDOACellInfo);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1PrtToStrm_lppa_OTDOACells_element_iE_Extensions (pctxt, "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_OTDOACells (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOACells* pvalue)
{
   lppa_OTDOACells_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOACells_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_OTDOACells_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

void asn1SetTC_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element_lppa_E_CIDMeasurementInitiationRequest_IEs_1
   (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pElem, lppa_Measurement_ID value)
{
   pElem->id = 2;
   pElem->criticality = lppa_reject;
   pElem->value.t = T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_1;
   pElem->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_1 = value;
}

void asn1SetTC_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element_lppa_E_CIDMeasurementInitiationRequest_IEs_2
   (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pElem, lppa_ReportCharacteristics value)
{
   pElem->id = 3;
   pElem->criticality = lppa_reject;
   pElem->value.t = T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_2;
   pElem->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_2 = value;
}

void asn1SetTC_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element_lppa_E_CIDMeasurementInitiationRequest_IEs_3
   (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pElem, lppa_MeasurementPeriodicity value)
{
   pElem->id = 4;
   pElem->criticality = lppa_reject;
   pElem->value.t = T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_3;
   pElem->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_3 = value;
}

void asn1SetTC_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element_lppa_E_CIDMeasurementInitiationRequest_IEs_4
   (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pElem, lppa_MeasurementQuantities *pvalue)
{
   pElem->id = 5;
   pElem->criticality = lppa_reject;
   pElem->value.t = T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_4;
   pElem->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_4 = pvalue;
}

void asn1SetTC_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element_lppa_E_CIDMeasurementInitiationRequest_IEs_5
   (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pElem, lppa_InterRATMeasurementQuantities *pvalue)
{
   pElem->id = 15;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_5;
   pElem->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_5 = pvalue;
}

EXTERN int asn1PE_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_E_CIDMeasurementInitiationRequest_IEs_1 */
   case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementInitiationRequest_IEs_1");

      stat = asn1PE_lppa_Measurement_ID (pctxt, pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementInitiationRequest_IEs_2 */
   case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_2:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementInitiationRequest_IEs_2");

      stat = asn1PE_lppa_ReportCharacteristics (pctxt, pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementInitiationRequest_IEs_3 */
   case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_3:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementInitiationRequest_IEs_3");

      stat = asn1PE_lppa_MeasurementPeriodicity (pctxt, pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementInitiationRequest_IEs_4 */
   case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_4:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementInitiationRequest_IEs_4");

      stat = asn1PE_lppa_MeasurementQuantities (pctxt, pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_4);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementInitiationRequest_IEs_5 */
   case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_5:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementInitiationRequest_IEs_5");

      stat = asn1PE_lppa_InterRATMeasurementQuantities (pctxt, pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T4lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_E_SMLC_UE_Measurement_ID:
      pvalue->value.t = T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_1;

      stat = asn1PD_lppa_Measurement_ID (pctxt, &pvalue->value.
         u._lppa_E_CIDMeasurementInitiationRequest_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_ReportCharacteristics:
      pvalue->value.t = T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_2;

      stat = asn1PD_lppa_ReportCharacteristics (pctxt, &pvalue->value.
         u._lppa_E_CIDMeasurementInitiationRequest_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_MeasurementPeriodicity:
      pvalue->value.t = T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_3;

      stat = asn1PD_lppa_MeasurementPeriodicity (pctxt, &pvalue->value.
         u._lppa_E_CIDMeasurementInitiationRequest_IEs_3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_MeasurementQuantities:
      pvalue->value.t = T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_4;

      pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_4
          = rtxMemAllocType (pctxt, lppa_MeasurementQuantities);

      if (pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_4
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_MeasurementQuantities (pvalue->value.
         u._lppa_E_CIDMeasurementInitiationRequest_IEs_4);

      stat = asn1PD_lppa_MeasurementQuantities (pctxt, pvalue->value.
         u._lppa_E_CIDMeasurementInitiationRequest_IEs_4);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_InterRATMeasurementQuantities:
      pvalue->value.t = T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_5;

      pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_5
          = rtxMemAllocType (pctxt, lppa_InterRATMeasurementQuantities);

      if (pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_5
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_InterRATMeasurementQuantities (pvalue->value.
         u._lppa_E_CIDMeasurementInitiationRequest_IEs_5);

      stat = asn1PD_lppa_InterRATMeasurementQuantities (pctxt, pvalue->value.
         u._lppa_E_CIDMeasurementInitiationRequest_IEs_5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T4lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element (
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_4:
         if (0 != pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_4) {
            asn1Free_lppa_MeasurementQuantities (pctxt, pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_4);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_4);
         }
         break;

      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_5:
         if (0 != pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_5) {
            asn1Free_lppa_InterRATMeasurementQuantities (pctxt, pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_5);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_5);
         }
         break;

      default:;
   }
}

int asn1Append_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_1
      (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs* plist
   , lppa_Measurement_ID value)
{
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element_lppa_E_CIDMeasurementInitiationRequest_IEs_1 (pctxt, pElem
      , value);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_2
      (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs* plist
   , lppa_ReportCharacteristics value)
{
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element_lppa_E_CIDMeasurementInitiationRequest_IEs_2 (pctxt, pElem
      , value);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_3
      (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs* plist
   , lppa_MeasurementPeriodicity value)
{
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element_lppa_E_CIDMeasurementInitiationRequest_IEs_3 (pctxt, pElem
      , value);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_4
      (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs* plist
   , lppa_MeasurementQuantities *pvalue)
{
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element_lppa_E_CIDMeasurementInitiationRequest_IEs_4 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_5
      (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs* plist
   , lppa_InterRATMeasurementQuantities *pvalue)
{
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element_lppa_E_CIDMeasurementInitiationRequest_IEs_5 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* 
   asn1Get_lppa_E_CIDMeasurementInitiationRequest_protocolIEs 
   (lppa_ProtocolIE_ID id, 
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_E_CIDMeasurementInitiationRequest_protocolIEs (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element (pctxt, ((lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementInitiationRequest_protocolIEs (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementInitiationRequest_protocolIEs (
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementInitiationRequest_protocolIEs (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs* pvalue)
{
   if (0 == pvalue) return;
   { lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element*)pnode->data;
      asn1Free_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_E_CIDMeasurementInitiationRequest (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-CIDMeasurementInitiationRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_lppa_E_CIDMeasurementInitiationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementInitiationRequest (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-CIDMeasurementInitiationRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_lppa_E_CIDMeasurementInitiationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementInitiationRequest (
   lppa_E_CIDMeasurementInitiationRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_E_CIDMeasurementInitiationRequest_protocolIEs (&pvalue->protocolIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementInitiationRequest (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementInitiationRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_E_CIDMeasurementInitiationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_OTDOA_Information_Type_Item_iE_Extensions_element (OSCTXT* pctxt, lppa_OTDOA_Information_Type_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode extensionValue */

   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pe_OpenType (pctxt, pvalue->extensionValue.numocts, pvalue->extensionValue.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOA_Information_Type_Item_iE_Extensions_element (OSCTXT* pctxt, lppa_OTDOA_Information_Type_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_OTDOA_Information_Type_Item_iE_Extensions_element (
   lppa_OTDOA_Information_Type_Item_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->extensionValue.numocts = 0;
   pvalue->extensionValue.data = 0;
   return 0;
}

void asn1Free_lppa_OTDOA_Information_Type_Item_iE_Extensions_element (OSCTXT *pctxt, 
   lppa_OTDOA_Information_Type_Item_iE_Extensions_element* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->extensionValue.data);
   }
}

EXTERN int asn1PE_lppa_OTDOA_Information_Type_Item_iE_Extensions (OSCTXT* pctxt, lppa_OTDOA_Information_Type_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_OTDOA_Information_Type_Item_iE_Extensions_element (pctxt, ((lppa_OTDOA_Information_Type_Item_iE_Extensions_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOA_Information_Type_Item_iE_Extensions (OSCTXT* pctxt, lppa_OTDOA_Information_Type_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_OTDOA_Information_Type_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_OTDOA_Information_Type_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_OTDOA_Information_Type_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_OTDOA_Information_Type_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_OTDOA_Information_Type_Item_iE_Extensions (
   lppa_OTDOA_Information_Type_Item_iE_Extensions* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_OTDOA_Information_Type_Item_iE_Extensions (OSCTXT *pctxt, 
   lppa_OTDOA_Information_Type_Item_iE_Extensions* pvalue)
{
   if (0 == pvalue) return;
   { lppa_OTDOA_Information_Type_Item_iE_Extensions_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_OTDOA_Information_Type_Item_iE_Extensions_element*)pnode->data;
      asn1Free_lppa_OTDOA_Information_Type_Item_iE_Extensions_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_OTDOA_Information_Type_Item (OSCTXT* pctxt, lppa_OTDOA_Information_Type_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOA-Information-Type-Item");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode oTDOA_Information_Type_Item */

   RTXCTXTPUSHELEMNAME (pctxt, "oTDOA-Information-Type-Item");

   stat = asn1PE_lppa_OTDOA_Information_Item (pctxt, pvalue->oTDOA_Information_Type_Item);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_lppa_OTDOA_Information_Type_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOA_Information_Type_Item (OSCTXT* pctxt, lppa_OTDOA_Information_Type_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOA-Information-Type-Item");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode oTDOA_Information_Type_Item */
   RTXCTXTPUSHELEMNAME (pctxt, "oTDOA-Information-Type-Item");

   stat = asn1PD_lppa_OTDOA_Information_Item (pctxt, &pvalue->oTDOA_Information_Type_Item);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_lppa_OTDOA_Information_Type_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_OTDOA_Information_Type_Item (
   lppa_OTDOA_Information_Type_Item* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_lppa_OTDOA_Information_Type_Item_iE_Extensions (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_OTDOA_Information_Type_Item (OSCTXT *pctxt, 
   lppa_OTDOA_Information_Type_Item* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_lppa_OTDOA_Information_Type_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_OTDOA_Information_Type_element (OSCTXT* pctxt, lppa_OTDOA_Information_Type_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_OTDOA_Information_TypeIEs_1 */
   case T11lppa___lppa_OTDOA_Information_TypeIEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_OTDOA_Information_TypeIEs_1");

      stat = asn1PE_lppa_OTDOA_Information_Type_Item (pctxt, pvalue->value.u._lppa_OTDOA_Information_TypeIEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T11lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOA_Information_Type_element (OSCTXT* pctxt, lppa_OTDOA_Information_Type_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_OTDOA_Information_Type_Item:
      pvalue->value.t = T11lppa___lppa_OTDOA_Information_TypeIEs_1;

      pvalue->value.u._lppa_OTDOA_Information_TypeIEs_1
          = rtxMemAllocType (pctxt, lppa_OTDOA_Information_Type_Item);

      if (pvalue->value.u._lppa_OTDOA_Information_TypeIEs_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_OTDOA_Information_Type_Item (pvalue->value.
         u._lppa_OTDOA_Information_TypeIEs_1);

      stat = asn1PD_lppa_OTDOA_Information_Type_Item (pctxt, pvalue->value.
         u._lppa_OTDOA_Information_TypeIEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T11lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_OTDOA_Information_Type_element (
   lppa_OTDOA_Information_Type_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_OTDOA_Information_Type_element (OSCTXT *pctxt, 
   lppa_OTDOA_Information_Type_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T11lppa___lppa_OTDOA_Information_TypeIEs_1:
         if (0 != pvalue->value.u._lppa_OTDOA_Information_TypeIEs_1) {
            asn1Free_lppa_OTDOA_Information_Type_Item (pctxt, pvalue->value.u._lppa_OTDOA_Information_TypeIEs_1);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_OTDOA_Information_TypeIEs_1);
         }
         break;

      default:;
   }
}

lppa_OTDOA_Information_Type_element* asn1Get_lppa_OTDOA_Information_Type 
   (lppa_ProtocolIE_ID id, lppa_OTDOA_Information_Type* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_OTDOA_Information_Type_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_OTDOA_Information_Type_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_OTDOA_Information_Type (OSCTXT* pctxt, lppa_OTDOA_Information_Type* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOA-Information-Type");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(63), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_OTDOA_Information_Type_element (pctxt, ((lppa_OTDOA_Information_Type_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOA_Information_Type (OSCTXT* pctxt, lppa_OTDOA_Information_Type* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOA-Information-Type");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(63), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_OTDOA_Information_Type_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_OTDOA_Information_Type_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_OTDOA_Information_Type_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_OTDOA_Information_Type_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_OTDOA_Information_Type (lppa_OTDOA_Information_Type* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_OTDOA_Information_Type (OSCTXT *pctxt, 
   lppa_OTDOA_Information_Type* pvalue)
{
   if (0 == pvalue) return;
   { lppa_OTDOA_Information_Type_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_OTDOA_Information_Type_element*)pnode->data;
      asn1Free_lppa_OTDOA_Information_Type_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_OTDOAInformationRequest_protocolIEs_element (OSCTXT* pctxt, lppa_OTDOAInformationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_OTDOAInformationRequest_IEs_1 */
   case T10lppa___lppa_OTDOAInformationRequest_IEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_OTDOAInformationRequest_IEs_1");

      stat = asn1PE_lppa_OTDOA_Information_Type (pctxt, pvalue->value.u._lppa_OTDOAInformationRequest_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T10lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOAInformationRequest_protocolIEs_element (OSCTXT* pctxt, lppa_OTDOAInformationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_OTDOA_Information_Type_Group:
      pvalue->value.t = T10lppa___lppa_OTDOAInformationRequest_IEs_1;

      pvalue->value.u._lppa_OTDOAInformationRequest_IEs_1
          = rtxMemAllocType (pctxt, lppa_OTDOA_Information_Type);

      if (pvalue->value.u._lppa_OTDOAInformationRequest_IEs_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_OTDOA_Information_Type (pvalue->value.
         u._lppa_OTDOAInformationRequest_IEs_1);

      stat = asn1PD_lppa_OTDOA_Information_Type (pctxt, pvalue->value.
         u._lppa_OTDOAInformationRequest_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T10lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_OTDOAInformationRequest_protocolIEs_element (
   lppa_OTDOAInformationRequest_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_OTDOAInformationRequest_protocolIEs_element (OSCTXT *pctxt, 
   lppa_OTDOAInformationRequest_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T10lppa___lppa_OTDOAInformationRequest_IEs_1:
         if (0 != pvalue->value.u._lppa_OTDOAInformationRequest_IEs_1) {
            asn1Free_lppa_OTDOA_Information_Type (pctxt, pvalue->value.u._lppa_OTDOAInformationRequest_IEs_1);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_OTDOAInformationRequest_IEs_1);
         }
         break;

      default:;
   }
}

lppa_OTDOAInformationRequest_protocolIEs_element* 
   asn1Get_lppa_OTDOAInformationRequest_protocolIEs (lppa_ProtocolIE_ID id, 
   lppa_OTDOAInformationRequest_protocolIEs* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_OTDOAInformationRequest_protocolIEs_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_OTDOAInformationRequest_protocolIEs_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_OTDOAInformationRequest_protocolIEs (OSCTXT* pctxt, lppa_OTDOAInformationRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_OTDOAInformationRequest_protocolIEs_element (pctxt, ((lppa_OTDOAInformationRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOAInformationRequest_protocolIEs (OSCTXT* pctxt, lppa_OTDOAInformationRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_OTDOAInformationRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_OTDOAInformationRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_OTDOAInformationRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_OTDOAInformationRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_OTDOAInformationRequest_protocolIEs (
   lppa_OTDOAInformationRequest_protocolIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_OTDOAInformationRequest_protocolIEs (OSCTXT *pctxt, 
   lppa_OTDOAInformationRequest_protocolIEs* pvalue)
{
   if (0 == pvalue) return;
   { lppa_OTDOAInformationRequest_protocolIEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_OTDOAInformationRequest_protocolIEs_element*)pnode->data;
      asn1Free_lppa_OTDOAInformationRequest_protocolIEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_OTDOAInformationRequest (OSCTXT* pctxt, lppa_OTDOAInformationRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOAInformationRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_lppa_OTDOAInformationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOAInformationRequest (OSCTXT* pctxt, lppa_OTDOAInformationRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOAInformationRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_lppa_OTDOAInformationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_OTDOAInformationRequest (
   lppa_OTDOAInformationRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_OTDOAInformationRequest_protocolIEs (&pvalue->protocolIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_OTDOAInformationRequest (OSCTXT *pctxt, 
   lppa_OTDOAInformationRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_OTDOAInformationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_UTDOAInformationRequest_protocolIEs_element (OSCTXT* pctxt, lppa_UTDOAInformationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_UTDOAInformationRequest_IEs_1 */
   case T15lppa___lppa_UTDOAInformationRequest_IEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_UTDOAInformationRequest_IEs_1");

      stat = asn1PE_lppa_RequestedSRSTransmissionCharacteristics (pctxt, pvalue->value.u._lppa_UTDOAInformationRequest_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T15lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_UTDOAInformationRequest_protocolIEs_element (OSCTXT* pctxt, lppa_UTDOAInformationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_RequestedSRSTransmissionCharacteristics:
      pvalue->value.t = T15lppa___lppa_UTDOAInformationRequest_IEs_1;

      pvalue->value.u._lppa_UTDOAInformationRequest_IEs_1
          = rtxMemAllocType (pctxt, 
         lppa_RequestedSRSTransmissionCharacteristics);

      if (pvalue->value.u._lppa_UTDOAInformationRequest_IEs_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_RequestedSRSTransmissionCharacteristics (pvalue->value.
         u._lppa_UTDOAInformationRequest_IEs_1);

      stat = asn1PD_lppa_RequestedSRSTransmissionCharacteristics (pctxt, pvalue
         ->value.u._lppa_UTDOAInformationRequest_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T15lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_UTDOAInformationRequest_protocolIEs_element (
   lppa_UTDOAInformationRequest_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_UTDOAInformationRequest_protocolIEs_element (OSCTXT *pctxt, 
   lppa_UTDOAInformationRequest_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T15lppa___lppa_UTDOAInformationRequest_IEs_1:
         if (0 != pvalue->value.u._lppa_UTDOAInformationRequest_IEs_1) {
            asn1Free_lppa_RequestedSRSTransmissionCharacteristics (pctxt, pvalue->value.u._lppa_UTDOAInformationRequest_IEs_1);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_UTDOAInformationRequest_IEs_1);
         }
         break;

      default:;
   }
}

lppa_UTDOAInformationRequest_protocolIEs_element* 
   asn1Get_lppa_UTDOAInformationRequest_protocolIEs (lppa_ProtocolIE_ID id, 
   lppa_UTDOAInformationRequest_protocolIEs* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_UTDOAInformationRequest_protocolIEs_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_UTDOAInformationRequest_protocolIEs_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_UTDOAInformationRequest_protocolIEs (OSCTXT* pctxt, lppa_UTDOAInformationRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_UTDOAInformationRequest_protocolIEs_element (pctxt, ((lppa_UTDOAInformationRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_UTDOAInformationRequest_protocolIEs (OSCTXT* pctxt, lppa_UTDOAInformationRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_UTDOAInformationRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_UTDOAInformationRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_UTDOAInformationRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_UTDOAInformationRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_UTDOAInformationRequest_protocolIEs (
   lppa_UTDOAInformationRequest_protocolIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_UTDOAInformationRequest_protocolIEs (OSCTXT *pctxt, 
   lppa_UTDOAInformationRequest_protocolIEs* pvalue)
{
   if (0 == pvalue) return;
   { lppa_UTDOAInformationRequest_protocolIEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_UTDOAInformationRequest_protocolIEs_element*)pnode->data;
      asn1Free_lppa_UTDOAInformationRequest_protocolIEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_UTDOAInformationRequest (OSCTXT* pctxt, lppa_UTDOAInformationRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UTDOAInformationRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_lppa_UTDOAInformationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_UTDOAInformationRequest (OSCTXT* pctxt, lppa_UTDOAInformationRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UTDOAInformationRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_lppa_UTDOAInformationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_UTDOAInformationRequest (
   lppa_UTDOAInformationRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_UTDOAInformationRequest_protocolIEs (&pvalue->protocolIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_UTDOAInformationRequest (OSCTXT *pctxt, 
   lppa_UTDOAInformationRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_UTDOAInformationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

void asn1SetTC_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element_lppa_E_CIDMeasurementFailureIndication_IEs_1
   (OSCTXT* pctxt, lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pElem, lppa_Measurement_ID value)
{
   pElem->id = 2;
   pElem->criticality = lppa_reject;
   pElem->value.t = T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_1;
   pElem->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_1 = value;
}

void asn1SetTC_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element_lppa_E_CIDMeasurementFailureIndication_IEs_2
   (OSCTXT* pctxt, lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pElem, lppa_Measurement_ID value)
{
   pElem->id = 6;
   pElem->criticality = lppa_reject;
   pElem->value.t = T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_2;
   pElem->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_2 = value;
}

void asn1SetTC_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element_lppa_E_CIDMeasurementFailureIndication_IEs_3
   (OSCTXT* pctxt, lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pElem, struct lppa_Cause *pvalue)
{
   pElem->id = 0;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_3;
   pElem->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_3 = pvalue;
}

EXTERN int asn1PE_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element (OSCTXT* pctxt, lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_E_CIDMeasurementFailureIndication_IEs_1 */
   case T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementFailureIndication_IEs_1");

      stat = asn1PE_lppa_Measurement_ID (pctxt, pvalue->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementFailureIndication_IEs_2 */
   case T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_2:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementFailureIndication_IEs_2");

      stat = asn1PE_lppa_Measurement_ID (pctxt, pvalue->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementFailureIndication_IEs_3 */
   case T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_3:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementFailureIndication_IEs_3");

      stat = asn1PE_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T7lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element (OSCTXT* pctxt, lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_E_SMLC_UE_Measurement_ID:
      pvalue->value.t = T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_1;

      stat = asn1PD_lppa_Measurement_ID (pctxt, &pvalue->value.
         u._lppa_E_CIDMeasurementFailureIndication_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_eNB_UE_Measurement_ID:
      pvalue->value.t = T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_2;

      stat = asn1PD_lppa_Measurement_ID (pctxt, &pvalue->value.
         u._lppa_E_CIDMeasurementFailureIndication_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_Cause:
      pvalue->value.t = T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_3;

      pvalue->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_3
          = rtxMemAllocType (pctxt, lppa_Cause);

      if (pvalue->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_3
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_Cause ((lppa_Cause*)pvalue->value.
         u._lppa_E_CIDMeasurementFailureIndication_IEs_3);

      stat = asn1PD_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.
         u._lppa_E_CIDMeasurementFailureIndication_IEs_3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T7lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element (
   lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_3:
         if (0 != pvalue->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_3) {
            asn1Free_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_3);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_3);
         }
         break;

      default:;
   }
}

int asn1Append_lppa_E_CIDMeasurementFailureIndication_protocolIEs_1
      (OSCTXT* pctxt, lppa_E_CIDMeasurementFailureIndication_protocolIEs* plist
   , lppa_Measurement_ID value)
{
   lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementFailureIndication_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element_lppa_E_CIDMeasurementFailureIndication_IEs_1 (pctxt, pElem
      , value);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementFailureIndication_protocolIEs_2
      (OSCTXT* pctxt, lppa_E_CIDMeasurementFailureIndication_protocolIEs* plist
   , lppa_Measurement_ID value)
{
   lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementFailureIndication_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element_lppa_E_CIDMeasurementFailureIndication_IEs_2 (pctxt, pElem
      , value);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementFailureIndication_protocolIEs_3
      (OSCTXT* pctxt, lppa_E_CIDMeasurementFailureIndication_protocolIEs* plist
   , struct lppa_Cause *pvalue)
{
   lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementFailureIndication_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element_lppa_E_CIDMeasurementFailureIndication_IEs_3 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* 
   asn1Get_lppa_E_CIDMeasurementFailureIndication_protocolIEs 
   (lppa_ProtocolIE_ID id, 
   lppa_E_CIDMeasurementFailureIndication_protocolIEs* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_E_CIDMeasurementFailureIndication_protocolIEs_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_E_CIDMeasurementFailureIndication_protocolIEs (OSCTXT* pctxt, lppa_E_CIDMeasurementFailureIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element (pctxt, ((lppa_E_CIDMeasurementFailureIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementFailureIndication_protocolIEs (OSCTXT* pctxt, lppa_E_CIDMeasurementFailureIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_E_CIDMeasurementFailureIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementFailureIndication_protocolIEs (
   lppa_E_CIDMeasurementFailureIndication_protocolIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementFailureIndication_protocolIEs (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementFailureIndication_protocolIEs* pvalue)
{
   if (0 == pvalue) return;
   { lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_E_CIDMeasurementFailureIndication_protocolIEs_element*)pnode->data;
      asn1Free_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_E_CIDMeasurementFailureIndication (OSCTXT* pctxt, lppa_E_CIDMeasurementFailureIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-CIDMeasurementFailureIndication");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_lppa_E_CIDMeasurementFailureIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementFailureIndication (OSCTXT* pctxt, lppa_E_CIDMeasurementFailureIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-CIDMeasurementFailureIndication");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_lppa_E_CIDMeasurementFailureIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementFailureIndication (
   lppa_E_CIDMeasurementFailureIndication* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_E_CIDMeasurementFailureIndication_protocolIEs (&pvalue->protocolIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementFailureIndication (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementFailureIndication* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_E_CIDMeasurementFailureIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

void asn1SetTC_lppa_E_CIDMeasurementReport_protocolIEs_element_lppa_E_CIDMeasurementReport_IEs_1
   (OSCTXT* pctxt, lppa_E_CIDMeasurementReport_protocolIEs_element* pElem, lppa_Measurement_ID value)
{
   pElem->id = 2;
   pElem->criticality = lppa_reject;
   pElem->value.t = T8lppa___lppa_E_CIDMeasurementReport_IEs_1;
   pElem->value.u._lppa_E_CIDMeasurementReport_IEs_1 = value;
}

void asn1SetTC_lppa_E_CIDMeasurementReport_protocolIEs_element_lppa_E_CIDMeasurementReport_IEs_2
   (OSCTXT* pctxt, lppa_E_CIDMeasurementReport_protocolIEs_element* pElem, lppa_Measurement_ID value)
{
   pElem->id = 6;
   pElem->criticality = lppa_reject;
   pElem->value.t = T8lppa___lppa_E_CIDMeasurementReport_IEs_2;
   pElem->value.u._lppa_E_CIDMeasurementReport_IEs_2 = value;
}

void asn1SetTC_lppa_E_CIDMeasurementReport_protocolIEs_element_lppa_E_CIDMeasurementReport_IEs_3
   (OSCTXT* pctxt, lppa_E_CIDMeasurementReport_protocolIEs_element* pElem, struct lppa_E_CID_MeasurementResult *pvalue)
{
   pElem->id = 7;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T8lppa___lppa_E_CIDMeasurementReport_IEs_3;
   pElem->value.u._lppa_E_CIDMeasurementReport_IEs_3 = pvalue;
}

void asn1SetTC_lppa_E_CIDMeasurementReport_protocolIEs_element_lppa_E_CIDMeasurementReport_IEs_4
   (OSCTXT* pctxt, lppa_E_CIDMeasurementReport_protocolIEs_element* pElem, lppa_Cell_Portion_ID value)
{
   pElem->id = 14;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T8lppa___lppa_E_CIDMeasurementReport_IEs_4;
   pElem->value.u._lppa_E_CIDMeasurementReport_IEs_4 = value;
}

EXTERN int asn1PE_lppa_E_CIDMeasurementReport_protocolIEs_element (OSCTXT* pctxt, lppa_E_CIDMeasurementReport_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_E_CIDMeasurementReport_IEs_1 */
   case T8lppa___lppa_E_CIDMeasurementReport_IEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementReport_IEs_1");

      stat = asn1PE_lppa_Measurement_ID (pctxt, pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementReport_IEs_2 */
   case T8lppa___lppa_E_CIDMeasurementReport_IEs_2:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementReport_IEs_2");

      stat = asn1PE_lppa_Measurement_ID (pctxt, pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementReport_IEs_3 */
   case T8lppa___lppa_E_CIDMeasurementReport_IEs_3:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementReport_IEs_3");

      stat = asn1PE_lppa_E_CID_MeasurementResult (pctxt, (lppa_E_CID_MeasurementResult*)pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementReport_IEs_4 */
   case T8lppa___lppa_E_CIDMeasurementReport_IEs_4:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementReport_IEs_4");

      stat = asn1PE_lppa_Cell_Portion_ID (pctxt, pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_4);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T8lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementReport_protocolIEs_element (OSCTXT* pctxt, lppa_E_CIDMeasurementReport_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_E_SMLC_UE_Measurement_ID:
      pvalue->value.t = T8lppa___lppa_E_CIDMeasurementReport_IEs_1;

      stat = asn1PD_lppa_Measurement_ID (pctxt, &pvalue->value.
         u._lppa_E_CIDMeasurementReport_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_eNB_UE_Measurement_ID:
      pvalue->value.t = T8lppa___lppa_E_CIDMeasurementReport_IEs_2;

      stat = asn1PD_lppa_Measurement_ID (pctxt, &pvalue->value.
         u._lppa_E_CIDMeasurementReport_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_E_CID_MeasurementResult:
      pvalue->value.t = T8lppa___lppa_E_CIDMeasurementReport_IEs_3;

      pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_3
          = rtxMemAllocType (pctxt, lppa_E_CID_MeasurementResult);

      if (pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_3 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_E_CID_MeasurementResult ((lppa_E_CID_MeasurementResult*)
         pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_3);

      stat = asn1PD_lppa_E_CID_MeasurementResult (pctxt, 
         (lppa_E_CID_MeasurementResult*)pvalue->value.
         u._lppa_E_CIDMeasurementReport_IEs_3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_Cell_Portion_ID:
      pvalue->value.t = T8lppa___lppa_E_CIDMeasurementReport_IEs_4;

      stat = asn1PD_lppa_Cell_Portion_ID (pctxt, &pvalue->value.
         u._lppa_E_CIDMeasurementReport_IEs_4);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T8lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementReport_protocolIEs_element (
   lppa_E_CIDMeasurementReport_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementReport_protocolIEs_element (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementReport_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T8lppa___lppa_E_CIDMeasurementReport_IEs_3:
         if (0 != pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_3) {
            asn1Free_lppa_E_CID_MeasurementResult (pctxt, (lppa_E_CID_MeasurementResult*)pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_3);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_3);
         }
         break;

      default:;
   }
}

int asn1Append_lppa_E_CIDMeasurementReport_protocolIEs_1   (OSCTXT* pctxt, 
   lppa_E_CIDMeasurementReport_protocolIEs* plist, lppa_Measurement_ID value)
{
   lppa_E_CIDMeasurementReport_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementReport_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementReport_protocolIEs_element_lppa_E_CIDMeasurementReport_IEs_1 (pctxt, pElem
      , value);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementReport_protocolIEs_2   (OSCTXT* pctxt, 
   lppa_E_CIDMeasurementReport_protocolIEs* plist, lppa_Measurement_ID value)
{
   lppa_E_CIDMeasurementReport_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementReport_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementReport_protocolIEs_element_lppa_E_CIDMeasurementReport_IEs_2 (pctxt, pElem
      , value);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementReport_protocolIEs_3   (OSCTXT* pctxt, 
   lppa_E_CIDMeasurementReport_protocolIEs* plist, struct 
   lppa_E_CID_MeasurementResult *pvalue)
{
   lppa_E_CIDMeasurementReport_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementReport_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementReport_protocolIEs_element_lppa_E_CIDMeasurementReport_IEs_3 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementReport_protocolIEs_4   (OSCTXT* pctxt, 
   lppa_E_CIDMeasurementReport_protocolIEs* plist, lppa_Cell_Portion_ID value)
{
   lppa_E_CIDMeasurementReport_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementReport_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementReport_protocolIEs_element_lppa_E_CIDMeasurementReport_IEs_4 (pctxt, pElem
      , value);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

lppa_E_CIDMeasurementReport_protocolIEs_element* 
   asn1Get_lppa_E_CIDMeasurementReport_protocolIEs (lppa_ProtocolIE_ID id, 
   lppa_E_CIDMeasurementReport_protocolIEs* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_E_CIDMeasurementReport_protocolIEs_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_E_CIDMeasurementReport_protocolIEs_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_E_CIDMeasurementReport_protocolIEs (OSCTXT* pctxt, lppa_E_CIDMeasurementReport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_E_CIDMeasurementReport_protocolIEs_element (pctxt, ((lppa_E_CIDMeasurementReport_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementReport_protocolIEs (OSCTXT* pctxt, lppa_E_CIDMeasurementReport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_E_CIDMeasurementReport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_E_CIDMeasurementReport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_E_CIDMeasurementReport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_E_CIDMeasurementReport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementReport_protocolIEs (
   lppa_E_CIDMeasurementReport_protocolIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementReport_protocolIEs (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementReport_protocolIEs* pvalue)
{
   if (0 == pvalue) return;
   { lppa_E_CIDMeasurementReport_protocolIEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_E_CIDMeasurementReport_protocolIEs_element*)pnode->data;
      asn1Free_lppa_E_CIDMeasurementReport_protocolIEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_E_CIDMeasurementReport (OSCTXT* pctxt, lppa_E_CIDMeasurementReport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-CIDMeasurementReport");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_lppa_E_CIDMeasurementReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementReport (OSCTXT* pctxt, lppa_E_CIDMeasurementReport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-CIDMeasurementReport");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_lppa_E_CIDMeasurementReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementReport (lppa_E_CIDMeasurementReport* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_E_CIDMeasurementReport_protocolIEs (&pvalue->protocolIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementReport (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementReport* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_E_CIDMeasurementReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

void asn1SetTC_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element_lppa_E_CIDMeasurementTerminationCommand_IEs_1
   (OSCTXT* pctxt, lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pElem, lppa_Measurement_ID value)
{
   pElem->id = 2;
   pElem->criticality = lppa_reject;
   pElem->value.t = T9lppa___lppa_E_CIDMeasurementTerminationCommand_IEs_1;
   pElem->value.u._lppa_E_CIDMeasurementTerminationCommand_IEs_1 = value;
}

void asn1SetTC_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element_lppa_E_CIDMeasurementTerminationCommand_IEs_2
   (OSCTXT* pctxt, lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pElem, lppa_Measurement_ID value)
{
   pElem->id = 6;
   pElem->criticality = lppa_reject;
   pElem->value.t = T9lppa___lppa_E_CIDMeasurementTerminationCommand_IEs_2;
   pElem->value.u._lppa_E_CIDMeasurementTerminationCommand_IEs_2 = value;
}

EXTERN int asn1PE_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element (OSCTXT* pctxt, lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_E_CIDMeasurementTerminationCommand_IEs_1 */
   case T9lppa___lppa_E_CIDMeasurementTerminationCommand_IEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementTerminationCommand_IEs_1");

      stat = asn1PE_lppa_Measurement_ID (pctxt, pvalue->value.u._lppa_E_CIDMeasurementTerminationCommand_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementTerminationCommand_IEs_2 */
   case T9lppa___lppa_E_CIDMeasurementTerminationCommand_IEs_2:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementTerminationCommand_IEs_2");

      stat = asn1PE_lppa_Measurement_ID (pctxt, pvalue->value.u._lppa_E_CIDMeasurementTerminationCommand_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T9lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element (OSCTXT* pctxt, lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_E_SMLC_UE_Measurement_ID:
      pvalue->value.
         t = T9lppa___lppa_E_CIDMeasurementTerminationCommand_IEs_1;

      stat = asn1PD_lppa_Measurement_ID (pctxt, &pvalue->value.
         u._lppa_E_CIDMeasurementTerminationCommand_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_eNB_UE_Measurement_ID:
      pvalue->value.
         t = T9lppa___lppa_E_CIDMeasurementTerminationCommand_IEs_2;

      stat = asn1PD_lppa_Measurement_ID (pctxt, &pvalue->value.
         u._lppa_E_CIDMeasurementTerminationCommand_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T9lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element (
   lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

int asn1Append_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_1
      (OSCTXT* pctxt, 
   lppa_E_CIDMeasurementTerminationCommand_protocolIEs* plist, 
   lppa_Measurement_ID value)
{
   lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element_lppa_E_CIDMeasurementTerminationCommand_IEs_1 (pctxt, pElem
      , value);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_2
      (OSCTXT* pctxt, 
   lppa_E_CIDMeasurementTerminationCommand_protocolIEs* plist, 
   lppa_Measurement_ID value)
{
   lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element_lppa_E_CIDMeasurementTerminationCommand_IEs_2 (pctxt, pElem
      , value);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* 
   asn1Get_lppa_E_CIDMeasurementTerminationCommand_protocolIEs 
   (lppa_ProtocolIE_ID id, 
   lppa_E_CIDMeasurementTerminationCommand_protocolIEs* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_E_CIDMeasurementTerminationCommand_protocolIEs (OSCTXT* pctxt, lppa_E_CIDMeasurementTerminationCommand_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element (pctxt, ((lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementTerminationCommand_protocolIEs (OSCTXT* pctxt, lppa_E_CIDMeasurementTerminationCommand_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementTerminationCommand_protocolIEs (
   lppa_E_CIDMeasurementTerminationCommand_protocolIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementTerminationCommand_protocolIEs (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementTerminationCommand_protocolIEs* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

EXTERN int asn1PE_lppa_E_CIDMeasurementTerminationCommand (OSCTXT* pctxt, lppa_E_CIDMeasurementTerminationCommand* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-CIDMeasurementTerminationCommand");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_lppa_E_CIDMeasurementTerminationCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementTerminationCommand (OSCTXT* pctxt, lppa_E_CIDMeasurementTerminationCommand* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-CIDMeasurementTerminationCommand");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_lppa_E_CIDMeasurementTerminationCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementTerminationCommand (
   lppa_E_CIDMeasurementTerminationCommand* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_E_CIDMeasurementTerminationCommand_protocolIEs (&pvalue->protocolIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementTerminationCommand (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementTerminationCommand* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_E_CIDMeasurementTerminationCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

void asn1SetTC_lppa_ErrorIndication_protocolIEs_element_lppa_ErrorIndication_IEs_1
   (OSCTXT* pctxt, lppa_ErrorIndication_protocolIEs_element* pElem, struct lppa_Cause *pvalue)
{
   pElem->id = 0;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T19lppa___lppa_ErrorIndication_IEs_1;
   pElem->value.u._lppa_ErrorIndication_IEs_1 = pvalue;
}

void asn1SetTC_lppa_ErrorIndication_protocolIEs_element_lppa_ErrorIndication_IEs_2
   (OSCTXT* pctxt, lppa_ErrorIndication_protocolIEs_element* pElem, struct lppa_CriticalityDiagnostics *pvalue)
{
   pElem->id = 1;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T19lppa___lppa_ErrorIndication_IEs_2;
   pElem->value.u._lppa_ErrorIndication_IEs_2 = pvalue;
}

EXTERN int asn1PE_lppa_ErrorIndication_protocolIEs_element (OSCTXT* pctxt, lppa_ErrorIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_ErrorIndication_IEs_1 */
   case T19lppa___lppa_ErrorIndication_IEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_ErrorIndication_IEs_1");

      stat = asn1PE_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.u._lppa_ErrorIndication_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_ErrorIndication_IEs_2 */
   case T19lppa___lppa_ErrorIndication_IEs_2:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_ErrorIndication_IEs_2");

      stat = asn1PE_lppa_CriticalityDiagnostics (pctxt, (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_ErrorIndication_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T19lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ErrorIndication_protocolIEs_element (OSCTXT* pctxt, lppa_ErrorIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_Cause:
      pvalue->value.t = T19lppa___lppa_ErrorIndication_IEs_1;

      pvalue->value.u._lppa_ErrorIndication_IEs_1 = rtxMemAllocType (pctxt, 
         lppa_Cause);

      if (pvalue->value.u._lppa_ErrorIndication_IEs_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_Cause ((lppa_Cause*)pvalue->value.
         u._lppa_ErrorIndication_IEs_1);

      stat = asn1PD_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.
         u._lppa_ErrorIndication_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_CriticalityDiagnostics:
      pvalue->value.t = T19lppa___lppa_ErrorIndication_IEs_2;

      pvalue->value.u._lppa_ErrorIndication_IEs_2 = rtxMemAllocType (pctxt, 
         lppa_CriticalityDiagnostics);

      if (pvalue->value.u._lppa_ErrorIndication_IEs_2 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_CriticalityDiagnostics ((lppa_CriticalityDiagnostics*)
         pvalue->value.u._lppa_ErrorIndication_IEs_2);

      stat = asn1PD_lppa_CriticalityDiagnostics (pctxt, 
         (lppa_CriticalityDiagnostics*)pvalue->value.
         u._lppa_ErrorIndication_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T19lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ErrorIndication_protocolIEs_element (
   lppa_ErrorIndication_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_ErrorIndication_protocolIEs_element (OSCTXT *pctxt, 
   lppa_ErrorIndication_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T19lppa___lppa_ErrorIndication_IEs_1:
         if (0 != pvalue->value.u._lppa_ErrorIndication_IEs_1) {
            asn1Free_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.u._lppa_ErrorIndication_IEs_1);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_ErrorIndication_IEs_1);
         }
         break;

      case T19lppa___lppa_ErrorIndication_IEs_2:
         if (0 != pvalue->value.u._lppa_ErrorIndication_IEs_2) {
            asn1Free_lppa_CriticalityDiagnostics (pctxt, (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_ErrorIndication_IEs_2);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_ErrorIndication_IEs_2);
         }
         break;

      default:;
   }
}

int asn1Append_lppa_ErrorIndication_protocolIEs_1   (OSCTXT* pctxt, 
   lppa_ErrorIndication_protocolIEs* plist, struct lppa_Cause *pvalue)
{
   lppa_ErrorIndication_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_ErrorIndication_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_ErrorIndication_protocolIEs_element_lppa_ErrorIndication_IEs_1 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_ErrorIndication_protocolIEs_2   (OSCTXT* pctxt, 
   lppa_ErrorIndication_protocolIEs* plist, struct lppa_CriticalityDiagnostics 
   *pvalue)
{
   lppa_ErrorIndication_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_ErrorIndication_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_ErrorIndication_protocolIEs_element_lppa_ErrorIndication_IEs_2 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

lppa_ErrorIndication_protocolIEs_element* 
   asn1Get_lppa_ErrorIndication_protocolIEs (lppa_ProtocolIE_ID id, 
   lppa_ErrorIndication_protocolIEs* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_ErrorIndication_protocolIEs_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_ErrorIndication_protocolIEs_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_ErrorIndication_protocolIEs (OSCTXT* pctxt, lppa_ErrorIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_ErrorIndication_protocolIEs_element (pctxt, ((lppa_ErrorIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_ErrorIndication_protocolIEs (OSCTXT* pctxt, lppa_ErrorIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_ErrorIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_ErrorIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_ErrorIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_ErrorIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_ErrorIndication_protocolIEs (
   lppa_ErrorIndication_protocolIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_ErrorIndication_protocolIEs (OSCTXT *pctxt, 
   lppa_ErrorIndication_protocolIEs* pvalue)
{
   if (0 == pvalue) return;
   { lppa_ErrorIndication_protocolIEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_ErrorIndication_protocolIEs_element*)pnode->data;
      asn1Free_lppa_ErrorIndication_protocolIEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_ErrorIndication (OSCTXT* pctxt, lppa_ErrorIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ErrorIndication");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_lppa_ErrorIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_ErrorIndication (OSCTXT* pctxt, lppa_ErrorIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ErrorIndication");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_lppa_ErrorIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_ErrorIndication (lppa_ErrorIndication* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_ErrorIndication_protocolIEs (&pvalue->protocolIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_ErrorIndication (OSCTXT *pctxt, 
   lppa_ErrorIndication* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_ErrorIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_PrivateMessage_privateIEs_element (OSCTXT* pctxt, lppa_PrivateMessage_privateIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_PrivateIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pe_OpenType (pctxt, pvalue->value.numocts, pvalue->value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_PrivateMessage_privateIEs_element (OSCTXT* pctxt, lppa_PrivateMessage_privateIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_PrivateIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_PrivateMessage_privateIEs_element (
   lppa_PrivateMessage_privateIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_PrivateIE_ID (&pvalue->id);
   pvalue->value.numocts = 0;
   pvalue->value.data = 0;
   return 0;
}

void asn1Free_lppa_PrivateMessage_privateIEs_element (OSCTXT *pctxt, 
   lppa_PrivateMessage_privateIEs_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_PrivateIE_ID (pctxt, &pvalue->id);
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->value.data);
   }
}

EXTERN int asn1PE_lppa_PrivateMessage_privateIEs (OSCTXT* pctxt, lppa_PrivateMessage_privateIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_PrivateMessage_privateIEs_element (pctxt, ((lppa_PrivateMessage_privateIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_PrivateMessage_privateIEs (OSCTXT* pctxt, lppa_PrivateMessage_privateIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_PrivateMessage_privateIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_PrivateMessage_privateIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_PrivateMessage_privateIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_PrivateMessage_privateIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_PrivateMessage_privateIEs (
   lppa_PrivateMessage_privateIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_PrivateMessage_privateIEs (OSCTXT *pctxt, 
   lppa_PrivateMessage_privateIEs* pvalue)
{
   if (0 == pvalue) return;
   { lppa_PrivateMessage_privateIEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_PrivateMessage_privateIEs_element*)pnode->data;
      asn1Free_lppa_PrivateMessage_privateIEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_PrivateMessage (OSCTXT* pctxt, lppa_PrivateMessage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateMessage");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode privateIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "privateIEs");

   stat = asn1PE_lppa_PrivateMessage_privateIEs (pctxt, &pvalue->privateIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_PrivateMessage (OSCTXT* pctxt, lppa_PrivateMessage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateMessage");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode privateIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "privateIEs");

   stat = asn1PD_lppa_PrivateMessage_privateIEs (pctxt, &pvalue->privateIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_PrivateMessage (lppa_PrivateMessage* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_PrivateMessage_privateIEs (&pvalue->privateIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_PrivateMessage (OSCTXT *pctxt, lppa_PrivateMessage* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_PrivateMessage_privateIEs (pctxt, &pvalue->privateIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_lppa_UTDOAInformationUpdate_protocolIEs_element (OSCTXT* pctxt, lppa_UTDOAInformationUpdate_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_UTDOAInformationUpdate_IEs_1 */
   case T18lppa___lppa_UTDOAInformationUpdate_IEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_UTDOAInformationUpdate_IEs_1");

      stat = asn1PE_lppa_ULConfiguration (pctxt, pvalue->value.u._lppa_UTDOAInformationUpdate_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T18lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_UTDOAInformationUpdate_protocolIEs_element (OSCTXT* pctxt, lppa_UTDOAInformationUpdate_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_ULConfiguration:
      pvalue->value.t = T18lppa___lppa_UTDOAInformationUpdate_IEs_1;

      pvalue->value.u._lppa_UTDOAInformationUpdate_IEs_1
          = rtxMemAllocType (pctxt, lppa_ULConfiguration);

      if (pvalue->value.u._lppa_UTDOAInformationUpdate_IEs_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_ULConfiguration (pvalue->value.
         u._lppa_UTDOAInformationUpdate_IEs_1);

      stat = asn1PD_lppa_ULConfiguration (pctxt, pvalue->value.
         u._lppa_UTDOAInformationUpdate_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T18lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_UTDOAInformationUpdate_protocolIEs_element (
   lppa_UTDOAInformationUpdate_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_UTDOAInformationUpdate_protocolIEs_element (OSCTXT *pctxt, 
   lppa_UTDOAInformationUpdate_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T18lppa___lppa_UTDOAInformationUpdate_IEs_1:
         if (0 != pvalue->value.u._lppa_UTDOAInformationUpdate_IEs_1) {
            asn1Free_lppa_ULConfiguration (pctxt, pvalue->value.u._lppa_UTDOAInformationUpdate_IEs_1);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_UTDOAInformationUpdate_IEs_1);
         }
         break;

      default:;
   }
}

lppa_UTDOAInformationUpdate_protocolIEs_element* 
   asn1Get_lppa_UTDOAInformationUpdate_protocolIEs (lppa_ProtocolIE_ID id, 
   lppa_UTDOAInformationUpdate_protocolIEs* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_UTDOAInformationUpdate_protocolIEs_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_UTDOAInformationUpdate_protocolIEs_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_UTDOAInformationUpdate_protocolIEs (OSCTXT* pctxt, lppa_UTDOAInformationUpdate_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_UTDOAInformationUpdate_protocolIEs_element (pctxt, ((lppa_UTDOAInformationUpdate_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_UTDOAInformationUpdate_protocolIEs (OSCTXT* pctxt, lppa_UTDOAInformationUpdate_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_UTDOAInformationUpdate_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_UTDOAInformationUpdate_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_UTDOAInformationUpdate_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_UTDOAInformationUpdate_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_UTDOAInformationUpdate_protocolIEs (
   lppa_UTDOAInformationUpdate_protocolIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_UTDOAInformationUpdate_protocolIEs (OSCTXT *pctxt, 
   lppa_UTDOAInformationUpdate_protocolIEs* pvalue)
{
   if (0 == pvalue) return;
   { lppa_UTDOAInformationUpdate_protocolIEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_UTDOAInformationUpdate_protocolIEs_element*)pnode->data;
      asn1Free_lppa_UTDOAInformationUpdate_protocolIEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_UTDOAInformationUpdate (OSCTXT* pctxt, lppa_UTDOAInformationUpdate* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UTDOAInformationUpdate");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_lppa_UTDOAInformationUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_UTDOAInformationUpdate (OSCTXT* pctxt, lppa_UTDOAInformationUpdate* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UTDOAInformationUpdate");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_lppa_UTDOAInformationUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_UTDOAInformationUpdate (lppa_UTDOAInformationUpdate* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_UTDOAInformationUpdate_protocolIEs (&pvalue->protocolIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_UTDOAInformationUpdate (OSCTXT *pctxt, 
   lppa_UTDOAInformationUpdate* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_UTDOAInformationUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

void asn1SetTC_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element_lppa_E_CIDMeasurementInitiationResponse_IEs_1
   (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pElem, lppa_Measurement_ID value)
{
   pElem->id = 2;
   pElem->criticality = lppa_reject;
   pElem->value.t = T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_1;
   pElem->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_1 = value;
}

void asn1SetTC_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element_lppa_E_CIDMeasurementInitiationResponse_IEs_2
   (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pElem, lppa_Measurement_ID value)
{
   pElem->id = 6;
   pElem->criticality = lppa_reject;
   pElem->value.t = T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_2;
   pElem->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_2 = value;
}

void asn1SetTC_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element_lppa_E_CIDMeasurementInitiationResponse_IEs_3
   (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pElem, struct lppa_E_CID_MeasurementResult *pvalue)
{
   pElem->id = 7;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_3;
   pElem->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_3 = pvalue;
}

void asn1SetTC_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element_lppa_E_CIDMeasurementInitiationResponse_IEs_4
   (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pElem, struct lppa_CriticalityDiagnostics *pvalue)
{
   pElem->id = 1;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_4;
   pElem->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_4 = pvalue;
}

void asn1SetTC_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element_lppa_E_CIDMeasurementInitiationResponse_IEs_5
   (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pElem, lppa_Cell_Portion_ID value)
{
   pElem->id = 14;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_5;
   pElem->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_5 = value;
}

void asn1SetTC_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element_lppa_E_CIDMeasurementInitiationResponse_IEs_6
   (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pElem, lppa_InterRATMeasurementResult *pvalue)
{
   pElem->id = 17;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_6;
   pElem->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_6 = pvalue;
}

EXTERN int asn1PE_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_E_CIDMeasurementInitiationResponse_IEs_1 */
   case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementInitiationResponse_IEs_1");

      stat = asn1PE_lppa_Measurement_ID (pctxt, pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementInitiationResponse_IEs_2 */
   case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_2:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementInitiationResponse_IEs_2");

      stat = asn1PE_lppa_Measurement_ID (pctxt, pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementInitiationResponse_IEs_3 */
   case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_3:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementInitiationResponse_IEs_3");

      stat = asn1PE_lppa_E_CID_MeasurementResult (pctxt, (lppa_E_CID_MeasurementResult*)pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementInitiationResponse_IEs_4 */
   case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_4:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementInitiationResponse_IEs_4");

      stat = asn1PE_lppa_CriticalityDiagnostics (pctxt, (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_4);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementInitiationResponse_IEs_5 */
   case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_5:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementInitiationResponse_IEs_5");

      stat = asn1PE_lppa_Cell_Portion_ID (pctxt, pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementInitiationResponse_IEs_6 */
   case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_6:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementInitiationResponse_IEs_6");

      stat = asn1PE_lppa_InterRATMeasurementResult (pctxt, pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_6);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T5lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_E_SMLC_UE_Measurement_ID:
      pvalue->value.
         t = T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_1;

      stat = asn1PD_lppa_Measurement_ID (pctxt, &pvalue->value.
         u._lppa_E_CIDMeasurementInitiationResponse_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_eNB_UE_Measurement_ID:
      pvalue->value.
         t = T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_2;

      stat = asn1PD_lppa_Measurement_ID (pctxt, &pvalue->value.
         u._lppa_E_CIDMeasurementInitiationResponse_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_E_CID_MeasurementResult:
      pvalue->value.
         t = T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_3;

      pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_3
          = rtxMemAllocType (pctxt, lppa_E_CID_MeasurementResult);

      if (pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_3
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_E_CID_MeasurementResult ((lppa_E_CID_MeasurementResult*)
         pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_3);

      stat = asn1PD_lppa_E_CID_MeasurementResult (pctxt, 
         (lppa_E_CID_MeasurementResult*)pvalue->value.
         u._lppa_E_CIDMeasurementInitiationResponse_IEs_3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_CriticalityDiagnostics:
      pvalue->value.
         t = T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_4;

      pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_4
          = rtxMemAllocType (pctxt, lppa_CriticalityDiagnostics);

      if (pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_4
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_CriticalityDiagnostics ((lppa_CriticalityDiagnostics*)
         pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_4);

      stat = asn1PD_lppa_CriticalityDiagnostics (pctxt, 
         (lppa_CriticalityDiagnostics*)pvalue->value.
         u._lppa_E_CIDMeasurementInitiationResponse_IEs_4);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_Cell_Portion_ID:
      pvalue->value.
         t = T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_5;

      stat = asn1PD_lppa_Cell_Portion_ID (pctxt, &pvalue->value.
         u._lppa_E_CIDMeasurementInitiationResponse_IEs_5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_InterRATMeasurementResult:
      pvalue->value.
         t = T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_6;

      pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_6
          = rtxMemAllocType (pctxt, lppa_InterRATMeasurementResult);

      if (pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_6
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_InterRATMeasurementResult (pvalue->value.
         u._lppa_E_CIDMeasurementInitiationResponse_IEs_6);

      stat = asn1PD_lppa_InterRATMeasurementResult (pctxt, pvalue->value.
         u._lppa_E_CIDMeasurementInitiationResponse_IEs_6);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T5lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element (
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_3:
         if (0 != pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_3) {
            asn1Free_lppa_E_CID_MeasurementResult (pctxt, (lppa_E_CID_MeasurementResult*)pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_3);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_3);
         }
         break;

      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_4:
         if (0 != pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_4) {
            asn1Free_lppa_CriticalityDiagnostics (pctxt, (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_4);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_4);
         }
         break;

      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_6:
         if (0 != pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_6) {
            asn1Free_lppa_InterRATMeasurementResult (pctxt, pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_6);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_6);
         }
         break;

      default:;
   }
}

int asn1Append_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_1
      (OSCTXT* pctxt, 
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs* plist, 
   lppa_Measurement_ID value)
{
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element_lppa_E_CIDMeasurementInitiationResponse_IEs_1 (pctxt, pElem
      , value);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_2
      (OSCTXT* pctxt, 
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs* plist, 
   lppa_Measurement_ID value)
{
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element_lppa_E_CIDMeasurementInitiationResponse_IEs_2 (pctxt, pElem
      , value);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_3
      (OSCTXT* pctxt, 
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs* plist, struct 
   lppa_E_CID_MeasurementResult *pvalue)
{
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element_lppa_E_CIDMeasurementInitiationResponse_IEs_3 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_4
      (OSCTXT* pctxt, 
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs* plist, struct 
   lppa_CriticalityDiagnostics *pvalue)
{
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element_lppa_E_CIDMeasurementInitiationResponse_IEs_4 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_5
      (OSCTXT* pctxt, 
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs* plist, 
   lppa_Cell_Portion_ID value)
{
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element_lppa_E_CIDMeasurementInitiationResponse_IEs_5 (pctxt, pElem
      , value);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_6
      (OSCTXT* pctxt, 
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs* plist, 
   lppa_InterRATMeasurementResult *pvalue)
{
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element_lppa_E_CIDMeasurementInitiationResponse_IEs_6 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* 
   asn1Get_lppa_E_CIDMeasurementInitiationResponse_protocolIEs 
   (lppa_ProtocolIE_ID id, 
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_E_CIDMeasurementInitiationResponse_protocolIEs (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element (pctxt, ((lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementInitiationResponse_protocolIEs (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementInitiationResponse_protocolIEs (
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementInitiationResponse_protocolIEs (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs* pvalue)
{
   if (0 == pvalue) return;
   { lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element*)pnode->data;
      asn1Free_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_E_CIDMeasurementInitiationResponse (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-CIDMeasurementInitiationResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_lppa_E_CIDMeasurementInitiationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementInitiationResponse (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-CIDMeasurementInitiationResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_lppa_E_CIDMeasurementInitiationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementInitiationResponse (
   lppa_E_CIDMeasurementInitiationResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_E_CIDMeasurementInitiationResponse_protocolIEs (&pvalue->protocolIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementInitiationResponse (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementInitiationResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_E_CIDMeasurementInitiationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

void asn1SetTC_lppa_OTDOAInformationResponse_protocolIEs_element_lppa_OTDOAInformationResponse_IEs_1
   (OSCTXT* pctxt, lppa_OTDOAInformationResponse_protocolIEs_element* pElem, lppa_OTDOACells *pvalue)
{
   pElem->id = 8;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T13lppa___lppa_OTDOAInformationResponse_IEs_1;
   pElem->value.u._lppa_OTDOAInformationResponse_IEs_1 = pvalue;
}

void asn1SetTC_lppa_OTDOAInformationResponse_protocolIEs_element_lppa_OTDOAInformationResponse_IEs_2
   (OSCTXT* pctxt, lppa_OTDOAInformationResponse_protocolIEs_element* pElem, struct lppa_CriticalityDiagnostics *pvalue)
{
   pElem->id = 1;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T13lppa___lppa_OTDOAInformationResponse_IEs_2;
   pElem->value.u._lppa_OTDOAInformationResponse_IEs_2 = pvalue;
}

EXTERN int asn1PE_lppa_OTDOAInformationResponse_protocolIEs_element (OSCTXT* pctxt, lppa_OTDOAInformationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_OTDOAInformationResponse_IEs_1 */
   case T13lppa___lppa_OTDOAInformationResponse_IEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_OTDOAInformationResponse_IEs_1");

      stat = asn1PE_lppa_OTDOACells (pctxt, pvalue->value.u._lppa_OTDOAInformationResponse_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_OTDOAInformationResponse_IEs_2 */
   case T13lppa___lppa_OTDOAInformationResponse_IEs_2:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_OTDOAInformationResponse_IEs_2");

      stat = asn1PE_lppa_CriticalityDiagnostics (pctxt, (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_OTDOAInformationResponse_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T13lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOAInformationResponse_protocolIEs_element (OSCTXT* pctxt, lppa_OTDOAInformationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_OTDOACells:
      pvalue->value.t = T13lppa___lppa_OTDOAInformationResponse_IEs_1;

      pvalue->value.u._lppa_OTDOAInformationResponse_IEs_1
          = rtxMemAllocType (pctxt, lppa_OTDOACells);

      if (pvalue->value.u._lppa_OTDOAInformationResponse_IEs_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_OTDOACells (pvalue->value.
         u._lppa_OTDOAInformationResponse_IEs_1);

      stat = asn1PD_lppa_OTDOACells (pctxt, pvalue->value.
         u._lppa_OTDOAInformationResponse_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_CriticalityDiagnostics:
      pvalue->value.t = T13lppa___lppa_OTDOAInformationResponse_IEs_2;

      pvalue->value.u._lppa_OTDOAInformationResponse_IEs_2
          = rtxMemAllocType (pctxt, lppa_CriticalityDiagnostics);

      if (pvalue->value.u._lppa_OTDOAInformationResponse_IEs_2 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_CriticalityDiagnostics ((lppa_CriticalityDiagnostics*)
         pvalue->value.u._lppa_OTDOAInformationResponse_IEs_2);

      stat = asn1PD_lppa_CriticalityDiagnostics (pctxt, 
         (lppa_CriticalityDiagnostics*)pvalue->value.
         u._lppa_OTDOAInformationResponse_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T13lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_OTDOAInformationResponse_protocolIEs_element (
   lppa_OTDOAInformationResponse_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_OTDOAInformationResponse_protocolIEs_element (OSCTXT *pctxt, 
   lppa_OTDOAInformationResponse_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T13lppa___lppa_OTDOAInformationResponse_IEs_1:
         if (0 != pvalue->value.u._lppa_OTDOAInformationResponse_IEs_1) {
            asn1Free_lppa_OTDOACells (pctxt, pvalue->value.u._lppa_OTDOAInformationResponse_IEs_1);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_OTDOAInformationResponse_IEs_1);
         }
         break;

      case T13lppa___lppa_OTDOAInformationResponse_IEs_2:
         if (0 != pvalue->value.u._lppa_OTDOAInformationResponse_IEs_2) {
            asn1Free_lppa_CriticalityDiagnostics (pctxt, (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_OTDOAInformationResponse_IEs_2);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_OTDOAInformationResponse_IEs_2);
         }
         break;

      default:;
   }
}

int asn1Append_lppa_OTDOAInformationResponse_protocolIEs_1   (OSCTXT* pctxt, 
   lppa_OTDOAInformationResponse_protocolIEs* plist, lppa_OTDOACells *pvalue)
{
   lppa_OTDOAInformationResponse_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_OTDOAInformationResponse_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_OTDOAInformationResponse_protocolIEs_element_lppa_OTDOAInformationResponse_IEs_1 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_OTDOAInformationResponse_protocolIEs_2   (OSCTXT* pctxt, 
   lppa_OTDOAInformationResponse_protocolIEs* plist, struct 
   lppa_CriticalityDiagnostics *pvalue)
{
   lppa_OTDOAInformationResponse_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_OTDOAInformationResponse_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_OTDOAInformationResponse_protocolIEs_element_lppa_OTDOAInformationResponse_IEs_2 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

lppa_OTDOAInformationResponse_protocolIEs_element* 
   asn1Get_lppa_OTDOAInformationResponse_protocolIEs (lppa_ProtocolIE_ID id, 
   lppa_OTDOAInformationResponse_protocolIEs* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_OTDOAInformationResponse_protocolIEs_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_OTDOAInformationResponse_protocolIEs_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_OTDOAInformationResponse_protocolIEs (OSCTXT* pctxt, lppa_OTDOAInformationResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_OTDOAInformationResponse_protocolIEs_element (pctxt, ((lppa_OTDOAInformationResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOAInformationResponse_protocolIEs (OSCTXT* pctxt, lppa_OTDOAInformationResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_OTDOAInformationResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_OTDOAInformationResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_OTDOAInformationResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_OTDOAInformationResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_OTDOAInformationResponse_protocolIEs (
   lppa_OTDOAInformationResponse_protocolIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_OTDOAInformationResponse_protocolIEs (OSCTXT *pctxt, 
   lppa_OTDOAInformationResponse_protocolIEs* pvalue)
{
   if (0 == pvalue) return;
   { lppa_OTDOAInformationResponse_protocolIEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_OTDOAInformationResponse_protocolIEs_element*)pnode->data;
      asn1Free_lppa_OTDOAInformationResponse_protocolIEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_OTDOAInformationResponse (OSCTXT* pctxt, lppa_OTDOAInformationResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOAInformationResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_lppa_OTDOAInformationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOAInformationResponse (OSCTXT* pctxt, lppa_OTDOAInformationResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOAInformationResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_lppa_OTDOAInformationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_OTDOAInformationResponse (
   lppa_OTDOAInformationResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_OTDOAInformationResponse_protocolIEs (&pvalue->protocolIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_OTDOAInformationResponse (OSCTXT *pctxt, 
   lppa_OTDOAInformationResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_OTDOAInformationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

void asn1SetTC_lppa_UTDOAInformationResponse_protocolIEs_element_lppa_UTDOAInformationResponse_IEs_1
   (OSCTXT* pctxt, lppa_UTDOAInformationResponse_protocolIEs_element* pElem, struct lppa_ULConfiguration *pvalue)
{
   pElem->id = 13;
   pElem->criticality = lppa_reject;
   pElem->value.t = T16lppa___lppa_UTDOAInformationResponse_IEs_1;
   pElem->value.u._lppa_UTDOAInformationResponse_IEs_1 = pvalue;
}

void asn1SetTC_lppa_UTDOAInformationResponse_protocolIEs_element_lppa_UTDOAInformationResponse_IEs_2
   (OSCTXT* pctxt, lppa_UTDOAInformationResponse_protocolIEs_element* pElem, struct lppa_CriticalityDiagnostics *pvalue)
{
   pElem->id = 1;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T16lppa___lppa_UTDOAInformationResponse_IEs_2;
   pElem->value.u._lppa_UTDOAInformationResponse_IEs_2 = pvalue;
}

EXTERN int asn1PE_lppa_UTDOAInformationResponse_protocolIEs_element (OSCTXT* pctxt, lppa_UTDOAInformationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_UTDOAInformationResponse_IEs_1 */
   case T16lppa___lppa_UTDOAInformationResponse_IEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_UTDOAInformationResponse_IEs_1");

      stat = asn1PE_lppa_ULConfiguration (pctxt, (lppa_ULConfiguration*)pvalue->value.u._lppa_UTDOAInformationResponse_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_UTDOAInformationResponse_IEs_2 */
   case T16lppa___lppa_UTDOAInformationResponse_IEs_2:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_UTDOAInformationResponse_IEs_2");

      stat = asn1PE_lppa_CriticalityDiagnostics (pctxt, (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_UTDOAInformationResponse_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T16lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_UTDOAInformationResponse_protocolIEs_element (OSCTXT* pctxt, lppa_UTDOAInformationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_ULConfiguration:
      pvalue->value.t = T16lppa___lppa_UTDOAInformationResponse_IEs_1;

      pvalue->value.u._lppa_UTDOAInformationResponse_IEs_1
          = rtxMemAllocType (pctxt, lppa_ULConfiguration);

      if (pvalue->value.u._lppa_UTDOAInformationResponse_IEs_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_ULConfiguration ((lppa_ULConfiguration*)pvalue->value.
         u._lppa_UTDOAInformationResponse_IEs_1);

      stat = asn1PD_lppa_ULConfiguration (pctxt, (lppa_ULConfiguration*)pvalue
         ->value.u._lppa_UTDOAInformationResponse_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_CriticalityDiagnostics:
      pvalue->value.t = T16lppa___lppa_UTDOAInformationResponse_IEs_2;

      pvalue->value.u._lppa_UTDOAInformationResponse_IEs_2
          = rtxMemAllocType (pctxt, lppa_CriticalityDiagnostics);

      if (pvalue->value.u._lppa_UTDOAInformationResponse_IEs_2 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_CriticalityDiagnostics ((lppa_CriticalityDiagnostics*)
         pvalue->value.u._lppa_UTDOAInformationResponse_IEs_2);

      stat = asn1PD_lppa_CriticalityDiagnostics (pctxt, 
         (lppa_CriticalityDiagnostics*)pvalue->value.
         u._lppa_UTDOAInformationResponse_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T16lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_UTDOAInformationResponse_protocolIEs_element (
   lppa_UTDOAInformationResponse_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_UTDOAInformationResponse_protocolIEs_element (OSCTXT *pctxt, 
   lppa_UTDOAInformationResponse_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T16lppa___lppa_UTDOAInformationResponse_IEs_1:
         if (0 != pvalue->value.u._lppa_UTDOAInformationResponse_IEs_1) {
            asn1Free_lppa_ULConfiguration (pctxt, (lppa_ULConfiguration*)pvalue->value.u._lppa_UTDOAInformationResponse_IEs_1);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_UTDOAInformationResponse_IEs_1);
         }
         break;

      case T16lppa___lppa_UTDOAInformationResponse_IEs_2:
         if (0 != pvalue->value.u._lppa_UTDOAInformationResponse_IEs_2) {
            asn1Free_lppa_CriticalityDiagnostics (pctxt, (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_UTDOAInformationResponse_IEs_2);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_UTDOAInformationResponse_IEs_2);
         }
         break;

      default:;
   }
}

int asn1Append_lppa_UTDOAInformationResponse_protocolIEs_1   (OSCTXT* pctxt, 
   lppa_UTDOAInformationResponse_protocolIEs* plist, struct 
   lppa_ULConfiguration *pvalue)
{
   lppa_UTDOAInformationResponse_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_UTDOAInformationResponse_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_UTDOAInformationResponse_protocolIEs_element_lppa_UTDOAInformationResponse_IEs_1 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_UTDOAInformationResponse_protocolIEs_2   (OSCTXT* pctxt, 
   lppa_UTDOAInformationResponse_protocolIEs* plist, struct 
   lppa_CriticalityDiagnostics *pvalue)
{
   lppa_UTDOAInformationResponse_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_UTDOAInformationResponse_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_UTDOAInformationResponse_protocolIEs_element_lppa_UTDOAInformationResponse_IEs_2 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

lppa_UTDOAInformationResponse_protocolIEs_element* 
   asn1Get_lppa_UTDOAInformationResponse_protocolIEs (lppa_ProtocolIE_ID id, 
   lppa_UTDOAInformationResponse_protocolIEs* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_UTDOAInformationResponse_protocolIEs_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_UTDOAInformationResponse_protocolIEs_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_UTDOAInformationResponse_protocolIEs (OSCTXT* pctxt, lppa_UTDOAInformationResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_UTDOAInformationResponse_protocolIEs_element (pctxt, ((lppa_UTDOAInformationResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_UTDOAInformationResponse_protocolIEs (OSCTXT* pctxt, lppa_UTDOAInformationResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_UTDOAInformationResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_UTDOAInformationResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_UTDOAInformationResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_UTDOAInformationResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_UTDOAInformationResponse_protocolIEs (
   lppa_UTDOAInformationResponse_protocolIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_UTDOAInformationResponse_protocolIEs (OSCTXT *pctxt, 
   lppa_UTDOAInformationResponse_protocolIEs* pvalue)
{
   if (0 == pvalue) return;
   { lppa_UTDOAInformationResponse_protocolIEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_UTDOAInformationResponse_protocolIEs_element*)pnode->data;
      asn1Free_lppa_UTDOAInformationResponse_protocolIEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_UTDOAInformationResponse (OSCTXT* pctxt, lppa_UTDOAInformationResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UTDOAInformationResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_lppa_UTDOAInformationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_UTDOAInformationResponse (OSCTXT* pctxt, lppa_UTDOAInformationResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UTDOAInformationResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_lppa_UTDOAInformationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_UTDOAInformationResponse (
   lppa_UTDOAInformationResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_UTDOAInformationResponse_protocolIEs (&pvalue->protocolIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_UTDOAInformationResponse (OSCTXT *pctxt, 
   lppa_UTDOAInformationResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_UTDOAInformationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

void asn1SetTC_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element_lppa_E_CIDMeasurementInitiationFailure_IEs_1
   (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pElem, lppa_Measurement_ID value)
{
   pElem->id = 2;
   pElem->criticality = lppa_reject;
   pElem->value.t = T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_1;
   pElem->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_1 = value;
}

void asn1SetTC_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element_lppa_E_CIDMeasurementInitiationFailure_IEs_2
   (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pElem, struct lppa_Cause *pvalue)
{
   pElem->id = 0;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_2;
   pElem->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_2 = pvalue;
}

void asn1SetTC_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element_lppa_E_CIDMeasurementInitiationFailure_IEs_3
   (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pElem, struct lppa_CriticalityDiagnostics *pvalue)
{
   pElem->id = 1;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_3;
   pElem->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_3 = pvalue;
}

EXTERN int asn1PE_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_E_CIDMeasurementInitiationFailure_IEs_1 */
   case T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementInitiationFailure_IEs_1");

      stat = asn1PE_lppa_Measurement_ID (pctxt, pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementInitiationFailure_IEs_2 */
   case T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_2:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementInitiationFailure_IEs_2");

      stat = asn1PE_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_E_CIDMeasurementInitiationFailure_IEs_3 */
   case T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_3:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_E_CIDMeasurementInitiationFailure_IEs_3");

      stat = asn1PE_lppa_CriticalityDiagnostics (pctxt, (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T6lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_E_SMLC_UE_Measurement_ID:
      pvalue->value.t = T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_1;

      stat = asn1PD_lppa_Measurement_ID (pctxt, &pvalue->value.
         u._lppa_E_CIDMeasurementInitiationFailure_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_Cause:
      pvalue->value.t = T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_2;

      pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_2
          = rtxMemAllocType (pctxt, lppa_Cause);

      if (pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_2
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_Cause ((lppa_Cause*)pvalue->value.
         u._lppa_E_CIDMeasurementInitiationFailure_IEs_2);

      stat = asn1PD_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.
         u._lppa_E_CIDMeasurementInitiationFailure_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_CriticalityDiagnostics:
      pvalue->value.t = T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_3;

      pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_3
          = rtxMemAllocType (pctxt, lppa_CriticalityDiagnostics);

      if (pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_3
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_CriticalityDiagnostics ((lppa_CriticalityDiagnostics*)
         pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_3);

      stat = asn1PD_lppa_CriticalityDiagnostics (pctxt, 
         (lppa_CriticalityDiagnostics*)pvalue->value.
         u._lppa_E_CIDMeasurementInitiationFailure_IEs_3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T6lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element (
   lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_2:
         if (0 != pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_2) {
            asn1Free_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_2);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_2);
         }
         break;

      case T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_3:
         if (0 != pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_3) {
            asn1Free_lppa_CriticalityDiagnostics (pctxt, (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_3);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_3);
         }
         break;

      default:;
   }
}

int asn1Append_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_1
      (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationFailure_protocolIEs* plist
   , lppa_Measurement_ID value)
{
   lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element_lppa_E_CIDMeasurementInitiationFailure_IEs_1 (pctxt, pElem
      , value);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_2
      (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationFailure_protocolIEs* plist
   , struct lppa_Cause *pvalue)
{
   lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element_lppa_E_CIDMeasurementInitiationFailure_IEs_2 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_3
      (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationFailure_protocolIEs* plist
   , struct lppa_CriticalityDiagnostics *pvalue)
{
   lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element_lppa_E_CIDMeasurementInitiationFailure_IEs_3 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* 
   asn1Get_lppa_E_CIDMeasurementInitiationFailure_protocolIEs 
   (lppa_ProtocolIE_ID id, 
   lppa_E_CIDMeasurementInitiationFailure_protocolIEs* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_E_CIDMeasurementInitiationFailure_protocolIEs (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element (pctxt, ((lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementInitiationFailure_protocolIEs (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementInitiationFailure_protocolIEs (
   lppa_E_CIDMeasurementInitiationFailure_protocolIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementInitiationFailure_protocolIEs (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementInitiationFailure_protocolIEs* pvalue)
{
   if (0 == pvalue) return;
   { lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element*)pnode->data;
      asn1Free_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_E_CIDMeasurementInitiationFailure (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-CIDMeasurementInitiationFailure");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_lppa_E_CIDMeasurementInitiationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_E_CIDMeasurementInitiationFailure (OSCTXT* pctxt, lppa_E_CIDMeasurementInitiationFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-CIDMeasurementInitiationFailure");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_lppa_E_CIDMeasurementInitiationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_E_CIDMeasurementInitiationFailure (
   lppa_E_CIDMeasurementInitiationFailure* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_E_CIDMeasurementInitiationFailure_protocolIEs (&pvalue->protocolIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_E_CIDMeasurementInitiationFailure (OSCTXT *pctxt, 
   lppa_E_CIDMeasurementInitiationFailure* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_E_CIDMeasurementInitiationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

void asn1SetTC_lppa_OTDOAInformationFailure_protocolIEs_element_lppa_OTDOAInformationFailure_IEs_1
   (OSCTXT* pctxt, lppa_OTDOAInformationFailure_protocolIEs_element* pElem, struct lppa_Cause *pvalue)
{
   pElem->id = 0;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T14lppa___lppa_OTDOAInformationFailure_IEs_1;
   pElem->value.u._lppa_OTDOAInformationFailure_IEs_1 = pvalue;
}

void asn1SetTC_lppa_OTDOAInformationFailure_protocolIEs_element_lppa_OTDOAInformationFailure_IEs_2
   (OSCTXT* pctxt, lppa_OTDOAInformationFailure_protocolIEs_element* pElem, struct lppa_CriticalityDiagnostics *pvalue)
{
   pElem->id = 1;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T14lppa___lppa_OTDOAInformationFailure_IEs_2;
   pElem->value.u._lppa_OTDOAInformationFailure_IEs_2 = pvalue;
}

EXTERN int asn1PE_lppa_OTDOAInformationFailure_protocolIEs_element (OSCTXT* pctxt, lppa_OTDOAInformationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_OTDOAInformationFailure_IEs_1 */
   case T14lppa___lppa_OTDOAInformationFailure_IEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_OTDOAInformationFailure_IEs_1");

      stat = asn1PE_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.u._lppa_OTDOAInformationFailure_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_OTDOAInformationFailure_IEs_2 */
   case T14lppa___lppa_OTDOAInformationFailure_IEs_2:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_OTDOAInformationFailure_IEs_2");

      stat = asn1PE_lppa_CriticalityDiagnostics (pctxt, (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_OTDOAInformationFailure_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T14lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOAInformationFailure_protocolIEs_element (OSCTXT* pctxt, lppa_OTDOAInformationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_Cause:
      pvalue->value.t = T14lppa___lppa_OTDOAInformationFailure_IEs_1;

      pvalue->value.u._lppa_OTDOAInformationFailure_IEs_1
          = rtxMemAllocType (pctxt, lppa_Cause);

      if (pvalue->value.u._lppa_OTDOAInformationFailure_IEs_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_Cause ((lppa_Cause*)pvalue->value.
         u._lppa_OTDOAInformationFailure_IEs_1);

      stat = asn1PD_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.
         u._lppa_OTDOAInformationFailure_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_CriticalityDiagnostics:
      pvalue->value.t = T14lppa___lppa_OTDOAInformationFailure_IEs_2;

      pvalue->value.u._lppa_OTDOAInformationFailure_IEs_2
          = rtxMemAllocType (pctxt, lppa_CriticalityDiagnostics);

      if (pvalue->value.u._lppa_OTDOAInformationFailure_IEs_2 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_CriticalityDiagnostics ((lppa_CriticalityDiagnostics*)
         pvalue->value.u._lppa_OTDOAInformationFailure_IEs_2);

      stat = asn1PD_lppa_CriticalityDiagnostics (pctxt, 
         (lppa_CriticalityDiagnostics*)pvalue->value.
         u._lppa_OTDOAInformationFailure_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T14lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_OTDOAInformationFailure_protocolIEs_element (
   lppa_OTDOAInformationFailure_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_OTDOAInformationFailure_protocolIEs_element (OSCTXT *pctxt, 
   lppa_OTDOAInformationFailure_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T14lppa___lppa_OTDOAInformationFailure_IEs_1:
         if (0 != pvalue->value.u._lppa_OTDOAInformationFailure_IEs_1) {
            asn1Free_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.u._lppa_OTDOAInformationFailure_IEs_1);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_OTDOAInformationFailure_IEs_1);
         }
         break;

      case T14lppa___lppa_OTDOAInformationFailure_IEs_2:
         if (0 != pvalue->value.u._lppa_OTDOAInformationFailure_IEs_2) {
            asn1Free_lppa_CriticalityDiagnostics (pctxt, (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_OTDOAInformationFailure_IEs_2);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_OTDOAInformationFailure_IEs_2);
         }
         break;

      default:;
   }
}

int asn1Append_lppa_OTDOAInformationFailure_protocolIEs_1   (OSCTXT* pctxt, 
   lppa_OTDOAInformationFailure_protocolIEs* plist, struct lppa_Cause *pvalue)
{
   lppa_OTDOAInformationFailure_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_OTDOAInformationFailure_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_OTDOAInformationFailure_protocolIEs_element_lppa_OTDOAInformationFailure_IEs_1 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_OTDOAInformationFailure_protocolIEs_2   (OSCTXT* pctxt, 
   lppa_OTDOAInformationFailure_protocolIEs* plist, struct 
   lppa_CriticalityDiagnostics *pvalue)
{
   lppa_OTDOAInformationFailure_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_OTDOAInformationFailure_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_OTDOAInformationFailure_protocolIEs_element_lppa_OTDOAInformationFailure_IEs_2 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

lppa_OTDOAInformationFailure_protocolIEs_element* 
   asn1Get_lppa_OTDOAInformationFailure_protocolIEs (lppa_ProtocolIE_ID id, 
   lppa_OTDOAInformationFailure_protocolIEs* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_OTDOAInformationFailure_protocolIEs_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_OTDOAInformationFailure_protocolIEs_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_OTDOAInformationFailure_protocolIEs (OSCTXT* pctxt, lppa_OTDOAInformationFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_OTDOAInformationFailure_protocolIEs_element (pctxt, ((lppa_OTDOAInformationFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOAInformationFailure_protocolIEs (OSCTXT* pctxt, lppa_OTDOAInformationFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_OTDOAInformationFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_OTDOAInformationFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_OTDOAInformationFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_OTDOAInformationFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_OTDOAInformationFailure_protocolIEs (
   lppa_OTDOAInformationFailure_protocolIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_OTDOAInformationFailure_protocolIEs (OSCTXT *pctxt, 
   lppa_OTDOAInformationFailure_protocolIEs* pvalue)
{
   if (0 == pvalue) return;
   { lppa_OTDOAInformationFailure_protocolIEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_OTDOAInformationFailure_protocolIEs_element*)pnode->data;
      asn1Free_lppa_OTDOAInformationFailure_protocolIEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_OTDOAInformationFailure (OSCTXT* pctxt, lppa_OTDOAInformationFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOAInformationFailure");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_lppa_OTDOAInformationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_OTDOAInformationFailure (OSCTXT* pctxt, lppa_OTDOAInformationFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OTDOAInformationFailure");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_lppa_OTDOAInformationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_OTDOAInformationFailure (
   lppa_OTDOAInformationFailure* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_OTDOAInformationFailure_protocolIEs (&pvalue->protocolIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_OTDOAInformationFailure (OSCTXT *pctxt, 
   lppa_OTDOAInformationFailure* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_OTDOAInformationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

void asn1SetTC_lppa_UTDOAInformationFailure_protocolIEs_element_lppa_UTDOAInformationFailure_IEs_1
   (OSCTXT* pctxt, lppa_UTDOAInformationFailure_protocolIEs_element* pElem, struct lppa_Cause *pvalue)
{
   pElem->id = 0;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T17lppa___lppa_UTDOAInformationFailure_IEs_1;
   pElem->value.u._lppa_UTDOAInformationFailure_IEs_1 = pvalue;
}

void asn1SetTC_lppa_UTDOAInformationFailure_protocolIEs_element_lppa_UTDOAInformationFailure_IEs_2
   (OSCTXT* pctxt, lppa_UTDOAInformationFailure_protocolIEs_element* pElem, struct lppa_CriticalityDiagnostics *pvalue)
{
   pElem->id = 1;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T17lppa___lppa_UTDOAInformationFailure_IEs_2;
   pElem->value.u._lppa_UTDOAInformationFailure_IEs_2 = pvalue;
}

EXTERN int asn1PE_lppa_UTDOAInformationFailure_protocolIEs_element (OSCTXT* pctxt, lppa_UTDOAInformationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_lppa_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _lppa_UTDOAInformationFailure_IEs_1 */
   case T17lppa___lppa_UTDOAInformationFailure_IEs_1:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_UTDOAInformationFailure_IEs_1");

      stat = asn1PE_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.u._lppa_UTDOAInformationFailure_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _lppa_UTDOAInformationFailure_IEs_2 */
   case T17lppa___lppa_UTDOAInformationFailure_IEs_2:
      RTXCTXTPUSHELEMNAME (pctxt, "_lppa_UTDOAInformationFailure_IEs_2");

      stat = asn1PE_lppa_CriticalityDiagnostics (pctxt, (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_UTDOAInformationFailure_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T17lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_UTDOAInformationFailure_protocolIEs_element (OSCTXT* pctxt, lppa_UTDOAInformationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_lppa_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->id) {
   case ASN1V_lppa_id_Cause:
      pvalue->value.t = T17lppa___lppa_UTDOAInformationFailure_IEs_1;

      pvalue->value.u._lppa_UTDOAInformationFailure_IEs_1
          = rtxMemAllocType (pctxt, lppa_Cause);

      if (pvalue->value.u._lppa_UTDOAInformationFailure_IEs_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_Cause ((lppa_Cause*)pvalue->value.
         u._lppa_UTDOAInformationFailure_IEs_1);

      stat = asn1PD_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.
         u._lppa_UTDOAInformationFailure_IEs_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_CriticalityDiagnostics:
      pvalue->value.t = T17lppa___lppa_UTDOAInformationFailure_IEs_2;

      pvalue->value.u._lppa_UTDOAInformationFailure_IEs_2
          = rtxMemAllocType (pctxt, lppa_CriticalityDiagnostics);

      if (pvalue->value.u._lppa_UTDOAInformationFailure_IEs_2 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_CriticalityDiagnostics ((lppa_CriticalityDiagnostics*)
         pvalue->value.u._lppa_UTDOAInformationFailure_IEs_2);

      stat = asn1PD_lppa_CriticalityDiagnostics (pctxt, 
         (lppa_CriticalityDiagnostics*)pvalue->value.
         u._lppa_UTDOAInformationFailure_IEs_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T17lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

int asn1Init_lppa_UTDOAInformationFailure_protocolIEs_element (
   lppa_UTDOAInformationFailure_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_UTDOAInformationFailure_protocolIEs_element (OSCTXT *pctxt, 
   lppa_UTDOAInformationFailure_protocolIEs_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T17lppa___lppa_UTDOAInformationFailure_IEs_1:
         if (0 != pvalue->value.u._lppa_UTDOAInformationFailure_IEs_1) {
            asn1Free_lppa_Cause (pctxt, (lppa_Cause*)pvalue->value.u._lppa_UTDOAInformationFailure_IEs_1);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_UTDOAInformationFailure_IEs_1);
         }
         break;

      case T17lppa___lppa_UTDOAInformationFailure_IEs_2:
         if (0 != pvalue->value.u._lppa_UTDOAInformationFailure_IEs_2) {
            asn1Free_lppa_CriticalityDiagnostics (pctxt, (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_UTDOAInformationFailure_IEs_2);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u._lppa_UTDOAInformationFailure_IEs_2);
         }
         break;

      default:;
   }
}

int asn1Append_lppa_UTDOAInformationFailure_protocolIEs_1   (OSCTXT* pctxt, 
   lppa_UTDOAInformationFailure_protocolIEs* plist, struct lppa_Cause *pvalue)
{
   lppa_UTDOAInformationFailure_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_UTDOAInformationFailure_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_UTDOAInformationFailure_protocolIEs_element_lppa_UTDOAInformationFailure_IEs_1 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

int asn1Append_lppa_UTDOAInformationFailure_protocolIEs_2   (OSCTXT* pctxt, 
   lppa_UTDOAInformationFailure_protocolIEs* plist, struct 
   lppa_CriticalityDiagnostics *pvalue)
{
   lppa_UTDOAInformationFailure_protocolIEs_element* pElem = 
      rtxMemAllocType (pctxt, lppa_UTDOAInformationFailure_protocolIEs_element);
   if (0 == pElem) return LOG_RTERR (pctxt, RTERR_NOMEM);

   asn1SetTC_lppa_UTDOAInformationFailure_protocolIEs_element_lppa_UTDOAInformationFailure_IEs_2 (pctxt, pElem
      , pvalue);
   if (0 == rtxDListAppend (pctxt, plist, (void*)pElem)) return LOG_RTERR 
      (pctxt, RTERR_NOMEM);

   return 0;
}

lppa_UTDOAInformationFailure_protocolIEs_element* 
   asn1Get_lppa_UTDOAInformationFailure_protocolIEs (lppa_ProtocolIE_ID id, 
   lppa_UTDOAInformationFailure_protocolIEs* plist)
{
   if (0 != plist && plist->count > 0) {
      OSRTDListNode* pNode = plist->head;
      lppa_UTDOAInformationFailure_protocolIEs_element* pElem;
      while (0 != pNode) {
         pElem = (lppa_UTDOAInformationFailure_protocolIEs_element*) pNode->data;
         if (pElem->id == id) return pElem;
         pNode = pNode->next;
      }
   }
   return 0;
}

EXTERN int asn1PE_lppa_UTDOAInformationFailure_protocolIEs (OSCTXT* pctxt, lppa_UTDOAInformationFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_lppa_UTDOAInformationFailure_protocolIEs_element (pctxt, ((lppa_UTDOAInformationFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_lppa_UTDOAInformationFailure_protocolIEs (OSCTXT* pctxt, lppa_UTDOAInformationFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      lppa_UTDOAInformationFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, lppa_UTDOAInformationFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_UTDOAInformationFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_lppa_UTDOAInformationFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_lppa_UTDOAInformationFailure_protocolIEs (
   lppa_UTDOAInformationFailure_protocolIEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_lppa_UTDOAInformationFailure_protocolIEs (OSCTXT *pctxt, 
   lppa_UTDOAInformationFailure_protocolIEs* pvalue)
{
   if (0 == pvalue) return;
   { lppa_UTDOAInformationFailure_protocolIEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (lppa_UTDOAInformationFailure_protocolIEs_element*)pnode->data;
      asn1Free_lppa_UTDOAInformationFailure_protocolIEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_lppa_UTDOAInformationFailure (OSCTXT* pctxt, lppa_UTDOAInformationFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UTDOAInformationFailure");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_lppa_UTDOAInformationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_UTDOAInformationFailure (OSCTXT* pctxt, lppa_UTDOAInformationFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UTDOAInformationFailure");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_lppa_UTDOAInformationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_UTDOAInformationFailure (
   lppa_UTDOAInformationFailure* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_lppa_UTDOAInformationFailure_protocolIEs (&pvalue->protocolIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_lppa_UTDOAInformationFailure (OSCTXT *pctxt, 
   lppa_UTDOAInformationFailure* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_lppa_UTDOAInformationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

void asn1Print_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element 
   (const char* name, const lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_1 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_1:
      {
         asn1Print_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.
            u._lppa_E_CIDMeasurementInitiationRequest_IEs_1);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_2 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_2:
      {
         asn1Print_lppa_ReportCharacteristics ("ReportCharacteristics", &pvalue
            ->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_2);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_3 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_3:
      {
         asn1Print_lppa_MeasurementPeriodicity ("MeasurementPeriodicity", &
            pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_3);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_4 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_4:
      {
         asn1Print_lppa_MeasurementQuantities ("MeasurementQuantities", pvalue
            ->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_4);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_5 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_5:
      {
         asn1Print_lppa_InterRATMeasurementQuantities (
            "InterRATMeasurementQuantities", pvalue->value.
            u._lppa_E_CIDMeasurementInitiationRequest_IEs_5);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_E_CIDMeasurementInitiationRequest_protocolIEs 
   (const char* name, const lppa_E_CIDMeasurementInitiationRequest_protocolIEs* pvalue)
{
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element (
         namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_E_CIDMeasurementInitiationRequest 
   (const char* name, const lppa_E_CIDMeasurementInitiationRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_E_CIDMeasurementInitiationRequest_protocolIEs (
      "protocolIEs", &pvalue->protocolIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_OTDOA_Information_Type_Item_iE_Extensions_element 
   (const char* name, const lppa_OTDOA_Information_Type_Item_iE_Extensions_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("extensionValue", pvalue->extensionValue.numocts,
   pvalue->extensionValue.data);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_OTDOA_Information_Type_Item_iE_Extensions 
   (const char* name, const lppa_OTDOA_Information_Type_Item_iE_Extensions* pvalue)
{
   lppa_OTDOA_Information_Type_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOA_Information_Type_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_OTDOA_Information_Type_Item_iE_Extensions_element (
         namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_OTDOA_Information_Type_Item 
   (const char* name, const lppa_OTDOA_Information_Type_Item* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_OTDOA_Information_Item ("oTDOA_Information_Type_Item", &
      pvalue->oTDOA_Information_Type_Item);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_lppa_OTDOA_Information_Type_Item_iE_Extensions (
         "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_OTDOA_Information_Type_element 
   (const char* name, const lppa_OTDOA_Information_Type_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_OTDOA_Information_TypeIEs_1 */
      case T11lppa___lppa_OTDOA_Information_TypeIEs_1:
      {
         asn1Print_lppa_OTDOA_Information_Type_Item (
            "OTDOA-Information-Type-Item", pvalue->value.
            u._lppa_OTDOA_Information_TypeIEs_1);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_OTDOA_Information_Type 
   (const char* name, const lppa_OTDOA_Information_Type* pvalue)
{
   lppa_OTDOA_Information_Type_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOA_Information_Type_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_OTDOA_Information_Type_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_OTDOAInformationRequest_protocolIEs_element 
   (const char* name, const lppa_OTDOAInformationRequest_protocolIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_OTDOAInformationRequest_IEs_1 */
      case T10lppa___lppa_OTDOAInformationRequest_IEs_1:
      {
         asn1Print_lppa_OTDOA_Information_Type ("OTDOA-Information-Type", 
            pvalue->value.u._lppa_OTDOAInformationRequest_IEs_1);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_OTDOAInformationRequest_protocolIEs 
   (const char* name, const lppa_OTDOAInformationRequest_protocolIEs* pvalue)
{
   lppa_OTDOAInformationRequest_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOAInformationRequest_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_OTDOAInformationRequest_protocolIEs_element (namebuf, 
         pdata0);
      xx1++;
   }
}

void asn1Print_lppa_OTDOAInformationRequest 
   (const char* name, const lppa_OTDOAInformationRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_OTDOAInformationRequest_protocolIEs ("protocolIEs", &pvalue->
      protocolIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_UTDOAInformationRequest_protocolIEs_element 
   (const char* name, const lppa_UTDOAInformationRequest_protocolIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_UTDOAInformationRequest_IEs_1 */
      case T15lppa___lppa_UTDOAInformationRequest_IEs_1:
      {
         asn1Print_lppa_RequestedSRSTransmissionCharacteristics (
            "RequestedSRSTransmissionCharacteristics", pvalue->value.
            u._lppa_UTDOAInformationRequest_IEs_1);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_UTDOAInformationRequest_protocolIEs 
   (const char* name, const lppa_UTDOAInformationRequest_protocolIEs* pvalue)
{
   lppa_UTDOAInformationRequest_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_UTDOAInformationRequest_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_UTDOAInformationRequest_protocolIEs_element (namebuf, 
         pdata0);
      xx1++;
   }
}

void asn1Print_lppa_UTDOAInformationRequest 
   (const char* name, const lppa_UTDOAInformationRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_UTDOAInformationRequest_protocolIEs ("protocolIEs", &pvalue->
      protocolIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element 
   (const char* name, const lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_E_CIDMeasurementFailureIndication_IEs_1 */
      case T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_1:
      {
         asn1Print_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.
            u._lppa_E_CIDMeasurementFailureIndication_IEs_1);
         break;
      }
      /* _lppa_E_CIDMeasurementFailureIndication_IEs_2 */
      case T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_2:
      {
         asn1Print_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.
            u._lppa_E_CIDMeasurementFailureIndication_IEs_2);
         break;
      }
      /* _lppa_E_CIDMeasurementFailureIndication_IEs_3 */
      case T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_3:
      {
         asn1Print_lppa_Cause ("Cause", (lppa_Cause*)pvalue->value.
            u._lppa_E_CIDMeasurementFailureIndication_IEs_3);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_E_CIDMeasurementFailureIndication_protocolIEs 
   (const char* name, const lppa_E_CIDMeasurementFailureIndication_protocolIEs* pvalue)
{
   lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementFailureIndication_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element (
         namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_E_CIDMeasurementFailureIndication 
   (const char* name, const lppa_E_CIDMeasurementFailureIndication* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_E_CIDMeasurementFailureIndication_protocolIEs (
      "protocolIEs", &pvalue->protocolIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_E_CIDMeasurementReport_protocolIEs_element 
   (const char* name, const lppa_E_CIDMeasurementReport_protocolIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_E_CIDMeasurementReport_IEs_1 */
      case T8lppa___lppa_E_CIDMeasurementReport_IEs_1:
      {
         asn1Print_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.
            u._lppa_E_CIDMeasurementReport_IEs_1);
         break;
      }
      /* _lppa_E_CIDMeasurementReport_IEs_2 */
      case T8lppa___lppa_E_CIDMeasurementReport_IEs_2:
      {
         asn1Print_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.
            u._lppa_E_CIDMeasurementReport_IEs_2);
         break;
      }
      /* _lppa_E_CIDMeasurementReport_IEs_3 */
      case T8lppa___lppa_E_CIDMeasurementReport_IEs_3:
      {
         asn1Print_lppa_E_CID_MeasurementResult ("E-CID-MeasurementResult", 
            (lppa_E_CID_MeasurementResult*)pvalue->value.
            u._lppa_E_CIDMeasurementReport_IEs_3);
         break;
      }
      /* _lppa_E_CIDMeasurementReport_IEs_4 */
      case T8lppa___lppa_E_CIDMeasurementReport_IEs_4:
      {
         asn1Print_lppa_Cell_Portion_ID ("Cell-Portion-ID", &pvalue->value.
            u._lppa_E_CIDMeasurementReport_IEs_4);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_E_CIDMeasurementReport_protocolIEs 
   (const char* name, const lppa_E_CIDMeasurementReport_protocolIEs* pvalue)
{
   lppa_E_CIDMeasurementReport_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementReport_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_E_CIDMeasurementReport_protocolIEs_element (namebuf, 
         pdata0);
      xx1++;
   }
}

void asn1Print_lppa_E_CIDMeasurementReport 
   (const char* name, const lppa_E_CIDMeasurementReport* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_E_CIDMeasurementReport_protocolIEs ("protocolIEs", &pvalue->
      protocolIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element 
   (const char* name, const lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_E_CIDMeasurementTerminationCommand_IEs_1 */
      case T9lppa___lppa_E_CIDMeasurementTerminationCommand_IEs_1:
      {
         asn1Print_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.
            u._lppa_E_CIDMeasurementTerminationCommand_IEs_1);
         break;
      }
      /* _lppa_E_CIDMeasurementTerminationCommand_IEs_2 */
      case T9lppa___lppa_E_CIDMeasurementTerminationCommand_IEs_2:
      {
         asn1Print_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.
            u._lppa_E_CIDMeasurementTerminationCommand_IEs_2);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_E_CIDMeasurementTerminationCommand_protocolIEs 
   (const char* name, const lppa_E_CIDMeasurementTerminationCommand_protocolIEs* pvalue)
{
   lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element (
         namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_E_CIDMeasurementTerminationCommand 
   (const char* name, const lppa_E_CIDMeasurementTerminationCommand* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_E_CIDMeasurementTerminationCommand_protocolIEs (
      "protocolIEs", &pvalue->protocolIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_ErrorIndication_protocolIEs_element 
   (const char* name, const lppa_ErrorIndication_protocolIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_ErrorIndication_IEs_1 */
      case T19lppa___lppa_ErrorIndication_IEs_1:
      {
         asn1Print_lppa_Cause ("Cause", (lppa_Cause*)pvalue->value.
            u._lppa_ErrorIndication_IEs_1);
         break;
      }
      /* _lppa_ErrorIndication_IEs_2 */
      case T19lppa___lppa_ErrorIndication_IEs_2:
      {
         asn1Print_lppa_CriticalityDiagnostics ("CriticalityDiagnostics", 
            (lppa_CriticalityDiagnostics*)pvalue->value.
            u._lppa_ErrorIndication_IEs_2);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_ErrorIndication_protocolIEs 
   (const char* name, const lppa_ErrorIndication_protocolIEs* pvalue)
{
   lppa_ErrorIndication_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ErrorIndication_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_ErrorIndication_protocolIEs_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_ErrorIndication 
   (const char* name, const lppa_ErrorIndication* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ErrorIndication_protocolIEs ("protocolIEs", &pvalue->
      protocolIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_PrivateMessage_privateIEs_element 
   (const char* name, const lppa_PrivateMessage_privateIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_PrivateIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("value", pvalue->value.numocts,
   pvalue->value.data);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_PrivateMessage_privateIEs 
   (const char* name, const lppa_PrivateMessage_privateIEs* pvalue)
{
   lppa_PrivateMessage_privateIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_PrivateMessage_privateIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_PrivateMessage_privateIEs_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_PrivateMessage 
   (const char* name, const lppa_PrivateMessage* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_PrivateMessage_privateIEs ("privateIEs", &pvalue->privateIEs
      );

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_UTDOAInformationUpdate_protocolIEs_element 
   (const char* name, const lppa_UTDOAInformationUpdate_protocolIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_UTDOAInformationUpdate_IEs_1 */
      case T18lppa___lppa_UTDOAInformationUpdate_IEs_1:
      {
         asn1Print_lppa_ULConfiguration ("ULConfiguration", pvalue->value.
            u._lppa_UTDOAInformationUpdate_IEs_1);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_UTDOAInformationUpdate_protocolIEs 
   (const char* name, const lppa_UTDOAInformationUpdate_protocolIEs* pvalue)
{
   lppa_UTDOAInformationUpdate_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_UTDOAInformationUpdate_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_UTDOAInformationUpdate_protocolIEs_element (namebuf, 
         pdata0);
      xx1++;
   }
}

void asn1Print_lppa_UTDOAInformationUpdate 
   (const char* name, const lppa_UTDOAInformationUpdate* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_UTDOAInformationUpdate_protocolIEs ("protocolIEs", &pvalue->
      protocolIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element 
   (const char* name, const lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_1 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_1:
      {
         asn1Print_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.
            u._lppa_E_CIDMeasurementInitiationResponse_IEs_1);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_2 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_2:
      {
         asn1Print_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.
            u._lppa_E_CIDMeasurementInitiationResponse_IEs_2);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_3 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_3:
      {
         asn1Print_lppa_E_CID_MeasurementResult ("E-CID-MeasurementResult", 
            (lppa_E_CID_MeasurementResult*)pvalue->value.
            u._lppa_E_CIDMeasurementInitiationResponse_IEs_3);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_4 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_4:
      {
         asn1Print_lppa_CriticalityDiagnostics ("CriticalityDiagnostics", 
            (lppa_CriticalityDiagnostics*)pvalue->value.
            u._lppa_E_CIDMeasurementInitiationResponse_IEs_4);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_5 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_5:
      {
         asn1Print_lppa_Cell_Portion_ID ("Cell-Portion-ID", &pvalue->value.
            u._lppa_E_CIDMeasurementInitiationResponse_IEs_5);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_6 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_6:
      {
         asn1Print_lppa_InterRATMeasurementResult (
            "InterRATMeasurementResult", pvalue->value.
            u._lppa_E_CIDMeasurementInitiationResponse_IEs_6);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_E_CIDMeasurementInitiationResponse_protocolIEs 
   (const char* name, const lppa_E_CIDMeasurementInitiationResponse_protocolIEs* pvalue)
{
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element (
         namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_E_CIDMeasurementInitiationResponse 
   (const char* name, const lppa_E_CIDMeasurementInitiationResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_E_CIDMeasurementInitiationResponse_protocolIEs (
      "protocolIEs", &pvalue->protocolIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_OTDOAInformationResponse_protocolIEs_element 
   (const char* name, const lppa_OTDOAInformationResponse_protocolIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_OTDOAInformationResponse_IEs_1 */
      case T13lppa___lppa_OTDOAInformationResponse_IEs_1:
      {
         asn1Print_lppa_OTDOACells ("OTDOACells", pvalue->value.
            u._lppa_OTDOAInformationResponse_IEs_1);
         break;
      }
      /* _lppa_OTDOAInformationResponse_IEs_2 */
      case T13lppa___lppa_OTDOAInformationResponse_IEs_2:
      {
         asn1Print_lppa_CriticalityDiagnostics ("CriticalityDiagnostics", 
            (lppa_CriticalityDiagnostics*)pvalue->value.
            u._lppa_OTDOAInformationResponse_IEs_2);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_OTDOAInformationResponse_protocolIEs 
   (const char* name, const lppa_OTDOAInformationResponse_protocolIEs* pvalue)
{
   lppa_OTDOAInformationResponse_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOAInformationResponse_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_OTDOAInformationResponse_protocolIEs_element (namebuf, 
         pdata0);
      xx1++;
   }
}

void asn1Print_lppa_OTDOAInformationResponse 
   (const char* name, const lppa_OTDOAInformationResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_OTDOAInformationResponse_protocolIEs ("protocolIEs", &pvalue
      ->protocolIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_UTDOAInformationResponse_protocolIEs_element 
   (const char* name, const lppa_UTDOAInformationResponse_protocolIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_UTDOAInformationResponse_IEs_1 */
      case T16lppa___lppa_UTDOAInformationResponse_IEs_1:
      {
         asn1Print_lppa_ULConfiguration ("ULConfiguration", 
            (lppa_ULConfiguration*)pvalue->value.
            u._lppa_UTDOAInformationResponse_IEs_1);
         break;
      }
      /* _lppa_UTDOAInformationResponse_IEs_2 */
      case T16lppa___lppa_UTDOAInformationResponse_IEs_2:
      {
         asn1Print_lppa_CriticalityDiagnostics ("CriticalityDiagnostics", 
            (lppa_CriticalityDiagnostics*)pvalue->value.
            u._lppa_UTDOAInformationResponse_IEs_2);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_UTDOAInformationResponse_protocolIEs 
   (const char* name, const lppa_UTDOAInformationResponse_protocolIEs* pvalue)
{
   lppa_UTDOAInformationResponse_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_UTDOAInformationResponse_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_UTDOAInformationResponse_protocolIEs_element (namebuf, 
         pdata0);
      xx1++;
   }
}

void asn1Print_lppa_UTDOAInformationResponse 
   (const char* name, const lppa_UTDOAInformationResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_UTDOAInformationResponse_protocolIEs ("protocolIEs", &pvalue
      ->protocolIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element 
   (const char* name, const lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_E_CIDMeasurementInitiationFailure_IEs_1 */
      case T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_1:
      {
         asn1Print_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.
            u._lppa_E_CIDMeasurementInitiationFailure_IEs_1);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationFailure_IEs_2 */
      case T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_2:
      {
         asn1Print_lppa_Cause ("Cause", (lppa_Cause*)pvalue->value.
            u._lppa_E_CIDMeasurementInitiationFailure_IEs_2);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationFailure_IEs_3 */
      case T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_3:
      {
         asn1Print_lppa_CriticalityDiagnostics ("CriticalityDiagnostics", 
            (lppa_CriticalityDiagnostics*)pvalue->value.
            u._lppa_E_CIDMeasurementInitiationFailure_IEs_3);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_E_CIDMeasurementInitiationFailure_protocolIEs 
   (const char* name, const lppa_E_CIDMeasurementInitiationFailure_protocolIEs* pvalue)
{
   lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element (
         namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_lppa_E_CIDMeasurementInitiationFailure 
   (const char* name, const lppa_E_CIDMeasurementInitiationFailure* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_E_CIDMeasurementInitiationFailure_protocolIEs (
      "protocolIEs", &pvalue->protocolIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_OTDOAInformationFailure_protocolIEs_element 
   (const char* name, const lppa_OTDOAInformationFailure_protocolIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_OTDOAInformationFailure_IEs_1 */
      case T14lppa___lppa_OTDOAInformationFailure_IEs_1:
      {
         asn1Print_lppa_Cause ("Cause", (lppa_Cause*)pvalue->value.
            u._lppa_OTDOAInformationFailure_IEs_1);
         break;
      }
      /* _lppa_OTDOAInformationFailure_IEs_2 */
      case T14lppa___lppa_OTDOAInformationFailure_IEs_2:
      {
         asn1Print_lppa_CriticalityDiagnostics ("CriticalityDiagnostics", 
            (lppa_CriticalityDiagnostics*)pvalue->value.
            u._lppa_OTDOAInformationFailure_IEs_2);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_OTDOAInformationFailure_protocolIEs 
   (const char* name, const lppa_OTDOAInformationFailure_protocolIEs* pvalue)
{
   lppa_OTDOAInformationFailure_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOAInformationFailure_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_OTDOAInformationFailure_protocolIEs_element (namebuf, 
         pdata0);
      xx1++;
   }
}

void asn1Print_lppa_OTDOAInformationFailure 
   (const char* name, const lppa_OTDOAInformationFailure* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_OTDOAInformationFailure_protocolIEs ("protocolIEs", &pvalue->
      protocolIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_UTDOAInformationFailure_protocolIEs_element 
   (const char* name, const lppa_UTDOAInformationFailure_protocolIEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* _lppa_UTDOAInformationFailure_IEs_1 */
      case T17lppa___lppa_UTDOAInformationFailure_IEs_1:
      {
         asn1Print_lppa_Cause ("Cause", (lppa_Cause*)pvalue->value.
            u._lppa_UTDOAInformationFailure_IEs_1);
         break;
      }
      /* _lppa_UTDOAInformationFailure_IEs_2 */
      case T17lppa___lppa_UTDOAInformationFailure_IEs_2:
      {
         asn1Print_lppa_CriticalityDiagnostics ("CriticalityDiagnostics", 
            (lppa_CriticalityDiagnostics*)pvalue->value.
            u._lppa_UTDOAInformationFailure_IEs_2);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_UTDOAInformationFailure_protocolIEs 
   (const char* name, const lppa_UTDOAInformationFailure_protocolIEs* pvalue)
{
   lppa_UTDOAInformationFailure_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_UTDOAInformationFailure_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_lppa_UTDOAInformationFailure_protocolIEs_element (namebuf, 
         pdata0);
      xx1++;
   }
}

void asn1Print_lppa_UTDOAInformationFailure 
   (const char* name, const lppa_UTDOAInformationFailure* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_UTDOAInformationFailure_protocolIEs ("protocolIEs", &pvalue->
      protocolIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

int asn1PrtToStr_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element (
   const char* name, 
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_1 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_1:
      {
         if (asn1PrtToStr_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_2 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_2:
      {
         if (asn1PrtToStr_lppa_ReportCharacteristics ("ReportCharacteristics", &pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_2, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_3 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_3:
      {
         if (asn1PrtToStr_lppa_MeasurementPeriodicity ("MeasurementPeriodicity", &pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_3, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_4 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_4:
      {
         if (asn1PrtToStr_lppa_MeasurementQuantities ("MeasurementQuantities", pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_4, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_5 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_5:
      {
         if (asn1PrtToStr_lppa_InterRATMeasurementQuantities ("InterRATMeasurementQuantities", pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_5, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementInitiationRequest_protocolIEs (
   const char* name, 
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementInitiationRequest (const char* name, 
   lppa_E_CIDMeasurementInitiationRequest* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_E_CIDMeasurementInitiationRequest_protocolIEs ("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_OTDOA_Information_Type_Item_iE_Extensions_element (
   const char* name, 
   lppa_OTDOA_Information_Type_Item_iE_Extensions_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringHexStr ("extensionValue", pvalue->extensionValue.numocts, pvalue->extensionValue.data, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_OTDOA_Information_Type_Item_iE_Extensions (
   const char* name, lppa_OTDOA_Information_Type_Item_iE_Extensions* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   lppa_OTDOA_Information_Type_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOA_Information_Type_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_OTDOA_Information_Type_Item_iE_Extensions_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_OTDOA_Information_Type_Item (const char* name, 
   lppa_OTDOA_Information_Type_Item* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_OTDOA_Information_Item ("oTDOA_Information_Type_Item", &pvalue->oTDOA_Information_Type_Item, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      if (asn1PrtToStr_lppa_OTDOA_Information_Type_Item_iE_Extensions ("iE_Extensions", &pvalue->iE_Extensions, buffer, bufSize) < 0)
      {
         return -1;
      }
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_OTDOA_Information_Type_element (const char* name, 
   lppa_OTDOA_Information_Type_element* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_OTDOA_Information_TypeIEs_1 */
      case T11lppa___lppa_OTDOA_Information_TypeIEs_1:
      {
         if (asn1PrtToStr_lppa_OTDOA_Information_Type_Item ("OTDOA-Information-Type-Item", pvalue->value.u._lppa_OTDOA_Information_TypeIEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_OTDOA_Information_Type (const char* name, 
   lppa_OTDOA_Information_Type* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_OTDOA_Information_Type_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOA_Information_Type_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_OTDOA_Information_Type_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_OTDOAInformationRequest_protocolIEs_element (
   const char* name, lppa_OTDOAInformationRequest_protocolIEs_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_OTDOAInformationRequest_IEs_1 */
      case T10lppa___lppa_OTDOAInformationRequest_IEs_1:
      {
         if (asn1PrtToStr_lppa_OTDOA_Information_Type ("OTDOA-Information-Type", pvalue->value.u._lppa_OTDOAInformationRequest_IEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_OTDOAInformationRequest_protocolIEs (const char* name, 
   lppa_OTDOAInformationRequest_protocolIEs* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   lppa_OTDOAInformationRequest_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOAInformationRequest_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_OTDOAInformationRequest_protocolIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_OTDOAInformationRequest (const char* name, 
   lppa_OTDOAInformationRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_OTDOAInformationRequest_protocolIEs ("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_UTDOAInformationRequest_protocolIEs_element (
   const char* name, lppa_UTDOAInformationRequest_protocolIEs_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_UTDOAInformationRequest_IEs_1 */
      case T15lppa___lppa_UTDOAInformationRequest_IEs_1:
      {
         if (asn1PrtToStr_lppa_RequestedSRSTransmissionCharacteristics ("RequestedSRSTransmissionCharacteristics", pvalue->value.u._lppa_UTDOAInformationRequest_IEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_UTDOAInformationRequest_protocolIEs (const char* name, 
   lppa_UTDOAInformationRequest_protocolIEs* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   lppa_UTDOAInformationRequest_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_UTDOAInformationRequest_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_UTDOAInformationRequest_protocolIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_UTDOAInformationRequest (const char* name, 
   lppa_UTDOAInformationRequest* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_UTDOAInformationRequest_protocolIEs ("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element (
   const char* name, 
   lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_E_CIDMeasurementFailureIndication_IEs_1 */
      case T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_1:
      {
         if (asn1PrtToStr_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementFailureIndication_IEs_2 */
      case T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_2:
      {
         if (asn1PrtToStr_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_2, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementFailureIndication_IEs_3 */
      case T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_3:
      {
         if (asn1PrtToStr_lppa_Cause ("Cause", (lppa_Cause*)pvalue->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_3, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementFailureIndication_protocolIEs (
   const char* name, 
   lppa_E_CIDMeasurementFailureIndication_protocolIEs* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementFailureIndication_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementFailureIndication (const char* name, 
   lppa_E_CIDMeasurementFailureIndication* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_E_CIDMeasurementFailureIndication_protocolIEs ("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementReport_protocolIEs_element (
   const char* name, lppa_E_CIDMeasurementReport_protocolIEs_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_E_CIDMeasurementReport_IEs_1 */
      case T8lppa___lppa_E_CIDMeasurementReport_IEs_1:
      {
         if (asn1PrtToStr_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementReport_IEs_2 */
      case T8lppa___lppa_E_CIDMeasurementReport_IEs_2:
      {
         if (asn1PrtToStr_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_2, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementReport_IEs_3 */
      case T8lppa___lppa_E_CIDMeasurementReport_IEs_3:
      {
         if (asn1PrtToStr_lppa_E_CID_MeasurementResult ("E-CID-MeasurementResult", (lppa_E_CID_MeasurementResult*)pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_3, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementReport_IEs_4 */
      case T8lppa___lppa_E_CIDMeasurementReport_IEs_4:
      {
         if (asn1PrtToStr_lppa_Cell_Portion_ID ("Cell-Portion-ID", &pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_4, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementReport_protocolIEs (const char* name, 
   lppa_E_CIDMeasurementReport_protocolIEs* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   lppa_E_CIDMeasurementReport_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementReport_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_E_CIDMeasurementReport_protocolIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementReport (const char* name, 
   lppa_E_CIDMeasurementReport* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_E_CIDMeasurementReport_protocolIEs ("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element (
   const char* name, 
   lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_E_CIDMeasurementTerminationCommand_IEs_1 */
      case T9lppa___lppa_E_CIDMeasurementTerminationCommand_IEs_1:
      {
         if (asn1PrtToStr_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementTerminationCommand_IEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementTerminationCommand_IEs_2 */
      case T9lppa___lppa_E_CIDMeasurementTerminationCommand_IEs_2:
      {
         if (asn1PrtToStr_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementTerminationCommand_IEs_2, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementTerminationCommand_protocolIEs (
   const char* name, 
   lppa_E_CIDMeasurementTerminationCommand_protocolIEs* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementTerminationCommand (const char* name, 
   lppa_E_CIDMeasurementTerminationCommand* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_E_CIDMeasurementTerminationCommand_protocolIEs ("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_ErrorIndication_protocolIEs_element (const char* name, 
   lppa_ErrorIndication_protocolIEs_element* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_ErrorIndication_IEs_1 */
      case T19lppa___lppa_ErrorIndication_IEs_1:
      {
         if (asn1PrtToStr_lppa_Cause ("Cause", (lppa_Cause*)pvalue->value.u._lppa_ErrorIndication_IEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_ErrorIndication_IEs_2 */
      case T19lppa___lppa_ErrorIndication_IEs_2:
      {
         if (asn1PrtToStr_lppa_CriticalityDiagnostics ("CriticalityDiagnostics", (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_ErrorIndication_IEs_2, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_ErrorIndication_protocolIEs (const char* name, 
   lppa_ErrorIndication_protocolIEs* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_ErrorIndication_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ErrorIndication_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_ErrorIndication_protocolIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_ErrorIndication (const char* name, 
   lppa_ErrorIndication* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ErrorIndication_protocolIEs ("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_PrivateMessage_privateIEs_element (const char* name, 
   lppa_PrivateMessage_privateIEs_element* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_PrivateIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if(rtPrintToStringIndent (buffer, bufSize) < 0)
   {
      return -1;
   }
   if(rtPrintToStringHexStr ("value", pvalue->value.numocts, pvalue->value.data, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_PrivateMessage_privateIEs (const char* name, 
   lppa_PrivateMessage_privateIEs* pvalue, char* buffer, OSSIZE bufSize)
{
   lppa_PrivateMessage_privateIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_PrivateMessage_privateIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_PrivateMessage_privateIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_PrivateMessage (const char* name, 
   lppa_PrivateMessage* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_PrivateMessage_privateIEs ("privateIEs", &pvalue->privateIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_UTDOAInformationUpdate_protocolIEs_element (
   const char* name, lppa_UTDOAInformationUpdate_protocolIEs_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_UTDOAInformationUpdate_IEs_1 */
      case T18lppa___lppa_UTDOAInformationUpdate_IEs_1:
      {
         if (asn1PrtToStr_lppa_ULConfiguration ("ULConfiguration", pvalue->value.u._lppa_UTDOAInformationUpdate_IEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_UTDOAInformationUpdate_protocolIEs (const char* name, 
   lppa_UTDOAInformationUpdate_protocolIEs* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   lppa_UTDOAInformationUpdate_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_UTDOAInformationUpdate_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_UTDOAInformationUpdate_protocolIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_UTDOAInformationUpdate (const char* name, 
   lppa_UTDOAInformationUpdate* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_UTDOAInformationUpdate_protocolIEs ("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element (
   const char* name, 
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_1 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_1:
      {
         if (asn1PrtToStr_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_2 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_2:
      {
         if (asn1PrtToStr_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_2, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_3 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_3:
      {
         if (asn1PrtToStr_lppa_E_CID_MeasurementResult ("E-CID-MeasurementResult", (lppa_E_CID_MeasurementResult*)pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_3, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_4 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_4:
      {
         if (asn1PrtToStr_lppa_CriticalityDiagnostics ("CriticalityDiagnostics", (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_4, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_5 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_5:
      {
         if (asn1PrtToStr_lppa_Cell_Portion_ID ("Cell-Portion-ID", &pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_5, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_6 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_6:
      {
         if (asn1PrtToStr_lppa_InterRATMeasurementResult ("InterRATMeasurementResult", pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_6, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementInitiationResponse_protocolIEs (
   const char* name, 
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementInitiationResponse (const char* name, 
   lppa_E_CIDMeasurementInitiationResponse* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_E_CIDMeasurementInitiationResponse_protocolIEs ("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_OTDOAInformationResponse_protocolIEs_element (
   const char* name, 
   lppa_OTDOAInformationResponse_protocolIEs_element* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_OTDOAInformationResponse_IEs_1 */
      case T13lppa___lppa_OTDOAInformationResponse_IEs_1:
      {
         if (asn1PrtToStr_lppa_OTDOACells ("OTDOACells", pvalue->value.u._lppa_OTDOAInformationResponse_IEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_OTDOAInformationResponse_IEs_2 */
      case T13lppa___lppa_OTDOAInformationResponse_IEs_2:
      {
         if (asn1PrtToStr_lppa_CriticalityDiagnostics ("CriticalityDiagnostics", (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_OTDOAInformationResponse_IEs_2, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_OTDOAInformationResponse_protocolIEs (const char* name, 
   lppa_OTDOAInformationResponse_protocolIEs* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   lppa_OTDOAInformationResponse_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOAInformationResponse_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_OTDOAInformationResponse_protocolIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_OTDOAInformationResponse (const char* name, 
   lppa_OTDOAInformationResponse* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_OTDOAInformationResponse_protocolIEs ("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_UTDOAInformationResponse_protocolIEs_element (
   const char* name, 
   lppa_UTDOAInformationResponse_protocolIEs_element* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_UTDOAInformationResponse_IEs_1 */
      case T16lppa___lppa_UTDOAInformationResponse_IEs_1:
      {
         if (asn1PrtToStr_lppa_ULConfiguration ("ULConfiguration", (lppa_ULConfiguration*)pvalue->value.u._lppa_UTDOAInformationResponse_IEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_UTDOAInformationResponse_IEs_2 */
      case T16lppa___lppa_UTDOAInformationResponse_IEs_2:
      {
         if (asn1PrtToStr_lppa_CriticalityDiagnostics ("CriticalityDiagnostics", (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_UTDOAInformationResponse_IEs_2, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_UTDOAInformationResponse_protocolIEs (const char* name, 
   lppa_UTDOAInformationResponse_protocolIEs* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   lppa_UTDOAInformationResponse_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_UTDOAInformationResponse_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_UTDOAInformationResponse_protocolIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_UTDOAInformationResponse (const char* name, 
   lppa_UTDOAInformationResponse* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_UTDOAInformationResponse_protocolIEs ("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element (
   const char* name, 
   lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_E_CIDMeasurementInitiationFailure_IEs_1 */
      case T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_1:
      {
         if (asn1PrtToStr_lppa_Measurement_ID ("Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationFailure_IEs_2 */
      case T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_2:
      {
         if (asn1PrtToStr_lppa_Cause ("Cause", (lppa_Cause*)pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_2, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationFailure_IEs_3 */
      case T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_3:
      {
         if (asn1PrtToStr_lppa_CriticalityDiagnostics ("CriticalityDiagnostics", (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_3, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementInitiationFailure_protocolIEs (
   const char* name, 
   lppa_E_CIDMeasurementInitiationFailure_protocolIEs* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_E_CIDMeasurementInitiationFailure (const char* name, 
   lppa_E_CIDMeasurementInitiationFailure* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_E_CIDMeasurementInitiationFailure_protocolIEs ("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_OTDOAInformationFailure_protocolIEs_element (
   const char* name, lppa_OTDOAInformationFailure_protocolIEs_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_OTDOAInformationFailure_IEs_1 */
      case T14lppa___lppa_OTDOAInformationFailure_IEs_1:
      {
         if (asn1PrtToStr_lppa_Cause ("Cause", (lppa_Cause*)pvalue->value.u._lppa_OTDOAInformationFailure_IEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_OTDOAInformationFailure_IEs_2 */
      case T14lppa___lppa_OTDOAInformationFailure_IEs_2:
      {
         if (asn1PrtToStr_lppa_CriticalityDiagnostics ("CriticalityDiagnostics", (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_OTDOAInformationFailure_IEs_2, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_OTDOAInformationFailure_protocolIEs (const char* name, 
   lppa_OTDOAInformationFailure_protocolIEs* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   lppa_OTDOAInformationFailure_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOAInformationFailure_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_OTDOAInformationFailure_protocolIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_OTDOAInformationFailure (const char* name, 
   lppa_OTDOAInformationFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_OTDOAInformationFailure_protocolIEs ("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_UTDOAInformationFailure_protocolIEs_element (
   const char* name, lppa_UTDOAInformationFailure_protocolIEs_element* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProtocolIE_ID ("id", &pvalue->id, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* _lppa_UTDOAInformationFailure_IEs_1 */
      case T17lppa___lppa_UTDOAInformationFailure_IEs_1:
      {
         if (asn1PrtToStr_lppa_Cause ("Cause", (lppa_Cause*)pvalue->value.u._lppa_UTDOAInformationFailure_IEs_1, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* _lppa_UTDOAInformationFailure_IEs_2 */
      case T17lppa___lppa_UTDOAInformationFailure_IEs_2:
      {
         if (asn1PrtToStr_lppa_CriticalityDiagnostics ("CriticalityDiagnostics", (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_UTDOAInformationFailure_IEs_2, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_UTDOAInformationFailure_protocolIEs (const char* name, 
   lppa_UTDOAInformationFailure_protocolIEs* pvalue, char* buffer, 
   OSSIZE bufSize)
{
   lppa_UTDOAInformationFailure_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_UTDOAInformationFailure_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      if (asn1PrtToStr_lppa_UTDOAInformationFailure_protocolIEs_element (namebuf, pdata0, buffer, bufSize) < 0)
      {
         return -1;
      }
      xx1++;
   }
   return 0;
}

int asn1PrtToStr_lppa_UTDOAInformationFailure (const char* name, 
   lppa_UTDOAInformationFailure* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_UTDOAInformationFailure_protocolIEs ("protocolIEs", &pvalue->protocolIEs, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenTypeExtBraceText("extElem1", &pvalue->extElem1, buffer, bufSize)  < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_1 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_1:
      {
         asn1PrtToStrm_lppa_Measurement_ID (pctxt, "Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_1);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_2 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_2:
      {
         asn1PrtToStrm_lppa_ReportCharacteristics (pctxt, "ReportCharacteristics", &pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_2);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_3 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_3:
      {
         asn1PrtToStrm_lppa_MeasurementPeriodicity (pctxt, "MeasurementPeriodicity", &pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_3);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_4 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_4:
      {
         asn1PrtToStrm_lppa_MeasurementQuantities (pctxt, "MeasurementQuantities", pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_4);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationRequest_IEs_5 */
      case T4lppa___lppa_E_CIDMeasurementInitiationRequest_IEs_5:
      {
         asn1PrtToStrm_lppa_InterRATMeasurementQuantities (pctxt, "InterRATMeasurementQuantities", pvalue->value.u._lppa_E_CIDMeasurementInitiationRequest_IEs_5);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementInitiationRequest_protocolIEs (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementInitiationRequest_protocolIEs* pvalue)
{
   lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_E_CIDMeasurementInitiationRequest_protocolIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementInitiationRequest (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementInitiationRequest* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_E_CIDMeasurementInitiationRequest_protocolIEs (pctxt, "protocolIEs", &pvalue->protocolIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_OTDOA_Information_Type_Item_iE_Extensions_element (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOA_Information_Type_Item_iE_Extensions_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "extensionValue",
      pvalue->extensionValue.numocts, pvalue->extensionValue.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_OTDOA_Information_Type_Item_iE_Extensions (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOA_Information_Type_Item_iE_Extensions* pvalue)
{
   lppa_OTDOA_Information_Type_Item_iE_Extensions_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOA_Information_Type_Item_iE_Extensions_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_OTDOA_Information_Type_Item_iE_Extensions_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_OTDOA_Information_Type_Item (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOA_Information_Type_Item* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_OTDOA_Information_Item (pctxt, "oTDOA_Information_Type_Item", &pvalue->oTDOA_Information_Type_Item);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1PrtToStrm_lppa_OTDOA_Information_Type_Item_iE_Extensions (pctxt, "iE_Extensions", &pvalue->iE_Extensions);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_OTDOA_Information_Type_element (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOA_Information_Type_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_OTDOA_Information_TypeIEs_1 */
      case T11lppa___lppa_OTDOA_Information_TypeIEs_1:
      {
         asn1PrtToStrm_lppa_OTDOA_Information_Type_Item (pctxt, "OTDOA-Information-Type-Item", pvalue->value.u._lppa_OTDOA_Information_TypeIEs_1);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_OTDOA_Information_Type (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOA_Information_Type* pvalue)
{
   lppa_OTDOA_Information_Type_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOA_Information_Type_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_OTDOA_Information_Type_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_OTDOAInformationRequest_protocolIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOAInformationRequest_protocolIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_OTDOAInformationRequest_IEs_1 */
      case T10lppa___lppa_OTDOAInformationRequest_IEs_1:
      {
         asn1PrtToStrm_lppa_OTDOA_Information_Type (pctxt, "OTDOA-Information-Type", pvalue->value.u._lppa_OTDOAInformationRequest_IEs_1);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_OTDOAInformationRequest_protocolIEs (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOAInformationRequest_protocolIEs* pvalue)
{
   lppa_OTDOAInformationRequest_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOAInformationRequest_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_OTDOAInformationRequest_protocolIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_OTDOAInformationRequest (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOAInformationRequest* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_OTDOAInformationRequest_protocolIEs (pctxt, "protocolIEs", &pvalue->protocolIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_UTDOAInformationRequest_protocolIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_UTDOAInformationRequest_protocolIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_UTDOAInformationRequest_IEs_1 */
      case T15lppa___lppa_UTDOAInformationRequest_IEs_1:
      {
         asn1PrtToStrm_lppa_RequestedSRSTransmissionCharacteristics (pctxt, "RequestedSRSTransmissionCharacteristics", pvalue->value.u._lppa_UTDOAInformationRequest_IEs_1);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_UTDOAInformationRequest_protocolIEs (OSCTXT *pctxt, 
   const char* name, const lppa_UTDOAInformationRequest_protocolIEs* pvalue)
{
   lppa_UTDOAInformationRequest_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_UTDOAInformationRequest_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_UTDOAInformationRequest_protocolIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_UTDOAInformationRequest (OSCTXT *pctxt, 
   const char* name, const lppa_UTDOAInformationRequest* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_UTDOAInformationRequest_protocolIEs (pctxt, "protocolIEs", &pvalue->protocolIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_E_CIDMeasurementFailureIndication_IEs_1 */
      case T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_1:
      {
         asn1PrtToStrm_lppa_Measurement_ID (pctxt, "Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_1);
         break;
      }
      /* _lppa_E_CIDMeasurementFailureIndication_IEs_2 */
      case T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_2:
      {
         asn1PrtToStrm_lppa_Measurement_ID (pctxt, "Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_2);
         break;
      }
      /* _lppa_E_CIDMeasurementFailureIndication_IEs_3 */
      case T7lppa___lppa_E_CIDMeasurementFailureIndication_IEs_3:
      {
         asn1PrtToStrm_lppa_Cause (pctxt, "Cause", (lppa_Cause*)pvalue->value.u._lppa_E_CIDMeasurementFailureIndication_IEs_3);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementFailureIndication_protocolIEs (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementFailureIndication_protocolIEs* pvalue)
{
   lppa_E_CIDMeasurementFailureIndication_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementFailureIndication_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_E_CIDMeasurementFailureIndication_protocolIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementFailureIndication (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementFailureIndication* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_E_CIDMeasurementFailureIndication_protocolIEs (pctxt, "protocolIEs", &pvalue->protocolIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementReport_protocolIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementReport_protocolIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_E_CIDMeasurementReport_IEs_1 */
      case T8lppa___lppa_E_CIDMeasurementReport_IEs_1:
      {
         asn1PrtToStrm_lppa_Measurement_ID (pctxt, "Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_1);
         break;
      }
      /* _lppa_E_CIDMeasurementReport_IEs_2 */
      case T8lppa___lppa_E_CIDMeasurementReport_IEs_2:
      {
         asn1PrtToStrm_lppa_Measurement_ID (pctxt, "Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_2);
         break;
      }
      /* _lppa_E_CIDMeasurementReport_IEs_3 */
      case T8lppa___lppa_E_CIDMeasurementReport_IEs_3:
      {
         asn1PrtToStrm_lppa_E_CID_MeasurementResult (pctxt, "E-CID-MeasurementResult", (lppa_E_CID_MeasurementResult*)pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_3);
         break;
      }
      /* _lppa_E_CIDMeasurementReport_IEs_4 */
      case T8lppa___lppa_E_CIDMeasurementReport_IEs_4:
      {
         asn1PrtToStrm_lppa_Cell_Portion_ID (pctxt, "Cell-Portion-ID", &pvalue->value.u._lppa_E_CIDMeasurementReport_IEs_4);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementReport_protocolIEs (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementReport_protocolIEs* pvalue)
{
   lppa_E_CIDMeasurementReport_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementReport_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_E_CIDMeasurementReport_protocolIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementReport (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementReport* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_E_CIDMeasurementReport_protocolIEs (pctxt, "protocolIEs", &pvalue->protocolIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_E_CIDMeasurementTerminationCommand_IEs_1 */
      case T9lppa___lppa_E_CIDMeasurementTerminationCommand_IEs_1:
      {
         asn1PrtToStrm_lppa_Measurement_ID (pctxt, "Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementTerminationCommand_IEs_1);
         break;
      }
      /* _lppa_E_CIDMeasurementTerminationCommand_IEs_2 */
      case T9lppa___lppa_E_CIDMeasurementTerminationCommand_IEs_2:
      {
         asn1PrtToStrm_lppa_Measurement_ID (pctxt, "Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementTerminationCommand_IEs_2);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementTerminationCommand_protocolIEs (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementTerminationCommand_protocolIEs* pvalue)
{
   lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_E_CIDMeasurementTerminationCommand_protocolIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementTerminationCommand (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementTerminationCommand* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_E_CIDMeasurementTerminationCommand_protocolIEs (pctxt, "protocolIEs", &pvalue->protocolIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_ErrorIndication_protocolIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_ErrorIndication_protocolIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_ErrorIndication_IEs_1 */
      case T19lppa___lppa_ErrorIndication_IEs_1:
      {
         asn1PrtToStrm_lppa_Cause (pctxt, "Cause", (lppa_Cause*)pvalue->value.u._lppa_ErrorIndication_IEs_1);
         break;
      }
      /* _lppa_ErrorIndication_IEs_2 */
      case T19lppa___lppa_ErrorIndication_IEs_2:
      {
         asn1PrtToStrm_lppa_CriticalityDiagnostics (pctxt, "CriticalityDiagnostics", (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_ErrorIndication_IEs_2);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_ErrorIndication_protocolIEs (OSCTXT *pctxt, 
   const char* name, const lppa_ErrorIndication_protocolIEs* pvalue)
{
   lppa_ErrorIndication_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_ErrorIndication_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_ErrorIndication_protocolIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_ErrorIndication (OSCTXT *pctxt, 
   const char* name, const lppa_ErrorIndication* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ErrorIndication_protocolIEs (pctxt, "protocolIEs", &pvalue->protocolIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_PrivateMessage_privateIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_PrivateMessage_privateIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_PrivateIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "value",
      pvalue->value.numocts, pvalue->value.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_PrivateMessage_privateIEs (OSCTXT *pctxt, 
   const char* name, const lppa_PrivateMessage_privateIEs* pvalue)
{
   lppa_PrivateMessage_privateIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_PrivateMessage_privateIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_PrivateMessage_privateIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_PrivateMessage (OSCTXT *pctxt, 
   const char* name, const lppa_PrivateMessage* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_PrivateMessage_privateIEs (pctxt, "privateIEs", &pvalue->privateIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_UTDOAInformationUpdate_protocolIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_UTDOAInformationUpdate_protocolIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_UTDOAInformationUpdate_IEs_1 */
      case T18lppa___lppa_UTDOAInformationUpdate_IEs_1:
      {
         asn1PrtToStrm_lppa_ULConfiguration (pctxt, "ULConfiguration", pvalue->value.u._lppa_UTDOAInformationUpdate_IEs_1);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_UTDOAInformationUpdate_protocolIEs (OSCTXT *pctxt, 
   const char* name, const lppa_UTDOAInformationUpdate_protocolIEs* pvalue)
{
   lppa_UTDOAInformationUpdate_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_UTDOAInformationUpdate_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_UTDOAInformationUpdate_protocolIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_UTDOAInformationUpdate (OSCTXT *pctxt, 
   const char* name, const lppa_UTDOAInformationUpdate* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_UTDOAInformationUpdate_protocolIEs (pctxt, "protocolIEs", &pvalue->protocolIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_1 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_1:
      {
         asn1PrtToStrm_lppa_Measurement_ID (pctxt, "Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_1);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_2 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_2:
      {
         asn1PrtToStrm_lppa_Measurement_ID (pctxt, "Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_2);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_3 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_3:
      {
         asn1PrtToStrm_lppa_E_CID_MeasurementResult (pctxt, "E-CID-MeasurementResult", (lppa_E_CID_MeasurementResult*)pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_3);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_4 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_4:
      {
         asn1PrtToStrm_lppa_CriticalityDiagnostics (pctxt, "CriticalityDiagnostics", (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_4);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_5 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_5:
      {
         asn1PrtToStrm_lppa_Cell_Portion_ID (pctxt, "Cell-Portion-ID", &pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_5);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationResponse_IEs_6 */
      case T5lppa___lppa_E_CIDMeasurementInitiationResponse_IEs_6:
      {
         asn1PrtToStrm_lppa_InterRATMeasurementResult (pctxt, "InterRATMeasurementResult", pvalue->value.u._lppa_E_CIDMeasurementInitiationResponse_IEs_6);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementInitiationResponse_protocolIEs (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementInitiationResponse_protocolIEs* pvalue)
{
   lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_E_CIDMeasurementInitiationResponse_protocolIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementInitiationResponse (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementInitiationResponse* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_E_CIDMeasurementInitiationResponse_protocolIEs (pctxt, "protocolIEs", &pvalue->protocolIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_OTDOAInformationResponse_protocolIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOAInformationResponse_protocolIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_OTDOAInformationResponse_IEs_1 */
      case T13lppa___lppa_OTDOAInformationResponse_IEs_1:
      {
         asn1PrtToStrm_lppa_OTDOACells (pctxt, "OTDOACells", pvalue->value.u._lppa_OTDOAInformationResponse_IEs_1);
         break;
      }
      /* _lppa_OTDOAInformationResponse_IEs_2 */
      case T13lppa___lppa_OTDOAInformationResponse_IEs_2:
      {
         asn1PrtToStrm_lppa_CriticalityDiagnostics (pctxt, "CriticalityDiagnostics", (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_OTDOAInformationResponse_IEs_2);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_OTDOAInformationResponse_protocolIEs (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOAInformationResponse_protocolIEs* pvalue)
{
   lppa_OTDOAInformationResponse_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOAInformationResponse_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_OTDOAInformationResponse_protocolIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_OTDOAInformationResponse (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOAInformationResponse* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_OTDOAInformationResponse_protocolIEs (pctxt, "protocolIEs", &pvalue->protocolIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_UTDOAInformationResponse_protocolIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_UTDOAInformationResponse_protocolIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_UTDOAInformationResponse_IEs_1 */
      case T16lppa___lppa_UTDOAInformationResponse_IEs_1:
      {
         asn1PrtToStrm_lppa_ULConfiguration (pctxt, "ULConfiguration", (lppa_ULConfiguration*)pvalue->value.u._lppa_UTDOAInformationResponse_IEs_1);
         break;
      }
      /* _lppa_UTDOAInformationResponse_IEs_2 */
      case T16lppa___lppa_UTDOAInformationResponse_IEs_2:
      {
         asn1PrtToStrm_lppa_CriticalityDiagnostics (pctxt, "CriticalityDiagnostics", (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_UTDOAInformationResponse_IEs_2);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_UTDOAInformationResponse_protocolIEs (OSCTXT *pctxt, 
   const char* name, const lppa_UTDOAInformationResponse_protocolIEs* pvalue)
{
   lppa_UTDOAInformationResponse_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_UTDOAInformationResponse_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_UTDOAInformationResponse_protocolIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_UTDOAInformationResponse (OSCTXT *pctxt, 
   const char* name, const lppa_UTDOAInformationResponse* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_UTDOAInformationResponse_protocolIEs (pctxt, "protocolIEs", &pvalue->protocolIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_E_CIDMeasurementInitiationFailure_IEs_1 */
      case T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_1:
      {
         asn1PrtToStrm_lppa_Measurement_ID (pctxt, "Measurement-ID", &pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_1);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationFailure_IEs_2 */
      case T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_2:
      {
         asn1PrtToStrm_lppa_Cause (pctxt, "Cause", (lppa_Cause*)pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_2);
         break;
      }
      /* _lppa_E_CIDMeasurementInitiationFailure_IEs_3 */
      case T6lppa___lppa_E_CIDMeasurementInitiationFailure_IEs_3:
      {
         asn1PrtToStrm_lppa_CriticalityDiagnostics (pctxt, "CriticalityDiagnostics", (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_E_CIDMeasurementInitiationFailure_IEs_3);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementInitiationFailure_protocolIEs (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementInitiationFailure_protocolIEs* pvalue)
{
   lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_E_CIDMeasurementInitiationFailure_protocolIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_E_CIDMeasurementInitiationFailure (OSCTXT *pctxt, 
   const char* name, const lppa_E_CIDMeasurementInitiationFailure* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_E_CIDMeasurementInitiationFailure_protocolIEs (pctxt, "protocolIEs", &pvalue->protocolIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_OTDOAInformationFailure_protocolIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOAInformationFailure_protocolIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_OTDOAInformationFailure_IEs_1 */
      case T14lppa___lppa_OTDOAInformationFailure_IEs_1:
      {
         asn1PrtToStrm_lppa_Cause (pctxt, "Cause", (lppa_Cause*)pvalue->value.u._lppa_OTDOAInformationFailure_IEs_1);
         break;
      }
      /* _lppa_OTDOAInformationFailure_IEs_2 */
      case T14lppa___lppa_OTDOAInformationFailure_IEs_2:
      {
         asn1PrtToStrm_lppa_CriticalityDiagnostics (pctxt, "CriticalityDiagnostics", (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_OTDOAInformationFailure_IEs_2);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_OTDOAInformationFailure_protocolIEs (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOAInformationFailure_protocolIEs* pvalue)
{
   lppa_OTDOAInformationFailure_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_OTDOAInformationFailure_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_OTDOAInformationFailure_protocolIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_OTDOAInformationFailure (OSCTXT *pctxt, 
   const char* name, const lppa_OTDOAInformationFailure* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_OTDOAInformationFailure_protocolIEs (pctxt, "protocolIEs", &pvalue->protocolIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_UTDOAInformationFailure_protocolIEs_element (OSCTXT *pctxt, 
   const char* name, const lppa_UTDOAInformationFailure_protocolIEs_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProtocolIE_ID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* _lppa_UTDOAInformationFailure_IEs_1 */
      case T17lppa___lppa_UTDOAInformationFailure_IEs_1:
      {
         asn1PrtToStrm_lppa_Cause (pctxt, "Cause", (lppa_Cause*)pvalue->value.u._lppa_UTDOAInformationFailure_IEs_1);
         break;
      }
      /* _lppa_UTDOAInformationFailure_IEs_2 */
      case T17lppa___lppa_UTDOAInformationFailure_IEs_2:
      {
         asn1PrtToStrm_lppa_CriticalityDiagnostics (pctxt, "CriticalityDiagnostics", (lppa_CriticalityDiagnostics*)pvalue->value.u._lppa_UTDOAInformationFailure_IEs_2);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_UTDOAInformationFailure_protocolIEs (OSCTXT *pctxt, 
   const char* name, const lppa_UTDOAInformationFailure_protocolIEs* pvalue)
{
   lppa_UTDOAInformationFailure_protocolIEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((lppa_UTDOAInformationFailure_protocolIEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_lppa_UTDOAInformationFailure_protocolIEs_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_lppa_UTDOAInformationFailure (OSCTXT *pctxt, 
   const char* name, const lppa_UTDOAInformationFailure* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_UTDOAInformationFailure_protocolIEs (pctxt, "protocolIEs", &pvalue->protocolIEs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

void asn1SetTC_lppa_InitiatingMessage_e_CIDMeasurementInitiation
   (OSCTXT* pctxt, lppa_InitiatingMessage* pElem, lppa_E_CIDMeasurementInitiationRequest *pvalue)
{
   pElem->procedureCode = 2;
   pElem->criticality = lppa_reject;
   pElem->value.t = T1lppa__e_CIDMeasurementInitiation;
   pElem->value.u.e_CIDMeasurementInitiation = pvalue;
}

void asn1SetTC_lppa_InitiatingMessage_oTDOAInformationExchange
   (OSCTXT* pctxt, lppa_InitiatingMessage* pElem, lppa_OTDOAInformationRequest *pvalue)
{
   pElem->procedureCode = 6;
   pElem->criticality = lppa_reject;
   pElem->value.t = T1lppa__oTDOAInformationExchange;
   pElem->value.u.oTDOAInformationExchange = pvalue;
}

void asn1SetTC_lppa_InitiatingMessage_uTDOAInformationExchange
   (OSCTXT* pctxt, lppa_InitiatingMessage* pElem, lppa_UTDOAInformationRequest *pvalue)
{
   pElem->procedureCode = 7;
   pElem->criticality = lppa_reject;
   pElem->value.t = T1lppa__uTDOAInformationExchange;
   pElem->value.u.uTDOAInformationExchange = pvalue;
}

void asn1SetTC_lppa_InitiatingMessage_e_CIDMeasurementFailureIndication
   (OSCTXT* pctxt, lppa_InitiatingMessage* pElem, lppa_E_CIDMeasurementFailureIndication *pvalue)
{
   pElem->procedureCode = 3;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T1lppa__e_CIDMeasurementFailureIndication;
   pElem->value.u.e_CIDMeasurementFailureIndication = pvalue;
}

void asn1SetTC_lppa_InitiatingMessage_e_CIDMeasurementReport
   (OSCTXT* pctxt, lppa_InitiatingMessage* pElem, lppa_E_CIDMeasurementReport *pvalue)
{
   pElem->procedureCode = 4;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T1lppa__e_CIDMeasurementReport;
   pElem->value.u.e_CIDMeasurementReport = pvalue;
}

void asn1SetTC_lppa_InitiatingMessage_e_CIDMeasurementTermination
   (OSCTXT* pctxt, lppa_InitiatingMessage* pElem, lppa_E_CIDMeasurementTerminationCommand *pvalue)
{
   pElem->procedureCode = 5;
   pElem->criticality = lppa_reject;
   pElem->value.t = T1lppa__e_CIDMeasurementTermination;
   pElem->value.u.e_CIDMeasurementTermination = pvalue;
}

void asn1SetTC_lppa_InitiatingMessage_errorIndication
   (OSCTXT* pctxt, lppa_InitiatingMessage* pElem, lppa_ErrorIndication *pvalue)
{
   pElem->procedureCode = 0;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T1lppa__errorIndication;
   pElem->value.u.errorIndication = pvalue;
}

void asn1SetTC_lppa_InitiatingMessage_privateMessage
   (OSCTXT* pctxt, lppa_InitiatingMessage* pElem, lppa_PrivateMessage *pvalue)
{
   pElem->procedureCode = 1;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T1lppa__privateMessage;
   pElem->value.u.privateMessage = pvalue;
}

void asn1SetTC_lppa_InitiatingMessage_uTDOAInformationUpdate
   (OSCTXT* pctxt, lppa_InitiatingMessage* pElem, lppa_UTDOAInformationUpdate *pvalue)
{
   pElem->procedureCode = 8;
   pElem->criticality = lppa_ignore;
   pElem->value.t = T1lppa__uTDOAInformationUpdate;
   pElem->value.u.uTDOAInformationUpdate = pvalue;
}

EXTERN int asn1PE_lppa_InitiatingMessage (OSCTXT* pctxt, lppa_InitiatingMessage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InitiatingMessage");

   /* encode procedureCode */

   RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

   stat = asn1PE_lppa_ProcedureCode (pctxt, pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode lppatransactionID */

   RTXCTXTPUSHELEMNAME (pctxt, "lppatransactionID");

   stat = asn1PE_lppa_LPPATransactionID (pctxt, pvalue->lppatransactionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* e_CIDMeasurementInitiation */
   case T1lppa__e_CIDMeasurementInitiation:
      RTXCTXTPUSHELEMNAME (pctxt, "e_CIDMeasurementInitiation");

      stat = asn1PE_lppa_E_CIDMeasurementInitiationRequest (pctxt, pvalue->value.u.e_CIDMeasurementInitiation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* oTDOAInformationExchange */
   case T1lppa__oTDOAInformationExchange:
      RTXCTXTPUSHELEMNAME (pctxt, "oTDOAInformationExchange");

      stat = asn1PE_lppa_OTDOAInformationRequest (pctxt, pvalue->value.u.oTDOAInformationExchange);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* uTDOAInformationExchange */
   case T1lppa__uTDOAInformationExchange:
      RTXCTXTPUSHELEMNAME (pctxt, "uTDOAInformationExchange");

      stat = asn1PE_lppa_UTDOAInformationRequest (pctxt, pvalue->value.u.uTDOAInformationExchange);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* e_CIDMeasurementFailureIndication */
   case T1lppa__e_CIDMeasurementFailureIndication:
      RTXCTXTPUSHELEMNAME (pctxt, "e_CIDMeasurementFailureIndication");

      stat = asn1PE_lppa_E_CIDMeasurementFailureIndication (pctxt, pvalue->value.u.e_CIDMeasurementFailureIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* e_CIDMeasurementReport */
   case T1lppa__e_CIDMeasurementReport:
      RTXCTXTPUSHELEMNAME (pctxt, "e_CIDMeasurementReport");

      stat = asn1PE_lppa_E_CIDMeasurementReport (pctxt, pvalue->value.u.e_CIDMeasurementReport);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* e_CIDMeasurementTermination */
   case T1lppa__e_CIDMeasurementTermination:
      RTXCTXTPUSHELEMNAME (pctxt, "e_CIDMeasurementTermination");

      stat = asn1PE_lppa_E_CIDMeasurementTerminationCommand (pctxt, pvalue->value.u.e_CIDMeasurementTermination);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* errorIndication */
   case T1lppa__errorIndication:
      RTXCTXTPUSHELEMNAME (pctxt, "errorIndication");

      stat = asn1PE_lppa_ErrorIndication (pctxt, pvalue->value.u.errorIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* privateMessage */
   case T1lppa__privateMessage:
      RTXCTXTPUSHELEMNAME (pctxt, "privateMessage");

      stat = asn1PE_lppa_PrivateMessage (pctxt, pvalue->value.u.privateMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* uTDOAInformationUpdate */
   case T1lppa__uTDOAInformationUpdate:
      RTXCTXTPUSHELEMNAME (pctxt, "uTDOAInformationUpdate");

      stat = asn1PE_lppa_UTDOAInformationUpdate (pctxt, pvalue->value.u.uTDOAInformationUpdate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T1lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_InitiatingMessage (OSCTXT* pctxt, lppa_InitiatingMessage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InitiatingMessage");

   /* decode root elements */
   /* decode procedureCode */
   RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

   stat = asn1PD_lppa_ProcedureCode (pctxt, &pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode lppatransactionID */
   RTXCTXTPUSHELEMNAME (pctxt, "lppatransactionID");

   stat = asn1PD_lppa_LPPATransactionID (pctxt, &pvalue->lppatransactionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->procedureCode) {
   case ASN1V_lppa_id_e_CIDMeasurementInitiation:
      pvalue->value.t = T1lppa__e_CIDMeasurementInitiation;

      pvalue->value.u.e_CIDMeasurementInitiation = rtxMemAllocType (pctxt, 
         lppa_E_CIDMeasurementInitiationRequest);

      if (pvalue->value.u.e_CIDMeasurementInitiation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_E_CIDMeasurementInitiationRequest (pvalue->value.
         u.e_CIDMeasurementInitiation);

      stat = asn1PD_lppa_E_CIDMeasurementInitiationRequest (pctxt, pvalue->
         value.u.e_CIDMeasurementInitiation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_oTDOAInformationExchange:
      pvalue->value.t = T1lppa__oTDOAInformationExchange;

      pvalue->value.u.oTDOAInformationExchange = rtxMemAllocType (pctxt, 
         lppa_OTDOAInformationRequest);

      if (pvalue->value.u.oTDOAInformationExchange == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_OTDOAInformationRequest (pvalue->value.
         u.oTDOAInformationExchange);

      stat = asn1PD_lppa_OTDOAInformationRequest (pctxt, pvalue->value.
         u.oTDOAInformationExchange);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_uTDOAInformationExchange:
      pvalue->value.t = T1lppa__uTDOAInformationExchange;

      pvalue->value.u.uTDOAInformationExchange = rtxMemAllocType (pctxt, 
         lppa_UTDOAInformationRequest);

      if (pvalue->value.u.uTDOAInformationExchange == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_UTDOAInformationRequest (pvalue->value.
         u.uTDOAInformationExchange);

      stat = asn1PD_lppa_UTDOAInformationRequest (pctxt, pvalue->value.
         u.uTDOAInformationExchange);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_e_CIDMeasurementFailureIndication:
      pvalue->value.t = T1lppa__e_CIDMeasurementFailureIndication;

      pvalue->value.u.e_CIDMeasurementFailureIndication
          = rtxMemAllocType (pctxt, lppa_E_CIDMeasurementFailureIndication);

      if (pvalue->value.u.e_CIDMeasurementFailureIndication == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_E_CIDMeasurementFailureIndication (pvalue->value.
         u.e_CIDMeasurementFailureIndication);

      stat = asn1PD_lppa_E_CIDMeasurementFailureIndication (pctxt, pvalue->
         value.u.e_CIDMeasurementFailureIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_e_CIDMeasurementReport:
      pvalue->value.t = T1lppa__e_CIDMeasurementReport;

      pvalue->value.u.e_CIDMeasurementReport = rtxMemAllocType (pctxt, 
         lppa_E_CIDMeasurementReport);

      if (pvalue->value.u.e_CIDMeasurementReport == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_E_CIDMeasurementReport (pvalue->value.
         u.e_CIDMeasurementReport);

      stat = asn1PD_lppa_E_CIDMeasurementReport (pctxt, pvalue->value.
         u.e_CIDMeasurementReport);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_e_CIDMeasurementTermination:
      pvalue->value.t = T1lppa__e_CIDMeasurementTermination;

      pvalue->value.u.e_CIDMeasurementTermination = rtxMemAllocType (pctxt, 
         lppa_E_CIDMeasurementTerminationCommand);

      if (pvalue->value.u.e_CIDMeasurementTermination == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_E_CIDMeasurementTerminationCommand (pvalue->value.
         u.e_CIDMeasurementTermination);

      stat = asn1PD_lppa_E_CIDMeasurementTerminationCommand (pctxt, pvalue->
         value.u.e_CIDMeasurementTermination);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_errorIndication:
      pvalue->value.t = T1lppa__errorIndication;

      pvalue->value.u.errorIndication = rtxMemAllocType (pctxt, 
         lppa_ErrorIndication);

      if (pvalue->value.u.errorIndication == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_ErrorIndication (pvalue->value.u.errorIndication);

      stat = asn1PD_lppa_ErrorIndication (pctxt, pvalue->value.
         u.errorIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_privateMessage:
      pvalue->value.t = T1lppa__privateMessage;

      pvalue->value.u.privateMessage = rtxMemAllocType (pctxt, 
         lppa_PrivateMessage);

      if (pvalue->value.u.privateMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_PrivateMessage (pvalue->value.u.privateMessage);

      stat = asn1PD_lppa_PrivateMessage (pctxt, pvalue->value.u.privateMessage
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_uTDOAInformationUpdate:
      pvalue->value.t = T1lppa__uTDOAInformationUpdate;

      pvalue->value.u.uTDOAInformationUpdate = rtxMemAllocType (pctxt, 
         lppa_UTDOAInformationUpdate);

      if (pvalue->value.u.uTDOAInformationUpdate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_UTDOAInformationUpdate (pvalue->value.
         u.uTDOAInformationUpdate);

      stat = asn1PD_lppa_UTDOAInformationUpdate (pctxt, pvalue->value.
         u.uTDOAInformationUpdate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T1lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_InitiatingMessage (lppa_InitiatingMessage* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_InitiatingMessage (OSCTXT *pctxt, 
   lppa_InitiatingMessage* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T1lppa__e_CIDMeasurementInitiation:
         if (0 != pvalue->value.u.e_CIDMeasurementInitiation) {
            asn1Free_lppa_E_CIDMeasurementInitiationRequest (pctxt, pvalue->value.u.e_CIDMeasurementInitiation);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.e_CIDMeasurementInitiation);
         }
         break;

      case T1lppa__oTDOAInformationExchange:
         if (0 != pvalue->value.u.oTDOAInformationExchange) {
            asn1Free_lppa_OTDOAInformationRequest (pctxt, pvalue->value.u.oTDOAInformationExchange);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.oTDOAInformationExchange);
         }
         break;

      case T1lppa__uTDOAInformationExchange:
         if (0 != pvalue->value.u.uTDOAInformationExchange) {
            asn1Free_lppa_UTDOAInformationRequest (pctxt, pvalue->value.u.uTDOAInformationExchange);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.uTDOAInformationExchange);
         }
         break;

      case T1lppa__e_CIDMeasurementFailureIndication:
         if (0 != pvalue->value.u.e_CIDMeasurementFailureIndication) {
            asn1Free_lppa_E_CIDMeasurementFailureIndication (pctxt, pvalue->value.u.e_CIDMeasurementFailureIndication);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.e_CIDMeasurementFailureIndication);
         }
         break;

      case T1lppa__e_CIDMeasurementReport:
         if (0 != pvalue->value.u.e_CIDMeasurementReport) {
            asn1Free_lppa_E_CIDMeasurementReport (pctxt, pvalue->value.u.e_CIDMeasurementReport);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.e_CIDMeasurementReport);
         }
         break;

      case T1lppa__e_CIDMeasurementTermination:
         if (0 != pvalue->value.u.e_CIDMeasurementTermination) {
            asn1Free_lppa_E_CIDMeasurementTerminationCommand (pctxt, pvalue->value.u.e_CIDMeasurementTermination);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.e_CIDMeasurementTermination);
         }
         break;

      case T1lppa__errorIndication:
         if (0 != pvalue->value.u.errorIndication) {
            asn1Free_lppa_ErrorIndication (pctxt, pvalue->value.u.errorIndication);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.errorIndication);
         }
         break;

      case T1lppa__privateMessage:
         if (0 != pvalue->value.u.privateMessage) {
            asn1Free_lppa_PrivateMessage (pctxt, pvalue->value.u.privateMessage);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.privateMessage);
         }
         break;

      case T1lppa__uTDOAInformationUpdate:
         if (0 != pvalue->value.u.uTDOAInformationUpdate) {
            asn1Free_lppa_UTDOAInformationUpdate (pctxt, pvalue->value.u.uTDOAInformationUpdate);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.uTDOAInformationUpdate);
         }
         break;

      default:;
   }
}

void asn1SetTC_lppa_SuccessfulOutcome_e_CIDMeasurementInitiation
   (OSCTXT* pctxt, lppa_SuccessfulOutcome* pElem, lppa_E_CIDMeasurementInitiationResponse *pvalue)
{
   pElem->procedureCode = 2;
   pElem->criticality = lppa_reject;
   pElem->value.t = T1lppa__e_CIDMeasurementInitiation;
   pElem->value.u.e_CIDMeasurementInitiation = pvalue;
}

void asn1SetTC_lppa_SuccessfulOutcome_oTDOAInformationExchange
   (OSCTXT* pctxt, lppa_SuccessfulOutcome* pElem, lppa_OTDOAInformationResponse *pvalue)
{
   pElem->procedureCode = 6;
   pElem->criticality = lppa_reject;
   pElem->value.t = T1lppa__oTDOAInformationExchange;
   pElem->value.u.oTDOAInformationExchange = pvalue;
}

void asn1SetTC_lppa_SuccessfulOutcome_uTDOAInformationExchange
   (OSCTXT* pctxt, lppa_SuccessfulOutcome* pElem, lppa_UTDOAInformationResponse *pvalue)
{
   pElem->procedureCode = 7;
   pElem->criticality = lppa_reject;
   pElem->value.t = T1lppa__uTDOAInformationExchange;
   pElem->value.u.uTDOAInformationExchange = pvalue;
}

EXTERN int asn1PE_lppa_SuccessfulOutcome (OSCTXT* pctxt, lppa_SuccessfulOutcome* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SuccessfulOutcome");

   /* encode procedureCode */

   RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

   stat = asn1PE_lppa_ProcedureCode (pctxt, pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode lppatransactionID */

   RTXCTXTPUSHELEMNAME (pctxt, "lppatransactionID");

   stat = asn1PE_lppa_LPPATransactionID (pctxt, pvalue->lppatransactionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* e_CIDMeasurementInitiation */
   case T1lppa__e_CIDMeasurementInitiation:
      RTXCTXTPUSHELEMNAME (pctxt, "e_CIDMeasurementInitiation");

      stat = asn1PE_lppa_E_CIDMeasurementInitiationResponse (pctxt, pvalue->value.u.e_CIDMeasurementInitiation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* oTDOAInformationExchange */
   case T1lppa__oTDOAInformationExchange:
      RTXCTXTPUSHELEMNAME (pctxt, "oTDOAInformationExchange");

      stat = asn1PE_lppa_OTDOAInformationResponse (pctxt, pvalue->value.u.oTDOAInformationExchange);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* uTDOAInformationExchange */
   case T1lppa__uTDOAInformationExchange:
      RTXCTXTPUSHELEMNAME (pctxt, "uTDOAInformationExchange");

      stat = asn1PE_lppa_UTDOAInformationResponse (pctxt, pvalue->value.u.uTDOAInformationExchange);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T1lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_SuccessfulOutcome (OSCTXT* pctxt, lppa_SuccessfulOutcome* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SuccessfulOutcome");

   /* decode root elements */
   /* decode procedureCode */
   RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

   stat = asn1PD_lppa_ProcedureCode (pctxt, &pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode lppatransactionID */
   RTXCTXTPUSHELEMNAME (pctxt, "lppatransactionID");

   stat = asn1PD_lppa_LPPATransactionID (pctxt, &pvalue->lppatransactionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->procedureCode) {
   case ASN1V_lppa_id_e_CIDMeasurementInitiation:
      pvalue->value.t = T1lppa__e_CIDMeasurementInitiation;

      pvalue->value.u.e_CIDMeasurementInitiation = rtxMemAllocType (pctxt, 
         lppa_E_CIDMeasurementInitiationResponse);

      if (pvalue->value.u.e_CIDMeasurementInitiation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_E_CIDMeasurementInitiationResponse (pvalue->value.
         u.e_CIDMeasurementInitiation);

      stat = asn1PD_lppa_E_CIDMeasurementInitiationResponse (pctxt, pvalue->
         value.u.e_CIDMeasurementInitiation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_oTDOAInformationExchange:
      pvalue->value.t = T1lppa__oTDOAInformationExchange;

      pvalue->value.u.oTDOAInformationExchange = rtxMemAllocType (pctxt, 
         lppa_OTDOAInformationResponse);

      if (pvalue->value.u.oTDOAInformationExchange == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_OTDOAInformationResponse (pvalue->value.
         u.oTDOAInformationExchange);

      stat = asn1PD_lppa_OTDOAInformationResponse (pctxt, pvalue->value.
         u.oTDOAInformationExchange);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_uTDOAInformationExchange:
      pvalue->value.t = T1lppa__uTDOAInformationExchange;

      pvalue->value.u.uTDOAInformationExchange = rtxMemAllocType (pctxt, 
         lppa_UTDOAInformationResponse);

      if (pvalue->value.u.uTDOAInformationExchange == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_UTDOAInformationResponse (pvalue->value.
         u.uTDOAInformationExchange);

      stat = asn1PD_lppa_UTDOAInformationResponse (pctxt, pvalue->value.
         u.uTDOAInformationExchange);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T1lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_SuccessfulOutcome (lppa_SuccessfulOutcome* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_SuccessfulOutcome (OSCTXT *pctxt, 
   lppa_SuccessfulOutcome* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T1lppa__e_CIDMeasurementInitiation:
         if (0 != pvalue->value.u.e_CIDMeasurementInitiation) {
            asn1Free_lppa_E_CIDMeasurementInitiationResponse (pctxt, pvalue->value.u.e_CIDMeasurementInitiation);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.e_CIDMeasurementInitiation);
         }
         break;

      case T1lppa__oTDOAInformationExchange:
         if (0 != pvalue->value.u.oTDOAInformationExchange) {
            asn1Free_lppa_OTDOAInformationResponse (pctxt, pvalue->value.u.oTDOAInformationExchange);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.oTDOAInformationExchange);
         }
         break;

      case T1lppa__uTDOAInformationExchange:
         if (0 != pvalue->value.u.uTDOAInformationExchange) {
            asn1Free_lppa_UTDOAInformationResponse (pctxt, pvalue->value.u.uTDOAInformationExchange);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.uTDOAInformationExchange);
         }
         break;

      default:;
   }
}

void asn1SetTC_lppa_UnsuccessfulOutcome_e_CIDMeasurementInitiation
   (OSCTXT* pctxt, lppa_UnsuccessfulOutcome* pElem, lppa_E_CIDMeasurementInitiationFailure *pvalue)
{
   pElem->procedureCode = 2;
   pElem->criticality = lppa_reject;
   pElem->value.t = T1lppa__e_CIDMeasurementInitiation;
   pElem->value.u.e_CIDMeasurementInitiation = pvalue;
}

void asn1SetTC_lppa_UnsuccessfulOutcome_oTDOAInformationExchange
   (OSCTXT* pctxt, lppa_UnsuccessfulOutcome* pElem, lppa_OTDOAInformationFailure *pvalue)
{
   pElem->procedureCode = 6;
   pElem->criticality = lppa_reject;
   pElem->value.t = T1lppa__oTDOAInformationExchange;
   pElem->value.u.oTDOAInformationExchange = pvalue;
}

void asn1SetTC_lppa_UnsuccessfulOutcome_uTDOAInformationExchange
   (OSCTXT* pctxt, lppa_UnsuccessfulOutcome* pElem, lppa_UTDOAInformationFailure *pvalue)
{
   pElem->procedureCode = 7;
   pElem->criticality = lppa_reject;
   pElem->value.t = T1lppa__uTDOAInformationExchange;
   pElem->value.u.uTDOAInformationExchange = pvalue;
}

EXTERN int asn1PE_lppa_UnsuccessfulOutcome (OSCTXT* pctxt, lppa_UnsuccessfulOutcome* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UnsuccessfulOutcome");

   /* encode procedureCode */

   RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

   stat = asn1PE_lppa_ProcedureCode (pctxt, pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_lppa_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode lppatransactionID */

   RTXCTXTPUSHELEMNAME (pctxt, "lppatransactionID");

   stat = asn1PE_lppa_LPPATransactionID (pctxt, pvalue->lppatransactionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* e_CIDMeasurementInitiation */
   case T1lppa__e_CIDMeasurementInitiation:
      RTXCTXTPUSHELEMNAME (pctxt, "e_CIDMeasurementInitiation");

      stat = asn1PE_lppa_E_CIDMeasurementInitiationFailure (pctxt, pvalue->value.u.e_CIDMeasurementInitiation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* oTDOAInformationExchange */
   case T1lppa__oTDOAInformationExchange:
      RTXCTXTPUSHELEMNAME (pctxt, "oTDOAInformationExchange");

      stat = asn1PE_lppa_OTDOAInformationFailure (pctxt, pvalue->value.u.oTDOAInformationExchange);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* uTDOAInformationExchange */
   case T1lppa__uTDOAInformationExchange:
      RTXCTXTPUSHELEMNAME (pctxt, "uTDOAInformationExchange");

      stat = asn1PE_lppa_UTDOAInformationFailure (pctxt, pvalue->value.u.uTDOAInformationExchange);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T1lppa__UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      stat = pe_OpenType (pctxt, openType.numocts, openType.data);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, openType.data);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_UnsuccessfulOutcome (OSCTXT* pctxt, lppa_UnsuccessfulOutcome* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UnsuccessfulOutcome");

   /* decode root elements */
   /* decode procedureCode */
   RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

   stat = asn1PD_lppa_ProcedureCode (pctxt, &pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_lppa_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode lppatransactionID */
   RTXCTXTPUSHELEMNAME (pctxt, "lppatransactionID");

   stat = asn1PD_lppa_LPPATransactionID (pctxt, &pvalue->lppatransactionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   ASN1OpenType openType;

   stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode open type data into specific type field */

   rtxCopyContext (&lctxt, pctxt);

   stat = pd_setp (pctxt, (OSOCTET*)openType.data,
      openType.numocts, pctxt->buffer.aligned);

   switch (pvalue->procedureCode) {
   case ASN1V_lppa_id_e_CIDMeasurementInitiation:
      pvalue->value.t = T1lppa__e_CIDMeasurementInitiation;

      pvalue->value.u.e_CIDMeasurementInitiation = rtxMemAllocType (pctxt, 
         lppa_E_CIDMeasurementInitiationFailure);

      if (pvalue->value.u.e_CIDMeasurementInitiation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_E_CIDMeasurementInitiationFailure (pvalue->value.
         u.e_CIDMeasurementInitiation);

      stat = asn1PD_lppa_E_CIDMeasurementInitiationFailure (pctxt, pvalue->
         value.u.e_CIDMeasurementInitiation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_oTDOAInformationExchange:
      pvalue->value.t = T1lppa__oTDOAInformationExchange;

      pvalue->value.u.oTDOAInformationExchange = rtxMemAllocType (pctxt, 
         lppa_OTDOAInformationFailure);

      if (pvalue->value.u.oTDOAInformationExchange == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_OTDOAInformationFailure (pvalue->value.
         u.oTDOAInformationExchange);

      stat = asn1PD_lppa_OTDOAInformationFailure (pctxt, pvalue->value.
         u.oTDOAInformationExchange);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   case ASN1V_lppa_id_uTDOAInformationExchange:
      pvalue->value.t = T1lppa__uTDOAInformationExchange;

      pvalue->value.u.uTDOAInformationExchange = rtxMemAllocType (pctxt, 
         lppa_UTDOAInformationFailure);

      if (pvalue->value.u.uTDOAInformationExchange == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_lppa_UTDOAInformationFailure (pvalue->value.
         u.uTDOAInformationExchange);

      stat = asn1PD_lppa_UTDOAInformationFailure (pctxt, pvalue->value.
         u.uTDOAInformationExchange);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;

   default:
      pvalue->value.t = T1lppa__UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->value.u.extElem1->numocts = openType.numocts;
      pvalue->value.u.extElem1->data = openType.data;

      /* prevent local data from being freed */
      openType.data = 0;
      break;
   }

   if (0 != openType.data) {
      rtxMemFreePtr (pctxt, openType.data);
   }
   rtxCopyContext (pctxt, &lctxt);

   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_UnsuccessfulOutcome (lppa_UnsuccessfulOutcome* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->value, 0, sizeof(pvalue->value));
   return 0;
}

void asn1Free_lppa_UnsuccessfulOutcome (OSCTXT *pctxt, 
   lppa_UnsuccessfulOutcome* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->value.t) {
      case T1lppa__e_CIDMeasurementInitiation:
         if (0 != pvalue->value.u.e_CIDMeasurementInitiation) {
            asn1Free_lppa_E_CIDMeasurementInitiationFailure (pctxt, pvalue->value.u.e_CIDMeasurementInitiation);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.e_CIDMeasurementInitiation);
         }
         break;

      case T1lppa__oTDOAInformationExchange:
         if (0 != pvalue->value.u.oTDOAInformationExchange) {
            asn1Free_lppa_OTDOAInformationFailure (pctxt, pvalue->value.u.oTDOAInformationExchange);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.oTDOAInformationExchange);
         }
         break;

      case T1lppa__uTDOAInformationExchange:
         if (0 != pvalue->value.u.uTDOAInformationExchange) {
            asn1Free_lppa_UTDOAInformationFailure (pctxt, pvalue->value.u.uTDOAInformationExchange);
            rtxMemFreePtr (pctxt, (void*)pvalue->value.u.uTDOAInformationExchange);
         }
         break;

      default:;
   }
}

EXTERN int asn1PE_lppa_LPPA_PDU (OSCTXT* pctxt, lppa_LPPA_PDU* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LPPA-PDU");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 3);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* initiatingMessage */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "initiatingMessage");

            stat = asn1PE_lppa_InitiatingMessage (pctxt, pvalue->u.initiatingMessage);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* successfulOutcome */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "successfulOutcome");

            stat = asn1PE_lppa_SuccessfulOutcome (pctxt, pvalue->u.successfulOutcome);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* unsuccessfulOutcome */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "unsuccessfulOutcome");

            stat = asn1PE_lppa_UnsuccessfulOutcome (pctxt, pvalue->u.unsuccessfulOutcome);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_lppa_LPPA_PDU (OSCTXT* pctxt, lppa_LPPA_PDU* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "LPPA-PDU");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* initiatingMessage */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "initiatingMessage");

            pvalue->u.initiatingMessage = rtxMemAllocType (pctxt, 
               lppa_InitiatingMessage);

            if (pvalue->u.initiatingMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_lppa_InitiatingMessage (pvalue->u.initiatingMessage);

            stat = asn1PD_lppa_InitiatingMessage (pctxt, pvalue->u.initiatingMessage);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* successfulOutcome */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "successfulOutcome");

            pvalue->u.successfulOutcome = rtxMemAllocType (pctxt, 
               lppa_SuccessfulOutcome);

            if (pvalue->u.successfulOutcome == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_lppa_SuccessfulOutcome (pvalue->u.successfulOutcome);

            stat = asn1PD_lppa_SuccessfulOutcome (pctxt, pvalue->u.successfulOutcome);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* unsuccessfulOutcome */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "unsuccessfulOutcome");

            pvalue->u.unsuccessfulOutcome = rtxMemAllocType (pctxt, 
               lppa_UnsuccessfulOutcome);

            if (pvalue->u.unsuccessfulOutcome == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_lppa_UnsuccessfulOutcome (pvalue->u.unsuccessfulOutcome);

            stat = asn1PD_lppa_UnsuccessfulOutcome (pctxt, pvalue->u.unsuccessfulOutcome);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_lppa_LPPA_PDU (lppa_LPPA_PDU* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_lppa_LPPA_PDU (OSCTXT *pctxt, lppa_LPPA_PDU* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.initiatingMessage) {
            asn1Free_lppa_InitiatingMessage (pctxt, pvalue->u.initiatingMessage);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.initiatingMessage);
            pvalue->u.initiatingMessage = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.successfulOutcome) {
            asn1Free_lppa_SuccessfulOutcome (pctxt, pvalue->u.successfulOutcome);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.successfulOutcome);
            pvalue->u.successfulOutcome = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.unsuccessfulOutcome) {
            asn1Free_lppa_UnsuccessfulOutcome (pctxt, pvalue->u.unsuccessfulOutcome);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.unsuccessfulOutcome);
            pvalue->u.unsuccessfulOutcome = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

void asn1Print_lppa_InitiatingMessage 
   (const char* name, const lppa_InitiatingMessage* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProcedureCode ("procedureCode", &pvalue->procedureCode);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   asn1Print_lppa_LPPATransactionID ("lppatransactionID", &pvalue->
      lppatransactionID);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* e_CIDMeasurementInitiation */
      case T1lppa__e_CIDMeasurementInitiation:
      {
         asn1Print_lppa_E_CIDMeasurementInitiationRequest (
            "e_CIDMeasurementInitiation", pvalue->value.
            u.e_CIDMeasurementInitiation);
         break;
      }
      /* oTDOAInformationExchange */
      case T1lppa__oTDOAInformationExchange:
      {
         asn1Print_lppa_OTDOAInformationRequest ("oTDOAInformationExchange", 
            pvalue->value.u.oTDOAInformationExchange);
         break;
      }
      /* uTDOAInformationExchange */
      case T1lppa__uTDOAInformationExchange:
      {
         asn1Print_lppa_UTDOAInformationRequest ("uTDOAInformationExchange", 
            pvalue->value.u.uTDOAInformationExchange);
         break;
      }
      /* e_CIDMeasurementFailureIndication */
      case T1lppa__e_CIDMeasurementFailureIndication:
      {
         asn1Print_lppa_E_CIDMeasurementFailureIndication (
            "e_CIDMeasurementFailureIndication", pvalue->value.
            u.e_CIDMeasurementFailureIndication);
         break;
      }
      /* e_CIDMeasurementReport */
      case T1lppa__e_CIDMeasurementReport:
      {
         asn1Print_lppa_E_CIDMeasurementReport ("e_CIDMeasurementReport", 
            pvalue->value.u.e_CIDMeasurementReport);
         break;
      }
      /* e_CIDMeasurementTermination */
      case T1lppa__e_CIDMeasurementTermination:
      {
         asn1Print_lppa_E_CIDMeasurementTerminationCommand (
            "e_CIDMeasurementTermination", pvalue->value.
            u.e_CIDMeasurementTermination);
         break;
      }
      /* errorIndication */
      case T1lppa__errorIndication:
      {
         asn1Print_lppa_ErrorIndication ("errorIndication", pvalue->value.
            u.errorIndication);
         break;
      }
      /* privateMessage */
      case T1lppa__privateMessage:
      {
         asn1Print_lppa_PrivateMessage ("privateMessage", pvalue->value.
            u.privateMessage);
         break;
      }
      /* uTDOAInformationUpdate */
      case T1lppa__uTDOAInformationUpdate:
      {
         asn1Print_lppa_UTDOAInformationUpdate ("uTDOAInformationUpdate", 
            pvalue->value.u.uTDOAInformationUpdate);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_SuccessfulOutcome 
   (const char* name, const lppa_SuccessfulOutcome* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProcedureCode ("procedureCode", &pvalue->procedureCode);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   asn1Print_lppa_LPPATransactionID ("lppatransactionID", &pvalue->
      lppatransactionID);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* e_CIDMeasurementInitiation */
      case T1lppa__e_CIDMeasurementInitiation:
      {
         asn1Print_lppa_E_CIDMeasurementInitiationResponse (
            "e_CIDMeasurementInitiation", pvalue->value.
            u.e_CIDMeasurementInitiation);
         break;
      }
      /* oTDOAInformationExchange */
      case T1lppa__oTDOAInformationExchange:
      {
         asn1Print_lppa_OTDOAInformationResponse ("oTDOAInformationExchange", 
            pvalue->value.u.oTDOAInformationExchange);
         break;
      }
      /* uTDOAInformationExchange */
      case T1lppa__uTDOAInformationExchange:
      {
         asn1Print_lppa_UTDOAInformationResponse ("uTDOAInformationExchange", 
            pvalue->value.u.uTDOAInformationExchange);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_UnsuccessfulOutcome 
   (const char* name, const lppa_UnsuccessfulOutcome* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_lppa_ProcedureCode ("procedureCode", &pvalue->procedureCode);

   asn1Print_lppa_Criticality ("criticality", &pvalue->criticality);

   asn1Print_lppa_LPPATransactionID ("lppatransactionID", &pvalue->
      lppatransactionID);

   rtxPrintOpenBrace ("value");

   switch (pvalue->value.t)
   {
      /* e_CIDMeasurementInitiation */
      case T1lppa__e_CIDMeasurementInitiation:
      {
         asn1Print_lppa_E_CIDMeasurementInitiationFailure (
            "e_CIDMeasurementInitiation", pvalue->value.
            u.e_CIDMeasurementInitiation);
         break;
      }
      /* oTDOAInformationExchange */
      case T1lppa__oTDOAInformationExchange:
      {
         asn1Print_lppa_OTDOAInformationFailure ("oTDOAInformationExchange", 
            pvalue->value.u.oTDOAInformationExchange);
         break;
      }
      /* uTDOAInformationExchange */
      case T1lppa__uTDOAInformationExchange:
      {
         asn1Print_lppa_UTDOAInformationFailure ("uTDOAInformationExchange", 
            pvalue->value.u.uTDOAInformationExchange);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtxPrintIndent ();
            rtxPrintHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtxPrintCloseBrace ();

   rtxPrintCloseBrace ();
}

void asn1Print_lppa_LPPA_PDU (const char* name, const lppa_LPPA_PDU* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* initiatingMessage */
      case 1:
      {
         asn1Print_lppa_InitiatingMessage ("initiatingMessage", pvalue->
            u.initiatingMessage);
         break;
      }
      /* successfulOutcome */
      case 2:
      {
         asn1Print_lppa_SuccessfulOutcome ("successfulOutcome", pvalue->
            u.successfulOutcome);
         break;
      }
      /* unsuccessfulOutcome */
      case 3:
      {
         asn1Print_lppa_UnsuccessfulOutcome ("unsuccessfulOutcome", pvalue->
            u.unsuccessfulOutcome);
         break;
      }
      /* extElem1 */
      case 4:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

int asn1PrtToStr_lppa_InitiatingMessage (const char* name, 
   lppa_InitiatingMessage* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProcedureCode ("procedureCode", &pvalue->procedureCode, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_LPPATransactionID ("lppatransactionID", &pvalue->lppatransactionID, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* e_CIDMeasurementInitiation */
      case T1lppa__e_CIDMeasurementInitiation:
      {
         if (asn1PrtToStr_lppa_E_CIDMeasurementInitiationRequest ("e_CIDMeasurementInitiation", pvalue->value.u.e_CIDMeasurementInitiation, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* oTDOAInformationExchange */
      case T1lppa__oTDOAInformationExchange:
      {
         if (asn1PrtToStr_lppa_OTDOAInformationRequest ("oTDOAInformationExchange", pvalue->value.u.oTDOAInformationExchange, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* uTDOAInformationExchange */
      case T1lppa__uTDOAInformationExchange:
      {
         if (asn1PrtToStr_lppa_UTDOAInformationRequest ("uTDOAInformationExchange", pvalue->value.u.uTDOAInformationExchange, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* e_CIDMeasurementFailureIndication */
      case T1lppa__e_CIDMeasurementFailureIndication:
      {
         if (asn1PrtToStr_lppa_E_CIDMeasurementFailureIndication ("e_CIDMeasurementFailureIndication", pvalue->value.u.e_CIDMeasurementFailureIndication, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* e_CIDMeasurementReport */
      case T1lppa__e_CIDMeasurementReport:
      {
         if (asn1PrtToStr_lppa_E_CIDMeasurementReport ("e_CIDMeasurementReport", pvalue->value.u.e_CIDMeasurementReport, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* e_CIDMeasurementTermination */
      case T1lppa__e_CIDMeasurementTermination:
      {
         if (asn1PrtToStr_lppa_E_CIDMeasurementTerminationCommand ("e_CIDMeasurementTermination", pvalue->value.u.e_CIDMeasurementTermination, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* errorIndication */
      case T1lppa__errorIndication:
      {
         if (asn1PrtToStr_lppa_ErrorIndication ("errorIndication", pvalue->value.u.errorIndication, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* privateMessage */
      case T1lppa__privateMessage:
      {
         if (asn1PrtToStr_lppa_PrivateMessage ("privateMessage", pvalue->value.u.privateMessage, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* uTDOAInformationUpdate */
      case T1lppa__uTDOAInformationUpdate:
      {
         if (asn1PrtToStr_lppa_UTDOAInformationUpdate ("uTDOAInformationUpdate", pvalue->value.u.uTDOAInformationUpdate, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_SuccessfulOutcome (const char* name, 
   lppa_SuccessfulOutcome* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProcedureCode ("procedureCode", &pvalue->procedureCode, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_LPPATransactionID ("lppatransactionID", &pvalue->lppatransactionID, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* e_CIDMeasurementInitiation */
      case T1lppa__e_CIDMeasurementInitiation:
      {
         if (asn1PrtToStr_lppa_E_CIDMeasurementInitiationResponse ("e_CIDMeasurementInitiation", pvalue->value.u.e_CIDMeasurementInitiation, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* oTDOAInformationExchange */
      case T1lppa__oTDOAInformationExchange:
      {
         if (asn1PrtToStr_lppa_OTDOAInformationResponse ("oTDOAInformationExchange", pvalue->value.u.oTDOAInformationExchange, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* uTDOAInformationExchange */
      case T1lppa__uTDOAInformationExchange:
      {
         if (asn1PrtToStr_lppa_UTDOAInformationResponse ("uTDOAInformationExchange", pvalue->value.u.uTDOAInformationExchange, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_UnsuccessfulOutcome (const char* name, 
   lppa_UnsuccessfulOutcome* pvalue, char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_ProcedureCode ("procedureCode", &pvalue->procedureCode, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_Criticality ("criticality", &pvalue->criticality, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (asn1PrtToStr_lppa_LPPATransactionID ("lppatransactionID", &pvalue->lppatransactionID, buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringOpenBrace ("value", buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->value.t) {
      /* e_CIDMeasurementInitiation */
      case T1lppa__e_CIDMeasurementInitiation:
      {
         if (asn1PrtToStr_lppa_E_CIDMeasurementInitiationFailure ("e_CIDMeasurementInitiation", pvalue->value.u.e_CIDMeasurementInitiation, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* oTDOAInformationExchange */
      case T1lppa__oTDOAInformationExchange:
      {
         if (asn1PrtToStr_lppa_OTDOAInformationFailure ("oTDOAInformationExchange", pvalue->value.u.oTDOAInformationExchange, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* uTDOAInformationExchange */
      case T1lppa__uTDOAInformationExchange:
      {
         if (asn1PrtToStr_lppa_UTDOAInformationFailure ("uTDOAInformationExchange", pvalue->value.u.uTDOAInformationExchange, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStringIndent (buffer, bufSize);
            rtPrintToStringHexStr ("extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data, buffer, bufSize);
         }
      }
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0) return -1;
   return 0;
}

int asn1PrtToStr_lppa_LPPA_PDU (const char* name, lppa_LPPA_PDU* pvalue, 
   char* buffer, OSSIZE bufSize)
{
   if (rtPrintToStringOpenBrace (name, buffer, bufSize) < 0)
   {
      return -1;
   }

   switch (pvalue->t) {
      /* initiatingMessage */
      case 1:
      {
         if (asn1PrtToStr_lppa_InitiatingMessage ("initiatingMessage", pvalue->u.initiatingMessage, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* successfulOutcome */
      case 2:
      {
         if (asn1PrtToStr_lppa_SuccessfulOutcome ("successfulOutcome", pvalue->u.successfulOutcome, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* unsuccessfulOutcome */
      case 3:
      {
         if (asn1PrtToStr_lppa_UnsuccessfulOutcome ("unsuccessfulOutcome", pvalue->u.unsuccessfulOutcome, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      /* extElem1 */
      case 4:
      {
         if(rtPrintToStringIndent (buffer, bufSize) < 0)
         {
            return -1;
         }
         if(rtPrintToStringHexStr ("extElem1", pvalue->u.extElem1->numocts, pvalue->u.extElem1->data, buffer, bufSize) < 0)
         {
            return -1;
         }
         break;
      }
      default:;
   }

   if (rtPrintToStringCloseBrace (buffer, bufSize) < 0)
   {
      return -1;
   }
   return 0;
}

int asn1PrtToStrm_lppa_InitiatingMessage (OSCTXT *pctxt, 
   const char* name, const lppa_InitiatingMessage* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProcedureCode (pctxt, "procedureCode", &pvalue->procedureCode);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   asn1PrtToStrm_lppa_LPPATransactionID (pctxt, "lppatransactionID", &pvalue->lppatransactionID);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* e_CIDMeasurementInitiation */
      case T1lppa__e_CIDMeasurementInitiation:
      {
         asn1PrtToStrm_lppa_E_CIDMeasurementInitiationRequest (pctxt, "e_CIDMeasurementInitiation", pvalue->value.u.e_CIDMeasurementInitiation);
         break;
      }
      /* oTDOAInformationExchange */
      case T1lppa__oTDOAInformationExchange:
      {
         asn1PrtToStrm_lppa_OTDOAInformationRequest (pctxt, "oTDOAInformationExchange", pvalue->value.u.oTDOAInformationExchange);
         break;
      }
      /* uTDOAInformationExchange */
      case T1lppa__uTDOAInformationExchange:
      {
         asn1PrtToStrm_lppa_UTDOAInformationRequest (pctxt, "uTDOAInformationExchange", pvalue->value.u.uTDOAInformationExchange);
         break;
      }
      /* e_CIDMeasurementFailureIndication */
      case T1lppa__e_CIDMeasurementFailureIndication:
      {
         asn1PrtToStrm_lppa_E_CIDMeasurementFailureIndication (pctxt, "e_CIDMeasurementFailureIndication", pvalue->value.u.e_CIDMeasurementFailureIndication);
         break;
      }
      /* e_CIDMeasurementReport */
      case T1lppa__e_CIDMeasurementReport:
      {
         asn1PrtToStrm_lppa_E_CIDMeasurementReport (pctxt, "e_CIDMeasurementReport", pvalue->value.u.e_CIDMeasurementReport);
         break;
      }
      /* e_CIDMeasurementTermination */
      case T1lppa__e_CIDMeasurementTermination:
      {
         asn1PrtToStrm_lppa_E_CIDMeasurementTerminationCommand (pctxt, "e_CIDMeasurementTermination", pvalue->value.u.e_CIDMeasurementTermination);
         break;
      }
      /* errorIndication */
      case T1lppa__errorIndication:
      {
         asn1PrtToStrm_lppa_ErrorIndication (pctxt, "errorIndication", pvalue->value.u.errorIndication);
         break;
      }
      /* privateMessage */
      case T1lppa__privateMessage:
      {
         asn1PrtToStrm_lppa_PrivateMessage (pctxt, "privateMessage", pvalue->value.u.privateMessage);
         break;
      }
      /* uTDOAInformationUpdate */
      case T1lppa__uTDOAInformationUpdate:
      {
         asn1PrtToStrm_lppa_UTDOAInformationUpdate (pctxt, "uTDOAInformationUpdate", pvalue->value.u.uTDOAInformationUpdate);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_SuccessfulOutcome (OSCTXT *pctxt, 
   const char* name, const lppa_SuccessfulOutcome* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProcedureCode (pctxt, "procedureCode", &pvalue->procedureCode);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   asn1PrtToStrm_lppa_LPPATransactionID (pctxt, "lppatransactionID", &pvalue->lppatransactionID);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* e_CIDMeasurementInitiation */
      case T1lppa__e_CIDMeasurementInitiation:
      {
         asn1PrtToStrm_lppa_E_CIDMeasurementInitiationResponse (pctxt, "e_CIDMeasurementInitiation", pvalue->value.u.e_CIDMeasurementInitiation);
         break;
      }
      /* oTDOAInformationExchange */
      case T1lppa__oTDOAInformationExchange:
      {
         asn1PrtToStrm_lppa_OTDOAInformationResponse (pctxt, "oTDOAInformationExchange", pvalue->value.u.oTDOAInformationExchange);
         break;
      }
      /* uTDOAInformationExchange */
      case T1lppa__uTDOAInformationExchange:
      {
         asn1PrtToStrm_lppa_UTDOAInformationResponse (pctxt, "uTDOAInformationExchange", pvalue->value.u.uTDOAInformationExchange);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_UnsuccessfulOutcome (OSCTXT *pctxt, 
   const char* name, const lppa_UnsuccessfulOutcome* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_lppa_ProcedureCode (pctxt, "procedureCode", &pvalue->procedureCode);

   asn1PrtToStrm_lppa_Criticality (pctxt, "criticality", &pvalue->criticality);

   asn1PrtToStrm_lppa_LPPATransactionID (pctxt, "lppatransactionID", &pvalue->lppatransactionID);

   rtPrintToStreamOpenBrace (pctxt, "value");

   switch (pvalue->value.t)
   {
      /* e_CIDMeasurementInitiation */
      case T1lppa__e_CIDMeasurementInitiation:
      {
         asn1PrtToStrm_lppa_E_CIDMeasurementInitiationFailure (pctxt, "e_CIDMeasurementInitiation", pvalue->value.u.e_CIDMeasurementInitiation);
         break;
      }
      /* oTDOAInformationExchange */
      case T1lppa__oTDOAInformationExchange:
      {
         asn1PrtToStrm_lppa_OTDOAInformationFailure (pctxt, "oTDOAInformationExchange", pvalue->value.u.oTDOAInformationExchange);
         break;
      }
      /* uTDOAInformationExchange */
      case T1lppa__uTDOAInformationExchange:
      {
         asn1PrtToStrm_lppa_UTDOAInformationFailure (pctxt, "uTDOAInformationExchange", pvalue->value.u.uTDOAInformationExchange);
         break;
      }
      default: {
         if (0 != pvalue->value.u.extElem1) {
            rtPrintToStreamIndent (pctxt);
            rtPrintToStreamHexStr (pctxt, "extElem1", pvalue->value.u.extElem1->numocts, pvalue->value.u.extElem1->data);
         }
      }
   }

   rtPrintToStreamCloseBrace (pctxt);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_lppa_LPPA_PDU (OSCTXT *pctxt, 
   const char* name, const lppa_LPPA_PDU* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* initiatingMessage */
      case 1:
      {
         asn1PrtToStrm_lppa_InitiatingMessage (pctxt, "initiatingMessage", pvalue->u.initiatingMessage);
         break;
      }
      /* successfulOutcome */
      case 2:
      {
         asn1PrtToStrm_lppa_SuccessfulOutcome (pctxt, "successfulOutcome", pvalue->u.successfulOutcome);
         break;
      }
      /* unsuccessfulOutcome */
      case 3:
      {
         asn1PrtToStrm_lppa_UnsuccessfulOutcome (pctxt, "unsuccessfulOutcome", pvalue->u.unsuccessfulOutcome);
         break;
      }
      /* extElem1 */
      case 4:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamHexStr (pctxt, "extElem1",
            pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

