/******************************************************************************
 *
 *   FILE NAME:
 *       uecc_llim.c
 *
 *   DESCRIPTION:
 *       This is the source file of the UECC LLIM.
 *       UECC LLIM interacts with RRC LLIM module.
 *
 *   DATE            AUTHOR      REFERENCE       REASON
 *   20 Jul 2009     GrygoriyS   ---------       Initial
 *
 *   Copyright (c) 2009, Aricent Inc. All Rights Reserved
 *
 ******************************************************************************/

/****************************************************************************
 * Header File Includes
 ***************************************************************************/

#include "rrc_common_utils.h"
#include "rrc_common_md.h"
#include "rrc_msg_mgmt.h"
#include "rrc_intrl_api.h"
#include "rrc_phy_intf.h"
#include "rrc_uecc_llim_intf.h"
#include "rrc_asn_enc_dec.h"
#ifdef LTE_EMBMS_SUPPORTED
#include "rrc_m2apRrc_intf.h"
#endif
#include "uecc_llim.h"
#include "uecc_utils.h"
#include "uecc_mainfsm.h"
#include "uecc_logger.h"
#include "uecc_llim_utils.h"
#include "uecc_defaults.h"

#include "uecc_common.h"
#include "uecc_fsm_engine.h"
#include "uecc_fsm_common.h"
#include "uecc_statistic.h"
#include "uecc_s1ap.h"
#include "rrc_s1u_intf.h"
#include "rrc_mac_intf.h"
#include "rrc_s1ap_asn_intrl_enc_3gpp.h"
#include "uecc_rrm.h"
#include "ylib.h"
#include "rrc_rrm_intf.h"
#include "rrc_rrm_il_composer.h"
#include "rrc_shared_stats.h"
#include "uecc_x2ap.h"
#include "rrc_logging.h"
#include "lteMisc.h"
#include "rrc_defines.h"
#ifdef LTE_EMBMS_SUPPORTED
#include "m2ap_api.h"
#include "rrc_m2apRrc_intf.h"
#endif

#include "uecc_src_hofsm.h"
/*SPR_17893_START*/
#include "uecc_ct_a.h"
/*SPR_17893_END*/


/****************************************************************************
 * Defines
 ***************************************************************************/
#define RRC_S1U_CREATE_UE_NORMAL_TUNNEL_SAP_FLAG         0x0F 
#define RRC_S1U_CREATE_UE_DL_FORWARDING_TUNNEL_SAP_FLAG  0x2D
#define RRC_S1U_CREATE_UE_UL_FORWARDING_TUNNEL_SAP_FLAG  0x6D

#define RRC_S1U_RECONFIG_UE_NORMAL_TUNNEL_SAP_FLAG         0x0F 
#define RRC_S1U_RECONFIG_UE_DL_FORWARDING_TUNNEL_SAP_FLAG  0x2E
#define RRC_S1U_RECONFIG_UE_UL_FORWARDING_TUNNEL_SAP_FLAG  0x6E

#ifdef ENDC_ENABLED
/*OPTION3X Changes Start*/
#define RRC_S1U_RECONFIG_UE_X2U_TUNNEL_SAP_FLAG             0x9F
/*OPTION3X Changes Stop*/
#endif

#define CSG_RESET_VAL 0xE0
#define RAND_CDMA_NBITS 32
/****************************************************************************
 * Local Functions Prototypes
 ****************************************************************************/

/* GDB Fix - compiler warning */
extern rrc_return_et uecc_llim_build_asn1_setup_drb_to_release_list(    uecc_ue_context_t*   p_uecc_ue_context,
        DRB_ToReleaseList*   p_asn1_list,
        OSCTXT*              p_asn1_ctx );

#ifdef LTE_EMBMS_SUPPORTED
static rrc_return_et  parse_mbms_counting_resp
(
    UL_DCCH_Message                      *p_ul_dcch_message,
    rrc_m2ap_mbms_counting_result_ind_t    *p_m2ap_mbms_counting_result_ind,
    uecc_gb_context_t                      *p_uecc_gb_context
);
#endif

static rrc_return_et uecc_llim_process_ccch_rrcConnectionRequest(
        uecc_gb_context_t           *p_uecc_gb_context,    /* UECC global context */
        rrc_cell_index_t            cell_index,            /* Cell Index */
        rrc_rnti_t                  rnti,                       /* UE rnti */
        U16                         timing_advance,            
        U8                          sinr,
        RRCConnectionRequest_r8_IEs *p_rrcConnectionRequest_r8,  /* UE message */
        rrc_counter_t                buffer_length,
        U8                          *buffer,
        rrc_module_id_t             dst_module_id
        );

/* SPR 16149 Fix 6 Start */ 
static rrc_return_et uecc_llim_process_ccch_rrcConnectionReestablishmentRequest(
        uecc_gb_context_t           *p_uecc_gb_context,    /* UECC global context */
        rrc_rnti_t                  rnti,                       /* UE rnti */
        RRCConnectionReestablishmentRequest_r8_IEs *p_rrcConnectionReestablishmentRequest_r8, /* UE message */
        U16                         data_buffer_length,
        U8                          *p_data_buffer,
        rrc_cell_index_t            cell_index,
        U8                          rnti_found
        );
/* SPR 16149 Fix 6 Stop */ 


static rrc_return_et uecc_llim_process_dcch_rrcConnectionSetupComplete(
        uecc_gb_context_t       *p_uecc_gb_context,      /* UECC global context */
        rrc_ue_index_t          ue_index,                /* UE index  */
        RRCConnectionSetupComplete *rrcConnectionSetupComplete  /* UE message */
        );

static 
rrc_return_et uecc_llim_process_dcch_rrcConnectionReestablishmentComplete(
        uecc_gb_context_t       *p_uecc_gb_context,      /* UECC global context */
        rrc_ue_index_t          ue_index,                /* UE index  */
        RRCConnectionReestablishmentComplete *rrcConnectionReestablishmentComplete  
        /* UE message */
        );
static rrc_return_et uecc_llim_process_dcch_measurementReport(
        uecc_gb_context_t       *p_uecc_gb_context,  /* UECC global context */
        rrc_ue_index_t          ue_index,            /* UE index  */
        MeasurementReport*      p_measurementReport  /* UE message */
        );

static rrc_return_et uecc_llim_process_dcch_rrcConnectionReconfigurationComplete
(
 uecc_gb_context_t       *p_uecc_gb_context,      /* UECC global context */
 rrc_ue_index_t          ue_index,                /* UE index  */
 RRCConnectionReconfigurationComplete *rrcConnectionReconfigurationComplete
 );

static rrc_return_et uecc_llim_process_dcch_ulInformationTransfer(
        uecc_gb_context_t       *p_uecc_gb_context,       /* UECC global context */
        rrc_ue_index_t          ue_index,                 /* UE index  */
        ULInformationTransfer   *rrcULInformationTransfer /* UE message */
        );

static rrc_return_et uecc_llim_process_dcch_ueInformationResp(
        uecc_gb_context_t       *p_uecc_gb_context,        /* UECC global context */
        rrc_ue_index_t          ue_index,                  /* UE index  */
        UEInformationResponse_r9 *p_UEInformationResp, /*Pointer on UE message*/
        rrc_uecc_llim_srb_data_ind_t *p_srb_data
        );
static rrc_return_et uecc_llim_process_dcch_ueCapabilityInformation(
        uecc_gb_context_t       *p_uecc_gb_context,        /* UECC global context */
        rrc_ue_index_t          ue_index,                  /* UE index  */
        UECapabilityInformation *p_UECapabilityInformation /*Pointer on UE message*/
        );

static rrc_return_et uecc_llim_process_dcch_securityModeComplete(
        uecc_gb_context_t       *p_uecc_gb_context,        /* UECC global context */
        rrc_ue_index_t          ue_index,                  /* UE index  */
        SecurityModeComplete    *p_rrcSecurityModeComplete /* UE message */
        );

static rrc_return_et uecc_llim_process_dcch_securityModeFailure(
        uecc_gb_context_t       *p_uecc_gb_context,        /* UECC global context */
        rrc_ue_index_t          ue_index,                  /* UE index  */
        SecurityModeFailure    *p_rrcSecurityModeFailure /* UE message */
        );

static rrc_return_et uecc_llim_process_dcch_proximityIndication_r9(
        uecc_gb_context_t       *p_uecc_gb_context,  /* UECC global context */
        rrc_ue_index_t          ue_index,            /* UE index  */
        ProximityIndication_r9* p_proximityIndication,  /* UE message */
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
        );


rrc_return_et uecc_llim_process_dcch_interFreqRstdMeasurement_r10(
        uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
        rrc_ue_index_t      ue_index,           /* UE index  */
        InterFreqRSTDMeasurementIndication_r10 *p_inter_freq_rstd_meas_ind, /* UE message */
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
        );

#ifdef ENDC_ENABLED
/*NR_DC Code Change Start*/
static rrc_return_et uecc_llim_process_dcch_scgFailureInformationNR_r15(
        uecc_gb_context_t       *p_uecc_gb_context,        /* UECC global context */
        rrc_ue_index_t          ue_index,                  /* UE index  */
        SCGFailureInformationNR_r15 *p_scgFailureInformationNR /*Pointer on UE message*/
        );
/*NR_DC Code Change Stop*/

/******************************************************************************
 *   FUNCTION NAME: uecc_rrc_update_curr_MeasObject_NR
 *   INPUT        : meas_object_nr_t*     p_rrm_curr_meas_object_nr
 *                  meas_object_nr_t*     p_rrm_meas_object_nr
 *                  uecc_gb_context_t*    p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds MeasObjectNR_r15 in currMeasConfig
 *                  structure
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 ******************************************************************************/
rrc_return_et
uecc_rrc_update_curr_MeasObject_NR
(
    meas_object_nr_t*     p_rrm_curr_meas_object_nr,
    meas_object_nr_t*     p_rrm_meas_object_nr,
    uecc_gb_context_t*    p_uecc_gb_context
);
#endif

static void uecc_llim_build_add_lc_req(
        uecc_ue_context_t*  p_uecc_ue_context,
        rrc_uecc_llim_add_lc_req_t* p_rrc_uecc_llim_add_lc_req
        );
/* ERAB SETUP START */
static void uecc_llim_build_add_rollback_req(
        uecc_ue_context_t*  p_uecc_ue_context,
        rrc_uecc_llim_add_rollback_req_t* p_rrc_uecc_llim_add_rollback_req
        );
/* ERAB SETUP STOP */


rrc_return_et uecc_llim_build_modify_lc_req(
        uecc_ue_context_t*              p_uecc_ue_context,
        rrc_uecc_llim_modify_lc_req_t*  p_rrc_uecc_llim_modify_lc_req
        );

rrc_return_et rrc_get_rb_direction(
        uecc_ue_context_t*                p_uecc_ue_context,
        U8                                erab_index,
        rrc_rb_direction_t                *rb_direction
        );




void uecc_llim_fill_to_be_modified_radio_rsource_config
(
 uecc_ue_context_t*  p_uecc_ue_context,
 rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 );

rrc_return_et uecc_llim_fill_radio_rsource_config_for_rollback
(
 uecc_ue_context_t*  p_uecc_ue_context,
 rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 );

void uecc_llim_build_modify_rollback_req
(
 uecc_ue_context_t*              p_uecc_ue_context,
 rrc_uecc_llim_modify_rollback_req_t*  p_rrc_uecc_llim_rollback_req
 );

void uecc_llim_build_modify_rollback_req_for_ue_reconfig
(
 uecc_ue_context_t*              p_uecc_ue_context,
 rrc_uecc_llim_modify_rollback_req_t*  p_rrc_uecc_llim_rollback_req
 );
void uecc_llim_build_modify_rollback_req_for_ue_ctx_mod
(
 uecc_ue_context_t*              p_uecc_ue_context,
 rrc_uecc_llim_modify_rollback_req_t*  p_rrc_uecc_llim_rollback_req
 );
/*securitykey*/
void uecc_llim_fill_to_be_modified_radio_rsource_config_for_ue_ctx_mod
(
 uecc_ue_context_t*             p_uecc_ue_context,
 rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 ); 
void uecc_llim_fill_to_be_modified_radio_rsource_config_for_ue_ctx_mod_for_rollback
(
 uecc_ue_context_t*             p_uecc_ue_context,
 rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 ); 
/*securitykey*/
rrc_return_et uecc_llim_build_erb_modify_rrc_connection_reconfiguration
(
 DL_DCCH_Message           *p_dl_dcch_msg,
 OSCTXT                    *p_asn1_ctx,
 uecc_ue_context_t         *p_uecc_ue_context
 );

rrc_return_et uecc_llim_init_asn_context
(
 OSCTXT             *p_asn1_ctx,
 uecc_ue_context_t  *p_uecc_ue_context
 );

rrc_return_et uecc_llim_build_dl_dcch_msg
(
 DL_DCCH_Message           *p_dl_dcch_msg,
 OSCTXT                    *p_asn1_ctx,
 uecc_ue_context_t         *p_uecc_ue_context,
 RRCConnectionReconfiguration** p_rrc_conn_recfg

 );

rrc_return_et uecc_llim_build_dl_dcch_meas_msg
(
 DL_DCCH_Message*              p_dl_dcch_msg,
 OSCTXT*                       p_asn1_ctx,
 uecc_ue_context_t*            p_uecc_ue_context,
 RRCConnectionReconfiguration** p_rrc_conn_recfg

 );

rrc_return_et uecc_llim_fill_erb_modify_srb_info
(
 RRCConnectionReconfiguration_r8_IEs    *p_r8,
 OSCTXT                                 *p_asn1_ctx,
 uecc_ue_context_t                      *p_uecc_ue_context
 );
rrc_return_et uecc_llim_build_erb_modify_radio_resource_cfg_dedicated(
        uecc_ue_context_t               *p_uecc_ue_context,
        RadioResourceConfigDedicated    *p_asn1_rrc,
        OSCTXT                          *p_asn1_ctx
        );

void uecc_llim_fill_erb_modify_drb_info
(
 RRCConnectionReconfiguration_r8_IEs    *p_r8,
 uecc_ue_context_t                      *p_uecc_ue_context 
 );

rrc_return_et uecc_llim_send_rrc_connection_reconfiguration(
        uecc_ue_context_t*                       p_uecc_ue_context,
        OSCTXT*                                  p_asn1_ctx,
        DL_DCCH_Message*                  p_dl_dcch_msg
        );

static rrc_return_et uecc_llim_encode_mobilityControlInfo(
        uecc_ue_context_t*  p_uecc_ue_context,
        OSCTXT   *            p_asn1_ctx,
        MobilityControlInfo *p_asn_mobilityControlInfo
        );

/*BUG 604 changes start*/
/*BUG 604 changes stop*/
static rrc_return_et uecc_llim_fill_mobility_control_info_radio_resource_config_common
(
 uecc_ue_context_t                  *p_uecc_ue_context,
 OSCTXT                             *p_asn1_ctx,
 RadioResourceConfigCommon          *p_asn1_cc     /* destination */
 );

/*static rrc_return_et uecc_s1ap_build_VarShortMAC_Input(
  uecc_ue_context_t   *p_ue_context,
  U32                 *p_cell_identity,
  U8                  *p_encoded_mac_i,
  U16                 *p_encoded_msg_length 
  ); */


static rrc_return_et uecc_llim_build_reestablishment_asn1_radio_resource_cfg_dedicated(
        uecc_ue_context_t               *p_uecc_ue_context,
        RadioResourceConfigDedicated    *p_asn1_rrc,
        OSCTXT                          *p_asn1_ctx
        );

/* HO Integration fix taken form rel 3.3 */
static rrc_bool_et is_am_mode_configured_drb_present(
        uecc_ue_context_t*  p_ue_context
        );        
/* SPR 1643 Start */
static rrc_return_et validate_meas_results_plmn_identity
(
 MeasResults_measResultNeighCells  *p_measResultNeighCells,
 uecc_gb_context_t       *p_uecc_gb_context        /* UECC global context */
 );
/* SPR 1643 Stop */


rrc_return_et uecc_llim_process_dcch_csfbParametersRequestCDMA2000
(
 uecc_gb_context_t                   *p_uecc_gb_context,              /* UECC global context */
 rrc_ue_index_t                      ue_index,                        /* UE index  */
 CSFBParametersRequestCDMA2000       *p_csfbParametersRequestCDMA2000, /* UE message */
 rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
 );


rrc_return_et uecc_llim_process_dcch_ulHandover_Preparation_Transfer
(
 uecc_gb_context_t               *p_uecc_gb_context,  /* UECC global context */
 rrc_ue_index_t                  ue_index,            /* UE index  */
 ULHandoverPreparationTransfer   *p_ul_ho_prep_transfer, //*p_proximityIndication  /* UE message */
 rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
 );

const void * uecc_curr_meas_object_id_keyof (const YLNODE *p_ylnode);
int uecc_curr_meas_compare (const void *p_key1, const void *p_key2);
const void * uecc_curr_report_config_id_keyof (const YLNODE *p_ylnode);

void uecc_llim_build_meas_config_req(
        uecc_ue_context_t*             p_uecc_ue_context,
        rrc_uecc_llim_meas_config_req_t* p_rrc_uecc_llim_meas_config_req
        );

rrc_return_et uecc_llim_process_dcch_counterCheckResponse(
        uecc_gb_context_t   *p_uecc_gb_context,
        rrc_ue_index_t      ue_index,           
        CounterCheckResponse *p_counterCheckResponse,
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
        );

rrc_return_et uecc_llim_send_counter_check_req(
        uecc_ue_context_t*                p_uecc_ue_context,
        OSCTXT*                           p_asn1_ctx,
        DL_DCCH_Message*                  p_dl_dcch_msg
        );

void uecc_llim_check_and_send_rrc_ue_information
(
 uecc_ue_context_t*  p_ue_context
 );
/*SPR_17121_START*/
void rrc_populate_maci_req(
        rrc_mac_i_msg_t* p_mac_i_req,
        uecc_ue_context_t*  p_ue_context);
/*SPR_17121_END*/

/* SPR 23209 FIXED START*/
rrc_return_et
uecc_llim_search_plmn_idx_in_sib1
(
 uecc_ue_context_t *p_ue_context,
 U8                *p_plmn_idx_sib1
);
/* SPR 23209 FIXED END*/

/*SPR 15304 Start*/
rrc_return_et uecc_llim_build_and_send_rollback_meas_config_req
(
    uecc_ue_context_t* p_uecc_ue_context
);
/*SPR 15304 Stop*/


rrc_return_et uecc_llim_build_scell_config
(
 uecc_ue_context_t                    *p_uecc_ue_context,
 RRCConnectionReconfiguration_r8_IEs  *p_r8,
 OSCTXT                               *p_asn1_ctx
 );
void uecc_llim_fill_scell_config_for_ue_reconfig
(
 uecc_ue_context_t*             p_uecc_ue_context,
 rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 );
static void build_scell_config_for_uecc_modify_rollback(
        uecc_ue_context_t*                    p_ue_context,
        rrc_uecc_llim_modify_rollback_req_t*  p_rrc_uecc_llim_rollback_req);



/* TRACE_changes_start */
/* SPR 16113 Start */
/******************************************************************************
 *   FUNCTION NAME: uecc_rrc_ue_assoc_msg_max_trace_handler
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  U8                 *buffer, 
 *                  U32                buffer_len,
 *                  char               *msg_name
 *                  char               *protocol_name
 *   OUTPUTS      : None
 *   DESCRIPTION  : This function handles the UE Trace for UE messages.
 *   RETURNS:     : None
 *******************************************************************************/
void uecc_rrc_ue_assoc_msg_max_trace_handler( 
        uecc_ue_context_t  *p_ue_context, 
        U8                 *buffer, 
        U32                buffer_len,
        char               *msg_name,
        char               *protocol_name)
/* SPR 16113 Stop */
{
    U32 index = 0;


    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if (p_ue_context->m.traceActivated)
    {
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & UU) &&
                ((MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                 (MAXIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
        {
            P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), GEN_MME, "\n <msg function=\"Uu\" name=\"%s\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    msg_name, difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & UU) &&
                ((MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                 (MAXIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
        {
            P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), GEN_CELL, "\n <msg function=\"Uu\" name=\"%s\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    msg_name, difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        /* SPR 16113 Start */
        P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), UU, "<rawMsg protocol=\"%s\" version=\"001\">", protocol_name);
        /* SPR 16113 Stop */
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (PNULL != p_ue_context->p_ue_trace_activation_info) &&
                (PNULL != p_ue_context->p_ue_trace_activation_info->fp) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & UU) &&
                ((p_ue_context->p_ue_trace_activation_info->trace_depth == MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION) ||
                 (p_ue_context->p_ue_trace_activation_info->trace_depth == MAXIMUM)))
        {
            for (index = 0; index < buffer_len; index++)
            {
                fprintf_wrapper(p_ue_context->p_ue_trace_activation_info->fp, (const S8 *)"%02x", buffer[index]);
            }
        }
        if ((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) && 
                (PNULL != p_ue_context->p_ue_cell_trace_activation_info) &&
                (PNULL != p_ue_context->p_ue_cell_trace_activation_info->fp) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & UU) &&
                ((p_ue_context->p_ue_cell_trace_activation_info->trace_depth == MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION) ||
                 (p_ue_context->p_ue_cell_trace_activation_info->trace_depth == MAXIMUM)))
        {
            for (index = 0; index < buffer_len; index++)
            {
                fprintf_wrapper(p_ue_context->p_ue_cell_trace_activation_info->fp, (const S8 *)"%02x", buffer[index]);
            }
        }
        P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), UU," </rawMsg>\n </msg>");
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}
/* TRACE_changes_start */
/*SPR 15896 Fix Stop*/

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_ccch_data_ind
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : None
 *   RETURNS      : None
 *   DESCRIPTION  : This function processes LLIM UECC_LLIM_CCCH_DATA_IND message
 ******************************************************************************/
void uecc_llim_process_ccch_data_ind
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    rrc_uecc_llim_ccch_data_ind_t   *p_ccch_data_ind = PNULL;
    UL_CCCH_Message                 ul_ccch_message;
    OSCTXT                          asn1_ctx;
    LOCAL_RRC_ERROR_STRUCT          *p_local_rrc_error = PNULL;


    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_ccch_data_ind =
        (rrc_uecc_llim_ccch_data_ind_t *)((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_ccch_data_ind->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");

        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }
    /* Decode CCCH data from ASN1*/
    /*****************************/

    /* Init ASN1 context */
    if ( RT_OK != rtInitContext(&asn1_ctx) )
    {
        /* Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "uecc_llim_process_ccch_data_ind:"
                "ASN context initialization failed.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    do
    {
        /*get pointer on LLIM message body*/
        pu_setBuffer(&asn1_ctx, p_ccch_data_ind->data_buffer,
                p_ccch_data_ind->data_buffer_length, ASN_RRC_BUF_TYPE);

        if ( RT_OK != asn1PD_UL_CCCH_Message(&asn1_ctx, &ul_ccch_message) )
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "uecc_llim_process_ccch_data_ind: ASN decode failed.");

            p_local_rrc_error = rrc_mem_get(sizeof(LOCAL_RRC_ERROR_STRUCT));
            if (PNULL != p_local_rrc_error)
            {
                memset_wrapper(p_local_rrc_error, RRC_NULL,sizeof(LOCAL_RRC_ERROR_STRUCT));

                p_local_rrc_error->header.length = sizeof(LOCAL_RRC_ERROR_STRUCT);
                p_local_rrc_error->header.event_id = LOCAL_RRC_ERROR;
                p_local_rrc_error->EVENT_PARAM_RRC_ERROR_TYPE = 
                    EVENT_VALUE_RRC_ASN1_DECODE_ERROR; 
                p_local_rrc_error->EVENT_PARAM_L3MESSAGE_LENGTH = p_ccch_data_ind->
                    data_buffer_length;

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_local_rrc_error);
            }
            break;
        }
        else
        {
            rrc_asn1PrtToStr_UL_CCCH_Message(RRC_ASN,"UL_CCCH_Message",
                    &ul_ccch_message, "Message", p_ccch_data_ind->data_buffer,
                    p_ccch_data_ind->data_buffer_length);
        }

        /* Process encoded message */
        if ( (T_UL_CCCH_MessageType_c1 != ul_ccch_message.message.t)
                && (PNULL == ul_ccch_message.message.u.c1) )
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "uecc_llim_process_ccch_data_ind:"
                    "UL_CCCH_MessageType invalid field value.");
            break;
        }

        switch (ul_ccch_message.message.u.c1->t)
        {
            case T_UL_CCCH_MessageType_c1_rrcConnectionRequest:

                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_INFO, "RRC_MSG: RRCConnectionRequest %s",
                        change_data_to_str(p_ccch_data_ind->data_buffer_length, p_ccch_data_ind->data_buffer));

                /* Check message */
                if((PNULL==ul_ccch_message.message.u.c1->u.rrcConnectionRequest)
                        ||
                        (
                         T_RRCConnectionRequest_criticalExtensions_rrcConnectionRequest_r8
                         != ul_ccch_message.message.u.c1->u.rrcConnectionRequest->
                         criticalExtensions.t)
                        || (PNULL == ul_ccch_message.message.u.c1->
                            u.rrcConnectionRequest->criticalExtensions.u.
                            rrcConnectionRequest_r8) )
                {
                    /* Drop message */
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "uecc_llim_process_ccch_data_ind:"
                            "rrcConnectionRequest invalid field value.");
                    /* SPR 19658 Changes Start */
                    /* send UECC_LLIM_UE_CON_REJ_REQ(rrcConnectionReject) message to LLIM */
                    /* SPR 20007 : CID 110511 Fix Start */
                    if (PNULL != ul_ccch_message.message.u.c1->u.rrcConnectionRequest)
                    {
                        uecc_llim_build_and_send_rrc_connection_reject(
                                p_uecc_gb_context,
                                p_ccch_data_ind->rnti,
                                UECC_LTE_RRC_CONNECTION_REJECT_WAIT_TIME_FIELD_DEFAULT_VALUE,
                                ul_ccch_message.message.u.c1->u.rrcConnectionRequest->criticalExtensions.u.rrcConnectionRequest_r8->establishmentCause,
                                p_ccch_data_ind->cell_index,
                                OTHER_FAILURE,
                                0,
                                PNULL);
                    }
                    /* SPR 20007 : CID 110511 Fix End */
                    /* SPR 19658 Changes End */
                }
                else
                {
                    /* Get destination module id from the received message */

                    /* ASN context should be freed here */
                    if (RRC_SUCCESS != uecc_llim_process_ccch_rrcConnectionRequest(
                                p_uecc_gb_context,
                                p_ccch_data_ind->cell_index,
                                p_ccch_data_ind->rnti,
                                /* CLPC Start */
                                p_ccch_data_ind->timing_advance,
                                p_ccch_data_ind->sinr,
                                /* CLPC Stop */
                                ul_ccch_message.message.u.c1->u.rrcConnectionRequest->
                                criticalExtensions.u.rrcConnectionRequest_r8,
                                p_ccch_data_ind->data_buffer_length,
                                p_ccch_data_ind->data_buffer,
                                p_uecc_gb_context->uecc_module_id ))
                    {
                        /* No MME connection */
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,
                                "uecc_llim_process_ccch_data_ind: "
                                "RRCConnectionRequest processing failed");
                    }
                }
                break;

            case T_UL_CCCH_MessageType_c1_rrcConnectionReestablishmentRequest:

                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_INFO, "RRC_MSG: RRCConnectionReestablishmentRequest %s",
                        change_data_to_str(p_ccch_data_ind->data_buffer_length, p_ccch_data_ind->data_buffer));

                /* Check message */
                if ((PNULL == ul_ccch_message.message.u.c1->
                            u.rrcConnectionReestablishmentRequest)
                        ||
                        (
                         T_RRCConnectionReestablishmentRequest_criticalExtensions_rrcConnectionReestablishmentRequest_r8 
                         != ul_ccch_message.message.u.c1->u.
                         rrcConnectionReestablishmentRequest->
                         criticalExtensions.t)
                        || (PNULL == ul_ccch_message.message.u.c1->
                            u.rrcConnectionReestablishmentRequest->criticalExtensions.u.
                            rrcConnectionReestablishmentRequest_r8) )
                {
                    /* Drop message */
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "uecc_llim_process_ccch_data_ind:"
                            "rrcConnectionReestablishmentRequest invalid field value.");
                    /* SPR 19658 Changes Start */
                    /* send UECC_LLIM_UE_CON_RE_ESTABLISH_REJ_REQ
                     * (rrcConnectionReestablishmentReject) message to LLIM */
                    /* SPR 20007 : CID 110510 Fix Start */
                    if (PNULL != ul_ccch_message.message.u.c1->u.rrcConnectionReestablishmentRequest)
                    {
                        if (RRC_SUCCESS != uecc_llim_build_and_send_rrc_connection_reestablishment_reject(
                                    p_uecc_gb_context,
                                    p_ccch_data_ind->rnti,
                                    ul_ccch_message.message.u.c1->u.rrcConnectionReestablishmentRequest->
                                    criticalExtensions.u.rrcConnectionReestablishmentRequest_r8->reestablishmentCause,
                                    p_ccch_data_ind->cell_index,
                                    RRC_UECCMD_MODULE_ID)
                           )
                        {
                            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                    p_uecc_gb_context->facility_name, RRC_ERROR,
                                    "Fail to send the RRCConnectionReestablishmentReject to UE");
                        }
                    }
                    /* SPR 20007 : CID 110510 Fix End */
                    /* SPR 19658 Changes End */

                }
                else
                {
                    /* SPR 16149  Fix 6 Start */  
                    /* ASN context should be freed here */
                    if (RRC_SUCCESS != 
                            uecc_llim_process_ccch_rrcConnectionReestablishmentRequest(
                                p_uecc_gb_context,
                                p_ccch_data_ind->rnti,
                                ul_ccch_message.message.u.c1->u.
                                rrcConnectionReestablishmentRequest->
                                criticalExtensions.u.
                                rrcConnectionReestablishmentRequest_r8,
                                p_ccch_data_ind->data_buffer_length,
                                p_ccch_data_ind->data_buffer,
                                p_ccch_data_ind->cell_index,
                                p_ccch_data_ind->rnti_found))
                    /* SPR 16149  Fix 6 Stop */ 
                    {
                        /* No MME connection */
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,
                                "uecc_llim_process_ccch_data_ind:"
                                "RRCConnectionReestablishmentRequest"
                                "processing failed");
                    }

                }
                break;

            default:
                /* Drop message */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "uecc_llim_process_ccch_data_ind:"
                        "UL_CCCH_MessageType_c1 invalid field value.");
                break;
        }
    }
    while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_ccch_rrcConnectionRequest
 *   INPUT        : uecc_gb_context_t   *p_uecc_gb_context
 *                  rrc_cell_index_t            cell_index
 *                  rrc_rnti_t                  rnt
 *                  U16                         timing_advance
 *                  U8                          sinr
 *                  RRCConnectionRequest_r8_IEs *p_rrcConnectionRequest_r8
 *                  rrc_counter_t                buffer_length
 *                  U8                          *buffer
 *                  rrc_module_id_t             dst_module_id
 *   OUTPUT       : None
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *   DESCRIPTION  : This function processes RRCConnectionRequest message
 ******************************************************************************/
rrc_return_et uecc_llim_process_ccch_rrcConnectionRequest(
        uecc_gb_context_t           *p_uecc_gb_context,    /* UECC global context */
        rrc_cell_index_t            cell_index,            /* Cell Index */
        rrc_rnti_t                  rnti,                       /* UE rnti */
        U16                         timing_advance,            
        U8                          sinr,
        RRCConnectionRequest_r8_IEs *p_rrcConnectionRequest_r8,  /* UE message */
        rrc_counter_t                buffer_length,
        U8                          *buffer,
        rrc_module_id_t             dst_module_id)

{
    rrc_ue_index_t                  ue_index = RRC_NULL;
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_return_et                   result = RRC_FAILURE;
    U32 establishment_cause = 0;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER           *p_event_header = PNULL;
    LOCAL_RRC_CONN_SETUP_ATTEMPT_STRUCT *p_rrc_conn_setup_attempt = PNULL;

    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do {

        if(p_uecc_gb_context->p_p_csc_context == PNULL)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionRequest] Cell Context NULL");
            break;
        }
        if (PNULL != g_rrc_stats.p_rrc_stats)
        {
            /* update statistic after message receiving not in UECC FSM */
            RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_gb_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[cell_index].rrc_connection_related_stats.
                    rrc_connection_establishment.
                    rrc_connEstabAtt_cause[p_rrcConnectionRequest_r8->establishmentCause],
                    p_rrcConnectionRequest_r8->establishmentCause,
                    (RRC_ESTABLISHMENT_CAUSE_INDEX-1));

            RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_gb_context,
                    g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                    rrc_uecc_instance_stats[p_uecc_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[cell_index].
                    rrc_connection_related_stats.rrc_connection_establishment.
                    rrc_connEstabAtt_sum, p_rrcConnectionRequest_r8->establishmentCause,
                    (RRC_ESTABLISHMENT_CAUSE_INDEX-1));
        }

        /* Check MME connection presence */
        if (RRC_FALSE == p_uecc_gb_context->mme_connection_status)
        {
            /* No MME connection */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionRequest] MME connection isn't present - reject");
            break;
        }
        /* if cell delete is ongoing send RRC COnnection Reject message*/
        if(p_uecc_gb_context->p_p_csc_context != PNULL && 
                p_uecc_gb_context->p_p_csc_context[cell_index] != PNULL &&
                p_uecc_gb_context->p_p_csc_context[cell_index]->del_cell_ongoing == 1)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionRequest] Delete cell ongoing - reject");
            break;
        }

        /* SPR 6058 Fix Start */
        if( (PNULL != p_uecc_gb_context->p_p_csc_context) && 
                (PNULL != p_uecc_gb_context->p_p_csc_context[cell_index]) &&
                (PNULL != p_uecc_gb_context->p_p_csc_context[cell_index]->p_csc_init_setup_ind) )
        {
            /* SPR 18233 Fix Start */
            if (RRM_RRC_CELL_BARRED == p_uecc_gb_context->p_p_csc_context[cell_index]->
                    p_csc_init_setup_ind->sib_type_1_Info.cell_access_related_info.cell_barred ) 
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING, 
                               "[RRCConnectionRequest] Call"
                        " not allowed in Cell Barred State");
            /* SPR 18233 Fix Stop */
                break;
            }
        }

        /* SPR 6058 Fix End */

        /* allocate UE context */
        ue_index = uecc_ue_ctx_allocate( p_uecc_gb_context, dst_module_id );
        /* SPR:7018 start */ 
        if (( MAX_NUM_SUPPORTED_UE_PER_UECC == RRC_GET_UE_INDEX(ue_index)) ||
                (ue_index == p_uecc_gb_context->total_ue_supported))
            /* SPR:7018 stop */ 
        {
            /* UE context allocation fail */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionRequest] The UE context allocation failure "
                    "- reject");
            break;
        }

        /* init UE context variables, UECC FSM engine and Statistic engine */
        uecc_ue_ctx_init(p_uecc_gb_context, ue_index, rnti, cell_index);

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context, ue_index);


        if ((PNULL != p_ue_context) && (PNULL != p_ue_context->p_gb_context))
        {
            RRC_UE_START_TIME_PERFORMANCE_COUNTER(
                    p_ue_context, p_ue_context->ue_stats.ue_timer_stats[RRC_UE_RRC_CONN_SETUP_TIME],
                    RRC_UE_RRC_CONN_SETUP_TIME);

            /* Activate trace if cell trace is activated */
            if (RRC_TRUE == p_uecc_gb_context->p_p_csc_context[cell_index]->
                    cell_trace_ongoing)
            {
                if (PNULL != p_uecc_gb_context->p_p_csc_context[cell_index]->
                        p_cell_traffic_trace_info)
                {
                    /* Allocate memory to store trace activation control and
                     * configuration parameter */
                    /*SPR 15896 Fix Start*/
                    if (PNULL == (p_ue_context->p_ue_cell_trace_activation_info =
                                (ue_trace_activation_info_t*)
                                rrc_mem_get(sizeof(ue_trace_activation_info_t))))
                        /*SPR 15896 Fix Stop*/
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_FATAL, "[CELL TRAFFIC TRACE]"
                                "Memory Allocation Failed For %d UE_Index", ue_index);
                        /* SPR 20686 Fix Start */
                            uecc_ue_ctx_free(p_uecc_gb_context, ue_index);
                        /* SPR 20686 Fix End */
                        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
                        return result;
                    }
                    else
                    {
                        /*SPR 15896 Fix Start*/
                        memset_wrapper(p_ue_context->p_ue_cell_trace_activation_info, RRC_NULL,
                                sizeof(ue_trace_activation_info_t));

                        //Trace Change Start
                        /** Set trace activation flag */
                        p_ue_context->m.traceActivated |= RRC_TRACE_ACTIVATION_CELL_INITIATE;
                        /*SPR 15896 Fix Stop*/

                        /* trace reference and trace recording
                         * session reference */
                        uecc_generate_eutran_traceid(p_ue_context);
                        //Trace Change End

                        /* store interfaces to trace */
                        /*SPR 15896 Fix Start*/
                        p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace =
                            p_uecc_gb_context->p_p_csc_context[cell_index]->p_cell_traffic_trace_info->
                            interface_to_trace;

                        /* store trace depth */
                        p_ue_context->p_ue_cell_trace_activation_info->trace_depth =
                            (trace_depth_et)(p_uecc_gb_context->p_p_csc_context[cell_index]->
                                    p_cell_traffic_trace_info->trace_depth);

                        /* Copy trace collection entity info into Ue Context */
                        l3_memcpy_wrapper(&p_ue_context->p_ue_cell_trace_activation_info->
                                trace_collection_entity_info,
                                &p_uecc_gb_context->p_p_csc_context[cell_index]->p_cell_traffic_trace_info->
                                trace_collection_entity,
                                sizeof(p_uecc_gb_context->p_p_csc_context[cell_index]->p_cell_traffic_trace_info->
                                    trace_collection_entity));

                        /* Create Trace File */
                        uecc_generate_trace_file_name(p_ue_context,TRACE_OAM_INITIATED);

                        /*SPR 15896 Fix Stop*/
                    }
                }
            }
            /* Call UECC_UE_EVENT_RRC_EST_REQ event handler *
             * and pass API data to FSM. */
            /* WARNING. The uecc_event_queue_push_event can't be used here
             * because the stack variable is used for storing the API data
             * if cell delete is ongoing send RRC COnnection Reject message*/
            /*SPR 15896 Fix Start*/
            if (p_ue_context != NULL && p_ue_context->m.traceActivated) 
            {
                /*SPR 15875 Fix Start*/
                if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                        (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                        (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & UU) &&
                        ((MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                         (MAXIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
                {
                    P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), GEN_MME,"\n <msg function=\"Uu\" name=\"RRC CONNECTION REQUEST\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                            difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
                }
                if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                        (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                        (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & UU) &&
                        ((MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                         (MAXIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
                {
                    P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), GEN_CELL,"\n <msg function=\"Uu\" name=\"RRC CONNECTION REQUEST\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                            difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
                }

                rrc_trace_max_file_write(p_ue_context ,RRC_CONNECTION_REQUEST,buffer_length,buffer, UU);
            }
            /*SPR 15896 Fix Stop*/

            /*Generating Protocol Event LOCAL_RRC_CONN_SETUP_ATTEMPT */
            p_rrc_conn_setup_attempt = rrc_mem_get(sizeof(LOCAL_RRC_CONN_SETUP_ATTEMPT_STRUCT));
            if (PNULL != p_rrc_conn_setup_attempt)
            {
                memset_wrapper(p_rrc_conn_setup_attempt, RRC_NULL, 
                        sizeof(LOCAL_RRC_CONN_SETUP_ATTEMPT_STRUCT));

                p_rrc_conn_setup_attempt->header.length = 
                    (sizeof(LOCAL_RRC_CONN_SETUP_ATTEMPT_STRUCT));
                p_rrc_conn_setup_attempt->header.event_id = LOCAL_RRC_CONN_SETUP_ATTEMPT;

                if ((PNULL != p_ue_context->p_gb_context->p_p_csc_context) && 
                        (PNULL != p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]) && 
                        (PNULL != p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                         p_csc_init_setup_ind))
                {
                    l3_memcpy_wrapper(&p_rrc_conn_setup_attempt->header.EVENT_PARAM_CELL_ID, 
                            p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                            p_csc_init_setup_ind->sib_type_1_Info.cell_access_related_info.
                            cell_Id, sizeof(U32));
                }
                p_rrc_conn_setup_attempt->header.EVENT_PARAM_EUTRANCELL_FROID = 
                    p_rrc_conn_setup_attempt->header.EVENT_PARAM_CELL_ID;

                if (p_ue_context->m.mme_ue_id_present)
                {
                    p_rrc_conn_setup_attempt->header.EVENT_PARAM_MMES1APID = p_ue_context->mme_ue_id;
                }
                p_rrc_conn_setup_attempt->header.EVENT_PARAM_RAC_UE_REF = p_ue_context->s1ap_ue_id;

                if (p_rrcConnectionRequest_r8->ue_Identity.t == T_InitialUE_Identity_s_TMSI)
                {
                    p_rrc_conn_setup_attempt->EVENT_PARAM_INITIAL_UE_IDENTITY_TYPE = 
                        EVENT_VALUE_S_TMSI;
                }
                else
                {
                    p_rrc_conn_setup_attempt->EVENT_PARAM_INITIAL_UE_IDENTITY_TYPE =
                        EVENT_VALUE_RANDOM_VALUE;
                    l3_memcpy_wrapper(p_rrc_conn_setup_attempt->EVENT_PARAM_INITIAL_UE_IDENTITY,
                            p_rrcConnectionRequest_r8->ue_Identity.u.randomValue->data,
                            sizeof(p_rrcConnectionRequest_r8->ue_Identity.u.randomValue->data));
                }

                p_rrc_conn_setup_attempt->EVENT_PARAM_RRC_ESTABL_CAUSE = 
                    p_rrcConnectionRequest_r8->establishmentCause;

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_rrc_conn_setup_attempt);
            }

            /*Generating Protocol Event LOCAL_RRC_CONNECTION_REQUEST */
            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    buffer_length);

            if (PNULL != p_event_header)
            {
                memset_wrapper(p_event_header, RRC_NULL, (sizeof(EVENT_EXTERNAL_HEADER) +
                            buffer_length));
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + buffer_length),
                        LOCAL_RRC_CONNECTION_REQUEST,
                        MESSAGE_DIRECTION_RECEIVED);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)buffer,
                        buffer_length);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
            /* CLPC Start */

            p_ue_context->timing_advance = timing_advance;
            p_ue_context->sinr = sinr;

            /* CLPC Stop */


            uecc_fsm_process_event(
                    p_ue_context,
                    UECC_EV_RRC_CONNECTION_REQUEST,
                    p_rrcConnectionRequest_r8);
            result = RRC_SUCCESS;
        } 

    } while (0);

    if (RRC_SUCCESS != result)
    {
        /* TRACE_fix */
        establishment_cause = p_rrcConnectionRequest_r8->establishmentCause; 

        /* send UECC_LLIM_UE_CON_REJ_REQ(rrcConnectionReject) message to LLIM */
        uecc_llim_build_and_send_rrc_connection_reject(
                p_uecc_gb_context,
                rnti,
                UECC_LTE_RRC_CONNECTION_REJECT_WAIT_TIME_FIELD_DEFAULT_VALUE,
                establishment_cause,
                cell_index,
                OTHER_FAILURE,
                0,
                p_ue_context);/*CR 026 changes stop*/

        /*Actions:
         *  - release UE context if needed */
        /* BZ 8256 Fix Start */
        /* BUG_764_FIX Start */
        if ( (MAX_NUM_SUPPORTED_UE_PER_UECC != RRC_GET_UE_INDEX(ue_index)) &&
                (p_uecc_gb_context->total_ue_supported != ue_index) &&
                (PNULL != p_ue_context) )   
            /* BUG_764_FIX Stop */
            /* BZ 8256 Fix End */
        {
            uecc_ue_ctx_free(p_uecc_gb_context, ue_index);
        }
        /* TRACE_fix */


    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_ccch_rrcConnectionReestablishmentRequest
 *   INPUT        : rrc_rnti_t                  rnti
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  RRCConnectionReestablishmentRequest_r8_IEs *p_rrcConnectionReestablishmentRequest_r8
 *                  U16                         data_buffer_length
 *                  U8                          *p_data_buffer
 *                  rrc_cell_index_t            cell_index
 *   OUTPUT       : None
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *   DESCRIPTION  : This function processes RRCConnectionReestablishmentRequest message
 ******************************************************************************/
/* SPR 16149 Fix 6 Start */ 
rrc_return_et uecc_llim_process_ccch_rrcConnectionReestablishmentRequest(
        uecc_gb_context_t           *p_uecc_gb_context,    /* UECC global context */
        rrc_rnti_t                  rnti,                       /* UE rnti */
        RRCConnectionReestablishmentRequest_r8_IEs *p_rrcConnectionReestablishmentRequest_r8,  /* UE message */
        U16                         data_buffer_length,
        U8                          *p_data_buffer,
        rrc_cell_index_t            cell_index,
        U8                          rnti_found
        )
/* SPR 16149 Fix 6 Stop */ 
{
    uecc_ue_context_t               *p_ue_context = PNULL;
    ho_ongoing_ue_identity_search_node_t* p_ue_identity_st_node = PNULL;
    U32                            search_ue_identity = RRC_NULL;
    rrc_rnti_t                      crnti = RRC_NULL;
    rrc_return_et                   result = RRC_FAILURE;
    EVENT_EXTERNAL_HEADER           *p_event_header = PNULL;
    /*SPR_16680_START*/
    U16                             short_mac_i = RRC_NULL;
    U16                             senb_short_mac_i = RRC_NULL;
    /*SPR_16680_END*/
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    /*SPR_17121_START*/
    rrc_bool_et                     matching_ue_found = RRC_FALSE;
    /*SPR_17121_END*/


    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    /*SPR_17727_START*/
    /*SPR_18121_start*/
    /* Code Removed */
    /*SPR_18121_end*/
    /*SPR_17727_END*/

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_uecc_gb_context,
                cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "cell not active");

        /* send UECC_LLIM_UE_CON_RE_ESTABLISH_REJ_REQ
         * (rrcConnectionReestablishmentReject) message to LLIM */ 
        if (RRC_SUCCESS !=
                uecc_llim_build_and_send_rrc_connection_reestablishment_reject(
                    p_uecc_gb_context,
                    rnti,
                    p_rrcConnectionReestablishmentRequest_r8->reestablishmentCause,
                    cell_index, RRC_UECCMD_MODULE_ID))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name, RRC_ERROR,
                    "Fail to send the RRCConnectionReestablishmentReject to UE");
        }
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return RRC_FAILURE;
    }
    /* SPR 16149 Fix 6 Start */ 
    if(rnti_found)
     { 

        if (RRC_SUCCESS !=
            uecc_llim_build_and_send_rrc_connection_reestablishment_reject(
                p_uecc_gb_context,
                rnti,
                p_rrcConnectionReestablishmentRequest_r8->reestablishmentCause,
                cell_index, RRC_UECCMD_MODULE_ID))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_ERROR,
                "Fail to send the RRCConnectionReestablishmentReject to UE");
        }
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return RRC_FAILURE;
     }
    /* SPR 16149 Fix 6 Stop */ 
    do {
        if (PNULL != g_rrc_stats.p_rrc_stats)
        {
            /* Update the performace counter */
            RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_gb_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_gb_context->
                    offset_uecc_mod_id].rrc_uecc_cell_stats[cell_index].
                    rrc_connection_related_stats.rrc_connection_reestablishment.
                    rrc_connReEstabAtt_cause[p_rrcConnectionReestablishmentRequest_r8->
                    reestablishmentCause], p_rrcConnectionReestablishmentRequest_r8->
                    reestablishmentCause, (RRC_REESTABLISHMENT_CAUSE_INDEX-1));

            RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_gb_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_gb_context->
                    offset_uecc_mod_id].rrc_uecc_cell_stats[cell_index].
                    rrc_connection_related_stats.rrc_connection_reestablishment.
                    rrc_connReEstabAtt_sum, p_rrcConnectionReestablishmentRequest_r8->
                    reestablishmentCause, (RRC_REESTABLISHMENT_CAUSE_INDEX-1));
        }
        /* if cell delete is ongoing send RRC COnnection Reestablishment Reject message*/
        /*Coverity 108859 Fix Start*/
        if(p_uecc_gb_context->p_p_csc_context[cell_index]->del_cell_ongoing == 1)
        /*Coverity 108859 Fix Stop*/
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionReestablishmentRequest]:"
                    " Delete cell ongoing - reject");
            break;
        }
        crnti = p_rrcConnectionReestablishmentRequest_r8->ue_Identity.c_RNTI.
            data[0];
        crnti = (U16)(crnti << 8);
        crnti = (U16)(crnti | p_rrcConnectionReestablishmentRequest_r8->ue_Identity.c_RNTI.
                data[1]);
        /*SPR_16680_START*/
        rrc_unpack_U16(&senb_short_mac_i, p_rrcConnectionReestablishmentRequest_r8->ue_Identity.shortMAC_I.data);
        if (PNULL != p_uecc_gb_context->p_p_csc_context[cell_index]->
                p_csc_init_setup_ind)
        {
            /*SPR_16680_END*/
            /* It may be Re-establishment Req received for Ue whose 
             * HO ongoing at target eNB */
            search_ue_identity = 
                p_rrcConnectionReestablishmentRequest_r8->ue_Identity.physCellId;
            /* 16 MSb used for phyCellId in ue_identity */
            search_ue_identity = search_ue_identity <<16; 

            /* This identity is used to find ue for which HO is ongoing list
             * for which re-estabishment req is received */
            /* 16 LSb used for C-RNTI */
            search_ue_identity |= crnti;

            /*SPR_16680_START*/

            for(p_ue_identity_st_node = (ho_ongoing_ue_identity_search_node_t*)(st_get_first_node
                        ((const search_tree_t *)&(p_uecc_gb_context->ho_ongoing_ue_identity_search_tree))); 
                    p_ue_identity_st_node; 
                    p_ue_identity_st_node = (ho_ongoing_ue_identity_search_node_t*)(st_get_next_node
                        ((const search_tree_node_t *) p_ue_identity_st_node)))
            {
                if(p_ue_identity_st_node->ue_identity == search_ue_identity)
                {
                    p_ue_context = p_uecc_gb_context->ue_db.
                        ue_contexts[p_ue_identity_st_node->ue_index];
                    /* Matching Node found. So, quit from 'for' loop */
                    if ( (PNULL != p_ue_context) &&
                            (PNULL != p_ue_context->ho_info.p_ho_info) &&
                            (PNULL != p_ue_context->ho_info.p_ho_info->p_trg_ho_info) &&
                            (RRC_TRUE != p_ue_context->ho_info.p_ho_info->
                             p_trg_ho_info->is_rrc_conn_reconf_comp_recv))
                    {
                        /* Check shortMAC-I received in Re-establishment Req msg with
                         * targetCellshortMAC-I received during HO msg at target eNB */
                        if ( (X2_HO == p_ue_context->ho_info.s1_or_x2_handover) ||
                                (INTER_CELL_HO == p_ue_context->ho_info.s1_or_x2_handover) || 
                                (INTRA_CELL_HO == p_ue_context->ho_info.s1_or_x2_handover)) 
                        {
                            short_mac_i = p_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                                rrc_x2ap_ho_request.rrc_x2ap_ue_ctx_info.rRC_Container.
                                as_Context.reestablishmentInfo.targetCellShortMAC_I.data[0];
                            short_mac_i = (U16)(short_mac_i <<8);
                            short_mac_i = (U16)(short_mac_i | p_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                                    rrc_x2ap_ho_request.rrc_x2ap_ue_ctx_info.rRC_Container.
                                    as_Context.reestablishmentInfo.targetCellShortMAC_I.data[1]);
                        }
                        else
                        {
                            short_mac_i = p_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                                rrc_s1ap_ho_request.source_to_target_transparent_container.
                                source_enb_to_target_enb_transparent_container.rRC_Container.
                                as_Context.reestablishmentInfo.targetCellShortMAC_I.data[0];
                            short_mac_i = (U16)(short_mac_i <<8);
                            short_mac_i = (U16)(short_mac_i | p_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                                    rrc_s1ap_ho_request.source_to_target_transparent_container.
                                    source_enb_to_target_enb_transparent_container.rRC_Container.
                                    as_Context.reestablishmentInfo.targetCellShortMAC_I.data[1]);
                        }
                        /* X2AP FIX_HO_4 : End*/

                        /* Check with shortMAC-I received in HO msg */
                        if (senb_short_mac_i == short_mac_i)
                        {
                            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                    p_uecc_gb_context->facility_name,
                                    RRC_INFO,
                                    "ShortMAC-I verification : PASSED at TeNB for UE:%u", p_ue_context->ue_index);
                            /*SPR_17976_START*/
                            /* Code Removed*/
                            /*SPR_17976_END*/
                            /*SPR_17121_START*/
                            matching_ue_found = RRC_TRUE;
                            /*SPR_17121_END*/
                            break;
                        }
                        /*SPR_17121_START*/
                        else
                        {
                            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                    p_uecc_gb_context->facility_name,
                                    RRC_INFO,
                                    "ShortMAC-I verification FAILED for UE:%u at TeNB. "
                                    "Stored Short MAC-I = %u and "
                                    "Received Short MAC-I = %u",
                                    p_ue_context->ue_index, 
                                    short_mac_i, senb_short_mac_i);

                        }
                        /*SPR_17121_END*/
                    }
                }
            }
            /*SPR_16680_END*/
        }

        /*SPR_17121_START*/
        if (RRC_FALSE == matching_ue_found)
        {
            p_ue_context = PNULL;
            /*SPR_16680_START*/
            if ((PNULL != p_uecc_gb_context->p_p_csc_context[cell_index]->
                    p_csc_init_setup_ind) &&
                    (p_rrcConnectionReestablishmentRequest_r8->ue_Identity.
                    physCellId == p_uecc_gb_context->p_p_csc_context[cell_index]->
                    p_csc_init_setup_ind->phys_cell_id))
            {
                /* When Re-establishment Req received at sorce eNB */
                p_ue_context = uecc_ue_ctx_get_by_crnti(p_uecc_gb_context, crnti);
                if(p_ue_context)
                {
                    if ((((PNULL == p_ue_context->ho_info.p_ho_info) ||
                                    (PNULL == p_ue_context->ho_info.p_ho_info->p_trg_ho_info) ||
                                    (RRC_TRUE == p_ue_context->ho_info.p_ho_info->
                                     p_trg_ho_info->is_rrc_conn_reconf_comp_recv))))
                    {
                        if((U16)(p_ue_context->mac_i) == senb_short_mac_i)
                        {
                            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                    p_uecc_gb_context->facility_name,
                                    RRC_INFO,
                                    "ShortMAC-I verification : PASSED for UE:%u",
                                    p_ue_context->ue_index);
                        }
                        else
                        {
                            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                    p_uecc_gb_context->facility_name,
                                    RRC_INFO,
                                    "ShortMAC-I verification FAILED for UE:%u."
                                    " Stored Short MAC-I = %u and "
                                    "Received Short MAC-I = %u",
                                    p_ue_context->ue_index, 
                                    (U16)(p_ue_context->mac_i), senb_short_mac_i);
                            p_ue_context = PNULL;
                        }
                    }
                    else
                    {
                        p_ue_context = PNULL;
                    }
                }
                /*SPR_17121_END*/
            }
        }
            /*SPR_16680_END*/

        if (PNULL != p_ue_context && (p_ue_context->cell_index == cell_index))
        {
            /* meas changes start */
            /*Check for ongoing meas_reconfig procedure */
            if (RRC_TRUE == p_ue_context->is_meas_transaction_id_valid)
            {
                /* stop the meas config guard timer */
                uecc_ue_timer_stop(
                        p_uecc_gb_context,                         
                        UECC_UE_MEAS_CONFIG_GUARD_TIMER, 
                        &p_ue_context->timers_data);

                /* Reset the transaction-id */

                p_ue_context->is_meas_transaction_id_valid = RRC_FALSE;

                /*SPR 15304 Start*/
                /*Rollback the Measurement Gap Configuration at MAC*/

                if ((p_ue_context->p_meas_config) && (p_ue_context->
                            p_meas_config->bitmask & UE_ADM_MEAS_GAP_CONFIG_PRESENT))
                {
                    if (RRC_SUCCESS != uecc_llim_build_and_send_rollback_meas_config_req
                            (p_ue_context))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_ERROR,
                                "[UECC_LLIM_MEAS_CONFIG_REQ] Message sending failed .");
                        break;
                    }
                }
		    /*SPR 15304 Stop*/
                /* Build and send the RRC_RRM_MEAS_CONFIG_RESP(Failure) to RRM */
                if (RRC_SUCCESS != uecc_rrm_build_and_send_meas_config_resp(
                            p_ue_context,RRC_FAILURE, RRC_REESTABLISHMENT_TRIGGERED))
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "Failure to build and send meas config resp to RRM.");
                    break;
                }
            }
            /* meas changes end */

            /* Store crnti prior to Re-establishment in old_crnti 
             * in ue context */
            p_ue_context->old_crnti = p_ue_context->crnti;

            /* Update C-RNTI which is allocated by MAC during RACH procdure
             * for Re-establishment Req */ 
            p_ue_context->crnti = rnti;

            /* Store the Re_establishment cause for performance counter */
            p_ue_context->reestablishmentCause = 
                p_rrcConnectionReestablishmentRequest_r8->reestablishmentCause;

            /*Generating Protocol Event LOCAL_RRC_CONNECTION_RE_ESTABLISHMENT_REQUEST*/
            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    data_buffer_length);

            if (PNULL != p_event_header)
            {
                memset_wrapper(p_event_header, RRC_NULL, (sizeof(EVENT_EXTERNAL_HEADER) +
                            data_buffer_length));
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + data_buffer_length),
                        LOCAL_RRC_CONNECTION_RE_ESTABLISHMENT_REQUEST,
                        MESSAGE_DIRECTION_RECEIVED);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_data_buffer,
                        data_buffer_length);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }

            /*SPR 15896 Fix Start*/
            if (p_ue_context->m.traceActivated)
            {
                /*SPR 15875 Fix Start*/
                if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                        (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                        (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & UU))
                {
                    P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), GEN_MME,"\n<msg function=\"Uu\" name=\"RRC CONNECTION REESTABLISHMENT REQUEST\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                            difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
                }
                if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                        (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                        (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & UU))
                {
                    P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), GEN_CELL,"\n<msg function=\"Uu\" name=\"RRC CONNECTION REESTABLISHMENT REQUEST\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                            difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
                }

                /*SPR 15875 Fix Stop*/

                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask (),UU,"\n<ie name=\"cause\">%d</ie>\n</msg>",
                        p_rrcConnectionReestablishmentRequest_r8->reestablishmentCause);
                rrc_trace_max_file_write(p_ue_context, RRC_CONNECTION_REESTABLISHMENT_REQ, 
                        data_buffer_length , p_data_buffer, UU); 
                /*SPR 15896 Fix Stop*/
            }
            /*SPR_20106_START*/
            uecc_fsm_process_event(
                        p_ue_context,
                        UECC_EV_RRC_RE_ESTABLISH_REQ,
                        p_rrcConnectionReestablishmentRequest_r8);
            result = RRC_SUCCESS;
        }
            /*SPR_20106_END*/
        else
        {
    /*SPR_19695_FIX_START*/
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionReestablishmentRequest]:"
                    " Ue Context not Found by CRNTI [%u], PCI recvd[%u]", crnti, p_rrcConnectionReestablishmentRequest_r8->ue_Identity.physCellId);
    /*SPR_19695_FIX_STOP*/
        }
    } while (0);

    if (RRC_SUCCESS != result)
    {
        /* send UECC_LLIM_UE_CON_RE_ESTABLISH_REJ_REQ
         * (rrcConnectionReestablishmentReject) message to LLIM */ 
        if (RRC_SUCCESS !=
                uecc_llim_build_and_send_rrc_connection_reestablishment_reject(
                    p_uecc_gb_context,
                    rnti,
                    p_rrcConnectionReestablishmentRequest_r8->reestablishmentCause,
                    cell_index, RRC_UECCMD_MODULE_ID))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name, RRC_ERROR,
                    "Fail to send the RRCConnectionReestablishmentReject to UE");
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_create_ue_entity_resp
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : None
 *   RETURNS      : None
 *   DESCRIPTION  : This function processes LLIM UECC_LLIM_CREATE_UE_ENTITY_RESP message
 ******************************************************************************/
void uecc_llim_process_create_ue_entity_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_uecc_llim_create_ue_entity_resp_t*     p_llim_create_ue_entity_resp;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_create_ue_entity_resp =
        (rrc_uecc_llim_create_ue_entity_resp_t *)((U8*)p_api + RRC_API_HEADER_SIZE);

    /* SPR 14860 FIX START */
    /* Code Removed */
    /* SPR 14860 FIX END */
    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_create_ue_entity_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "UECC: UECC_LLIM_CREATE_UE_ENTITY_RESP: Wrong message size-ignore");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            p_llim_create_ue_entity_resp->ue_index);
    if ( PNULL == p_ue_context )
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING, "UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Check transaction_id */
    if (p_llim_create_ue_entity_resp->transaction_id !=
            uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /* Error. Invalid transaction id */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING, "Invalid transaction id.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_LLIM_CREATE_UE_ENTITY_RESP event handler in RCS FSM *
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_CREATE_UE_ENTITY_RESP,
            p_llim_create_ue_entity_resp);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/****************************************************************************************
 *   FUNCTION NAME   :   uecc_llim_process_srb_data_ind_rrcConnectionSetupComplete
 *
 *   DESCRIPTION     :   This function processes LLIM UECC_LLIM_SRB_DATA_IND message's 
 *                   	T_UL_DCCH_MessageType_c1_rrcConnectionSetupComplete case.
 *
 *   RETURNS         :   RRC_SUCCESS/RRC_FAILURE
 *
 *****************************************************************************************/
static rrc_return_et uecc_llim_process_srb_data_ind_rrcConnectionSetupComplete(
        UL_DCCH_Message               *p_ul_dcch_message,
        uecc_gb_context_t  		  *p_uecc_gb_context,
        uecc_ue_context_t*             p_ue_context, 
        rrc_uecc_llim_srb_data_ind_t*  p_srb_data_ind,
        EVENT_EXTERNAL_HEADER          **p_event_header,
        U32                            encoded_msg_len 
        )
{
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    rrc_return_et result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO,
            "RRC_MSG: RRCConnectionSetupComplete %s",
            change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer));
    if ( PNULL == p_ul_dcch_message->message.u.c1->
            u.rrcConnectionSetupComplete )
    {
        /* Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_SRB_DATA_IND] "
                "rrcConnectionSetupComplete invalid field value.");
    }
    else
    {
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,p_srb_data_ind->ue_index);

        if (PNULL != *p_event_header)
        {
            /*Generating Protocol Events */
            rrc_uecc_fill_protocol_event_params(p_ue_context,
                    *p_event_header,
                    (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                    LOCAL_RRC_CONNECTION_SETUP_COMPLETE,
                    MESSAGE_DIRECTION_RECEIVED);

            l3_memcpy_wrapper((void*)((U8*)*p_event_header +
                        sizeof(EVENT_EXTERNAL_HEADER)),
                    (const void*)p_srb_data_ind->data_buffer,
                    encoded_msg_len);

            rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, *p_event_header);
            *p_event_header = PNULL;
        }

        /*SPR 15896 Fix Start*/
        if((p_ue_context != PNULL) &&
                (p_ue_context->m.traceActivated))
        {
            /*SPR 15875 Fix Start*/
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                    (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                    (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & UU) &&
                    ((MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                     (MAXIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
            {
                P_RRC_TRACE(p_ue_context, set_maximum_bitmask (),GEN_MME,"\n <msg function=\"Uu\" name=\"RRC CONNECTION SETUP COMPLETE\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                        difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
            }
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                    (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                    (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & UU) &&
                    ((MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                     (MAXIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
            {
                P_RRC_TRACE(p_ue_context, set_maximum_bitmask (),GEN_CELL,"\n <msg function=\"Uu\" name=\"RRC CONNECTION SETUP COMPLETE\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                        difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
            }
            /*SPR 15875 Fix Stop*/

            rrc_trace_max_file_write(p_ue_context ,RRC_CONNECTION_SETUP_COMPLETE,
                    p_srb_data_ind->data_buffer_length,p_srb_data_ind->data_buffer, UU);
            /*SPR 15896 Fix Stop*/
        }			

        /* ASN context should be freed here */
        result = uecc_llim_process_dcch_rrcConnectionSetupComplete(
                p_uecc_gb_context,
                p_srb_data_ind->ue_index,
                p_ul_dcch_message->message.u.c1->
                u.rrcConnectionSetupComplete);
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_srb_data_ind_measurementReport
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_SRB_DATA_IND message's
 *	T_UL_DCCH_MessageType_c1_measurementReport case.
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
static rrc_return_et uecc_llim_process_srb_data_ind_measurementReport
(
 UL_DCCH_Message               *p_ul_dcch_message,
 uecc_gb_context_t  		  *p_uecc_gb_context,
 uecc_ue_context_t*             p_ue_context, 
 rrc_uecc_llim_srb_data_ind_t*  p_srb_data_ind,
 EVENT_EXTERNAL_HEADER          **p_event_header,
 U32                            encoded_msg_len 
 )
{
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    rrc_return_et result = RRC_SUCCESS;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO, "RRC_MSG: MeasurementReport %s",
            change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer));
    if (PNULL == p_ul_dcch_message->message.u.c1->u.measurementReport)
    {
        /* Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_SRB_DATA_IND] "
                "measurementReport invalid field value.");
    }
    else
    {
        /* ASN context should be freed here */
        result = uecc_llim_process_dcch_measurementReport(
                p_uecc_gb_context,
                p_srb_data_ind->ue_index,
                p_ul_dcch_message->message.u.c1->u.measurementReport);
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,p_srb_data_ind->ue_index);
        if (PNULL != *p_event_header)
        {
            /*Generating Protocol Events */
            rrc_uecc_fill_protocol_event_params(p_ue_context,
                    *p_event_header,
                    (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                    LOCAL_RRC_MEASUREMENT_REPORT,
                    MESSAGE_DIRECTION_RECEIVED);

            l3_memcpy_wrapper((void*)((U8*)*p_event_header +
                        sizeof(EVENT_EXTERNAL_HEADER)),
                    (const void*)p_srb_data_ind->data_buffer,
                    encoded_msg_len);

            rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, *p_event_header);
            *p_event_header = PNULL;
        }
        /*SPR 15896 Fix Start*/
        if((p_ue_context != PNULL) &&
                (p_ue_context->m.traceActivated))
        {
            /*SPR 15875 Fix Start*/
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                    (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                    (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & UU) &&
                    ((MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                     (MAXIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
            {
                P_RRC_TRACE(p_ue_context, set_maximum_bitmask (),GEN_MME,"\n <msg function=\"Uu\" name=\"MEASUREMENT REPORT\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                        difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
            }
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                    (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                    (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & UU) &&
                    ((MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                     (MAXIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
            {
                P_RRC_TRACE(p_ue_context, set_maximum_bitmask (),GEN_CELL,"\n <msg function=\"Uu\" name=\"MEASUREMENT REPORT\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                        difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
            }
            /*SPR 15875 Fix Stop*/

            rrc_trace_max_file_write(p_ue_context ,MEASUREMENT_REPORT,p_srb_data_ind->
                    data_buffer_length,p_srb_data_ind->data_buffer, UU);
            /*SPR 15896 Fix Stop*/
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/**********************************************************************************************
 *   FUNCTION NAME   :   uecc_llim_process_srb_data_ind_rrcConnectionReconfigurationComplete
 *
 *   DESCRIPTION     :   This function processes LLIM UECC_LLIM_SRB_DATA_IND for 
 *                   	rrcConnectionReconfigurationComplete message
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ************************************************************************************************/
static rrc_return_et uecc_llim_process_srb_data_ind_rrcConnectionReconfigurationComplete(
        UL_DCCH_Message                   *p_ul_dcch_message,
        uecc_gb_context_t  		          *p_uecc_gb_context,
        uecc_ue_context_t*                 p_ue_context, 
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind,
        EVENT_EXTERNAL_HEADER             **p_event_header,
        U32                                encoded_msg_len 
        )
{
    rrc_return_et result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO, "RRC_MSG: RRCConnectionReconfigurationComplete %s",
            change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer));

    if (PNULL == p_ul_dcch_message->message.u.c1->
            u.rrcConnectionReconfigurationComplete)
    {
        /* Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"[UECC_LLIM_SRB_DATA_IND] "
                "rrcConnectionReconfigurationComplete "
                "invalid field value.");
    }
    else
    {
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,p_srb_data_ind->ue_index);

        if ((PNULL != *p_event_header) && (PNULL != p_ue_context))
        {
            /*Generating Protocol Events */
            rrc_uecc_fill_protocol_event_params(p_ue_context,
                    *p_event_header,
                    (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                    LOCAL_RRC_CONNECTION_RECONFIGURATION_COMPLETE,
                    MESSAGE_DIRECTION_RECEIVED);

            l3_memcpy_wrapper((void*)((U8*)*p_event_header +
                        sizeof(EVENT_EXTERNAL_HEADER)),
                    (const void*)p_srb_data_ind->data_buffer,
                    encoded_msg_len);

            rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, *p_event_header);
            *p_event_header = PNULL;
        }
        /* TRACE_changes_start */
        if(PNULL != p_ue_context)
        {
            /* SPR 16113 Start */
            uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_srb_data_ind->data_buffer, 
                    p_srb_data_ind->data_buffer_length, "RRC Connection Reconfiguration Complete", RRC_UL_DCCH);
            /* SPR 16113 Stop */
        }
        /* TRACE_changes_start */
        /* ASN context should be freed here */
        result =    uecc_llim_process_dcch_rrcConnectionReconfigurationComplete(
                p_uecc_gb_context,
                p_srb_data_ind->ue_index,
                p_ul_dcch_message->message.u.c1->
                u.rrcConnectionReconfigurationComplete);            
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/**********************************************************************************************
 *   FUNCTION NAME   :   uecc_llim_process_srb_data_ind_ulInformationTransfer
 *   DESCRIPTION     :   This function processes LLIM UECC_LLIM_SRB_DATA_IND for 
 *                       ulInformationTransfer message
 *
 *   RETURNS         :   RRC_SUCCESS/RRC_FAILURE
 *
 ************************************************************************************************/
static rrc_return_et uecc_llim_process_srb_data_ind_ulInformationTransfer(
        UL_DCCH_Message                   *p_ul_dcch_message,
        uecc_gb_context_t  		          *p_uecc_gb_context,
        uecc_ue_context_t*                 p_ue_context, 
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind,
        EVENT_EXTERNAL_HEADER             **p_event_header,
        U32                                encoded_msg_len 
        )
{
    rrc_return_et result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO, "RRC_MSG: ULInformationTransfer %s",
            change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer));
    if (PNULL == p_ul_dcch_message->message.u.c1->
            u.ulInformationTransfer)
    {
        /* Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"[UECC_LLIM_SRB_DATA_IND] ulInformationTransfer "
                "invalid field value.");
    }
    else
    {
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,p_srb_data_ind->ue_index);

        if ((PNULL != *p_event_header) && (PNULL != p_ue_context))
        {
            /*Generating Protocol Events */
            rrc_uecc_fill_protocol_event_params(p_ue_context,
                    *p_event_header,
                    (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                    LOCAL_RRC_UL_INFORMATION_TRANSFER,
                    MESSAGE_DIRECTION_RECEIVED);

            l3_memcpy_wrapper((void*)((U8*)*p_event_header +
                        sizeof(EVENT_EXTERNAL_HEADER)),
                    (const void*)p_srb_data_ind->data_buffer,
                    encoded_msg_len);

            rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, *p_event_header);
            *p_event_header = PNULL;
        }
        /* TRACE_changes_start */
        if(PNULL != p_ue_context)
        {
            /* SPR 16113 Start */
            uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_srb_data_ind->data_buffer, 
                    p_srb_data_ind->data_buffer_length, "UL Information Transfer", RRC_UL_DCCH);
            /* SPR 16113 Stop */
        }
        /* TRACE_changes_start */
        /* ASN context should be freed here */
        result =  uecc_llim_process_dcch_ulInformationTransfer(
                p_uecc_gb_context,
                p_srb_data_ind->ue_index,
                p_ul_dcch_message->message.u.c1->
                u.ulInformationTransfer);
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}



/**********************************************************************************************
 *   FUNCTION NAME   :   uecc_llim_process_srb_data_ind_ueCapabilityInformation
 *   DESCRIPTION     :   This function processes LLIM UECC_LLIM_SRB_DATA_IND for 
 *                       ueCapabilityInformation message
 *
 *   RETURNS         :   RRC_SUCCESS/RRC_FAILURE
 *
 ************************************************************************************************/
static rrc_return_et uecc_llim_process_srb_data_ind_ueCapabilityInformation(
        UL_DCCH_Message                   *p_ul_dcch_message,
        uecc_gb_context_t  		          *p_uecc_gb_context,
        uecc_ue_context_t*                 p_ue_context, 
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind,
        EVENT_EXTERNAL_HEADER             **p_event_header,
        U32                                encoded_msg_len 
        )
{
    rrc_return_et result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO, "RRC_MSG: UECapabilityInformation %s",
            change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer));
    if (PNULL ==
            p_ul_dcch_message->message.u.c1->u.ueCapabilityInformation)
    {
        /* Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_SRB_DATA_IND] ueCapabilityInformation "
                "invalid field value.");
    }
    else
    {
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,p_srb_data_ind->ue_index);

        if ((PNULL != *p_event_header) && (PNULL != p_ue_context))
        {
            /*Generating Protocol Events */
            rrc_uecc_fill_protocol_event_params(p_ue_context,*p_event_header,
                    (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                    LOCAL_RRC_UE_CAPABILITY_INFORMATION,
                    MESSAGE_DIRECTION_RECEIVED);

            l3_memcpy_wrapper((void*)((U8*)*p_event_header +
                        sizeof(EVENT_EXTERNAL_HEADER)),
                    (const void*)p_srb_data_ind->data_buffer,
                    encoded_msg_len);

            rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, *p_event_header);
            *p_event_header = PNULL;
        }
        /* TRACE_changes_start */
        if(PNULL != p_ue_context)
        {
            /* SPR 16113 Start */
            uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_srb_data_ind->data_buffer, 
                    p_srb_data_ind->data_buffer_length, "UE Capability Information", RRC_UL_DCCH);
            /* SPR 16113 Stop */
        }
        /* TRACE_changes_start */
        /* ASN context should be freed here */
        result =  uecc_llim_process_dcch_ueCapabilityInformation(
                p_uecc_gb_context,
                p_srb_data_ind->ue_index,
                p_ul_dcch_message->message.u.c1->
                u.ueCapabilityInformation);
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/**********************************************************************************************
 *   FUNCTION NAME   :   uecc_llim_process_srb_data_ind_securityModeComplete
 *   DESCRIPTION     :   This function processes LLIM UECC_LLIM_SRB_DATA_IND for 
 *                       securityModeComplete message
 *
 *   RETURNS         :   RRC_SUCCESS/RRC_FAILURE
 *
 ************************************************************************************************/
static rrc_return_et uecc_llim_process_srb_data_ind_securityModeComplete(
        UL_DCCH_Message                   *p_ul_dcch_message,
        uecc_gb_context_t  		          *p_uecc_gb_context,
        uecc_ue_context_t*                 p_ue_context, 
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind,
        EVENT_EXTERNAL_HEADER             **p_event_header,
        U32                                encoded_msg_len 
        )
{
    rrc_return_et result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO, "RRC_MSG: SecurityModeComplete %s",
            change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer));
    if (PNULL ==
            p_ul_dcch_message->message.u.c1->u.securityModeComplete)
    {
        /* Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_SRB_DATA_IND] securityModeComplete "
                "invalid field value.");
    }
    else
    {
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,p_srb_data_ind->ue_index);

        if ((PNULL != *p_event_header) && (PNULL != p_ue_context))
        {
            /*Generating Protocol Events */
            rrc_uecc_fill_protocol_event_params(p_ue_context,
                    *p_event_header,
                    (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                    LOCAL_RRC_SECURITY_MODE_COMPLETE,
                    MESSAGE_DIRECTION_RECEIVED);

            l3_memcpy_wrapper((void*)((U8*)*p_event_header +
                        sizeof(EVENT_EXTERNAL_HEADER)),
                    (const void*)p_srb_data_ind->data_buffer,
                    encoded_msg_len);

            rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, *p_event_header);
            *p_event_header = PNULL;
        }
        /* TRACE_changes_start */
        if(PNULL != p_ue_context)
        {
            /* SPR 16113 Start */
            uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_srb_data_ind->data_buffer,
                    p_srb_data_ind->data_buffer_length, "Security Mode Complete", RRC_UL_DCCH);
            /* SPR 16113 Stop */
        }
        /* TRACE_changes_start */
        /* ASN context should be freed here */
        result =  uecc_llim_process_dcch_securityModeComplete(
                p_uecc_gb_context,
                p_srb_data_ind->ue_index,
                p_ul_dcch_message->message.u.c1->
                u.securityModeComplete);
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/**********************************************************************************************
 *   FUNCTION NAME   :   uecc_llim_process_srb_data_ind_securityModeFailure
 *   DESCRIPTION     :   This function processes LLIM UECC_LLIM_SRB_DATA_IND for 
 *                       securityModeFailure message
 *
 *   RETURNS         :   RRC_SUCCESS/RRC_FAILURE
 *
 ************************************************************************************************/
static rrc_return_et uecc_llim_process_srb_data_ind_securityModeFailure(
        UL_DCCH_Message                   *p_ul_dcch_message,
        uecc_gb_context_t  		          *p_uecc_gb_context,
        uecc_ue_context_t*                 p_ue_context, 
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind,
        EVENT_EXTERNAL_HEADER             **p_event_header,
        U32                                encoded_msg_len 
        )
{
    rrc_return_et result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO, "RRC_MSG: SecurityModeFailure %s",
            change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer));
    if (PNULL ==
            p_ul_dcch_message->message.u.c1->u.securityModeFailure)
    {
        /* Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_SRB_DATA_IND] securityModeFailure "
                "invalid field value.");
    }
    else
    {
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,p_srb_data_ind->ue_index);

        if ((PNULL != *p_event_header) && (PNULL != p_ue_context))
        {
            /*Generating Protocol Events */
            rrc_uecc_fill_protocol_event_params(p_ue_context,
                    *p_event_header,
                    (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                    LOCAL_RRC_SECURITY_MODE_FAILURE,
                    MESSAGE_DIRECTION_RECEIVED);

            l3_memcpy_wrapper((void*)((U8*)*p_event_header +
                        sizeof(EVENT_EXTERNAL_HEADER)),
                    (const void*)p_srb_data_ind->data_buffer,
                    encoded_msg_len);

            rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, *p_event_header);
            *p_event_header = PNULL;
        }
        /* TRACE_changes_start */
        if(PNULL != p_ue_context)
        {
            /* SPR 16113 Start */
            uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_srb_data_ind->data_buffer,
                    p_srb_data_ind->data_buffer_length, "Security Mode Failure", RRC_UL_DCCH);
            /* SPR 16113 Stop */
        }
        /* TRACE_changes_start */
        /* ASN context should be freed here */
        result =  uecc_llim_process_dcch_securityModeFailure(
                p_uecc_gb_context,
                p_srb_data_ind->ue_index,
                p_ul_dcch_message->message.u.c1->
                u.securityModeFailure);
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/**********************************************************************************************
 *   FUNCTION NAME   :   uecc_llim_process_srb_data_ind_rrcConnectionReestablishmentComplete
 *   DESCRIPTION     :   This function processes LLIM UECC_LLIM_SRB_DATA_IND for 
 *                       rrcConnectionReestablishmentComplete message
 *
 *   RETURNS         :   RRC_SUCCESS/RRC_FAILURE
 *
 ************************************************************************************************/
static rrc_return_et uecc_llim_process_srb_data_ind_rrcConnectionReestablishmentComplete(
        UL_DCCH_Message                   *p_ul_dcch_message,
        uecc_gb_context_t  		          *p_uecc_gb_context,
        uecc_ue_context_t*                 p_ue_context, 
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind,
        EVENT_EXTERNAL_HEADER             **p_event_header,
        U32                                encoded_msg_len 
        )
{
    rrc_return_et result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO, "RRC_MSG: RRCConnectionReestablishmentComplete %s",
            change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer));

    if (PNULL == p_ul_dcch_message->message.u.c1->
            u.rrcConnectionReestablishmentComplete)
    {
        /* Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_SRB_DATA_IND] "
                "rrcConnectionReestablishmentComplete"
                " invalid field value.");
    }
    else
    {
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,p_srb_data_ind->ue_index);

        if ((PNULL != *p_event_header) && (PNULL != p_ue_context))
        {
            /*Generating Protocol Events */
            rrc_uecc_fill_protocol_event_params(p_ue_context,
                    *p_event_header,
                    (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                    LOCAL_RRC_CONNECTION_RE_ESTABLISHMENT_COMPLETE,
                    MESSAGE_DIRECTION_RECEIVED);

            l3_memcpy_wrapper((void*)((U8*)*p_event_header +
                        sizeof(EVENT_EXTERNAL_HEADER)),
                    (const void*)p_srb_data_ind->data_buffer,
                    encoded_msg_len);

            rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, *p_event_header);
            *p_event_header = PNULL;
        }
        /* TRACE_changes_start */
        if(PNULL != p_ue_context)
        {
            /* SPR 16113 Start */
            uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_srb_data_ind->data_buffer,
                    p_srb_data_ind->data_buffer_length, "RRC Connection Reestablishment Complete", RRC_UL_DCCH);
            /* SPR 16113 Stop */
        }
        /* TRACE_changes_start */
        /* ASN context should be freed here */
        result =
            uecc_llim_process_dcch_rrcConnectionReestablishmentComplete(
                    p_uecc_gb_context,
                    p_srb_data_ind->ue_index,
                    p_ul_dcch_message->message.u.c1->
                    u.rrcConnectionReestablishmentComplete);
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/**********************************************************************************************
 *   FUNCTION NAME   :   uecc_llim_process_srb_data_ind_csfbParametersRequestCDMA2000
 *   DESCRIPTION     :   This function processes LLIM UECC_LLIM_SRB_DATA_IND for 
 *                       csfbParametersRequestCDMA2000e message
 *
 *   RETURNS         :   RRC_SUCCESS/RRC_FAILURE
 *
 ************************************************************************************************/
static rrc_return_et uecc_llim_process_srb_data_ind_csfbParametersRequestCDMA2000(
        UL_DCCH_Message                   *p_ul_dcch_message,
        uecc_gb_context_t  		          *p_uecc_gb_context,
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
        )
{
    rrc_return_et result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO, "RRC_MSG: CSFBParametersRequestCDMA2000 %s",
            change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer));
    if (PNULL == p_ul_dcch_message->message.u.c1->u.csfbParametersRequestCDMA2000)
    {
        /* Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_SRB_DATA_IND] csfbParametersRequestCDMA2000 "
                "invalid field value.");
    }
    else
    {
        /* ASN context should be freed here */
        result = uecc_llim_process_dcch_csfbParametersRequestCDMA2000(
                p_uecc_gb_context,
                p_srb_data_ind->ue_index,
                p_ul_dcch_message->message.u.c1->u.csfbParametersRequestCDMA2000,
                p_srb_data_ind);
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/**********************************************************************************************
 *   FUNCTION NAME   :   uecc_llim_process_srb_data_ind_ueInformationResponse_r9
 *   DESCRIPTION     :   This function processes LLIM UECC_LLIM_SRB_DATA_IND for 
 *                       ueInformationResponse_r9 message
 *
 *   RETURNS         :   RRC_SUCCESS/RRC_FAILURE
 *
 ************************************************************************************************/
static rrc_return_et uecc_llim_process_srb_data_ind_ueInformationResponse_r9(
        UL_DCCH_Message                   *p_ul_dcch_message,
        uecc_gb_context_t  		          *p_uecc_gb_context,
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
        )
{
    rrc_return_et result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO, "RRC_MSG: UEInformationResponse-r9 %s",
            change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer));

    if (PNULL == p_ul_dcch_message->message.u.c1->u.ueInformationResponse_r9)
    {
        /* Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_SRB_DATA_IND] ueInformation "
                "invalid field value.");
    }
    else
    {
        /* ASN context should be freed here */
        result =  uecc_llim_process_dcch_ueInformationResp(
                p_uecc_gb_context,
                p_srb_data_ind->ue_index,
                p_ul_dcch_message->message.u.c1->
                u.ueInformationResponse_r9,
                p_srb_data_ind);
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/**********************************************************************************************
 *   FUNCTION NAME   :   uecc_llim_process_srb_data_ind_ulHandoverPreparationTransfer
 *   DESCRIPTION     :   This function processes LLIM UECC_LLIM_SRB_DATA_IND for 
 *                       ulHandoverPreparationTransfer message
 *
 *   RETURNS         :   RRC_SUCCESS/RRC_FAILURE
 *
 ************************************************************************************************/
static rrc_return_et uecc_llim_process_srb_data_ind_ulHandoverPreparationTransfer(
        UL_DCCH_Message                   *p_ul_dcch_message,
        uecc_gb_context_t  		          *p_uecc_gb_context,
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
        )
{
    rrc_return_et result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO, "RRC_MSG: ULHandoverPreparationTransfer %s",
            change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer));

    if(PNULL == p_ul_dcch_message->message.u.c1->u.ulHandoverPreparationTransfer)
    {
        /*Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"[UECC_LLIM_SRB_DATA_IND]ulHandoverPreparationTransfer"
                " invalid field value.");
    }
    else
    {
        /* ASN context should be freed here*/
        result = uecc_llim_process_dcch_ulHandover_Preparation_Transfer(
                p_uecc_gb_context,
                p_srb_data_ind->ue_index,
                p_ul_dcch_message->message.u.c1->u.ulHandoverPreparationTransfer,
                p_srb_data_ind);
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
#ifdef ENDC_ENABLED
/*NR_DC Code Change Start*/
/****************************************************************************************
 *   FUNCTION NAME   :   uecc_llim_process_srb_data_ind_scgFailureInformationNR
 *
 *   DESCRIPTION     :   This function processes LLIM UECC_LLIM_SRB_DATA_IND message's 
 *                   	T_UL_DCCH_MessageType_messageClassExtension_c2_scgFailureInformationNR_r15
 *                   	case.
 *
 *   RETURNS         :   RRC_SUCCESS/RRC_FAILURE
 *
 *****************************************************************************************/
static rrc_return_et uecc_llim_process_srb_data_ind_scgFailureInformationNR(
        UL_DCCH_Message               *p_ul_dcch_message,
        uecc_gb_context_t  		  *p_uecc_gb_context,
        uecc_ue_context_t*             p_ue_context, 
        rrc_uecc_llim_srb_data_ind_t*  p_srb_data_ind
        )
{
    rrc_return_et result = RRC_FAILURE;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO,
            "RRC_MSG: scgFailureInformationNR-r15 %s",
            change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer));
    if ( PNULL == p_ul_dcch_message->message.u.messageClassExtension->u.c2->
            u.scgFailureInformationNR_r15 )
    {
        /* Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_SRB_DATA_IND] "
                "scgFailureInformationNR invalid field value.");
    }
    else
    {
        /* ASN context should be freed here */
        result = uecc_llim_process_dcch_scgFailureInformationNR_r15(
                p_uecc_gb_context,
                p_srb_data_ind->ue_index,
                p_ul_dcch_message->message.u.messageClassExtension->u.c2->
                u.scgFailureInformationNR_r15);
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/*NR_DC Code Change Stop*/
#endif
/****************************************************************************************
 *   FUNCTION NAME: uecc_llim_process_srb_data_ind_switch_cases
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_SRB_DATA_IND message 
 *       UL_DCCH_Message message_type
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************************/
static rrc_return_et uecc_llim_process_srb_data_ind_switch_cases
(
 UL_DCCH_Message               *p_ul_dcch_message,
 uecc_gb_context_t  		  *p_uecc_gb_context,
 rrc_uecc_llim_srb_data_ind_t*  p_srb_data_ind,
 EVENT_EXTERNAL_HEADER          **p_event_header,
 U32                            encoded_msg_len 
 )
{
    rrc_return_et result = RRC_SUCCESS;
    uecc_ue_context_t*     p_ue_context = PNULL;
#ifdef LTE_EMBMS_SUPPORTED
    void   *p_intrl_msg   = PNULL;
    rrc_size_t msg_api_length;

#endif
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
#ifdef ENDC_ENABLED
/*NR_DC Code Change Start*/
	if ( T_UL_DCCH_MessageType_c1 ==
            p_ul_dcch_message->message.t )
    {
/*NR_DC Code Change Stop*/
#endif

        switch (p_ul_dcch_message->message.u.c1->t)
        {

            case T_UL_DCCH_MessageType_c1_rrcConnectionSetupComplete:
            {
                result = uecc_llim_process_srb_data_ind_rrcConnectionSetupComplete(
                        p_ul_dcch_message,p_uecc_gb_context,
                        p_ue_context,p_srb_data_ind,p_event_header,encoded_msg_len);
                break;
            }
            case T_UL_DCCH_MessageType_c1_csfbParametersRequestCDMA2000:
            {
                result = uecc_llim_process_srb_data_ind_csfbParametersRequestCDMA2000(
                        p_ul_dcch_message,p_uecc_gb_context,p_srb_data_ind);
                break;
            }
            case T_UL_DCCH_MessageType_c1_measurementReport:
            {
                result = uecc_llim_process_srb_data_ind_measurementReport(p_ul_dcch_message,p_uecc_gb_context,
                        p_ue_context,p_srb_data_ind,p_event_header,encoded_msg_len);
                break;
            }
            case T_UL_DCCH_MessageType_c1_rrcConnectionReconfigurationComplete:
            {
                result = uecc_llim_process_srb_data_ind_rrcConnectionReconfigurationComplete(
                        p_ul_dcch_message,p_uecc_gb_context,
                        p_ue_context,p_srb_data_ind,p_event_header,encoded_msg_len);
                break;
            }
            case T_UL_DCCH_MessageType_c1_ulInformationTransfer:
            {
                result = uecc_llim_process_srb_data_ind_ulInformationTransfer(
                        p_ul_dcch_message,p_uecc_gb_context,
                        p_ue_context,p_srb_data_ind,p_event_header,encoded_msg_len);
                break;
            }
            case T_UL_DCCH_MessageType_c1_ueInformationResponse_r9:
            {
                result = uecc_llim_process_srb_data_ind_ueInformationResponse_r9(
                        p_ul_dcch_message,p_uecc_gb_context,p_srb_data_ind);
                break; 
            }
            case T_UL_DCCH_MessageType_c1_ueCapabilityInformation:
            {
                result = uecc_llim_process_srb_data_ind_ueCapabilityInformation(
                        p_ul_dcch_message,p_uecc_gb_context,
                        p_ue_context,p_srb_data_ind,p_event_header,encoded_msg_len);
                break; 
            }
            case T_UL_DCCH_MessageType_c1_securityModeComplete:
            {
                result = uecc_llim_process_srb_data_ind_securityModeComplete(
                        p_ul_dcch_message,p_uecc_gb_context,
                        p_ue_context,p_srb_data_ind,p_event_header,encoded_msg_len);
                break; 
            }
            case T_UL_DCCH_MessageType_c1_securityModeFailure:
            {
                result = uecc_llim_process_srb_data_ind_securityModeFailure(
                        p_ul_dcch_message,p_uecc_gb_context,
                        p_ue_context,p_srb_data_ind,p_event_header,encoded_msg_len);
                break; 
            }
            case T_UL_DCCH_MessageType_c1_rrcConnectionReestablishmentComplete:
            {
                result = uecc_llim_process_srb_data_ind_rrcConnectionReestablishmentComplete(
                        p_ul_dcch_message,p_uecc_gb_context,
                        p_ue_context,p_srb_data_ind,p_event_header,encoded_msg_len);
                break; 
            }
            case T_UL_DCCH_MessageType_c1_ulHandoverPreparationTransfer:
            {
                result = uecc_llim_process_srb_data_ind_ulHandoverPreparationTransfer(
                        p_ul_dcch_message,p_uecc_gb_context,p_srb_data_ind);
                break; 
            }
            case T_UL_DCCH_MessageType_c1_counterCheckResponse:
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_INFO, "RRC_MSG: CounterCheckResponse %s",
                        change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer));

                if (PNULL == p_ul_dcch_message->message.u.c1->
                        u.counterCheckResponse)
                {
                    /* Drop message */
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "[UECC_LLIM_SRB_DATA_IND] "
                            "counterCheckResponse"
                            " invalid field value.");
                }
                else
                {
                    /* ASN context should be freed here */
                    result  =   uecc_llim_process_dcch_counterCheckResponse(
                            p_uecc_gb_context,
                            p_srb_data_ind->ue_index,
                            p_ul_dcch_message->message.u.c1->
                            u.counterCheckResponse,
                            p_srb_data_ind);
                }
                break; 
            }
            case T_UL_DCCH_MessageType_c1_proximityIndication_r9:
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_INFO, "RRC_MSG: ProximityIndication-r9 %s",
                        change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer));
                if(PNULL == p_ul_dcch_message->message.u.c1->u.proximityIndication_r9)
                {
                    /*Drop message */
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,"[UECC_LLIM_SRB_DATA_IND]proximityIndication_r9"
                            " invalid field value.");
                }
                else
                {
                    /* ASN context should be freed here*/
                    result = uecc_llim_process_dcch_proximityIndication_r9(
                            p_uecc_gb_context,
                            p_srb_data_ind->ue_index,
                            p_ul_dcch_message->message.u.c1->u.proximityIndication_r9,
                            p_srb_data_ind);
                }
                break; 
            }
            case T_UL_DCCH_MessageType_c1_interFreqRSTDMeasurementIndication_r10:
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_INFO, "RRC_MSG: InterFreqRSTDMeasurementIndication-r10 %s",
                        change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer)); 
                if(PNULL == p_ul_dcch_message->message.u.c1->u.interFreqRSTDMeasurementIndication_r10)
                {
                    /*Drop message */
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,"[UECC_LLIM_SRB_DATA_IND]interFreqRSTDMeasurementIndication_r10"
                            " invalid field value.");
                }
                else
                {
                    /* ASN context should be freed here*/
                    result = uecc_llim_process_dcch_interFreqRstdMeasurement_r10(
                            p_uecc_gb_context,
                            p_srb_data_ind->ue_index,
                            p_ul_dcch_message->message.u.c1->u.interFreqRSTDMeasurementIndication_r10,
                            p_srb_data_ind);
                }
                break;
            }
#ifdef LTE_EMBMS_SUPPORTED
            case T_UL_DCCH_MessageType_c1_mbmsCountingResponse_r10:
            {

                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_INFO, "RRC_MSG:MBMS Counting Report %s",
                        change_data_to_str(p_srb_data_ind->data_buffer_length, p_srb_data_ind->data_buffer)); 
                msg_api_length =
                    (rrc_size_t)(sizeof(rrc_m2ap_mbms_counting_report_t) + RRC_API_HEADER_SIZE);
                /* Allocate buffer */
                p_intrl_msg = rrc_msg_mem_get(msg_api_length);
                /* CID fix 92851 ++ */
                if (PNULL != p_intrl_msg)
                {
                    memset_wrapper(p_intrl_msg, 0, msg_api_length);

                    /* Fill RRC header */
                    rrc_construct_api_header(p_intrl_msg,
                            RRC_VERSION_ID,
                            RRC_MODULE_ID,
                            M2AP_INTERNAL_MODULE_ID,
                            RRC_M2AP_MBMS_COUNTING_RESULT_IND,
                            (U16)msg_api_length);
                    /* Fill and send message */
                    rrc_m2ap_mbms_counting_report_t *rrc_m2ap_mbms_counting_report_p = 
                        (rrc_m2ap_mbms_counting_report_t *)((U8 *)p_intrl_msg +
                                RRC_API_HEADER_SIZE);
                    rrc_m2ap_mbms_counting_report_p->cell_index =
                        p_srb_data_ind->cell_index;
                    if(RRC_FAILURE == parse_mbms_counting_resp(p_ul_dcch_message,
                                &rrc_m2ap_mbms_counting_report_p->rrc_m2ap_mbms_counting_result_ind,
                                p_uecc_gb_context))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,
                                "[UECC_LLIM_SRB_DATA_IND] parsing of counting result"
                                "failed");
                    }

                    rrc_send_message(p_intrl_msg, M2AP_INTERNAL_MODULE_ID);
                }
                /* CID fix 92851 -- */

                break;
            }
#endif
            default:
            {
                /* Drop message */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[UECC_LLIM_SRB_DATA_IND] UL_DCCH_MessageType_c1 "
                        "invalid field value.");
                break;
            }
        }
#ifdef ENDC_ENABLED
        /*NR_DC Code Change Start*/
    }
    else if ( (T_UL_DCCH_MessageType_messageClassExtension ==
                p_ul_dcch_message->message.t)
                &&
                (T_UL_DCCH_MessageType_messageClassExtension_c2 ==
                 p_ul_dcch_message->message.u.messageClassExtension->t)
                &&
                (PNULL != p_ul_dcch_message->message.u.messageClassExtension->u.c2)
            )
    {
        switch (p_ul_dcch_message->message.u.messageClassExtension->u.c2->t)
        {
            case T_UL_DCCH_MessageType_messageClassExtension_c2_scgFailureInformationNR_r15:
            {
                result = uecc_llim_process_srb_data_ind_scgFailureInformationNR(
                        p_ul_dcch_message,
                        p_uecc_gb_context,
                        p_ue_context,
                        p_srb_data_ind);
                break;
            }

            default:
            {
                /* Drop message */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[UECC_LLIM_SRB_DATA_IND] UL_DCCH_MessageType_messageClassExtension "
                        "invalid field value.");
                break;
            }
        }
    }
    else
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "[UECC_LLIM_SRB_DATA_IND] UL_DCCH_MessageType "
                "invalid message type value.");
    }
    /*NR_DC Code Change Stop*/
#endif
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

#ifdef LTE_EMBMS_SUPPORTED
/********************************************************************************
 *   FUNCTION NAME: parse_mbms_counting_resp
 *   INPUT        : UL_DCCH_Message                      *p_ul_dcch_message
 *                  rrc_m2ap_mbms_counting_result_ind_t     
 *p_m2ap_mbms_counting_result_ind
 uecc_gb_context_t                    *p_uecc_gb_context
 *   OUTPUT       : p_m2ap_mbms_counting_result_ind filled with mbms counting response
 received from UE.
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *   DESCRIPTION  : This function parse mbms counting resp received from mce
 and fills rrc_m2ap_mbms_counting_result_ind_t
 ******************************************************************************/
    rrc_return_et  parse_mbms_counting_resp
(
 UL_DCCH_Message                        *p_ul_dcch_message,
 rrc_m2ap_mbms_counting_result_ind_t    *p_m2ap_mbms_counting_result_ind,
 uecc_gb_context_t                      *p_uecc_gb_context
 )
{
    rrc_return_et                       result = RRC_SUCCESS;
    MBMSCountingResponse_r10            *p_mbms_counting_resp = PNULL;
    MBMSCountingResponse_r10_IEs        *p_mbms_counting_resp_ies = PNULL;
    OSRTDListNode                       *p_node = PNULL;
    CountingResponseInfo_r10            *p_counting_resp_info = PNULL;
    U8                                  index = RRC_ZERO;
    U8                                  count = RRC_ZERO;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_mbms_counting_resp = 
        p_ul_dcch_message->message.u.c1->u.mbmsCountingResponse_r10;

    if (PNULL == p_mbms_counting_resp)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_FATAL,
                "UL_DCCH_MessageType_c1_u.mbmsCountingResponse_r10 is NULL");

        result = RRC_FAILURE;
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return result;
    }

    if ( T_MBMSCountingResponse_r10_criticalExtensions_c1 ==
            p_mbms_counting_resp->criticalExtensions.t)
    {

        if ( PNULL == 
                p_mbms_counting_resp->criticalExtensions.u.c1)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_FATAL,
                    "[mbmsCountingResponse_r10]"
                    "Invalid message format.");
            result = RRC_FAILURE;
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return result;

        }

        if ( T_MBMSCountingResponse_r10_criticalExtensions_c1_countingResponse_r10 
                == p_mbms_counting_resp->criticalExtensions.u.c1->t)
        {
            if ( PNULL ==
                    p_mbms_counting_resp->criticalExtensions.u.c1->u.countingResponse_r10)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_FATAL,
                        "[mbmsCountingResponse_r10]"
                        "Invalid message format.");
                result = RRC_FAILURE;
                RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
                return result;
            }

            p_mbms_counting_resp_ies = 
                p_mbms_counting_resp->criticalExtensions.u.c1->u.countingResponse_r10;

            if( p_mbms_counting_resp_ies->m.mbsfn_AreaIndex_r10Present == RRC_ONE)
            {
                p_m2ap_mbms_counting_result_ind->bitmask |=
                    MBSFN_AREA_INDEX_R10_PRESENT;

                if( (M2AP_MAX_SERVICE_COUNT - RRC_ONE) <
                        p_mbms_counting_resp_ies->mbsfn_AreaIndex_r10)
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_ERROR,
                            "Invalid mbsfn-AreaIndex");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
                    return result;

                }

                p_m2ap_mbms_counting_result_ind->mbsfn_area_index =
                    p_mbms_counting_resp_ies->mbsfn_AreaIndex_r10; 
            }

            if( p_mbms_counting_resp_ies->m.countingResponseList_r10Present == 
                    RRC_ONE)
            {
                p_m2ap_mbms_counting_result_ind->bitmask |=
                    COUNTING_RESPONSE_LIST_R10_PRESENT;

                count = p_mbms_counting_resp_ies->countingResponseList_r10.count;

                if (M2AP_MAX_SERVICE_COUNT < count)
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_ERROR,
                            "number of CountingResponseInfo are Invalid");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
                    return result;

                }

                p_m2ap_mbms_counting_result_ind->num_service_count = count;

                p_node = 
                    p_mbms_counting_resp_ies->countingResponseList_r10.head;

                /* parsing the each CountingResponseInfo and 
                 * if validation is successful then 
                 * Filling CountingResponseInfo into 
                 * m2ap_mbms_counting_result_ind */
                for (index = RRC_ZERO; index < count; index++)
                {
                    if(!p_node)
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_ERROR,
                                "CountingResponseInfo is not found");
                        result = RRC_FAILURE;
                        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
                        return result;
                    }

                    p_counting_resp_info =
                        (CountingResponseInfo_r10*)p_node->data;

                    if ( (M2AP_MAX_SERVICE_COUNT - RRC_ONE) < 
                            p_counting_resp_info->countingResponseService_r10)
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_ERROR,
                                "invalid countingResponseService-r10");
                        result = RRC_FAILURE;
                        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
                        return result;

                    }

                    p_m2ap_mbms_counting_result_ind->counting_service_id[index] =
                        p_counting_resp_info->countingResponseService_r10;

                    p_node = p_node->next;
                }

            }

        }

    }  
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
#endif

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_srb_data_ind
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : None
 *   RETURNS      : None
 *   DESCRIPTION  : This function processes LLIM UECC_LLIM_SRB_DATA_IND message
 ******************************************************************************/
void uecc_llim_process_srb_data_ind
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    rrc_uecc_llim_srb_data_ind_t*  p_srb_data_ind = PNULL;
    UL_DCCH_Message                ul_dcch_message;
    OSCTXT                         asn1_ctx;
    rrc_return_et                  result = RRC_SUCCESS;
    uecc_ue_context_t*             p_ue_context ;
    EVENT_EXTERNAL_HEADER          *p_event_header = PNULL;
    U32                            encoded_msg_len = 0;
    LOCAL_RRC_ERROR_STRUCT         *p_local_rrc_error = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_srb_data_ind =
        (rrc_uecc_llim_srb_data_ind_t *)((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_srb_data_ind->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Decode DCCH data from ASN1*/
    /*****************************/

    /* Init ASN1 context */
    if ( RT_OK != rtInitContext(&asn1_ctx) )
    {
        /* Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "[UECC_LLIM_SRB_DATA_IND] ASN context initialization failed.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    do
    {
        pu_setBuffer(&asn1_ctx, p_srb_data_ind->data_buffer,
                p_srb_data_ind->data_buffer_length, ASN_RRC_BUF_TYPE);

        if ( RT_OK != asn1PD_UL_DCCH_Message(&asn1_ctx, &ul_dcch_message) )
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[UECC_LLIM_SRB_DATA_IND] ASN decode failed.");

            p_local_rrc_error = rrc_mem_get(sizeof(LOCAL_RRC_ERROR_STRUCT));

            if (PNULL != p_local_rrc_error)
            {
                memset_wrapper(p_local_rrc_error, RRC_NULL,sizeof(LOCAL_RRC_ERROR_STRUCT));

                p_local_rrc_error->header.length = sizeof(LOCAL_RRC_ERROR_STRUCT);
                p_local_rrc_error->header.event_id = LOCAL_RRC_ERROR;

                p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context, p_srb_data_ind->ue_index);

                if (PNULL != p_ue_context)
                {
                    if ((PNULL != p_uecc_gb_context->p_p_csc_context) && (PNULL !=
                                p_uecc_gb_context->p_p_csc_context[p_ue_context->cell_index])
                            && (PNULL != p_uecc_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                                p_csc_init_setup_ind))
                    {
                        l3_memcpy_wrapper(&p_local_rrc_error->header.EVENT_PARAM_CELL_ID, p_ue_context->p_gb_context->
                                p_p_csc_context[p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                                cell_access_related_info.cell_Id, sizeof(U32));
                    }

                    p_local_rrc_error->header.EVENT_PARAM_EUTRANCELL_FROID = p_local_rrc_error->header.
                        EVENT_PARAM_CELL_ID;

                    if (p_ue_context->m.mme_ue_id_present)
                    {
                        p_local_rrc_error->header.EVENT_PARAM_MMES1APID = p_ue_context->mme_ue_id;
                    }

                    p_local_rrc_error->header.EVENT_PARAM_RAC_UE_REF = p_ue_context->s1ap_ue_id;
                }

                p_local_rrc_error->EVENT_PARAM_RRC_ERROR_TYPE = 
                    EVENT_VALUE_RRC_ASN1_DECODE_ERROR; 
                p_local_rrc_error->EVENT_PARAM_L3MESSAGE_LENGTH = p_srb_data_ind->
                    data_buffer_length;

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_local_rrc_error);
            }

            break;
        }
        else
        {
            /* Used for Protocol Events*/
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_UL_DCCH_Message(RRC_ASN, "UL_DCCH_Message",
                    &ul_dcch_message, "Message", p_srb_data_ind->data_buffer,
                    encoded_msg_len);
            
            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL == p_event_header)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_FATAL, "Memory Allocation Failed ");
                break;
            }
            memset_wrapper(p_event_header, RRC_NULL, (sizeof(EVENT_EXTERNAL_HEADER) +
                        encoded_msg_len));
        }
        /* Process encoded message */
        if ( !(
                ((T_UL_DCCH_MessageType_c1 == ul_dcch_message.message.t)
                    && (PNULL != ul_dcch_message.message.u.c1))
#ifdef ENDC_ENABLED
                /*NR_DC Code Change Start*/
		        ||
        	    ((T_UL_DCCH_MessageType_messageClassExtension == ul_dcch_message.message.t)
                    && (PNULL != ul_dcch_message.message.u.messageClassExtension))
                /*NR_DC Code Change Stop*/
#endif
              )
	        )
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[UECC_LLIM_SRB_DATA_IND] "
                    "UL_DCCH_MessageType invalid field value.");
            break;
        }
        result=uecc_llim_process_srb_data_ind_switch_cases(
                &ul_dcch_message,p_uecc_gb_context,
                p_srb_data_ind,&p_event_header,encoded_msg_len);
    }
    while(0);

    if (PNULL != p_event_header)
    {
        rrc_mem_free(p_event_header);
        p_event_header = PNULL;
    }

    if(RRC_SUCCESS != result)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "[UECC_LLIM_SRB_DATA_IND] process message failure occurred.");
    }

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_add_lc_resp
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : None
 *   RETURNS      : None
 *   DESCRIPTION  : This function processes LLIM UECC_LLIM_ADD_LC_RESP message
 ******************************************************************************/
void uecc_llim_process_add_lc_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_uecc_llim_add_lc_resp_t*    p_llim_add_lc_resp;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_add_lc_resp = (rrc_uecc_llim_add_lc_resp_t*)((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_add_lc_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_add_lc_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_ADD_LC_RESP] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context,p_llim_add_lc_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_ADD_LC_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Check transaction_id */
    if (p_llim_add_lc_resp->transaction_id !=
            uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /* Error. Invalid transaction id */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_ADD_LC_RESP] Invalid transaction id.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_RM_EVENT_LLIM_RECONFIG_UE_RESP event handler in RM FSM *
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_RECONFIGURE_UE_RESP,
            p_llim_add_lc_resp);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/* Measurment Re-config START */ 
/******************************************************************************
 *   FUNCTION NAME: uecc_update_MeasConfig_in_ics_complete
 *   INPUT        : rrm_meas_config_t*  p_rrm_meas_config
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  uecc_ue_curr_meas_config_t*  p_ue_curr_meas_config
 *   OUTPUT       : None
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *   DESCRIPTION  : This function builds MeasConfig field in RRCConnectionReconfiguration
 *                  message
 ******************************************************************************/
rrc_return_et uecc_update_MeasConfig_in_ics_complete(
        rrm_meas_config_t*  p_rrm_meas_config,
        uecc_ue_curr_meas_config_t*  p_ue_curr_meas_config,
        uecc_gb_context_t*       p_uecc_gb_context  /* UECC global context */
        )
{
    rrc_return_et       result = RRC_FAILURE;
    uecc_meas_object_to_add_mod_t*  p_curr_meas_config = PNULL;
    U8 list_idx = RRC_NULL;
    /* SPR 15905 Fix Delete Start */
    /* SPR 15905 Fix Delete Stop */
    uecc_report_config_to_add_mod_t* p_report_config = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_meas_config);

    do
    {
        /* MeasObjectToAddModList */
        if (UE_ADM_MEAS_OBJECT_TO_ADD_MOD_LIST_PRESENT &
                p_rrm_meas_config->bitmask)
        {
            for(
                    list_idx=0;
                    list_idx < p_rrm_meas_config->meas_object_to_add_mod_list.count;
                    list_idx++)
            {
                p_curr_meas_config = (uecc_meas_object_to_add_mod_t*)
                    rrc_mem_get(sizeof(uecc_meas_object_to_add_mod_t));
                //memset_wrapper(p_curr_meas_config, RRC_NULL, sizeof(uecc_meas_object_to_add_mod_t));
                if (PNULL == p_curr_meas_config)
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_FATAL, "Memory Allocation Failed ");
                    result = RRC_FAILURE;
                    break;
                }
                memset_wrapper (p_curr_meas_config, RRC_NULL, sizeof(uecc_meas_object_to_add_mod_t));
                p_curr_meas_config->meas_object_id = 
                    p_rrm_meas_config->meas_object_to_add_mod_list.meas_object_to_add_mod[list_idx].meas_object_id;

                result = uecc_rrc_update_curr_MeasobjectToAddMod (
                        p_curr_meas_config,
                        &p_rrm_meas_config->meas_object_to_add_mod_list.
                        meas_object_to_add_mod[list_idx],
                        p_uecc_gb_context);        

                if (result == RRC_FAILURE)
                {
                    /* Coverity Fix 63285 Start */
                    if (PNULL != p_curr_meas_config)
                    {
                        rrc_mem_free(p_curr_meas_config);
                        p_curr_meas_config = PNULL;
                    }
                    /* Coverity Fix 63285 Stop */
                    break;
                }

                ylPushTail(&p_ue_curr_meas_config->curr_meas_object_to_add_mod_list,
                        (YLNODE*)p_curr_meas_config);    

            }
            p_ue_curr_meas_config->m.curr_meas_object_to_add_mod_list_present = 1;
        }

        /* ReportConfigToAddModList */
        if (UE_ADM_MEAS_REPORT_CONFIG_TO_ADD_MOD_LIST_PRESENT &
                p_rrm_meas_config->bitmask)
        {

            for(
                    list_idx=0;
                    list_idx < p_rrm_meas_config->report_config_to_add_mod_list.count;
                    list_idx++)
            {
                p_report_config = (uecc_report_config_to_add_mod_t*)
                    rrc_mem_get(sizeof(uecc_report_config_to_add_mod_t));

                if (p_report_config == PNULL)
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_FATAL, "Memory Allocation Failed ");
                    result = RRC_FAILURE;
                    break;
                }
                p_report_config->report_config_id = 
                    p_rrm_meas_config->report_config_to_add_mod_list.report_config_to_add_mod[list_idx].report_config_id;

                l3_memcpy_wrapper(&p_report_config->report_config, 
                        &p_rrm_meas_config->report_config_to_add_mod_list.report_config_to_add_mod[list_idx].report_config,
                        sizeof(report_config_to_add_mod_report_config_t));

                ylPushTail(&p_ue_curr_meas_config->curr_report_config_to_add_mod_list,
                        (YLNODE*)p_report_config);    

            }

            p_ue_curr_meas_config->m.curr_meas_report_config_to_add_mod_list_present = 1; 

        }

        /* MeasIdToAddModList */
        if (UE_ADM_MEAS_ID_TO_ADD_MOD_LIST_PRESENT &
                p_rrm_meas_config->bitmask)
        {
            /* SPR 15905 Fix Start */
            result = uecc_rrc_update_MeasIdToAddModList_to_CurrMeasConfigList(
                    p_rrm_meas_config,
                    p_ue_curr_meas_config,
                    p_uecc_gb_context);
            if ( result == RRC_FAILURE )
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,"[uecc_update_MeasConfig_in_ics_complete]: Update Meas Id failed.");
                break;
            }
            /* SPR 15905 Fix Stop */
            p_ue_curr_meas_config->m.curr_meas_id_to_add_mod_list_present = 1;

        }
        /* QuantityConfig */
        if (UE_ADM_MEAS_QUANTITY_CONFIG_PRESENT &
                p_rrm_meas_config->bitmask)
        {
            p_ue_curr_meas_config->curr_quantity_config = 
                p_rrm_meas_config->quantity_config;
            p_ue_curr_meas_config->m.curr_meas_quantity_config_present = 1; 
        }

        /* MeasGapConfig */
        if (UE_ADM_MEAS_GAP_CONFIG_PRESENT & p_rrm_meas_config->bitmask)
        {
            p_ue_curr_meas_config->curr_meas_gap_config = 
                p_rrm_meas_config->meas_gap_config;
            p_ue_curr_meas_config->m.curr_meas_gap_config_present = 1;
        }

        /* RSRP_Range */
        if (UE_ADM_MEAS_S_MEASURE_PRESENT & p_rrm_meas_config->bitmask)
        {
            p_ue_curr_meas_config->curr_s_measure = 
                p_rrm_meas_config->s_measure;
            p_ue_curr_meas_config->m.curr_meas_s_measure_present = 1;
        }

        /* PreRegistrationInfoHRPD */
        if (UE_ADM_MEAS_PRE_REGISTRATION_INFO_PRESENT &
                p_rrm_meas_config->bitmask)
        {
            p_ue_curr_meas_config->curr_pre_registration_info_hrpd = 
                p_rrm_meas_config->pre_registration_info_hrpd;
            p_ue_curr_meas_config->m.curr_meas_pre_registration_info_present = 1;
        }

        /* MeasConfig_speedStatePars */
        if (UE_ADM_MEAS_SPEED_STATE_PARS_PRESENT & p_rrm_meas_config->bitmask)
        {
            p_ue_curr_meas_config->curr_meas_config_speed_state_pars = 
                p_rrm_meas_config->meas_config_speed_state_pars;
            p_ue_curr_meas_config->m.curr_meas_speed_state_pars_present = 1;
        }

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/* Measurment Re-config END */


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_rrcConnectionSetupComplete
 *   INPUT        : rrc_ue_index_t      ue_index
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  RRCConnectionSetupComplete *rrcConnectionSetupComplete
 *   OUTPUT       : None
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *   DESCRIPTION  : This function processes RRCConnectionSetupComplete message
 ******************************************************************************/
rrc_return_et uecc_llim_process_dcch_rrcConnectionSetupComplete(
        uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
        rrc_ue_index_t      ue_index,           /* UE index  */
        RRCConnectionSetupComplete *rrcConnectionSetupComplete  /* UE message */
        )
{
    uecc_ue_context_t*                  p_ue_context = PNULL;
    rrc_return_et                       result = RRC_FAILURE;
    RRCConnectionSetupComplete_r8_IEs*  p_rrcConnectionSetupComplete_r8 = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        /* Check message */
        if ( (T_RRCConnectionSetupComplete_criticalExtensions_c1 !=
                    rrcConnectionSetupComplete->criticalExtensions.t)
                || (PNULL==rrcConnectionSetupComplete->criticalExtensions.u.c1) ||
                (
                 T_RRCConnectionSetupComplete_criticalExtensions_c1_rrcConnectionSetupComplete_r8
                 !=rrcConnectionSetupComplete->criticalExtensions.u.c1->t)
                || (PNULL == rrcConnectionSetupComplete->criticalExtensions.u.c1->
                    u.rrcConnectionSetupComplete_r8))
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionSetupComplete] Invalid message format.");
            break;
        }
        /* Get pointer on message data */
        p_rrcConnectionSetupComplete_r8 =
            rrcConnectionSetupComplete->criticalExtensions.u.c1->
            u.rrcConnectionSetupComplete_r8;


        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionSetupComplete] UE context not found.");
            break;
        }

        /* Check RRC_TransactionIdentifier rrc_TransactionIdentifier */
        if (rrcConnectionSetupComplete->rrc_TransactionIdentifier !=
                (uecc_ue_ctx_get_op_transction_id(p_ue_context) &
                 UECC_LTE_RRC_TRANSACTION_ID_MASK) )
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionSetupComplete] Invalid transaction id.");
            break;
        }
        if(p_rrcConnectionSetupComplete_r8->m.nonCriticalExtensionPresent && 
                p_rrcConnectionSetupComplete_r8->nonCriticalExtension.m.nonCriticalExtensionPresent) 
        {
            p_ue_context->rlf_proc_flags.m.rrc_conn_setup_reconfigure_rlf_info_present = 
                p_rrcConnectionSetupComplete_r8->nonCriticalExtension.nonCriticalExtension.m.rlf_InfoAvailable_r10Present;
        }
        /* Call UECC_RCS_EVENT_RRC_CONN_SETUP_COMP event handler in RCS FSM *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRC_CONNECTION_SETUP_COMPLETE,
                rrcConnectionSetupComplete);

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}


/* SPR 1643 Start */
/****************************************************************************
 * Function Name  : validate_meas_results_plmn_identity
 * Inputs         : p_measResultNeighCells pointer points to
 *                  measurement results of neighbouring cells recived in
 *                  Measurement report.
 *                  uecc_gb_context_t       *p_uecc_gb_context
 * Outputs        : None
 * Returns        : RRC_SUCCESS/RRC_FAILURE
 * Description    : This function validates PLMN identiy range
 *                  received in Measurement report.
 ****************************************************************************/
static rrc_return_et validate_meas_results_plmn_identity(
        MeasResults_measResultNeighCells  *p_measResultNeighCells,
        uecc_gb_context_t       *p_uecc_gb_context        /* UECC global context */
        )
{
    OSRTDListNode*      p_node      = PNULL;
    OSRTDListNode*      p_plmn_node = PNULL;
    U8 list_count = 0;
    U8 count      = 0;


    switch(p_measResultNeighCells->t) 
    {
        case T_MeasResults_measResultNeighCells_measResultListEUTRA:
            /* measResultListEUTRA */
            p_node = p_measResultNeighCells->
                u.measResultListEUTRA->head;

            for (list_count = 0;
                    list_count < (U8)(p_measResultNeighCells->u.
                        measResultListEUTRA->count);
                    list_count++)
            {
                RRC_ASSERT(PNULL != p_node);
                RRC_ASSERT(PNULL != p_node->data);

                if (1 == ((MeasResultEUTRA *)p_node->data)->m.cgi_InfoPresent)
                {
                    /* CellGlobalIdEUTRA */
                    if (RRC_FAILURE == is_valid_mcc_mnc(&((MeasResultEUTRA
                                        *)p_node->data)->
                                cgi_Info.cellGlobalId.plmn_Identity))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,
                                "[validate_meas_results_plmn_identity]"
                                "MCC/MNC Range Check Fail -"
                                "measResultListEUTRA - CellGlobalIdEUTRA");
                        return RRC_FAILURE;
                    }

                    /* plmn-IdentityList */
                    if (1 == ((MeasResultEUTRA *)p_node->data)->
                            cgi_Info.m.plmn_IdentityListPresent)
                    {
                        p_plmn_node = ((MeasResultEUTRA *)p_node->data)->
                            cgi_Info.plmn_IdentityList.head;

                        for (count = 0;
                                count < (U8)(((MeasResultEUTRA *)p_node->data)->
                                    cgi_Info.plmn_IdentityList.count);
                                count++)
                        {
                            RRC_ASSERT(PNULL != p_plmn_node);
                            RRC_ASSERT(PNULL != p_plmn_node->data);

                            if (RRC_FAILURE == is_valid_mcc_mnc(((PLMN_Identity
                                                *)p_plmn_node->data)))
                            {
                                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                        p_uecc_gb_context->facility_name,
                                        RRC_WARNING,
                                        "[validate_meas_results_plmn_identity]"
                                        " MCC/MNC Range Fail -"
                                        "measResultListEUTRA - plmn-IdentityList");
                                return RRC_FAILURE;
                            }
                            p_plmn_node = p_plmn_node->next;

                        }
                    }
                }
                p_node = p_node->next;
            }
            break;
        case T_MeasResults_measResultNeighCells_measResultListUTRA:

            /* measResultListUTRA */
            p_node = p_measResultNeighCells->
                u.measResultListUTRA->head;

            for (list_count = 0;
                    list_count < (U8)(p_measResultNeighCells->u.
                        measResultListUTRA->count);
                    list_count++)
            {
                RRC_ASSERT(PNULL != p_node);
                RRC_ASSERT(PNULL != p_node->data);

                if (1 == ((MeasResultUTRA *)p_node->data)->m.cgi_InfoPresent)
                {
                    /* CellGlobalIdUTRA */
                    if (RRC_FAILURE == is_valid_mcc_mnc(&((MeasResultUTRA
                                        *)p_node->data)->
                                cgi_Info.cellGlobalId.plmn_Identity))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,
                                "[validate_meas_results_plmn_identity] "
                                "MCC/MNC Range Fail -"
                                "measResultListUTRA - CellGlobalIdUTRA");
                        return RRC_FAILURE;
                    }

                    /* plmn-IdentityList */
                    if (1 == ((MeasResultUTRA *)p_node->data)->
                            cgi_Info.m.plmn_IdentityListPresent)
                    {
                        p_plmn_node = ((MeasResultUTRA *)p_node->data)->
                            cgi_Info.plmn_IdentityList.head;

                        for (count = 0;
                                count < (U8)(((MeasResultUTRA *)p_node->data)->
                                    cgi_Info.plmn_IdentityList.count);
                                count++)
                        {
                            RRC_ASSERT(PNULL != p_plmn_node);
                            RRC_ASSERT(PNULL != p_plmn_node->data);

                            if (RRC_FAILURE == is_valid_mcc_mnc(((PLMN_Identity
                                                *)p_plmn_node->data)))
                            {
                                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                        p_uecc_gb_context->facility_name,
                                        RRC_WARNING,
                                        "[validate_meas_results_plmn_identity]"
                                        "MCC/MNC Range Fail -"
                                        "measResultListUTRA - plmn-IdentityList");
                                return RRC_FAILURE;
                            }
                            p_plmn_node = p_plmn_node->next;

                        }
                    }
                }
                p_node = p_node->next;
            }
            break;
        case T_MeasResults_measResultNeighCells_measResultListGERAN:

            /* measResultListGERAN */
            p_node = p_measResultNeighCells->
                u.measResultListGERAN->head;

            for (list_count = 0;
                    list_count < (U8)(p_measResultNeighCells->u.
                        measResultListGERAN->count);
                    list_count++)
            {
                RRC_ASSERT(PNULL != p_node);
                RRC_ASSERT(PNULL != p_node->data);

                if (1 == ((MeasResultGERAN *)p_node->data)->m.cgi_InfoPresent)
                {
                    /* CellGlobalIdGERAN */
                    if (RRC_FAILURE == is_valid_mcc_mnc(&((MeasResultGERAN
                                        *)p_node->data)->
                                cgi_Info.cellGlobalId.plmn_Identity))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,
                                "[validate_meas_results_plmn_identity] "
                                "MCC/MNC Range Fail -"
                                "measResultListGERAN - CellGlobalIdGERAN");
                        return RRC_FAILURE;
                    }
                }
                p_node = p_node->next;
            }
            break;
        default:
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"MeasResults_measResultNeighCells: "
                    "EUTRA/UTRA/GERAN not Present to validate PLMN id !!");
            break;

    }
    return RRC_SUCCESS;
}
/* SPR 1643 End */


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_rrcConnectionReestablishmentComplete
 *   INPUT        : rrc_ue_index_t      ue_index
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  RRCConnectionSetupComplete *rrcConnectionSetupComplete
 *   OUTPUT       : None
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *   DESCRIPTION  : This function processes RRCConnectionReestablishmentComplete message
 ******************************************************************************/
rrc_return_et uecc_llim_process_dcch_rrcConnectionReestablishmentComplete(
        uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
        rrc_ue_index_t      ue_index,           /* UE index  */
        RRCConnectionReestablishmentComplete *rrcConnectionReestablishmentComplete
        /* UE message */
        )
{
    uecc_ue_context_t*                  p_ue_context = PNULL;
    RRCConnectionReestablishmentComplete_r8_IEs*
        p_rrcConnectionReestablishmentComplete_r8 = PNULL;

    rrc_return_et                       result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        /* Check message */
        if ( (T_RRCConnectionReestablishmentComplete_criticalExtensions_rrcConnectionReestablishmentComplete_r8 !=
                    rrcConnectionReestablishmentComplete->criticalExtensions.t)
                || (PNULL==rrcConnectionReestablishmentComplete->criticalExtensions.
                    u.rrcConnectionReestablishmentComplete_r8))
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionReestablishmentComplete]"
                    " Invalid message format.");
            break;
        }

        /* Get pointer on message data */
        p_rrcConnectionReestablishmentComplete_r8 =
            rrcConnectionReestablishmentComplete->criticalExtensions.u.
            rrcConnectionReestablishmentComplete_r8;

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionReestablishmentComplete] UE context not found.");
            break;
        }

        /* Check RRC_TransactionIdentifier rrc_TransactionIdentifier */
        if (rrcConnectionReestablishmentComplete->rrc_TransactionIdentifier !=
                (uecc_ue_ctx_get_op_transction_id(p_ue_context) &
                 UECC_LTE_RRC_TRANSACTION_ID_MASK) )
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionReestablishmentComplete] Invalid transaction id.");
            break;
        }

        p_ue_context->rlf_proc_flags.m.rrc_reestab_comp_rlf_info_present = 
            p_rrcConnectionReestablishmentComplete_r8->nonCriticalExtension.
            m.rlf_InfoAvailable_r9Present;

        if ((!p_ue_context->rlf_proc_flags.m.rrc_reestab_comp_rlf_info_present) &&
                /*CA_PHASE3_INTER_CELL_MRO_START*/
                (RRC_FALSE == p_ue_context->too_late_inter_cell_ho_flg))
            /*CA_PHASE3_INTER_CELL_MRO_STOP*/
        {
            if(RRC_FAILURE == x2ap_build_and_send_reestablishment_ind(
                        p_ue_context))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_ERROR,"x2ap_build_and_send_reestablishment_ind failed.");
            }
        }
        /*CA_PHASE3_INTER_CELL_MRO_START*/
        if ((!p_ue_context->rlf_proc_flags.m.
                    rrc_reestab_comp_rlf_info_present) &&
                (RRC_TRUE == p_ue_context->too_late_inter_cell_ho_flg))
        {
            if (RRC_FAILURE == x2ap_build_and_send_rlf_ind(p_ue_context,
                        p_uecc_gb_context))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_ERROR,"x2ap_build_and_send_rlf_ind failed.");
            }
            p_ue_context->too_late_inter_cell_ho_flg = RRC_FALSE;
        }
        /*CA_PHASE3_INTER_CELL_MRO_STOP*/

        /* Call UECC_CRE_EVENT_RRC_CONN_RE_ESTABLISH_COMP event handler 
         * in CRE FSM *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRC_CONNECTION_REESTABLISHMENT_COMPLETE,
                rrcConnectionReestablishmentComplete);

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_ulHandover_Preparation_Transfer
 *   INPUT        : rrc_ue_index_t      ue_index
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  ULHandoverPreparationTransfer   *p_ul_ho_prep_transfer
 *                  rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
 *   OUTPUT       : None
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *   DESCRIPTION  : This function processes ulHandover Preparation Transfer message
 *****************************************************************************/
rrc_return_et uecc_llim_process_dcch_ulHandover_Preparation_Transfer(
        uecc_gb_context_t               *p_uecc_gb_context,  /* UECC global context */
        rrc_ue_index_t                  ue_index,            /* UE index  */
        ULHandoverPreparationTransfer   *p_ul_ho_prep_transfer, /* UE message */
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
        )
{
    rrc_return_et                       result = RRC_FAILURE;
    uecc_ue_context_t*                  p_ue_context = PNULL;

    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_ul_ho_prep_transfer);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        /* Check message */
        if((T_ULHandoverPreparationTransfer_criticalExtensions_c1 !=
                    p_ul_ho_prep_transfer->criticalExtensions.t) ||
                (PNULL==p_ul_ho_prep_transfer->criticalExtensions.u.c1) )
        {
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[ulHandover Preparation Transfer] Wrong message format");

            break;
        }

        if ( (T_ULHandoverPreparationTransfer_criticalExtensions_c1_ulHandoverPreparationTransfer_r8 !=
                    p_ul_ho_prep_transfer->criticalExtensions.u.c1->t) ||
                (PNULL==p_ul_ho_prep_transfer->criticalExtensions.u.c1->
                 u.ulHandoverPreparationTransfer_r8)
           )
        {
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[UL Handover Preparation Transfer] Wrong message format");
            break;
        }

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[UL Handover Preparation Transfer] UE context not found");
            break;
        }

        /* TRACE_changes_start */
        /* SPR 16113 Start */
        uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_srb_data_ind->data_buffer,
                p_srb_data_ind->data_buffer_length, "UL Handover Preparation Transfer", RRC_UL_DCCH);
        /* SPR 16113 Stop */
        /* TRACE_changes_start */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRC_UL_HANDOVER_PREPARATION_TRANSFER,
                p_ul_ho_prep_transfer->criticalExtensions.u.c1->
                u.ulHandoverPreparationTransfer_r8);

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_proximityIndication_r9 
 *   INPUT        : uecc_gb_context_t   *p_uecc_gb_context
 *                  rrc_ue_index_t      ue_index
 *                  ProximityIndication_r9*  p_proximityIndication
 *                  rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
 *   OUTPUT       : None
 *   DESCRIPTION  : This function processes ProximityIndication message
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_process_dcch_proximityIndication_r9(
        uecc_gb_context_t   *p_uecc_gb_context,  /* UECC global context */
        rrc_ue_index_t      ue_index,            /* UE index  */
        ProximityIndication_r9*  p_proximityIndication,  /* UE message */
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
        )
{
    rrc_return_et                       result = RRC_FAILURE;
    uecc_ue_context_t*                  p_ue_context = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        /* Check message */
        if(T_ProximityIndication_r9_criticalExtensions_c1 !=
                p_proximityIndication->criticalExtensions.t ||
                (PNULL==p_proximityIndication->criticalExtensions.u.c1) )
        {
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCProximityIndication] Wrong message format");
            break;
        }

        if ( (T_ProximityIndication_r9_criticalExtensions_c1_proximityIndication_r9 !=
                    p_proximityIndication->criticalExtensions.u.c1->t) ||
                (PNULL==p_proximityIndication->criticalExtensions.u.c1->
                 u.proximityIndication_r9)
           )
        {
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCProximityIndication] Wrong message format");
            break;
        }

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCProximityIndication] UE context not found");
            break;
        }
        /* TRACE_changes_start */
        /* SPR 16113 Start */
        uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_srb_data_ind->data_buffer,
                p_srb_data_ind->data_buffer_length, "Proximity Indication", RRC_UL_DCCH);
        /* SPR 16113 Stop */
        /* TRACE_changes_start */

        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRC_PROXIMITY_INDICATION_IND,
                p_proximityIndication->criticalExtensions.u.c1->
                u.proximityIndication_r9);

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_measurementReport
 *   INPUT        : uecc_gb_context_t   *p_uecc_gb_context
 *                  rrc_ue_index_t      ue_index
 *                  MeasurementReport*  p_measurementReport
 *   OUTPUT       : None
 *   DESCRIPTION  : This function processes MeasurementReport message
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_process_dcch_measurementReport(
        uecc_gb_context_t   *p_uecc_gb_context,  /* UECC global context */
        rrc_ue_index_t      ue_index,            /* UE index  */
        MeasurementReport*  p_measurementReport  /* UE message */
        )
{
    rrc_return_et                       result = RRC_FAILURE;
    uecc_ue_context_t*                  p_ue_context = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        /* Check message */
        if ( (T_MeasurementReport_criticalExtensions_c1 !=
                    p_measurementReport->criticalExtensions.t) ||
                (PNULL==p_measurementReport->criticalExtensions.u.c1) )
        {
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCMeasurementReport] Wrong message format");
            break;
        }

        if ( (T_MeasurementReport_criticalExtensions_c1_measurementReport_r8 !=
                    p_measurementReport->criticalExtensions.u.c1->t) ||
                (PNULL==p_measurementReport->criticalExtensions.u.c1->
                 u.measurementReport_r8)
           )
        {
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCMeasurementReport] Wrong message format");
            break;
        }

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCMeasurementReport] UE context not found");
            break;
        }

        /* SPR 1643 Start */
        if (1 == p_measurementReport->criticalExtensions.u.c1->
                u.measurementReport_r8->measResults.m.
                measResultNeighCellsPresent)
        {
            if (RRC_FAILURE ==
                    validate_meas_results_plmn_identity(&p_measurementReport->
                        criticalExtensions.u.c1->
                        u.measurementReport_r8->measResults.measResultNeighCells,
                        p_uecc_gb_context))
            {
                /* PLMN ID range check error */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[RRCMeasurementReport] PLMN ID Range Invalid");
                /* Drop. */
                break;
            }
        }
        /* SPR 1643 End */



        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRC_MEASUREMENT_REPORT_IND,
                &p_measurementReport->criticalExtensions.u.c1->
                u.measurementReport_r8->measResults);

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/* Measurment Re-config START */
/******************************************************************************
 *   FUNCTION NAME: uecc_rrc_update_MeasObjectToRemoveList_to_CurrMeasConfigList
 *   INPUT        : rrm_meas_config_t* p_rrm_meas_config
 *                  uecc_ue_curr_meas_config_t* p_curr_rrm_meas_config
 *                  uecc_gb_context_t*       p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds MeasObjectToRemoveList in MeasConfig structure
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_rrc_update_MeasObjectToRemoveList_to_CurrMeasConfigList(
        rrm_meas_config_t* p_rrm_meas_config,
        uecc_ue_curr_meas_config_t* p_curr_rrm_meas_config,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */
        )
{
    U8 index = 0;
    U8 i = 0;
    U8 object_id_del = RRC_NULL;

    uecc_meas_object_to_add_mod_t *p_meas_object = PNULL;
    rrc_return_et   result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_meas_config);


    for (index = 0; index <
            p_rrm_meas_config->meas_object_to_remove_list.count; index++)
    {
        object_id_del = p_rrm_meas_config->
            meas_object_to_remove_list.meas_object_id[index]; 
        if (( 0 < object_id_del) && (object_id_del <= MAX_MEAS_OBJECT_ID))
        {
            /* Log the message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO,"object_id_del : %u",
                    object_id_del);
            /* remove the entry with the matching meas_object_id
             * from the measObjectList */
            p_meas_object = (uecc_meas_object_to_add_mod_t *) 
                ylFind(&p_curr_rrm_meas_config->curr_meas_object_to_add_mod_list,
                        &object_id_del, 
                        uecc_curr_meas_object_id_keyof, 
                        uecc_curr_meas_compare);
            if (p_meas_object != PNULL)
            {
                ylDelete(&p_curr_rrm_meas_config->curr_meas_object_to_add_mod_list,
                        (YLNODE *)p_meas_object);

                rrc_mem_free(p_meas_object);

                /* remove all meas_id associated with this meas_object_id
                 * from the measIdList, if any */
                /* SPR 13261 Fix Start */ 
                for (i = 0; i < MAX_MEAS_ID; i++)
                {
                    if (object_id_del == p_curr_rrm_meas_config->
                            curr_meas_id_to_add_mod_list.
                            meas_id_to_add_mod[i].meas_object_id)
                    {
                        p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                            meas_id_to_add_mod[i].meas_id = 0;
                        p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                            meas_id_to_add_mod[i].meas_object_id = 0;
                        p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                            meas_id_to_add_mod[i].report_config_id = 0;
                        /* SPR 15905 Fix Start */ 
                        p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                            meas_id_to_add_mod[i].meas_id_deleted = RRC_TRUE;
                        /* SPR 15905 Fix Stop */ 
                        /* decrement the count of meas_id */
                        --p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.count;
                    }
                }
                /* SPR 13261 Fix Stop */ 
            }
            else
            {
                /* Log the message */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,"Can not Remove Object_id : %u,"
                        " As this object_id is not present",object_id_del);
                result = RRC_FAILURE;
                break;
            }

        }
        else
        {
            /* Log the message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"Remove Object_id : %u,"
                    " is not within the Range",object_id_del);
            result = RRC_FAILURE;
            break;
        }
        result = RRC_SUCCESS;

    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_rrc_update_curr_MeasObjectCDMA2000
 *   INPUT        : meas_object_cdma2000_t*     p_rrm_curr_meas_object_cdma2000
 *                  meas_object_cdma2000_t*     p_rrm_meas_object_cdma2000
 *                  uecc_gb_context_t*       p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds MeasObjectCDMA2000 in MeasConfig structure
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_rrc_update_curr_MeasObjectCDMA2000(
        meas_object_cdma2000_t*     p_rrm_curr_meas_object_cdma2000,
        meas_object_cdma2000_t*     p_rrm_meas_object_cdma2000,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */
        )
{
    rrc_return_et   result = RRC_FAILURE;
    U8 i=0;
    U8 cell_index_del = 0;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_meas_object_cdma2000);

    do
    {
        /* OSUINT8 */
        if (MEAS_OBJECT_CDMA2000_SEARCH_WINDOW_SIZE_PRESENT &
                p_rrm_meas_object_cdma2000->bitmask)
        {
            p_rrm_curr_meas_object_cdma2000->search_window_size =
                p_rrm_meas_object_cdma2000->search_window_size;
        }

        /* CellIndexList */
        if (MEAS_OBJECT_CDMA2000_CELLS_TO_REMOVE_LIST_PRESENT &
                p_rrm_meas_object_cdma2000->bitmask)
        {
            for (i=0; i < p_rrm_meas_object_cdma2000->cells_to_remove_list.count; i++)
            {

                cell_index_del = p_rrm_meas_object_cdma2000->
                    cells_to_remove_list.cell_index[i];
                if ((0 < cell_index_del) && (cell_index_del <= MAX_CELL_MEAS))
                {
                    if (p_rrm_curr_meas_object_cdma2000->cells_to_add_mod_list.
                            cells_to_add_mod_cdma2000[cell_index_del - 1].cell_index != 0)
                    {
                        p_rrm_curr_meas_object_cdma2000->cells_to_add_mod_list.
                            cells_to_add_mod_cdma2000[cell_index_del - 1].cell_index = 0;
                        p_rrm_curr_meas_object_cdma2000->cells_to_add_mod_list.
                            cells_to_add_mod_cdma2000[cell_index_del - 1].phys_cell_id = 0;
                        --p_rrm_curr_meas_object_cdma2000->cells_to_add_mod_list.count;
                    }
                    else
                    {
                        /* Log the message */
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,"Can not Remove cell_index : %u,"
                                " As this cell_index is not present",cell_index_del);
                        result = RRC_FAILURE;
                        break;

                    }
                }
                else
                {
                    /* Log the message */
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,"remove cell_index : %u,"
                            " is not within the Range",cell_index_del);
                    result = RRC_FAILURE;
                    break;
                }

            }
            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* CellsToAddModListCDMA2000 */
        if (MEAS_OBJECT_CDMA2000_CELLS_TO_ADD_MOD_LIST_PRESENT &
                p_rrm_meas_object_cdma2000->bitmask)
        {

            /* fill list of CellsToAddModCDMA2000 */
            result = uecc_rrc_update_curr_CellsToAddModListCDMA2000(
                    &p_rrm_curr_meas_object_cdma2000->cells_to_add_mod_list,
                    &p_rrm_meas_object_cdma2000->cells_to_add_mod_list,
                    p_uecc_gb_context);
            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* PhysCellIdCDMA2000 */
        if (MEAS_OBJECT_CDMA2000_CELL_FOR_WHICH_TO_REPEORT_CGI_PRESENT &
                p_rrm_meas_object_cdma2000->bitmask)
        {
            p_rrm_curr_meas_object_cdma2000->cells_for_which_to_report_cgi =
                p_rrm_meas_object_cdma2000->cells_for_which_to_report_cgi;
        }

        p_rrm_curr_meas_object_cdma2000->cdma2000_type = 
            p_rrm_meas_object_cdma2000->cdma2000_type;

        p_rrm_curr_meas_object_cdma2000->carrier_freq_cdma2000.band_class = 
            p_rrm_meas_object_cdma2000->carrier_freq_cdma2000.band_class;

        p_rrm_curr_meas_object_cdma2000->carrier_freq_cdma2000.arfcn =
            p_rrm_meas_object_cdma2000->carrier_freq_cdma2000.arfcn;

        p_rrm_curr_meas_object_cdma2000->offset_freq =
            p_rrm_meas_object_cdma2000->offset_freq;

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/* eICIC meas changse start */
/************************************************************************************************************
 *   FUNCTION NAME: uecc_rrc_update_curr_MeasSubframePatternConfigNeigh_r10 
 *   INPUT        : meas_subframe_pattern_config_neigh_r10_t    *p_rrm_curr_meas_subframe_pattern_neigh_r10
 *                  meas_subframe_pattern_config_neigh_r10_t    *p_rrm_meas_subframe_pattern_neigh_r10
 *                  uecc_gb_context_t*       p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds MeasSubframePatternConfigNeigh_r10 in currMeasConfig structure
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 *************************************************************************************************************/
rrc_return_et uecc_rrc_update_curr_MeasSubframePatternConfigNeigh_r10(
        meas_subframe_pattern_config_neigh_r10_t    *p_rrm_curr_meas_subframe_pattern_neigh_r10,
        meas_subframe_pattern_config_neigh_r10_t    *p_rrm_meas_subframe_pattern_neigh_r10,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */
        )
{
    U8 count = RRC_NULL;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);


    if(MEAS_SUBFRAME_PATTERN_CONFIG_NEIGH_R10_SETUP_PRESENT &
            p_rrm_meas_subframe_pattern_neigh_r10->bitmask)
    {
        p_rrm_curr_meas_subframe_pattern_neigh_r10->bitmask |=
            MEAS_SUBFRAME_PATTERN_CONFIG_NEIGH_R10_SETUP_PRESENT;

        if(RRC_PHY_MEAS_SUBFRAME_PATTERN_FDD_R10 &
                p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                meas_subframe_pattern_neigh_r10.bitmask)
        {
            p_rrm_curr_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                meas_subframe_pattern_neigh_r10.bitmask |=
                RRC_PHY_MEAS_SUBFRAME_PATTERN_FDD_R10;

            l3_memcpy_wrapper(p_rrm_curr_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                    meas_subframe_pattern_neigh_r10.subframe_pattern_fdd_r10.data,
                    p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                    meas_subframe_pattern_neigh_r10.subframe_pattern_fdd_r10.data,
                    MAX_SUBFRAME_PATTERN_FDD);
        }
        else if(RRC_PHY_MEAS_SUBFRAME_PATTERN_TDD_R10 &
                p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                meas_subframe_pattern_neigh_r10.bitmask)
        {
            p_rrm_curr_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                meas_subframe_pattern_neigh_r10.bitmask |=
                RRC_PHY_MEAS_SUBFRAME_PATTERN_TDD_R10;

            if(RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG1_5_R10 &
                    p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                    meas_subframe_pattern_neigh_r10.subframe_pattern_tdd_r10.bitmask)
            {
                p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                    meas_subframe_pattern_neigh_r10.subframe_pattern_tdd_r10.bitmask |=
                    RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG1_5_R10;

                l3_memcpy_wrapper(p_rrm_curr_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                        meas_subframe_pattern_neigh_r10.subframe_pattern_tdd_r10.subframe_config1_5_r10,
                        p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                        meas_subframe_pattern_neigh_r10.subframe_pattern_tdd_r10.subframe_config1_5_r10,
                        MAX_SUBFRAME_CONFIG1_5_TDD);
            }
            else if (RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG0_R10 &
                    p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                    meas_subframe_pattern_neigh_r10.subframe_pattern_tdd_r10.bitmask)
            {
                p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                    meas_subframe_pattern_neigh_r10.subframe_pattern_tdd_r10.bitmask |=
                    RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG0_R10;

                l3_memcpy_wrapper(p_rrm_curr_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                        meas_subframe_pattern_neigh_r10.subframe_pattern_tdd_r10.subframe_config0_r10, 
                        p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                        meas_subframe_pattern_neigh_r10.subframe_pattern_tdd_r10.subframe_config0_r10,
                        MAX_SUBFRAME_CONFIG0_TDD);

            }
            else if(RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG6_R10 &
                    p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                    meas_subframe_pattern_neigh_r10.subframe_pattern_tdd_r10.bitmask)
            {
                p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                    meas_subframe_pattern_neigh_r10.subframe_pattern_tdd_r10.bitmask |=
                    RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG6_R10;

                l3_memcpy_wrapper(p_rrm_curr_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                        meas_subframe_pattern_neigh_r10.subframe_pattern_tdd_r10.subframe_config6_r10,
                        p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                        meas_subframe_pattern_neigh_r10.subframe_pattern_tdd_r10.subframe_config6_r10,
                        MAX_SUBFRAME_CONFIG6_TDD);
            }
        }
        if(MEAS_SUBFRAME_CELL_LIST_R10_PRESENT &
                p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.bitmask)
        {
            p_rrm_curr_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.bitmask |=
                MEAS_SUBFRAME_CELL_LIST_R10_PRESENT;

            p_rrm_curr_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                meas_subframe_cell_list_r10.count =
                p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                meas_subframe_cell_list_r10.count;

            for (count=0; count <p_rrm_meas_subframe_pattern_neigh_r10->
                    meas_subframe_pattern_config_neigh_r10_setup.meas_subframe_cell_list_r10.count && count < MAX_CELL_MEAS; count++)
            {

                p_rrm_curr_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                    meas_subframe_cell_list_r10.meas_subframe_cells[count].start =
                    p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                    meas_subframe_cell_list_r10.meas_subframe_cells[count].start;
                if(PHY_CELL_ID_RANGE & p_rrm_meas_subframe_pattern_neigh_r10->
                        meas_subframe_pattern_config_neigh_r10_setup.
                        meas_subframe_cell_list_r10.meas_subframe_cells[count].presence_bitmask)
                {
                    p_rrm_curr_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                        meas_subframe_cell_list_r10.meas_subframe_cells[count].presence_bitmask |=
                        PHY_CELL_ID_RANGE;

                    p_rrm_curr_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                        meas_subframe_cell_list_r10.meas_subframe_cells[count].range =
                        p_rrm_meas_subframe_pattern_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup.
                        meas_subframe_cell_list_r10.meas_subframe_cells[count].range;
                }
            }
        }
    }
    else if(MEAS_SUBFRAME_PATTERN_CONFIG_NEIGH_R10_RELEASE_PRESENT & 
            p_rrm_meas_subframe_pattern_neigh_r10->bitmask)
    {
        p_rrm_curr_meas_subframe_pattern_neigh_r10->bitmask |=
            MEAS_SUBFRAME_PATTERN_CONFIG_NEIGH_R10_RELEASE_PRESENT;
    }
    else
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"Invalid bitmask received : %u",
                p_rrm_meas_subframe_pattern_neigh_r10->bitmask);

        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return RRC_FAILURE;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return RRC_SUCCESS;
}
/* eICIC meas changes stop */
/******************************************************************************
 *   FUNCTION NAME: uecc_rrc_update_curr_MeasObjectEUTRA
 *   INPUT        : meas_object_eutra_t*     p_rrm_curr_meas_object_eutra
 *                  meas_object_eutra_t*     p_rrm_meas_object_eutra
 *                  uecc_gb_context_t*       p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds MeasObjectEUTRA in currMeasConfig structure
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_rrc_update_curr_MeasObjectEUTRA(
        meas_object_eutra_t*     p_rrm_curr_meas_object_eutra,
        meas_object_eutra_t*     p_rrm_meas_object_eutra,
        uecc_gb_context_t*       p_uecc_gb_context)      /* UECC global context */
{
    rrc_return_et   result = RRC_SUCCESS;
    U8 count = 0;
    U8 cell_index_del = 0;
    U8 black_cell_index_del = 0;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_meas_object_eutra);

    do
    {
        p_rrm_curr_meas_object_eutra->bitmask =
            p_rrm_meas_object_eutra->bitmask;
        /* CellIndexList */
        if (MEAS_OBJECT_EUTRA_CELLS_TO_REMOVE_LIST_PRESENT &
                p_rrm_meas_object_eutra->bitmask)
        {

            for (count = 0; count < p_rrm_meas_object_eutra->
                    cells_to_remove_list.count; count++)
            {
                cell_index_del =
                    p_rrm_meas_object_eutra->cells_to_remove_list.cell_index[count];
                if ((0 < cell_index_del) && (cell_index_del <= MAX_CELL_MEAS))
                {
                    if(p_rrm_curr_meas_object_eutra->cells_to_add_mod_list.
                            cells_to_add_mod[cell_index_del - 1].cell_index != 0)
                    {
                        p_rrm_curr_meas_object_eutra->cells_to_add_mod_list.
                            cells_to_add_mod[cell_index_del - 1].cell_index = 0;
                        p_rrm_curr_meas_object_eutra->cells_to_add_mod_list.
                            cells_to_add_mod[cell_index_del - 1].phys_cell_id = 0;
                        p_rrm_curr_meas_object_eutra->cells_to_add_mod_list.
                            cells_to_add_mod[cell_index_del - 1].cell_individual_offset = 0;
                        --p_rrm_curr_meas_object_eutra->cells_to_add_mod_list.count;
                    }
                    else
                    {
                        /* Log the message */
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,"Can not Remove cell_index : %u,"
                                " As this cell_index is not present",cell_index_del);
                        result = RRC_FAILURE;
                        break;
                    }
                }
                else
                {
                    /* Log the message */
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,"Remove cell_index : %u,"
                            " is not within the Range",cell_index_del);
                    result = RRC_FAILURE;
                    break;
                }

            }
            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* CellsToAddModListEUTRA */
        if (MEAS_OBJECT_EUTRA_CELLS_TO_ADD_MOD_LIST_PRESENT &
                p_rrm_meas_object_eutra->bitmask)
        {

            /* fill list of CellsToAddModEUTRA */
            result = uecc_rrc_update_curr_CellsToAddModListEUTRA(
                    &p_rrm_curr_meas_object_eutra->cells_to_add_mod_list,
                    &p_rrm_meas_object_eutra->cells_to_add_mod_list,
                    p_uecc_gb_context);
            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* BlackCellIndexList */
        if (MEAS_OBJECT_EUTRA_BLACK_CELLS_TO_REMOVE_LIST_PRESENT &
                p_rrm_meas_object_eutra->bitmask)
        {

            for (count=0; count < p_rrm_meas_object_eutra->black_cells_to_remove_list.count; 
                    count++)
            {

                black_cell_index_del =
                    p_rrm_meas_object_eutra->black_cells_to_remove_list.cell_index[count];
                if ((0 < black_cell_index_del) && (black_cell_index_del <= MAX_CELL_MEAS))
                {
                    if(p_rrm_curr_meas_object_eutra->black_cells_to_add_mod_list.
                            black_cells_to_add_mod[black_cell_index_del - 1].cell_index != 0)
                    {
                        p_rrm_curr_meas_object_eutra->black_cells_to_add_mod_list.
                            black_cells_to_add_mod[black_cell_index_del - 1].cell_index = 0;
                        memset_wrapper(&(p_rrm_curr_meas_object_eutra->
                                    black_cells_to_add_mod_list.black_cells_to_add_mod[
                                    black_cell_index_del - 1].phys_cell_id_range),0,
                                sizeof (p_rrm_curr_meas_object_eutra->black_cells_to_add_mod_list.
                                    black_cells_to_add_mod[
                                    black_cell_index_del - 1].phys_cell_id_range));
                        --p_rrm_curr_meas_object_eutra->black_cells_to_add_mod_list.count;
                    }
                    else
                    {
                        /* Log the message */
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,"Can not Remove black_cell_index : %u,"
                                " As this black_cell_index is not present",black_cell_index_del);
                        result = RRC_FAILURE;
                        break;

                    }
                }
                else
                {
                    /* Log the message */
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,"Remove black_cell_index : %u,"
                            " is not within the Range",black_cell_index_del);
                    result = RRC_FAILURE;
                    break;
                }
            }
            if ( RRC_FAILURE == result )
            {
                break;
            }
        }

        /* BlackCellsToAddModListEUTRA */
        if (MEAS_OBJECT_EUTRA_BLACK_CELLS_TO_ADD_MOD_LIST_PRESENT &
                p_rrm_meas_object_eutra->bitmask)
        {

            /* fill list of blackCellsToAddModEUTRA */
            result = uecc_rrc_update_curr_BlackListedCellsToAddModListEUTRA(
                    &p_rrm_curr_meas_object_eutra->black_cells_to_add_mod_list,
                    &p_rrm_meas_object_eutra->black_cells_to_add_mod_list,
                    p_uecc_gb_context);
            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* PhysCellIdEUTRA */
        if (MEAS_OBJECT_EUTRA_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT &
                p_rrm_meas_object_eutra->bitmask)
        {
            p_rrm_curr_meas_object_eutra->cell_for_which_to_report_cgi =
                p_rrm_meas_object_eutra->cell_for_which_to_report_cgi;
        }
        p_rrm_curr_meas_object_eutra->carrier_freq =
            p_rrm_meas_object_eutra->carrier_freq;

        p_rrm_curr_meas_object_eutra->allowed_meas_bandwidth =
            p_rrm_meas_object_eutra->allowed_meas_bandwidth;

        p_rrm_curr_meas_object_eutra->presence_antenna_port1 =
            p_rrm_meas_object_eutra->presence_antenna_port1;

        p_rrm_curr_meas_object_eutra->neigh_cell_config =
            p_rrm_meas_object_eutra->neigh_cell_config;

        p_rrm_curr_meas_object_eutra->offset_freq =
            p_rrm_meas_object_eutra->offset_freq;
        /*CA_START_MEAS_CYCLE_SCELL_R10*/
        if(MEAS_OBJECT_EUTRA_CYCLE_SCELL_R10_PRESENT &
                p_rrm_meas_object_eutra->bitmask)
        {
            /*coverity fix 61045*/
            p_rrm_curr_meas_object_eutra->meas_cycle_scell_r10 = 
                p_rrm_meas_object_eutra->meas_cycle_scell_r10;
            /*coverity fix 61045*/
        }
        /*CA_STOP_MEAS_CYCLE_SCELL_R10*/

        /* eICIC meas changse start */
        if(MEAS_SUBFRAME_PATTERN_CONFIG_NEIGH_R10_PRESENT &
                p_rrm_meas_object_eutra->bitmask)
        {
            /* fill list of MeasSubframePatternConfigNeigh_r10 */
            result = uecc_rrc_update_curr_MeasSubframePatternConfigNeigh_r10(
                    &p_rrm_curr_meas_object_eutra->meas_subframe_pattern_config_neigh_r10,
                    &p_rrm_meas_object_eutra->meas_subframe_pattern_config_neigh_r10,
                    p_uecc_gb_context);
            if (RRC_FAILURE == result)
            {
                break;
            }
        }
        /* eICIC meas changse stop */
        result = RRC_SUCCESS;
    }
    while(0);
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_rrc_update_curr_CellsToAddModListCDMA2000
 *   INPUT        : cells_to_add_mod_list_cdma2000_list_t*   p_rrm_curr_cells_to_add_mod_list_cdma2000_list
 *                  cells_to_add_mod_list_cdma2000_list_t*   p_rrm_cells_to_add_mod_list_cdma2000_list
 *                  uecc_gb_context_t*       p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds CellsToAddModCDMA2000 in curr MeasConfig structure
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_rrc_update_curr_CellsToAddModListCDMA2000(
        cells_to_add_mod_list_cdma2000_list_t*   p_rrm_curr_cells_to_add_mod_list_cdma2000_list,
        cells_to_add_mod_list_cdma2000_list_t*   p_rrm_cells_to_add_mod_list_cdma2000_list,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */
        )
{
    rrc_return_et           result = RRC_FAILURE;
    U8 index = 0;
    U8 cell_index_add = 0;


    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_cells_to_add_mod_list_cdma2000_list);

    for (index=0; index < p_rrm_cells_to_add_mod_list_cdma2000_list->count; index++)
    {

        cell_index_add = p_rrm_cells_to_add_mod_list_cdma2000_list->
            cells_to_add_mod_cdma2000[index].cell_index;
        if ((0 < cell_index_add) && ( cell_index_add <= MAX_CELL_MEAS))
        {
            if (cell_index_add == p_rrm_curr_cells_to_add_mod_list_cdma2000_list->
                    cells_to_add_mod_cdma2000[cell_index_add - 1].cell_index)
            {
                p_rrm_curr_cells_to_add_mod_list_cdma2000_list->
                    cells_to_add_mod_cdma2000[cell_index_add - 1].cell_index =
                    p_rrm_cells_to_add_mod_list_cdma2000_list->
                    cells_to_add_mod_cdma2000[index].cell_index;

                p_rrm_curr_cells_to_add_mod_list_cdma2000_list->
                    cells_to_add_mod_cdma2000[cell_index_add - 1].phys_cell_id =
                    p_rrm_cells_to_add_mod_list_cdma2000_list->
                    cells_to_add_mod_cdma2000[index].phys_cell_id;
            }
            else
            {
                p_rrm_curr_cells_to_add_mod_list_cdma2000_list->
                    cells_to_add_mod_cdma2000[cell_index_add - 1].cell_index = 
                    cell_index_add;

                p_rrm_curr_cells_to_add_mod_list_cdma2000_list->
                    cells_to_add_mod_cdma2000[cell_index_add - 1].phys_cell_id =
                    p_rrm_cells_to_add_mod_list_cdma2000_list->
                    cells_to_add_mod_cdma2000[index].phys_cell_id;

                ++p_rrm_curr_cells_to_add_mod_list_cdma2000_list->count;
            }
        }
        else
        {
            /* Log the message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"cell_index : %u,"
                    " is not within the Range",cell_index_add);
            result = RRC_FAILURE;
            break;
        }
        result = RRC_SUCCESS;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_rrc_update_curr_CellsToAddModListEUTRA
 *   INPUT        : cells_to_add_mod_list_t*   p_rrm_curr_cells_to_add_mod_list_eutra_list
 *                  cells_to_add_mod_list_t*   p_rrm_cells_to_add_mod_list_eutra_list
 *                  uecc_gb_context_t*       p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds CellsToAddModEUTRA in curr MeasConfig structure
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_rrc_update_curr_CellsToAddModListEUTRA(
        cells_to_add_mod_list_t*   p_rrm_curr_cells_to_add_mod_list_eutra_list,
        cells_to_add_mod_list_t*   p_rrm_cells_to_add_mod_list_eutra_list,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */
        )
{
    rrc_return_et           result = RRC_FAILURE;
    U8 count = 0;
    U8 cell_index_add = 0;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_cells_to_add_mod_list_eutra_list);

    for (count = 0; count < p_rrm_cells_to_add_mod_list_eutra_list->count; count++)
    {

        cell_index_add = p_rrm_cells_to_add_mod_list_eutra_list->
            cells_to_add_mod[count].cell_index;
        if ((0 < cell_index_add) && (cell_index_add <= MAX_CELL_MEAS))
        {
            if (cell_index_add == p_rrm_curr_cells_to_add_mod_list_eutra_list->
                    cells_to_add_mod[cell_index_add - 1].cell_index)
            {
                p_rrm_curr_cells_to_add_mod_list_eutra_list->
                    cells_to_add_mod[cell_index_add - 1].cell_index =
                    p_rrm_cells_to_add_mod_list_eutra_list->
                    cells_to_add_mod[count].cell_index;

                p_rrm_curr_cells_to_add_mod_list_eutra_list->
                    cells_to_add_mod[cell_index_add - 1].phys_cell_id =
                    p_rrm_cells_to_add_mod_list_eutra_list->
                    cells_to_add_mod[count].phys_cell_id;

                p_rrm_curr_cells_to_add_mod_list_eutra_list->
                    cells_to_add_mod[cell_index_add - 1].cell_individual_offset =
                    p_rrm_cells_to_add_mod_list_eutra_list->
                    cells_to_add_mod[count].cell_individual_offset;
            }
            else
            {        
                p_rrm_curr_cells_to_add_mod_list_eutra_list->
                    cells_to_add_mod[cell_index_add - 1].cell_index = 
                    cell_index_add;

                p_rrm_curr_cells_to_add_mod_list_eutra_list->
                    cells_to_add_mod[cell_index_add - 1].phys_cell_id =
                    p_rrm_cells_to_add_mod_list_eutra_list->
                    cells_to_add_mod[count].phys_cell_id;

                p_rrm_curr_cells_to_add_mod_list_eutra_list->
                    cells_to_add_mod[cell_index_add - 1].cell_individual_offset =
                    p_rrm_cells_to_add_mod_list_eutra_list->
                    cells_to_add_mod[count].cell_individual_offset;

                ++p_rrm_curr_cells_to_add_mod_list_eutra_list->count;

            }
        }
        else
        {
            /* Log the message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"Add/Modify cell_index : %u,"
                    " is not within the Range",cell_index_add);
            result = RRC_FAILURE;
            break;
        }
        result = RRC_SUCCESS;
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/*****************************************************************************
 *   FUNCTION NAME: uecc_rrc_update_curr_BlackListedCellsToAddModListEUTRA
 *   INPUT        : black_cells_to_add_mod_list_t* p_rrm_curr_black_cells_to_add_mod_list_eutra_list
 *                  black_cells_to_add_mod_list_t* p_rrm_black_cells_to_add_mod_list_eutra_list
 *                  uecc_gb_context_t*       p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds CellsToAddModEUTRA in currMeasConfig structure
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_rrc_update_curr_BlackListedCellsToAddModListEUTRA(
        black_cells_to_add_mod_list_t* p_rrm_curr_black_cells_to_add_mod_list_eutra_list,
        black_cells_to_add_mod_list_t* p_rrm_black_cells_to_add_mod_list_eutra_list,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */
        )
{
    rrc_return_et           result = RRC_FAILURE;
    U8 count = 0;
    U8 black_cell_index_add = 0;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_black_cells_to_add_mod_list_eutra_list);

    for (count=0; count < p_rrm_black_cells_to_add_mod_list_eutra_list->count; count++)
    {

        black_cell_index_add = p_rrm_black_cells_to_add_mod_list_eutra_list->
            black_cells_to_add_mod[count].cell_index;
        if ((0 < black_cell_index_add) && (black_cell_index_add <= MAX_CELL_MEAS))
        {
            if (black_cell_index_add == p_rrm_curr_black_cells_to_add_mod_list_eutra_list->
                    black_cells_to_add_mod[black_cell_index_add - 1].cell_index)
            {
                p_rrm_curr_black_cells_to_add_mod_list_eutra_list->
                    black_cells_to_add_mod[black_cell_index_add - 1].cell_index =
                    p_rrm_black_cells_to_add_mod_list_eutra_list->
                    black_cells_to_add_mod[count].cell_index;

                p_rrm_curr_black_cells_to_add_mod_list_eutra_list->
                    black_cells_to_add_mod[black_cell_index_add -1].phys_cell_id_range =
                    p_rrm_black_cells_to_add_mod_list_eutra_list->
                    black_cells_to_add_mod[count].phys_cell_id_range;

            }
            else
            {
                p_rrm_curr_black_cells_to_add_mod_list_eutra_list->
                    black_cells_to_add_mod[black_cell_index_add - 1].cell_index = 
                    black_cell_index_add;

                p_rrm_curr_black_cells_to_add_mod_list_eutra_list->
                    black_cells_to_add_mod[black_cell_index_add - 1].phys_cell_id_range =
                    p_rrm_black_cells_to_add_mod_list_eutra_list->
                    black_cells_to_add_mod[count].phys_cell_id_range;


                ++p_rrm_curr_black_cells_to_add_mod_list_eutra_list->count;

            }
        }
        else
        {
            /* Log the message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"black_cell_index_add : %u,"
                    " is not within the Range",black_cell_index_add);
            result = RRC_FAILURE;
            break;
        }
        result = RRC_SUCCESS;

    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_rrc_update_curr_MeasObjectUTRA
 *   INPUT        : meas_object_utra_t*         p_rrm_curr_meas_object_utra
 *                  meas_object_utra_t*         p_rrm_meas_object_utra
 *                  uecc_gb_context_t*       p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds MeasObjectUTRA in MeasConfig structure
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_rrc_update_curr_MeasObjectUTRA(
        meas_object_utra_t*         p_rrm_curr_meas_object_utra,
        meas_object_utra_t*         p_rrm_meas_object_utra,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */

        )
{
    rrc_return_et   result = RRC_FAILURE;
    U8 count = 0;
    U8 cell_index_del = 0;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_meas_object_utra);

    do
    {
        /*SPR_19379_START*/
        p_rrm_curr_meas_object_utra->bitmask = 
                p_rrm_meas_object_utra->bitmask;
        /*SPR_19379_END*/
        /* CellIndexList */
        if (MEAS_OBJECT_UTRA_CELLS_TO_REMOVE_LIST_PRESENT &
                p_rrm_meas_object_utra->bitmask)
        {

            for (count=0; count < p_rrm_meas_object_utra->cells_to_remove_list.count; count++)
            {

                cell_index_del =
                    p_rrm_meas_object_utra->cells_to_remove_list.cell_index[count];
                if ((0 < cell_index_del) && (cell_index_del <= MAX_CELL_MEAS))
                {
                    if (p_rrm_curr_meas_object_utra->cells_to_add_mod_list.bitmask &
                            MEAS_OBJECT_UTRA_CELLS_TO_ADD_MOD_LIST_FDD_PRESENT)
                    {
                        if ( cell_index_del == p_rrm_curr_meas_object_utra->cells_to_add_mod_list.
                                cells_to_add_mod_list_utra_fdd.cells_to_add_mod_utra_fdd[
                                cell_index_del -1].cell_index)
                        {
                            if (p_rrm_curr_meas_object_utra->cells_to_add_mod_list.
                                    cells_to_add_mod_list_utra_fdd.cells_to_add_mod_utra_fdd[
                                    cell_index_del -1].cell_index != 0)
                            {
                                p_rrm_curr_meas_object_utra->cells_to_add_mod_list.
                                    cells_to_add_mod_list_utra_fdd.cells_to_add_mod_utra_fdd[
                                    cell_index_del -1].cell_index = 0;
                                p_rrm_curr_meas_object_utra->cells_to_add_mod_list.
                                    cells_to_add_mod_list_utra_fdd.cells_to_add_mod_utra_fdd[
                                    cell_index_del -1].phys_cell_id = 0;

                                --p_rrm_curr_meas_object_utra->cells_to_add_mod_list.
                                    cells_to_add_mod_list_utra_fdd.count;
                            }
                            else
                            {
                                /* Log the message */
                                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                        p_uecc_gb_context->facility_name,
                                        RRC_WARNING,"Can not Remove cell_index : %u,"
                                        " As this cell_index is not present",cell_index_del);
                                result = RRC_FAILURE;
                                break;

                            }
                        }
                    }
                    if (p_rrm_curr_meas_object_utra->cells_to_add_mod_list.bitmask &
                            MEAS_OBJECT_UTRA_CELLS_TO_ADD_MOD_LIST_TDD_PRESENT)
                    {
                        if ( cell_index_del == p_rrm_curr_meas_object_utra->cells_to_add_mod_list.
                                cells_to_add_mod_list_utra_tdd.cells_to_add_mod_utra_tdd[
                                cell_index_del -1].cell_index)
                        {
                            if (p_rrm_curr_meas_object_utra->cells_to_add_mod_list.
                                    cells_to_add_mod_list_utra_tdd.cells_to_add_mod_utra_tdd[
                                    cell_index_del -1].cell_index != 0)
                            {
                                p_rrm_curr_meas_object_utra->cells_to_add_mod_list.
                                    cells_to_add_mod_list_utra_tdd.cells_to_add_mod_utra_tdd[
                                    cell_index_del -1].cell_index = 0;

                                p_rrm_curr_meas_object_utra->cells_to_add_mod_list.
                                    cells_to_add_mod_list_utra_tdd.cells_to_add_mod_utra_tdd[
                                    cell_index_del -1].phys_cell_id = 0;

                                --p_rrm_curr_meas_object_utra->cells_to_add_mod_list.
                                    cells_to_add_mod_list_utra_tdd.count;
                            }
                            else
                            {
                                /* Log the message */
                                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                        p_uecc_gb_context->facility_name,
                                        RRC_WARNING,"Can not Remove cell_index : %u,"
                                        " As this cell_index is not present",cell_index_del);
                                result = RRC_FAILURE;
                                break;
                            }
                        }
                    }
                }
                else
                {
                    /* Log the message */
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,"cell_index_del : %u,"
                            " is not within the Range",cell_index_del);
                    result = RRC_FAILURE;
                    break;
                }

            }
            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* CellsToAddModListUTRA */
        if (MEAS_OBJECT_UTRA_CELLS_TO_ADD_MOD_LIST_PRESENT &
                p_rrm_meas_object_utra->bitmask)
        {

            /*SPR_19380_START*/
            p_rrm_curr_meas_object_utra->cells_to_add_mod_list.bitmask =
                    p_rrm_meas_object_utra->cells_to_add_mod_list.bitmask;
            /*SPR_19380_END*/

            if ( MEAS_OBJECT_UTRA_CELLS_TO_ADD_MOD_LIST_FDD_PRESENT &
                    p_rrm_meas_object_utra->cells_to_add_mod_list.bitmask )
            {
                /* fill list of CellsToAddModUTRA-FDD */
                result = uecc_rrc_update_curr_CellsToAddModListUTRA_FDD(
                        &p_rrm_curr_meas_object_utra->cells_to_add_mod_list.
                        cells_to_add_mod_list_utra_fdd,
                        &p_rrm_meas_object_utra->cells_to_add_mod_list.
                        cells_to_add_mod_list_utra_fdd,
                        p_uecc_gb_context);
                if (RRC_FAILURE == result)
                {
                    break;
                }
            }
            if ( MEAS_OBJECT_UTRA_CELLS_TO_ADD_MOD_LIST_TDD_PRESENT &
                    p_rrm_meas_object_utra->cells_to_add_mod_list.bitmask )
            {
                /* fill list of CellsToAddModUTRA-TDD */
                result = uecc_rrc_update_curr_CellsToAddModListUTRA_TDD(
                        &p_rrm_curr_meas_object_utra->cells_to_add_mod_list.
                        cells_to_add_mod_list_utra_tdd,
                        &p_rrm_meas_object_utra->cells_to_add_mod_list.
                        cells_to_add_mod_list_utra_tdd,
                        p_uecc_gb_context);
                if (RRC_FAILURE == result)
                {
                    break;
                }
            }
        }

        /* PhysCellIdUTRA */
        if (MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT &
                p_rrm_meas_object_utra->bitmask)
        {
            /*SPR_19381_START*/
            p_rrm_curr_meas_object_utra->cell_for_which_to_report_cgi.bitmask =
                    p_rrm_meas_object_utra->cell_for_which_to_report_cgi.bitmask;
            /*SPR_19381_END*/

            if (MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_UTRA_FDD_PRESENT &
                    p_rrm_meas_object_utra->cell_for_which_to_report_cgi.bitmask)
            {

                p_rrm_curr_meas_object_utra->cell_for_which_to_report_cgi.utra_fdd =
                    p_rrm_meas_object_utra->cell_for_which_to_report_cgi.utra_fdd;
            }

            if (MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_UTRA_TDD_PRESENT &
                    p_rrm_meas_object_utra->cell_for_which_to_report_cgi.bitmask)
            {

                p_rrm_curr_meas_object_utra->cell_for_which_to_report_cgi.utra_tdd =
                    p_rrm_meas_object_utra->cell_for_which_to_report_cgi.utra_tdd;
            }
        }

        p_rrm_curr_meas_object_utra->carrier_freq =
            p_rrm_meas_object_utra->carrier_freq;

        p_rrm_curr_meas_object_utra->offset_freq =
            p_rrm_meas_object_utra->offset_freq;

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_rrc_update_curr_CellsToAddModListUTRA_FDD
 *   INPUT        : cells_to_add_mod_list_utra_fdd_t* p_rrm_curr_cells_to_add_mod_list_utra_fdd
 *                  cells_to_add_mod_list_utra_fdd_t* p_rrm_cells_to_add_mod_list_utra_fdd
 *                  uecc_gb_context_t*       p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds CellsToAddModUTRA-FDD in MeasConfig structure
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_rrc_update_curr_CellsToAddModListUTRA_FDD(
        cells_to_add_mod_list_utra_fdd_t* p_rrm_curr_cells_to_add_mod_list_utra_fdd,
        cells_to_add_mod_list_utra_fdd_t* p_rrm_cells_to_add_mod_list_utra_fdd,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */
        )
{
    rrc_return_et           result = RRC_FAILURE;
    U8 count = 0;
    U8 cell_index_add = 0;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_cells_to_add_mod_list_utra_fdd);

    for (count = 0; count < p_rrm_cells_to_add_mod_list_utra_fdd->count; count++)
    {

        cell_index_add = p_rrm_cells_to_add_mod_list_utra_fdd->
            cells_to_add_mod_utra_fdd[count].cell_index;
        if ((0 < cell_index_add) && (cell_index_add <= MAX_CELL_MEAS))
        {
            if (cell_index_add == p_rrm_curr_cells_to_add_mod_list_utra_fdd->
                    cells_to_add_mod_utra_fdd[cell_index_add - 1].cell_index)
            {
                p_rrm_curr_cells_to_add_mod_list_utra_fdd->
                    cells_to_add_mod_utra_fdd[cell_index_add - 1].cell_index =
                    p_rrm_cells_to_add_mod_list_utra_fdd->
                    cells_to_add_mod_utra_fdd[count].cell_index;

                p_rrm_curr_cells_to_add_mod_list_utra_fdd->
                    cells_to_add_mod_utra_fdd[cell_index_add - 1].phys_cell_id =
                    p_rrm_cells_to_add_mod_list_utra_fdd->
                    cells_to_add_mod_utra_fdd[count].phys_cell_id;
            }
            else
            {        
                p_rrm_curr_cells_to_add_mod_list_utra_fdd->
                    cells_to_add_mod_utra_fdd[cell_index_add - 1].cell_index = 
                    cell_index_add;

                p_rrm_curr_cells_to_add_mod_list_utra_fdd->
                    cells_to_add_mod_utra_fdd[cell_index_add - 1].phys_cell_id =
                    p_rrm_cells_to_add_mod_list_utra_fdd->
                    cells_to_add_mod_utra_fdd[count].phys_cell_id;

                ++p_rrm_curr_cells_to_add_mod_list_utra_fdd->count;
            }
        }
        else
        {
            /* Log the message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"cell_index_add : %u,"
                    " is not within the Range",cell_index_add);
            result = RRC_FAILURE;
            break;
        }
        result = RRC_SUCCESS;
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_rrc_update_curr_CellsToAddModListUTRA_TDD
 *   INPUT        : cells_to_add_mod_list_utra_tdd_t* p_rrm_curr_cells_to_add_mod_list_utra_tdd
 *                  cells_to_add_mod_list_utra_tdd_t* p_rrm_cells_to_add_mod_list_utra_tdd
 *                  uecc_gb_context_t*       p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds CellsToAddModUTRA-TDD in MeasConfig structure
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_rrc_update_curr_CellsToAddModListUTRA_TDD(
        cells_to_add_mod_list_utra_tdd_t* p_rrm_curr_cells_to_add_mod_list_utra_tdd,
        cells_to_add_mod_list_utra_tdd_t* p_rrm_cells_to_add_mod_list_utra_tdd,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */
        )
{
    rrc_return_et           result = RRC_FAILURE;
    U8 count = 0;
    U8 cell_index_add = 0;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_cells_to_add_mod_list_utra_tdd);

    for (count = 0; count < p_rrm_cells_to_add_mod_list_utra_tdd->count; count++)
    {

        cell_index_add = p_rrm_cells_to_add_mod_list_utra_tdd->
            cells_to_add_mod_utra_tdd[count].cell_index;
        if ((0 < cell_index_add) && (cell_index_add <= MAX_CELL_MEAS))
        {

            if (cell_index_add == p_rrm_curr_cells_to_add_mod_list_utra_tdd->
                    cells_to_add_mod_utra_tdd[cell_index_add - 1].cell_index)
            {
                p_rrm_curr_cells_to_add_mod_list_utra_tdd->
                    cells_to_add_mod_utra_tdd[cell_index_add - 1].cell_index =
                    p_rrm_cells_to_add_mod_list_utra_tdd->
                    cells_to_add_mod_utra_tdd[count].cell_index;

                p_rrm_curr_cells_to_add_mod_list_utra_tdd->
                    cells_to_add_mod_utra_tdd[cell_index_add - 1].phys_cell_id =
                    p_rrm_cells_to_add_mod_list_utra_tdd->
                    cells_to_add_mod_utra_tdd[count].phys_cell_id;
            }
            else
            {        
                p_rrm_curr_cells_to_add_mod_list_utra_tdd->
                    cells_to_add_mod_utra_tdd[cell_index_add - 1].cell_index = 
                    cell_index_add;

                p_rrm_curr_cells_to_add_mod_list_utra_tdd->
                    cells_to_add_mod_utra_tdd[cell_index_add - 1].phys_cell_id =
                    p_rrm_cells_to_add_mod_list_utra_tdd->
                    cells_to_add_mod_utra_tdd[count].phys_cell_id;

                ++p_rrm_curr_cells_to_add_mod_list_utra_tdd->count;
            }
        }
        else
        {
            /* Log the message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"cell_index_add : %u,"
                    " is not within the Range",cell_index_add);
            result = RRC_FAILURE;
            break;
        }
        result = RRC_SUCCESS;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

#ifdef ENDC_ENABLED
/*****************************************************************************
 *   FUNCTION NAME: uecc_rrc_update_curr_BlackListedCellsToAddModListNR
 *   INPUT        : black_cells_to_add_mod_list_r15_t*
 *                      p_rrm_curr_black_cells_to_add_mod_list_nr
 *                  black_cells_to_add_mod_list_r15_t*
 *                      p_rrm_black_cells_to_add_mod_list_nr
 *                  uecc_gb_context_t*       p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds CellsToAddModNR in currMeasConfig
 *                  structure
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 ******************************************************************************/
rrc_return_et
uecc_rrc_update_curr_BlackListedCellsToAddModListNR
(
    black_cells_to_add_mod_list_r15_t* p_rrm_curr_black_cells_to_add_mod_list_nr,
    black_cells_to_add_mod_list_r15_t* p_rrm_black_cells_to_add_mod_list_nr,
    uecc_gb_context_t*                 p_uecc_gb_context
)
{
    rrc_return_et    result = RRC_FAILURE;
    U8               count = RRC_NULL;
    U8               black_cell_index_add = RRC_NULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_ASSERT(PNULL != p_rrm_black_cells_to_add_mod_list_nr);

    for ( count = RRC_NULL; count <
        p_rrm_black_cells_to_add_mod_list_nr->count; count++ )
    {
        black_cell_index_add = p_rrm_black_cells_to_add_mod_list_nr->
            black_cells_to_add_mod[count].cell_index_r15;

        if ((RRC_NULL < black_cell_index_add) && (black_cell_index_add <= MAX_CELL_MEAS))
        {
            if (black_cell_index_add == p_rrm_curr_black_cells_to_add_mod_list_nr->
                    black_cells_to_add_mod[black_cell_index_add - RRC_ONE].cell_index_r15)
            {
                p_rrm_curr_black_cells_to_add_mod_list_nr->
                    black_cells_to_add_mod[black_cell_index_add - RRC_ONE].cell_index_r15 =
                    p_rrm_black_cells_to_add_mod_list_nr->
                    black_cells_to_add_mod[count].cell_index_r15;

                p_rrm_curr_black_cells_to_add_mod_list_nr->
                    black_cells_to_add_mod[black_cell_index_add - RRC_ONE].phys_cellid_r15 =
                    p_rrm_black_cells_to_add_mod_list_nr->
                    black_cells_to_add_mod[count].phys_cellid_r15;
            }
            else
            {
                p_rrm_curr_black_cells_to_add_mod_list_nr->
                    black_cells_to_add_mod[black_cell_index_add - RRC_ONE].cell_index_r15 = 
                    black_cell_index_add;

                p_rrm_curr_black_cells_to_add_mod_list_nr->
                    black_cells_to_add_mod[black_cell_index_add - RRC_ONE].phys_cellid_r15 =
                    p_rrm_black_cells_to_add_mod_list_nr->
                    black_cells_to_add_mod[count].phys_cellid_r15;

                ++p_rrm_curr_black_cells_to_add_mod_list_nr->count;
            }
        }
        else
        {
            /* Log the message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"black_cell_index_add : %u,"
                    " is not within the Range",black_cell_index_add);
            result = RRC_FAILURE;
            break;
        }
        result = RRC_SUCCESS;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_rrc_update_curr_MeasObject_NR
 *   INPUT        : meas_object_nr_t*     p_rrm_curr_meas_object_nr
 *                  meas_object_nr_t*     p_rrm_meas_object_nr
 *                  uecc_gb_context_t*    p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds MeasObjectNR_r15 in currMeasConfig
 *                  structure
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 ******************************************************************************/
rrc_return_et
uecc_rrc_update_curr_MeasObject_NR
(
    meas_object_nr_t*     p_rrm_curr_meas_object_nr,
    meas_object_nr_t*     p_rrm_meas_object_nr,
    uecc_gb_context_t*    p_uecc_gb_context
)
{
    rrc_return_et   result = RRC_SUCCESS;
    U8              count = RRC_NULL;
    U8              black_cell_index_del = RRC_NULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_ASSERT(PNULL != p_rrm_meas_object_nr);

    do
    {
        p_rrm_curr_meas_object_nr->bitmask =
            p_rrm_meas_object_nr->bitmask;

        p_rrm_curr_meas_object_nr->carrier_freq_r15 =
            p_rrm_meas_object_nr->carrier_freq_r15;

        p_rrm_curr_meas_object_nr->quantity_config_set_r15 =
            p_rrm_meas_object_nr->quantity_config_set_r15;

        p_rrm_curr_meas_object_nr->offset_freq_r15 =
            p_rrm_meas_object_nr->offset_freq_r15;

        l3_memcpy_wrapper(&p_rrm_curr_meas_object_nr->rs_config_ssb_nr_r15,
            &p_rrm_meas_object_nr->rs_config_ssb_nr_r15,
            sizeof(rs_config_ssb_nr_r15_t));

        if ( MEAS_OBJECT_NR_MAX_RS_IDX_CELL_QUAL_PRESENT &
            p_rrm_meas_object_nr->bitmask )
        {
            p_rrm_curr_meas_object_nr->max_rs_index_cell_qual_r15 =
                p_rrm_meas_object_nr->max_rs_index_cell_qual_r15;
        }

        /* black_cells_to_remove_list */
        if ( MEAS_OBJECT_NR_BLACK_CELLS_TO_REMOVE_LIST_PRESENT &
                p_rrm_meas_object_nr->bitmask )
        {
            for ( count = RRC_NULL; count < p_rrm_meas_object_nr->
                black_cells_to_remove_list.count; count++)
            {
                black_cell_index_del =
                    p_rrm_meas_object_nr->black_cells_to_remove_list.cell_index[count];
                if ((RRC_NULL < black_cell_index_del) && (black_cell_index_del <=
                    MAX_CELL_MEAS))
                {
                    if(p_rrm_curr_meas_object_nr->black_cells_to_add_mod_list.
                            black_cells_to_add_mod[black_cell_index_del - RRC_ONE].
                        cell_index_r15 != RRC_NULL)
                    {
                        p_rrm_curr_meas_object_nr->black_cells_to_add_mod_list.
                            black_cells_to_add_mod[black_cell_index_del - RRC_ONE].
                                cell_index_r15 = RRC_NULL;

                        memset_wrapper(&(p_rrm_curr_meas_object_nr->
                                    black_cells_to_add_mod_list.black_cells_to_add_mod[
                                    black_cell_index_del - RRC_ONE].phys_cellid_r15),RRC_NULL,
                                sizeof (p_rrm_curr_meas_object_nr->black_cells_to_add_mod_list.
                                    black_cells_to_add_mod[
                                    black_cell_index_del - RRC_ONE].phys_cellid_r15));
                        --p_rrm_curr_meas_object_nr->black_cells_to_add_mod_list.count;
                    }
                    else
                    {
                        /* Log the message */
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,"Can not Remove black_cell_index_r15 : %u,"
                                " As this black_cell_index_r15 is not present",black_cell_index_del);
                        result = RRC_FAILURE;
                        break;
                    }
                }
                else
                {
                    /* Log the message */
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,"Remove black_cell_index_r15 : %u,"
                            " is not within the Range",black_cell_index_del);
                    result = RRC_FAILURE;
                    break;
                }
            }
            if ( RRC_FAILURE == result )
            {
                break;
            }
        }

        /* BlackCellsToAddModListNR */
        if ( MEAS_OBJECT_NR_BLACK_CELLS_TO_ADD_MOD_LIST_PRESENT &
                p_rrm_meas_object_nr->bitmask )
        {
            /* fill list of blackCellsToAddModNR */
            result = uecc_rrc_update_curr_BlackListedCellsToAddModListNR(
                    &p_rrm_curr_meas_object_nr->black_cells_to_add_mod_list,
                    &p_rrm_meas_object_nr->black_cells_to_add_mod_list,
                    p_uecc_gb_context);
            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* cells_to_report_SFTD_r15_list */
        if ( MEAS_OBJECT_NR_CELLS_TO_REPORT_SFTD_PRESENT &
                p_rrm_meas_object_nr->bitmask )
        {
            l3_memcpy_wrapper(&p_rrm_curr_meas_object_nr->thresh_rs_index_r15,
                    &p_rrm_meas_object_nr->thresh_rs_index_r15,
                    sizeof(threshold_list_nr_r15_t));
        }

        /* threshold_list_nr_r15 */
        if ( MEAS_OBJECT_NR_THRESHHOLD_RS_INDEX_PRESENT &
                p_rrm_meas_object_nr->bitmask )
        {
            l3_memcpy_wrapper(&p_rrm_curr_meas_object_nr->
                    cells_to_report_SFTD_r15_list,
                    &p_rrm_meas_object_nr->cells_to_report_SFTD_r15_list,
                    sizeof(cells_to_report_SFTD_r15_list_t));
        }

        result = RRC_SUCCESS;

    }while(RRC_NULL);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
#endif

/******************************************************************************
 *   FUNCTION NAME: uecc_rrc_update_curr_MeasobjectToAddMod
 *   INPUT        : uecc_meas_object_to_add_mod_t*   p_ue_curr_meas_object_to_add_mod
 *                  meas_object_to_add_mod_t*   p_rrm_meas_object_to_add_mod
 *                  uecc_gb_context_t*       p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds MeasObjectToAddMod in MeasConfig structure
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_rrc_update_curr_MeasobjectToAddMod(
        uecc_meas_object_to_add_mod_t*   p_ue_curr_meas_object_to_add_mod,
        meas_object_to_add_mod_t*   p_rrm_meas_object_to_add_mod,
        uecc_gb_context_t*       p_uecc_gb_context)      /* UECC global context */
{
    rrc_return_et               result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_meas_object_to_add_mod);

    switch (p_rrm_meas_object_to_add_mod->meas_object.bitmask)
    {
        /* only CDMA2000 implemented */
        case MEAS_OBJECT_TO_ADD_CDMA2000_PRESENT:
            p_ue_curr_meas_object_to_add_mod->meas_object_id =
                p_rrm_meas_object_to_add_mod->meas_object_id;

            p_ue_curr_meas_object_to_add_mod->meas_object.t = 
                UECC_MEAS_OBJECT_TO_ADD_CDMA2000_PRESENT;

            result = uecc_rrc_update_curr_MeasObjectCDMA2000(
                    &p_ue_curr_meas_object_to_add_mod->meas_object.u.meas_object_cdma2000,
                    &p_rrm_meas_object_to_add_mod->meas_object.meas_object_cdma2000,
                    p_uecc_gb_context);

            break;

        case MEAS_OBJECT_TO_ADD_EUTRA_PRESENT:
            p_ue_curr_meas_object_to_add_mod->meas_object_id =
                p_rrm_meas_object_to_add_mod->meas_object_id;

            p_ue_curr_meas_object_to_add_mod->meas_object.t = 
                UECC_MEAS_OBJECT_TO_ADD_EUTRA_PRESENT;
            result = uecc_rrc_update_curr_MeasObjectEUTRA(
                    &p_ue_curr_meas_object_to_add_mod->meas_object.u.meas_object_eutra,
                    &p_rrm_meas_object_to_add_mod->meas_object.meas_object_eutra,
                    p_uecc_gb_context);

            break;

        case MEAS_OBJECT_TO_ADD_UTRA_PRESENT:
            p_ue_curr_meas_object_to_add_mod->meas_object_id =
                p_rrm_meas_object_to_add_mod->meas_object_id;

            p_ue_curr_meas_object_to_add_mod->meas_object.t = 
                UECC_MEAS_OBJECT_TO_ADD_UTRA_PRESENT;
            result = uecc_rrc_update_curr_MeasObjectUTRA(
                    &p_ue_curr_meas_object_to_add_mod->meas_object.u.meas_object_utra,
                    &p_rrm_meas_object_to_add_mod->meas_object.meas_object_utra,
                    p_uecc_gb_context);

            break;

        case MEAS_OBJECT_TO_ADD_GERAN_PRESENT:

            p_ue_curr_meas_object_to_add_mod->meas_object_id =
                p_rrm_meas_object_to_add_mod->meas_object_id;

            p_ue_curr_meas_object_to_add_mod->meas_object.t = 
                UECC_MEAS_OBJECT_TO_ADD_GERAN_PRESENT;
            p_ue_curr_meas_object_to_add_mod->meas_object.u.meas_object_geran =
                p_rrm_meas_object_to_add_mod->meas_object.meas_object_geran;

            result = RRC_SUCCESS;

            break;

        #ifdef ENDC_ENABLED
        case MEAS_OBJECT_TO_ADD_NR_PRESENT:
            p_ue_curr_meas_object_to_add_mod->meas_object_id =
                p_rrm_meas_object_to_add_mod->meas_object_id;

            p_ue_curr_meas_object_to_add_mod->meas_object.t = 
                UECC_MEAS_OBJECT_TO_ADD_NR_PRESENT;

            result = uecc_rrc_update_curr_MeasObject_NR(
                    &p_ue_curr_meas_object_to_add_mod->meas_object.u.meas_object_nr,
                    &p_rrm_meas_object_to_add_mod->meas_object.meas_object_nr,
                    p_uecc_gb_context);

            break;

        #endif


        default:
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "uecc_rrc_update_curr_MeasobjectToAddMod -> wrong bitmask");
            break;
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
 * *   FUNCTION NAME: uecc_rrc_update_MeasObjectToAddModList_to_CurrMeasConfigList
 * *   INPUT        : rrm_meas_config_t* p_rrm_meas_config
 *                    uecc_ue_curr_meas_config_t* p_curr_rrm_meas_config
 *                    uecc_gb_context_t*       p_uecc_gb_context
 *     OUTPUT       : none
 * *   DESCRIPTION  : This function builds MeasObjectToAddModList in CurrMeasConfig structure
 * *
 * *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 * *
 * ******************************************************************************/
rrc_return_et uecc_rrc_update_MeasObjectToAddModList_to_CurrMeasConfigList(
        rrm_meas_config_t* p_rrm_meas_config,
        uecc_ue_curr_meas_config_t* p_curr_rrm_meas_config,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */
        )
{
    U8 index = 0;
    U8 meas_object_add = 0;

    uecc_meas_object_to_add_mod_t *p_meas_object = PNULL;
    rrc_return_et   result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_meas_config);

    for (index = 0; index <
            p_rrm_meas_config->meas_object_to_add_mod_list.count; index++)
    {

        meas_object_add = 
            p_rrm_meas_config->meas_object_to_add_mod_list.
            meas_object_to_add_mod[index].meas_object_id;
        if ((0 < meas_object_add) && (meas_object_add <= MAX_MEAS_OBJECT_ID))
        {
            /* if matching meas_object_id exists in the measObjectList */
            p_meas_object = (uecc_meas_object_to_add_mod_t *) 
                ylFind(&p_curr_rrm_meas_config->curr_meas_object_to_add_mod_list,
                        &meas_object_add, 
                        uecc_curr_meas_object_id_keyof, 
                        uecc_curr_meas_compare); 

            if (p_meas_object != PNULL)
            {

                result = uecc_rrc_update_curr_MeasobjectToAddMod (
                        p_meas_object,
                        &p_rrm_meas_config->meas_object_to_add_mod_list.
                        meas_object_to_add_mod[index],
                        p_uecc_gb_context);        

                if (result == RRC_FAILURE)
                {
                    break;
                }

            }
            else
            {
                /* add a new entry for the received measObject 
                 * to the measObjectList and increment the count */
                p_meas_object = (uecc_meas_object_to_add_mod_t*)
                    rrc_mem_get(sizeof(uecc_meas_object_to_add_mod_t));
                /* coverity_fix_61966 start */
                if (p_meas_object == PNULL)
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_FATAL, "Memory Allocation Failed ");
                    result = RRC_FAILURE;
                    break;
                }
                /* coverity_fix_61966 stop */
                /* SPR:9516 start */
                memset_wrapper(p_meas_object, RRC_NULL, sizeof(uecc_meas_object_to_add_mod_t));
                /* SPR:9516 stop */
                p_meas_object->meas_object_id = meas_object_add; 

                result = uecc_rrc_update_curr_MeasobjectToAddMod (
                        p_meas_object,
                        &p_rrm_meas_config->meas_object_to_add_mod_list.
                        meas_object_to_add_mod[index],
                        p_uecc_gb_context);        

                if (result == RRC_FAILURE)
                {
                    /* coverity_fix_63284_start */
                    rrc_mem_free(p_meas_object);
                    p_meas_object = PNULL;
                    /* coverity_fix_63284_stop */
                    break;
                }

                ylPushTail(&p_curr_rrm_meas_config->curr_meas_object_to_add_mod_list,
                        (YLNODE*)p_meas_object);    
            }
        }
        else
        {
            /* Log the message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"meas_object_add : %u,"
                    " is not within the Range",meas_object_add);
            result = RRC_FAILURE;
            break;
        }
        result = RRC_SUCCESS;
    }

    /* Coverity Fix 63284 Start */
    if ((RRC_FAILURE == result) && 
            (PNULL != p_meas_object))
    {
        rrc_mem_free(p_meas_object);
        p_meas_object = PNULL;
    }
    /* Coverity Fix 63284 Stop */

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
 * *   FUNCTION NAME: uecc_rrc_update_MeasIdToRemoveList_to_CurrMeasConfigList
 *                    uecc_ue_curr_meas_config_t* p_curr_rrm_meas_config
 * *   INPUT        : rrm_meas_config_t* p_rrm_meas_config
 *                    uecc_gb_context_t*       p_uecc_gb_context
 *     OUTPUT       : none
 * *   DESCRIPTION  : This function update MeasIdToRemoveList in
 * *                  CurrMeasConfig structure
 * *
 * *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 * *
 * ******************************************************************************/
rrc_return_et uecc_rrc_update_MeasIdToRemoveList_to_CurrMeasConfigList(
        rrm_meas_config_t* p_rrm_meas_config,
        uecc_ue_curr_meas_config_t* p_curr_rrm_meas_config,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */
        )
{
    U8 index = 0;
    U8 meas_id_del = 0;

    rrc_return_et   result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_meas_config);

    for (index = 0; index <
            p_rrm_meas_config->meas_id_to_remove_list.count; index++)
    {
        /* remove the entry with the matching meas_id from
         * the measIdList. */
        meas_id_del = 
            p_rrm_meas_config->meas_id_to_remove_list.meas_id[index];
        if ((0 < meas_id_del) && (meas_id_del <= MAX_MEAS_ID))
        {
            if (p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                    meas_id_to_add_mod[meas_id_del - 1].meas_id != 0)
            {
                /* Log the message */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_INFO,"meas_id : %u deleted",
                        meas_id_del);
                p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                    meas_id_to_add_mod[meas_id_del - 1].meas_id = 0; 

                p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                    meas_id_to_add_mod[meas_id_del - 1].meas_object_id = 0; 

                p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                    meas_id_to_add_mod[meas_id_del - 1].report_config_id = 0; 
                /* SPR 15905 Fix Start */
                p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                    meas_id_to_add_mod[meas_id_del - 1].meas_id_deleted = RRC_TRUE;
                /* SPR 15905 Fix Stop */
                /* decrement the counter */
                --p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.count;
            }
            else
            {
                /* SPR 15905 Fix Start */
                if ( RRC_TRUE == p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                        meas_id_to_add_mod[meas_id_del - 1].meas_id_deleted )
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,"meas_id : %u already deleted ", meas_id_del);
                }
                else
                {/* SPR 15905 Fix Stop */
                    /* Log the message */
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,"Can not Remove meas_id : %u,"
                            " As this meas_id is not present",
                            meas_id_del);
                    result = RRC_FAILURE;
                    break; /* SPR 15905 Fix Start */
                }/* SPR 15905 Fix Stop */
            }      
        }
        else
        {
            /* Log the message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"Remove meas_id : %u,"
                    " is not within the Range",meas_id_del);
            result = RRC_FAILURE;
            break;
        }
        result = RRC_SUCCESS;
    }        
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/******************************************************************************
 * *   FUNCTION NAME: uecc_rrc_update_ReportConfigToRemoveList_to_CurrMeasConfigList
 * *   INPUT        : rrm_meas_config_t* p_rrm_meas_config
 *                    uecc_ue_curr_meas_config_t* p_curr_rrm_meas_config 
 *                    uecc_gb_context_t*       p_uecc_gb_context
 *     OUTPUT       : none
 * *   DESCRIPTION  : This function update MeasIdToRemoveList in
 * *                  CurrMeasConfig structure
 * *
 * *   RETURNS      : None
 * *
 * ******************************************************************************/
rrc_return_et uecc_rrc_update_ReportConfigToRemoveList_to_CurrMeasConfigList(
        rrm_meas_config_t* p_rrm_meas_config,
        uecc_ue_curr_meas_config_t* p_curr_rrm_meas_config,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */
        )
{
    U8 index = 0;
    U8 i = 0;
    U8 report_config_del = 0;
    uecc_report_config_to_add_mod_t *p_report_config = PNULL;

    rrc_return_et   result = RRC_FAILURE;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_meas_config);

    for (index = 0; index <
            p_rrm_meas_config->report_config_to_remove_list.count; index++)
    {
        /* Remove the entry with the matching report_config_id 
         * from the report_config_List */

        report_config_del = 
            p_rrm_meas_config->report_config_to_remove_list.report_config_id[index];
        if ((0 < report_config_del) && (report_config_del <= MAX_REPORT_CONFIG_ID))
        {
            /* Log the message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO,"report_config : %u",
                    report_config_del);
            p_report_config = (uecc_report_config_to_add_mod_t *) 
                ylFind(&p_curr_rrm_meas_config->curr_report_config_to_add_mod_list,
                        &report_config_del, 
                        uecc_curr_report_config_id_keyof, 
                        uecc_curr_meas_compare);
            if (p_report_config != PNULL)
            {
                ylDelete(&p_curr_rrm_meas_config->curr_report_config_to_add_mod_list,
                        (YLNODE *)p_report_config);

                rrc_mem_free(p_report_config);

                /* remove all meas_id associated with this report_config_id 
                 * from the measIdList, if any */
                /* Bug_10698_1 Fix Start*/
                for (i = 0;i < MAX_MEAS_ID; i++)
                {
                    /* Bug_10698_1 Fix Stop*/
                    if (report_config_del == 
                            p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                            meas_id_to_add_mod[i].report_config_id)
                    {   
                        /* Bug_10698 Fix Start*/
                        p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                            meas_id_to_add_mod[i].meas_id = 0;

                        p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                            meas_id_to_add_mod[i].meas_object_id = 0;

                        p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                            meas_id_to_add_mod[i].report_config_id = 0;
                        /* Bug_10698 Fix Stop*/
                        /* SPR 15905 Start */
                        p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                            meas_id_to_add_mod[i].meas_id_deleted = RRC_TRUE; 
                        /* SPR 15905 Fix Stop */

                        /* decrement the count of meas_id */
                        --p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.count;
                    }
                }
            }
            else
            {
                /* Log the message */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,"Can not Remove Report_config  : %u,"
                        " As this report_config is not present",report_config_del);
                result = RRC_FAILURE;
                break;

            }
        }
        else
        {
            /* Log the message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"remove report_config : %u,"
                    " is not within the Range",report_config_del);
            result = RRC_FAILURE;
            break;
        }
        result = RRC_SUCCESS;
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/******************************************************************************
 * *   FUNCTION NAME: uecc_rrc_update_ReportConfigToAddModList_to_CurrMeasConfigList
 * *   INPUT        : rrm_meas_config_t* p_rrm_meas_config
 *                    uecc_ue_curr_meas_config_t* p_curr_rrm_meas_config
 *                    uecc_gb_context_t*       p_uecc_gb_context
 *     OUTPUT       : none               
 * *   DESCRIPTION  : This function update ReportConfigToAddModList in
 * *                  CurrMeasConfig structure
 * *
 * *   RETURNS      : None
 * *
 * ******************************************************************************/
rrc_return_et uecc_rrc_update_ReportConfigToAddModList_to_CurrMeasConfigList(
        rrm_meas_config_t* p_rrm_meas_config,
        uecc_ue_curr_meas_config_t* p_curr_rrm_meas_config,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */
        )
{
    U8 index = 0;
    U8 report_config_add = 0;
    uecc_report_config_to_add_mod_t *p_report_config = PNULL;

    rrc_return_et   result = RRC_FAILURE;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_meas_config);

    for (index = 0; index <
            p_rrm_meas_config->report_config_to_add_mod_list.count; index++)
    {

        report_config_add = 
            p_rrm_meas_config->report_config_to_add_mod_list.
            report_config_to_add_mod[index].report_config_id;
        if ((0 < report_config_add) && (report_config_add <= MAX_REPORT_CONFIG_ID))
        {
            /* if an entry with the matching report_config_id exist in 
             * reportConfigList. */
            p_report_config = (uecc_report_config_to_add_mod_t *) 
                ylFind(&p_curr_rrm_meas_config->curr_report_config_to_add_mod_list,
                        &report_config_add, 
                        uecc_curr_report_config_id_keyof, 
                        uecc_curr_meas_compare);
            if (p_report_config != PNULL)
            {
                /* replace the entry with the value received for this report config */
                p_report_config->report_config_id = 
                    report_config_add;
                l3_memcpy_wrapper(&p_report_config->report_config,
                        &p_rrm_meas_config->report_config_to_add_mod_list.
                        report_config_to_add_mod[index].report_config,
                        sizeof(report_config_to_add_mod_report_config_t));
            }
            else 
            {
                /* add a new entry for the received report config 
                 * to the reportConfiglist */
                p_report_config = (uecc_report_config_to_add_mod_t*)
                    rrc_mem_get(sizeof(uecc_report_config_to_add_mod_t));
                if (p_report_config == PNULL)
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_FATAL, "Memory Allocation Failed ");
                    result = RRC_FAILURE;
                    break;
                }

                p_report_config->report_config_id = 
                    report_config_add;

                l3_memcpy_wrapper(&p_report_config->report_config, 
                        &p_rrm_meas_config->report_config_to_add_mod_list.
                        report_config_to_add_mod[index].report_config,
                        sizeof(report_config_to_add_mod_report_config_t));

                ylPushTail(&p_curr_rrm_meas_config->curr_report_config_to_add_mod_list,
                        (YLNODE*)p_report_config);    

            }
        }
        else
        {
            /* Log the message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"add report_config : %u,"
                    " is not within the Range",report_config_add);
            result = RRC_FAILURE;
            break;
        }
        result = RRC_SUCCESS;
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
 * *   FUNCTION NAME: uecc_rrc_update_MeasIdToAddModList_to_CurrMeasConfigList
 * *   INPUT        : rrm_meas_config_t* p_rrm_meas_config
 *                    uecc_ue_curr_meas_config_t* p_curr_rrm_meas_config
 *                    uecc_gb_context_t*       p_uecc_gb_context
 *     OUTPUT       : none               
 * *
 * *   DESCRIPTION  : This function update MeasIdToAddModList in
 * *                  CurrMeasConfig structure
 * *
 * *   RETURNS      : None
 * *
 * ******************************************************************************/
rrc_return_et uecc_rrc_update_MeasIdToAddModList_to_CurrMeasConfigList(
        rrm_meas_config_t* p_rrm_meas_config,
        uecc_ue_curr_meas_config_t* p_curr_rrm_meas_config,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */
        )
{
    /* BUG_304 Start */
    U8 index = 0;
    U8 index2 = 0;
    U8 meas_id_add = 0;
    U8 meas_id_found = 0;

    rrc_return_et   result = RRC_FAILURE;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_meas_config);

    for (index = 0; index <
            p_rrm_meas_config->meas_id_to_add_mod_list.count; index++)
    {

        meas_id_add = 
            p_rrm_meas_config->meas_id_to_add_mod_list.
            meas_id_to_add_mod[index].meas_id;
        if ((0 < meas_id_add) && (meas_id_add <= MAX_MEAS_ID))
        {
            for (index2 = 0; index2 < MAX_MEAS_ID; index2++)
            {
                if (meas_id_add == 
                        p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                        meas_id_to_add_mod[index2].meas_id)
                {
                    meas_id_found = 1;
                    break;
                }
            }
            if(meas_id_found == 1)
            {
                /* SPR 15905 Fix Start */
                p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                    meas_id_to_add_mod[index2].meas_id =
                    p_rrm_meas_config->meas_id_to_add_mod_list.
                    meas_id_to_add_mod[index].meas_id;
                p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                    meas_id_to_add_mod[index2].meas_object_id =
                    p_rrm_meas_config->meas_id_to_add_mod_list.
                    meas_id_to_add_mod[index].meas_object_id;
                p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                    meas_id_to_add_mod[index2].report_config_id =
                    p_rrm_meas_config->meas_id_to_add_mod_list.
                    meas_id_to_add_mod[index].report_config_id;
                /* SPR 15905 Fix Stop */

            }
            else 
            {
                /* add a new entry for this meas_id */
                /* SPR 13261 Fix Start */
                p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                    meas_id_to_add_mod[meas_id_add - 1].meas_id = meas_id_add;

                p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                    meas_id_to_add_mod[meas_id_add - 1].meas_object_id =
                    p_rrm_meas_config->meas_id_to_add_mod_list.
                    meas_id_to_add_mod[index].meas_object_id;

                p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.
                    meas_id_to_add_mod[meas_id_add - 1].report_config_id =
                    /* SPR 13261 Fix Stop */
                    p_rrm_meas_config->meas_id_to_add_mod_list.
                    meas_id_to_add_mod[index].report_config_id;
                ++p_curr_rrm_meas_config->curr_meas_id_to_add_mod_list.count;
            }
        }
        else
        {
            /* Log the message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"meas_id_add : %u,"
                    " is not within the Range",meas_id_add);
            result = RRC_FAILURE;
            break;
        }
        result = RRC_SUCCESS;
        meas_id_found = 0;
    }
    /* BUG_304 Stop */
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
 * *   FUNCTION NAME: uecc_rrc_update_CurrMeasConfigList
 * *   INPUT        : rrm_meas_config_t* p_rrm_meas_config
 *                    uecc_ue_curr_meas_config_t* p_curr_rrm_meas_config
 *                    uecc_gb_context_t*       p_uecc_gb_context
 *     OUTPUT       : none               
 * *
 * *   DESCRIPTION  : This function builds CurrMeasConfig field from MeasConfig and update
 * *                  the UE context.
 * *
 * *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 * *
 * ******************************************************************************/
rrc_return_et uecc_rrc_update_CurrMeasConfigList(
        rrm_meas_config_t*  p_rrm_meas_config,
        uecc_ue_curr_meas_config_t*  p_ue_curr_meas_config,
        uecc_gb_context_t*       p_uecc_gb_context      /* UECC global context */
        )
{
    rrc_return_et       result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rrm_meas_config);
    do
    {
        /* MeasObjectToRemoveList */
        if (UE_ADM_MEAS_OBJECT_TO_REMOVE_LIST_PRESENT &
                p_rrm_meas_config->bitmask)
        {
            result = uecc_rrc_update_MeasObjectToRemoveList_to_CurrMeasConfigList(
                    p_rrm_meas_config,
                    p_ue_curr_meas_config,
                    p_uecc_gb_context
                    );

            if (RRC_FAILURE == result)
            {
                break;
            }
            p_ue_curr_meas_config->m.curr_meas_object_to_add_mod_list_present = 1; 
        }
        /* MeasObjectToAddModList */
        if (UE_ADM_MEAS_OBJECT_TO_ADD_MOD_LIST_PRESENT &
                p_rrm_meas_config->bitmask)
        {

            /* fill list of MeasObjectToAddMod */
            result = uecc_rrc_update_MeasObjectToAddModList_to_CurrMeasConfigList(
                    p_rrm_meas_config,
                    p_ue_curr_meas_config,
                    p_uecc_gb_context
                    );

            if (RRC_FAILURE == result)
            {
                break;
            }
            p_ue_curr_meas_config->m.curr_meas_object_to_add_mod_list_present = 1; 
        }

        /* ReportConfigToRemoveList */
        if (UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT &
                p_rrm_meas_config->bitmask)
        {

            result = uecc_rrc_update_ReportConfigToRemoveList_to_CurrMeasConfigList(
                    p_rrm_meas_config,
                    p_ue_curr_meas_config,
                    p_uecc_gb_context
                    );

            if (RRC_FAILURE == result)
            {
                break;
            }
            p_ue_curr_meas_config->m.curr_meas_report_config_to_add_mod_list_present = 1; 
        }

        /* ReportConfigToAddModList */
        if (UE_ADM_MEAS_REPORT_CONFIG_TO_ADD_MOD_LIST_PRESENT &
                p_rrm_meas_config->bitmask)
        {

            /* fill list of ReportConfigToAddMod */
            result = uecc_rrc_update_ReportConfigToAddModList_to_CurrMeasConfigList(
                    p_rrm_meas_config,
                    p_ue_curr_meas_config,
                    p_uecc_gb_context
                    );

            if (RRC_FAILURE == result)
            {
                break;
            }
            p_ue_curr_meas_config->m.curr_meas_report_config_to_add_mod_list_present = 1; 
        }

        /* MeasIdToRemoveList */
        if (UE_ADM_MEAS_ID_TO_REMOVE_LIST_PRESENT &
                p_rrm_meas_config->bitmask)
        {

            result = uecc_rrc_update_MeasIdToRemoveList_to_CurrMeasConfigList(
                    p_rrm_meas_config,
                    p_ue_curr_meas_config,
                    p_uecc_gb_context
                    );

            if (RRC_FAILURE == result)
            {
                break;
            }
            p_ue_curr_meas_config->m.curr_meas_id_to_add_mod_list_present = 1; 
        }

        /* MeasIdToAddModList */
        if (UE_ADM_MEAS_ID_TO_ADD_MOD_LIST_PRESENT &
                p_rrm_meas_config->bitmask)
        {

            /* fill list of MeasIdToAddMod */
            result = uecc_rrc_update_MeasIdToAddModList_to_CurrMeasConfigList(
                    p_rrm_meas_config,
                    p_ue_curr_meas_config,
                    p_uecc_gb_context
                    );

            if (RRC_FAILURE == result)
            {
                break;
            }
            p_ue_curr_meas_config->m.curr_meas_id_to_add_mod_list_present = 1; 
        }

        /* QuantityConfig */
        if (UE_ADM_MEAS_QUANTITY_CONFIG_PRESENT &
                p_rrm_meas_config->bitmask)
        {
            p_ue_curr_meas_config->curr_quantity_config = 
                p_rrm_meas_config->quantity_config;
            p_ue_curr_meas_config->m.curr_meas_quantity_config_present = 1; 

        }

        /* MeasGapConfig */
        if (UE_ADM_MEAS_GAP_CONFIG_PRESENT & p_rrm_meas_config->bitmask)
        {
            /* SPR 16350 Start */
            if(1 == p_rrm_meas_config->meas_gap_config.meas_gap_config_type)
            {/* for setup */
                p_ue_curr_meas_config->curr_meas_gap_config = 
                    p_rrm_meas_config->meas_gap_config;
                p_ue_curr_meas_config->m.curr_meas_gap_config_present = 1;
            }
            else
            {/* for release */
                p_ue_curr_meas_config->m.curr_meas_gap_config_present = 0;
            }
            /* SPR 16350 Stop */
        }

        /* RSRP_Range */
        if (UE_ADM_MEAS_S_MEASURE_PRESENT & p_rrm_meas_config->bitmask)
        {
            p_ue_curr_meas_config->curr_s_measure = 
                p_rrm_meas_config->s_measure;
            p_ue_curr_meas_config->m.curr_meas_s_measure_present = 1;
        }

        /* PreRegistrationInfoHRPD */
        if (UE_ADM_MEAS_PRE_REGISTRATION_INFO_PRESENT &
                p_rrm_meas_config->bitmask)
        {
            p_ue_curr_meas_config->curr_pre_registration_info_hrpd = 
                p_rrm_meas_config->pre_registration_info_hrpd;
            p_ue_curr_meas_config->m.curr_meas_pre_registration_info_present = 1;
        }

        /* MeasConfig_speedStatePars */
        if (UE_ADM_MEAS_SPEED_STATE_PARS_PRESENT & p_rrm_meas_config->bitmask)
        {
            p_ue_curr_meas_config->curr_meas_config_speed_state_pars = 
                p_rrm_meas_config->meas_config_speed_state_pars;
            p_ue_curr_meas_config->m.curr_meas_speed_state_pars_present = 1;
        }

        #ifdef ENDC_ENABLED
        /* fr1_gap_r15 */
        if ( UE_ADM_FR1_GAP_R15_PRESENT &
            p_rrm_meas_config->bitmask )
        {
            p_ue_curr_meas_config->curr_fr1_gap_r15 = 
                p_rrm_meas_config->fr1_gap_r15;
            p_ue_curr_meas_config->m.curr_fr1_gap_r15_present = RRC_ONE;
        }

        /* mgta_r15 */
        if ( UE_ADM_MGTA_R15_PRESENT &
            p_rrm_meas_config->bitmask )
        {
            p_ue_curr_meas_config->curr_mgta_r15 = 
                p_rrm_meas_config->mgta_r15;
            p_ue_curr_meas_config->m.curr_mgta_r15_present = RRC_ONE;
        }
        #endif

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;

}
/* Measurment Re-config END */


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_rrcConnectionReconfigurationComplete
 *   INPUT        : uecc_gb_context_t       *p_uecc_gb_context
 *                  rrc_ue_index_t          ue_index
 *                  RRCConnectionReconfigurationComplete *rrcConnectionReconfigurationComplete
 *   OUTPUT       : none
 *   DESCRIPTION  : This function processes RRCConnectionReconfigurationComplete message
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_process_dcch_rrcConnectionReconfigurationComplete(
        uecc_gb_context_t       *p_uecc_gb_context,      /* UECC global context */
        rrc_ue_index_t          ue_index,                /* UE index  */
        RRCConnectionReconfigurationComplete *rrcConnectionReconfigurationComplete
        )
{
    uecc_ue_context_t*                              p_ue_context = PNULL;
    rrc_return_et                                   result = RRC_FAILURE;
    RRCConnectionReconfigurationComplete_r8_IEs*
        p_rrcConnectionReconfigurationComplete_r8 = PNULL;


    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        /* Check message */
        if ( (
                    T_RRCConnectionReconfigurationComplete_criticalExtensions_rrcConnectionReconfigurationComplete_r8
                    != rrcConnectionReconfigurationComplete->criticalExtensions.t)
                || (PNULL == rrcConnectionReconfigurationComplete->
                    criticalExtensions.u.rrcConnectionReconfigurationComplete_r8) )
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionReconfigurationComplete] "
                    "Invalid message format.");
            break;
        }

        /* Get pointer on message data */
        p_rrcConnectionReconfigurationComplete_r8 =
            rrcConnectionReconfigurationComplete->
            criticalExtensions.u.rrcConnectionReconfigurationComplete_r8;

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionReconfigurationComplete] "
                    "UE context not found.");
            break;
        }
        /* Measurment Re-config START */

        /* Check  rrc_TransactionIdentifier 
         * received with "meas_transaction_id" in UE context */
        if ((RRC_TRUE == p_ue_context->is_meas_transaction_id_valid) &&
                (rrcConnectionReconfigurationComplete->rrc_TransactionIdentifier ==
                 (uecc_ue_ctx_get_meas_transction_id(p_ue_context) & UECC_LTE_RRC_TRANSACTION_ID_MASK)))
        {
            /* stop the meas config guard timer */
            uecc_ue_timer_stop(
                    p_uecc_gb_context, 
                    UECC_UE_MEAS_CONFIG_GUARD_TIMER, 
                    &p_ue_context->timers_data);

            /* Reset the transaction-id */
            p_ue_context->is_meas_transaction_id_valid = RRC_FALSE;

            if (p_ue_context->p_meas_config != PNULL)
            {
                if (RRC_SUCCESS != uecc_rrc_update_CurrMeasConfigList(
                            p_ue_context->p_meas_config,
                            &p_ue_context->curr_meas_config,
                            p_uecc_gb_context))
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "Failure to update CurrMeasConfigList.");
                    /* Build and send the RRC_RRM_MEAS_CONFIG_RESP(Failure) to RRM */
                    if (RRC_SUCCESS != uecc_rrm_build_and_send_meas_config_resp(
                                p_ue_context,RRC_FAILURE, RRC_NO_ERROR))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,
                                "Failure to build and send meas config resp to RRM.");
                        break;
                    }
                    break;
                }
            }
            /* Build and send the RRC_RRM_MEAS_CONFIG_RESP(success) to RRM */
            if (RRC_SUCCESS != uecc_rrm_build_and_send_meas_config_resp(
                        p_ue_context,RRC_SUCCESS, RRC_NO_ERROR))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "Failure to build and send meas config resp to RRM.");
                break;
            }
            /*SPR_16811_START*/
            else
            {
                result = RRC_SUCCESS;
            }
            /*SPR_16811_END*/


            if (p_ue_context->p_meas_config != PNULL)
            {
                /* Memory Optimization: Free the meas_config data.*/
                rrc_mem_free(p_ue_context->p_meas_config);
                p_ue_context->p_meas_config = PNULL;
            }
            break;
        }
        /* Measurment Re-config END */
        /* Check RRC_TransactionIdentifier rrc_TransactionIdentifier */
        else if (rrcConnectionReconfigurationComplete->rrc_TransactionIdentifier !=
                (uecc_ue_ctx_get_op_transction_id(p_ue_context) &
                 UECC_LTE_RRC_TRANSACTION_ID_MASK))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCConnectionReconfigurationComplete] "
                    "Invalid transaction id.");
            break;
        }
        if(p_rrcConnectionReconfigurationComplete_r8->m.nonCriticalExtensionPresent &&
                p_rrcConnectionReconfigurationComplete_r8->nonCriticalExtension.m.nonCriticalExtensionPresent)
        {
            p_ue_context->rlf_proc_flags.m.rrc_conn_setup_reconfigure_rlf_info_present = 
                p_rrcConnectionReconfigurationComplete_r8->nonCriticalExtension.nonCriticalExtension.m.rlf_InfoAvailable_r10Present;
        }
        /* Measurment Re-config END */
  
#ifdef ENDC_ENABLED
        /*NR_DC Code Change Start*/
        /*
         * Checking for r15 IEs in RRCConnectionReconfigComplete
         * scg-ConfigResponseNR-r15, if found will be stored in uecc_ue_ctx and
         * will be send as MeNBToSgNBContainer in SgNBReconfigurationComplete.
         */
        if(p_rrcConnectionReconfigurationComplete_r8->m.nonCriticalExtensionPresent &&
            p_rrcConnectionReconfigurationComplete_r8->nonCriticalExtension.m.nonCriticalExtensionPresent && 
            p_rrcConnectionReconfigurationComplete_r8->nonCriticalExtension.nonCriticalExtension.m.\
            nonCriticalExtensionPresent &&
            p_rrcConnectionReconfigurationComplete_r8->nonCriticalExtension.nonCriticalExtension.\
            nonCriticalExtension.m.nonCriticalExtensionPresent &&
            p_rrcConnectionReconfigurationComplete_r8->nonCriticalExtension.nonCriticalExtension.\
            nonCriticalExtension.nonCriticalExtension.m.nonCriticalExtensionPresent &&
            p_rrcConnectionReconfigurationComplete_r8->nonCriticalExtension.nonCriticalExtension.\
            nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.m.nonCriticalExtensionPresent &&
            p_rrcConnectionReconfigurationComplete_r8->nonCriticalExtension.nonCriticalExtension.\
            nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.\
            m.scg_ConfigResponseNR_r15Present
         )
        {
            p_ue_context->scg_config_response_nr.numocts = 
                p_rrcConnectionReconfigurationComplete_r8->nonCriticalExtension.\
                    nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.\
                    nonCriticalExtension.nonCriticalExtension.scg_ConfigResponseNR_r15.\
                    numocts;

            p_ue_context->scg_config_response_nr.data = (OSOCTET *)
                rrc_mem_get(p_ue_context->scg_config_response_nr.numocts);

            if (PNULL == p_ue_context->scg_config_response_nr.data)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR, "Unable to allocate memory to scg_config_response_nr");
                break;
            }
            memset_wrapper ((void *)p_ue_context->scg_config_response_nr.data, 
                    RRC_NULL,
                    p_ue_context->scg_config_response_nr.numocts);


            l3_memcpy_wrapper(
                    (void *)p_ue_context->scg_config_response_nr.data,
                    p_rrcConnectionReconfigurationComplete_r8->nonCriticalExtension.\
                        nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.\
                        nonCriticalExtension.nonCriticalExtension.scg_ConfigResponseNR_r15.\
                        data,
                        p_ue_context->scg_config_response_nr.numocts);

            p_ue_context->m.scg_config_response_nr_present = RRC_ONE;
        }
        /*NR_DC Code Change Stop*/
#endif
        /* Call UECC_RM_EVENT_UE_RECONFIG_RESP event handler in RM FSM *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRC_CONNECTION_RECONFIGURATION_COMPLETE,
                rrcConnectionReconfigurationComplete);

        result = RRC_SUCCESS;
    }
    while(0);


    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_ulInformationTransfer
 *   INPUT        : uecc_gb_context_t       *p_uecc_gb_context
 *                  rrc_ue_index_t          ue_index
 *                  ULInformationTransfer   *rrcULInformationTransfer
 *   DESCRIPTION  : This function processes RRCULInformationTransfer message
 *
 *   RETURNS      : RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_process_dcch_ulInformationTransfer(
        uecc_gb_context_t       *p_uecc_gb_context,        /* UECC global context */
        rrc_ue_index_t          ue_index,                  /* UE index  */
        ULInformationTransfer   *rrcULInformationTransfer  /* UE message */
        )

{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;

    ULInformationTransfer_r8_IEs *p_ulInformationTransfer_r8 = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do {
        /* Check message */
        if ((T_ULInformationTransfer_criticalExtensions_c1 !=
                    rrcULInformationTransfer->criticalExtensions.t) || 
                (PNULL == rrcULInformationTransfer->criticalExtensions.u.c1) ||

                (T_ULInformationTransfer_criticalExtensions_c1_ulInformationTransfer_r8
                 != rrcULInformationTransfer->criticalExtensions.u.c1->t) 
                || 
                (PNULL == rrcULInformationTransfer->criticalExtensions.u.c1->
                 u.ulInformationTransfer_r8)
                ||(
                    (T_ULInformationTransfer_r8_IEs_dedicatedInfoType_dedicatedInfoNAS >
                     rrcULInformationTransfer->criticalExtensions.u.c1->
                     u.ulInformationTransfer_r8->dedicatedInfoType.t)
                    &&  
                    (T_ULInformationTransfer_r8_IEs_dedicatedInfoType_dedicatedInfoCDMA2000_HRPD <
                     rrcULInformationTransfer->criticalExtensions.u.c1->
                     u.ulInformationTransfer_r8->dedicatedInfoType.t) 
                  ))
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCULInformationTransfer] Invalid message format.");
            break;
        }

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCULInformationTransfer] "
                    "UE context not found.");
            break;
        }

        p_ulInformationTransfer_r8 = rrcULInformationTransfer->criticalExtensions.
            u.c1->u.ulInformationTransfer_r8;	

        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_S1AP_UL_NAS_TRANSPORT_REQ,
                &p_ulInformationTransfer_r8->dedicatedInfoType);

        result = RRC_SUCCESS;
    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return result;
}

/****************************************************************************
 * Function Name  : uecc_llim_ue_information_resp_handler
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 *                  void*   - api data
 * Outputs        : None
 * Returns        : None
 * Description    : This action routine is called when UECC receives the
 *                  RRC_RRM_UE_INFORMATION_RESP message.
 ****************************************************************************/
void uecc_llim_ue_information_resp_handler(
        uecc_ue_context_t*  p_ue_context,
        void*               p_api
        )
{
    U8          fail_cause = RRC_NULL;

    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_ue_context);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);


    uecc_rrm_ue_information_req_stop_timer(p_ue_context); 

    /* checking result and sending message to RRM */
    if(RRC_SUCCESS == 
            uecc_rrm_build_and_send_ue_information_resp(p_ue_context,(UEInformationResponse_r9*)p_api)) 
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                p_ue_context->p_gb_context->facility_name, RRC_INFO,
                "uecc_rrm_build_and_send_ue_information_resp"
                " sent RRC_RRM_UE_INFORMATION_RESP success");
    }
    else
    {
        fail_cause = RRM_RRC_UE_INFO_INTERNAL_FAILURE;
        if(RRC_SUCCESS != uecc_rrm_build_and_send_rrc_rrm_ue_information_failure(p_ue_context,fail_cause))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "RRC_RRM_UE_INFORMATION failure message not sent to RRM");
        }

    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_ueInformationResp
 *   INPUT        : uecc_gb_context_t       *p_uecc_gb_context
 *                  rrc_ue_index_t          ue_index
 *                  UEInformationResponse_r9 *p_UEInformationResp
 *                  rrc_uecc_llim_srb_data_ind_t *p_srb_data
 *   OUTPUT       : none
 *   DESCRIPTION  : This function processes uecc_llim_process_dcch_ueInformationResp message
 *
 *   RETURNS      : RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_process_dcch_ueInformationResp(
        uecc_gb_context_t       *p_uecc_gb_context,         /* UECC global context*/
        rrc_ue_index_t          ue_index,                   /* UE index  */
        UEInformationResponse_r9 *p_UEInformationResp, /* UE message */
        rrc_uecc_llim_srb_data_ind_t *p_srb_data
        )
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;

    RRC_ASSERT(PNULL !=p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);


    do {
        /* Check message */
        if ( (T_UEInformationRequest_r9_criticalExtensions_c1 !=
                    p_UEInformationResp->criticalExtensions.t)
                || (PNULL == p_UEInformationResp->criticalExtensions.u.c1)
                || (T_UEInformationRequest_r9_criticalExtensions_c1_ueInformationRequest_r9
                    != p_UEInformationResp->criticalExtensions.u.c1->t)
                || (PNULL == p_UEInformationResp->criticalExtensions.u.c1->
                    u.ueInformationResponse_r9)
           )
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING, "[RRCUEInformation] "
                    "Invalid message format.");
            break;
        }

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING, "[RRCUEInformation] "
                    "UE context not found.");
            break;
        }

        if (p_ue_context->ue_info_proc_running != RRC_TRUE)
        {
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING, "[RRCUEInformation] "
                    "UE Information Proc not running .. drop message");
            break;
        }

        /* Check RRC_TransactionIdentifier rrc_TransactionIdentifier */
        if (p_UEInformationResp->rrc_TransactionIdentifier !=
                (uecc_ue_ctx_get_op_transction_id(p_ue_context) &
                 UECC_LTE_RRC_TRANSACTION_ID_MASK))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCUEInformation] Invalid transaction id.");
            break;
        }

        /* TRACE_changes_start */
        /* SPR 16113 Start */
        uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_srb_data->data_buffer,
                p_srb_data->data_buffer_length, "UE Information Response", RRC_UL_DCCH);
        /* SPR 16113 Stop */
        /* TRACE_changes_start */

        if (p_ue_context->rlf_proc_flags.ue_info_proc_intrl)
        {
            p_ue_context->rlf_proc_flags.ue_info_proc_intrl = RRC_FALSE;
            uecc_rrm_ue_information_req_stop_timer(p_ue_context);

            if((PNULL != p_UEInformationResp->criticalExtensions.u.c1) &&
                    (PNULL != p_UEInformationResp->criticalExtensions.u.c1->
                     u.ueInformationResponse_r9))
            {
                if(p_UEInformationResp->criticalExtensions.u.c1->u.
                        ueInformationResponse_r9->m.rlf_Report_r9Present == 1)
                {
                    p_ue_context->rlf_proc_flags.m.rlf_report_present = 1;

                    l3_memcpy_wrapper(&p_ue_context->rlf_proc_flags.rlf_report,
                            &p_UEInformationResp->criticalExtensions.u.c1->u.
                            ueInformationResponse_r9->rlf_Report_r9,
                            sizeof(RLF_Report_r9));
                }
            }
            /*CA_PHASE3_INTER_CELL_MRO_START*/
            if (RRC_TRUE == p_ue_context->too_late_inter_cell_ho_flg)
            {    
                if (RRC_FAILURE == x2ap_build_and_send_rlf_ind(p_ue_context,
                            p_ue_context->p_gb_context))
                {     
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_ERROR,"x2ap_build_and_send_rlf_ind failed.");
                }    
                p_ue_context->too_late_inter_cell_ho_flg = RRC_FALSE;
            }   
            /*CA_PHASE3_INTER_CELL_MRO_STOP*/
            else
            {
                if(RRC_FAILURE == x2ap_build_and_send_reestablishment_ind(
                            p_ue_context))
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_ERROR,
                            "x2ap_build_and_send_reestablishment_ind failed.");
                }
            }
            /* BUG:698 fix start */
            p_ue_context->rlf_proc_flags.m.rlf_report_present = 0;
            /* BUG:698 fix stop */
        }
        else if(p_ue_context->rlf_proc_flags.ue_info_proc_setup_reconfig_rlf)
        {
            p_ue_context->rlf_proc_flags.ue_info_proc_setup_reconfig_rlf = RRC_FALSE;
            p_ue_context->rlf_proc_flags.m.rrc_conn_setup_reconfigure_rlf_info_present = RRC_FALSE;
            uecc_rrm_ue_information_req_stop_timer(p_ue_context);
            if((PNULL != p_UEInformationResp->criticalExtensions.u.c1) &&
                    (PNULL != p_UEInformationResp->criticalExtensions.u.c1->
                     u.ueInformationResponse_r9))
            {
                if(p_UEInformationResp->criticalExtensions.u.c1->u.
                        ueInformationResponse_r9->m.rlf_Report_r9Present == 1)
                {
                    p_ue_context->rlf_proc_flags.m.rlf_report_present = 1;

                    l3_memcpy_wrapper(&p_ue_context->rlf_proc_flags.rlf_report,
                            &p_UEInformationResp->criticalExtensions.u.c1->u.
                            ueInformationResponse_r9->rlf_Report_r9,
                            sizeof(RLF_Report_r9));
                    if(RRC_FAILURE == x2ap_build_and_send_conn_setup_reconfig_rlf_report(
                                p_ue_context))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_ERROR,
                                "x2ap_build_and_send_conn_setup_reconfig_rlf_report failed.");
                    }

                }
                /* BUG:698 fix start */
                p_ue_context->rlf_proc_flags.m.rlf_report_present = 0;
                /* BUG:698 fix stop */
            }

        }
        else
        {
            uecc_llim_ue_information_resp_handler(p_ue_context, 
                    p_UEInformationResp);
        }

        result = RRC_SUCCESS;
    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return result;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_ueCapabilityInformation
 *   INPUT        : uecc_gb_context_t       *p_uecc_gb_context
 *                  rrc_ue_index_t          ue_index 
 *                  UECapabilityInformation *p_UECapabilityInformation
 *                  rrc_uecc_llim_srb_data_ind_t *p_srb_data
 *   OUTPUT       : none
 *   DESCRIPTION  : This function processes UECapabilityInformation message
 *
 *   RETURNS      : RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_process_dcch_ueCapabilityInformation(
        uecc_gb_context_t       *p_uecc_gb_context,         /* UECC global context*/
        rrc_ue_index_t          ue_index,                   /* UE index  */
        UECapabilityInformation *p_UECapabilityInformation /* UE message */
        )
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);


    do {
        /* Check message */
        if ( (T_UECapabilityEnquiry_criticalExtensions_c1 !=
                    p_UECapabilityInformation->criticalExtensions.t)
                || (PNULL == p_UECapabilityInformation->criticalExtensions.u.c1)
                || (T_UECapabilityEnquiry_criticalExtensions_c1_ueCapabilityEnquiry_r8
                    != p_UECapabilityInformation->criticalExtensions.u.c1->t)
                || (PNULL == p_UECapabilityInformation->criticalExtensions.u.c1->
                    u.ueCapabilityInformation_r8)
           )
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING, "[RRCUECapabilityInformation] "
                    "Invalid message format.");
            break;
        }

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING, "[RRCUECapabilityInformation] "
                    "UE context not found.");
            break;
        }

        /* Check RRC_TransactionIdentifier rrc_TransactionIdentifier */
        if (p_UECapabilityInformation->rrc_TransactionIdentifier !=
                (uecc_ue_ctx_get_op_transction_id(p_ue_context) &
                 UECC_LTE_RRC_TRANSACTION_ID_MASK))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCUECapabilityInformation] Invalid transaction id.");
            break;
        }

        /* Send event to UE Main FSM and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data */
        /*SPR_17893_START*/
        if(RRC_FALSE == p_ue_context->rrm_ue_capability_enq_flag_after_attach)
        {
            uecc_fsm_process_event(
                    p_ue_context,
                    UECC_EV_RRC_UE_CAPABILITY_INFORMATION,
                    p_UECapabilityInformation);
        }
        else
        {
            uecc_ue_capability_information_handler(p_ue_context,p_UECapabilityInformation);
        }
        /*SPR_17893_END*/

        result = RRC_SUCCESS;
    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_securityModeComplete
 *   INPUT        : uecc_gb_context_t       *p_uecc_gb_context
 *                  rrc_ue_index_t          ue_index
 *                  SecurityModeComplete    *p_rrcSecurityModeComplete
 *   OUTPUT       : none
 *   DESCRIPTION  : This function processes RRCSecurityModeComplete message
 *
 *   RETURNS      : RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_process_dcch_securityModeComplete(
        uecc_gb_context_t       *p_uecc_gb_context,        /* UECC global context */
        rrc_ue_index_t          ue_index,                  /* UE index  */
        SecurityModeComplete    *p_rrcSecurityModeComplete /* UE message */
        )
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;
    /* SPR 16895 Fix Start */
    /* Code Removed */
    /* SPR 16895 Fix Stop */


    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do {
        /* Check message */
        if (
                (T_SecurityModeComplete_criticalExtensions_securityModeComplete_r8 !=
                 p_rrcSecurityModeComplete->criticalExtensions.t)
                ||
                (PNULL == p_rrcSecurityModeComplete->
                 criticalExtensions.u.securityModeComplete_r8)
           )
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCSecurityModeComplete] Invalid message format.");
            break;
        }

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCSecurityModeComplete] UE context not found.");
            break;
        }
        /* Check RRC_TransactionIdentifier rrc_TransactionIdentifier */
        if (p_rrcSecurityModeComplete->rrc_TransactionIdentifier !=
                (uecc_ue_ctx_get_op_transction_id(p_ue_context) &
                 UECC_LTE_RRC_TRANSACTION_ID_MASK))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCSecurityModeComplete] Invalid transaction id.");
            break;
        }
        /* SPR 16895 Fix Start */
        /* Code Removed */
        /* SPR 16895 Fix Stop */

        /* Send event to UE Main FSM and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRC_SECURITY_MODE_COMPLETE,
                PNULL);

        result = RRC_SUCCESS;
    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_securityModeFailure
 *   INPUT        : uecc_gb_context_t       *p_uecc_gb_context
 *                  rrc_ue_index_t          ue_index
 *                  SecurityModeFailure     *p_rrcSecurityModeFailure
 *   OUTPUT       : none
 *   DESCRIPTION  : This function processes RRCSecurityModeFailure message
 *
 *   RETURNS      : RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_process_dcch_securityModeFailure(
        uecc_gb_context_t       *p_uecc_gb_context,        /* UECC global context */
        rrc_ue_index_t          ue_index,                  /* UE index  */
        SecurityModeFailure     *p_rrcSecurityModeFailure/* UE message */
        )
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do {
        /* Check message */
        if (
                (T_SecurityModeFailure_criticalExtensions_securityModeFailure_r8 !=
                 p_rrcSecurityModeFailure->criticalExtensions.t)
                ||
                (PNULL == p_rrcSecurityModeFailure->
                 criticalExtensions.u.securityModeFailure_r8)
           )
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCSecurityModeFailure] Invalid message format.");
            break;
        }

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRCSecurityModeFailure] UE context not found.");
            break;
        }

        /* Send event to UE Main FSM and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRC_SECURITY_MODE_FAILURE,
                PNULL);

        result = RRC_SUCCESS;
    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return result;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_csfbParametersRequestCDMA2000
 *   INPUT        : uecc_gb_context_t                   *p_uecc_gb_context
 *                  rrc_ue_index_t                      ue_index
 *                  CSFBParametersRequestCDMA2000       *p_csfbParametersRequestCDMA2000
 *                  rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
 *   OUTPUT       : none
 *   DESCRIPTION  : This function processes CSFBParametersRequestCDMA2000 message
 *
 *   RETURNS      : RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_process_dcch_csfbParametersRequestCDMA2000(
        uecc_gb_context_t       		*p_uecc_gb_context,        	 /* UECC global context */
        rrc_ue_index_t          		ue_index,                  	 /* UE index  */
        CSFBParametersRequestCDMA2000   	*p_csfbParametersRequestCDMA2000, /* UE message */
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
        )
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;


    RRC_ASSERT (PNULL != p_csfbParametersRequestCDMA2000);
    RRC_ASSERT (PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do {
        /* Check message */
        if (
                (T_CSFBParametersRequestCDMA2000_criticalExtensions_csfbParametersRequestCDMA2000_r8 !=
                 p_csfbParametersRequestCDMA2000->criticalExtensions.t)
                ||
                (PNULL == p_csfbParametersRequestCDMA2000->
                 criticalExtensions.u.csfbParametersRequestCDMA2000_r8)
           )
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[CSFBParametersRequestCDMA2000] Invalid message format.");
            break;
        }

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[CSFBParametersRequestCDMA2000] UE context not found.");
            break;
        }

        /* TRACE_changes_start */
        /* SPR 16113 Start */
        uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_srb_data_ind->data_buffer, 
                p_srb_data_ind->data_buffer_length, "CSFB Parameters Request CDMA2000", RRC_UL_DCCH);
        /* SPR 16113 Stop */
        /* TRACE_changes_start */

        /* Send event to UE Main FSM and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_CSFB_PARAMETERS_REQUEST_CDMA2000,
                p_csfbParametersRequestCDMA2000);

        result = RRC_SUCCESS;
    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_delete_ue_entity_resp
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function processes LLIM UECC_LLIM_DELETE_UE_ENTITY_RESP message
 *
 *   RETURNS      : None
 *
 ******************************************************************************/
void uecc_llim_process_delete_ue_entity_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t                      *p_ue_context = PNULL;
    rrc_uecc_llim_delete_ue_entity_resp_t* p_llim_delete_ue_entity_resp = PNULL;

    RRC_ASSERT (PNULL != p_api);
    RRC_ASSERT (PNULL != p_uecc_gb_context);
    RRC_ASSERT (PNULL != p_uecc_gb_context->p_p_csc_context);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_delete_ue_entity_resp =
        (rrc_uecc_llim_delete_ue_entity_resp_t *)((U8*)p_api + RRC_API_HEADER_SIZE);

    if ((RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context,p_llim_delete_ue_entity_resp->cell_index)) &&
            (PNULL != p_uecc_gb_context->
             p_p_csc_context[p_llim_delete_ue_entity_resp->cell_index]) &&
            (RRC_NULL == p_uecc_gb_context->
             p_p_csc_context[p_llim_delete_ue_entity_resp->cell_index]->del_cell_ongoing))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) <
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_delete_ue_entity_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_llim_process_delete_ue_entity_resp: "
                "Wrong message size-ignore");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    {
    p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            p_llim_delete_ue_entity_resp->ue_index);
    }
    if ( PNULL == p_ue_context )
    /*LTE_REG_FIX*/
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_llim_process_delete_ue_entity_resp: "
                "UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Check transaction_id */
    {
        /*LTE_REG_FIX*/
    if (p_llim_delete_ue_entity_resp->transaction_id !=
            uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /* Error. Invalid transaction id */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_llim_process_delete_ue_entity_resp: Invalid transaction id.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }
    }
    /*LTE_REG_FIX*/    


    /* Call UECC_EV_LLIM_DELETE_UE_ENTITY_RESP event handler in RCS FSM */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_DELETE_UE_ENTITY_RESP,
            p_llim_delete_ue_entity_resp);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_configure_security_resp
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_CONFIGURE_SECURITY_RESP message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_configure_security_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t                      *p_ue_context = PNULL;
    rrc_uecc_llim_configure_security_resp_t *p_configure_security_resp = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_configure_security_resp =
        (rrc_uecc_llim_configure_security_resp_t *)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_configure_security_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }
    do {

        /* Precondition - p_api should point to right message */
        if (rrc_get_api_buf_size(p_api) <
                RRC_API_HEADER_SIZE +
                sizeof(rrc_uecc_llim_configure_security_resp_t))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[LLIM_CONFIGURE_SECURITY_RESP] Wrong message size - ignore");
            break;
        }

        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
                p_configure_security_resp->ue_index);
        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[LLIM_CONFIGURE_SECURITY_RESP] UE context not found.");
            break;
        }

        /* Check transaction_id */
        if (p_configure_security_resp->transaction_id !=
                uecc_ue_ctx_get_op_transction_id(p_ue_context))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[LLIM_CONFIGURE_SECURITY_RESP] Invalid transaction id.");
            break;
        }

        /* Call UECC_EV_LLIM_DELETE_UE_ENTITY_RESP event handler in RCS FSM */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_LLIM_CONFIGURE_SECURITY_RESP,
                p_configure_security_resp);
    } while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_srb_data_status_ind
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_SRB_DATA_STATUS_IND message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_srb_data_status_ind
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t                      *p_ue_context = PNULL;

    rrc_uecc_llim_srb_data_status_ind_t    *p_llim_srb_data_status_ind = PNULL;

    RRC_ASSERT( PNULL != p_api );
    RRC_ASSERT( PNULL != p_uecc_gb_context );
    RRC_ASSERT (PNULL != p_uecc_gb_context->p_p_csc_context);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_srb_data_status_ind =
        (rrc_uecc_llim_srb_data_status_ind_t *)((U8*)p_api + RRC_API_HEADER_SIZE);

    if ((RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context,p_llim_srb_data_status_ind->cell_index)) &&
            (PNULL != p_uecc_gb_context->
             p_p_csc_context[p_llim_srb_data_status_ind->cell_index]) &&
            (RRC_NULL == p_uecc_gb_context->
             p_p_csc_context[p_llim_srb_data_status_ind->cell_index]->del_cell_ongoing))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }
    do {
        /* Precondition - p_api should point to right message */
        if (rrc_get_api_buf_size(p_api) <
                RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_srb_data_status_ind_t))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[LLIM_SRB_DATA_STATUS_IND] Wrong message size - ignore.");
            break;
        }

        /* Process message */
    {
/* SPR 21660 changes end */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
                p_llim_srb_data_status_ind->ue_index);
        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[LLIM_SRB_DATA_STATUS_IND] UE context not found.");
            break;
        }
    }

        /* Check transaction_id */
        if ( UECC_NAS_TRANSACTION_ID &
                p_llim_srb_data_status_ind->transaction_id )
        {
            /* NAS delivery indication  */
            /* Call UECC_EV_S1AP_NAS_NON_DELIEVERY_IND event handler
             * in RCR FSM */
            /* WARNING. The uecc_event_queue_push_event can't be used here
             * because the stack variable is used for storing the API data
             * */
            uecc_fsm_process_event(
                    p_ue_context,
                    UECC_EV_S1AP_NAS_NON_DELIEVERY_IND,
                    p_llim_srb_data_status_ind);
        }
        else
        {
            /* Call UECC_RCR_EVENT_SRB_DATA_STATUS_IND event handler in
             * RCR FSM */
            /* WARNING. The uecc_event_queue_push_event can't be used here
             * because the stack variable is used for storing the API data
             * */
            uecc_fsm_process_event(
                    p_ue_context,
                    UECC_EV_LLIM_SRB_DATA_STATUS_IND,
                    p_llim_srb_data_status_ind);
        }
    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_s1u_error_ind
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_S1U_ERROR_IND message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_s1u_error_ind
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t              *p_ue_context = PNULL;
    rrc_uecc_llim_s1u_error_ind_t  *p_llim_s1u_error_ind = PNULL;

    RRC_ASSERT( PNULL != p_api );
    RRC_ASSERT( PNULL != p_uecc_gb_context );
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_s1u_error_ind =
        (rrc_uecc_llim_s1u_error_ind_t *)((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_s1u_error_ind->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }
    do {
        /* Precondition - p_api should point to right message */
        if (rrc_get_api_buf_size(p_api) <
                RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_s1u_error_ind_t))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[UECC_LLIM_S1U_ERROR_IND] Wrong message size - ignore.");
            break;
        }

        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
                p_llim_s1u_error_ind->ue_index);
        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[UECC_LLIM_S1U_ERROR_IND] UE context not found.");
            break;
        }

        /* Call UECC_EV_LLIM_S1U_ERROR_IND event handler.
         * WARNING. The uecc_event_queue_push_event can't be used here
         * because the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_LLIM_S1U_ERROR_IND,
                p_llim_s1u_error_ind);

    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_s1u_path_failure_ind
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_S1U_PATH_FAILURE_IND message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_s1u_path_failure_ind
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    rrc_uecc_llim_s1u_path_failure_ind_t  *p_llim_s1u_path_failure = PNULL;

    RRC_ASSERT( PNULL != p_api );
    RRC_ASSERT( PNULL != p_uecc_gb_context );
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_s1u_path_failure =
        (rrc_uecc_llim_s1u_path_failure_ind_t*)((U8*)p_api + RRC_API_HEADER_SIZE);

    do {
        /* Precondition - p_api should point to right message */
        if (rrc_get_api_buf_size(p_api) <
                RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_s1u_path_failure_ind_t))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[UECC_LLIM_S1U_PATH_FAILURE_IND] Wrong message size - ignore");
            break;
        }
        /* lipa start */
        if ( (RRC_MAX_IP_ADDR_LEN >
                    p_llim_s1u_path_failure->ip_address_octet_size)
                ||
                ( RRC_MAX_IP_ADDR_LEN_IPV6 <
                  p_llim_s1u_path_failure->ip_address_octet_size)
                ||
                (0 == p_llim_s1u_path_failure->ip_address_octet_size))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[UECC_LLIM_S1U_PATH_FAILURE_IND] Wrong parameter value "
                    "ip_address_octet_size[%u] - ignore",
                    p_llim_s1u_path_failure->ip_address_octet_size);
            break;
        }


        /*build and send RRC_RRM_LOCAL_ERROR_IND to RRM informing 
         * about the erabs for which s1u_path_failure_ind has been received 
         * so that RRM can initiate the release of such erabs 
         */       
        uecc_rrm_build_and_send_rrc_rrm_local_error_ind(p_uecc_gb_context,GTP_PATH_FAIL,p_api);
        /* lipa end */
    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_s1u_path_success_ind
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_S1U_PATH_SUCCESS_IND message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_s1u_path_success_ind
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT( PNULL != p_api );
    RRC_ASSERT( PNULL != p_uecc_gb_context );

    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO,
            "[UECC_LLIM_S1U_PATH_SUCCESS_IND] Msg received successfully; Unused"
            "varaible p_api=%p",p_api);/*SPR 17777 +-*/

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_mac_i_resp
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_MAC_I_RESP message
 *
 *   RETURNS:  None
 *
 ******************************************************************************/
void uecc_llim_process_mac_i_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_uecc_llim_mac_i_resp_t*    p_llim_mac_i_resp = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_mac_i_resp = 
        (rrc_uecc_llim_mac_i_resp_t*)((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_mac_i_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }


    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_mac_i_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_MAC_I_RESP] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context, p_llim_mac_i_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_MAC_I_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Check transaction_id */
    if (p_llim_mac_i_resp->transaction_id !=
            uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /* Error. Invalid transaction id */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_MAC_I_RESP] Invalid transaction id.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    if (p_ue_context->x2ap_rlf_ind_recvd_flag)
    {
        U8 rlf_ind_flag = RRC_FALSE;
        U8 ho_report_flag = RRC_FALSE;

        if(p_llim_mac_i_resp->response_code == RRC_SUCCESS)
        {
            if (p_ue_context->x2ap_rlf_ind.short_mac_i ==
                    (U16)(p_llim_mac_i_resp->msg_auth_code_list.mac_i[0].encoded_mac_i))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_INFO, "shortMAC-I matched");
                rlf_ind_flag = RRC_TRUE;
                ho_report_flag = p_ue_context->ho_report_flag;
            }
        }

        x2ap_build_and_send_rlf_resp(p_uecc_gb_context,
                rlf_ind_flag,
                ho_report_flag,
                p_ue_context);
        p_ue_context->x2ap_rlf_ind_recvd_flag = RRC_FALSE;
        return;
    }
    /* Call UECC_EV_LLIM_MAC_I_RESP event handler
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_MAC_I_RESP, 
            p_llim_mac_i_resp);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/*SPR_19066_START*/
/******************************************************************************
*   FUNCTION NAME: uecc_llim_process_ho_prep_info_resp
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none
*
*   DESCRIPTION:
*       This function processes LLIM UECC_LLIM_HO_PREP_INFO_RESP message
*
*   RETURNS:  None
*
******************************************************************************/
void uecc_llim_process_ho_prep_info_resp
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_uecc_llim_ho_prep_info_resp_t*    p_llim_ho_prep_info_resp = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_ho_prep_info_resp = 
        (rrc_uecc_llim_ho_prep_info_resp_t*)((U8*)p_api + RRC_API_HEADER_SIZE);
    
    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
           p_uecc_gb_context,p_llim_ho_prep_info_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }


    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
        RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_ho_prep_info_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_WARNING,
            "[UECC_LLIM_HO_PREP_INFO_RESP] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context, p_llim_ho_prep_info_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_WARNING,
            "[UECC_LLIM_HO_PREP_INFO_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Check transaction_id */
    if (p_llim_ho_prep_info_resp->transaction_id !=
        uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /* Error. Invalid transaction id */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_WARNING,
            "[UECC_LLIM_HO_PREP_INFO_RESP] Invalid transaction id.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_EV_LLIM_HO_PREP_INFO_RESP event handler
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_HO_PREP_INFO_RESP, 
            p_llim_ho_prep_info_resp);

   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/*SPR_19066_END*/

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_sn_hfn_status_resp
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_SN_HFN_STATUS_RESP message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_sn_hfn_status_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_uecc_llim_sn_hfn_status_resp_t*    p_llim_sn_hfn_status_resp = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_sn_hfn_status_resp = (rrc_uecc_llim_sn_hfn_status_resp_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_sn_hfn_status_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }


    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_sn_hfn_status_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_SN_HFN_STATUS_RESP] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context,p_llim_sn_hfn_status_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_SN_HFN_STATUS_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Check transaction_id */
    if (p_llim_sn_hfn_status_resp->transaction_id !=
            uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /* Error. Invalid transaction id */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_SN_HFN_STATUS_RESP] Invalid transaction id.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_EV_LLIM_SN_HFN_STATUS_RESP event handler
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_SN_HFN_STATUS_RESP, 
            p_llim_sn_hfn_status_resp);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_ue_inactive_time_resp
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_UE_INACTIVE_TIME_RESP message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_ue_inactive_time_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_uecc_llim_ue_inactive_time_resp_t* p_llim_ue_inactive_time_resp = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_ue_inactive_time_resp = (rrc_uecc_llim_ue_inactive_time_resp_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_ue_inactive_time_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }


    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_ue_inactive_time_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_UE_INACTIVE_TIME_RESP] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            p_llim_ue_inactive_time_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_UE_INACTIVE_TIME_REQ] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Check transaction_id */
    if (p_llim_ue_inactive_time_resp->transaction_id !=
            uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /* Error. Invalid transaction id */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_UE_INACTIVE_TIME_REQ] Invalid transaction id.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_EV_LLIM_UE_INACTIVE_TIME_RESP event handler
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_UE_INACTIVE_TIME_RESP, 
            p_llim_ue_inactive_time_resp);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_ho_rach_resource_resp
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_HO_RACH_RESOURCE_RESP message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_ho_rach_resource_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_uecc_llim_ho_rach_resource_resp_t* p_llim_ho_rach_resource_resp = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_ho_rach_resource_resp = (rrc_uecc_llim_ho_rach_resource_resp_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_ho_rach_resource_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }


    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_ho_rach_resource_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_HO_RACH_RESOURCE_RESP] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            p_llim_ho_rach_resource_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_HO_RACH_RESOURCE_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Check transaction_id */
    if (p_llim_ho_rach_resource_resp->transaction_id !=
            uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /* Error. Invalid transaction id */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_HO_RACH_RESOURCE_RESP] Invalid transaction id.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_EV_LLIM_RACH_RES_RESP event handler
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_RACH_RES_RESP,
            p_llim_ho_rach_resource_resp);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_s1u_reconfigure_cnf
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_S1U_RECONFIGURE_CNF message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_s1u_reconfigure_cnf
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_uecc_llim_s1u_reconfigure_cnf_t*    p_llim_s1u_reconfigure_cnf = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_s1u_reconfigure_cnf = (rrc_uecc_llim_s1u_reconfigure_cnf_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_s1u_reconfigure_cnf->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_s1u_reconfigure_cnf_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_S1U_RECONFIGURE_CNF] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context,p_llim_s1u_reconfigure_cnf->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_S1U_RECONFIGURE_CNF] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Check transaction_id */
    if (p_llim_s1u_reconfigure_cnf->transaction_id !=
            uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /*SPR_17791_START*/
        if (p_llim_s1u_reconfigure_cnf->transaction_id ==
                RRC_S1U_END_MARKER_RESERVED_TRANSACTION_ID)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_DETAILED,
                    "[UECC_LLIM_S1U_RECONFIGURE_CNF] received for "
                    "RRC_S1U_END_MARKER_RESERVED_TRANSACTION_ID. "
                    "Ignoring this msg.");
        }
        else
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[UECC_LLIM_S1U_RECONFIGURE_CNF] Invalid transaction id.");
        }
        /*SPR_17791_END*/
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /*SPR_17976_START*/
    if(RRC_TRUE == p_ue_context->trg_ho_fail_rrc_cre_flag)
    {
        /* Re-establishment procedure has been triggered
         * during HO at TeNB. This reconfiguration should
         * be the response for UL tunnel reconfiguration.
         * queuing this message so that it can be processed
         * after successful completion of HO.
         */
        if(0 == 
                TENB_CRE_Q_GET_COUNT(&p_ue_context->p_tenb_cre_event_queue))
        {
            uecc_event_queue_push_tenb_cre_event(
                    UECC_EV_LLIM_S1U_RECONFIG_CNF, 
                    p_ue_context, 
                    p_api, 
                    &p_ue_context->p_tenb_cre_event_queue);
        }
        else
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->
                    facility_name, RRC_WARNING,
                    "S1U Reconfigure event is ignored because reestablishment "
                    "procedure ongoing during handover for ue_index: %d"
                    " and one event is already queued",
                    p_ue_context->ue_index );
        }
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }
        /*SPR_17976_END*/

    /* Call UECC_EV_LLIM_S1U_RECONFIG_CNF event handler
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_S1U_RECONFIG_CNF,
            p_llim_s1u_reconfigure_cnf);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_s1u_end_marker_ind
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_S1U_END_MARKER_IND message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_s1u_end_marker_ind
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_uecc_llim_s1u_end_marker_ind_t*    p_llim_s1u_end_marker_ind = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_s1u_end_marker_ind = (rrc_uecc_llim_s1u_end_marker_ind_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_s1u_end_marker_ind->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_s1u_end_marker_ind_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_S1U_END_MARKER_IND] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context,p_llim_s1u_end_marker_ind->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_S1U_END_MARKER_IND] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_EV_LLIM_S1U_END_MARKER_IND event handler
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_S1U_END_MARKER_IND,
            p_llim_s1u_end_marker_ind);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_re_establish_ue_entity_resp
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *   This function processes UECC_LLIM_RE_ESTABLISH_UE_ENTITY_RESP message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_re_establish_ue_entity_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*        p_ue_context = PNULL;
    rrc_uecc_llim_re_establish_ue_entity_resp_t* 
        p_llim_re_establish_ue_entity_resp = PNULL;
    /*Bug 357 Fix Start*/
    U16 api_id = 0;
    /*Bug 357 Fix Stop*/

    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    /*Bug 357 Fix Start*/
    api_id = rrc_get_api_id(p_api);
    /*Bug 357 Fix Stop*/

    p_llim_re_establish_ue_entity_resp =
        (rrc_uecc_llim_re_establish_ue_entity_resp_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_re_establish_ue_entity_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }


    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_re_establish_ue_entity_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_RE_ESTABLISH_UE_ENTITY_RESP]"
                "Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context, 
                p_llim_re_establish_ue_entity_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_RE_ESTABLISH_UE_ENTITY_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_EV_LLIM_REESTABLISH_UE_ENTITY_RESP event handler
     *      * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     *      * the stack variable is used for storing the API data
     *           * */
    /*Bug 357 Fix Start*/
    if (UECC_LLIM_PDCP_RE_ESTABLISH_UE_ENTITY_RESP == api_id)
    {
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_LLIM_PDCP_REESTABLISH_UE_ENTITY_RESP,
                p_llim_re_establish_ue_entity_resp);
    }
    else
    {
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_LLIM_REESTABLISH_UE_ENTITY_RESP,
                p_llim_re_establish_ue_entity_resp);
    }
    /*Bug 357 Fix Stop*/

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_reconfig_security_resp
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *   This function processes UECC_LLIM_RECONFIG_SECURITY_RESP message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_reconfig_security_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*        p_ue_context = PNULL;
    rrc_uecc_llim_reconfig_security_resp_t* 
        p_llim_reconfig_security_resp = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_reconfig_security_resp =
        (rrc_uecc_llim_reconfig_security_resp_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_reconfig_security_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_reconfig_security_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_RECONFIG_SECURITY_RESP]"
                "Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context, 
                p_llim_reconfig_security_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_RECONFIG_SECURITY_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_LLIM_RECONFIG_SECURITY_RESP event handler
     *      * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     *      * the stack variable is used for storing the API data
     *           * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_RECONFIGURE_UE_ENTITY_RESP,
            p_llim_reconfig_security_resp);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_resume_ue_entity_resp 
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *   This function processes UECC_LLIM_RESUME_UE_ENTITY_RESP message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_resume_ue_entity_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*        p_ue_context = PNULL;
    rrc_uecc_llim_resume_ue_entity_resp_t* 
        p_llim_resume_ue_entity_resp = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_resume_ue_entity_resp =
        (rrc_uecc_llim_resume_ue_entity_resp_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_resume_ue_entity_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,    
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }


    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_resume_ue_entity_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_RESUME_UE_ENTITY_RESP]"
                "Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context, 
                p_llim_resume_ue_entity_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_RESUME_UE_ENTITY_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_LLIM_RESUME_UE_ENTITY_RESP event handler
     *      * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     *      * the stack variable is used for storing the API data
     *           * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_RESUME_UE_ENTITY_RESP,
            p_llim_resume_ue_entity_resp);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_change_crnti_resp 
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *   This function processes UECC_LLIM_CHANGE_CRNTI_RESP message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_change_crnti_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*        p_ue_context = PNULL;
    rrc_uecc_llim_change_crnti_resp_t* 
        p_llim_change_crnti_resp = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_change_crnti_resp =
        (rrc_uecc_llim_change_crnti_resp_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_change_crnti_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
        return;
    }


    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_change_crnti_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_CHANGE_CRNTI_RESP]"
                "Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context, 
                p_llim_change_crnti_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_CHANGE_CRNTI_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_LLIM_CHANGE_CRNTI_RESP event handler
     *  and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     ** the stack variable is used for storing the API data
     ***/
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_CHANGE_CRNTI_RESP,
            p_llim_change_crnti_resp);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_meas_config_resp 
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *   This function processes UECC_LLIM_MEAS_CONFIG_RESP message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_meas_config_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*        p_ue_context = PNULL;
    rrc_uecc_llim_meas_config_resp_t* 
        p_uecc_llim_meas_config_resp = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_uecc_llim_meas_config_resp =
        (rrc_uecc_llim_meas_config_resp_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_uecc_llim_meas_config_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }


    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_meas_config_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_MEAS_CONFIG_RESP]"
                "Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context, 
            p_uecc_llim_meas_config_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_MEAS_CONFIG_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }
    /*SPR 15304 Start*/
    else if (RRC_FALSE == p_ue_context->is_meas_transaction_id_valid)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_WARNING,
            "[UECC_LLIM_MEAS_CONFIG_RESP] Ignoring UECC_LLIM_MEAS_CONFIG_RESP");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }
    /*SPR 15304 Stop*/

    if (RRC_SUCCESS == p_uecc_llim_meas_config_resp->response_code)
    {
        if (p_ue_context->uecc_fsm.p_current_state->s_name != PNULL)
        {
            if (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                        ((const S8 *)("UECC_UE_RADIO_LINK_FAILURE_HANDLING_ONGOING"))))
            {
                /* Stop UECC_UE_MEAS_CONFIG_GUARD_TIMER timer */
                uecc_ue_timer_stop(
                        p_uecc_gb_context, 
                        UECC_UE_MEAS_CONFIG_GUARD_TIMER,
                        &p_ue_context->timers_data);
			/*SPR 15304 Start*/
			/*Rollback the Measurement Gap Configuration at MAC*/

                if ((p_ue_context->p_meas_config) && (p_ue_context->
                            p_meas_config->bitmask & UE_ADM_MEAS_GAP_CONFIG_PRESENT))
                {
                    if (RRC_SUCCESS != uecc_llim_build_and_send_rollback_meas_config_req
                            (p_ue_context))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_ERROR,
                                "[UECC_LLIM_MEAS_CONFIG_REQ] Message sending failed .");
                    }
                }
                p_ue_context->is_meas_transaction_id_valid = RRC_FALSE;
                /*SPR 15304 Stop*/
                /* Build and send rrc_rrm_meas_config_resp with cause */
                if (RRC_SUCCESS != uecc_rrm_build_and_send_meas_config_resp(
                            p_ue_context, RRC_FAILURE, RRC_RADIO_LINK_FAILURE_TRIGGERED))
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "Failure to build and send meas config resp to RRM.");
                }
            }
            else if (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                        ((const S8 *)("UECC_UE_CONNECTION_RE_ESTABLISHMENT_ONGOING"))))
            {
                /*SPR 15304 Start*/
                /*Rollback the Measurement Gap Configuration at MAC*/

                if((p_ue_context->p_meas_config) && (p_ue_context->p_meas_config->bitmask &
                            UE_ADM_MEAS_GAP_CONFIG_PRESENT))
                {
                    if (RRC_SUCCESS != uecc_llim_build_and_send_rollback_meas_config_req
                            (p_ue_context))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_ERROR,
                                "[UECC_LLIM_MEAS_CONFIG_REQ] Message sending failed .");
                    }
                }
                p_ue_context->is_meas_transaction_id_valid = RRC_FALSE;
                /*SPR 15304 Stop*/
                /* Stop UECC_UE_MEAS_CONFIG_GUARD_TIMER timer */
                uecc_ue_timer_stop(
                        p_uecc_gb_context, 
                        UECC_UE_MEAS_CONFIG_GUARD_TIMER,
                        &p_ue_context->timers_data);

                /* Build and send rrc_rrm_meas_config_resp with cause */
                if (RRC_SUCCESS != uecc_rrm_build_and_send_meas_config_resp(
                            p_ue_context, RRC_FAILURE, RRC_REESTABLISHMENT_TRIGGERED))
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "Failure to build and send meas config resp to RRM.");
                }
            }
            else
            { 
                /* build and send RRCConnectionReconfiguration */
                if (RRC_SUCCESS !=
                        uecc_llim_build_and_send_meas_reconfig_rrc_connection_reconfiguration(
                            p_ue_context))
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "Failure to build and send "
                            "meas_reconfig_rrc_connection_reconfiguration"
                            "to LLIM.");
                }
            }
        }
    }
    else
    {
        /* Stop UECC_UE_MEAS_CONFIG_GUARD_TIMER timer */
        uecc_ue_timer_stop(
                p_uecc_gb_context, 
                UECC_UE_MEAS_CONFIG_GUARD_TIMER,
                &p_ue_context->timers_data);

        /* Build and send the RRC_RRM_MEAS_CONFIG_RESP(failure) to RRM.*/
        if (RRC_SUCCESS != uecc_rrm_build_and_send_meas_config_resp(
                    p_ue_context, RRC_FAILURE, RRC_NO_ERROR))
        {
            /* Process failure according to selected failure actions
             * list */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "Failure to build and send meas config resp to RRM.");
        }
        /*SPR 15304 Start*/
        p_ue_context->is_meas_transaction_id_valid = RRC_FALSE;
        /*SPR 15304 Stop*/
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/****************************************************************************
 ****************************************************************************
 * Build and Send Functions implementation
 ****************************************************************************
 ****************************************************************************/

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_rrc_connection_reject
 *   INPUT        : uecc_gb_context_t*  p_uecc_gb_context
 *                  rrc_rnti_t          rnti
 *                  U8                  wait_time
 *                  U32                 establishment_cause
 *                  rrc_cell_index_t    cell_index
 *                  rrc_bool_t          rcs_reject_cause
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds and sends RRC connection reject message
 *                  to LLIM module within UECC_LLIM_UE_CON_REJ_REQ message.
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_rrc_connection_reject
(
 uecc_gb_context_t*  p_uecc_gb_context,
 rrc_rnti_t          rnti,        /* UE rnti */
 U8                  wait_time,    /* RRCConnectionReject waitTime value */
 U32                 establishment_cause,
 rrc_cell_index_t    cell_index,
 rrc_bool_t          rcs_reject_cause,
 U16                 extended_wait_time,/*CR 026 changes start*/
 uecc_ue_context_t   *p_ue_context/*CR 026 changes stop*/
 )
{
    U8  msg[sizeof(rrc_uecc_llim_con_rej_req_t)+UECC_MAX_ASN1_BUF_LEN];
    rrc_uecc_llim_con_rej_req_t*              p_llim_con_rej = PNULL;

    OSCTXT                                      asn1_ctx;
    DL_CCCH_Message                             dl_ccch_msg;
    DL_CCCH_MessageType_c1*                     p_dl_ccch_c1 = PNULL;
    RRCConnectionReject_criticalExtensions_c1*  p_dl_cch_rrc_ext_c1 = PNULL;
    time_t time1 ;

    rrc_return_et                               response = RRC_FAILURE;
    LOCAL_RRC_CONNECTION_REJECT_STRUCT          *p_rrc_conn_reject = PNULL;
    U32                                         encoded_msg_len = 0;
    LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT *p_event_rrc_protocol_err = PNULL;

    RRC_ASSERT (PNULL != p_uecc_gb_context);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    time_wrapper(&time1); 

    /* Init ASN1 context */
    if ( RT_OK != rtInitContext(&asn1_ctx) )
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "[RRCConnectionReject] ASN context initialization failed.");
        return RRC_FAILURE;
    }

    /*SPR 15896 Fix Start*/
    if ((p_ue_context != PNULL) && p_ue_context->m.traceActivated) 
    {
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & UU) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                 (MEDIUM == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                 (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                 (MINIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
        {
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), GEN_MME,"\n<msg function=\"Uu\" name=\"RRC Connection Reject \" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & UU) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                 (MEDIUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                 (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                 (MINIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
        {
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), GEN_CELL,"\n<msg function=\"Uu\" name=\"RRC Connection Reject \" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), UU,"<ie name=\"Wait Time\">%d</ie>\n </msg>",UECC_LTE_RRC_CONNECTION_REJECT_WAIT_TIME_FIELD_DEFAULT_VALUE);
        /*SPR 15896 Fix Stop*/
    }

    do {
        /* Fill the values in the ASN structures that shall be encoded
         * by ASN Encoder */
        /* Set Downlink CCCH message type */
        dl_ccch_msg.message.t = T_DL_CCCH_MessageType_c1;

        /* Allocate and choose RRCConnectionReject */
        p_dl_ccch_c1 = rtxMemAllocType(&asn1_ctx, DL_CCCH_MessageType_c1);
        if (PNULL == p_dl_ccch_c1)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReject] ASN malloc failed.");
            break;
        }
        dl_ccch_msg.message.u.c1 = p_dl_ccch_c1;

        p_dl_ccch_c1->t = T_DL_CCCH_MessageType_c1_rrcConnectionReject;
        p_dl_ccch_c1->u.rrcConnectionReject =
            rtxMemAllocType(&asn1_ctx, RRCConnectionReject);
        if (PNULL == p_dl_ccch_c1->u.rrcConnectionReject)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReject] ASN malloc failed.");
            break;
        }

        p_dl_ccch_c1->u.rrcConnectionReject->criticalExtensions.t =
            T_RRCConnectionReject_criticalExtensions_c1;
        p_dl_cch_rrc_ext_c1 = rtxMemAllocType(&asn1_ctx,
                RRCConnectionReject_criticalExtensions_c1);
        if (PNULL == p_dl_cch_rrc_ext_c1)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReject] ASN malloc failed.");
            break;
        }
        p_dl_ccch_c1->u.rrcConnectionReject->criticalExtensions.u.c1 =
            p_dl_cch_rrc_ext_c1;

        p_dl_cch_rrc_ext_c1->t =
            T_RRCConnectionReject_criticalExtensions_c1_rrcConnectionReject_r8;
        p_dl_cch_rrc_ext_c1->u.rrcConnectionReject_r8 =
            rtxMemAllocType(&asn1_ctx, RRCConnectionReject_r8_IEs);
        if (PNULL == p_dl_cch_rrc_ext_c1->u.rrcConnectionReject_r8)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReject] ASN malloc failed.");
            break;
        }
        asn1Init_RRCConnectionReject_r8_IEs(
                p_dl_cch_rrc_ext_c1->u.rrcConnectionReject_r8);

        /* Fill value for wait time */
        p_dl_cch_rrc_ext_c1->u.rrcConnectionReject_r8->waitTime = wait_time;

        if ( delayTolerantAccess_v1020 == establishment_cause && 0!=extended_wait_time )
        {
            p_dl_cch_rrc_ext_c1->u.rrcConnectionReject_r8->m.nonCriticalExtensionPresent = 1;
            p_dl_cch_rrc_ext_c1->u.rrcConnectionReject_r8->nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
            p_dl_cch_rrc_ext_c1->u.rrcConnectionReject_r8->nonCriticalExtension.nonCriticalExtension.m.extendedWaitTime_r10Present= 1;
            p_dl_cch_rrc_ext_c1->u.rrcConnectionReject_r8->nonCriticalExtension.nonCriticalExtension.extendedWaitTime_r10 = extended_wait_time;
        }    

        /* Prepare pointer on RRC internal message */
        p_llim_con_rej = (rrc_uecc_llim_con_rej_req_t*)msg;

        /* ASN Encode message */
        pu_setBuffer(&asn1_ctx, p_llim_con_rej->data_buffer,
                UECC_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);

        if (RT_OK != asn1PE_DL_CCCH_Message(&asn1_ctx, &dl_ccch_msg))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReject] ASN1 encoding failed.");

            /*Generating Protocol Event LOCAL_EVENT_RRC_PROTOCOL_ERROR*/
            p_event_rrc_protocol_err = rrc_mem_get(sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));
            if (PNULL != p_event_rrc_protocol_err)
            {
                memset_wrapper(p_event_rrc_protocol_err, RRC_NULL, 
                        sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));

                p_event_rrc_protocol_err->header.length = 
                    sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT);
                p_event_rrc_protocol_err->header.event_id = LOCAL_EVENT_RRC_PROTOCOL_ERROR;

                l3_strncpy_wrapper(((S8 *)(p_event_rrc_protocol_err->EVENT_PARAM_RRC_MESSAGE_DISCARDED)),
                        ((S8 *)("RRC CONNECTION REJECT")), RRC_MESSAGE_DISCARDED_SIZE);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_rrc_protocol_err);
            }
            break;
        }
        else
        {

            /* Generating Protocol Event LOCAL_RRC_CONNECTION_REJECT */ 
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);
            
            rrc_asn1PrtToStr_DL_CCCH_Message(RRC_ASN,"DL_CCCH_Message",
                    &dl_ccch_msg,"RRCConnectionReject",
                    p_llim_con_rej->data_buffer, encoded_msg_len);

            p_rrc_conn_reject = rrc_mem_get(sizeof(LOCAL_RRC_CONNECTION_REJECT_STRUCT) +
                    encoded_msg_len);
            if (PNULL != p_rrc_conn_reject)
            {
                memset_wrapper(p_rrc_conn_reject, RRC_NULL, 
                        (sizeof(LOCAL_RRC_CONNECTION_REJECT_STRUCT) + encoded_msg_len));

                p_rrc_conn_reject->header.length = (sizeof(LOCAL_RRC_CONNECTION_REJECT_STRUCT) + 
                        encoded_msg_len);
                p_rrc_conn_reject->header.event_id = LOCAL_RRC_CONNECTION_REJECT;

                if ((PNULL != p_uecc_gb_context->p_p_csc_context) && (PNULL !=
                            p_uecc_gb_context->p_p_csc_context[cell_index])
                        && (PNULL != p_uecc_gb_context->p_p_csc_context[cell_index]->
                            p_csc_init_setup_ind))
                {
                    l3_memcpy_wrapper(&p_rrc_conn_reject->header.EVENT_PARAM_CELL_ID, 
                            p_uecc_gb_context->p_p_csc_context[cell_index]->
                            p_csc_init_setup_ind->sib_type_1_Info.cell_access_related_info.
                            cell_Id, sizeof(U32));
                }
                p_rrc_conn_reject->header.EVENT_PARAM_EUTRANCELL_FROID = 
                    p_rrc_conn_reject->header.EVENT_PARAM_CELL_ID;

                p_rrc_conn_reject->EVENT_PARAM_MESSAGE_DIRECTION = 
                    MESSAGE_DIRECTION_SEND;                    
                p_rrc_conn_reject->EVENT_PARAM_L3MESSAGE_LENGTH = 
                    encoded_msg_len;
                p_rrc_conn_reject->EVENT_PARAM_RRC_REJECT_CAUSE = (U32)rcs_reject_cause;
                p_rrc_conn_reject->EVENT_PARAM_RRC_ESTABL_CAUSE = (U32)establishment_cause;

                l3_memcpy_wrapper(((void*)((U8*)(p_rrc_conn_reject)) + 
                            sizeof(LOCAL_RRC_CONNECTION_REJECT_STRUCT)),
                        (const void*)p_llim_con_rej->data_buffer,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_rrc_conn_reject);
            }
        }

        p_llim_con_rej->data_buffer_length = (rrc_counter_t)pe_GetMsgLen(&asn1_ctx);
        p_llim_con_rej->crnti = rnti;
        p_llim_con_rej->cell_index = cell_index;

        /* TRACE_fix */
        if(PNULL != p_ue_context)
        {
            /* SPR 16113 Start */
            uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_llim_con_rej->data_buffer, 
                    p_llim_con_rej->data_buffer_length, "RRC Connection Reject", RRC_DL_CCCH);
            /* SPR 16113 Stop */
        }
        /* TRACE_fix */

        /* Send message to LLIM  */
        response = uecc_rrc_send_internal_msg(
                RRC_LLIM_MODULE_ID,
                UECC_LLIM_UE_CON_REJ_REQ,
                (U16)(sizeof(rrc_uecc_llim_con_rej_req_t) +
                    p_llim_con_rej->data_buffer_length),
                msg);

        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO,"RRC_MSG: RRCConnectionReject %s",
                change_data_to_str(p_llim_con_rej->data_buffer_length, p_llim_con_rej->data_buffer));
        if (PNULL != g_rrc_stats.p_rrc_stats)
        {
            /* Update the performance counter */
            RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_gb_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[cell_index].rrc_connection_related_stats.
                    rrc_connection_establishment.
                    rrc_connEstabFail_cause[establishment_cause],
                    establishment_cause, (RRC_ESTABLISHMENT_CAUSE_INDEX-1));

            RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_gb_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[cell_index].rrc_connection_related_stats.
                    rrc_connection_establishment.
                    rrc_connEstabFail_sum, establishment_cause,
                    (RRC_ESTABLISHMENT_CAUSE_INDEX-1));

            /*CR 026 changes start*/
            if ((PNULL != p_ue_context) && (p_ue_context->m.rrc_conn_estab_rrm_fail_cause_present == 1))
            {
                if (p_ue_context->rrc_conn_estab_rrm_fail_cause == FAIL_CAUSE_CONGESTION)
                {
                    RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_gb_context,
                            g_rrc_stats.p_rrc_stats->
                            rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_gb_context->offset_uecc_mod_id].
                            rrc_uecc_cell_stats[cell_index].rrc_connection_related_stats.
                            rrc_connection_establishment.rrc_ConnEstabFaileNBCause_Congestion,
                            RRC_NULL, DUMMY_RANGE_CHECK_INDEX );
                }
                else if (p_ue_context->rrc_conn_estab_rrm_fail_cause == FAIL_CAUSE_ENERGY_SAVING)
                {
                    RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_gb_context,
                            g_rrc_stats.p_rrc_stats->
                            rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_gb_context->offset_uecc_mod_id].
                            rrc_uecc_cell_stats[cell_index].rrc_connection_related_stats.
                            rrc_connection_establishment.rrc_ConnEstabFaileNBCause_EnergySaving,
                            RRC_NULL, DUMMY_RANGE_CHECK_INDEX );
                }
                else
                {
                    RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_gb_context,
                            g_rrc_stats.p_rrc_stats->
                            rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_gb_context->offset_uecc_mod_id].
                            rrc_uecc_cell_stats[cell_index].rrc_connection_related_stats.
                            rrc_connection_establishment.rrc_connEstabFaileNBCause_Unspecified,
                            RRC_NULL, DUMMY_RANGE_CHECK_INDEX );
                }
            }
            else
            {
                RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_gb_context,
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[cell_index].rrc_connection_related_stats.
                        rrc_connection_establishment.rrc_connEstabFaileNBCause_Unspecified,
                        RRC_NULL, DUMMY_RANGE_CHECK_INDEX );

            }/*CR 026 changes stop*/
        }
    } while (0);

    /* Free ASN1 context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_delete_ue_entity_req
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds and sends delete UE entity  message
 *                   to LLIM module. (UECC_LLIM_DELETE_UE_ENTITY_REQ)
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_delete_ue_entity_req
(
 uecc_ue_context_t*  p_uecc_ue_context
 )
{
    rrc_uecc_llim_delete_ue_entity_req_t        uecc_llim_delete_ue_entity_req;
    rrc_return_et                               response = RRC_FAILURE;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /*BUG 11046 changes start*/
    memset_wrapper(&uecc_llim_delete_ue_entity_req, 0,
            sizeof(rrc_uecc_llim_delete_ue_entity_req_t));
    /*BUG 11046 changes stop*/

    /* Fill message */
    uecc_llim_delete_ue_entity_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
    uecc_llim_delete_ue_entity_req.ue_index = p_uecc_ue_context->ue_index;
    uecc_llim_delete_ue_entity_req.cell_index = p_uecc_ue_context->cell_index;
    /* SPR 21458 Start */
    uecc_llim_delete_ue_entity_req.l2_instance_reset_flag = p_uecc_ue_context->p_gb_context->l2_instance_reset_flag;
    /* SPR 21458 End */
    /*BUG 11046 changes start*/
    if((INTRA_CELL_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover)||
            (p_uecc_ue_context->share_data.uecc_rcr_data.s1u_release_not_req_flag))
    {
        uecc_llim_delete_ue_entity_req.bitmask |=
            UECC_LLIM_DELETE_UE_ENTITY_HO_TYPE_PRESENT;
        uecc_llim_delete_ue_entity_req.ho_type = HANDOVER_TYPE_INTRA_CELL;
    }
    /*BUG 11046 changes stop*/
    response = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_DELETE_UE_ENTITY_REQ,
            sizeof(uecc_llim_delete_ue_entity_req),
            &uecc_llim_delete_ue_entity_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}

/*SPR_19066_START*/
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_convert_inactivity_time_in_mili_seconds
 *   INPUT        : RRM_Config_ue_InactiveTime ue_inactivity_time
 *   OUTPUT       : none
 *
 *   DESCRIPTION  :
 *                  This is the function contains the inactivity time 
 *                  in miliseconds.
 *              
 *
 *   RETURNS     :  ue_inactivity_time_val_in__ms
 *       
 *
 ******************************************************************************/
U32 uecc_llim_convert_inactivity_time_in_mili_seconds(
        RRM_Config_ue_InactiveTime ue_inactivity_time)
{
    U32 ue_inactivity_time_val_in__ms = 0;
    switch(ue_inactivity_time)
    {
        case UE_INACTIVITY_TIME_S1:
            ue_inactivity_time_val_in__ms = 1000;
            break;
        case UE_INACTIVITY_TIME_S2:
            ue_inactivity_time_val_in__ms = 2000;
            break;
        case UE_INACTIVITY_TIME_S3:
            ue_inactivity_time_val_in__ms = 3000;
            break;
        case UE_INACTIVITY_TIME_S5:
            ue_inactivity_time_val_in__ms = 5000;
            break;
        case UE_INACTIVITY_TIME_S7:
            ue_inactivity_time_val_in__ms = 7000;
            break;
        case UE_INACTIVITY_TIME_S10:
            ue_inactivity_time_val_in__ms = 10000;
            break;
        case UE_INACTIVITY_TIME_S15:
            ue_inactivity_time_val_in__ms = 15000;
            break;
        case UE_INACTIVITY_TIME_S20:
            ue_inactivity_time_val_in__ms = 20000;
            break;
        case UE_INACTIVITY_TIME_S25:
            ue_inactivity_time_val_in__ms = 25000;
            break;
        case UE_INACTIVITY_TIME_S30:
            ue_inactivity_time_val_in__ms = 30000;
            break;
        case UE_INACTIVITY_TIME_S40:
            ue_inactivity_time_val_in__ms = 40000;
            break;
        case UE_INACTIVITY_TIME_S50:
            ue_inactivity_time_val_in__ms = 50000;
            break;
        case UE_INACTIVITY_TIME_MIN1:
            ue_inactivity_time_val_in__ms = 60000;
            break;
        case UE_INACTIVITY_TIME_MIN1S20c:
            ue_inactivity_time_val_in__ms = 80000;
            break;
        case UE_INACTIVITY_TIME_MIN1S40:
            ue_inactivity_time_val_in__ms = 100000;
            break;
        case UE_INACTIVITY_TIME_MIN2:
            ue_inactivity_time_val_in__ms = 120000;
            break;
        case UE_INACTIVITY_TIME_MIN2S30:
            ue_inactivity_time_val_in__ms = 150000;
            break;
        case UE_INACTIVITY_TIME_MIN3:
            ue_inactivity_time_val_in__ms = 180000;
            break;
        case UE_INACTIVITY_TIME_MIN3S30:
            ue_inactivity_time_val_in__ms = 210000;
            break;
        case UE_INACTIVITY_TIME_MIN4:
            ue_inactivity_time_val_in__ms = 240000;
            break;
        case UE_INACTIVITY_TIME_MIN5:
            ue_inactivity_time_val_in__ms = 300000;
            break;
        case UE_INACTIVITY_TIME_MIN6:
            ue_inactivity_time_val_in__ms = 360000;
            break;
        case UE_INACTIVITY_TIME_MIN7:
            ue_inactivity_time_val_in__ms = 420000;
            break;
        case UE_INACTIVITY_TIME_MIN8:
            ue_inactivity_time_val_in__ms = 480000;
            break;
        case UE_INACTIVITY_TIME_MIN9:
            ue_inactivity_time_val_in__ms = 540000;
            break;
        case UE_INACTIVITY_TIME_MIN10:
            ue_inactivity_time_val_in__ms = 600000;
            break;
        case UE_INACTIVITY_TIME_MIN12:
            ue_inactivity_time_val_in__ms = 720000;
            break;
        case UE_INACTIVITY_TIME_MIN14:
            ue_inactivity_time_val_in__ms = 840000;
            break;
        case UE_INACTIVITY_TIME_MIN17:
            ue_inactivity_time_val_in__ms = 1020000;
            break;
        case UE_INACTIVITY_TIME_MIN20:
            ue_inactivity_time_val_in__ms = 1200000;
            break;
        case UE_INACTIVITY_TIME_MIN24:
            ue_inactivity_time_val_in__ms = 1440000;
            break;
        case UE_INACTIVITY_TIME_MIN28:
            ue_inactivity_time_val_in__ms = 1680000;
            break;
        case UE_INACTIVITY_TIME_MIN33:
            ue_inactivity_time_val_in__ms = 1980000;
            break;
        case UE_INACTIVITY_TIME_MIN38:
            ue_inactivity_time_val_in__ms = 2280000;
            break;
        case UE_INACTIVITY_TIME_MIN44:
            ue_inactivity_time_val_in__ms = 2640000;
            break;
        case UE_INACTIVITY_TIME_MIN50:
            ue_inactivity_time_val_in__ms = 3000000;
            break;
        case UE_INACTIVITY_TIME_HR1:
            ue_inactivity_time_val_in__ms = 3600000;
            break;
        case UE_INACTIVITY_TIME_HR1MIN30:
            ue_inactivity_time_val_in__ms = 5400000;
            break;
        case UE_INACTIVITY_TIME_HR2:
            ue_inactivity_time_val_in__ms = 7200000;
            break;
        case UE_INACTIVITY_TIME_HR2MIN30:
            ue_inactivity_time_val_in__ms = 9000000;
            break;
        case UE_INACTIVITY_TIME_HR3:
            ue_inactivity_time_val_in__ms = 10800000;
            break;
        case UE_INACTIVITY_TIME_HR3MIN30:
            ue_inactivity_time_val_in__ms = 12600000;
            break;
        case UE_INACTIVITY_TIME_HR4:
            ue_inactivity_time_val_in__ms = 14400000;
            break;
        case UE_INACTIVITY_TIME_HR5:
            ue_inactivity_time_val_in__ms = 18000000;
            break;
        case UE_INACTIVITY_TIME_HR6:
            ue_inactivity_time_val_in__ms = 21600000;
            break;
        case UE_INACTIVITY_TIME_HR8:
            ue_inactivity_time_val_in__ms = 28800000;
            break;
        case UE_INACTIVITY_TIME_HR10:
            ue_inactivity_time_val_in__ms = 36000000;
            break;
        case UE_INACTIVITY_TIME_HR13:
            ue_inactivity_time_val_in__ms = 46800000;
            break;
        case UE_INACTIVITY_TIME_HR16:
            ue_inactivity_time_val_in__ms = 57600000;
            break;
        case UE_INACTIVITY_TIME_HR20:
            ue_inactivity_time_val_in__ms = 72000000;
            break;
        case UE_INACTIVITY_TIME_DAY1:
            ue_inactivity_time_val_in__ms = 86400000;
            break;
        case UE_INACTIVITY_TIME_DAY1HR12:
            ue_inactivity_time_val_in__ms = 129600000;
            break;
        case UE_INACTIVITY_TIME_DAY2:
            ue_inactivity_time_val_in__ms = 172800000;
            break;
        case UE_INACTIVITY_TIME_DAY2HR12:
            ue_inactivity_time_val_in__ms = 216000000;
            break;
        case UE_INACTIVITY_TIME_DAY3:
            ue_inactivity_time_val_in__ms = 259200000;
            break;
        case UE_INACTIVITY_TIME_DAY4:
            ue_inactivity_time_val_in__ms = 345600000;
            break;
        case UE_INACTIVITY_TIME_DAY5:
            ue_inactivity_time_val_in__ms = 432000000;
            break;
        case UE_INACTIVITY_TIME_DAY7:
            ue_inactivity_time_val_in__ms = 604800000;
            break;
        case UE_INACTIVITY_TIME_DAY10:
            ue_inactivity_time_val_in__ms = 864000000;
            break;
        case UE_INACTIVITY_TIME_DAY14:
            ue_inactivity_time_val_in__ms = 1209600000;
            break;
        case UE_INACTIVITY_TIME_DAY19:
            ue_inactivity_time_val_in__ms = 1641600000;
            break;
        case UE_INACTIVITY_TIME_DAY24:
            ue_inactivity_time_val_in__ms = 2073600000;
            break;
        case UE_INACTIVITY_TIME_DAY30:
            ue_inactivity_time_val_in__ms = 2592000000u;
            break;
        case UE_INACTIVITY_TIME_DAYMORETHAN30:
        default:
            ue_inactivity_time_val_in__ms = 0;
            break;
    }
    return ue_inactivity_time_val_in__ms;
}
/*SPR_19066_END*/
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_create_ue_entity_req
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *                This is the function for building and sending messages from
 *                the UECC to LLIM to create UE entity at lower layers
 *                (UECC_LLIM_CREATE_UE_ENTITY_REQ)
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_create_ue_entity_req(
        uecc_ue_context_t*  p_uecc_ue_context
        )
{
    /* coverity_fix_54690_start */
    U32 create_drb_entity_counter = 0;
    U8 total_fwd_elem = 0;

    /* SPR 23209 FIXED START */
    U8  plmn_idx_sib1 = RRC_NULL;
    /* SPR 23209 FIXED END */

    uecc_s1_trg_ho_info_t * p_uecc_s1_trg_ho_info = PNULL;
    rrc_return_et                           result = RRC_FAILURE;
    static rrc_uecc_llim_create_ue_entity_req_t    create_ue_entity_req;
    rrc_uecc_llim_s1u_tunnel_info_t *
        pp_rrc_uecc_llim_s1u_tunnel_info_list = PNULL;
    rrc_counter_t drb_index = 0, create_drb_idx = 0;

    U8  index = RRC_NULL;
    U8  scell_index = RRC_NULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /* INFO: All needed incoming data is stored
     * in UE context. */

    if (  (!p_uecc_ue_context->m.physical_config_dedicated_present)
            ||(!p_uecc_ue_context->m.mac_config_present)
            ||(!p_uecc_ue_context->m.srb1_config_present))
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "physical_config_dedicated or mac_config or"
                " srb1_config config not present\n");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* Reset */
    memset_wrapper(&create_ue_entity_req, 0,
            sizeof(rrc_uecc_llim_create_ue_entity_req_t));

    /* Transaction ID */
    create_ue_entity_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    /* UE Index */
    create_ue_entity_req.ue_index = p_uecc_ue_context->ue_index;
    create_ue_entity_req.cell_index = p_uecc_ue_context->cell_index;

    /* CRNTI */
    create_ue_entity_req.crnti = p_uecc_ue_context->crnti;

    /* Physical Dedicated Configuration   */
    create_ue_entity_req.bitmask |=  
        UECC_LLIM_CREATE_UE_ENTITY_PHY_CONFIG_DEDICATED_PRESENT;
    create_ue_entity_req.physical_config_dedicated =
        p_uecc_ue_context->physical_config_dedicated;
    /* LLIM has to pass ANTENNA info explicitly to lower layers if
     * default is received from RRM. So, setting default values explicitly. */
    if((!(RRC_PHY_ANTENNA_INFORMATION_PRESENT &
                    create_ue_entity_req.physical_config_dedicated.bitmask))
            || (!(RRC_PHY_ANTENNA_INFORMATION_EXPLICIT_VALUE_PRESENT &
                    create_ue_entity_req.physical_config_dedicated
                    .antenna_information.bitmask)))
    {
        create_ue_entity_req.physical_config_dedicated.bitmask |=
            RRC_PHY_ANTENNA_INFORMATION_PRESENT;
        create_ue_entity_req.physical_config_dedicated.antenna_information
            = physical_config_dedicated_default.antenna_information;
    }
    /* Get pointer on MAC configuration and assign it to REQ*/
    create_ue_entity_req.bitmask |=  
        UECC_LLIM_CREATE_UE_ENTITY_REQ_MAC_CONFIG_PRESENT;
    create_ue_entity_req.mac_config = p_uecc_ue_context->mac_config;

    /*create_srb1_entity*/
    /* lc_id */
    create_ue_entity_req.create_srb1_entity.lc_id = RRC_SRB1_LC_ID;

    /* srb_config */
    create_ue_entity_req.create_srb1_entity.srb_config =
        p_uecc_ue_context->srb1_config;

    /* LLIM has to pass AM config explicitly to lower layers even if
     * default is received from RRM. So, setting this bitmask. */
    create_ue_entity_req.create_srb1_entity.srb_config.srb_am_config.bitmask |=
        RRM_SRB_AM_CONFIG_EXPLICIT_PRESENT;

        /*SPS Start*/
        /* SPE 20747 Fix Start */
    if ((p_uecc_ue_context->m.is_sps_recv_frm_rrm) &&
	 !(p_uecc_ue_context->m.is_sps_setup_or_rel_recv))
        /* SPE 20747 Fix End */
        {
            create_ue_entity_req.bitmask |=  
                UECC_LLIM_CREATE_UE_ENTITY_REQ_SPS_CONFIG_PRESENT;
           
            uecc_llim_fill_sps_config(
                    p_uecc_ue_context->p_sps_config,
                    &create_ue_entity_req.sps_config);

        /* SPS Stop */
    }

    /*HANDOVER_CHANGES_REVANTH_01_begin*/
    if (p_uecc_ue_context->ho_info.p_ho_info &&
            p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info)
    {
        /*SPR 23209 FIXED START */

        /* Check if MOCN is configured in system */
        if( p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                cell_index]->p_csc_init_setup_ind->bitmask
                & RRC_CSC_UECC_MOCN_OPERATOR_PRESENCE_FLAG)
        {
            if(!p_uecc_ue_context->m.mocn_operator_id_already_configured)
            {
                if(RRC_SUCCESS ==
                        uecc_llim_search_plmn_idx_in_sib1(p_uecc_ue_context,&plmn_idx_sib1))
                {
                    create_ue_entity_req.bitmask |=
                        UECC_LLIM_CREATE_UE_ENTITY_MOCN_OPERATOR_ID_PRESENT;
                    create_ue_entity_req.operator_id =
                        p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                        cell_index]->p_csc_init_setup_ind->
                        operator_id[plmn_idx_sib1];
                    p_uecc_ue_context->m.mocn_operator_id_already_configured = 1;
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_DETAILED,
                            "UE[%d] selected PLMN is Present in SIB1 at pos [%d] "
                            " Send correspondig operator id[%d] in Create UE to LLIM ",
                            p_uecc_ue_context->ue_index,plmn_idx_sib1,
                            create_ue_entity_req.operator_id);
                }

                else
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_DETAILED,
                            "UE[%d] selected PLMN is Not Present in SIB1"
                            "MOCN operator ID can't be configured for this UE",
                            p_uecc_ue_context->ue_index);
                }
            }
            else
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_DETAILED,
                        "[UECC_LLIM_CREATE_UE_ENTITY_REQ] "
                        "Operator Id is already applied on the UE [%d]",
                        p_uecc_ue_context->ue_index);
            }
        }
        else
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_DETAILED,
                    "[UECC_LLIM_CREATE_UE_ENTITY_REQ]: UE[%d] MOCN is disabled in system ",
                    p_uecc_ue_context->ue_index);
        }
        /*SPR 23209 FIXED END */

        /* Qos changes start*/
        /*Fill ambr_info for create_ue_entity in case of HO*/
        create_ue_entity_req.bitmask |= 
            UECC_LLIM_CREATE_UE_ENTITY_UE_AMBR_PRESENT;
        create_ue_entity_req.ue_ambr.dl_ambr = (U32)p_uecc_ue_context->
            ue_aggregate_maximum_bitrate.uEaggregateMaximumBitRateDL;
        create_ue_entity_req.ue_ambr.ul_ambr = (U32)p_uecc_ue_context->
            ue_aggregate_maximum_bitrate.uEaggregateMaximumBitRateUL;
        /* Qos changes stop*/
        /*create_srb2_entity*/
        /* lc_id */
        create_ue_entity_req.bitmask |= 
            UECC_LLIM_CREATE_UE_ENTITY_CREATE_SRB2_INFO_PRESENT;

        create_ue_entity_req.create_srb2_entity.lc_id = RRC_SRB2_LC_ID;

        /* srb_config */
        create_ue_entity_req.create_srb2_entity.srb_config =
            p_uecc_ue_context->srb2_config;

        /* LLIM has to pass AM config explicitly to lower layers even if
         * default is received from RRM. So, setting this bitmask. */
                create_ue_entity_req.create_srb2_entity.
                    srb_config.srb_am_config.bitmask |=
                    RRM_SRB_AM_CONFIG_EXPLICIT_PRESENT;

            /* Srb1*/
            /*configure_integrity_protection*/
            create_ue_entity_req.create_srb1_entity.bitmask |=  
                UECC_LLIM_SRB_CONFIGURE_INTEGRITY_PROTECTION_PRESENT;
            create_ue_entity_req.create_srb1_entity.
                configure_integrity_protection = 
                p_uecc_ue_context->configure_integrity_protection;

            /*srb_configure_ciphering*/
            create_ue_entity_req.create_srb1_entity.bitmask |= 
                UECC_LLIM_SRB_CONFIGURE_CIPHERING_PRESENT;
            create_ue_entity_req.create_srb1_entity.configure_ciphering = 
                p_uecc_ue_context->configure_ciphering;

            /* Srb2*/
            /*configure_integrity_protection*/
            create_ue_entity_req.create_srb2_entity.bitmask |=  
                UECC_LLIM_SRB_CONFIGURE_INTEGRITY_PROTECTION_PRESENT;
            create_ue_entity_req.create_srb2_entity.
                configure_integrity_protection = 
                p_uecc_ue_context->configure_integrity_protection;

            /*srb_configure_ciphering*/
            create_ue_entity_req.create_srb2_entity.bitmask |= 
                UECC_LLIM_SRB_CONFIGURE_CIPHERING_PRESENT;
            create_ue_entity_req.create_srb2_entity.configure_ciphering = 
                p_uecc_ue_context->configure_ciphering;

            /*create_drb_entity_info*/
            create_ue_entity_req.bitmask |=  
                UECC_LLIM_CREATE_DRB_ENTITY_LIST_PRESENT;

            create_ue_entity_req.create_drb_entity_info.create_drb_entity_counter =
                p_uecc_ue_context->e_rab_list_count;

            for(drb_index = 0; drb_index < MAX_ERAB_COUNT; drb_index++)
            {
                if (!p_uecc_ue_context->p_e_rab_list[drb_index])
                {
                    continue;
                }
                if (create_drb_entity_counter < RRC_UECC_LLIM_MAX_CREATE_DRB)
                {    
                    /* disable masks by default */
                    create_ue_entity_req.create_drb_entity_info.
                        create_drb_entity[create_drb_entity_counter].bitmask = 0;

                    /* drb_config */
                    create_ue_entity_req.create_drb_entity_info.
                        create_drb_entity[create_drb_entity_counter].
                        uecc_llim_drb_config.drb_config =
                        p_uecc_ue_context->p_e_rab_list[drb_index]->drb_config;

                    /* Qos changes start*/

                    /* setting the bitmask for Qos info*/
                    create_ue_entity_req.create_drb_entity_info.
                        create_drb_entity[create_drb_entity_counter].
                        uecc_llim_drb_config.bitmask |= 
                        UECC_LLIM_DRB_CONFIG_QOS_INFO_PRESENT;
                    /* Filling the Qos Infos*/
                    create_ue_entity_req.create_drb_entity_info.
                        create_drb_entity[create_drb_entity_counter].
                        uecc_llim_drb_config.qos_info.qci =
                        p_uecc_ue_context->p_e_rab_list[drb_index]->e_RABlevelQoSParameters.qCI;

                    /* check for Bearer_type*/
                    if((RRM_DRB_CONFIG_BEARER_TYPE_PRESENT & p_uecc_ue_context->
                                p_e_rab_list[drb_index]->drb_config.bitmask) && 
                            (BEARER_TYPE_GBR == p_uecc_ue_context->p_e_rab_list[drb_index]->
                             drb_config.bearer_type))
                    {
                        /* Setting the bitmask for GBR-QoS*/
                        create_ue_entity_req.create_drb_entity_info.
                            create_drb_entity[create_drb_entity_counter].
                            uecc_llim_drb_config.qos_info.bitmask |= RRC_GBR_QOS_INFO_PRESENT;

                        create_ue_entity_req.create_drb_entity_info.
                            create_drb_entity[create_drb_entity_counter].
                            uecc_llim_drb_config.qos_info.gbr_qos_info.dl_mbr =
                            (U32)p_uecc_ue_context->p_e_rab_list[drb_index]->
                            e_RABlevelQoSParameters.gbrQosInformation.
                            e_RAB_MaximumBitrateDL;
                        create_ue_entity_req.create_drb_entity_info.
                            create_drb_entity[create_drb_entity_counter].
                            uecc_llim_drb_config.qos_info.gbr_qos_info.ul_mbr =
                            (U32)p_uecc_ue_context->p_e_rab_list[drb_index]->
                            e_RABlevelQoSParameters.gbrQosInformation.
                            e_RAB_MaximumBitrateUL;
                        create_ue_entity_req.create_drb_entity_info.
                            create_drb_entity[create_drb_entity_counter].
                            uecc_llim_drb_config.qos_info.gbr_qos_info.dl_gbr =
                            (U32)p_uecc_ue_context->p_e_rab_list[drb_index]->
                            e_RABlevelQoSParameters.gbrQosInformation.
                            e_RAB_GuaranteedBitrateDL;
                        create_ue_entity_req.create_drb_entity_info.
                            create_drb_entity[create_drb_entity_counter].
                            uecc_llim_drb_config.qos_info.gbr_qos_info.ul_gbr =
                            (U32)p_uecc_ue_context->p_e_rab_list[drb_index]->
                            e_RABlevelQoSParameters.gbrQosInformation.
                            e_RAB_GuaranteedBitrateUL;
                    }
                    /* Qos changes stop*/

                    /* clear bits as requested by LLIM team */
                    create_ue_entity_req.create_drb_entity_info.
                        create_drb_entity[create_drb_entity_counter].
                        uecc_llim_drb_config.drb_config.bitmask =
                        (rrc_bitmask_t)(create_ue_entity_req.create_drb_entity_info.
                                create_drb_entity[create_drb_entity_counter].
                                uecc_llim_drb_config.drb_config.bitmask & 
                                ~RRM_DRB_CONFIG_RLC_CONFIG_UE_PRESENT);

                    create_ue_entity_req.create_drb_entity_info.
                        create_drb_entity[create_drb_entity_counter].
                        uecc_llim_drb_config.drb_config.bitmask =
                        (rrc_bitmask_t)(create_ue_entity_req.create_drb_entity_info.
                                create_drb_entity[create_drb_entity_counter].
                                uecc_llim_drb_config.drb_config.bitmask &
                                ~RRM_DRB_CONFIG_LOGICAL_CHANNEL_CONFIG_PRESENT);

                    /*drb_s1u_info:tunnel_info_list */
                    /* drb_s1u_info:gtp_teid */
                    pp_rrc_uecc_llim_s1u_tunnel_info_list =
                        &(create_ue_entity_req.create_drb_entity_info.
                                create_drb_entity[create_drb_entity_counter].
                                drb_s1u_info.tunnel_info_list[0]);

                    RRC_ASSERT(sizeof(rrc_gtp_teid_t) ==
                            sizeof(p_uecc_ue_context->p_e_rab_list[drb_index]->
                                gTP_TEID.data));

                    /*sap_flag*/
                    pp_rrc_uecc_llim_s1u_tunnel_info_list
                        [BEARER_TUNNEL_ID].sap_flag = p_uecc_ue_context->
                        p_e_rab_list[drb_index]->drb_config.s1u_config.sap_flags;

                    if ((X2_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover) ||
                            (INTER_CELL_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover))
                    {
                        RRC_ASSERT(sizeof(rrc_gtp_teid_t) ==
                                sizeof(p_uecc_ue_context->p_e_rab_list[drb_index]->
                                    uecc_x2ap_drb_ctx.gTP_TEID.data));

                        rrc_unpack_U32(
                                &pp_rrc_uecc_llim_s1u_tunnel_info_list[BEARER_TUNNEL_ID].teid_peer,
                                p_uecc_ue_context->p_e_rab_list[drb_index]->uecc_x2ap_drb_ctx.gTP_TEID.data);

                        /* ipv6_change */        
                        if (RRC_MAX_IP_ADDR_LEN_IPV6*8 
                                < p_uecc_ue_context->p_e_rab_list[drb_index]->transportLayerAddress.numbits)
                        {
                            /* ipv6_change */
                            if ( RRC_MAX_IP_ADDR_LEN*8 /*8 bits in byte*/ <
                                    p_uecc_ue_context->p_e_rab_list[drb_index]->
                                    uecc_x2ap_drb_ctx.transportLayerAddress.numbits)
                            {
                                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                        (p_uecc_ue_context->p_gb_context)->facility_name,
                                        RRC_WARNING,
                                        "[UECC_LLIM_ADD_LC_REQ] "
                                        "transportLayerAddress has invalid size");
                                RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                                return RRC_FAILURE;
                            }
                            /* ipv6_change */
                            else if(RRC_MAX_IP_ADDR_LEN*8 /*8 bits in byte*/ >
                                    p_uecc_ue_context->p_e_rab_list[drb_index]->
                                    transportLayerAddress.numbits)  
                            {

                                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                        (p_uecc_ue_context->p_gb_context)->facility_name,
                                        RRC_WARNING,
                                        "[UECC_LLIM_ADD_LC_REQ] "
                                        "transportLayerAddress has invalid size");
                                p_uecc_ue_context->p_e_rab_list[drb_index]->
                                    transportLayerAddress.numbits = RRC_MAX_IP_ADDR_LEN_IPV6*8;
                                /*8 bits in byte*/
                            }
                            /* ipv6_change */        
                        }
                        /* drb_s1u_info:ip_address_octet_size */
                        pp_rrc_uecc_llim_s1u_tunnel_info_list[BEARER_TUNNEL_ID].
                            transport_addr.data_length =
                            (U8)(p_uecc_ue_context->p_e_rab_list[drb_index]->
                                    uecc_x2ap_drb_ctx.transportLayerAddress.numbits/8);

                        /* drb_s1u_info:ip_address */
                        l3_memcpy_wrapper(
                                pp_rrc_uecc_llim_s1u_tunnel_info_list[BEARER_TUNNEL_ID].
                                transport_addr.data,
                                p_uecc_ue_context->p_e_rab_list[drb_index]->
                                uecc_x2ap_drb_ctx.transportLayerAddress.data,
                                pp_rrc_uecc_llim_s1u_tunnel_info_list[BEARER_TUNNEL_ID].
                                transport_addr.data_length);
                    }
                    else
                    {
                        RRC_ASSERT(sizeof(rrc_gtp_teid_t) ==
                                sizeof(p_uecc_ue_context->p_e_rab_list[drb_index]->
                                    gTP_TEID.data));

                        rrc_unpack_U32(& pp_rrc_uecc_llim_s1u_tunnel_info_list
                                [BEARER_TUNNEL_ID].teid_peer,
                                p_uecc_ue_context->p_e_rab_list[drb_index]->gTP_TEID.data);
                        /* ipv6_change */
                        if (RRC_MAX_IP_ADDR_LEN_IPV6*8 
                                < p_uecc_ue_context->p_e_rab_list[drb_index]->transportLayerAddress.numbits)
                        {
                            /* ipv6_change */
                            if ( RRC_MAX_IP_ADDR_LEN*8 /*8 bits in byte*/ <
                                    p_uecc_ue_context->p_e_rab_list[drb_index]->
                                    transportLayerAddress.numbits)
                            {
                                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                        (p_uecc_ue_context->p_gb_context)->facility_name,
                                        RRC_WARNING,
                                        "[UECC_LLIM_ADD_LC_REQ] "
                                        "transportLayerAddress has invalid size");
                                RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                                return RRC_FAILURE;
                            }
                            /* ipv6_change */
                            else if(RRC_MAX_IP_ADDR_LEN*8 /*8 bits in byte*/ >
                                    p_uecc_ue_context->p_e_rab_list[drb_index]->
                                    transportLayerAddress.numbits)  
                            {

                                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                        (p_uecc_ue_context->p_gb_context)->facility_name,
                                        RRC_WARNING,
                                        "[UECC_LLIM_ADD_LC_REQ] "
                                        "transportLayerAddress has invalid size");
                                p_uecc_ue_context->p_e_rab_list[drb_index]->
                                    transportLayerAddress.numbits = RRC_MAX_IP_ADDR_LEN_IPV6*8;
                                /*8 bits in byte*/
                            }
                            /* ipv6_change */
                        }
                        /* drb_s1u_info:ip_address_octet_size */
                        pp_rrc_uecc_llim_s1u_tunnel_info_list[BEARER_TUNNEL_ID].
                            transport_addr.data_length =
                            (U8)(p_uecc_ue_context->p_e_rab_list[drb_index]->
                                    transportLayerAddress.numbits/8);

                        /* drb_s1u_info:ip_address */
                        l3_memcpy_wrapper(
                                pp_rrc_uecc_llim_s1u_tunnel_info_list[BEARER_TUNNEL_ID].
                                transport_addr.data,
                                p_uecc_ue_context->p_e_rab_list[drb_index]->
                                transportLayerAddress.data,
                                pp_rrc_uecc_llim_s1u_tunnel_info_list[BEARER_TUNNEL_ID].
                                transport_addr.data_length);
                    }
                    /* drb_s1u_info:tunnel_list_count */
                    create_ue_entity_req.create_drb_entity_info.
                        create_drb_entity[create_drb_entity_counter].drb_s1u_info.
                        tunnel_list_count = NUM_TUNNELS_WITHOUT_FWD;

                    /* configure_ciphering */
                    create_ue_entity_req.create_drb_entity_info.
                        create_drb_entity[create_drb_entity_counter].bitmask |=
                        UECC_LLIM_DRB_CONFIGURE_CIPHERING_PRESENT;

                    create_ue_entity_req.create_drb_entity_info.
                        create_drb_entity[create_drb_entity_counter].
                        configure_ciphering =
                        p_uecc_ue_context->configure_ciphering_user_plane;
                    create_drb_entity_counter++;

                    if (create_ue_entity_req.create_drb_entity_info.
                            create_drb_entity_counter == create_drb_entity_counter)
                    {
                        break;
                    }
                }
                else
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "DRB Count has increase maximum number of Supported DRBs"
                            "i.e 10");
                    break;
                }    
            }

            /*sps_config*/
            if (p_uecc_ue_context->m.sps_config_updated)
            {
                create_ue_entity_req.bitmask |=  
                    UECC_LLIM_CREATE_UE_ENTITY_REQ_SPS_CONFIG_PRESENT;
                /* SPS Start */
                l3_memcpy_wrapper(&create_ue_entity_req.sps_config,
                        p_uecc_ue_context->p_sps_config,
                        sizeof(rrc_sps_config_t));
                /* SPS Stop */
            }

            /*ho_triggered*/
            create_ue_entity_req.bitmask |=  
                UECC_LLIM_CREATE_UE_ENTITY_REQ_HO_TRIGGERED_FLAG;
            /*SPR_19066_START*/
            create_ue_entity_req.ho_triggered.ho_trigger = 1;
            if(S1_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover)
            {
                if((RRC_SOURCE_ENB_TO_TARGET_ENB_TRANSPARENT_CONTAINER_PRESENT & 
                            p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                            rrc_s1ap_ho_request.
                            source_to_target_transparent_container.bitmask) &&
                        (p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                         rrc_s1ap_ho_request.
                         source_to_target_transparent_container.
                         source_enb_to_target_enb_transparent_container.
                         rRC_Container.m.rrm_ConfigPresent) &&
                        (p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                         rrc_s1ap_ho_request.
                         source_to_target_transparent_container.
                         source_enb_to_target_enb_transparent_container.
                         rRC_Container.rrm_Config.m.ue_InactiveTimePresent))
                {
                    /* Send the received lapsed enum value to PDCP */
                    create_ue_entity_req.ho_triggered.rrc_ue_inactive_time_lapsed.
                        ue_inactive_time_val = p_uecc_ue_context->ho_info.
                        p_ho_info->p_trg_ho_info->rrc_s1ap_ho_request.
                        source_to_target_transparent_container.
                        source_enb_to_target_enb_transparent_container.
                        rRC_Container.rrm_Config.ue_InactiveTime;

                    /* Set the Bitmask */
                    create_ue_entity_req.ho_triggered.optional_elems_present |= 
                        RRC_PDCP_UE_INACTIVE_TIME_LAPSED_PRESENT;
                }
            }
            else if(X2_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover)
            {
                if((p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                            rrc_x2ap_ho_request.rrc_x2ap_ue_ctx_info.
                            rRC_Container.m.rrm_ConfigPresent) &&
                        (p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                         rrc_x2ap_ho_request.rrc_x2ap_ue_ctx_info.
                         rRC_Container.rrm_Config.m.ue_InactiveTimePresent))
                {
                    /* Send the received lapsed enum value to PDCP */
                    create_ue_entity_req.ho_triggered.rrc_ue_inactive_time_lapsed.
                        ue_inactive_time_val = p_uecc_ue_context->ho_info.
                        p_ho_info->p_trg_ho_info->rrc_x2ap_ho_request.
                        rrc_x2ap_ue_ctx_info.rRC_Container.rrm_Config.ue_InactiveTime;

                    /* Set the Bitmask */
                    create_ue_entity_req.ho_triggered.optional_elems_present |= 
                        RRC_PDCP_UE_INACTIVE_TIME_LAPSED_PRESENT;

                }
            }
            /*SPR_19066_END*/

            /* meas_config */
            if (p_uecc_ue_context->m.meas_config_updated)
            {
                create_ue_entity_req.bitmask |=  
                    UECC_LLIM_CREATE_UE_ENTITY_REQ_MEAS_CONFIG_PRESENT;
                //TB_COMMENT
                create_ue_entity_req.meas_config = *p_uecc_ue_context->p_meas_config;
            }

            /* FWD tunnels */
            p_uecc_s1_trg_ho_info = 
                &(p_uecc_ue_context->ho_info.p_ho_info->
                        p_trg_ho_info->s1_trg_ho_info);

            total_fwd_elem = p_uecc_s1_trg_ho_info->trg_ho_forward_list_count;

            for (drb_index =0, create_drb_idx = 0; 
                    total_fwd_elem &&(drb_index < MAX_ERAB_COUNT) &&
                    (create_drb_idx < RRC_UECC_LLIM_MAX_CREATE_DRB) ;
                    drb_index++)
            {
                if (!p_uecc_s1_trg_ho_info->
                        p_erab_trg_ho_forward_list[drb_index])
                {
                    continue;
                }
                /*SPR 8257 Start*/
                /* klockwork fix */
                while((create_drb_idx < RRC_UECC_LLIM_MAX_CREATE_DRB)
                        &&

                        (drb_index != create_ue_entity_req.create_drb_entity_info.
                         create_drb_entity[create_drb_idx].uecc_llim_drb_config.drb_config.erab_id)
                        && (create_drb_idx < RRC_UECC_LLIM_MAX_CREATE_DRB))
                {
                    create_drb_idx++;
                }
                if (create_drb_idx != RRC_UECC_LLIM_MAX_CREATE_DRB)
                {
                    /*SPR 8257 Stop*/
                    switch (p_uecc_s1_trg_ho_info->p_erab_trg_ho_forward_list
                            [drb_index]->forward_direction)
                    {
                        case UECC_FORWARDING_DIRECTION_UL:
                            create_ue_entity_req.create_drb_entity_info.
                                create_drb_entity[create_drb_idx].drb_s1u_info.
                                tunnel_list_count = 
                                NUM_TUNNELS_WITH_FWD_EITHER_UL_OR_DL;

                            create_ue_entity_req.create_drb_entity_info.
                                create_drb_entity[create_drb_idx].drb_s1u_info.
                                tunnel_info_list[FWD_TUNNEL_ID_1].sap_flag = 
                                RRC_S1U_CREATE_UE_UL_FORWARDING_TUNNEL_SAP_FLAG;

                            create_drb_idx++;
                            break;

                        case UECC_FORWARDING_DIRECTION_DL:
                            create_ue_entity_req.create_drb_entity_info.
                                create_drb_entity[create_drb_idx].drb_s1u_info.
                                tunnel_list_count = 
                                NUM_TUNNELS_WITH_FWD_EITHER_UL_OR_DL;

                            create_ue_entity_req.create_drb_entity_info.
                                create_drb_entity[create_drb_idx].drb_s1u_info.
                                tunnel_info_list[FWD_TUNNEL_ID_1].sap_flag = 
                                RRC_S1U_CREATE_UE_DL_FORWARDING_TUNNEL_SAP_FLAG;

                            create_drb_idx++;
                            break;

                        case UECC_FORWARDING_DIRECTION_BOTH:
                            create_ue_entity_req.create_drb_entity_info.
                                create_drb_entity[create_drb_idx].drb_s1u_info.
                                tunnel_list_count = 
                                NUM_TUNNELS_WITH_FWD_BOTH_UL_AND_DL;

                            create_ue_entity_req.create_drb_entity_info.
                                create_drb_entity[create_drb_idx].drb_s1u_info.
                                tunnel_info_list[FWD_TUNNEL_ID_1].sap_flag = 
                                RRC_S1U_CREATE_UE_UL_FORWARDING_TUNNEL_SAP_FLAG;

                            create_ue_entity_req.create_drb_entity_info.
                                create_drb_entity[create_drb_idx].drb_s1u_info.
                                tunnel_info_list[FWD_TUNNEL_ID_2].sap_flag = 
                                RRC_S1U_CREATE_UE_DL_FORWARDING_TUNNEL_SAP_FLAG;

                            create_drb_idx++;
                            break;
                        default:
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_WARNING,
                                    "Invalid forward_direction");
                    }
                    total_fwd_elem--;
                }
            }
            /* HD-FDD start */
            if(p_uecc_ue_context->ue_mode == 1)
            {
                create_ue_entity_req.bitmask |=
                    UECC_LLIM_CREATE_UE_ENTITY_UE_HD_FDD_MODE_PRESENT;
            }
            /* HD-FDD stop */
            /*SPR:5084 start */
            create_ue_entity_req.bitmask |= 
                UECC_LLIM_CREATE_UE_ENTITY_UE_CATEGORY_PRESENT;
            create_ue_entity_req.ue_category = p_uecc_ue_context->ue_category;
            /*SPR:5084 stop */
            /*SPR_18803_START*/
            if(1 == p_uecc_ue_context->m.access_stratum_release)
            {
                create_ue_entity_req.bitmask |=
                    UECC_LLIM_CREATE_UE_ENTITY_RAT_1_SUPPORT_PRESENT;

                if(FGI_BIT_2 & p_uecc_ue_context->feature_group_indicators)
                {
                    create_ue_entity_req.rat_1_support = 1;
                }
                else
                {
                    create_ue_entity_req.rat_1_support = 0;
                }
            }
            /*SPR_18803_END*/
            /* 36321_CR0538 start */
            create_ue_entity_req.bitmask |=
                UECC_LLIM_CREATE_UE_ENTITY_ACCESS_STRATUM_REL_PRESENT;
            create_ue_entity_req.access_stratum_release = p_uecc_ue_context->access_stratum_release;
            /* 36321_CR0538 stop */
            /*SPR_17121_START*/
            /* Populate Mac-I req */
            rrc_mac_i_msg_t              *p_mac_i_req = RRC_PNULL;
            create_ue_entity_req.bitmask |= 
                UECC_LLIM_CREATE_UE_ENTITY_MACI_REQ_PRESENT;

            p_mac_i_req = &(create_ue_entity_req.mac_i_req);

            rrc_populate_maci_req(p_mac_i_req, p_uecc_ue_context );
            /*SPR_17121_END*/

            /*SPR_19066_START*/
            if (p_uecc_ue_context->m.ue_inactive_time_updated)
            { 
                create_ue_entity_req.bitmask |= 
                    UECC_LLIM_CREATE_UE_ENTITY_UE_INACTIVITY_TIMER_PRESENT;
                create_ue_entity_req.ue_inactivity_timer.ue_inactive_time_config = 
                    p_uecc_ue_context->ue_inactive_time;
            }
            /*SPR_19066_END*/
    }
    /*BUG 604 changes start*/
    if(INTRA_CELL_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover)
    {
        create_ue_entity_req.bitmask |=
            UECC_LLIM_CREATE_UE_ENTITY_HO_TYPE_PRESENT;
        create_ue_entity_req.ho_type = HANDOVER_TYPE_INTRA_CELL;
    }
    /*BUG 604 changes stop*/

    if ((p_uecc_ue_context->m.scell_config_present == RRC_TRUE) && 
            (PNULL != p_uecc_ue_context->p_scell_config))
    {
        create_ue_entity_req.bitmask |= UECC_LLIM_CREATE_UE_ENTITY_SCELL_CONFIG_PRESENT;        

        l3_memcpy_wrapper(&create_ue_entity_req.scell_config,
                p_uecc_ue_context->p_scell_config, 
                sizeof(rrm_scell_config_t));

        if (p_uecc_ue_context->p_scell_config->bitmask &
                RRM_SCELL_ADD_MOD_LIST_PRESENT)
        {
            for (index = RRC_NULL; index < p_uecc_ue_context->p_scell_config->scell_add_mod_list.
                    count; index++)
            {
                scell_index = p_uecc_ue_context->p_scell_config->scell_add_mod_list.
                    rrc_scell_to_add_mod[index].scellIndex;

                create_ue_entity_req.scells_operation_list[scell_index].
                    chk_cellid_exist = RRC_TRUE;

                create_ue_entity_req.scells_operation_list[scell_index].
                    operation_type = ADD_SCELL;
            }
        }
    }

    if (p_uecc_ue_context->m.rel10_ue_category_present)
    {
        create_ue_entity_req.bitmask |= UECC_LLIM_CREATE_UE_ENTITY_R10_UE_CATEGORY_PRESENT;

        create_ue_entity_req.rel10_ue_category = p_uecc_ue_context->rel10_ue_category;
    }

    /*HANDOVER_CHANGES_REVANTH_01_end*/
    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_CREATE_UE_ENTITY_REQ,
            sizeof(rrc_uecc_llim_create_ue_entity_req_t),
            &create_ue_entity_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;
}
/* coverity_fix_54690_stop */

/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_rrc_connnection_setup
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : none
 * Description    : This is the function for building and sending messages from
 *                : the UECC to LLIM
 * Returns        : rrc_return_et
 ****************************************************************************/
rrc_return_et uecc_llim_build_and_send_rrc_connection_setup(
        uecc_ue_context_t*  p_uecc_ue_context
        )
{
    OSCTXT                                      asn1_ctx;
    DL_CCCH_Message                             dl_ccch_msg;
    rrc_return_et                               result = RRC_FAILURE;

    rrc_uecc_llim_ccch_data_req_t               *p_ccch_data_req = PNULL;
    U8  msg[sizeof(rrc_uecc_llim_ccch_data_req_t)+UECC_MAX_ASN1_BUF_LEN];

    rrm_srb_info_t      srb_info;
    EVENT_EXTERNAL_HEADER                       *p_event_header = PNULL;
    U32                                         encoded_msg_len = 0;
    LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT *p_event_rrc_protocol_err = PNULL;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Init ASN1 context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[RRCConnectionSetup] ASN1 context initialization failed.");
        return RRC_FAILURE;
    }

    do
    {
        /* Fill the values in the ASN structures that shall be encoded by
         * ASN Encoder */
        /* Downlink CCCH message type */
        dl_ccch_msg.message.t = T_DL_CCCH_MessageType_c1;
        dl_ccch_msg.message.u.c1 =
            rtxMemAllocType(&asn1_ctx, DL_CCCH_MessageType_c1);
        if (PNULL == dl_ccch_msg.message.u.c1)
        {
            break;
        }

        /* Choose RRCConnectionSetup */
        dl_ccch_msg.message.u.c1->t =
            T_DL_CCCH_MessageType_c1_rrcConnectionSetup;

        dl_ccch_msg.message.u.c1->u.rrcConnectionSetup =
            rtxMemAllocType(&asn1_ctx, RRCConnectionSetup);
        if (PNULL == dl_ccch_msg.message.u.c1->u.rrcConnectionSetup)
        {
            break;
        }

        /* Generate RRC Transaction Identifier */
        dl_ccch_msg.message.u.c1->u.rrcConnectionSetup->
            rrc_TransactionIdentifier =
            (RRC_TransactionIdentifier) (uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context) &
                    UECC_LTE_RRC_TRANSACTION_ID_MASK);

        /* critical extensions c1 */
        dl_ccch_msg.message.u.c1->u.rrcConnectionSetup->criticalExtensions.t =
            T_RRCConnectionSetup_criticalExtensions_c1;

        dl_ccch_msg.message.u.c1->u.rrcConnectionSetup->criticalExtensions.u.c1=
            rtxMemAllocType(&asn1_ctx,RRCConnectionSetup_criticalExtensions_c1);
        if (PNULL == dl_ccch_msg.message.u.c1->u.rrcConnectionSetup->
                criticalExtensions.u.c1)
        {
            break;
        }

        /* Choose RRCConnectionSetup_r8 */
        dl_ccch_msg.message.u.c1->u.rrcConnectionSetup->
            criticalExtensions.u.c1->t =
            T_RRCConnectionSetup_criticalExtensions_c1_rrcConnectionSetup_r8;

        /* RRCConnectionSetup_r8 Structure */
        dl_ccch_msg.message.u.c1->u.rrcConnectionSetup->
            criticalExtensions.u.c1->u.rrcConnectionSetup_r8 =
            rtxMemAllocType(&asn1_ctx, RRCConnectionSetup_r8_IEs);
        if (PNULL == dl_ccch_msg.message.u.c1->u.rrcConnectionSetup->
                criticalExtensions.u.c1->u.rrcConnectionSetup_r8)
        {
            break;
        }
        asn1Init_RRCConnectionSetup_r8_IEs(
                dl_ccch_msg.message.u.c1->u.rrcConnectionSetup->
                criticalExtensions.u.c1->u.rrcConnectionSetup_r8);

        /* Use SRB1 configuration from UE context hear */
        srb_info.bitmask = RRM_SRB_INFO_SRB1_CONFIG_PRESENT;
        srb_info.srb1_config = p_uecc_ue_context->srb1_config;

        if (RRC_SUCCESS !=
                uecc_llim_build_asn1_radio_resource_cfg_dedicated(
                    p_uecc_ue_context,
                    &dl_ccch_msg.message.u.c1->u.rrcConnectionSetup->
                    criticalExtensions.u.c1->u.rrcConnectionSetup_r8->
                    radioResourceConfigDedicated,
                    &srb_info,
                    &asn1_ctx))
        {
            break;
        }

        /* Prepare pointer on RRC internal message */
        p_ccch_data_req = (rrc_uecc_llim_ccch_data_req_t*)msg;

        /* Do ASN1 encode */
        pu_setBuffer(&asn1_ctx, p_ccch_data_req->data_buffer,
                UECC_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);

        if (RT_OK != asn1PE_DL_CCCH_Message(&asn1_ctx, &dl_ccch_msg))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionSetup] ASN1 encoding failed.");

            /*Generating Protocol Event LOCAL_EVENT_RRC_PROTOCOL_ERROR*/
            p_event_rrc_protocol_err = rrc_mem_get(sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));
            if (PNULL != p_event_rrc_protocol_err)
            {
                memset_wrapper(p_event_rrc_protocol_err, RRC_NULL, 
                        sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));

                p_event_rrc_protocol_err->header.length = 
                    sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT);
                p_event_rrc_protocol_err->header.event_id = LOCAL_EVENT_RRC_PROTOCOL_ERROR;

                l3_strncpy_wrapper((S8 *)(p_event_rrc_protocol_err->EVENT_PARAM_RRC_MESSAGE_DISCARDED),
                        (S8 *)("RRC CONNECTION SETUP"), RRC_MESSAGE_DISCARDED_SIZE);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_rrc_protocol_err);
            }
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);
            rrc_asn1PrtToStr_DL_CCCH_Message(RRC_ASN,"DL_CCCH_Message",
                    &dl_ccch_msg,"RRCConnectionSetup",
                    p_ccch_data_req->data_buffer, encoded_msg_len);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                memset_wrapper(p_event_header, RRC_NULL, (sizeof(EVENT_EXTERNAL_HEADER) +
                            encoded_msg_len));
                rrc_uecc_fill_protocol_event_params(p_uecc_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_RRC_CONNECTION_SETUP,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_ccch_data_req->data_buffer,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        p_ccch_data_req->data_buffer_length = (rrc_counter_t)pe_GetMsgLen(&asn1_ctx);
        p_ccch_data_req->rnti = p_uecc_ue_context->crnti;
        p_ccch_data_req->cell_index = p_uecc_ue_context->cell_index;

        /* trace_fix */
        /* SPR 16113 Start */
        uecc_rrc_ue_assoc_msg_max_trace_handler(p_uecc_ue_context, p_ccch_data_req->data_buffer, 
                p_ccch_data_req->data_buffer_length, "RRC Connection Setup", RRC_DL_CCCH);
        /* SPR 16113 Stop */
        /* trace_fix */

        /* Send message to LLIM  */
        result = uecc_rrc_send_internal_msg(
                RRC_LLIM_MODULE_ID,
                UECC_LLIM_CCCH_DATA_REQ,
                (U16)( p_ccch_data_req->data_buffer_length +
                    sizeof(rrc_uecc_llim_ccch_data_req_t)),
                msg);

        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_INFO,"RRC_MSG: RRCConnectionSetup %s",
                change_data_to_str(p_ccch_data_req->data_buffer_length, p_ccch_data_req->data_buffer));

    } while(0);

    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;
}

/* ERAB SETUP START */

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_add_rollback_req
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       Send internal message UECC_LLIM_ADD_LC_REQ to LLIM
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_add_rollback_req
(
 uecc_ue_context_t *p_uecc_ue_context
 )
{
    rrc_return_et   rrc_response = RRC_FAILURE;
    U8*             p_msg = PNULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_msg = uecc_alloc_intrl_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_ADD_ROLLBACK_REQ,
            sizeof(rrc_uecc_llim_add_rollback_req_t));

    if (PNULL != p_msg)
    {
        uecc_llim_build_add_rollback_req(p_uecc_ue_context,
                (rrc_uecc_llim_add_rollback_req_t*)(p_msg + RRC_API_HEADER_SIZE));

        /* Send the built API to LLIM  module*/
        rrc_send_message(p_msg, RRC_LLIM_MODULE_ID);
        rrc_response = RRC_SUCCESS;
    }
    else
    {
        rrc_response = RRC_FAILURE;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return rrc_response;


}


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_add_rollback_req
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *                  rrc_uecc_llim_add_rollback_req_t* p_rrc_uecc_llim_add_rollback_req
 *   OUTPUT       : none
 *
 *   DESCRIPTION  : Build internal message UECC_LLIM_ADD_LC_REQ
 *
 *   RETURNS      : None
 *
 ******************************************************************************/
void uecc_llim_build_add_rollback_req(
        uecc_ue_context_t*  p_uecc_ue_context,
        rrc_uecc_llim_add_rollback_req_t* p_rrc_uecc_llim_add_rollback_req
        )
{
    rrc_counter_t drb_index = 0;
    rrc_counter_t del_counter = 0;
    U8 erab_id = 0;
    /* Copy Pointer of Optional Parameters */
    uecc_rm_erab_setup_op_data_t* p_erab_op_params =  &p_uecc_ue_context->
        p_curr_proc_data->u.erab_setup_request_data.erab_op_params;    

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_add_rollback_req);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Fill message */
    /* Trasnsaction ID */
    p_rrc_uecc_llim_add_rollback_req->transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
    /* UE Index */
    p_rrc_uecc_llim_add_rollback_req->ue_index = p_uecc_ue_context->ue_index;
    p_rrc_uecc_llim_add_rollback_req->cell_index = p_uecc_ue_context->cell_index;

    /* Set Bitmask to 0 */
    p_rrc_uecc_llim_add_rollback_req->bitmask = 0;

    if (MAX_ERAB_COUNT >= p_uecc_ue_context->p_curr_proc_data->u.
            erab_setup_request_data.erab_info_data.count)
    {
        /* Fill DRB Info */
        for(drb_index = 0;
                drb_index < p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                erab_info_data.count; 
                drb_index++)
        {
            if (p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                    erab_info_data.erab_info[drb_index].status == RRC_NO_ERROR)
            {

                erab_id = p_uecc_ue_context->p_curr_proc_data->u.
                    erab_setup_request_data.erab_info_data.erab_info
                    [drb_index].erab_id;
                if(RRC_UECC_LLIM_MAX_DRB > del_counter)
                {

                    p_rrc_uecc_llim_add_rollback_req->add_drb_entity[del_counter].lc_id
                        =  p_uecc_ue_context->p_e_rab_list[erab_id]->drb_config.
                        logical_channel_identity;

                    if (RRC_RLC_CONFIG_AM_CONFIG_PRESENT &
                            p_uecc_ue_context->p_e_rab_list[erab_id]->
                            drb_config.rlc_config_enb.rlc_config.bitmask)
                    {
                        p_rrc_uecc_llim_add_rollback_req->add_drb_entity[del_counter].
                            rlc_mode = RLC_CONFIG_AM_MODE;
                    }
                    if (RRC_RLC_CONFIG_UM_BI_DIRECTIONAL_CONFIG_PRESENT &
                            p_uecc_ue_context->p_e_rab_list[erab_id]->
                            drb_config.rlc_config_enb.rlc_config.bitmask)
                    {

                        p_rrc_uecc_llim_add_rollback_req->add_drb_entity[del_counter].
                            rlc_mode = RLC_CONFIG_UM_BI_DIR_MODE;
                    }
                    if (RRC_RLC_CONFIG_UM_UNI_DIRECTIONAL_CONFIG_UL_PRESENT &
                            p_uecc_ue_context->p_e_rab_list[erab_id]->
                            drb_config.rlc_config_enb.rlc_config.bitmask)
                    {
                        p_rrc_uecc_llim_add_rollback_req->add_drb_entity[del_counter].
                            rlc_mode = RLC_CONFIG_UM_UL_UNI_DIR_MODE;
                    }
                    if (RRC_RLC_CONFIG_UM_UNI_DIRECTIONAL_CONFIG_DL_PRESENT &
                            p_uecc_ue_context->p_e_rab_list[erab_id]->
                            drb_config.rlc_config_enb.rlc_config.bitmask)
                    {
                        p_rrc_uecc_llim_add_rollback_req->add_drb_entity[del_counter].
                            rlc_mode = RLC_CONFIG_UM_DL_UNI_DIR_MODE;
                    }
                    del_counter++;
                }
                else
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,"Invalid del_counter");
                    break;
                }
            }
        }
    }
    else
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"Invalid del_counter");
        return;
    }

    /* Fill Old Mac Config if New Mac Config is Present */
    if (p_erab_op_params->m.mac_config_present)
    {
        p_rrc_uecc_llim_add_rollback_req->bitmask |= 
            UECC_LLIM_ADD_ROLLBACK_REQ_OLD_MAC_CONFIG_PRESENT; 
        p_rrc_uecc_llim_add_rollback_req->mac_config = p_uecc_ue_context->
            mac_config;
    } 

    /* Fill Old Meas Config if New Meas Config is Present */
    if (p_erab_op_params->m.meas_config_present)
    {
        p_rrc_uecc_llim_add_rollback_req->bitmask |= 
            UECC_LLIM_ADD_ROLLBACK_REQ_OLD_MEAS_CONFIG_PRESENT; 
        p_rrc_uecc_llim_add_rollback_req->meas_config = *p_uecc_ue_context->
            p_meas_config;
    } 
    p_rrc_uecc_llim_add_rollback_req->add_rollback_drb_count = del_counter;

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);    

}

/* ERAB SETUP STOP */
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_add_lc_req
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION  : Send internal message UECC_LLIM_ADD_LC_REQ to LLIM
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_add_lc_req
(
 uecc_ue_context_t *p_uecc_ue_context
 )
{
    rrc_return_et   rrc_response = RRC_FAILURE;
    U8*             p_msg = PNULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_msg = uecc_alloc_intrl_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_ADD_LC_REQ,
            sizeof(rrc_uecc_llim_add_lc_req_t));

    if (PNULL != p_msg)
    {

        /* Check the UE Category in UE Context - If Invalid then
         * terminate the procedure
         */
        if (p_uecc_ue_context->p_curr_proc_data && //add for bugid 117724
			(UECC_ICS_PROC == p_uecc_ue_context->p_curr_proc_data->t))
        {
            if (p_uecc_ue_context->ue_category >=1 &&
                    p_uecc_ue_context->ue_category <=5)
            {
                /* Log the message */
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_INFO,"UE Category Of UE : %u",
                        p_uecc_ue_context->ue_category);
            }
            else
            {
                /* Log the message and return RRC_FAILURE; */
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,"InValid UE Category Found in UE Context : %u",
                        p_uecc_ue_context->ue_category);
                /* coverity_fix_48257_start */
                rrc_msg_mem_free(p_msg);
                /* Coverity ID 85906 Fix Start*/
                /*	p_msg = PNULL; */
                /* Coverity ID 85906 Fix End*/
                /* coverity_fix_48257_stop */
                return RRC_FAILURE;

            }
            /* eMTC changes stop */
        }

        uecc_llim_build_add_lc_req(p_uecc_ue_context,
                (rrc_uecc_llim_add_lc_req_t*)(p_msg + RRC_API_HEADER_SIZE));

        /* Send the built API to LLIM  module*/
        rrc_send_message(p_msg, RRC_LLIM_MODULE_ID);
        rrc_response = RRC_SUCCESS;
    }
    else
    {
        rrc_response = RRC_FAILURE;
    }


    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return rrc_response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_add_lc_req
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *                  rrc_uecc_llim_add_lc_req_t* p_rrc_uecc_llim_add_lc_req
 *   OUTPUT       : none
 *
 *   DESCRIPTION  : Build internal message UECC_LLIM_ADD_LC_REQ
 *
 *   RETURNS      : None
 *
 ******************************************************************************/
void uecc_llim_build_add_lc_req(
        uecc_ue_context_t*  p_uecc_ue_context,
        rrc_uecc_llim_add_lc_req_t* p_rrc_uecc_llim_add_lc_req
        )
{
    rrc_counter_t drb_index = 0;
    /*NR_DC Code Changes Start*/
    rrc_counter_t drb_count = 0;
    /*NR_DC Code Changes Stop*/
    U8            erab_id   = 0;
    /*OPTION3X Changes Start*/
    U8            count     = 0; 
    /*OPTION3X Changes Stop*/

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_add_lc_req);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* disable masks by default */
    p_rrc_uecc_llim_add_lc_req->bitmask = 0;

    /* Fill message */
    p_rrc_uecc_llim_add_lc_req->transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
    p_rrc_uecc_llim_add_lc_req->ue_index = p_uecc_ue_context->ue_index;
    p_rrc_uecc_llim_add_lc_req->cell_index = p_uecc_ue_context->cell_index;

    /* HD-FDD start */
    if(p_uecc_ue_context->ue_mode == 1)
    {
        p_rrc_uecc_llim_add_lc_req->bitmask |=
            UECC_LLIM_ADD_LC_REQ_UE_HD_FDD_MODE_PRESENT;
    }
    /* HD-FDD stop */
    /* SPR 23457 Fix Start */
    if(!p_uecc_ue_context->m.mocn_operator_id_already_configured)
    {
        if( p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                cell_index]->p_csc_init_setup_ind->bitmask
                & RRC_CSC_UECC_MOCN_OPERATOR_PRESENCE_FLAG)
        {
            p_rrc_uecc_llim_add_lc_req->bitmask |=
                UECC_LLIM_ADD_LC_REQ_MOCN_OPERATOR_ID_PRESENT;
            p_rrc_uecc_llim_add_lc_req->operator_id =
                p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                cell_index]->p_csc_init_setup_ind->
                operator_id[p_uecc_ue_context->selected_plmn_identity -  1];
            p_uecc_ue_context->m.mocn_operator_id_already_configured = 1;
        }
    }
    else
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_DETAILED,
                "[UECC_LLIM_ADD_LC_REQ] "
                "Either Operator Id is already applied on the UE or MOCN is disabled,"
                "No need to send operator id in ADD lC ");
    }
    /* SPR 23457 Fix End */

    /* Set UE Category If ICS is ongoing */
    /* 36321_CR0538 start */
    p_rrc_uecc_llim_add_lc_req->bitmask |= 
        UECC_LLIM_ADD_LC_REQ_UE_ACCESS_STRATUM_REL_PRESENT;
    p_rrc_uecc_llim_add_lc_req->access_stratum_release = p_uecc_ue_context->access_stratum_release;
    /* 36321_CR0538 stop */
    /* Set Bitmask */
    if (p_uecc_ue_context->p_curr_proc_data && //add for bugid 117724
		(UECC_ICS_PROC == p_uecc_ue_context->p_curr_proc_data->t))
    {
        p_rrc_uecc_llim_add_lc_req->bitmask |=
            UECC_LLIM_ADD_LC_REQ_UE_CATEGORY_PRESENT;

        /* Set Value */
        p_rrc_uecc_llim_add_lc_req->ue_category =
            p_uecc_ue_context->ue_category;
        /*SPR_18803_START*/
        p_rrc_uecc_llim_add_lc_req->bitmask |=
            UECC_LLIM_ADD_LC_REQ_RAT_1_SUPPORT_PRESENT;
        /* eMTC changes stop */

        if(FGI_BIT_2 & p_uecc_ue_context->feature_group_indicators)
        {
            p_rrc_uecc_llim_add_lc_req->rat_1_support = 1;
        }
        else
        {
            p_rrc_uecc_llim_add_lc_req->rat_1_support = 0;
        }
        /*SPR_18803_END*/
    }



    /* Fill srb2 */

    /* srb2 config to be sent during ICS 
     * (if only received from RRM in UE admission response) 
     * and not in ERAB setup response */
    if((!(strncmp_wrapper((const S8 *)(p_uecc_ue_context->uecc_fsm.proc_descriptor.
                            p_active_proc->s_id),((const S8 *)("UE_ICS_P")),
                        strlen_wrapper((const Char8 *)p_uecc_ue_context->uecc_fsm.proc_descriptor.
                            p_active_proc->s_id))
                    &&
                    p_uecc_ue_context->m.srb2_config_present)))

    {
        p_rrc_uecc_llim_add_lc_req->bitmask |=UECC_LLIM_ADD_LC_REQ_CREATE_SRB2_INFO_PRESENT;

        p_rrc_uecc_llim_add_lc_req->create_srb2_entity.lc_id = UECC_LTE_RRC_SRB2_LC_ID;

        p_rrc_uecc_llim_add_lc_req->create_srb2_entity.srb_config = p_uecc_ue_context->srb2_config;

        p_rrc_uecc_llim_add_lc_req->create_srb2_entity.bitmask |= UECC_LLIM_SRB_CONFIGURE_INTEGRITY_PROTECTION_PRESENT;
        p_rrc_uecc_llim_add_lc_req->create_srb2_entity.configure_integrity_protection = p_uecc_ue_context->configure_integrity_protection;

        p_rrc_uecc_llim_add_lc_req->create_srb2_entity.bitmask |= UECC_LLIM_SRB_CONFIGURE_CIPHERING_PRESENT;
        p_rrc_uecc_llim_add_lc_req->create_srb2_entity.configure_ciphering = p_uecc_ue_context->configure_ciphering;

        /*Setting the bitmask for AM config,as LLIM has to send this config data to lower layers, for LC creation */
        p_rrc_uecc_llim_add_lc_req->create_srb2_entity.srb_config.srb_am_config.bitmask |= RRM_SRB_AM_CONFIG_EXPLICIT_PRESENT;


    }

    /* Filling the UE-AMBR info*/
    if(p_uecc_ue_context->m.ue_agg_max_bit_rate_updated)
    {
#ifdef ENDC_ENABLED
        /*NR_DC Code Change Start*/
        /*check if any scg bearer is present on this UE*/
        if(RRC_TRUE == p_uecc_ue_context->is_sgnb_add_reqd )
        {
            /*Since ue_agg_max_bit_rate_sgnb has been allocated to the SgNB, MeNb
             * will be having the remaining Aggregated bitrate to be configured*/
            p_rrc_uecc_llim_add_lc_req->ue_ambr.ul_ambr =
                (U32)(p_uecc_ue_context->ue_aggregate_maximum_bitrate.uEaggregateMaximumBitRateUL -
                        p_uecc_ue_context->ue_agg_max_bit_rate_sgnb.ue_agg_max_bit_rate_ul);

            p_rrc_uecc_llim_add_lc_req->ue_ambr.dl_ambr = 
                (U32)(p_uecc_ue_context->ue_aggregate_maximum_bitrate.uEaggregateMaximumBitRateDL -
                        p_uecc_ue_context->ue_agg_max_bit_rate_sgnb.ue_agg_max_bit_rate_dl);
        }
        else
            /*NR_DC Code Change Stop*/
#endif
        {
            p_rrc_uecc_llim_add_lc_req->ue_ambr.ul_ambr = 
                (U32)p_uecc_ue_context->ue_aggregate_maximum_bitrate.uEaggregateMaximumBitRateUL;
            p_rrc_uecc_llim_add_lc_req->ue_ambr.dl_ambr = 
                (U32)p_uecc_ue_context->ue_aggregate_maximum_bitrate.uEaggregateMaximumBitRateDL;
        }

        p_rrc_uecc_llim_add_lc_req->bitmask |= UECC_LLIM_ADD_LC_REQ_UE_AMBR_PRESENT;
    }

    /* Fill DRB Config Info received from RRM */
#ifdef ENDC_ENABLED
    /*OPTION3X Changes Start*/
    if(p_uecc_ue_context->p_curr_proc_data && //add for bugid 117724
		(UECC_RRM_DC_BEARER_CHANGE_PROC == p_uecc_ue_context->p_curr_proc_data->t))
    {
        count = p_uecc_ue_context->p_curr_proc_data->u.
            rrm_dc_bearer_change_request_data.drb_to_modify_list.drb_count;
    }
    else
    {
        /*OPTION3X Changes Stop*/
#endif
        count = p_uecc_ue_context->p_curr_proc_data->u.
            erab_setup_request_data.erab_info_data.count; 
#ifdef ENDC_ENABLED
        /*OPTION3X Changes Start*/
    }
        /*OPTION3X Changes Stop*/
#endif

        for (drb_index = 0; drb_index < count; drb_index++)
        {
#ifdef ENDC_ENABLED
            /*OPTION3X Changes Start*/
            if(p_uecc_ue_context->p_curr_proc_data && //add for bugid 117724
				(UECC_RRM_DC_BEARER_CHANGE_PROC == p_uecc_ue_context->p_curr_proc_data->t))
            {
                erab_id = p_uecc_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data
                    .drb_to_modify_list.drb_config[drb_index].erab_id;
            }
            else
            {
                /*OPTION3X Changes Stop*/
#endif
                erab_id = p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data
                    .erab_info_data.erab_info[drb_index].erab_id;
#ifdef ENDC_ENABLED
                /*OPTION3X Changes Start*/
            }
            /*OPTION3X Changes Stop*/
#endif

            if (PNULL != p_uecc_ue_context->p_e_rab_list[erab_id])
            {
#ifdef ENDC_ENABLED
                /*NR_DC Code Changes Start*/
                /*check if the erab_id is SN_TERMINATED_SCG_BEARER */
                if((RRC_ONE == 
                            p_uecc_ue_context->p_e_rab_list[erab_id]->m.DC_BearerTypePresent) &&
                        (SN_TERMINATED_SCG_BEARER == 
                         p_uecc_ue_context->p_e_rab_list[erab_id]->dc_bearer_type))
                {
                    /*Do not add the drb info in llim reconfig request, as it will be sent to 
                     * the SgNB in SGNB_ADD_REQ*/
                    continue;
                }
                /*NR_DC Code Changes Stop*/
#endif
                /* disable masks by default */
                p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].bitmask = 0;

                /* drb_config */
                p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                    uecc_llim_drb_config.drb_config =
                    p_uecc_ue_context->p_e_rab_list[erab_id]->drb_config;


#ifdef ENDC_ENABLED
                /*OPTION3X Changes Start*/
                /*JIRA MENB-46 Fix start*/
                if(p_uecc_ue_context->p_curr_proc_data && //add for bugid 117724
					(UECC_RRM_DC_BEARER_CHANGE_PROC == p_uecc_ue_context->p_curr_proc_data->t &&
                        SN_TERMINATED_SPLIT_BEARER == 
                        p_uecc_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data.
                        drb_to_modify_list.drb_config[drb_index].dc_bearer_type ))
                {
                    /*need to update the new lc id in the llim add_lc_req*/
                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                        uecc_llim_drb_config.drb_config.logical_channel_identity = 
                        p_uecc_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data
                        .drb_to_modify_list.drb_config[drb_index].new_lc_id;

                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                        uecc_llim_drb_config.drb_config.bitmask |=
                        RRM_DRB_CONFIG_LOGICAL_CHANNEL_IDENTITY_PRESENT;

                    /*need to update the dc_bearer_type in the llim add_lc_req*/
                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                        uecc_llim_drb_config.drb_config.dc_bearer_type = 
                        p_uecc_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data
                        .drb_to_modify_list.drb_config[drb_index].dc_bearer_type;

                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                        uecc_llim_drb_config.drb_config.bitmask |=
                        RRM_DRB_CONFIG_DC_BEARER_TYPE_PRESENT;
                } 
                /*JIRA MENB-46 Fix stop*/
                /*OPTION3X Changes Stop*/
#endif

                /* clear bits as requested by LLIM team */
                p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                    uecc_llim_drb_config.drb_config.bitmask =
                    (rrc_bitmask_t)(p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            uecc_llim_drb_config.drb_config.bitmask &
                            ~RRM_DRB_CONFIG_RLC_CONFIG_UE_PRESENT);

                p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                    uecc_llim_drb_config.drb_config.bitmask =
                    (rrc_bitmask_t)(p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            uecc_llim_drb_config.drb_config.bitmask &
                            ~RRM_DRB_CONFIG_LOGICAL_CHANNEL_CONFIG_PRESENT);

                /* lipa start */

                /* drb_s1u_info */
                RRC_ASSERT(sizeof(rrc_gtp_teid_t) ==
                        sizeof(p_uecc_ue_context->p_e_rab_list[erab_id]->gTP_TEID.data));

                /* Set the Count of S1U Tunnel Info */
                if (p_uecc_ue_context->p_e_rab_list[erab_id]->m.Lipa_RabPresent)
                {
                    RRC_ASSERT(sizeof(rrc_gtp_teid_t) ==
                            sizeof(p_uecc_ue_context->p_e_rab_list[erab_id]->correlation_id->data));

                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].drb_s1u_info.
                        tunnel_list_count = NUM_TUNNELS_LIPA; 

                    /* Primary tunnel will be LGW tunnel */   
                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count]. 
                        drb_s1u_info.tunnel_info_list[0].sap_flag = SAP_FLAG_PRIMARY_TUNNEL;


                    rrc_unpack_U32(
                            &p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[0].teid_peer,
                            p_uecc_ue_context->p_e_rab_list[erab_id]->correlation_id->data);


                    /* Bitmasks not being set by UECC for S1U config 
                     * in ADD_LC_REQUEST being sent to LLIM. 
                     * LLIM not verifying the bitmask received from UECC */
                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                        drb_s1u_info.tunnel_info_list[0].bitmask |= 
                        RRC_UECC_LLIM_S1U_TUNNEL_INFO_TEID_PEER_PRESENT;  
                    /* SPR 15627 FIX Start*/
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_DETAILED,
                            "[UECC_LLIM_ADD_LC_REQ] "
                            "transportLayerAddress length =%d", p_uecc_ue_context->p_gb_context->lgw_data_length);
                    /* IPV6  or IPV4 */
                    if ((RRC_MAX_IP_ADDR_LEN_IPV6 
                                == p_uecc_ue_context->p_gb_context->lgw_data_length)
                            || (RRC_MAX_IP_ADDR_LEN 
                                == p_uecc_ue_context->p_gb_context->lgw_data_length)
                       )
                    {
                        p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[0].bitmask |=
                            RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;

                        p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[0].transport_addr.data_length =
                            (U8)(p_uecc_ue_context->p_gb_context->lgw_data_length);

                        l3_memcpy_wrapper(
                                p_rrc_uecc_llim_add_lc_req->
                                create_drb_entity[drb_count].drb_s1u_info.tunnel_info_list[0].transport_addr.data,
                                p_uecc_ue_context->p_gb_context->lgw_ip_addr,
                                p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                                drb_s1u_info.tunnel_info_list[0].transport_addr.data_length);

                    }
                    /*IPV4 and IPV6 160 bit*/
                    else if((RRC_MAX_IP_ADDR_LEN + RRC_MAX_IP_ADDR_LEN_IPV6)
                            == p_uecc_ue_context->p_gb_context->lgw_data_length)  
                    {
                        p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[0].bitmask |=
                            RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                        /* set IPV6 or IPV4 as per active mme info*/
                        /*
                         * if both IPv4 and IPv6 addresses are signaled, 
                         * then IPv4 address is contained in the first 32 bits
                         */
                        if(p_uecc_ue_context->p_gb_context->mme_ctx[p_uecc_ue_context->mme_id].connection_info.bitmask
                                & MME_COMM_INFO_IPV6_ADDR_PRESENT) /*IPV6 */
                        {
                            /*extract ipv6 from transportLayerAddress*/
                            p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                                drb_s1u_info.tunnel_info_list[0].transport_addr.data_length =
                                RRC_MAX_IP_ADDR_LEN_IPV6;

                            l3_memcpy_wrapper(
                                    p_rrc_uecc_llim_add_lc_req->
                                    create_drb_entity[drb_count].drb_s1u_info.tunnel_info_list[0]
                                    .transport_addr.data,
                                    (U8*)(p_uecc_ue_context->p_gb_context->lgw_ip_addr)+ RRC_MAX_IP_ADDR_LEN ,
                                    RRC_MAX_IP_ADDR_LEN_IPV6);
                        }
                        else /*fill IPV4*/
                        {
                            p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                                drb_s1u_info.tunnel_info_list[0].transport_addr.data_length =
                                RRC_MAX_IP_ADDR_LEN;

                            l3_memcpy_wrapper(
                                    p_rrc_uecc_llim_add_lc_req->
                                    create_drb_entity[drb_count].drb_s1u_info.tunnel_info_list[0]
                                    .transport_addr.data,
                                    p_uecc_ue_context->p_gb_context->lgw_ip_addr,
                                    RRC_MAX_IP_ADDR_LEN);
                        }

                    }
                    else
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_WARNING,
                                "[UECC_LLIM_ADD_LC_REQ] "
                                "transportLayerAddress has invalid size");
                        /*unset the bitmask */
                        p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[0].bitmask &=
                            ~RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                        //error
                    }
                    /* SPR 15627 FIX End*/
                    /* secondary tunnel will the one whose deatils are receievd from MME 
                     *  in ICS request */
                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count]. 
                        drb_s1u_info.tunnel_info_list[1].sap_flag = SAP_FLAG_SECONDARY_TUNNEL;

                    rrc_unpack_U32(
                            &p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[1].teid_peer,
                            p_uecc_ue_context->p_e_rab_list[erab_id]->gTP_TEID.data);

                    /* Bitmasks not being set by UECC for S1U config 
                     * in ADD_LC_REQUEST being sent to LLIM. 
                     * LLIM not verifying the bitmask received from UECC */
                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                        drb_s1u_info.tunnel_info_list[1].bitmask |= 
                        RRC_UECC_LLIM_S1U_TUNNEL_INFO_TEID_PEER_PRESENT;  
                    /* SPR 15627 FIX Start*/
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_DETAILED,
                            "[UECC_LLIM_ADD_LC_REQ] "
                            "transportLayerAddress length =%d",  p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.numbits);
                    /* IPV6  or IPV4 */
                    if ((RRC_MAX_IP_ADDR_LEN_IPV6*8 
                                ==  p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.numbits)
                            || (RRC_MAX_IP_ADDR_LEN*8 
                                ==  p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.numbits)
                       )
                    {
                        p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[1].bitmask |=
                            RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;

                        p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[1].transport_addr.data_length =
                            (U8)( p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.numbits/8);

                        l3_memcpy_wrapper(
                                p_rrc_uecc_llim_add_lc_req->
                                create_drb_entity[drb_count].drb_s1u_info.tunnel_info_list[1]
                                .transport_addr.data,
                                p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.data ,
                                p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                                drb_s1u_info.tunnel_info_list[1].transport_addr.data_length);

                    }
                    /*IPV4 and IPV6 160 bit*/
                    else if((RRC_MAX_IP_ADDR_LEN*8 + RRC_MAX_IP_ADDR_LEN_IPV6*8)
                            == p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.numbits)  
                    {
                        p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[1].bitmask |=
                            RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                        /* set IPV6 or IPV4 as per active mme info*/
                        /*
                         * if both IPv4 and IPv6 addresses are signaled, 
                         * then IPv4 address is contained in the first 32 bits
                         */
                        if(p_uecc_ue_context->p_gb_context->mme_ctx[p_uecc_ue_context->mme_id].connection_info.bitmask
                                & MME_COMM_INFO_IPV6_ADDR_PRESENT) /*IPV6 */
                        {
                            /*extract ipv6 from transportLayerAddress*/
                            p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                                drb_s1u_info.tunnel_info_list[1].transport_addr.data_length =
                                RRC_MAX_IP_ADDR_LEN_IPV6;

                            l3_memcpy_wrapper(
                                    p_rrc_uecc_llim_add_lc_req->
                                    create_drb_entity[drb_count].drb_s1u_info.tunnel_info_list[1]
                                    .transport_addr.data,
                                    (U8*)(p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.data)+ RRC_MAX_IP_ADDR_LEN ,
                                    RRC_MAX_IP_ADDR_LEN_IPV6);
                        }
                        else /*fill IPV4*/
                        {
                            p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                                drb_s1u_info.tunnel_info_list[1].transport_addr.data_length =
                                RRC_MAX_IP_ADDR_LEN;

                            l3_memcpy_wrapper(
                                    p_rrc_uecc_llim_add_lc_req->
                                    create_drb_entity[drb_count].drb_s1u_info.tunnel_info_list[1]
                                    .transport_addr.data,
                                    p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.data,
                                    RRC_MAX_IP_ADDR_LEN);
                        }

                    }
                    else
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_WARNING,
                                "[UECC_LLIM_ADD_LC_REQ] "
                                "transportLayerAddress has invalid size");
                        /*unset the bitmask */
                        p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[1].bitmask &=
                            ~RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                        //error
                    }
                    /* SPR 15627 FIX End*/
                }
                else /* If LIPA RAB is not Present */
                { 
                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].drb_s1u_info.
                        tunnel_list_count = 1;


                    /* Set SAP Flags */
                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                        drb_s1u_info.tunnel_info_list[0].sap_flag =
                        p_uecc_ue_context->p_e_rab_list[erab_id]->drb_config.s1u_config.sap_flags;


                    rrc_unpack_U32(
                            &p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[0].teid_peer,
                            p_uecc_ue_context->p_e_rab_list[erab_id]->gTP_TEID.data);

                    /* Bitmasks not being set by UECC for S1U config 
                     * in ADD_LC_REQUEST being sent to LLIM. 
                     * LLIM not verifying the bitmask received from UECC */
                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                        drb_s1u_info.tunnel_info_list[0].bitmask |= 
                        RRC_UECC_LLIM_S1U_TUNNEL_INFO_TEID_PEER_PRESENT;  

                    /* SPR 15627 FIX Start*/

                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_DETAILED,
                            "[UECC_LLIM_ADD_LC_REQ] "
                            "transportLayerAddress length =%d", p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.numbits);

                    /* IPV6  or IPV4 */
                    if ((RRC_MAX_IP_ADDR_LEN_IPV6*8 
                                == p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.numbits)
                            || (RRC_MAX_IP_ADDR_LEN*8 
                                == p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.numbits)
                       )
                    {
                        p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[0].bitmask |= 
                            RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;  

                        p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[0].transport_addr.data_length =
                            (U8)(p_uecc_ue_context->p_e_rab_list[erab_id]->
                                    transportLayerAddress.numbits/8);

                        l3_memcpy_wrapper(
                                p_rrc_uecc_llim_add_lc_req->
                                create_drb_entity[drb_count].drb_s1u_info.tunnel_info_list[0]
                                .transport_addr.data,
                                p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.data,
                                p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                                drb_s1u_info.tunnel_info_list[0].transport_addr.data_length);

                    }
                    /*IPV4 and IPV6 160 bit*/
                    else if((RRC_MAX_IP_ADDR_LEN*8 + RRC_MAX_IP_ADDR_LEN_IPV6*8)
                            == p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.numbits)  
                    {
                        p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[0].bitmask |=
                            RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                        /* set IPV6 or IPV4 as per active mme info*/
                        /*
                         * if both IPv4 and IPv6 addresses are signaled, 
                         * then IPv4 address is contained in the first 32 bits
                         */
                        if(p_uecc_ue_context->p_gb_context->mme_ctx[p_uecc_ue_context->mme_id].connection_info.bitmask
                                & MME_COMM_INFO_IPV6_ADDR_PRESENT) /*IPV6 */
                        {
                            /*extract ipv6 from transportLayerAddress*/
                            p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                                drb_s1u_info.tunnel_info_list[0].transport_addr.data_length =
                                RRC_MAX_IP_ADDR_LEN_IPV6;

                            l3_memcpy_wrapper(
                                    p_rrc_uecc_llim_add_lc_req->
                                    create_drb_entity[drb_count].drb_s1u_info.tunnel_info_list[0]
                                    .transport_addr.data,
                                    (U8*)(p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.data)+ RRC_MAX_IP_ADDR_LEN ,
                                    RRC_MAX_IP_ADDR_LEN_IPV6);
                        }
                        else /*fill IPV4*/
                        {
                            p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                                drb_s1u_info.tunnel_info_list[0].transport_addr.data_length =
                                RRC_MAX_IP_ADDR_LEN;

                            l3_memcpy_wrapper(
                                    p_rrc_uecc_llim_add_lc_req->
                                    create_drb_entity[drb_count].drb_s1u_info.tunnel_info_list[0]
                                    .transport_addr.data,
                                    p_uecc_ue_context->p_e_rab_list[erab_id]->transportLayerAddress.data,
                                    RRC_MAX_IP_ADDR_LEN);
                        }

                    }
                    else
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_WARNING,
                                "[UECC_LLIM_ADD_LC_REQ] "
                                "transportLayerAddress has invalid size");
                        /*unset the bitmask */
                        p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                            drb_s1u_info.tunnel_info_list[0].bitmask &=
                            ~RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                        //error
                    }
                    /* SPR 15627 FIX End*/


                }
                /* lipa end */
                /* configure_ciphering */
                p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].bitmask |=
                    UECC_LLIM_DRB_CONFIGURE_CIPHERING_PRESENT;

                p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                    configure_ciphering =
                    p_uecc_ue_context->configure_ciphering_user_plane;

                /* Filling QOS INFO*/
                /* Setting the Qos bitmask value as received Qci value is mandatory in
                 * e_RABlevelQoSParameters*/
                p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                    uecc_llim_drb_config.bitmask |= 
                    UECC_LLIM_DRB_CONFIG_QOS_INFO_PRESENT;

                p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                    uecc_llim_drb_config.qos_info.qci = p_uecc_ue_context->
                    p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI;

                if (p_uecc_ue_context->p_e_rab_list[erab_id]->
                        e_RABlevelQoSParameters.m.gbrQosInformationPresent) 
                {
                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                        uecc_llim_drb_config.qos_info.bitmask |= RRC_GBR_QOS_INFO_PRESENT;

                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                        uecc_llim_drb_config.qos_info.gbr_qos_info.dl_mbr = 
                        (U32)p_uecc_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.
                        gbrQosInformation.e_RAB_MaximumBitrateDL;

                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                        uecc_llim_drb_config.qos_info.gbr_qos_info.ul_mbr = 
                        (U32)p_uecc_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.
                        gbrQosInformation.e_RAB_MaximumBitrateUL;

                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                        uecc_llim_drb_config.qos_info.gbr_qos_info.dl_gbr = 
                        (U32)p_uecc_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.
                        gbrQosInformation.e_RAB_GuaranteedBitrateDL;

                    p_rrc_uecc_llim_add_lc_req->create_drb_entity[drb_count].
                        uecc_llim_drb_config.qos_info.gbr_qos_info.ul_gbr = 
                        (U32)p_uecc_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.
                        gbrQosInformation.e_RAB_GuaranteedBitrateUL;
                }
            /*NR_DC Code Changes Start*/
            drb_count++;
            /*NR_DC Code Changes Stop*/
            }
        }

    /*NR_DC Code Changes Start*/
    /*check if there is any drb_count, if yes set the bitmask*/
    if(drb_count > RRC_NULL)
    {
        p_rrc_uecc_llim_add_lc_req->create_drb_entity_counter = drb_count;

        p_rrc_uecc_llim_add_lc_req->bitmask |=
            UECC_LLIM_ADD_LC_REQ_CREATE_DRB_INFO_PRESENT;
    }
    else
    {
        p_rrc_uecc_llim_add_lc_req->create_drb_entity_counter = RRC_NULL;
    }
    /*NR_DC Code Changes Stop*/

    /* mac_config and meas_config */
    /* Check if Current Procedure is ICS */
    if (p_uecc_ue_context->p_curr_proc_data && //add for bugid 117724
		(UECC_ICS_PROC == p_uecc_ue_context->p_curr_proc_data->t))
    {
        /* Send new mac_config to LLIM from the UE Context */
        if (p_uecc_ue_context->m.mac_config_updated)
        {
            p_rrc_uecc_llim_add_lc_req->bitmask |=
                UECC_LLIM_ADD_LC_REQ_NEW_MAC_CONFIG_PRESENT;
            p_rrc_uecc_llim_add_lc_req->mac_config[UECC_LLIM_ADD_LC_REQ_NEW_MAC_CONFIG] = 
                p_uecc_ue_context->mac_config;
        }
        /* Send new meas_config to LLIM from the UE Context */
        if (p_uecc_ue_context->m.meas_config_updated)
        {
            p_rrc_uecc_llim_add_lc_req->bitmask |=
                UECC_LLIM_ADD_LC_REQ_NEW_MEAS_CONFIG_PRESENT;
            p_rrc_uecc_llim_add_lc_req->meas_config[UECC_LLIM_ADD_LC_REQ_NEW_MEAS_CONFIG] = 
                *p_uecc_ue_context->p_meas_config;
        }
    }
#ifdef ENDC_ENABLED
    else if(p_uecc_ue_context->p_curr_proc_data && //add for bugid 117724
    		(UECC_RRM_DC_BEARER_CHANGE_PROC == 
            p_uecc_ue_context->p_curr_proc_data->t))
    {
        /* If new meas_config is received from RRM 
         * Send new as well as old meas_config to LLIM */
        if ( p_uecc_ue_context->p_curr_proc_data->u.
            rrm_dc_bearer_change_request_data.m.endc_meas_config_updated )
        {
            p_rrc_uecc_llim_add_lc_req->bitmask |=
                UECC_LLIM_ADD_LC_REQ_OLD_MEAS_CONFIG_PRESENT;

            p_rrc_uecc_llim_add_lc_req->bitmask |=
                UECC_LLIM_ADD_LC_REQ_NEW_MEAS_CONFIG_PRESENT;

            p_rrc_uecc_llim_add_lc_req->meas_config[UECC_LLIM_ADD_LC_REQ_NEW_MEAS_CONFIG].
                bitmask |=
                UE_ADM_MEAS_OBJECT_TO_REMOVE_LIST_PRESENT;

            p_rrc_uecc_llim_add_lc_req->meas_config[UECC_LLIM_ADD_LC_REQ_NEW_MEAS_CONFIG].
                meas_object_to_remove_list = 
                p_uecc_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data.
                endc_meas_config.meas_object_to_remove_list;

            p_rrc_uecc_llim_add_lc_req->meas_config[UECC_LLIM_ADD_LC_REQ_NEW_MEAS_CONFIG].
                bitmask |=
                UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT;

            p_rrc_uecc_llim_add_lc_req->meas_config[UECC_LLIM_ADD_LC_REQ_NEW_MEAS_CONFIG].
                report_config_to_remove_list = 
                p_uecc_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data.
                endc_meas_config.report_config_to_remove_list;

            p_rrc_uecc_llim_add_lc_req->meas_config[UECC_LLIM_ADD_LC_REQ_NEW_MEAS_CONFIG].
                bitmask |=
                UE_ADM_MEAS_ID_TO_REMOVE_LIST_PRESENT;

            p_rrc_uecc_llim_add_lc_req->meas_config[UECC_LLIM_ADD_LC_REQ_NEW_MEAS_CONFIG].
                meas_id_to_remove_list = 
                p_uecc_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data.
                endc_meas_config.meas_id_to_remove_list;

            p_rrc_uecc_llim_add_lc_req->meas_config[UECC_LLIM_ADD_LC_REQ_NEW_MEAS_CONFIG].
                bitmask |=
                UE_ADM_MEAS_GAP_CONFIG_PRESENT;

            p_rrc_uecc_llim_add_lc_req->meas_config[UECC_LLIM_ADD_LC_REQ_NEW_MEAS_CONFIG].
                meas_gap_config = 
                p_uecc_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data.
                endc_meas_config.meas_gap_config;
        }
    }
#endif
    else    /* Current Procedure is ERAB SETUP */
    {
        /* If new mac_config is received from RRM 
         * Send new as well as old mac_config to LLIM */
        if (p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                erab_op_params.m.mac_config_present)
        {
            p_rrc_uecc_llim_add_lc_req->bitmask |=
                UECC_LLIM_ADD_LC_REQ_OLD_MAC_CONFIG_PRESENT;
            p_rrc_uecc_llim_add_lc_req->mac_config[UECC_LLIM_ADD_LC_REQ_OLD_MAC_CONFIG] = 
                p_uecc_ue_context->mac_config;

            p_rrc_uecc_llim_add_lc_req->bitmask |=
                UECC_LLIM_ADD_LC_REQ_NEW_MAC_CONFIG_PRESENT;
            p_rrc_uecc_llim_add_lc_req->mac_config[UECC_LLIM_ADD_LC_REQ_NEW_MAC_CONFIG] = 
                p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.erab_op_params.
                mac_config;
        }

        /* If new meas_config is received from RRM 
         * Send new as well as old mac_config to LLIM */
        if (p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                erab_op_params.m.meas_config_present)
        {
            p_rrc_uecc_llim_add_lc_req->bitmask |=
                UECC_LLIM_ADD_LC_REQ_OLD_MEAS_CONFIG_PRESENT;
            p_rrc_uecc_llim_add_lc_req->meas_config[UECC_LLIM_ADD_LC_REQ_OLD_MEAS_CONFIG] = 
                *p_uecc_ue_context->p_meas_config;

            p_rrc_uecc_llim_add_lc_req->bitmask |=
                UECC_LLIM_ADD_LC_REQ_NEW_MEAS_CONFIG_PRESENT;
            p_rrc_uecc_llim_add_lc_req->meas_config[UECC_LLIM_ADD_LC_REQ_NEW_MEAS_CONFIG] = 
                p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.erab_op_params.
                meas_config;
        }
    }

    /* Fill PHY Config data fields */
    /*SPR 21043 Fix Start*/
    if (p_uecc_ue_context->p_curr_proc_data && //add for bugid 117724
    	(UECC_ICS_PROC == p_uecc_ue_context->p_curr_proc_data->t))
    {
        /*SPR 21043 Fix Stop*/

        if (p_uecc_ue_context->m.physical_config_dedicated_updated)
        {
            p_rrc_uecc_llim_add_lc_req->bitmask |=
                UECC_LLIM_ADD_LC_REQ_PHY_CONFIG_DEDICATED_PRESENT;

            p_rrc_uecc_llim_add_lc_req->physical_config_dedicated =
                p_uecc_ue_context->physical_config_dedicated;

            if((RRC_PHY_ANTENNA_INFORMATION_PRESENT &
                        p_uecc_ue_context->physical_config_dedicated.bitmask)
                    && (!(RRC_PHY_ANTENNA_INFORMATION_EXPLICIT_VALUE_PRESENT &
                            p_uecc_ue_context->physical_config_dedicated
                            .antenna_information.bitmask)))
            {   /* Default values shall be used */
                p_rrc_uecc_llim_add_lc_req->physical_config_dedicated
                    .antenna_information
                    = physical_config_dedicated_default.antenna_information;
                p_rrc_uecc_llim_add_lc_req->physical_config_dedicated
                    .antenna_information.bitmask |=
                    RRC_PHY_ANTENNA_INFORMATION_EXPLICIT_VALUE_PRESENT;
            }
        }
        /*SPR 21043 Fix Start*/
    }
    else
    {
        if (p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                erab_op_params.m.physical_config_dedicated_present)
        {
            p_rrc_uecc_llim_add_lc_req->bitmask |=
                UECC_LLIM_ADD_LC_REQ_PHY_CONFIG_DEDICATED_PRESENT;
            p_rrc_uecc_llim_add_lc_req->physical_config_dedicated =
                p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                erab_op_params.physical_config_dedicated;

            if((RRC_PHY_ANTENNA_INFORMATION_PRESENT &
                        p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                        erab_op_params.physical_config_dedicated.bitmask)
                    && (!(RRC_PHY_ANTENNA_INFORMATION_EXPLICIT_VALUE_PRESENT &
                            p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.erab_op_params.
                            physical_config_dedicated.antenna_information.bitmask)))
            {
                p_rrc_uecc_llim_add_lc_req->physical_config_dedicated
                    .antenna_information
                    = physical_config_dedicated_default.antenna_information;
                p_rrc_uecc_llim_add_lc_req->physical_config_dedicated
                    .antenna_information.bitmask |=
                    RRC_PHY_ANTENNA_INFORMATION_EXPLICIT_VALUE_PRESENT;
            }
        }
    }
    /*SPR 21043 Fix Stop*/


    /* SPS Start */
    if (p_uecc_ue_context->m.sps_config_updated)
    {
        if(!p_uecc_ue_context->p_sps_config)
        {
            p_uecc_ue_context->m.sps_config_updated = 0;
        }
        else
        {
            p_rrc_uecc_llim_add_lc_req->bitmask |= 
                UECC_LLIM_ADD_LC_REQ_SPS_CONFIG_PRESENT;

            uecc_llim_fill_sps_config(
                    p_uecc_ue_context->p_sps_config,
                    &p_rrc_uecc_llim_add_lc_req->sps_config);
        }
    }

    /* SPS Stop */


    /*SPR_19066_START*/
    if(p_uecc_ue_context->m.ue_inactive_time_updated)
    { 

        p_rrc_uecc_llim_add_lc_req->bitmask |= UECC_LLIM_ADD_LC_REQ_UE_INACTIVITY_TIMER_PRESENT;
        p_rrc_uecc_llim_add_lc_req->ue_inactivity_timer.ue_inactive_time_config =
            p_uecc_ue_context->ue_inactive_time;
    }
    /*SPR_19066_END*/
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_csfb_parameters_response_CDMA2000
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *                  rrc_rrm_csfb_parameters_resp_cdma2000_t 
 *                  p_rrc_rrm_csfb_parameters_resp_cdma2000
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds and sends UECC_LLIM_SRB_DATA_REQ message
 *                  with csfbParametersResponseCDMA2000 to LLIM
 *
 *   RETURNS      : RRC_FAILURE/RRC_SUCCESS
 *
 * ******************************************************************************/

rrc_return_et uecc_llim_build_and_send_csfb_parameters_response_CDMA2000(
        uecc_ue_context_t*  p_uecc_ue_context,
        rrc_rrm_csfb_parameters_resp_cdma2000_t* 
        p_rrc_rrm_csfb_parameters_resp_cdma2000
        )
{
    OSCTXT                                  asn1_ctx;
    DL_DCCH_Message                         dl_dcch_msg;
    CSFBParametersResponseCDMA2000*         p_csfb_param_res_cdma2000 = PNULL;
    CSFBParametersResponseCDMA2000_r8_IEs*  p_r8 = PNULL;
    rrc_return_et                           result = RRC_FAILURE;
    OSDynOctStr*                            p_octet_data = PNULL;
    rrc_uecc_llim_srb_data_req_t*           p_srb_data_req = PNULL;
    U8  msg[sizeof(rrc_uecc_llim_srb_data_req_t)+UECC_MAX_ASN1_BUF_LEN];


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    p_srb_data_req = (rrc_uecc_llim_srb_data_req_t*)msg;

    memset_wrapper(&dl_dcch_msg, 0, sizeof(DL_DCCH_Message));

    /* Init ASN1 context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[CSFBParametersResponseCDMA2000] "
                "ASN1 context initialization failed.");
        return RRC_FAILURE;
    }

    do
    {
        /* Fill the values in the ASN structures that shall be encoded by
         * ASN Encoder */
        /* Downlink DCCH message type */
        dl_dcch_msg.message.t = T_DL_DCCH_MessageType_c1;
        dl_dcch_msg.message.u.c1 =
            rtxMemAllocType(&asn1_ctx, DL_DCCH_MessageType_c1);
        if (PNULL == dl_dcch_msg.message.u.c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[CSFBParametersResponseCDMA2000] ASN malloc failed.");
            break;
        }

        /* Choose CSFBParametersResponseCDMA2000 */
        dl_dcch_msg.message.u.c1->t =
            T_DL_DCCH_MessageType_c1_csfbParametersResponseCDMA2000;

        dl_dcch_msg.message.u.c1->u.csfbParametersResponseCDMA2000 =
            rtxMemAllocType(&asn1_ctx, CSFBParametersResponseCDMA2000);
        if (PNULL == dl_dcch_msg.message.u.c1->u.csfbParametersResponseCDMA2000)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[CSFBParametersResponseCDMA2000] ASN malloc failed.");
            break;
        }

        p_csfb_param_res_cdma2000 =
            dl_dcch_msg.message.u.c1->u.csfbParametersResponseCDMA2000;

        /* transaction id */
        p_csfb_param_res_cdma2000->rrc_TransactionIdentifier =
            (RRC_TransactionIdentifier) (uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context) &
                    UECC_LTE_RRC_TRANSACTION_ID_MASK);

        p_csfb_param_res_cdma2000->criticalExtensions.t =
            T_CSFBParametersResponseCDMA2000_criticalExtensions_csfbParametersResponseCDMA2000_r8;

        p_r8 = rtxMemAllocType(&asn1_ctx, CSFBParametersResponseCDMA2000_r8_IEs);
        if (PNULL == p_r8)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[CSFBParametersResponseCDMA2000] ASN malloc failed.");
            break;
        }

        p_csfb_param_res_cdma2000->criticalExtensions.u.csfbParametersResponseCDMA2000_r8 
            = p_r8;

        /* CSFB Parameters Response CDMA2000 r8 IEs*/
        asn1Init_CSFBParametersResponseCDMA2000_r8_IEs(p_r8);

        p_octet_data = (OSDynOctStr *)rrc_mem_get(sizeof(OSDynOctStr));
        if(PNULL == p_octet_data)
        {
            RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                    p_uecc_ue_context->p_gb_context->facility_name,
                    RRC_FATAL,
                    "Memory allocation to p_octet_data failed");
            result = RRC_FAILURE;
            break;
        }
        memset_wrapper(p_octet_data, 0 , sizeof(OSDynOctStr));

        p_octet_data->data = (OSOCTET *)rrc_mem_get(MOBILITY_PARAMS_MAX_OCTETS);
        if(p_octet_data->data == NULL)
        {
            RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                    p_uecc_ue_context->p_gb_context->facility_name,
                    RRC_INFO,
                    "Memory allocation to p_octet_data failed");
            /* coverity_fix_63288_start */
            rrc_mem_free(p_octet_data);
            p_octet_data = PNULL;
            /* coverity_fix_63288_stop */
            result = RRC_FAILURE;
            break;
        }
        else
        {
            memset_wrapper ( (void *)p_octet_data->data, 0, MOBILITY_PARAMS_MAX_OCTETS );
            rrc_form_mob_params_to_octet_string(
                    p_uecc_ue_context,
                    p_octet_data,
                    &p_rrc_rrm_csfb_parameters_resp_cdma2000->\
                    mobility_parameters,
                    &p_rrc_rrm_csfb_parameters_resp_cdma2000->\
                    add_mobility_parameters);

            p_r8->mobilityParameters.numocts = p_octet_data->numocts;

            RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                    p_uecc_ue_context->p_gb_context->facility_name,
                    RRC_INFO,
                    "After packing p_octet_data->numocts = [%d]",p_octet_data->numocts);

            /* Copying Octet String in ASN1 structure to send on Transport layer */

            p_r8->mobilityParameters.data =
                (OSOCTET*)rtxMemAlloc(&asn1_ctx,p_octet_data->numocts);

            if (PNULL == p_r8->mobilityParameters.data)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR, " mobilityParameters ASN malloc failed.");
                result = RRC_FAILURE;
                break;
            }

            memset_wrapper(((void *)p_r8->mobilityParameters.data),
                    RRC_NULL,
                    p_octet_data->numocts);

            l3_memcpy_wrapper(((void *)p_r8->mobilityParameters.data),
                    p_octet_data->data,
                    p_octet_data->numocts);

            if (PNULL != p_octet_data->data)
            {
                rrc_mem_free((void *)p_octet_data->data);
                p_octet_data->data = PNULL;
            }

            if (PNULL != p_octet_data)
            {
                rrc_mem_free(p_octet_data);
                p_octet_data = PNULL;
            }
        }

        /* Fill p_r8 data from csc_context in UE Global Context */
        rrc_pack_U32((void*)p_r8->rand_.data,&(p_uecc_ue_context->p_gb_context->\
                    p_p_csc_context[p_uecc_ue_context->cell_index]->\
                    p_csc_init_setup_ind->cdma2000_rand));

        p_r8->rand_.numbits = (8*sizeof(U32)); /*cdma2000_rand is of size 32 bits*/

        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_DETAILED, "p_r8->rand.numbits = %d\n", p_r8->rand_.numbits);


        /* Do ASN1 encode */

        pu_setBuffer(&asn1_ctx, p_srb_data_req->data_buffer,
                UECC_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);


        if (RT_OK != asn1PE_DL_DCCH_Message(&asn1_ctx, &dl_dcch_msg))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,                    
                    RRC_ERROR,
                    "[CSFBParametersResponseCDMA2000] ASN1 encoding failed.");
            break;
        }
        else
        {
            rrc_asn1PrtToStr_DL_DCCH_Message(RRC_ASN,"DL_DCCH_Message",
                    &dl_dcch_msg, "CSFBParametersResponseCDMA2000",
                    p_srb_data_req->data_buffer, (U16)pe_GetMsgLen(&asn1_ctx));
        }

        p_srb_data_req->data_buffer_length = (rrc_counter_t)pe_GetMsgLen(&asn1_ctx);
        p_srb_data_req->transaction_id =
            uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
        p_srb_data_req->ue_index = p_uecc_ue_context->ue_index;
        p_srb_data_req->cell_index = p_uecc_ue_context->cell_index;
        p_srb_data_req->lc_id = UECC_LTE_RRC_SRB1_LC_ID;
        p_srb_data_req->service_requested =
            UECC_LLIM_SRB_SERVICEREQUESTED_DELIVERY_STATUS_TRUE;

        /* TRACE_changes_start */
        /* SPR 16113 Start */
        uecc_rrc_ue_assoc_msg_max_trace_handler(p_uecc_ue_context, p_srb_data_req->data_buffer, 
                p_srb_data_req->data_buffer_length, "CSFB Parameters Response CDMA2000", RRC_DL_DCCH);
        /* SPR 16113 Stop */
        /* TRACE_changes_start */

        result = uecc_rrc_send_internal_msg(
                RRC_LLIM_MODULE_ID,
                UECC_LLIM_SRB_DATA_REQ,
                (U16)( p_srb_data_req->data_buffer_length+
                    sizeof(rrc_uecc_llim_srb_data_req_t)),
                msg);

        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "RRC_MSG: CSFBParametersResponseCDMA2000 %s",
                change_data_to_str(p_srb_data_req->data_buffer_length, p_srb_data_req->data_buffer));

    }
    while(0);

    /* coverity_fix_63288_&_63289_start */
    if (PNULL != p_octet_data && PNULL != p_octet_data->data)
    {
        rrc_mem_free((void *)p_octet_data->data);
        p_octet_data->data = PNULL;
        rrc_mem_free(p_octet_data);
    }
    /* coverity_fix_63288_&_63289_stop */

    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************************
 *   FUNCTION NAME: rrc_form_mob_params_for_PZIDHystParameter
 *
 *   DESCRIPTION:
 *       This function forms an octet string of mobility parameters for PZIDHystParameter 
 *       from parameter transfer response from RRM.
 *
 *   RETURNS:
 *       void
 *
 *******************************************************************************************/
/* Bug 12190 Fix Start */
void  rrc_form_mob_params_for_PZIDHystParameter(
        uecc_ue_context_t*  p_uecc_ue_context,
        U8 ***p_buffer,
        U8 **bitPosition,
        mobility_parameters_t* p_mobility_parameters_fill
        )
{
    U8 *bitPos = PNULL;
    U8 **p_buf = PNULL;

    bitPos = (*bitPosition);
    p_buf = (*p_buffer);
    /* Bug 12190 Fix Stop */

    /*PZ_HYST_PARAMETERS_INCLUDED_PRESENT */
    SETNBIT (p_buf, bitPos, RRC_TRUE,
            CSFB_BITMASK_PRESENT_WIDTH, p_uecc_ue_context);

    /*PZ_HYST_ENABLED_PRESENT Parameter */
    if (p_mobility_parameters_fill->pz_hyst_parameters_included.bitmask
            & PZ_HYST_ENABLD_PRESENT)
    {
        /*PZ_HYST_ENABLED */
        SETNBIT (p_buf, bitPos,
                p_mobility_parameters_fill->pz_hyst_parameters_included.
                pz_hyst_enabled, CSFB_PARAM_1XRTT_PZ_HYST_ENABLED_NBITS,
                p_uecc_ue_context);
    }

    /*PZ_HYST_INFO_INCL Parameter */
    if (p_mobility_parameters_fill->pz_hyst_parameters_included.bitmask
            & PZ_HYST_INFO_INCL_PRESENT)
    {
        /*PZ_HYST_INFO_INCL */
        SETNBIT (p_buf, bitPos,
                p_mobility_parameters_fill->pz_hyst_parameters_included.
                pz_hyst_info_incl, CSFB_PARAM_1XRTT_PZ_HYST_INFO_INCL_NBITS,
                p_uecc_ue_context);
    }


    /*PZ_HYST_LIST_LEN Parameter */
    if (p_mobility_parameters_fill->pz_hyst_parameters_included.bitmask
            & PZ_HYST_LIST_LEN_PRESENT)
    {
        /*PZ_HYST_LIST_LEN */
        SETNBIT (p_buf, bitPos,
                p_mobility_parameters_fill->pz_hyst_parameters_included.
                pz_hyst_list_len, CSFB_PARAM_1XRTT_PZ_HYST_LIST_LEN_NBITS,
                p_uecc_ue_context);
    }

    /*PZ_HYST_ACT_TIMER */
    if(p_mobility_parameters_fill->pz_hyst_parameters_included.bitmask\
            & PZ_HYST_ACT_TIMER_PRESENT)
    {
        /*PZ_HYST_ACT_TIMER*/
        SETNBIT(p_buf,bitPos,
                p_mobility_parameters_fill->\
                pz_hyst_parameters_included.pz_hyst_act_timer,
                CSFB_PARAM_1XRTT_PZ_HYST_ACT_TIMER_NBITS,
                p_uecc_ue_context);
    }
    /*PZ_HYST_TIMER_MUL Parameters*/
    if(p_mobility_parameters_fill->pz_hyst_parameters_included.bitmask\
            & PZ_HYST_TIMER_MUL_PRESENT)
    {
        /*PZ_HYST_TIMER_MUL*/
        SETNBIT(p_buf,bitPos,
                p_mobility_parameters_fill->
                pz_hyst_parameters_included.pz_hyst_timer_mul,
                CSFB_PARAM_1XRTT_PZ_HYST_TIMER_MUL_NBITS,
                p_uecc_ue_context);
    }

    /*PZ_HYST_TIMER_EXP Parameter*/
    if(p_mobility_parameters_fill->pz_hyst_parameters_included.bitmask\
            & PZ_HYST_TIMER_EXP_PRESENT)
    {
        /*PZ_HYST_TIMER_EXP*/
        SETNBIT(p_buf,bitPos,
                p_mobility_parameters_fill->
                pz_hyst_parameters_included.pz_hyst_timer_exp,
                CSFB_PARAM_1XRTT_PZ_HYST_TIMER_EXP_NBITS,
                p_uecc_ue_context);
    }

}
/******************************************************************************
 *   FUNCTION NAME: rrc_form_mob_params_to_octet_string_part1
 *
 *   DESCRIPTION:
 *
 *   RETURNS:
 *       void
 *
 ******************************************************************************/
/* Bug 12190 Fix Start */
static void rrc_form_mob_params_to_octet_string_part1(
        uecc_ue_context_t*  p_uecc_ue_context,
        U8 ***p_buffer,
        U8 **bitPosition,
        mobility_parameters_t* p_mobility_parameters_fill
        )
{
    U8 *bitPos = PNULL;
    U8  **p_buf = PNULL;

    bitPos = (*bitPosition);
    p_buf = (*p_buffer);
    /* Bug 12190 Fix Stop */

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /*P_REV parameter*/
    if(p_mobility_parameters_fill->bitmask & P_REV_INCLUDED_PRESENT)
    {
        /*P_REVIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE,
                CSFB_BITMASK_PRESENT_WIDTH,
                p_uecc_ue_context);
        /*P_REV*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->p_rev,
                CSFB_PARAM_1XRTT_P_REV_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*P_REVIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE,
                CSFB_BITMASK_PRESENT_WIDTH,
                p_uecc_ue_context);
    }

    /*MIN_P_REVIncluded Parameter*/
    if(p_mobility_parameters_fill->bitmask & MIN_P_REV_INCLUDED_PRESENT)
    {
        /*MIN_P_REVIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE,
                CSFB_BITMASK_PRESENT_WIDTH,
                p_uecc_ue_context);
        /*MIN_P_REV*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->min_p_rev,
                CSFB_PARAM_1XRTT_MIN_P_REV_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*MIN_P_REVIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE,
                CSFB_BITMASK_PRESENT_WIDTH,
                p_uecc_ue_context);
    }

    /*NEG_SLOT_CYCLE_INDEX_SUP Parameter*/
    if(p_mobility_parameters_fill->bitmask & NEG_SLOT_CYCLE_INDEX_SUP_INCLUDED_PRESENT)
    {
        /*NEG_SLOT_CYCLE_INDEX_SUPIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE,
                CSFB_BITMASK_PRESENT_WIDTH,
                p_uecc_ue_context);
        /*NEG_SLOT_CYCLE_INDEX_SUP*/

        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->neg_slot_cycle_index_sup,
                CSFB_PARAM_1XRTT_NEG_SLOT_CYCLE_INDEX_SUP_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*NEG_SLOT_CYCLE_INDEX_SUPIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*ENCRYPT_MODE Parameters*/
    if(p_mobility_parameters_fill->bitmask & ENCRYPT_MODE_INCLUDED_PRESENT)
    {
        /*ENCRYPT_MODEIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*ENCRYPT_MODE*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->encrypt_mode,
                CSFB_PARAM_1XRTT_ENCRYPT_MODE_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*ENCRYPT_MODEIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*ENC_SUPPORTED Parameters*/
    if(p_mobility_parameters_fill->bitmask & ENC_SUPPORTED_INCLUDED_PRESENT)
    {
        /*ENC_SUPPORTEDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*ENC_SUPPORTED*/
        SETNBIT(p_buf, bitPos,p_mobility_parameters_fill->enc_supported,
                CSFB_PARAM_1XRTT_ENC_SUPPORTED_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*ENC_SUPPORTED*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*SIG_ENCRYPT_SUP Parameters*/
    if(p_mobility_parameters_fill->bitmask & SIG_ENCRYPT_SUP_INCLUDED_PRESENT)
    {
        /*SIG_ENCRYPT_SUPIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*SIG_ENCRYPT_SUP*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->sig_encrypt_sup,
                CSFB_PARAM_1XRTT_SIG_ENCRYPT_SUP_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*SIG_ENCRYPT_SUPIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*MSG_INTEGRITY_SUP Parameters*/
    if(p_mobility_parameters_fill->bitmask & MSG_INTEGRITY_SUP_INCLUDED_PRESENT)
    {
        /*MSG_INTEGRITY_SUPIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*MSG_INTEGRITY_SUP*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->msg_integrity_sup,
                CSFB_PARAM_1XRTT_MSG_INTEGRITY_SUP_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*MSG_INTEGRITY_SUPIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }
    /*SIG_INTEGRITY_SUP_INCL Parameters*/
    if(p_mobility_parameters_fill->bitmask & SIG_INTEGRITY_SUP_INCL_INCLUDED_PRESENT)
    {
        /*SIG_INTEGRITY_SUP_INCLIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*SIG_INTEGRITY_SUP_INCL*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->sig_integrity_sup_incl,
                CSFB_PARAM_1XRTT_SIG_INTEGRITY_SUP_INCL_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*SIG_INTEGRITY_SUP_INCLIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*SIG_INTEGRITY_SUP Parameters*/
    if(p_mobility_parameters_fill->bitmask & SIG_INTEGRITY_SUP_INCLUDED_PRESENT)
    {
        /*SIG_INTEGRITY_SUPIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*SIG_INTEGRITY_SUP*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->sig_integrity_sup,
                CSFB_PARAM_1XRTT_SIG_INTEGRITY_SUP_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*SIG_INTEGRITY_SUPIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*AUTH Parameters*/
    if(p_mobility_parameters_fill->bitmask & AUTH_INCLUDED_PRESENT)
    {
        /*AUTHIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*AUTH*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->auth,
                CSFB_PARAM_1XRTT_AUTH_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*AUTHIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*MAX_NUM_ALT_SO Parameters*/
    if(p_mobility_parameters_fill->bitmask & MAX_NUM_ALT_SO_INCLUDED_PRESENT)
    {
        /*MAX_NUM_ALT_SOIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*MAX_NUM_ALT_SO*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->max_num_alt_so,
                CSFB_PARAM_1XRTT_MAX_NUM_ALT_SO_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*MAX_NUM_ALT_SOIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*USE_SYNC_ID Parameters*/
    if(p_mobility_parameters_fill->bitmask & USE_SYNC_ID_INCLUDED_PRESENT)
    {
        /*USE_SYNC_IDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*USE_SYNC_ID*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->use_sync_id,
                CSFB_PARAM_1XRTT_USE_SYNC_ID_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*USE_SYNC_IDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*MS_INIT_POS_LOC_SUP_IND Parameters*/	
    if(p_mobility_parameters_fill->bitmask & MS_INIT_POS_LOC_SUP_IND_INCLUDED_PRESENT)
    {
        /*MS_INIT_POS_LOC_SUP_INDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*MS_INIT_POS_LOC_SUP_IND*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->ms_init_pos_loc_sup_ind,
                CSFB_PARAM_1XRTT_MS_INIT_POS_LOC_SUP_IND_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*MS_INIT_POS_LOC_SUP_INDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*MOB_QOS Parameters*/
    if(p_mobility_parameters_fill->bitmask & MOB_QOS_INCLUDED_PRESENT)
    {
        /*MOB_QOSIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*MOB_QOS*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->mob_qos,
                CSFB_PARAM_1XRTT_MOB_QOS_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*MOB_QOSIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*BAND_CLASS_INFO_REQ Parameters*/
    if(p_mobility_parameters_fill->bitmask & BAND_CLASS_INFO_REQ_INCLUDED_PRESENT)
    {
        /*BAND_CLASS_INFO_REQIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*BAND_CLASS_INFO_REQ*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->band_class_info_req,
                CSFB_PARAM_1XRTT_BAND_CLASS_INFO_REQ_NBITS,
                p_uecc_ue_context); /*band_class_info_req*/
    }
    else
    {
        /*BAND_CLASS_INFO_REQIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*BAND_CLASS Parameters*/
    if(p_mobility_parameters_fill->bitmask & BAND_CLASS_INCLUDED_PRESENT)
    {
        /*BAND_CLASSIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*BAND_CLASS*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->band_class,
                CSFB_PARAM_1XRTT_BAND_CLASS_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*BAND_CLASSIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*BYPASS_REG_IND Parameters*/
    if(p_mobility_parameters_fill->bitmask & BYPASS_REG_IND_INCLUDED_PRESENT)
    {
        /*BYPASS_REG_INDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*BYPASS_REG_IND*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->bypass_reg_ind,
                CSFB_PARAM_1XRTT_BYPASS_REG_IND_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*BYPASS_REG_INDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*ALT_BAND_CLASS Parameters*/
    if(p_mobility_parameters_fill->bitmask & ALT_BAND_CLASS_INCLUDED_PRESENT)
    {
        /*ALT_BAND_CLASSIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*ALT_BAND_CLASS*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->alt_band_class,
                CSFB_PARAM_1XRTT_ALT_BAND_CLASS_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*ALT_BAND_CLASSIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: rrc_form_mob_params_to_octet_string_part2
 *
 *   DESCRIPTION:
 *
 *   RETURNS:
 *       void
 *
 ******************************************************************************/
/* Bug 12190 Fix Start */
static void rrc_form_mob_params_to_octet_string_part2(
        uecc_ue_context_t*  p_uecc_ue_context,
        U8 ***p_buffer,
        U8 **bitPosition,
        mobility_parameters_t* p_mobility_parameters_fill,
        additional_mobility_parameters_t* p_add_mobility_parameters_fill
        )
{
    U8 *bitPos = PNULL;
    U8  **p_buf = PNULL;

    bitPos = (*bitPosition);
    p_buf = (*p_buffer);
    /* Bug 12190 Fix Stop */

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /*MAX_ADD_SERV_INSTANCE Parameters*/
    if(p_mobility_parameters_fill->bitmask & MAX_ADD_SERV_INSTANCE_INCLUDED_PRESENT)
    {
        /*MAX_ADD_SERV_INSTANCEIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*MAX_ADD_SERV_INSTANCE*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->max_add_serv_instance,
                CSFB_PARAM_1XRTT_MAX_ADD_SERV_INSTANCE_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*MAX_ADD_SERV_INSTANCEIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*HOME_REG*/
    if( p_mobility_parameters_fill->bitmask & HOME_REG_INCLUDED_PRESENT)
    {
        /*HOME_REGIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*HOME_REG*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->home_reg,
                CSFB_PARAM_1XRTT_HOME_REG_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*HOME_REGIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*FOR_SID_REG Parameters*/
    if(p_mobility_parameters_fill->bitmask & FOR_SID_REG_INCLUDED_PRESENT)
    {
        /*FOR_SID_REGIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*FOR_SID_REG*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->for_sid_reg,
                CSFB_PARAM_1XRTT_FOR_SID_REG_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*FOR_SID_REGIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*FOR_NID_REG Parameters*/
    if( p_mobility_parameters_fill->bitmask & FOR_NID_REG_INCLUDED_PRESENT)
    {
        /*FOR_NID_REGIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*FOR_NID_REG*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->for_nid_reg,
                CSFB_PARAM_1XRTT_FOR_NID_REG_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*FOR_NID_REGIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*POWER_UP_REG Parameters*/
    if( p_mobility_parameters_fill->bitmask & POWER_UP_REG_INCLUDED_PRESENT)
    {
        /*POWER_UP_REGIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*POWER_UP_REG*/
        SETNBIT(p_buf, bitPos,
                p_mobility_parameters_fill->power_up_reg,
                CSFB_PARAM_1XRTT_POWER_UP_REG_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*POWER_UP_REGIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*POWER_DOWN_REG Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & POWER_DOWN_REG_INCLUDED_PRESENT)
    {
        /*POWER_DOWN_REGIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*POWER_DOWN_REG*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->power_down_reg,
                CSFB_PARAM_1XRTT_POWER_DOWN_REG_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*POWER_DOWN_REGIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*parameter_reg*/
    if(p_add_mobility_parameters_fill->bitmask & PARAMETER_REG_INCLUDED_PRESENT)
    {
        /*PARAMETER_REGIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*PARAMETER_REG*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->parameter_reg,
                CSFB_PARAM_1XRTT_PARAMETER_REG_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*PARAMETER_REGIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, 1,p_uecc_ue_context);
    }

    /*REG_PRD Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & REG_PRD_INCLUDED_PRESENT)
    {
        /*REG_PRDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*REG_PRD*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->reg_prd,
                CSFB_PARAM_1XRTT_REG_PRD_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*REG_PRDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*REG_DIST Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & REG_DIST_INCLUDED_PRESENT)
    {
        /*REG_DISTIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*REG_DIST*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->reg_dist,
                CSFB_PARAM_1XRTT_REG_DIST_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*REG_DISTIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*PREF_MSID_TYPE Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & PREF_MSID_TYPE_INCLUDED_PRESENT)
    {
        /*PREF_MSID_TYPEIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*PREF_MSID_TYPE*/
        /* Bug 12674 Fix Start */
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->pref_msid_type,
                CSFB_PARAM_1XRTT_PREF_MSID_TYPE_NBITS,
                p_uecc_ue_context);
        /* Bug 12674 Fix Stop */
    }
    else
    {
        /*PREF_MSID_TYPEIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*EXT_PREF_MSID_TYPE Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & EXT_PREF_MSID_TYPE_INCLUDED_PRESENT)
    {
        /*EXT_PREF_MSID_TYPEIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*EXT_PREF_MSID_TYPE*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->ext_pref_msid_type,
                CSFB_PARAM_1XRTT_EXT_PREF_MSID_TYPE_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*EXT_PREF_MSID_TYPEIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*MEID_REQD Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & MEID_REQD_INCLUDED_PRESENT)
    {
        /*MEID_REQDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*MEID_REQD*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->meid_reqd,
                CSFB_PARAM_1XRTT_MEID_REQD_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*MEID_REQDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*MCC Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & MCC_INCLUDED_PRESENT)
    {
        /*MCCIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*MCC*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->mcc,
                CSFB_PARAM_1XRTT_MCC_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*MCCIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*IMSI_11_12 Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & IMSI_11_12_INCLUDED_PRESENT)
    {
        /*IMSI_11_12Included*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*IMSI_11_12*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->imsi_11_12,
                CSFB_PARAM_1XRTT_IMSI_11_12_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*IMSI_11_12Included*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*IMSI_T_SUPPORTED Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & IMSI_T_SUPPORTED_INCLUDED_PRESENT)
    {
        /*IMSI_T_SUPPORTEDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*IMSI_T_SUPPORTED*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->imsi_t_supported,
                CSFB_PARAM_1XRTT_IMSI_T_SUPPORTED_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*IMSI_T_SUPPORTEDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*RECONNECT_MSG_IND Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & RECONNECT_MSG_IND_INCLUDED_PRESENT)
    {
        /*RECONNECT_MSG_INDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*RECONNECT_MSG_IND*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->reconnect_msg_ind,
                CSFB_PARAM_1XRTT_RECONNECT_MSG_IND_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*RECONNECT_MSG_INDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*RER_MODE_SUPPORTED Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & RER_MODE_SUPPORTED_INCLUDED_PRESENT)
    {
        /*RER_MODE_SUPPORTEDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*RER_MODE_SUPPORTED*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->rer_mode_supported,
                CSFB_PARAM_1XRTT_RER_MODE_SUPPORTED_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*RER_MODE_SUPPORTEDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*TKZ_MODE_SUPPORTED Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & TKZ_MODE_SUPPORTED_INCLUDED_PRESENT)
    {
        /*TKZ_MODE_SUPPORTEDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*TKZ_MODE_SUPPORTED*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->tkz_mode_supported,
                CSFB_PARAM_1XRTT_TKZ_MODE_SUPPORTED_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*TKZ_MODE_SUPPORTEDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }


    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: rrc_form_mob_params_to_octet_string_part3
 *
 *   DESCRIPTION:
 *
 *   RETURNS:
 *       void
 *
 ******************************************************************************/
/* Bug 12190 Fix Start */
static void rrc_form_mob_params_to_octet_string_part3(
        uecc_ue_context_t*  p_uecc_ue_context,
        U8 ***p_buffer,
        U8 **bitPosition,
        /*SPR 17777 +-*/
        additional_mobility_parameters_t* p_add_mobility_parameters_fill
        )
{
    U8 *bitPos = PNULL;
    U8  **p_buf = PNULL;

    bitPos = (*bitPosition);
    p_buf = (*p_buffer);
    /* Bug 12190 Fix Stop */

    /* SPR 13645 Fix Start */
    U8 ltm_off_value = RRC_NULL;
    /* SPR 13645 Fix Stop */
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /*TKZ_ID Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & TKZ_ID_INCLUDED_PRESENT)
    {
        /*TKZ_IDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*TKZ_ID*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->tkz_id,
                CSFB_PARAM_1XRTT_TKZ_ID_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*TKZ_IDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*PILOT_REPORT Paramneters*/
    if(p_add_mobility_parameters_fill->bitmask & PILOT_REPORT_INCLUDED_PRESENT)
    {
        /*PILOT_REPORTIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*PILOT_REPORT*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->pilot_report,
                CSFB_PARAM_1XRTT_PILOT_REPORT_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*PILOT_REPORTIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*SDB_SUPPORTED Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & SDB_SUPPORTED_INCLUDED_PRESENT)
    {
        /*SDB_SUPPORTEDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*SDB_SUPPORTED*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->sdb_supported,
                CSFB_PARAM_1XRTT_SDB_SUPPORTED_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*SDB_SUPPORTEDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*AUTO_FCSO_ALLOWED Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & AUTO_FCSO_ALLOWED_INCLUDED_PRESENT)
    {
        /*AUTO_FCSO_ALLOWEDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*AUTO_FCSO_ALLOWED*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->auto_fcso_allowed,
                CSFB_PARAM_1XRTT_AUTO_FCSO_ALLOWED_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*AUTO_FCSO_ALLOWEDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*SDB_IN_RCNM_IND Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & SDB_IN_RCNM_IND_INCLUDED_PRESENT)
    {
        /*SDB_IN_RCNM_INDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*SDB_IN_RCNM_IND*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->sdb_in_rcnm_ind,
                CSFB_PARAM_1XRTT_SDB_IN_RCNM_IND_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*SDB_IN_RCNM_INDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*FPC_FCH_INCLUDED_t Parameters*/
    /*FPC_FCH_Included*/
    if(p_add_mobility_parameters_fill->bitmask & FPC_FCH_INCLUDED_PRESENT)
    {
        /*FPC_FCH_INCLUDED_PRESENTIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH, p_uecc_ue_context);

        /*FPC_FCH_INIT_SETPT_RC3 Parameters*/
        if(p_add_mobility_parameters_fill->fpc_fch_included.bitmask & FPC_FCH_INIT_SETPT_RC3_PRESENT)
        {
            /*FPC_FCH_INIT_SETPT_RC3*/
            SETNBIT(p_buf, bitPos,
                    p_add_mobility_parameters_fill->\
                    fpc_fch_included.fpc_fch_init_setpt_rc3,
                    CSFB_PARAM_1XRT_FPC_FCH_INIT_SETPT_RC3_NBITS,
                    p_uecc_ue_context);
        }

        /*FPC_FCH_INIT_SETPT_RC4 Parameters*/
        if(p_add_mobility_parameters_fill->fpc_fch_included.bitmask & FPC_FCH_INIT_SETPT_RC4_PRESENT)
        {
            /*FPC_FCH_INIT_SETPT_RC4*/
            SETNBIT(p_buf, bitPos,
                    p_add_mobility_parameters_fill->\
                    fpc_fch_included.fpc_fch_init_setpt_rc4,
                    CSFB_PARAM_1XRT_FPC_FCH_INIT_SETPT_RC4_NBITS,
                    p_uecc_ue_context);
        }

        /*FPC_FCH_INIT_SETPT_RC5 Parameters*/
        if(p_add_mobility_parameters_fill->fpc_fch_included.bitmask & FPC_FCH_INIT_SETPT_RC5_PRESENT)
        {
            /*FPC_FCH_INIT_SETPT_RC5*/
            SETNBIT(p_buf, bitPos,
                    p_add_mobility_parameters_fill->\
                    fpc_fch_included.fpc_fch_init_setpt_rc5,
                    CSFB_PARAM_1XRT_FPC_FCH_INIT_SETPT_RC5_NBITS,
                    p_uecc_ue_context);
        }

        /* Bug 12674 Fix Start */
        /*FPC_FCH_INIT_SETPT_RC11 Parameters*/
        if(p_add_mobility_parameters_fill->fpc_fch_included.bitmask & FPC_FCH_INIT_SETPT_RC11_PRESENT)
        {
            /*FPC_FCH_INIT_SETPT_RC11*/
            SETNBIT(p_buf, bitPos,
                    p_add_mobility_parameters_fill->\
                    fpc_fch_included.fpc_fch_init_setpt_rc11,
                    CSFB_PARAM_1XRT_FPC_FCH_INIT_SETPT_RC11_NBITS,
                    p_uecc_ue_context);
        }

        /*FPC_FCH_INIT_SETPT_RC12 Parameters*/
        if(p_add_mobility_parameters_fill->fpc_fch_included.bitmask & FPC_FCH_INIT_SETPT_RC12_PRESENT)
        {
            /*FPC_FCH_INIT_SETPT_RC12*/
            SETNBIT(p_buf, bitPos,
                    p_add_mobility_parameters_fill->\
                    fpc_fch_included.fpc_fch_init_setpt_rc12,
                    CSFB_PARAM_1XRT_FPC_FCH_INIT_SETPT_RC12_NBITS,
                    p_uecc_ue_context);
        }
        /* Bug 12674 Fix Stop */
    }
    else
    {
        /*FPC_FCH_INCLUDED_PRESENTIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }
    /*T_ADD Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & T_ADD_INCLUDED_PRESENT)
    {
        /*T_ADDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*T_ADD*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->t_add,
                CSFB_PARAM_1XRT_T_ADD_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*T_ADDIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*PILOT_INC Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & PILOT_INC_INCLUDED_PRESENT)
    {
        /*PILOT_INCIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*PILOT_INC*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->pilot_inc,
                CSFB_PARAM_1XRT_PILOT_INC_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*PILOT_INCIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /* Bug 12190 Fix Start */
    /* Bug 12674 Fix Start */
    /*RAND_INCLUDED_PRESENT Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & RAND_INCLUDED_PRESENT)
    {
        /*RAND_Included*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*RAND */
        SETNBIT(p_buf, bitPos,
                p_uecc_ue_context->p_gb_context->
                p_p_csc_context[p_uecc_ue_context->cell_index]->
                p_csc_init_setup_ind->cdma2000_rand,
                CSFB_PARAM_1XRT_RAND_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*RAND_Included*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }
    /* Bug 12674 Fix Stop */
    /* Bug 12190 Fix Stop */

    /*LP_SEC Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & LP_SEC_INCLUDED_PRESENT)
    {
        /*LP_SECIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*LP_SEC*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->lp_sec,
                CSFB_PARAM_1XRT_LP_SEC_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*LP_SECIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /* Bug 12190 Fix Start */
    /* Bug 12674 Fix Start */
    if(p_add_mobility_parameters_fill->bitmask & LTM_OFF_INCLUDED_PRESENT)
    {
        /*LTM_OFFIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*LTM_OFF*/

        /* SPR 13645 Fix Start */	
        ltm_off_value_wrapper(&ltm_off_value);

        SETNBIT(p_buf, bitPos,
                ltm_off_value,
                CSFB_PARAM_1XRT_LTM_OFF_NBITS,
                p_uecc_ue_context);
        /* SPR 13645 Fix Stop */
    }
    else
    {
        /*LTM_OFF Included*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }
    /* Bug 12674 Fix Stop */
    /* Bug 12190 Fix Stop */

    /*DAYLT Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & DAYLT_INCLUDED_PRESENT)
    {
        /*DAYLTIncluded*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*DAYLT*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->daylt,
                CSFB_PARAM_1XRT_DAYLT_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*DAYLTIncluded*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*GCSNAL2AckTimer Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & GCSNA_L2_ACK_TIMER_INCLUDED_PRESENT)
    {
        /*GCSNAL2AckTimer_Included*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*GCSNAL2AckTimer*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->gcsna_l2_ack_timer,
                CSFB_PARAM_1XRT_GCSNAL2ACKTIMER_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*GCSNAL2AckTimer_Included*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }

    /*GCSNASequenceContextTimer Parameters*/
    if(p_add_mobility_parameters_fill->bitmask & GCSNA_SEQUENCE_CONTEXT_TIMER_INCLUDED_PRESENT)
    {
        /*GCSNASequenceContextTimer_Included*/
        SETNBIT(p_buf, bitPos, RRC_TRUE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
        /*GCSNASequenceContextTimer*/
        SETNBIT(p_buf, bitPos,
                p_add_mobility_parameters_fill->gcsna_sequence_context_timer,
                CSFB_PARAM_1XRT_GCSNASEQUENCECONTEXTTIMER_NBITS,
                p_uecc_ue_context);
    }
    else
    {
        /*GCSNASequenceContextTimer_Included*/
        SETNBIT(p_buf, bitPos, RRC_FALSE, CSFB_BITMASK_PRESENT_WIDTH,p_uecc_ue_context);
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: rrc_form_mob_params_to_octet_string
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *                  OSDynOctStr *p_octet_data
 *                  mobility_parameters_t* p_mobility_parameters_fill
 *                  additional_mobility_parameters_t* p_add_mobility_parameters_fill
 *   OUTPUT       : none               
 *   DESCRIPTION  : This function forms an octet string of mobility parameters received 
 *                  from parameter transfer response from RRM.
 *
 *   RETURNS      : void
 *
 ******************************************************************************/
void  rrc_form_mob_params_to_octet_string(
        uecc_ue_context_t*  p_uecc_ue_context,
        OSDynOctStr *p_octet_data,
        mobility_parameters_t* p_mobility_parameters_fill,
        additional_mobility_parameters_t* p_add_mobility_parameters_fill
        )
{

    U8 *buffer = PNULL;
    /* Bug 12190 Fix Start */
    U8 **p_buf = PNULL;
    U8 *p_buf1 = PNULL;
    U8 *bitPos = PNULL;
    U8 bitPosition = 0;
    /* Bug 12190 Fix Stop */
    U8* init_add_of_octet = PNULL;
    U8* final_add_of_octet = PNULL;
    U32 num_of_octets = 0;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    if(PNULL != p_octet_data)
    {
        buffer = (U8 *)p_octet_data->data;
        /* Bug 12190 Fix Start */
        p_buf1 = (U8 *)p_octet_data->data;
    }
    p_buf = &p_buf1;
    bitPos = &bitPosition;
    /* Bug 12190 Fix Stop */
    init_add_of_octet = buffer;

    if ( (p_octet_data == PNULL) || (PNULL == p_octet_data->data) )
    {
        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                p_uecc_ue_context->p_gb_context->facility_name,
                RRC_INFO,
                "Memory allocation to p_octet_data failed");
    }
    else
    {
        memset_wrapper((void *)p_octet_data->data,0, MOBILITY_PARAMS_MAX_OCTETS);
        /* Bug 12190 Fix Start */
        SETNBIT(p_buf, bitPos, 0,
                CSFB_PARAM_1XRT_RECORD_TYPE_NBITS,
                p_uecc_ue_context);
        /* Bug 12190 Fix Stop */

        if(p_mobility_parameters_fill->bitmask & SID_INCLUDED_PRESENT)
        {
            /*SIDIncluded*/
            SETNBIT(p_buf, bitPos, RRC_TRUE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
            /*SID*/
            SETNBIT(p_buf, bitPos, p_mobility_parameters_fill->sid,
                    CSFB_REG_PARAM_1_XRTT_SID_NBITS,
                    p_uecc_ue_context);
        }
        else
        {
            /*SIDIncluded*/
            SETNBIT(p_buf, bitPos, RRC_FALSE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
        }

        /*NID Parameter*/
        if(p_mobility_parameters_fill->bitmask & NID_INCLUDED_PRESENT)
        {
            /*NIDIncluded*/
            SETNBIT(p_buf, bitPos, RRC_TRUE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
            /*NID*/
            /* Bug 12190 Fix Start */
            SETNBIT(p_buf, bitPos, p_mobility_parameters_fill->nid,
                    CSFB_REG_PARAM_1_XRTT_NID_NBITS,
                    p_uecc_ue_context);
            /* Bug 12190 Fix Stop */
        }
        else
        {
            /*NIDIncluded*/
            SETNBIT(p_buf, bitPos, RRC_FALSE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
        }
        /*Multi Sids*/

        /*MULT_SIDS Parameter*/
        if(p_mobility_parameters_fill->bitmask & MULT_SIDS_INCLUDED_PRESENT)
        {
            /*MULT_SIDSIncluded*/
            SETNBIT(p_buf, bitPos, RRC_TRUE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
            /*MULT_SIDS*/
            SETNBIT(p_buf, bitPos, p_mobility_parameters_fill->multi_sids,
                    CSFB_PARAM_1XRTT_MULTI_SIDS_NBITS,
                    p_uecc_ue_context);
        }
        else
        {
            /*MULT_SIDSIncluded*/
            SETNBIT(p_buf, bitPos, RRC_FALSE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
        }

        /*MULT_NIDS Parameter*/

        if(p_mobility_parameters_fill->bitmask & MULT_NIDS_INCLUDED_PRESENT)
        {
            /*MULT_NIDSIncluded*/
            SETNBIT(p_buf, bitPos, RRC_TRUE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
            /*MULT_NIDS*/
            SETNBIT(p_buf, bitPos, p_mobility_parameters_fill->multi_nids,
                    CSFB_PARAM_1XRTT_MULTI_NIDS_NBITS,
                    p_uecc_ue_context);
        }
        else
        {
            /*MULT_NIDSIncluded*/
            SETNBIT(p_buf, bitPos, RRC_FALSE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
        }

        /*Reg_Zone*/
        if(p_mobility_parameters_fill->bitmask & REG_ZONE_INCLUDED_PRESENT)
        {
            /*REG_ZONEIncluded*/
            SETNBIT(p_buf, bitPos, RRC_TRUE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
            /*REG_ZONE*/
            SETNBIT(p_buf, bitPos, p_mobility_parameters_fill->reg_zone,
                    CSFB_REG_REG_ZONE_NBITS, p_uecc_ue_context);
        }
        else
        {
            /*REG_ZONEIncluded*/
            SETNBIT(p_buf, bitPos, RRC_FALSE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
        }

        /*TOTAL_ZONES Parameter*/
        if(p_mobility_parameters_fill->bitmask & TOTAL_ZONES_INCLUDED_PRESENT)
        {
            /*TOTAL_ZONESIncluded*/
            SETNBIT(p_buf, bitPos, RRC_TRUE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
            /*TOTAL_ZONES*/
            SETNBIT(p_buf, bitPos,
                    p_mobility_parameters_fill->total_zones,
                    CSFB_REG_TOTAL_ZONE_NBITS,
                    p_uecc_ue_context);
        }
        else
        {
            /*TOTAL_ZONESIncluded*/
            SETNBIT(p_buf, bitPos, RRC_FALSE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
        }

        /*ZONE_TIMER Parameter*/
        if( p_mobility_parameters_fill->bitmask & ZONE_TIMER_INCLUDED_PRESENT)
        {
            /*ZONE_TIMERIncluded*/
            SETNBIT(p_buf, bitPos, RRC_TRUE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
            /*ZONE_TIMER*/
            SETNBIT(p_buf, bitPos,
                    p_mobility_parameters_fill->zone_timer,
                    CSFB_REG_ZONE_TIMER_NBITS,
                    p_uecc_ue_context);
        }
        else
        {
            /*ZONE_TIMERIncluded*/
            SETNBIT(p_buf, bitPos, RRC_FALSE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
        }

        /*PACKET_ZONE_ID parameter*/
        if(p_mobility_parameters_fill->bitmask & PACKET_ZONE_ID_INCLUDED_PRESENT)
        {
            /*PACKET_ZONE_IDIncluded*/
            SETNBIT(p_buf, bitPos, RRC_TRUE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
            /*PACKET_ZONE_ID*/
            /* Bug 12190 Fix Start */
            SETNBIT(p_buf,bitPos,
                    p_mobility_parameters_fill->packet_zone_id,
                    CSFB_PARAM_1XRTT_PACKET_ZONE_ID_NBITS,
                    p_uecc_ue_context);
            /* Bug 12190 Fix Stop */
        }
        else
        {
            /*PACKET_ZONE_IDIncluded*/
            SETNBIT(p_buf, bitPos, RRC_FALSE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
        }

        /*PZIDHystParameter Parameter*/
        if(p_mobility_parameters_fill->bitmask & PZ_ID_HYST_PARAMETERS_INCLUDED_PRESENT)
        {
            /* Bug 12190 Fix Start */
            rrc_form_mob_params_for_PZIDHystParameter(
                    p_uecc_ue_context,&p_buf,&bitPos,p_mobility_parameters_fill);
            /* Bug 12190 Fix Stop */

        }
        else
        {
            /*PZIDHystParameterIncluded*/
            SETNBIT(p_buf, bitPos, RRC_FALSE,
                    CSFB_BITMASK_PRESENT_WIDTH,
                    p_uecc_ue_context);
        }

        /*P_REV parameter*/
        /* Bug 12190 Fix Start */
        rrc_form_mob_params_to_octet_string_part1(
                p_uecc_ue_context,&p_buf,&bitPos,p_mobility_parameters_fill);

        rrc_form_mob_params_to_octet_string_part2(
                p_uecc_ue_context,&p_buf,&bitPos,p_mobility_parameters_fill,
                p_add_mobility_parameters_fill);	

        rrc_form_mob_params_to_octet_string_part3(
                p_uecc_ue_context,&p_buf,&bitPos,p_add_mobility_parameters_fill);
        /*SPR 17777 +-*/
        /* Bug 12190 Fix Stop */

        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                p_uecc_ue_context->p_gb_context->facility_name,
                RRC_INFO,
                "octet string packed");
        /* Bug 12190 Fix Start */
        final_add_of_octet = *p_buf;
        /* Bug 12190 Fix Stop */
/*SPR 20636 Changes Start*/
        num_of_octets = ((U32_64_Bit)final_add_of_octet  - (U32_64_Bit)init_add_of_octet) + 1;

/*SPR 20636 Changes End*/

        if(0 == bitPos)
        {
            num_of_octets = (num_of_octets - 1);
        }


        p_octet_data->numocts = num_of_octets;

    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_rrc_connection_reconfiguration
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds and sends UECC_LLIM_SRB_DATA_REQ message
 *                  with RRCConnectionReconfiguration to LLIM
 *
 *   RETURNS      : RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_rrc_connection_reconfiguration(
        uecc_ue_context_t*  p_uecc_ue_context
        )
{
    OSCTXT                                  asn1_ctx;
    DL_DCCH_Message                         dl_dcch_msg;
    RRCConnectionReconfiguration*           p_rrc_conn_recfg = PNULL;
    RRCConnectionReconfiguration_r8_IEs*    p_r8 = PNULL;
    rrc_return_et                           result = RRC_FAILURE;


    rrc_uecc_llim_srb_data_req_t*           p_srb_data_req = PNULL;
    U8  msg[sizeof(rrc_uecc_llim_srb_data_req_t)+UECC_MAX_ASN1_BUF_LEN];
    EVENT_EXTERNAL_HEADER                   *p_event_header = PNULL;
    U32                                     encoded_msg_len = 0;
    LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT   *p_event_rrc_protocol_err = PNULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /*Bug_11945_fix_start*/
    S8* s_id = PNULL;
    /*Bug_11945_fix_start*/

    memset_wrapper(&dl_dcch_msg, 0, sizeof(dl_dcch_msg));

    /* Init ASN1 context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[RRCConnectionReconfiguration] "
                "ASN1 context initialization failed.");
        return RRC_FAILURE;
    }

    do
    {
        /* Fill the values in the ASN structures that shall be encoded by
         * ASN Encoder */
        /* Downlink DCCH message type */
        dl_dcch_msg.message.t = T_DL_DCCH_MessageType_c1;
        dl_dcch_msg.message.u.c1 =
            rtxMemAllocType(&asn1_ctx, DL_DCCH_MessageType_c1);
        if (PNULL == dl_dcch_msg.message.u.c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReconfiguration] ASN malloc failed.");
            break;
        }

        /* Choose RRCConnectionReconfiguration */
        dl_dcch_msg.message.u.c1->t =
            T_DL_DCCH_MessageType_c1_rrcConnectionReconfiguration;

        dl_dcch_msg.message.u.c1->u.rrcConnectionReconfiguration =
            rtxMemAllocType(&asn1_ctx, RRCConnectionReconfiguration);
        if (PNULL == dl_dcch_msg.message.u.c1->u.rrcConnectionReconfiguration)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReconfiguration] ASN malloc failed.");
            break;
        }

        p_rrc_conn_recfg =
            dl_dcch_msg.message.u.c1->u.rrcConnectionReconfiguration;

        /* transaction id */
        p_rrc_conn_recfg->rrc_TransactionIdentifier =
            (RRC_TransactionIdentifier) (uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context) &
                    UECC_LTE_RRC_TRANSACTION_ID_MASK);

        p_rrc_conn_recfg->criticalExtensions.t =
            T_RRCConnectionReconfiguration_criticalExtensions_c1;

        p_rrc_conn_recfg->criticalExtensions.u.c1 = rtxMemAllocType(&asn1_ctx,
                RRCConnectionReconfiguration_criticalExtensions_c1);
        if (PNULL == p_rrc_conn_recfg->criticalExtensions.u.c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReconfiguration] ASN malloc failed.");
            break;
        }

        p_rrc_conn_recfg->criticalExtensions.u.c1->t =
            T_RRCConnectionReconfiguration_criticalExtensions_c1_rrcConnectionReconfiguration_r8;

        p_r8 = rtxMemAllocType(&asn1_ctx, RRCConnectionReconfiguration_r8_IEs);
        if (PNULL == p_r8)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReconfiguration] ASN malloc failed.");
            break;
        }
        p_rrc_conn_recfg->criticalExtensions.u.c1->
            u.rrcConnectionReconfiguration_r8 = p_r8;
        asn1Init_RRCConnectionReconfiguration_r8_IEs(
                p_r8);

        /* If Reestablishment is not ongoing */

        /*SPR 21451 start*/
        if ((PNULL == p_uecc_ue_context->p_reestab_ue_identity) || (strcmp_wrapper(p_uecc_ue_context->uecc_fsm.p_current_state->s_name,
                        ((const S8 *)("UECC_UE_CONNECTION_RE_ESTABLISHMENT_ONGOING")))))
        {

        /*SPR 21451 stop*/
            /* SPR 12804 Fix Start */
            if (PNULL != p_uecc_ue_context->p_curr_proc_data)
            {
                /* SPR 4083 Start */
                if (0 < p_uecc_ue_context->p_curr_proc_data->u.
                        erab_release_command_data.erab_release_list.counter)
                {

                    p_r8->m.radioResourceConfigDedicatedPresent = 1;
                    /* SPR 12804 Fix Stop */

                    p_r8->radioResourceConfigDedicated.m.drb_ToReleaseListPresent = 1;
                    /* Generate DRB Information */
                    if (RRC_SUCCESS != uecc_llim_build_asn1_drb_to_release_list(
                                p_uecc_ue_context,
                                &p_r8->radioResourceConfigDedicated.drb_ToReleaseList,
                                &asn1_ctx))
                    {
                        break;
                    }   /* SPR 20747 Fix Start */
#ifdef ENDC_ENABLED
/* NR_DC Code Change Start */
                    /* If no element is present in DRB_ToReleaseList, the Reset
                     * the DRB_toReleaseListPresent to ZERO.
                     */
                    if (0 == p_r8->radioResourceConfigDedicated.drb_ToReleaseList.n)
                    {
                        p_r8->radioResourceConfigDedicated.m.drb_ToReleaseListPresent = 0;
                    }
/* NR_DC Code Change Start */
#endif
		    if((p_uecc_ue_context->m.is_sps_recv_frm_rrm) &&
				(p_uecc_ue_context->m.is_sps_setup_or_rel_recv) &&
				(PNULL != p_uecc_ue_context->p_sps_config))
		    {
			p_r8->radioResourceConfigDedicated.m.sps_ConfigPresent = 1;

			if (p_uecc_ue_context->p_sps_config->bitmask &
					RRC_SPS_CONFIG_SPS_CONFIG_DL_PRESENT)
			{
				p_r8->radioResourceConfigDedicated.sps_Config.m.sps_ConfigDLPresent = 1;
				p_r8->radioResourceConfigDedicated.sps_Config.sps_ConfigDL.t = T_SPS_ConfigDL_release;
			}
			if (p_uecc_ue_context->p_sps_config->bitmask &
					RRC_SPS_CONFIG_SPS_CONFIG_UL_PRESENT)
			{
				p_r8->radioResourceConfigDedicated.sps_Config.m.sps_ConfigULPresent = 1;
				p_r8->radioResourceConfigDedicated.sps_Config.sps_ConfigUL.t = T_SPS_ConfigUL_release;
			}


		    }
		    /* SPR 20747 Fix End */

                }
            }
            /* SPR 4083 Stop */
        } 
        /*CA_RE_ESTAB_START*/
        /* If Reestablishment is ongoing */
        /*Bug_11945_fix_start*/
        if (PNULL != p_uecc_ue_context->uecc_fsm.proc_descriptor.p_active_proc)
        {
            s_id = p_uecc_ue_context->uecc_fsm.proc_descriptor.p_active_proc->s_id;
        }
        if ((PNULL != s_id) &&
                !(strncmp_wrapper((const S8 *)s_id,(const S8 *)"CRE_P",
                        strlen_wrapper((const Char8*)s_id))))
            /*Bug_11945_fix_stop*/
        {
            if ((RRC_TRUE == p_uecc_ue_context->m.scell_config_present) &&
                    (PNULL != p_uecc_ue_context->p_scell_config) &&
                    (p_uecc_ue_context->p_scell_config->bitmask &
                     RRM_SCELL_ADD_MOD_LIST_PRESENT) &&
                    (p_uecc_ue_context->p_scell_config->scell_add_mod_list.
                     count > 0))
            {
                if (RRC_TRUE == p_uecc_ue_context->m.mac_config_present)
                {
                    if (RRC_TRUE == p_uecc_ue_context->m.mac_main_config_present)
                    {
                        if ((p_uecc_ue_context->mac_config.bitmask &
                                    RRM_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT) &&
                                (p_uecc_ue_context->mac_config.mac_main_config.
                                 bitmask & RRC_MAC_MAIN_CONFIG_V1020_PRESENT) &&
                                (p_uecc_ue_context->mac_config.mac_main_config.
                                 mac_main_config_v1020.bitmask &
                                 RRC_MAC_MAIN_CONFIG_V1020_SCELL_DEACTIVATION_TIMER_PRESENT) &&
                                RRC_RADIO_FRAME_INFINITY !=
                                p_uecc_ue_context->mac_config.mac_main_config.
                                mac_main_config_v1020.scell_deactivation_timer)
                        {
                            RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                                    p_uecc_ue_context->p_gb_context->facility_name, 
                                    RRC_INFO,"scell deactivation timer present");
                            p_r8->m.radioResourceConfigDedicatedPresent = 1;
                            p_r8->radioResourceConfigDedicated.m.mac_MainConfigPresent = 1;
                            p_r8->radioResourceConfigDedicated.mac_MainConfig.t = 
                                T_RadioResourceConfigDedicated_mac_MainConfig_explicitValue;
                            p_r8->radioResourceConfigDedicated.mac_MainConfig.u.
                                explicitValue =
                                rtxMemAllocType(&asn1_ctx,MAC_MainConfig);
                            if (PNULL == p_r8->radioResourceConfigDedicated.
                                    mac_MainConfig.u.explicitValue)
                            {
                                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->
                                        context_index,(p_uecc_ue_context->
                                            p_gb_context)->facility_name,RRC_ERROR,
                                        "[RRCConnectionReconfiguration]"
                                        "ASN malloc failed.");
                                break;
                            }
                            asn1Init_MAC_MainConfig(p_r8->radioResourceConfigDedicated.
                                    mac_MainConfig.u.explicitValue);
                            p_r8->radioResourceConfigDedicated.mac_MainConfig.u.
                                explicitValue->timeAlignmentTimerDedicated =
                                p_uecc_ue_context->mac_config.mac_main_config.
                                time_alignment_timer_dedicated;
                            p_r8->radioResourceConfigDedicated.mac_MainConfig.
                                u.explicitValue->m._v3ExtPresent = 1;
                            p_r8->radioResourceConfigDedicated.mac_MainConfig.
                                u.explicitValue->m.mac_MainConfig_v1020Present = 1;

                            if(RRC_RADIO_FRAME_INFINITY != p_uecc_ue_context->
                                    mac_config.mac_main_config.
                                    mac_main_config_v1020.scell_deactivation_timer &&
                                    RRC_TRUE == p_uecc_ue_context->m.scell_config_present)
                            {
                                p_r8->radioResourceConfigDedicated.mac_MainConfig.
                                    u.explicitValue->mac_MainConfig_v1020.m.
                                    sCellDeactivationTimer_r10Present = 1;
                                p_r8->radioResourceConfigDedicated.mac_MainConfig.
                                    u.explicitValue->mac_MainConfig_v1020.
                                    sCellDeactivationTimer_r10 =
                                    p_uecc_ue_context->mac_config.mac_main_config.
                                    mac_main_config_v1020.scell_deactivation_timer;
                            }
                        }
                        else
                        {
                            RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                                    p_uecc_ue_context->p_gb_context->facility_name,
                                    RRC_INFO,"scell deactivation timer is infinity"
                                    "or not present");
                        }
                    }
                }
                p_r8->m.nonCriticalExtensionPresent = 1;
                p_r8->nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
                p_r8->nonCriticalExtension.nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
                p_r8->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.m.
                    sCellToAddModList_r10Present = 1;
                if (RRC_SUCCESS != uecc_llim_build_asn1_add_modify_scell_config(
                            p_uecc_ue_context,
                            &p_uecc_ue_context->p_scell_config->
                            scell_add_mod_list,
                            &p_r8->nonCriticalExtension.nonCriticalExtension.
                            nonCriticalExtension.sCellToAddModList_r10,
                            &asn1_ctx))
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR, "Scell config error in Add ");
                    break;
                }
            }
        }
        /*CA_RE_ESTAB_STOP*/

        if (PNULL != p_uecc_ue_context->p_curr_proc_data)
        {
            if (p_uecc_ue_context->m.meas_config_updated )
            {
                if (RRC_SUCCESS != uecc_llim_build_MeasConfig(
                            p_uecc_ue_context,
                            p_uecc_ue_context->p_meas_config,
                            &asn1_ctx,
                            &p_r8->measConfig))
                {
                    break;
                }
                p_r8->m.measConfigPresent = 1;
            }
        }
        else
        {
            if (RRC_TRUE ==
                    p_uecc_ue_context->curr_meas_config.is_meas_config_valid)
            {
                if (RRC_SUCCESS !=
                        uecc_llim_build_CurrMeasConfig(
                            p_uecc_ue_context,
                            &p_uecc_ue_context->curr_meas_config,
                            &asn1_ctx,
                            &p_r8->measConfig))
                {
                    break;
                }
                p_r8->m.measConfigPresent
                    = 1;
            }
        }

#ifdef ENDC_ENABLED
        /*NR_DC Code Change Start*/
        uecc_llim_build_nr_rrc_connection_reconfig_r15_ies(
                &asn1_ctx,
                p_r8,
                p_uecc_ue_context,
                ERAB_RELEASE
                );
        /*NR_DC Code Change Stop*/
#endif


        /* Set NAS PDU if Present In Case of E-RAB Release */
        if (PNULL!= p_uecc_ue_context->p_curr_proc_data)
        {
            if (p_uecc_ue_context->p_curr_proc_data->u.
                    erab_release_command_data.m.nAS_PDUPresent)
            {
                p_r8->dedicatedInfoNASList.elem[0] =
                    p_uecc_ue_context->p_curr_proc_data->u.erab_release_command_data.nAS_PDU;
                p_r8->m.dedicatedInfoNASListPresent = 1;
                p_r8->dedicatedInfoNASList.n = 1;
            }
        }

        /* Do ASN1 encode */
        p_srb_data_req = (rrc_uecc_llim_srb_data_req_t*)msg;

        pu_setBuffer(&asn1_ctx, p_srb_data_req->data_buffer,
                UECC_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);

        if (RT_OK != asn1PE_DL_DCCH_Message(&asn1_ctx, &dl_dcch_msg))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,                    
                    RRC_ERROR,
                    "[RRCConnectionReconfiguration] ASN1 encoding failed.");

            /*Generating Protocol Event LOCAL_EVENT_RRC_PROTOCOL_ERROR*/
            p_event_rrc_protocol_err = rrc_mem_get(sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));
            if (PNULL != p_event_rrc_protocol_err)
            {
                memset_wrapper(p_event_rrc_protocol_err, RRC_NULL, 
                        sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));

                p_event_rrc_protocol_err->header.length = 
                    sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT);
                p_event_rrc_protocol_err->header.event_id = LOCAL_EVENT_RRC_PROTOCOL_ERROR;

                l3_strncpy_wrapper((S8 *)(p_event_rrc_protocol_err->EVENT_PARAM_RRC_MESSAGE_DISCARDED),
                        (S8 *)("RRC CONNECTION RECONFIGURATION"), RRC_MESSAGE_DISCARDED_SIZE);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_rrc_protocol_err);
            }
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_DL_DCCH_Message(RRC_ASN,"DL_DCCH_Message",
                    &dl_dcch_msg, "RRCConnectionReconfiguration",
                    p_srb_data_req->data_buffer, encoded_msg_len);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                memset_wrapper(p_event_header, RRC_NULL, (sizeof(EVENT_EXTERNAL_HEADER) +
                            encoded_msg_len));
                rrc_uecc_fill_protocol_event_params(p_uecc_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_RRC_CONNECTION_RECONFIGURATION,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_srb_data_req->data_buffer,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }


        p_srb_data_req->data_buffer_length = (rrc_counter_t)pe_GetMsgLen(&asn1_ctx);
        p_srb_data_req->transaction_id =
            uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
        p_srb_data_req->ue_index = p_uecc_ue_context->ue_index;
        p_srb_data_req->cell_index = p_uecc_ue_context->cell_index;
        p_srb_data_req->lc_id = UECC_LTE_RRC_SRB1_LC_ID;
        /* SPR 14982 Start */
        p_srb_data_req->service_requested =
            UECC_LLIM_SRB_SERVICEREQUESTED_DELIVERY_STATUS_FALSE;
        /* SPR 14982 End */

        /* TRACE_changes_start */
        /* SPR 16113 Start */
        uecc_rrc_ue_assoc_msg_max_trace_handler(p_uecc_ue_context, p_srb_data_req->data_buffer, 
                p_srb_data_req->data_buffer_length, "RRC CONNECTION RECONFIGURATION", RRC_DL_DCCH);
        /* SPR 16113 Stop */
        /* TRACE_changes_start */

        result = uecc_rrc_send_internal_msg(
                RRC_LLIM_MODULE_ID,
                UECC_LLIM_SRB_DATA_REQ,
                (U16)( p_srb_data_req->data_buffer_length+
                    sizeof(rrc_uecc_llim_srb_data_req_t)),
                msg);

        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "RRC_MSG: RRCConnectionReconfiguration %s",
                change_data_to_str(p_srb_data_req->data_buffer_length, p_srb_data_req->data_buffer));

    }
    while(0);

    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_ho_from_eutra_prep_req 
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : None
 *   DESCRIPTION  : This function builds and sends HO From EUTRA Req message
 *                  to LLIM module. (UECC_LLIM_SRB_DATA_REQ)
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_ho_from_eutra_prep_req
(
 uecc_ue_context_t*  p_uecc_ue_context        /* UE context */
 )
{
    rrc_return_et                               response = RRC_FAILURE;
    OSCTXT                                      asn1_ctx;
    rrc_uecc_llim_srb_data_req_t*               p_srb_data_req = PNULL;

    DL_DCCH_MessageType_c1*                     p_dl_dcch_c1 = PNULL;
    HandoverFromEUTRAPreparationRequest_criticalExtensions_c1*                      //check the relevance of this message, being used at one place only
        p_dl_dcch_rrc_ext_c1 = PNULL;
    HandoverFromEUTRAPreparationRequest_r8_IEs* p_r8 = PNULL;
    DL_DCCH_Message                             dl_dcch_msg;
    OSDynOctStr                            *p_octet_data = PNULL;

    U8  msg[sizeof(rrc_uecc_llim_srb_data_req_t)+UECC_MAX_ASN1_BUF_LEN];
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /*SPR 15896 Fix Start*/
    if (p_uecc_ue_context->m.traceActivated )

    {
        /*SPR 15875 Fix Start*/
        if((p_uecc_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_uecc_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_uecc_ue_context->p_ue_trace_activation_info->interfaces_to_trace & UU))
        {
            P_RRC_TRACE(p_uecc_ue_context, set_all_trace_bitmask(),GEN_MME,"\n <msg function=\"Uu\" name=\"HandoverFromEUTRAPreparationRequest\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_uecc_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_uecc_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_uecc_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_uecc_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & UU))
        {
            P_RRC_TRACE(p_uecc_ue_context, set_all_trace_bitmask(),GEN_CELL,"\n <msg function=\"Uu\" name=\"HandoverFromEUTRAPreparationRequest\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_uecc_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        /*SPR 15896 Fix Stop*/
        /*SPR 15875 Fix Stop*/
    }

    /* Init ASN1 context */
    if ( RT_OK != rtInitContext(&asn1_ctx) )
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[HandoverFromEUTRAPreparationRequest] ASN context initialization failed.");
        return RRC_FAILURE;
    }

    do {
        /* Fill the values in the ASN structures that shall
         * be encoded by ASN Encoder */
        /* Set Downlink DCCH message type */
        dl_dcch_msg.message.t = T_DL_DCCH_MessageType_c1;

        /* Allocate and choose HandoverFromEUTRAPreparationRequest */
        p_dl_dcch_c1 = rtxMemAllocType(&asn1_ctx, DL_DCCH_MessageType_c1);
        if (PNULL == p_dl_dcch_c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[HandoverFromEUTRAPreparationRequest] ASN malloc failed");
            break;
        }
        dl_dcch_msg.message.u.c1 = p_dl_dcch_c1;

        p_dl_dcch_c1->t = T_DL_DCCH_MessageType_c1_handoverFromEUTRAPreparationRequest;
        p_dl_dcch_c1->u.handoverFromEUTRAPreparationRequest =
            rtxMemAllocType(&asn1_ctx, HandoverFromEUTRAPreparationRequest);

        if (PNULL == p_dl_dcch_c1->u.handoverFromEUTRAPreparationRequest)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[HandoverFromEUTRAPreparationRequest] ASN malloc failed.");
            break;
        }

        /* transaction id */
        p_dl_dcch_c1->u.handoverFromEUTRAPreparationRequest->rrc_TransactionIdentifier =
            (RRC_TransactionIdentifier)(uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context) &
                    UECC_LTE_RRC_TRANSACTION_ID_MASK);

        p_dl_dcch_c1->u.handoverFromEUTRAPreparationRequest->criticalExtensions.t =
            T_HandoverFromEUTRAPreparationRequest_criticalExtensions_c1;
        p_dl_dcch_rrc_ext_c1 =
            rtxMemAllocType(&asn1_ctx,
                    HandoverFromEUTRAPreparationRequest_criticalExtensions_c1);

        if (PNULL == p_dl_dcch_rrc_ext_c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[HandoverFromEUTRAPreparationRequest] ASN malloc failed.");
            break;
        }
        p_dl_dcch_c1->u.handoverFromEUTRAPreparationRequest->criticalExtensions.u.c1 =
            p_dl_dcch_rrc_ext_c1;

        p_dl_dcch_rrc_ext_c1->t =
            T_HandoverFromEUTRAPreparationRequest_criticalExtensions_c1_handoverFromEUTRAPreparationRequest_r8;

        p_r8 = rtxMemAllocType(&asn1_ctx, HandoverFromEUTRAPreparationRequest_r8_IEs);
        if (PNULL == p_r8)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[HandoverFromEUTRAPreparationRequest] ASN malloc failed.");
            break;
        }

        p_dl_dcch_rrc_ext_c1->u.handoverFromEUTRAPreparationRequest_r8 = p_r8;

        asn1Init_HandoverFromEUTRAPreparationRequest_r8_IEs(p_r8);

        switch( p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info->
                s1_src_ho_info.p_rrc_rrm_ho_required->ho_type)
        {
            case HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT:
                /*CR 487 changes start*/
                {
                    if (p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info->
                            s1_src_ho_info.p_rrc_rrm_ho_required->cdma2000_information.
                            bitmask & RRC_RRM_HO_REQUIRED_HO_FROM_EUTRA_PREPERATION_REQ_PRESENT)
                    {
                        if(p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info->
                                s1_src_ho_info.p_rrc_rrm_ho_required->cdma2000_information.
                                ho_from_eutra_preperation_req_r10.bitmask & 
                                RRC_RRM_HO_FROM_EUTRA_DUAL_RX_TX_REDIRECT_IND_PRESENT)
                        {
                            p_r8->m.nonCriticalExtensionPresent = 1;
                            p_r8->nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
                            p_r8->nonCriticalExtension.nonCriticalExtension.m.
                                nonCriticalExtensionPresent = 1;
                            p_r8->nonCriticalExtension.nonCriticalExtension.
                                nonCriticalExtension.m.
                                dualRxTxRedirectIndicator_r10Present = 1;

                            p_r8->nonCriticalExtension.nonCriticalExtension.
                                nonCriticalExtension.dualRxTxRedirectIndicator_r10 =
                                p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info->
                                s1_src_ho_info.p_rrc_rrm_ho_required->cdma2000_information.
                                ho_from_eutra_preperation_req_r10.dual_rx_tx_redirect_ind_r10;

                            if (p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info->
                                    s1_src_ho_info.p_rrc_rrm_ho_required->cdma2000_information.
                                    ho_from_eutra_preperation_req_r10.bitmask &
                                    RRC_RRM_HO_FROM_EUTRA_REDIRECT_CARRIER_CDMA2000_1XRTT_PRESENT)
                            {
                                p_r8->nonCriticalExtension.nonCriticalExtension.
                                    nonCriticalExtension.m.
                                    redirectCarrierCDMA2000_1XRTT_r10Present = 1;

                                p_r8->nonCriticalExtension.nonCriticalExtension.
                                    nonCriticalExtension.
                                    redirectCarrierCDMA2000_1XRTT_r10.bandClass = 
                                    p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info->
                                    s1_src_ho_info.p_rrc_rrm_ho_required->cdma2000_information.
                                    ho_from_eutra_preperation_req_r10.
                                    redirect_carrier_cdma2000_1XRTT_r10.band_class;

                                p_r8->nonCriticalExtension.nonCriticalExtension.
                                    nonCriticalExtension.
                                    redirectCarrierCDMA2000_1XRTT_r10.arfcn = 
                                    p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info->
                                    s1_src_ho_info.p_rrc_rrm_ho_required->cdma2000_information.
                                    ho_from_eutra_preperation_req_r10.
                                    redirect_carrier_cdma2000_1XRTT_r10.arfcn;
                            }
                        }
                    }
                }
                /*CR 487 changes stop*/
            case HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD:
                {
                    p_r8->m.rand_Present = RRC_TRUE;
                    /* SSITP FIX 3 start */
                    /* Fill RAND value */
                    p_r8->rand_.numbits =RAND_CDMA_NBITS ;

                    rrc_pack_U32((void*)&p_r8->rand_.data,&p_uecc_ue_context->p_gb_context->\
                            p_p_csc_context[p_uecc_ue_context->cell_index]->\
                            p_csc_init_setup_ind->cdma2000_rand);

                    /* CSR 56323/Bug8834 FIX start */
                    /* Saving the value of RAND sent to UE in
                     * handoverFromEUTRAPreparationRequest in csc_context
                     * so that same value can be sent to MME in uplink CDMA2000
                     * tunneling message to avoid any mismatch in the value
                     * between UE and network */
                    p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->cell_index]\
                        ->cdma2000_rand_val_in_use_flag = RRC_TRUE ;

                    p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->cell_index]\
                        ->cdma2000_rand_val_used = p_uecc_ue_context->p_gb_context->\
                        p_p_csc_context[p_uecc_ue_context->cell_index]\
                        ->p_csc_init_setup_ind->cdma2000_rand ;

                    /* CSR 56323/Bug8834 FIX stop */
                    p_r8->m.mobilityParametersPresent = 1;
                    /* SSITP FIX 1 start */

                    p_octet_data = (OSDynOctStr*) rrc_mem_get(sizeof(OSDynOctStr));

                    if (PNULL == p_octet_data)
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_FATAL, "Memory Allocation Failed ");
                        break;
                    }
                    memset_wrapper(p_octet_data, 0, sizeof(OSDynOctStr));

                    p_octet_data->data = (OSOCTET *)rrc_mem_get(MOBILITY_PARAMS_MAX_OCTETS);

                    if (PNULL == p_octet_data->data)
                    {
                        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                                p_uecc_ue_context->p_gb_context->facility_name,
                                RRC_INFO,
                                "Memory allocation to p_octet_data->data failed");
                        response = RRC_FAILURE;
                        /* coverity_fix_63286_start */
                        rrc_mem_free(p_octet_data);
                        /* coverity_fix_63286_stop */
                        break;
                    }
                    else
                    {
                        memset_wrapper ((void *)p_octet_data->data,0,MOBILITY_PARAMS_MAX_OCTETS);
                    }
                    /* Fill Mobility parameters */

                    rrc_form_mob_params_to_octet_string(
                            p_uecc_ue_context,
                            p_octet_data,
                            &p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info->
                            s1_src_ho_info.p_rrc_rrm_ho_required->
                            cdma2000_information.mobility_parameters,
                            &p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info->
                            s1_src_ho_info.p_rrc_rrm_ho_required->
                            cdma2000_information.add_mobility_parameters);
                    /* SSITP FIX 1 stop */
                    p_r8->mobilityParameters.numocts = p_octet_data->numocts;

                    RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,
                            "After packing p_octet_data->numocts = [%d]",p_octet_data->numocts);

                    /* Copying Octet String in ASN1 structure to send on Transport layer */

                    p_r8->mobilityParameters.data =
                        (OSOCTET*)rtxMemAlloc(&asn1_ctx,p_octet_data->numocts);

                    if (PNULL == p_r8->mobilityParameters.data)
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_ERROR, " mobilityParameters ASN malloc failed.");
                        /* coverity_fix_63286_&_63287_start */
                        rrc_mem_free((void *)(p_octet_data->data));
                        p_octet_data->data = PNULL;
                        rrc_mem_free(p_octet_data);
			/*SPR_18125_START*/
                          rtFreeContext(&asn1_ctx);
                          /*SPR_18125_END*/
                        /* coverity_fix_63286_&_63287_stop */
                        return RRC_FAILURE;
                    }


                    memset_wrapper(((void *)p_r8->mobilityParameters.data),
                            RRC_NULL,
                            p_octet_data->numocts);

                    l3_memcpy_wrapper(((void *)p_r8->mobilityParameters.data),
                            p_octet_data->data,
                            p_octet_data->numocts);

                    if (PNULL != p_octet_data->data)
                    {
                        rrc_mem_free((void *)p_octet_data->data);
                        p_octet_data->data = PNULL;
                    }
                    if (PNULL != p_octet_data)
                    {
                        rrc_mem_free(p_octet_data);
                    }



                    /* Fill CDMA2000 Type */
                    p_r8->cdma2000_Type = type1XRTT;
                    if((HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD ==
                                p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info->
                                s1_src_ho_info.p_rrc_rrm_ho_required->ho_type))
                    {
                        p_r8->m.nonCriticalExtensionPresent = 1;
                        p_r8->nonCriticalExtension.m.lateNonCriticalExtensionPresent = 0;
                        p_r8->nonCriticalExtension.m.nonCriticalExtensionPresent = 1;				
                        p_r8->nonCriticalExtension.nonCriticalExtension.m.
                            concurrPrepCDMA2000_HRPD_r9Present = 1;
                        p_r8->nonCriticalExtension.nonCriticalExtension.
                            concurrPrepCDMA2000_HRPD_r9 = RRC_TRUE;				
                        p_r8->nonCriticalExtension.nonCriticalExtension.m.
                            nonCriticalExtensionPresent = 0;	
                    }
                }
                break;
            case HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD:
                {
                    p_r8->m.rand_Present = 0;
                    p_r8->m.mobilityParametersPresent = 0;
                    /* Fill CDMA2000 Type */
                    p_r8->cdma2000_Type = typeHRPD;

                }
                break;
            default:
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "[rrcDLInformationTransfer] Invalid handover type");
	        /*SPR_18125_START*/
                rtFreeContext(&asn1_ctx);
                /*SPR_18125_END*/	
                return RRC_FAILURE;
        }

        /* TRACE_fix */
        /*SPR 15896 Fix Start*/
        if (p_uecc_ue_context->m.traceActivated)
        {
            P_RRC_TRACE(p_uecc_ue_context, set_minimum_medium_both_bitmask(), UU, "\n <ie name=\"CDMA2000-Type\">%d</ie>",p_r8->cdma2000_Type);
            P_RRC_TRACE(p_uecc_ue_context, set_minimum_medium_both_bitmask(), UU,"\n </msg> ");
            /*SPR 15896 Fix Stop*/
        }
        /* TRACE_fix */

        /* Prepare pointer on RRC internal message */
        p_srb_data_req = (rrc_uecc_llim_srb_data_req_t*)msg;

        /* ASN Encode message */
        pu_setBuffer(&asn1_ctx, p_srb_data_req->data_buffer,
                UECC_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);

        if (RT_OK != asn1PE_DL_DCCH_Message(&asn1_ctx, &dl_dcch_msg))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[HandoverFromEUTRAPreparationRequest] ASN1 encoding failed.");
            break;
        }
        else
        {
            p_srb_data_req->data_buffer_length = (rrc_counter_t)pe_GetMsgLen(&asn1_ctx);
            p_srb_data_req->transaction_id =
                (rrc_transaction_id_t)(uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context) &
                        (~UECC_NAS_TRANSACTION_ID));
            p_srb_data_req->ue_index = p_uecc_ue_context->ue_index;
            p_srb_data_req->lc_id = UECC_LTE_RRC_SRB1_LC_ID;
            p_srb_data_req->service_requested =
                UECC_LLIM_SRB_SERVICEREQUESTED_DELIVERY_STATUS_TRUE;
            p_srb_data_req->cell_index = p_uecc_ue_context->cell_index;

            rrc_asn1PrtToStr_DL_DCCH_Message(RRC_ASN,"DL_DCCH_Message",
                    &dl_dcch_msg, "HandoverFromEUTRAPreparationRequest",
                    p_srb_data_req->data_buffer, pe_GetMsgLen(&asn1_ctx));

            /* bug_8325 */
            	/*SPR 15896 Fix Start*/
        rrc_trace_max_file_write(p_uecc_ue_context,HO_FROM_EUTRA_PREP_REQ,
                p_srb_data_req->data_buffer_length, p_srb_data_req->data_buffer, UU);
	/*SPR 15896 Fix Stop*/            
            /* bug_8325 */

            /* Send message to LLIM  */
            response = uecc_rrc_send_internal_msg(
                    RRC_LLIM_MODULE_ID,
                    UECC_LLIM_SRB_DATA_REQ,
                    (U16)(sizeof(rrc_uecc_llim_srb_data_req_t) +
                        p_srb_data_req->data_buffer_length),
                    msg);

            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_INFO,"RRC_MSG: HandoverFromEUTRAPreparationRequest %s",
                    change_data_to_str(p_srb_data_req->data_buffer_length, p_srb_data_req->data_buffer));
        }


    } while (0);
    /*Check if any flag needs to be cleared*/

    /* Free ASN1 context */
    rtFreeContext(&asn1_ctx);
    /*Coverity 86974 Fix Start*/
    /*Code Removed*/
    /*Coverity 86974 Fix End*/
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_redirected_carrier_info
 *
 *   DESCRIPTION:
 *       This function builds and sends redirected carrier information for
 * 	RRCConnectionRelease message to LLIM module. (UECC_LLIM_SRB_DATA_REQ)
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
static  rrc_return_et uecc_llim_build_and_send_redirected_carrier_info
(
 uecc_ue_context_t*  p_uecc_ue_context,        /* UE context */
 RRCConnectionRelease_criticalExtensions_c1* p_dl_dcch_rrc_ext_c1,
 OSCTXT*                                      p_asn1_ctx
 )
{
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    if (0 != p_uecc_ue_context->m.redirected_carrier_info_present)
    {
        /* CR 713 changes start*/
        /*if ((0 != p_uecc_ue_context->m.connection_release_v890_ies) &&
          (p_uecc_ue_context->rrc_connection_release_v890_ies.bitmask & 
          RRC_RRM_UE_CONNECTION_RELEASE_IND_RRC_CONN_REL_V920_IES_PRESENT) &&
          (p_uecc_ue_context->rrc_connection_release_v890_ies.rrc_connection_release_v920_ies.
          bitmask & RRC_RRM_CELL_INFO_LIST_R9_PRESENT))
          {
          bitmask_cell_info_list_r9 = p_uecc_ue_context->rrc_connection_release_v890_ies.
          rrc_connection_release_v920_ies.cell_info_list_r9.bitmask;

          }            
         */
        if (RRC_SUCCESS != uecc_llim_build_asn1_redirected_carrier_info(
                    p_uecc_ue_context,
                    p_uecc_ue_context->p_redirected_carrier_info,
                    &p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->
                    redirectedCarrierInfo,
                    p_asn1_ctx))
        {
            return RRC_FAILURE;
        }
        /*SPR 15896 Fix Start*/
        if (p_uecc_ue_context->m.traceActivated)
        {
            P_RRC_TRACE(p_uecc_ue_context , set_minimum_medium_both_bitmask(), UU,"\n <ieGroup name=\"Redirection Information\">");

            /* Trace Code */
            if (RRM_REDIRECTED_CARRIER_INFO_EUTRA_PRESENT & 
                    p_uecc_ue_context->p_redirected_carrier_info->bitmask)
            {
                P_RRC_TRACE(p_uecc_ue_context,set_minimum_medium_both_bitmask(), UU,
                        "\n <ie name=\"eutran\">%d</ie>",p_uecc_ue_context->p_redirected_carrier_info->eutra );

            }
            else if (RRM_REDIRECTED_CARRIER_INFO_GERAN_PRESENT & 
                    p_uecc_ue_context->p_redirected_carrier_info->bitmask)
            {
                P_RRC_TRACE(p_uecc_ue_context, set_minimum_medium_both_bitmask(), UU,
                        "\n <ie name=\"geran\">%d</ie>",p_uecc_ue_context->p_redirected_carrier_info->geran);
            }
            else if (RRM_REDIRECTED_CARRIER_INFO_UTRA_FDD_PRESENT & 
                    p_uecc_ue_context->p_redirected_carrier_info->bitmask)
            {
                P_RRC_TRACE(p_uecc_ue_context, set_minimum_medium_both_bitmask(), UU,
                        "\n <ie name=\"utra-FDD\">%d</ie>",p_uecc_ue_context->p_redirected_carrier_info->utra_fdd);
            }
            else if (RRM_REDIRECTED_CARRIER_INFO_UTRA_TDD_PRESENT & 
                    p_uecc_ue_context->p_redirected_carrier_info->bitmask)
            {
                P_RRC_TRACE(p_uecc_ue_context, set_minimum_medium_both_bitmask(), UU,
                        "\n <ie name=\"utra-TDD\">%d</ie>",p_uecc_ue_context->p_redirected_carrier_info->utra_tdd);
            }
            else if (RRM_REDIRECTED_CARRIER_INFO_CDMA2000_HRPD_PRESENT &
                    p_uecc_ue_context->p_redirected_carrier_info->bitmask)
            {
                P_RRC_TRACE(p_uecc_ue_context, set_minimum_medium_both_bitmask(), UU,
                        "\n <ieGroup name=\"cdma2000-HRPD\">");
                P_RRC_TRACE(p_uecc_ue_context , set_minimum_medium_both_bitmask(), UU,"<ie name=\"BandClass\">%d</ie>",
                        p_uecc_ue_context->p_redirected_carrier_info->cdma2000_hrpd.band_class);

                P_RRC_TRACE(p_uecc_ue_context, set_minimum_medium_both_bitmask(), UU,"\n<ie name=\"HRPD-ARFCN\">%d</ie>",
                        p_uecc_ue_context->p_redirected_carrier_info->cdma2000_hrpd.arfcn);

                P_RRC_TRACE(p_uecc_ue_context, set_minimum_medium_both_bitmask(), UU,"\n </ieGroup>" );
            }
            else if (RRM_REDIRECTED_CARRIER_INFO_CDMA2000_1XRTT_PRESENT &
                    p_uecc_ue_context->p_redirected_carrier_info->bitmask)
            {
                /* TRACE_fix */
                P_RRC_TRACE(p_uecc_ue_context, set_minimum_medium_both_bitmask(), UU,"\n <ieGroup name=\"cdma2000-1XRTT\">");
                P_RRC_TRACE(p_uecc_ue_context, set_minimum_medium_both_bitmask(), UU,"\n <ie name=\"BandClass\">%d</ie>",
                        p_uecc_ue_context->p_redirected_carrier_info->cdma2000_1xrtt.band_class);

                P_RRC_TRACE(p_uecc_ue_context, set_minimum_medium_both_bitmask(), UU,"\n <ie name=\"1XRTT-ARFCN\">%d</ie>",
                        p_uecc_ue_context->p_redirected_carrier_info->cdma2000_1xrtt.arfcn);
                P_RRC_TRACE(p_uecc_ue_context, set_minimum_medium_both_bitmask(), UU,"\n </ieGroup> ");
                /* TRACE_fix */
            }


            P_RRC_TRACE(p_uecc_ue_context , set_minimum_medium_both_bitmask(), UU,"\n </ieGroup>");
            /*SPR 15896 Fix Stop*/
        }
        p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->
            m.redirectedCarrierInfoPresent = 1;
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_rrc_conn_rel_msg
 *
 *   DESCRIPTION:
 *       This function builds and sends idle mobility control information,
 * 	rrcConnectionRelease ies and RRC internal message  for
 * 	RRCConnectionRelease message to LLIM module.
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
static  rrc_return_et uecc_llim_build_and_send_rrc_conn_rel_msg 
(
 uecc_ue_context_t*  p_uecc_ue_context,        
 RRCConnectionRelease_criticalExtensions_c1*  p_dl_dcch_rrc_ext_c1,
 OSCTXT*                                      p_asn1_ctx
 )
{
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /* idleModeMobilityControlInfo */
    if (0 != p_uecc_ue_context->m.idle_mode_mobility_control_present)
    {
        if (RRC_SUCCESS != uecc_llim_build_asn1_idle_mode_mobility_control(
                    p_uecc_ue_context,
                    p_uecc_ue_context->p_idle_mode_mobility_control,
                    &p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->
                    idleModeMobilityControlInfo,
                    p_asn1_ctx))
        {
            return RRC_FAILURE;
        }

        p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->
            m.idleModeMobilityControlInfoPresent = 1;
    }

    /* rrcConnectionRelease v890 ies */
    if (0 != p_uecc_ue_context->m.connection_release_v890_ies)
    {
        if (RRC_SUCCESS !=
                uecc_llim_build_asn1_rrc_connection_release_v890_ies(
                    p_uecc_ue_context,
                    &p_uecc_ue_context->rrc_connection_release_v890_ies,
                    &p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->
                    nonCriticalExtension,
                    p_asn1_ctx))
        {
            return RRC_FAILURE;
        }
        p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->
            m.nonCriticalExtensionPresent = 1;
    }
    else if (p_uecc_ue_context->m.extended_wait_time_present)
    {
        p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->
            m.nonCriticalExtensionPresent = 1;
        p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->
            nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
        p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->
            nonCriticalExtension.nonCriticalExtension.m.
            nonCriticalExtensionPresent = 1;
        p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->
            nonCriticalExtension.nonCriticalExtension.
            nonCriticalExtension.m.extendedWaitTime_r10Present = 1;
        p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->
            nonCriticalExtension.nonCriticalExtension.
            nonCriticalExtension.extendedWaitTime_r10 = 
            p_uecc_ue_context->extended_wait_time;                    
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;

}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_rrc_connection_release
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : None
 *
 *   DESCRIPTION  : This function builds and sends RRCConnectionRelease message
 *                  to LLIM module. (UECC_LLIM_SRB_DATA_REQ)
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_rrc_connection_release
(
 uecc_ue_context_t*  p_uecc_ue_context        /* UE context */
 )
{
    rrc_return_et                               response = RRC_FAILURE;
    rrc_return_et                               result = RRC_SUCCESS;
    OSCTXT                                      asn1_ctx;
    rrc_uecc_llim_srb_data_req_t*               p_srb_data_req = PNULL;

    DL_DCCH_MessageType_c1*                     p_dl_dcch_c1 = PNULL;
    RRCConnectionRelease_criticalExtensions_c1* p_dl_dcch_rrc_ext_c1 = PNULL;

    DL_DCCH_Message                             dl_dcch_msg;
    /*SPR 20553 FIX START */
    U8  msg[sizeof(rrc_uecc_llim_srb_data_req_t)+UECC_MAX_ASN1_BUF_LEN_RRC_CONN_REL];
    /*SPR 20553 FIX END */
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER                       *p_event_header = PNULL;  
    U32                                         encoded_msg_len = 0;
    LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT       *p_event_rrc_protocol_err = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /*SPR 15896 Fix Start*/
    if (p_uecc_ue_context->m.traceActivated )

    {
        /*SPR 15875 Fix Start*/
        if((p_uecc_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_uecc_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_uecc_ue_context->p_ue_trace_activation_info->interfaces_to_trace & UU))
        {
            P_RRC_TRACE(p_uecc_ue_context, set_all_trace_bitmask (),GEN_MME,"\n <msg function=\"Uu\" name=\"RRC Connection Release\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_uecc_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_uecc_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_uecc_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_uecc_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & UU))
        {
            P_RRC_TRACE(p_uecc_ue_context, set_all_trace_bitmask (),GEN_CELL,"\n <msg function=\"Uu\" name=\"RRC Connection Release\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_uecc_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        /*SPR 15896 Fix Stop*/
        /*SPR 15875 Fix Stop*/
    }

    /* Init ASN1 context */
    if ( RT_OK != rtInitContext(&asn1_ctx) )
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[RRCConnectionRelease] ASN context initialization failed.");
        return RRC_FAILURE;
    }

    do {
        /* Fill the values in the ASN structures that shall
         * be encoded by ASN Encoder */
        /* Set Downlink DCCH message type */
        dl_dcch_msg.message.t = T_DL_DCCH_MessageType_c1;

        /* Allocate and choose RRCConnectionReject */
        p_dl_dcch_c1 = rtxMemAllocType(&asn1_ctx, DL_DCCH_MessageType_c1);
        if (PNULL == p_dl_dcch_c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionRelease] ASN malloc failed");
            break;
        }
        dl_dcch_msg.message.u.c1 = p_dl_dcch_c1;

        p_dl_dcch_c1->t = T_DL_DCCH_MessageType_c1_rrcConnectionRelease;
        p_dl_dcch_c1->u.rrcConnectionRelease =
            rtxMemAllocType(&asn1_ctx, RRCConnectionRelease);
        if (PNULL == p_dl_dcch_c1->u.rrcConnectionRelease)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionRelease] ASN malloc failed.");
            break;
        }

        /* transaction id */
        p_dl_dcch_c1->u.rrcConnectionRelease->rrc_TransactionIdentifier =
            (RRC_TransactionIdentifier)(uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context) &
                    UECC_LTE_RRC_TRANSACTION_ID_MASK);

        p_dl_dcch_c1->u.rrcConnectionRelease->criticalExtensions.t =
            T_RRCConnectionRelease_criticalExtensions_c1;
        p_dl_dcch_rrc_ext_c1 =
            rtxMemAllocType(&asn1_ctx,
                    RRCConnectionRelease_criticalExtensions_c1);
        if (PNULL == p_dl_dcch_rrc_ext_c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionRelease] ASN malloc failed.");
            break;
        }
        p_dl_dcch_c1->u.rrcConnectionRelease->criticalExtensions.u.c1 =
            p_dl_dcch_rrc_ext_c1;

        p_dl_dcch_rrc_ext_c1->t =
            T_RRCConnectionRelease_criticalExtensions_c1_rrcConnectionRelease_r8;
        p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8 =
            rtxMemAllocType(&asn1_ctx, RRCConnectionRelease_r8_IEs);
        if (PNULL ==  p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionRelease] ASN malloc failed.");
            break;
        }
        asn1Init_RRCConnectionRelease_r8_IEs(
                p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8);

        /* Fill rrcConnectionRelease message */

        /* Release cause */
        p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->releaseCause = other;

        if ( (T_s1ap_Cause_radioNetwork ==
                    p_uecc_ue_context->share_data.uecc_rcr_data.u.cause.t) &&
                (s1ap_load_balancing_tau_required == p_uecc_ue_context->
                 share_data.uecc_rcr_data.u.cause.u.radioNetwork) )
        {
            p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->releaseCause =
                loadBalancingTAUrequired;
        }

        /* CR 490 Changes Start */
        if ( (T_s1ap_Cause_radioNetwork ==
                    p_uecc_ue_context->share_data.uecc_rcr_data.u.cause.t) &&
                (s1ap_cs_fallback_triggered == p_uecc_ue_context->
                 share_data.uecc_rcr_data.u.cause.u.radioNetwork) && (p_uecc_ue_context->m.CsfallbackIndicator)
                && (p_uecc_ue_context->cs_fallback_indicator ==  s1ap_cs_fallback_high_priority))
        {
            if( (0 != p_uecc_ue_context->m.redirected_carrier_info_present) &&
                    ((RRM_REDIRECTED_CARRIER_INFO_UTRA_FDD_PRESENT & p_uecc_ue_context->
                      p_redirected_carrier_info->bitmask)||
                     (RRM_REDIRECTED_CARRIER_INFO_UTRA_TDD_PRESENT & p_uecc_ue_context->
                      p_redirected_carrier_info->bitmask)))
            {
                p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->releaseCause =
                    cs_FallbackHighPriority_v1020;
            }
        }
        /* CR 490 Changes End */
        if ( p_uecc_ue_context->m.CsfallbackIndicator)
        {
            /* Reset Variables */
            p_uecc_ue_context->m.CsfallbackIndicator =
                RRC_FALSE;
        }
        /*SPR 15896 Fix Start*/
        if (p_uecc_ue_context->m.traceActivated )
        {
            P_RRC_TRACE(p_uecc_ue_context , set_minimum_medium_both_bitmask(), UU,"\n<ie name=\"Release Cause\">%d</ie>",
                    p_dl_dcch_rrc_ext_c1->u.rrcConnectionRelease_r8->releaseCause );
            /*SPR 15896 Fix Stop*/
        }

        /* redirectedCarrierInfo */
        result = uecc_llim_build_and_send_redirected_carrier_info(
                p_uecc_ue_context,p_dl_dcch_rrc_ext_c1,&asn1_ctx);
        if(result==RRC_FAILURE)
        {
            break;
        }

        /* idleModeMobilityControlInfo */
        result = uecc_llim_build_and_send_rrc_conn_rel_msg(
                p_uecc_ue_context,p_dl_dcch_rrc_ext_c1,&asn1_ctx);
        if (RRC_FAILURE==result)
        {
            break;
        }

        /* Prepare pointer on RRC internal message */
        p_srb_data_req = (rrc_uecc_llim_srb_data_req_t*)msg;

        /* ASN Encode message */
        /*SPR 20553 FIX START */
        pu_setBuffer(&asn1_ctx, p_srb_data_req->data_buffer,
                UECC_MAX_ASN1_BUF_LEN_RRC_CONN_REL, ASN_RRC_BUF_TYPE);
        /*SPR 20553 FIX END */

        if (RT_OK != asn1PE_DL_DCCH_Message(&asn1_ctx, &dl_dcch_msg))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionRelease] ASN1 encoding failed.");

            /*Generating Protocol Event LOCAL_EVENT_RRC_PROTOCOL_ERROR*/
            p_event_rrc_protocol_err = rrc_mem_get(sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));
            if (PNULL != p_event_rrc_protocol_err)
            {
                memset_wrapper(p_event_rrc_protocol_err, RRC_NULL, 
                        sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));

                p_event_rrc_protocol_err->header.length = 
                    sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT);
                p_event_rrc_protocol_err->header.event_id = LOCAL_EVENT_RRC_PROTOCOL_ERROR;

                l3_strncpy_wrapper((S8 *)(p_event_rrc_protocol_err->EVENT_PARAM_RRC_MESSAGE_DISCARDED),
                        (S8 *)("RRC CONNECTION RELEASE"), RRC_MESSAGE_DISCARDED_SIZE);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_rrc_protocol_err);
            }
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_DL_DCCH_Message(RRC_ASN, "DL_DCCH_Message",
                    &dl_dcch_msg, "RRCConnectionRelease",
                    p_srb_data_req->data_buffer, encoded_msg_len);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                memset_wrapper(p_event_header, RRC_NULL, (sizeof(EVENT_EXTERNAL_HEADER) +
                            encoded_msg_len));
                rrc_uecc_fill_protocol_event_params(p_uecc_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_RRC_CONNECTION_RELEASE,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_srb_data_req->data_buffer,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }
        p_srb_data_req->data_buffer_length = (rrc_counter_t)pe_GetMsgLen(&asn1_ctx);
        p_srb_data_req->transaction_id =
            (rrc_transaction_id_t)(uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context) &
                    (~UECC_NAS_TRANSACTION_ID));
        p_srb_data_req->ue_index = p_uecc_ue_context->ue_index;
        p_srb_data_req->lc_id = UECC_LTE_RRC_SRB1_LC_ID;
        p_srb_data_req->service_requested =
            UECC_LLIM_SRB_SERVICEREQUESTED_DELIVERY_STATUS_TRUE;
        p_srb_data_req->cell_index = p_uecc_ue_context->cell_index;

        /*SPR 15896 Fix Start*/
        rrc_trace_max_file_write(p_uecc_ue_context,RRC_CONNECTION_RELEASE,p_srb_data_req->data_buffer_length,
                p_srb_data_req->data_buffer, UU);
        /*SPR 15896 Fix Stop*/

        /* Send message to LLIM  */
        response = uecc_rrc_send_internal_msg(
                RRC_LLIM_MODULE_ID,
                UECC_LLIM_SRB_DATA_REQ,
                (U16)(sizeof(rrc_uecc_llim_srb_data_req_t) +
                    p_srb_data_req->data_buffer_length),
                msg);

        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_INFO,"RRC_MSG: RRCConnectionRelease %s",
                change_data_to_str(p_srb_data_req->data_buffer_length, p_srb_data_req->data_buffer));

    } while (0);

    /*SPR 15896 Fix Start*/
    if (p_uecc_ue_context->m.traceActivated )
    {
        P_RRC_TRACE(p_uecc_ue_context, set_minimum_medium_both_bitmask(), UU,"\n </msg> ");
        /*SPR 15896 Fix Stop*/
    }

    /* clear flags in any case */
    p_uecc_ue_context->m.redirected_carrier_info_present = 0;
    p_uecc_ue_context->m.idle_mode_mobility_control_present = 0;

    /* Free the redirected Info from UE Context*/
    if (p_uecc_ue_context->p_redirected_carrier_info != PNULL)
    {
        rrc_mem_free(p_uecc_ue_context->p_redirected_carrier_info);
        p_uecc_ue_context->p_redirected_carrier_info = PNULL;
    }
    if (p_uecc_ue_context->p_idle_mode_mobility_control != PNULL)
    {
        rrc_mem_free(p_uecc_ue_context->p_idle_mode_mobility_control);
        p_uecc_ue_context->p_idle_mode_mobility_control = PNULL;
    }

    /* Free ASN1 context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_rrc_dl_information_transfer
 *   INPUT        : uecc_ue_context_t   *p_uecc_ue_context
 *                  s1ap_NAS_PDU        *p_nas_pdu
 *                  U8          dedicatedInfoType
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds and sends rrcDLInformationTransfer message
 *                  to LLIM module. (UECC_LLIM_SRB_DATA_REQ)
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_rrc_dl_information_transfer
(
 uecc_ue_context_t   *p_uecc_ue_context,        /* UE context */
 s1ap_NAS_PDU        *p_nas_pdu,
 U8 		dedicatedInfoType
 )
{
    rrc_return_et                       response = RRC_FAILURE;
    rrc_uecc_llim_srb_data_req_t*       p_srb_data_req = PNULL;

    OSCTXT                              asn1_ctx;
    DL_DCCH_Message                     dl_dcch_msg;
    DL_DCCH_MessageType_c1*             p_dl_dcch_c1 = PNULL;
    DLInformationTransfer_r8_IEs        *dlInformationTransfer_r8 = PNULL;

    U8  msg[sizeof(rrc_uecc_llim_srb_data_req_t)+UECC_MAX_ASN1_BUF_LEN];
    EVENT_EXTERNAL_HEADER                       *p_event_header = PNULL;
    U32                                         encoded_msg_len = 0;
    LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT *p_event_rrc_protocol_err = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    RRC_ASSERT(PNULL!=p_nas_pdu);

    /* Init ASN1 context */
    if ( RT_OK != rtInitContext(&asn1_ctx) )
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[rrcDLInformationTransfer] ASN context initialization failed.");
        return RRC_FAILURE;
    }

    do {
        /* Fill the values in the ASN structures that shall be encoded by ASN */
        /* Set Downlink DCCH message type */
        dl_dcch_msg.message.t = T_DL_DCCH_MessageType_c1;

        /* Allocate and choose RRCConnectionReject */
        p_dl_dcch_c1 = rtxMemAllocType(&asn1_ctx, DL_DCCH_MessageType_c1);
        if (PNULL == p_dl_dcch_c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[rrcDLInformationTransfer] ASN malloc failed.");
            break;
        }
        dl_dcch_msg.message.u.c1 = p_dl_dcch_c1;

        p_dl_dcch_c1->t = T_DL_DCCH_MessageType_c1_dlInformationTransfer;
        p_dl_dcch_c1->u.dlInformationTransfer =
            rtxMemAllocType(&asn1_ctx, DLInformationTransfer);
        if (PNULL == p_dl_dcch_c1->u.dlInformationTransfer)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[rrcDLInformationTransfer] ASN malloc failed.");
            break;
        }

        /* transaction id */
        p_dl_dcch_c1->u.dlInformationTransfer->rrc_TransactionIdentifier =
            (RRC_TransactionIdentifier) (uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context) &
                    UECC_LTE_RRC_TRANSACTION_ID_MASK);

        p_dl_dcch_c1->u.dlInformationTransfer->criticalExtensions.t =
            T_DLInformationTransfer_criticalExtensions_c1;
        p_dl_dcch_c1->u.dlInformationTransfer->criticalExtensions.u.c1 =
            rtxMemAllocType(&asn1_ctx,
                    DLInformationTransfer_criticalExtensions_c1);

        if (PNULL ==
                p_dl_dcch_c1->u.dlInformationTransfer->criticalExtensions.u.c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[rrcDLInformationTransfer] ASN malloc failed.");
            break;
        }

        p_dl_dcch_c1->u.dlInformationTransfer->criticalExtensions.u.c1->t =
            T_DLInformationTransfer_criticalExtensions_c1_dlInformationTransfer_r8;
        dlInformationTransfer_r8 =
            rtxMemAllocType(&asn1_ctx, DLInformationTransfer_r8_IEs);

        if (PNULL == dlInformationTransfer_r8)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[rrcDLInformationTransfer] ASN malloc failed.");
            break;
        }
        asn1Init_DLInformationTransfer_r8_IEs(dlInformationTransfer_r8);
        p_dl_dcch_c1->u.dlInformationTransfer->criticalExtensions.u.c1->
            u.dlInformationTransfer_r8 = dlInformationTransfer_r8;

        /* Fill rrcDLInformationTransfer message */
        dlInformationTransfer_r8->dedicatedInfoType.t = dedicatedInfoType;

        switch(dlInformationTransfer_r8->dedicatedInfoType.t)
        {
            case T_DLInformationTransfer_r8_IEs_dedicatedInfoType_dedicatedInfoNAS:
                dlInformationTransfer_r8->dedicatedInfoType.u.dedicatedInfoNAS =
                    p_nas_pdu;
                break;

            case T_DLInformationTransfer_r8_IEs_dedicatedInfoType_dedicatedInfoCDMA2000_1XRTT:
                dlInformationTransfer_r8->dedicatedInfoType.u.
                    dedicatedInfoCDMA2000_1XRTT =  p_nas_pdu;
                break;

            case T_DLInformationTransfer_r8_IEs_dedicatedInfoType_dedicatedInfoCDMA2000_HRPD:
                dlInformationTransfer_r8->dedicatedInfoType.u.
                    dedicatedInfoCDMA2000_HRPD = p_nas_pdu;
                break;

            default:
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "[rrcDLInformationTransfer] Invalid data value type");
        }			




        /* Prepare pointer on RRC internal message */
        p_srb_data_req = (rrc_uecc_llim_srb_data_req_t*)msg;

        /* ASN Encode message */
        pu_setBuffer(&asn1_ctx, p_srb_data_req->data_buffer,
                UECC_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);

        if (RT_OK != asn1PE_DL_DCCH_Message(&asn1_ctx, &dl_dcch_msg))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[rrcDLInformationTransfer] ASN1 encoding failed.");

            /*Generating Protocol Event LOCAL_EVENT_RRC_PROTOCOL_ERROR*/
            p_event_rrc_protocol_err = rrc_mem_get(sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));
            if (PNULL != p_event_rrc_protocol_err)
            {
                memset_wrapper(p_event_rrc_protocol_err, RRC_NULL, 
                        sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));

                p_event_rrc_protocol_err->header.length = 
                    sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT);
                p_event_rrc_protocol_err->header.event_id = LOCAL_EVENT_RRC_PROTOCOL_ERROR;

                l3_strncpy_wrapper((S8 *)(p_event_rrc_protocol_err->EVENT_PARAM_RRC_MESSAGE_DISCARDED),
                        (const S8 *)("RRC DL INFORMATION TRANSFER"), RRC_MESSAGE_DISCARDED_SIZE);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_rrc_protocol_err);
            }
            break;
        }
        else
        {
            /*Generating Protocol Event LOCAL_RRC_DL_INFORMATION_TRANSFER*/
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_DL_DCCH_Message(RRC_ASN, "DL_DCCH_Message",
                    &dl_dcch_msg, "DLInformationTransfer",
                    p_srb_data_req->data_buffer, encoded_msg_len);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                memset_wrapper(p_event_header, RRC_NULL, (sizeof(EVENT_EXTERNAL_HEADER) +
                            encoded_msg_len));
                rrc_uecc_fill_protocol_event_params(p_uecc_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_RRC_DL_INFORMATION_TRANSFER,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_srb_data_req->data_buffer,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        p_srb_data_req->data_buffer_length = (rrc_counter_t)pe_GetMsgLen(&asn1_ctx);

        /* Special case of transaction id for NAS non delivery indication
         * detection */
        p_srb_data_req->transaction_id = UECC_NAS_TRANSACTION_ID;

        p_srb_data_req->ue_index = p_uecc_ue_context->ue_index;
        p_srb_data_req->cell_index = p_uecc_ue_context->cell_index;

        p_srb_data_req->lc_id = UECC_LTE_RRC_SRB1_LC_ID;
        if (p_uecc_ue_context->m.srb2_created)
        {
            /* Pass it through SRB2 */
            p_srb_data_req->lc_id = UECC_LTE_RRC_SRB2_LC_ID;
        }
        p_srb_data_req->service_requested =
            UECC_LLIM_SRB_SERVICEREQUESTED_DELIVERY_STATUS_TRUE;

        /* TRACE_changes_start */
        /* SPR 16113 Start */
        uecc_rrc_ue_assoc_msg_max_trace_handler(p_uecc_ue_context, p_srb_data_req->data_buffer,
                p_srb_data_req->data_buffer_length, "Downlink Information Transfer", RRC_DL_DCCH);
        /* SPR 16113 Stop */
        /* TRACE_changes_start */

        /* Send message to LLIM  */
        response = uecc_rrc_send_internal_msg(
                RRC_LLIM_MODULE_ID,
                UECC_LLIM_SRB_DATA_REQ,
                (U16)(sizeof(rrc_uecc_llim_srb_data_req_t) +
                    p_srb_data_req->data_buffer_length),
                msg);

        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_INFO,"RRC_MSG: DLInformationTransfer %s",
                change_data_to_str(p_srb_data_req->data_buffer_length, p_srb_data_req->data_buffer));

    } while (0);

    /* Free ASN1 context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_rrc_ue_capability_enquiry
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : None
 *   DESCRIPTION  : This function builds and sends ueCapabilityEnquiry message
 *                  to LLIM module. (UECC_LLIM_SRB_DATA_REQ)
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_rrc_ue_capability_enquiry
(
 uecc_ue_context_t   *p_uecc_ue_context        /* UE context */
 )
{
    rrc_return_et                        response = RRC_FAILURE;
    rrc_uecc_llim_srb_data_req_t*        p_srb_data_req = PNULL;
    rrc_counter_t rat_type_index = 0;

    OSCTXT                               asn1_ctx;
    DL_DCCH_Message                      dl_dcch_msg;
    DL_DCCH_MessageType_c1*              p_dl_dcch_c1 = PNULL;
    UECapabilityEnquiry_r8_IEs           *p_UECapabilityEnquiry_r8 = PNULL;

    U8  msg[sizeof(rrc_uecc_llim_srb_data_req_t)+UECC_MAX_ASN1_BUF_LEN];
    EVENT_EXTERNAL_HEADER                *p_event_header = PNULL;
    U32                                  encoded_msg_len = 0;
    LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT *p_event_rrc_protocol_err = PNULL;

    RRC_ASSERT(PNULL!=p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Init ASN1 context */
    if ( RT_OK != rtInitContext(&asn1_ctx) )
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[RRCUECapabilityEnquiry] ASN context initialization failed.");
        return RRC_FAILURE;
    }

    do {
        /* Fill the values in the ASN structures that
         * shall be encoded by ASN Encoder */
        /* Set Downlink DCCH message type */
        dl_dcch_msg.message.t = T_DL_DCCH_MessageType_c1;

        p_dl_dcch_c1 = rtxMemAllocType(&asn1_ctx, DL_DCCH_MessageType_c1);
        if (PNULL == p_dl_dcch_c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCUECapabilityEnquiry] ASN malloc failed.");
            break;
        }
        dl_dcch_msg.message.u.c1 = p_dl_dcch_c1;

        p_dl_dcch_c1->t = T_DL_DCCH_MessageType_c1_ueCapabilityEnquiry;
        p_dl_dcch_c1->u.ueCapabilityEnquiry =
            rtxMemAllocType(&asn1_ctx, UECapabilityEnquiry );
        if (PNULL == p_dl_dcch_c1->u.ueCapabilityEnquiry)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCUECapabilityEnquiry] ASN malloc failed.");
            break;
        }

        /* transaction id */
        p_dl_dcch_c1->u.ueCapabilityEnquiry->rrc_TransactionIdentifier =
            (RRC_TransactionIdentifier)(uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context)
                    & UECC_LTE_RRC_TRANSACTION_ID_MASK);

        p_dl_dcch_c1->u.ueCapabilityEnquiry->criticalExtensions.t =
            T_UECapabilityEnquiry_criticalExtensions_c1;
        p_dl_dcch_c1->u.ueCapabilityEnquiry->criticalExtensions.u.c1 =
            rtxMemAllocType(&asn1_ctx, UECapabilityEnquiry_criticalExtensions_c1);
        if (PNULL ==
                p_dl_dcch_c1->u.ueCapabilityEnquiry->criticalExtensions.u.c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCUECapabilityEnquiry] ASN malloc failed.");
            break;
        }

        p_dl_dcch_c1->u.ueCapabilityEnquiry->criticalExtensions.u.c1->t =
            T_UECapabilityEnquiry_criticalExtensions_c1_ueCapabilityEnquiry_r8;
        p_UECapabilityEnquiry_r8 =
            rtxMemAllocType(&asn1_ctx, UECapabilityEnquiry_r8_IEs);
        if (PNULL == p_UECapabilityEnquiry_r8)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCUECapabilityEnquiry] ASN malloc failed.");
            break;
        }
        asn1Init_UECapabilityEnquiry_r8_IEs(p_UECapabilityEnquiry_r8);
        p_dl_dcch_c1->u.ueCapabilityEnquiry->criticalExtensions.u.c1->
            u.ueCapabilityEnquiry_r8 = p_UECapabilityEnquiry_r8;
        /* Fill ueCapabilityEnquiry message */
        if((0 == p_uecc_ue_context->rrm_ue_capability_enq_count)
#ifdef ENDC_ENABLED
           /* NR_DC Code Change Start */
           || ( RRC_ONE == p_uecc_ue_context->nr_capab_req_flag )
           /* NR_DC Code Change Stop */
#endif
          )

        {
            /* was not received from RRM sending for all rat's */
#ifdef ENDC_ENABLED
            /*NR_DC Code Change Start*/
            if ( ( RRC_ONE == p_uecc_ue_context->endcConfigInfo.enDcR15Supported ) &&
                 ( RRC_ONE == p_uecc_ue_context->nr_capab_req_flag ))
            {
                p_UECapabilityEnquiry_r8->ue_CapabilityRequest.n = 3;/*UECC_MAX_NUM_OF_UE_RAT_ENQUIRY*/;
            }
            else
            {
                p_UECapabilityEnquiry_r8->ue_CapabilityRequest.n = 5;/*UECC_MAX_NUM_OF_UE_RAT_ENQUIRY*/;
            }
            /*NR_DC Code Change Stop*/
#else
            p_UECapabilityEnquiry_r8->ue_CapabilityRequest.n = 5;/*UECC_MAX_NUM_OF_UE_RAT_ENQUIRY*/;
            p_UECapabilityEnquiry_r8->ue_CapabilityRequest.elem[0] = eutra;
            p_UECapabilityEnquiry_r8->ue_CapabilityRequest.elem[1] = utra_1;
            p_UECapabilityEnquiry_r8->ue_CapabilityRequest.elem[2] = geran_cs;
            p_UECapabilityEnquiry_r8->ue_CapabilityRequest.elem[3] = geran_ps;
            p_UECapabilityEnquiry_r8->ue_CapabilityRequest.elem[4] = cdma2000_1XRTT_1;
#endif
#ifdef ENDC_ENABLED
            /*NR_DC Code Change Start*/
            if ( ( RRC_ONE == p_uecc_ue_context->endcConfigInfo.enDcR15Supported ) &&
                 ( RRC_ONE == p_uecc_ue_context->nr_capab_req_flag ))
            {
                p_UECapabilityEnquiry_r8->ue_CapabilityRequest.elem[0] = eutra;
                p_UECapabilityEnquiry_r8->ue_CapabilityRequest.elem[1] = eutra_nr;
                p_UECapabilityEnquiry_r8->ue_CapabilityRequest.elem[2] = nr;
            }
            else
            {
                p_UECapabilityEnquiry_r8->ue_CapabilityRequest.elem[0] = eutra;
                p_UECapabilityEnquiry_r8->ue_CapabilityRequest.elem[1] = utra_1;
                p_UECapabilityEnquiry_r8->ue_CapabilityRequest.elem[2] = geran_cs;
                p_UECapabilityEnquiry_r8->ue_CapabilityRequest.elem[3] = geran_ps;
                p_UECapabilityEnquiry_r8->ue_CapabilityRequest.elem[4] = cdma2000_1XRTT_1;
            }
            /*NR_DC Code Change Stop*/
#endif
        }
        else
        {
            /* Fill ueCapabilityEnquiry message as per enquired by RRM */
            for(rat_type_index = 0;
                    rat_type_index < p_uecc_ue_context->rrm_ue_capability_enq_count;
                    rat_type_index++)
            {
                p_UECapabilityEnquiry_r8->ue_CapabilityRequest.n = 
                    p_uecc_ue_context->rrm_ue_capability_enq_count;
                p_UECapabilityEnquiry_r8->ue_CapabilityRequest.elem[rat_type_index] = 
                    p_uecc_ue_context->rrm_ue_capability_enq_list[rat_type_index];
            }   
        }


        /* Prepare pointer on RRC internal message */
        p_srb_data_req = (rrc_uecc_llim_srb_data_req_t*)msg;

        /* ASN Encode message */
        pu_setBuffer(&asn1_ctx,
                p_srb_data_req->data_buffer, UECC_MAX_ASN1_BUF_LEN,
                ASN_RRC_BUF_TYPE);

        if (RT_OK != asn1PE_DL_DCCH_Message(&asn1_ctx, &dl_dcch_msg))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCUECapabilityEnquiry] ASN1 encoding failed.");

            /*Generating Protocol Event LOCAL_EVENT_RRC_PROTOCOL_ERROR*/
            p_event_rrc_protocol_err = rrc_mem_get(sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));
            if (PNULL != p_event_rrc_protocol_err)
            {
                memset_wrapper(p_event_rrc_protocol_err, RRC_NULL, 
                        sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));

                p_event_rrc_protocol_err->header.length = 
                    sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT);
                p_event_rrc_protocol_err->header.event_id = LOCAL_EVENT_RRC_PROTOCOL_ERROR;

                l3_strncpy_wrapper((S8 *)(p_event_rrc_protocol_err->EVENT_PARAM_RRC_MESSAGE_DISCARDED),
                        (const S8 *)("RRC UE CAPABILITY ENQUIRY"), RRC_MESSAGE_DISCARDED_SIZE);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_rrc_protocol_err);
            }
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_DL_DCCH_Message(RRC_ASN,"DL_DCCH_Message",
                    &dl_dcch_msg, "UECapabilityEnquiry",
                    p_srb_data_req->data_buffer, encoded_msg_len);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                memset_wrapper(p_event_header, RRC_NULL, (sizeof(EVENT_EXTERNAL_HEADER) +
                            encoded_msg_len));
                rrc_uecc_fill_protocol_event_params(p_uecc_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_RRC_UE_CAPABILITY_ENQUIRY,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_srb_data_req->data_buffer,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        p_srb_data_req->data_buffer_length = (rrc_counter_t)pe_GetMsgLen(&asn1_ctx);
        p_srb_data_req->transaction_id =
            uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
        p_srb_data_req->ue_index = p_uecc_ue_context->ue_index;
        p_srb_data_req->lc_id = UECC_LTE_RRC_SRB1_LC_ID;
        p_srb_data_req->service_requested =
            UECC_LLIM_SRB_SERVICEREQUESTED_DELIVERY_STATUS_FALSE;
        p_srb_data_req->cell_index = p_uecc_ue_context->cell_index;

        /* TRACE_changes_start */
        /* SPR 16113 Start */
        uecc_rrc_ue_assoc_msg_max_trace_handler(p_uecc_ue_context, p_srb_data_req->data_buffer,
                p_srb_data_req->data_buffer_length, "UE Capability Enquiry", RRC_DL_DCCH);
        /* SPR 16113 Stop */
        /* TRACE_changes_start */

        /* Send message to LLIM  */
        response = uecc_rrc_send_internal_msg(
                RRC_LLIM_MODULE_ID,
                UECC_LLIM_SRB_DATA_REQ,
                (U16)(sizeof(rrc_uecc_llim_srb_data_req_t) +
                    p_srb_data_req->data_buffer_length),
                msg);

        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "RRC_MSG: UECapabilityEnquiry %s",
                change_data_to_str(p_srb_data_req->data_buffer_length, p_srb_data_req->data_buffer));

    } while (0);

    /* Free ASN1 context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_configure_security_req
 *   INPUT        : uecc_ue_context_t*  p_ue_context
 *                  rrc_bool_t          configure_integrity
 *                  rrc_bool_t          configure_ciphering
 *                  rrc_rb_direction_et direction
 *                  rrc_bool_t          switch_off
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds and sends configure security message
 *                  to LLIM module. (UECC_LLIM_CONFIGURE_SECURITY_REQ)
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_configure_security_req
(
 uecc_ue_context_t*  p_ue_context,
 rrc_bool_t          configure_integrity,
 rrc_bool_t          configure_ciphering,
 rrc_rb_direction_et direction,
 rrc_bool_t          switch_off
 )
{
    rrc_uecc_llim_configure_security_req_t uecc_llim_configure_security;
    rrc_return_et                          response = RRC_FAILURE;


    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&uecc_llim_configure_security, 0,
            sizeof(rrc_uecc_llim_configure_security_req_t));

    /* Fill message */
    uecc_llim_configure_security.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_ue_context);
    uecc_llim_configure_security.ue_index = p_ue_context->ue_index;
    uecc_llim_configure_security.cell_index = p_ue_context->cell_index;

    uecc_llim_configure_security.bitmask = 0;

    /* Add integrity protection configuration */
    if (RRC_TRUE == switch_off)
    {
        uecc_llim_configure_security.bitmask |=
            RRC_UECC_LLIM_SECURITY_CONFIG_INTEGRITY_PROTECTION_PRESENT;

        uecc_llim_configure_security.configure_integrity.algorithm_id =
            RRC_PDCP_INT_ALG_EIA0;
    }
    else if (RRC_TRUE == configure_integrity)
    {
        uecc_llim_configure_security.bitmask |=
            RRC_UECC_LLIM_SECURITY_CONFIG_INTEGRITY_PROTECTION_PRESENT;

        if (p_ue_context->configure_integrity_protection.algorithm_id ==
                RRC_PDCP_INT_ALG_EIA0)
        {
            uecc_llim_configure_security.configure_integrity.algorithm_id =
                RRC_PDCP_INT_ALG_EIA0;
        }
        else
        {
            uecc_llim_configure_security.configure_integrity =
                p_ue_context->configure_integrity_protection;
        }
    }

    /* Add ciphering configuration */
    if (RRC_TRUE == switch_off)
    {
        uecc_llim_configure_security.bitmask |=
            RRC_UECC_LLIM_SECURITY_CONFIG_CIPHERING_PRESENT;

        uecc_llim_configure_security.configure_ciphering_info.
            configure_ciphering.algorithm_id = RRC_PDCP_CIPH_ALG_EEA0;

        uecc_llim_configure_security.configure_ciphering_info.rb_direction =
            direction;
    }
    else if (RRC_TRUE == configure_ciphering)
    {
        uecc_llim_configure_security.bitmask |=
            RRC_UECC_LLIM_SECURITY_CONFIG_CIPHERING_PRESENT;

        if (p_ue_context->configure_ciphering.algorithm_id ==
                RRC_PDCP_CIPH_ALG_EEA0)
        {
            uecc_llim_configure_security.configure_ciphering_info.
                configure_ciphering.algorithm_id = RRC_PDCP_CIPH_ALG_EEA0;
        }
        else
        {
            uecc_llim_configure_security.configure_ciphering_info.
                configure_ciphering =
                p_ue_context->configure_ciphering;
        }

        uecc_llim_configure_security.configure_ciphering_info.rb_direction =
            direction;
    }

    /*SPR_17121_START*/
    /* Populate Mac-I req */
    if((direction == RRC_PDCP_RB_DIR_RX) || 
            ((direction == RRC_PDCP_RB_DIR_BOTH) && (configure_ciphering == RRC_TRUE)))
    {
        rrc_mac_i_msg_t              *p_mac_i_req = RRC_PNULL;
        uecc_llim_configure_security.bitmask |= 
            UECC_LLIM_CONFIGURE_SECURITY_MACI_REQ_PRESENT;

        p_mac_i_req = &(uecc_llim_configure_security.mac_i_req);

        rrc_populate_maci_req(p_mac_i_req, p_ue_context );
    }
    /*SPR_17121_END*/

    response = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_CONFIGURE_SECURITY_REQ,
            sizeof(rrc_uecc_llim_configure_security_req_t),
            &uecc_llim_configure_security);


    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return response;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_rrc_security_mode_command
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : None
 *
 *   DESCRIPTION  : This function builds and sends rrcSecurityModeCommand message
 *                  to LLIM module. (UECC_LLIM_SRB_DATA_REQ)
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_rrc_security_mode_command
(
 uecc_ue_context_t   *p_ue_context        /* UE context */
 )
{
    rrc_return_et                       response = RRC_FAILURE;
    rrc_uecc_llim_srb_data_req_t*       p_srb_data_req = PNULL;

    OSCTXT                              asn1_ctx;
    DL_DCCH_Message                     dl_dcch_msg;
    DL_DCCH_MessageType_c1*             p_dl_dcch_c1 = PNULL;
    SecurityModeCommand_r8_IEs          *p_r8 = PNULL;

    U8  msg[sizeof(rrc_uecc_llim_srb_data_req_t)+UECC_MAX_ASN1_BUF_LEN];
    EVENT_EXTERNAL_HEADER               *p_event_header = PNULL;
    U32                                 encoded_msg_len = 0;
    LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT *p_event_rrc_protocol_err = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);


    /* Init ASN1 context */
    if ( RT_OK != rtInitContext(&asn1_ctx) )
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[rrcSecurityModeCommand] ASN context initialization failed.");
        return RRC_FAILURE;
    }

    do {
        asn1Init_DL_DCCH_Message(&dl_dcch_msg);

        /* Fill the values in the ASN structures that shall be encoded by ASN */
        /* Set Downlink DCCH message type */
        dl_dcch_msg.message.t = T_DL_DCCH_MessageType_c1;

        /* Allocate and choose RRCConnectionReject */
        p_dl_dcch_c1 = rtxMemAllocType(&asn1_ctx, DL_DCCH_MessageType_c1);
        if (PNULL == p_dl_dcch_c1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[rrcSecurityModeCommand] ASN malloc failed.");
            break;
        }
        asn1Init_DL_DCCH_MessageType_c1(p_dl_dcch_c1);
        dl_dcch_msg.message.u.c1 = p_dl_dcch_c1;


        p_dl_dcch_c1->t = T_DL_DCCH_MessageType_c1_securityModeCommand;
        p_dl_dcch_c1->u.securityModeCommand =
            rtxMemAllocType(&asn1_ctx, SecurityModeCommand);
        if (PNULL == p_dl_dcch_c1->u.securityModeCommand)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[rrcSecurityModeCommand] ASN malloc failed.");
            break;
        }
        asn1Init_SecurityModeCommand(p_dl_dcch_c1->u.securityModeCommand);

        /* transaction id */
        p_dl_dcch_c1->u.securityModeCommand->rrc_TransactionIdentifier =
            (RRC_TransactionIdentifier)(uecc_ue_ctx_get_op_transction_id(p_ue_context) &
                    UECC_LTE_RRC_TRANSACTION_ID_MASK);

        p_dl_dcch_c1->u.securityModeCommand->criticalExtensions.t =
            T_SecurityModeCommand_criticalExtensions_c1;
        p_dl_dcch_c1->u.securityModeCommand->criticalExtensions.u.c1 =
            rtxMemAllocType(&asn1_ctx,
                    SecurityModeCommand_criticalExtensions_c1);
        if (PNULL ==
                p_dl_dcch_c1->u.securityModeCommand->criticalExtensions.u.c1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[rrcSecurityModeCommand] ASN malloc failed.");
            break;
        }
        asn1Init_SecurityModeCommand_criticalExtensions_c1(
                p_dl_dcch_c1->u.securityModeCommand->criticalExtensions.u.c1);

        p_dl_dcch_c1->u.securityModeCommand->criticalExtensions.u.c1->t =
            T_SecurityModeCommand_criticalExtensions_c1_securityModeCommand_r8;
        p_r8 = rtxMemAllocType(&asn1_ctx, SecurityModeCommand_r8_IEs);
        if (PNULL == p_r8)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[rrcSecurityModeCommand] ASN malloc failed.");
            break;
        }
        asn1Init_SecurityModeCommand_r8_IEs(p_r8);
        p_dl_dcch_c1->u.securityModeCommand->criticalExtensions.u.c1->
            u.securityModeCommand_r8 = p_r8;

        /* Fill rrcSecurityModeCommand message */

        /* securityAlgorithmConfig.integrityProtAlgorithm */
        if (RRC_PDCP_INT_ALG_EIA0 ==
                p_ue_context->configure_integrity_protection.algorithm_id)
        {
            p_r8->securityConfigSMC.securityAlgorithmConfig.
                integrityProtAlgorithm = eia0_v920;
        }
        else if (RRC_PDCP_INT_ALG_EIA1 ==
                p_ue_context->configure_integrity_protection.algorithm_id)
        {
            p_r8->securityConfigSMC.securityAlgorithmConfig.
                integrityProtAlgorithm = eia1;
        }
        else if (RRC_PDCP_INT_ALG_EIA2 ==
                p_ue_context->configure_integrity_protection.algorithm_id)
        {
            p_r8->securityConfigSMC.securityAlgorithmConfig.
                integrityProtAlgorithm = eia2;
        }
        else
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, 
                    "[rrcSecurityModeCommand] "
                    "integrityProtAlgorithm value invalid [%u]",
                    p_ue_context->configure_integrity_protection.algorithm_id);
            break;
        }

        /* securityAlgorithmConfig.cipheringAlgorithm */
        if (RRC_PDCP_CIPH_ALG_EEA0 ==
                p_ue_context->configure_ciphering.algorithm_id)
        {
            p_r8->securityConfigSMC.securityAlgorithmConfig.
                cipheringAlgorithm = eea0;
        }
        else if (RRC_PDCP_CIPH_ALG_EEA1 ==
                p_ue_context->configure_ciphering.algorithm_id)
        {
            p_r8->securityConfigSMC.securityAlgorithmConfig.
                cipheringAlgorithm = eea1;
        }
        else if (RRC_PDCP_CIPH_ALG_EEA2 ==
                p_ue_context->configure_ciphering.algorithm_id)
        {
            p_r8->securityConfigSMC.securityAlgorithmConfig.
                cipheringAlgorithm = eea2;
        }
        else
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "[rrcSecurityModeCommand] "
                    "cipheringAlgorithm value invalid [%u]",
                    p_ue_context->configure_ciphering.algorithm_id);
            break;
        }

        /* Prepare pointer on RRC internal message */
        p_srb_data_req = (rrc_uecc_llim_srb_data_req_t*)msg;

        /* ASN Encode message */
        pu_setBuffer(&asn1_ctx, p_srb_data_req->data_buffer,
                UECC_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);

        if (RT_OK != asn1PE_DL_DCCH_Message(&asn1_ctx, &dl_dcch_msg))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[rrcSecurityModeCommand] ASN1 encoding failed.");

            /*Generating Protocol Event LOCAL_EVENT_RRC_PROTOCOL_ERROR*/
            p_event_rrc_protocol_err = rrc_mem_get(sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));
            if (PNULL != p_event_rrc_protocol_err)
            {
                memset_wrapper(p_event_rrc_protocol_err, RRC_NULL, 
                        sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));

                p_event_rrc_protocol_err->header.length = 
                    sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT);
                p_event_rrc_protocol_err->header.event_id = LOCAL_EVENT_RRC_PROTOCOL_ERROR;

                l3_strncpy_wrapper((S8 *)(p_event_rrc_protocol_err->EVENT_PARAM_RRC_MESSAGE_DISCARDED),
                        (S8 *)"RRC SECURITY MODE COMMAND", RRC_MESSAGE_DISCARDED_SIZE);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_rrc_protocol_err);
            }
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_DL_DCCH_Message(RRC_ASN,"DL_DCCH_Message",
                    &dl_dcch_msg, "SecurityModeCommand",
                    p_srb_data_req->data_buffer, encoded_msg_len);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                memset_wrapper(p_event_header, RRC_NULL, (sizeof(EVENT_EXTERNAL_HEADER) +
                            encoded_msg_len));
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_RRC_SECURITY_MODE_COMMAND,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_srb_data_req->data_buffer,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        p_srb_data_req->data_buffer_length =(rrc_counter_t) pe_GetMsgLen(&asn1_ctx);
        p_srb_data_req->transaction_id =
            (rrc_transaction_id_t)(uecc_ue_ctx_get_op_transction_id(p_ue_context) &
                    (~UECC_NAS_TRANSACTION_ID));
        p_srb_data_req->ue_index = p_ue_context->ue_index;
        p_srb_data_req->lc_id = UECC_LTE_RRC_SRB1_LC_ID;
        p_srb_data_req->service_requested =
            UECC_LLIM_SRB_SERVICEREQUESTED_DELIVERY_STATUS_FALSE;
        p_srb_data_req->cell_index = p_ue_context->cell_index;

        /* TRACE_changes_start */
        /* SPR 16113 Start */
        uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_srb_data_req->data_buffer,
                p_srb_data_req->data_buffer_length, "Security Mode Command", RRC_DL_DCCH);
        /* SPR 16113 Stop */
        /* TRACE_changes_start */

        /* Send message to LLIM  */
        response = uecc_rrc_send_internal_msg(
                RRC_LLIM_MODULE_ID,
                UECC_LLIM_SRB_DATA_REQ,
                (U16)(sizeof(rrc_uecc_llim_srb_data_req_t) +
                    p_srb_data_req->data_buffer_length),
                msg);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,"RRC_MSG: SecurityModeCommand %s",
                change_data_to_str(p_srb_data_req->data_buffer_length, p_srb_data_req->data_buffer));


    } while (0);

    /* Free ASN1 context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return response;
}

/* ERB RELEASE COMMAND START */
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_delete_lc_req
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : None
 *
 *   DESCRIPTION  : Send internal message UECC_LLIM_DELETE_LC_REQ to LLIM
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_delete_lc_req
(
 uecc_ue_context_t* p_uecc_ue_context
 )
{
    U8*             p_msg = PNULL;
    rrc_return_et   rrc_response = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_msg = uecc_alloc_intrl_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_DELETE_LC_REQ,
            sizeof(rrc_uecc_llim_delete_lc_req_t));

    if (PNULL != p_msg)
    {
        uecc_llim_build_delete_lc_req(p_uecc_ue_context,
                (rrc_uecc_llim_delete_lc_req_t*)(p_msg + RRC_API_HEADER_SIZE));

        /* Send the built API to LLIM  module*/
        rrc_send_message(p_msg, RRC_LLIM_MODULE_ID);
        rrc_response = RRC_SUCCESS;
    }
    else
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,
                "Build and Send [UECC_LLIM_DELETE_LC_REQ]:Memory Allocation Failed.");
        rrc_response = RRC_FAILURE;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return rrc_response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_meas_config_req
 *   INPUT        : uecc_ue_context_t*             p_uecc_ue_context
 *                  rrc_uecc_llim_meas_config_req_t* p_rrc_uecc_llim_meas_config_req
 *   OUTPUT       : none
 *   DESCRIPTION  : Build internal message UECC_LLIM_MEAS_CONFIG_REQ
 *
 *   RETURNS      : None
 *
 ******************************************************************************/
void uecc_llim_build_meas_config_req(
        uecc_ue_context_t*             p_uecc_ue_context,
        rrc_uecc_llim_meas_config_req_t* p_rrc_uecc_llim_meas_config_req
        )
{
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_meas_config_req);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);


    /* Fill message: transaction_id */
    p_rrc_uecc_llim_meas_config_req->transaction_id =
        uecc_ue_ctx_get_meas_transction_id(p_uecc_ue_context);

    /* Fill message: ue_index */
    p_rrc_uecc_llim_meas_config_req->cell_index = 
        p_uecc_ue_context->cell_index;
    p_rrc_uecc_llim_meas_config_req->ue_index = 
        p_uecc_ue_context->ue_index;

    /* Copy received rrm_meas_config into this structure */
    l3_memcpy_wrapper(&p_rrc_uecc_llim_meas_config_req->meas_config, 
            p_uecc_ue_context->p_meas_config, sizeof(rrm_meas_config_t));

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_delete_lc_req
 *   INPUT        : uecc_ue_context_t*             p_uecc_ue_context
 *                  rrc_uecc_llim_delete_lc_req_t* p_rrc_uecc_llim_delete_lc_req
 *   OUTPUT       : none
 *   DESCRIPTION  : Build internal message UECC_LLIM_DELETE_LC_REQ
 *
 *   RETURNS      : None
 *
 ******************************************************************************/
void uecc_llim_build_delete_lc_req(
        uecc_ue_context_t*             p_uecc_ue_context,
        rrc_uecc_llim_delete_lc_req_t* p_rrc_uecc_llim_delete_lc_req
        )
{
    erab_list_t*  p_erab_list = PNULL;
    rrc_counter_t drb_index = RRC_NULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_delete_lc_req);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);


    /* Fill message */
    /* Fill message: transaction_id */
    p_rrc_uecc_llim_delete_lc_req->transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
    /* Fill message: ue_index */
    p_rrc_uecc_llim_delete_lc_req->ue_index = p_uecc_ue_context->ue_index;
    p_rrc_uecc_llim_delete_lc_req->cell_index = p_uecc_ue_context->cell_index;

    /* point to erab_release_list in erab_release_command_data */
    p_erab_list = &p_uecc_ue_context->p_curr_proc_data->u.
        erab_release_command_data.erab_release_list;

#ifndef ENDC_ENABLED
    /* Fill LC info fields */
    p_rrc_uecc_llim_delete_lc_req->delete_drb_entity_counter =
        p_erab_list->counter; 
#endif

    for(drb_index = 0;
            drb_index < p_erab_list->counter;
            drb_index++)
    {
#ifdef ENDC_ENABLED
        /*NR_DC Code Change Start*/
        /* If Bearer in ERAB to release List is SN_TERMINATED_SCG_BEARER then don't
         * send the bearer LC ID for Reconfig at Lower Layer.
         */
/* OPTION3X Chanegs Start */
        if ( !(RRC_ONE == p_uecc_ue_context->p_e_rab_list[p_erab_list->
                erab_item[drb_index].e_RAB_ID]->m.DC_BearerTypePresent &&
                SN_TERMINATED_SCG_BEARER == p_uecc_ue_context->p_e_rab_list[p_erab_list->
                                erab_item[drb_index].e_RAB_ID]->dc_bearer_type) )
/* OPTION3X Chanegs End */
        {
            /* Update LC info fields */
            p_rrc_uecc_llim_delete_lc_req->delete_drb_entity_counter++;
        /*NR_DC Code Change Stop*/
/* OPTION3X Chanegs Start */
            /* Sending DC Bearer type also along with LC ID to let LLIm judge whether
             * PDCP reconfig needs to be send or not for that LC ID (PDCP reconfig won't
             * be sebd for the LC with DC_Bearer_Type as SN_TERMINATED_SPLIT_BEARER
             */
            if(RRM_DRB_CONFIG_DC_BEARER_TYPE_PRESENT &
                    p_uecc_ue_context->p_e_rab_list[p_erab_list->
                    erab_item[drb_index].e_RAB_ID]->
                    drb_config.bitmask)
            {
                p_rrc_uecc_llim_delete_lc_req->delete_drb_entity[drb_index].
                    dc_bearer_type = p_uecc_ue_context->p_e_rab_list[p_erab_list->
                    erab_item[drb_index].e_RAB_ID]->
                    drb_config.dc_bearer_type;
                p_rrc_uecc_llim_delete_lc_req->delete_drb_entity[drb_index].
                    bitmask |=
                    UECC_LLIM_DELETE_DRB_ENTITY_DC_BEARER_TYPE_PRESENT;
            }
/* OPTION3X Chanegs End */
#endif
            p_rrc_uecc_llim_delete_lc_req->delete_drb_entity[drb_index].
                lc_id = p_uecc_ue_context->p_e_rab_list[p_erab_list->
                erab_item[drb_index].e_RAB_ID]->
                drb_config.logical_channel_identity;

            if (RRC_RLC_CONFIG_AM_CONFIG_PRESENT &
                    p_uecc_ue_context->
                    p_e_rab_list[p_erab_list->erab_item[drb_index].e_RAB_ID]->
                    drb_config.rlc_config_enb.rlc_config.bitmask)
            {
                p_rrc_uecc_llim_delete_lc_req->delete_drb_entity[drb_index].
                    rlc_mode = RLC_CONFIG_AM_MODE; 
            }
            if (RRC_RLC_CONFIG_UM_BI_DIRECTIONAL_CONFIG_PRESENT &
                    p_uecc_ue_context->
                    p_e_rab_list[p_erab_list->erab_item[drb_index].e_RAB_ID]->
                    drb_config.rlc_config_enb.rlc_config.bitmask)
            {
                p_rrc_uecc_llim_delete_lc_req->delete_drb_entity[drb_index].
                    rlc_mode = RLC_CONFIG_UM_BI_DIR_MODE;
            }
            if (RRC_RLC_CONFIG_UM_UNI_DIRECTIONAL_CONFIG_UL_PRESENT &
                    p_uecc_ue_context->
                    p_e_rab_list[p_erab_list->erab_item[drb_index].e_RAB_ID]->
                    drb_config.rlc_config_enb.rlc_config.bitmask)
            {
                p_rrc_uecc_llim_delete_lc_req->delete_drb_entity[drb_index].
                    rlc_mode = RLC_CONFIG_UM_UL_UNI_DIR_MODE;
            }
            if (RRC_RLC_CONFIG_UM_UNI_DIRECTIONAL_CONFIG_DL_PRESENT &
                    p_uecc_ue_context->
                    p_e_rab_list[p_erab_list->erab_item[drb_index].e_RAB_ID]->
                    drb_config.rlc_config_enb.rlc_config.bitmask)
            {
                p_rrc_uecc_llim_delete_lc_req->delete_drb_entity[drb_index].
                    rlc_mode = RLC_CONFIG_UM_DL_UNI_DIR_MODE;
            }

#ifdef ENDC_ENABLED
        /*NR_DC Code Change Start*/
        }
        /*NR_DC Code Change Stop*/
#endif

    }

    /*SPR_19066_START*/
    if(p_uecc_ue_context->m.ue_inactive_time_updated)
    {
        p_rrc_uecc_llim_delete_lc_req->bitmask |= UECC_LLIM_DELETE_LC_REQ_UE_INACTIVITY_TIMER_PRESENT; 
        p_rrc_uecc_llim_delete_lc_req->ue_inactivity_timer.ue_inactive_time_config =
            p_uecc_ue_context->ue_inactive_time;

    }
    /*SPR_19066_END*/
    /* SPR 20747 Fix Start */  
     if((p_uecc_ue_context->m.is_sps_recv_frm_rrm) && 
          (p_uecc_ue_context->m.is_sps_setup_or_rel_recv) &&
               (PNULL != p_uecc_ue_context->p_sps_config))
      {   
          /*SPR_19066_START*/
          p_rrc_uecc_llim_delete_lc_req->bitmask  |=
                    UECC_LLIM_DELETE_LC_REQ_SPS_CONFIG_PRESENT;
          /*SPR_19066_END*/
          if (p_uecc_ue_context->p_sps_config->bitmask &
                    RRC_SPS_CONFIG_SPS_CONFIG_DL_PRESENT)
          {
              p_rrc_uecc_llim_delete_lc_req->sps_config.bitmask |= 
                                  RRC_SPS_CONFIG_SPS_CONFIG_DL_PRESENT;
              p_rrc_uecc_llim_delete_lc_req->sps_config.
                                  sps_config_dl.bitmask = 0;
          }
          if (p_uecc_ue_context->p_sps_config->bitmask &
                    RRC_SPS_CONFIG_SPS_CONFIG_UL_PRESENT)
          {
              p_rrc_uecc_llim_delete_lc_req->sps_config.bitmask |= 
                                RRC_SPS_CONFIG_SPS_CONFIG_UL_PRESENT;
              p_rrc_uecc_llim_delete_lc_req->sps_config.
                                  sps_config_ul.bitmask = 0;
          }
      }
    /* SPR 20747 Fix End */  
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_delete_lc_resp
 *   INPUT        : void*                p_api
 *                  uecc_gb_context_t*   p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function processes LLIM UECC_LLIM_DELETE_LC_RESP message
 *
 *   RETURNS      : None
 *
 ******************************************************************************/
void uecc_llim_process_delete_lc_resp
(
 void*                p_api,             /* Input API buffer */
 uecc_gb_context_t*   p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*                 p_ue_context = PNULL;
    rrc_uecc_llim_delete_lc_resp_t*    p_llim_delete_lc_resp = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_delete_lc_resp = (rrc_uecc_llim_delete_lc_resp_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_delete_lc_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_delete_lc_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_DELETE_LC_RESP] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context, p_llim_delete_lc_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_DELETE_LC_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Check transaction_id */
    if (p_llim_delete_lc_resp->transaction_id !=
            uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /* Error. Invalid transaction id */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_DELETE_LC_RESP] Invalid transaction id.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_EV_LLIM_RECONFIGURE_UE_RESP event handler in ERB RELEASE FSM *
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_RECONFIGURE_UE_RESP,
            p_llim_delete_lc_resp); /* stack variable to store api */

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

}

/* ERB RELEASE COMMAND END */

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_modify_lc_req
 *   INPUT        : uecc_gb_context_t*   p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       Send internal message UECC_LLIM_MODIFY_LC_REQ to LLIM
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_modify_lc_req
(
 uecc_ue_context_t *p_uecc_ue_context
 )
{
    U8*             p_msg = PNULL;

    rrc_return_et   rrc_response = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_msg = uecc_alloc_intrl_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_MODIFY_LC_REQ,
            sizeof(rrc_uecc_llim_modify_lc_req_t));

    if (PNULL != p_msg)
    {
        rrc_response = uecc_llim_build_modify_lc_req(
                p_uecc_ue_context,
                (rrc_uecc_llim_modify_lc_req_t*)
                (p_msg + RRC_API_HEADER_SIZE));
        if (RRC_SUCCESS == rrc_response)
        {
            /* Send the built API to LLIM  module*/
            rrc_send_message(p_msg, RRC_LLIM_MODULE_ID);
            rrc_response = RRC_SUCCESS;
        }
        else
        {
            /* coverity_fix_48258_start */
            rrc_msg_mem_free((void *)p_msg);
            /* Coverity ID 85919 Fix Start*/
            /*		p_msg = PNULL; */
            /* Coverity ID 85919 Fix End*/
            /* coverity_fix_48258_stop */
        }
    }
    else
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_MODIFY_LC_RESP] Memory Allocation Failure.");
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return rrc_response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_fill_radio_rsource_config_for_rollback_for_ue_reconfig
 *   INPUT        : uecc_gb_context_t*   p_uecc_gb_context
 rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 *   OUTPUT       : none
 *
 *   DESCRIPTION  : Fills Radio Resource Config Info for Rollback during Reconfiguration
 *                  of lower layers via LLIM during RRM initiated UE Reconfiguration 
 *                  Procedure
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_fill_radio_rsource_config_for_rollback_for_ue_reconfig
(
 uecc_ue_context_t*  p_uecc_ue_context,
 rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 )
{
    rrm_ue_reconfig_request_data_t  *p_rrm_ue_reconfig_request_data = PNULL;
    rrc_return_et   rrc_response = RRC_SUCCESS;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_modify_lc_req);

    p_rrm_ue_reconfig_request_data =&(p_uecc_ue_context->p_curr_proc_data->
            u.rrm_ue_reconfig_request_data);

    /* mac_config */
    if (p_rrm_ue_reconfig_request_data->m.mac_config_updated)
    {
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_MAC_CONFIG_PRESENT;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].mac_config = 
            p_uecc_ue_context->mac_config;
    }

    /* phy dedicated config */
    if(p_rrm_ue_reconfig_request_data->m.physical_config_dedicated_updated)
    {
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_PHY_CONFIG_DEDICATED_PRESENT;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].physical_config_dedicated = 
            p_uecc_ue_context->physical_config_dedicated;
    } 

    if(p_rrm_ue_reconfig_request_data->m.scell_config_updated)
    {
        if(PNULL != 
                p_uecc_ue_context->p_scell_config)
        {
            p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                [RRC_UECC_OLD_DRB_CONFIG_VERSION].bitmask |=
                UECC_LLIM_MODIFY_LC_REQ_SCELL_CONFIG_PRESENT;

            l3_memcpy_wrapper(&(p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                        [RRC_UECC_OLD_DRB_CONFIG_VERSION].scell_config),
                    p_uecc_ue_context->p_scell_config,
                    sizeof(rrm_scell_config_t));


            l3_memcpy_wrapper((p_rrc_uecc_llim_modify_lc_req->scells_operation_list),
                    p_uecc_ue_context->scells_operation_list,
                    MAX_NUM_CELLS*sizeof(scells_operation_list_t));
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return rrc_response;
}

/*CA_RE_ESTAB_START*/
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_fill_phy_and_scell_config_info
 *   INPUT        : uecc_ue_context_t*             p_uecc_ue_context
 *                  rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 *   OUTPUT       : none
 *   DESCRIPTION  : Fills Radio Resource Config Info to be sent to the lower layers 
 *                  via LLIM during RRM initiated UE Reconfiguration Procedure
 *
 *   RETURNS      : None
 *
 ******************************************************************************/
void uecc_llim_fill_phy_and_scell_config_info
(
 uecc_ue_context_t*             p_uecc_ue_context, /*UECC UE Context*/
 rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req /*trg*/
 ) 
{
    U8   count = RRC_NULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_modify_lc_req);

    if (p_uecc_ue_context->m.mac_config_present)
    {
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_MAC_CONFIG_PRESENT;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].mac_config = 
            p_uecc_ue_context->mac_config;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_MAC_CONFIG_PRESENT;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].mac_config = 
            p_uecc_ue_context->mac_config;
    }

    if (p_uecc_ue_context->m.physical_config_dedicated_present)
    {
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_PHY_CONFIG_DEDICATED_PRESENT;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].physical_config_dedicated = 
            p_uecc_ue_context->physical_config_dedicated;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_PHY_CONFIG_DEDICATED_PRESENT;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].physical_config_dedicated = 
            p_uecc_ue_context->physical_config_dedicated;
    }

    if (RRC_TRUE == p_uecc_ue_context->m.scell_config_present)
    {
        if(PNULL !=
                p_uecc_ue_context->p_scell_config)
        {
            p_rrc_uecc_llim_modify_lc_req->add_scell_info_mac_phy = RRC_TRUE;
            p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                [RRC_UECC_NEW_DRB_CONFIG_VERSION].bitmask |=
                UECC_LLIM_MODIFY_LC_REQ_SCELL_CONFIG_PRESENT;

            l3_memcpy_wrapper(&(p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                        [RRC_UECC_NEW_DRB_CONFIG_VERSION].scell_config),
                    p_uecc_ue_context->p_scell_config,
                    sizeof(rrm_scell_config_t));

            p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                [RRC_UECC_OLD_DRB_CONFIG_VERSION].bitmask |=
                UECC_LLIM_MODIFY_LC_REQ_SCELL_CONFIG_PRESENT;

            l3_memcpy_wrapper(&(p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                        [RRC_UECC_OLD_DRB_CONFIG_VERSION].scell_config),
                    p_uecc_ue_context->p_scell_config,
                    sizeof(rrm_scell_config_t));

            memset_wrapper((p_rrc_uecc_llim_modify_lc_req->scells_operation_list),
                    RRC_NULL,
                    MAX_NUM_CELLS*sizeof(scells_operation_list_t));
            if (p_uecc_ue_context->p_scell_config->bitmask & 
                    RRM_SCELL_ADD_MOD_LIST_PRESENT)
            {
                for (count = RRC_NULL; count < p_uecc_ue_context->p_scell_config->
                        scell_add_mod_list.count; count++)
                {
                    p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                        [RRC_UECC_NEW_DRB_CONFIG_VERSION].scell_config.
                        scell_add_mod_list.rrc_scell_to_add_mod[count].
                        bitmask |= 
                        RRM_SCELL_ADD_MOD_MAC_SCELL_CONFIG_EXTENSION_SCELL_PRESENT;

                    p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                        [RRC_UECC_NEW_DRB_CONFIG_VERSION].scell_config.
                        scell_add_mod_list.rrc_scell_to_add_mod[count].
                        mac_main_config_extensions.bitmask |= 
                        RRM_MAC_SCELL_ACTIVATE_STATUS_PRESENT;

                    p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                        [RRC_UECC_NEW_DRB_CONFIG_VERSION].scell_config.
                        scell_add_mod_list.rrc_scell_to_add_mod[count].
                        mac_main_config_extensions.scell_activate_status =
                        SCELL_NOT_ACTIVATED;
                }

            }

        }
    }
    /*setting ue category for r10 in uecontext*/
    if(p_uecc_ue_context->rel10_ue_category >= 6 && 
            p_uecc_ue_context->rel10_ue_category <=8)
    {
        p_rrc_uecc_llim_modify_lc_req->bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_R10_UE_CATEGORY_PRESENT;
        p_rrc_uecc_llim_modify_lc_req->rel10_ue_category = 
            p_uecc_ue_context->rel10_ue_category;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return;
}
/*CA_RE_ESTAB_STOP*/

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_fill_to_be_modified_radio_rsource_config_for_ue_reconfig
 *   INPUT        : uecc_ue_context_t*             p_uecc_ue_context
 *                  rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 *   OUTPUT       : none
 *   DESCRIPTION  : Fills Radio Resource Config Info to be sent to the lower layers 
 *                  via LLIM during RRM initiated UE Reconfiguration Procedure
 *
 *   RETURNS      : None
 *
 ******************************************************************************/
void uecc_llim_fill_to_be_modified_radio_rsource_config_for_ue_reconfig
(
 uecc_ue_context_t*             p_uecc_ue_context,
 rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 ) 
{
    rrm_ue_reconfig_request_data_t  *p_rrm_ue_reconfig_request_data = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_modify_lc_req);

    p_rrm_ue_reconfig_request_data =&(p_uecc_ue_context->p_curr_proc_data->
            u.rrm_ue_reconfig_request_data);

    if(p_rrm_ue_reconfig_request_data->m.mac_config_updated)
    {
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_MAC_CONFIG_PRESENT;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].mac_config = 
            p_rrm_ue_reconfig_request_data->mac_config;
    }

    if(p_rrm_ue_reconfig_request_data->m.physical_config_dedicated_updated)
    {
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_PHY_CONFIG_DEDICATED_PRESENT;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].physical_config_dedicated = 
            p_rrm_ue_reconfig_request_data->physical_config_dedicated;
    }


    if(p_rrm_ue_reconfig_request_data->m.scell_config_updated)
    {

        if(PNULL !=
                p_rrm_ue_reconfig_request_data->p_scell_config)
        {
            p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                [RRC_UECC_NEW_DRB_CONFIG_VERSION].bitmask |=
                UECC_LLIM_MODIFY_LC_REQ_SCELL_CONFIG_PRESENT;

            l3_memcpy_wrapper(&(p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                        [RRC_UECC_NEW_DRB_CONFIG_VERSION].scell_config),
                    p_rrm_ue_reconfig_request_data->p_scell_config,
                    sizeof(rrm_scell_config_t));

            l3_memcpy_wrapper((p_rrc_uecc_llim_modify_lc_req->scells_operation_list),
                    p_uecc_ue_context->scells_operation_list,
                    MAX_NUM_CELLS*sizeof(scells_operation_list_t));

        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_fill_to_be_modified_radio_rsource_config_for_ue_ctx_mod
 *   INPUT        : uecc_ue_context_t*             p_uecc_ue_context
 *                  rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 *   OUTPUT       : none
 *   DESCRIPTION  : Fills Radio Resource Config Info to be sent to the lower layers 
 *                  via LLIM during RRM initiated UE Context Modification Procedure
 *                  for AMBR
 *   RETURNS      : None
 ******************************************************************************/
void uecc_llim_fill_to_be_modified_radio_rsource_config_for_ue_ctx_mod
(
 uecc_ue_context_t*             p_uecc_ue_context,
 rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 ) 
{
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_modify_lc_req);

    if(p_uecc_ue_context->p_curr_proc_data->m.AggMaxBitRate)
    {
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_UE_AMBR_PRESENT;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].ue_ambr.dl_ambr =
            (U32)p_uecc_ue_context->p_curr_proc_data->\
            ue_aggregate_maximum_bitrate.uEaggregateMaximumBitRateDL; 

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].ue_ambr.ul_ambr =
            (U32)p_uecc_ue_context->p_curr_proc_data->\
            ue_aggregate_maximum_bitrate.uEaggregateMaximumBitRateUL; 
    }


    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return;
}
/*securitykey*/
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_fill_to_be_modified_radio_rsource_config_for_ue_ctx_mod_for_rollback
 *   INPUT        : uecc_ue_context_t*             p_uecc_ue_context
 *                  rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 *   OUTPUT       : none
 *   DESCRIPTION  : Fills Radio Resource Config Info to be sent to the lower layers 
 *                  via LLIM during RRM initiated UE Context Modification Procedure
 *                  for AMBR for rollback
 *   RETURNS      : None
 ******************************************************************************/
void uecc_llim_fill_to_be_modified_radio_rsource_config_for_ue_ctx_mod_for_rollback
(
 uecc_ue_context_t*             p_uecc_ue_context,
 rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 ) 
{
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_modify_lc_req);

    if(p_uecc_ue_context->p_curr_proc_data->m.AggMaxBitRate)
    {
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_UE_AMBR_PRESENT;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].ue_ambr.dl_ambr =
            (U32)p_uecc_ue_context->
            ue_aggregate_maximum_bitrate.uEaggregateMaximumBitRateDL; 

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].ue_ambr.ul_ambr =
            (U32)p_uecc_ue_context->
            ue_aggregate_maximum_bitrate.uEaggregateMaximumBitRateUL;

    }


    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return;
}
/*securitykey*/
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_modify_lc_req
 *   INPUT        : uecc_ue_context_t*              p_uecc_ue_contex
 *                  rrc_uecc_llim_modify_lc_req_t*  p_rrc_uecc_llim_modify_lc_req
 *   OUTPUT       : none
 *   DESCRIPTION  : Build internal message UECC_LLIM_MODIFY_LC_REQ
 *
 *   RETURNS      : None
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_modify_lc_req
(
 uecc_ue_context_t*              p_uecc_ue_context,
 rrc_uecc_llim_modify_lc_req_t*  p_rrc_uecc_llim_modify_lc_req
 )
{
    /* GDB Fix - compiler warning */
    S8*             s_id = PNULL;
    rrc_return_et   rrc_response = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_modify_lc_req);

    /* Fill message */
    p_rrc_uecc_llim_modify_lc_req->transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    p_rrc_uecc_llim_modify_lc_req->ue_index = p_uecc_ue_context->ue_index;

    p_rrc_uecc_llim_modify_lc_req->cell_index = p_uecc_ue_context->cell_index;

    s_id = p_uecc_ue_context->uecc_fsm.proc_descriptor.p_active_proc->s_id;
    if(!(strncmp_wrapper((const S8 *)s_id,(const S8 *)"UE_ERABMOD_P",
                    strlen_wrapper((const Char8 *)s_id))))
    {
        /* Fill the DRB info fields received from the MME */
        uecc_llim_fill_to_be_modified_radio_rsource_config(p_uecc_ue_context, 
                p_rrc_uecc_llim_modify_lc_req);

        /* Fill the existing DRB configuration info fields for rollback */
        rrc_response = uecc_llim_fill_radio_rsource_config_for_rollback(
                p_uecc_ue_context, 
                p_rrc_uecc_llim_modify_lc_req);    
    }
    else if(!(strncmp_wrapper((const S8 *)s_id,(const S8 *)"UE_RRM_UE_RECONFIG_P",
                    strlen_wrapper((const Char8 *)s_id))))
    {
        /* Fill the UE Reconfiguration fields received from the RRM */
        uecc_llim_fill_to_be_modified_radio_rsource_config_for_ue_reconfig(
                p_uecc_ue_context, 
                p_rrc_uecc_llim_modify_lc_req);

        /* Fill the UE Reconfiguration fields for rollback */
        rrc_response = uecc_llim_fill_radio_rsource_config_for_rollback_for_ue_reconfig(
                p_uecc_ue_context, 
                p_rrc_uecc_llim_modify_lc_req);

        /*CA_START*/
        if(p_uecc_ue_context->rel10_ue_category >= 6 && 
                p_uecc_ue_context->rel10_ue_category <=8)
        {
            p_rrc_uecc_llim_modify_lc_req->bitmask |=
                UECC_LLIM_MODIFY_LC_REQ_R10_UE_CATEGORY_PRESENT;
            p_rrc_uecc_llim_modify_lc_req->rel10_ue_category = 
                p_uecc_ue_context->rel10_ue_category;
        }
        /*CA_STOP*/
    }
    else if(!(strncmp_wrapper((const S8 *)s_id,(const S8 *)"UE_CONTXTMOD_P",
                    strlen_wrapper((const Char8 *)s_id))))
    {
        /* Fill the UL and DL AMBR received from the MME for ue_ctx_mod */
        uecc_llim_fill_to_be_modified_radio_rsource_config_for_ue_ctx_mod(
                p_uecc_ue_context, 
                p_rrc_uecc_llim_modify_lc_req);
        /*securitykey*/            
        uecc_llim_fill_to_be_modified_radio_rsource_config_for_ue_ctx_mod_for_rollback(
                p_uecc_ue_context, 
                p_rrc_uecc_llim_modify_lc_req);
        /*securitykey*/
        rrc_response = RRC_SUCCESS;
    }
    /*CA_RE_ESTAB_START*/
    /*fill the scell configuration incase of reestablishment is ongoing*/
    else if (!(strncmp_wrapper((const S8 *)s_id,(const S8 *)"CRE_P",
                    strlen_wrapper((const Char8 *)s_id))))
    {
        uecc_llim_fill_phy_and_scell_config_info(p_uecc_ue_context,
                p_rrc_uecc_llim_modify_lc_req);
        rrc_response = RRC_SUCCESS;
    }
    /*CA_RE_ESTAB_STOP*/


    /* SPS Start */
    if (p_uecc_ue_context->m.sps_config_updated)
    {
        p_rrc_uecc_llim_modify_lc_req->bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_SPS_CONFIG_PRESENT;

        uecc_llim_fill_sps_config(
                p_uecc_ue_context->p_sps_config,
                &p_rrc_uecc_llim_modify_lc_req->sps_config);

    }
    /* SPS Stop */

    /*SPR_19066_START*/
    if(p_uecc_ue_context->m.ue_inactive_time_updated)
    {
        p_rrc_uecc_llim_modify_lc_req->bitmask |=
          UECC_LLIM_MODIFY_LC_REQ_UE_INACTIVITY_TIMER_PRESENT;
        p_rrc_uecc_llim_modify_lc_req->ue_inactivity_timer.ue_inactive_time_config =
            p_uecc_ue_context->ue_inactive_time;

    }
    /*SPR_19066_END*/

    /* SPS Stop */
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return rrc_response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_fill_to_be_modified_radio_rsource_config
 *   INPUT        : uecc_ue_context_t*              p_uecc_ue_contex
 *                  rrc_uecc_llim_modify_lc_req_t*  p_rrc_uecc_llim_modify_lc_req
 *   OUTPUT       : none
 *
 *   DESCRIPTION  : Fills DRB info to be sent to the lower layers via LLIM
 *
 *   RETURNS      : None
 *
 ******************************************************************************/
void uecc_llim_fill_to_be_modified_radio_rsource_config
(
 uecc_ue_context_t*             p_uecc_ue_context,
 rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 ) 
{
    U8 rab_id = RRC_NULL;
    erab_modify_request_data_t  *p_erab_modify_request_data = PNULL;
    erab_modify_list_t  *p_modify_list = PNULL; /*contains the modified RABInfo 
                                                  (DRBInfo) recived from RRM */
    erab_to_be_modified_list_t  
        *p_erab_to_be_modify = PNULL; /*contains the modified 
                                        RABInfo (QOSInfo) received from MME*/

    rrc_counter_t drb_index        = RRC_NULL;
    rrc_counter_t count            = RRC_NULL;
    rrc_counter_t e_rab_list_count = RRC_NULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_modify_lc_req);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_erab_modify_request_data =&(p_uecc_ue_context->p_curr_proc_data->
            u.erab_modify_request_data);

    p_modify_list = &(p_erab_modify_request_data->erab_modify_list);

    p_erab_to_be_modify = &(p_erab_modify_request_data->
            erab_to_be_modified_list);

    e_rab_list_count = p_modify_list->erab_modify_list_counter;

    p_rrc_uecc_llim_modify_lc_req->
        modify_drb_entity[RRC_UECC_NEW_DRB_CONFIG_VERSION].
        drb_counter = e_rab_list_count;

    for(drb_index = 0; (drb_index < e_rab_list_count) &&
            (drb_index < RRC_UECC_LLIM_MAX_DRB ); drb_index++)
    {
        rab_id = p_modify_list->erab_modify_item[drb_index].drb_config.erab_id;

        /* drb_config */
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].uecc_llim_drb_config[drb_index].
            drb_config = p_modify_list->erab_modify_item[drb_index].drb_config;
        /*Qos changes START*/        
        /*Fill the BearerType info from Ue_context for the modified Rab
         * this is because bearer_type is a optional parameter from RRM
         * and can never be modidied for a RAB*/
        if (rab_id == p_uecc_ue_context->p_e_rab_list[rab_id]->e_RAB_ID)
        {
            p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                [RRC_UECC_NEW_DRB_CONFIG_VERSION].uecc_llim_drb_config[drb_index].
                drb_config.bitmask |= RRM_DRB_CONFIG_BEARER_TYPE_PRESENT;

            p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                [RRC_UECC_NEW_DRB_CONFIG_VERSION].uecc_llim_drb_config[drb_index].
                drb_config.bearer_type = p_uecc_ue_context->p_e_rab_list[rab_id]->
                drb_config.bearer_type;

            /* SPR 14387 Fix Start */
            if ( ( RRM_DRB_CONFIG_S1U_CONFIG_PRESENT &
                        p_uecc_ue_context->p_e_rab_list[rab_id]->drb_config.bitmask ) &&
                    ( RRM_DRB_CONFIG_S1U_CONFIG_PRESENT & 
                      p_modify_list->erab_modify_item[drb_index].drb_config.bitmask ) )
            {
                if ( RRC_NULL == memcmp_wrapper (&p_uecc_ue_context->p_e_rab_list[rab_id]->
                            drb_config.s1u_config, &p_modify_list->erab_modify_item[drb_index].
                            drb_config.s1u_config, sizeof(rrm_s1u_config_t) ) )
                {
                    p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                        [RRC_UECC_NEW_DRB_CONFIG_VERSION].uecc_llim_drb_config[drb_index].
                        drb_config.bitmask = (rrc_bitmask_t)p_rrc_uecc_llim_modify_lc_req->
                        modify_drb_entity[RRC_UECC_NEW_DRB_CONFIG_VERSION].uecc_llim_drb_config[drb_index].
                        drb_config.bitmask & ~RRM_DRB_CONFIG_S1U_CONFIG_PRESENT;
                }
            } 
            /* SPR 14387 Fix Stop */
        }


        /* Fill gbr_qos_info from p_erab_to_be_modify received from MME*/
        for (count = 0; count < 
                p_erab_to_be_modify->erab_to_be_modified_list_counter; count++)
        {
            /*Fills the QCI value and set the bitmask*/
            p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                [RRC_UECC_NEW_DRB_CONFIG_VERSION].uecc_llim_drb_config[drb_index].
                bitmask |= UECC_LLIM_DRB_CONFIG_QOS_INFO_PRESENT;

            p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                [RRC_UECC_NEW_DRB_CONFIG_VERSION].uecc_llim_drb_config[drb_index].
                qos_info.qci = 
                p_erab_to_be_modify->erab_to_be_modified_item[count].
                e_RABlevelQoSParameters.qCI;
            /* Match the Rab-ID received from RRM and MME and then if GBR_QOS
             * info is present then update the info in
             * rrc_uecc_llim_modify_lc_req_t */
            if ((rab_id == p_erab_to_be_modify->
                        erab_to_be_modified_item[count].e_RAB_ID) &&
                    (p_erab_to_be_modify->erab_to_be_modified_item[count].
                     e_RABlevelQoSParameters.m.gbrQosInformationPresent))
            {
                /* SPR:7369 start*/
                if(BEARER_TYPE_GBR ==
                        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                        [RRC_UECC_NEW_DRB_CONFIG_VERSION].uecc_llim_drb_config[drb_index].
                        drb_config.bearer_type)
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,
                            "gbr info present in uecc_llim.c");
                    /* SPR:7369 stop*/


                    /* Fills the GBR_QOS_INFO */
                    p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                        [RRC_UECC_NEW_DRB_CONFIG_VERSION].uecc_llim_drb_config[drb_index].
                        qos_info.bitmask |= RRC_GBR_QOS_INFO_PRESENT; 

                    p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                        [RRC_UECC_NEW_DRB_CONFIG_VERSION].uecc_llim_drb_config[drb_index].
                        qos_info.gbr_qos_info.dl_mbr = 
                        (U32)p_erab_to_be_modify->erab_to_be_modified_item[count].
                        e_RABlevelQoSParameters.gbrQosInformation.e_RAB_MaximumBitrateDL;

                    p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                        [RRC_UECC_NEW_DRB_CONFIG_VERSION].uecc_llim_drb_config[drb_index].
                        qos_info.gbr_qos_info.ul_mbr = 
                        (U32)p_erab_to_be_modify->erab_to_be_modified_item[count].
                        e_RABlevelQoSParameters.gbrQosInformation.e_RAB_MaximumBitrateUL;

                    p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                        [RRC_UECC_NEW_DRB_CONFIG_VERSION].uecc_llim_drb_config[drb_index].
                        qos_info.gbr_qos_info.dl_gbr = 
                        (U32)p_erab_to_be_modify->erab_to_be_modified_item[count].
                        e_RABlevelQoSParameters.gbrQosInformation.e_RAB_GuaranteedBitrateDL;

                    p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
                        [RRC_UECC_NEW_DRB_CONFIG_VERSION].uecc_llim_drb_config[drb_index].
                        qos_info.gbr_qos_info.ul_gbr = 
                        (U32)p_erab_to_be_modify->erab_to_be_modified_item[count].
                        e_RABlevelQoSParameters.gbrQosInformation.e_RAB_GuaranteedBitrateUL;
                    continue;
                    /* SPR:7369 start*/
                }
                /* SPR:7369 stop*/

            }
        }
    }

    /* Filling the UE-AMBR info*/
    if(p_erab_modify_request_data->m.ue_ambr_present)
    {
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].ue_ambr.ul_ambr = 
            (U32)p_erab_modify_request_data->ue_aggregate_maximum_bitrate.
            uEaggregateMaximumBitRateUL;
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].ue_ambr.dl_ambr = 
            (U32)p_erab_modify_request_data->ue_aggregate_maximum_bitrate.
            uEaggregateMaximumBitRateDL;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].bitmask |= 
            UECC_LLIM_MODIFY_LC_REQ_UE_AMBR_PRESENT;
    }
    /*Qos changes END*/        

    /* mac_config */
    if (p_erab_modify_request_data->m.mac_config_updated )
    {
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_MAC_CONFIG_PRESENT;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].mac_config = 
            p_erab_modify_request_data->mac_config;
    }
    /* meas_config */
    /* CA start */
    if ((p_erab_modify_request_data->m.meas_config_updated )
            &&
            (p_erab_modify_request_data->meas_config.bitmask & 
             UE_ADM_MEAS_GAP_CONFIG_PRESENT))
    {
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_MEAS_GAP_CONFIG_PRESENT;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_NEW_DRB_CONFIG_VERSION].meas_gap_config = 
            p_erab_modify_request_data->meas_config.meas_gap_config;
    }
    /* CA end */

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_fill_radio_rsource_config_for_rollback
 *   INPUT        : uecc_ue_context_t*              p_uecc_ue_contex
 *                  rrc_uecc_llim_modify_lc_req_t*  p_rrc_uecc_llim_modify_lc_req
 *   OUTPUT       : none
 *
 *   DESCRIPTION  : Fills DRB info to be sent to the lowe layers via LLIM
 *
 *   RETURNS      : None
 *
 ******************************************************************************/
rrc_return_et uecc_llim_fill_radio_rsource_config_for_rollback
(
 uecc_ue_context_t*  p_uecc_ue_context,
 rrc_uecc_llim_modify_lc_req_t* p_rrc_uecc_llim_modify_lc_req
 )
{
    rrc_counter_t drb_index  = RRC_NULL;
    U16 e_rab_list_count      = RRC_NULL;

    rrc_return_et   rrc_response = RRC_SUCCESS;

    s1ap_E_RAB_ID erab_id;

    erab_modify_request_data_t   *p_erab_modify_request_data = PNULL;
    s1ap_E_RABLevelQoSParameters *p_qos_info    = PNULL;
    rrc_uecc_llim_drb_config_t   *p_uecc_llim_drb_config = PNULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_modify_lc_req);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_erab_modify_request_data = &(p_uecc_ue_context->p_curr_proc_data->
            u.erab_modify_request_data);

    e_rab_list_count = 
        p_erab_modify_request_data->erab_modify_list.erab_modify_list_counter;

    p_rrc_uecc_llim_modify_lc_req->
        modify_drb_entity[RRC_UECC_OLD_DRB_CONFIG_VERSION].
        drb_counter = e_rab_list_count;

    for(drb_index = 0; drb_index < e_rab_list_count; drb_index++)
    {
        erab_id = (s1ap_E_RAB_ID)p_erab_modify_request_data->erab_modify_list.
            erab_modify_item[drb_index].drb_config.erab_id;

        if (p_uecc_ue_context->p_e_rab_list[erab_id] == PNULL)
        {
            /* Do Nothing */
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[UECC_LLIM_MODIFY_LC_REQ] E-RAB ID does not exist.");
            rrc_response = RRC_FAILURE;
            break;
        }
        else
        {
            p_qos_info = &(p_uecc_ue_context->p_e_rab_list[erab_id]->
                    e_RABlevelQoSParameters);
            p_uecc_llim_drb_config = &(p_rrc_uecc_llim_modify_lc_req->
                    modify_drb_entity[RRC_UECC_OLD_DRB_CONFIG_VERSION].
                    uecc_llim_drb_config[drb_index]);

            /* drb_config */
            p_uecc_llim_drb_config->drb_config = 
                p_uecc_ue_context->p_e_rab_list[erab_id]->drb_config;
            
            /* clear bits as requested by LLIM team */
            p_uecc_llim_drb_config->drb_config.bitmask =
                (rrc_bitmask_t)(p_uecc_llim_drb_config->drb_config.bitmask &
                        ~RRM_DRB_CONFIG_RLC_CONFIG_UE_PRESENT);

            p_uecc_llim_drb_config->drb_config.bitmask =
                (rrc_bitmask_t)(p_uecc_llim_drb_config->drb_config.bitmask &
                        ~RRM_DRB_CONFIG_LOGICAL_CHANNEL_CONFIG_PRESENT);
            
            /*Qos changes START*/
            /*Fill the Qos info*/
            p_uecc_llim_drb_config->bitmask |= UECC_LLIM_DRB_CONFIG_QOS_INFO_PRESENT;

            p_uecc_llim_drb_config->qos_info.qci = p_qos_info->qCI;

            if (p_qos_info->m.gbrQosInformationPresent)
            {
                p_uecc_llim_drb_config->qos_info.bitmask |= 
                    RRC_GBR_QOS_INFO_PRESENT;

                p_uecc_llim_drb_config->qos_info.gbr_qos_info.dl_mbr = 
                    (U32)p_qos_info->gbrQosInformation.e_RAB_MaximumBitrateDL;

                p_uecc_llim_drb_config->qos_info.gbr_qos_info.ul_mbr = 
                    (U32)p_qos_info->gbrQosInformation.e_RAB_MaximumBitrateUL;

                p_uecc_llim_drb_config->qos_info.gbr_qos_info.dl_gbr = 
                    (U32)p_qos_info->gbrQosInformation.e_RAB_GuaranteedBitrateDL;

                p_uecc_llim_drb_config->qos_info.gbr_qos_info.ul_gbr = 
                    (U32)p_qos_info->gbrQosInformation.e_RAB_GuaranteedBitrateUL;
            }
        }
    }
    /*Fills the AMBR info*/
    p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
        [RRC_UECC_OLD_DRB_CONFIG_VERSION].bitmask |= 
        UECC_LLIM_MODIFY_LC_REQ_UE_AMBR_PRESENT;
    p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
        [RRC_UECC_OLD_DRB_CONFIG_VERSION].ue_ambr.dl_ambr = (U32)p_uecc_ue_context->
        ue_aggregate_maximum_bitrate.uEaggregateMaximumBitRateDL;
    p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
        [RRC_UECC_OLD_DRB_CONFIG_VERSION].ue_ambr.ul_ambr = (U32)p_uecc_ue_context->
        ue_aggregate_maximum_bitrate.uEaggregateMaximumBitRateUL;
    /*Qos changes END*/
    /* mac_config */
    if (p_erab_modify_request_data->m.mac_config_updated)
    {
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_MAC_CONFIG_PRESENT;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].mac_config = 
            p_uecc_ue_context->mac_config;
    }
    /* meas_config */
    if ((p_erab_modify_request_data->m.meas_config_updated)
            &&
            (p_erab_modify_request_data->meas_config.bitmask &
             UE_ADM_MEAS_GAP_CONFIG_PRESENT ))
    {
        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_MEAS_GAP_CONFIG_PRESENT;

        p_rrc_uecc_llim_modify_lc_req->modify_drb_entity
            [RRC_UECC_OLD_DRB_CONFIG_VERSION].meas_gap_config = 
            p_uecc_ue_context->p_meas_config->meas_gap_config;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return rrc_response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_modify_lc_resp
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function processes LLIM UECC_LLIM_MODIFY_LC_RESP message
 *
 *   RETURNS      : None
 *
 ******************************************************************************/
void uecc_llim_process_modify_lc_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_uecc_llim_modify_lc_resp_t*    p_llim_modify_lc_resp;
    /*CA_RE_ESTAB_START*/
    S8*             s_id = PNULL;
    rrc_uecc_llim_re_establish_ue_entity_resp_t rrc_llim_re_establish_ue_entity_resp;
    memset_wrapper (&rrc_llim_re_establish_ue_entity_resp, RRC_NULL,
            sizeof (rrc_uecc_llim_re_establish_ue_entity_resp_t));
    /*CA_RE_ESTAB_STOP*/


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_modify_lc_resp = (rrc_uecc_llim_modify_lc_resp_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_modify_lc_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_modify_lc_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_MODIFY_LC_RESP] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context,p_llim_modify_lc_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_MODIFY_LC_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /*CA_RE_ESTAB_START*/
    if (PNULL != p_ue_context->uecc_fsm.proc_descriptor.p_active_proc)
    {
        s_id = p_ue_context->uecc_fsm.proc_descriptor.p_active_proc->s_id;
    }
    /*CA_RE_ESTAB_STOP*/

    /* Check transaction_id */
    if (p_llim_modify_lc_resp->transaction_id !=
            uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /* Error. Invalid transaction id */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_MODIFY_LC_RESP] Invalid transaction id.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /*CA_RE_ESTAB_START*/
    /*push the event UECC_EV_LLIM_RECONFIGURE_UE_ENTITY_RESP if reestab is on
     * going*/
    if ((PNULL != s_id) && 
            !(strncmp_wrapper((const S8 *)s_id,(const S8 *)"CRE_P",
                    strlen_wrapper((const Char8 *)s_id))))
    {
        rrc_llim_re_establish_ue_entity_resp.cell_index = 
            p_llim_modify_lc_resp->cell_index;
        rrc_llim_re_establish_ue_entity_resp.ue_index = 
            p_llim_modify_lc_resp->ue_index;
        rrc_llim_re_establish_ue_entity_resp.response_code = 
            p_llim_modify_lc_resp->response_code;

        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_LLIM_RECONFIGURE_UE_ENTITY_RESP,
                &rrc_llim_re_establish_ue_entity_resp);
    }
    else
    {
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_LLIM_RECONFIGURE_UE_RESP,
                p_llim_modify_lc_resp);
    }
    /*CA_RE_ESTAB_STOP*/

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_modify_rollback_req
 *   INPUT        : uecc_ue_context_t *p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds and sends  
 *                  LLIM UECC_LLIM_MODIFY_ROLLBACK_REQ message
 *
 *   RETURNS      : rrc_return_et
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_modify_rollback_req
(
 uecc_ue_context_t *p_uecc_ue_context
 )
{
    U8              *p_msg = PNULL;
    rrc_return_et   rrc_response = RRC_FAILURE;
    /* GDB fix - compiler warning */
    S8*             s_id = PNULL;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_msg = uecc_alloc_intrl_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_MODIFY_ROLLBACK_REQ,
            sizeof(rrc_uecc_llim_modify_rollback_req_t));

    if (PNULL != p_msg)
    {
        s_id = p_uecc_ue_context->uecc_fsm.proc_descriptor.p_active_proc->s_id;
        if(!(strncmp_wrapper((const S8 *)s_id,(const S8 *)"UE_ERABMOD_P",
                        strlen_wrapper((const Char8 *)s_id))))
        {
            uecc_llim_build_modify_rollback_req(p_uecc_ue_context,
                    (rrc_uecc_llim_modify_rollback_req_t*)
                    (p_msg + RRC_API_HEADER_SIZE));
        }
        else if(!(strncmp_wrapper((const S8 *)s_id,(const S8 *)"UE_RRM_UE_RECONFIG_P",
                        strlen_wrapper((const Char8 *)s_id))))
        {
            uecc_llim_build_modify_rollback_req_for_ue_reconfig(p_uecc_ue_context,
                    (rrc_uecc_llim_modify_rollback_req_t*)
                    (p_msg + RRC_API_HEADER_SIZE));
        }
        else if(!(strncmp_wrapper((const S8 *)s_id,(const S8 *)"UE_CONTXTMOD_P",
                        strlen_wrapper((const Char8 *)s_id))))
        {
            uecc_llim_build_modify_rollback_req_for_ue_ctx_mod(p_uecc_ue_context,
                    (rrc_uecc_llim_modify_rollback_req_t*)
                    (p_msg + RRC_API_HEADER_SIZE));
        }


        /* Send the built API to LLIM  module*/
        rrc_send_message(p_msg, RRC_LLIM_MODULE_ID);
        rrc_response = RRC_SUCCESS;
    }
    else
    {
        rrc_response = RRC_FAILURE;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return rrc_response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_modify_rollback_req
 *   INPUT        : uecc_ue_context_t*                    p_uecc_ue_context
 *                  rrc_uecc_llim_modify_rollback_req_t*  p_rrc_uecc_llim_rollback_req
 *   OUTPUT       : none
 *   DESCRIPTION  : Build internal message UECC_LLIM_MODIFY_ROLLBACK_REQ
 *
 *   RETURNS      : None
 *
 ******************************************************************************/
void uecc_llim_build_modify_rollback_req
(
 uecc_ue_context_t*                    p_uecc_ue_context,
 rrc_uecc_llim_modify_rollback_req_t*  p_rrc_uecc_llim_rollback_req
 )
{
    erab_modify_list_t      *p_mod_list = PNULL;

    s1ap_E_RAB_ID    erb_idx   = RRC_NULL;
    rrc_counter_t    drb_index = RRC_NULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_rollback_req);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_mod_list = &(p_uecc_ue_context->p_curr_proc_data->u.
            erab_modify_request_data.erab_modify_list);

    /* Fill message */
    p_rrc_uecc_llim_rollback_req->transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    p_rrc_uecc_llim_rollback_req->ue_index = p_uecc_ue_context->ue_index;
    p_rrc_uecc_llim_rollback_req->cell_index = p_uecc_ue_context->cell_index;

    /* Fill the existing DRB configuration info fields for rollback */
    p_rrc_uecc_llim_rollback_req->modify_drb_entity.drb_counter =
        p_mod_list->erab_modify_list_counter;

    for (drb_index = 0; 
            drb_index < p_mod_list->erab_modify_list_counter; 
            drb_index++)
    {
        erb_idx = p_mod_list->erab_modify_item[drb_index].drb_config.erab_id;

        p_rrc_uecc_llim_rollback_req->
            modify_drb_entity.uecc_llim_drb_config[drb_index].drb_config =
            p_uecc_ue_context->p_e_rab_list[erb_idx]->drb_config;
    }

    if (p_uecc_ue_context->p_curr_proc_data->u.erab_modify_request_data.
            m.mac_config_updated == 1)
    {
        p_rrc_uecc_llim_rollback_req->modify_drb_entity.mac_config = 
            p_uecc_ue_context->mac_config;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_modify_rollback_req_for_ue_reconfig
 *   INPUT        : uecc_ue_context_t*                    p_uecc_ue_context
 *                  rrc_uecc_llim_modify_rollback_req_t*  p_rrc_uecc_llim_rollback_req
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       Build internal message UECC_LLIM_MODIFY_ROLLBACK_REQ for UE_RECONFIG
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_build_modify_rollback_req_for_ue_reconfig
(
 uecc_ue_context_t*                    p_uecc_ue_context,
 rrc_uecc_llim_modify_rollback_req_t*  p_rrc_uecc_llim_rollback_req
 )
{
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_rollback_req);

    /* Fill message */
    p_rrc_uecc_llim_rollback_req->transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    p_rrc_uecc_llim_rollback_req->ue_index = p_uecc_ue_context->ue_index;
    p_rrc_uecc_llim_rollback_req->cell_index = p_uecc_ue_context->cell_index;

    if (p_uecc_ue_context->p_curr_proc_data->u.rrm_ue_reconfig_request_data.
            m.mac_config_updated == 1)
    {
        p_rrc_uecc_llim_rollback_req->modify_drb_entity.mac_config = 
            p_uecc_ue_context->mac_config;
    }
    if (p_uecc_ue_context->p_curr_proc_data->u.rrm_ue_reconfig_request_data.
            m.physical_config_dedicated_updated == 1)
    {
        p_rrc_uecc_llim_rollback_req->modify_drb_entity.physical_config_dedicated = 
            p_uecc_ue_context->physical_config_dedicated;
    }
    /* CA UT Fix start */
    if(RRC_TRUE == p_uecc_ue_context->p_curr_proc_data->u.rrm_ue_reconfig_request_data.
            m.scell_config_updated)
    {

        /* For returning back to prev configuration, 
         * release the Scells added ,
         * and modify the Scells back to previous config that have been modified
         * to new values*/
        /* SPR 19838 : Coverity 10021 fix start */
        if( p_uecc_ue_context->p_curr_proc_data->u.rrm_ue_reconfig_request_data.p_scell_config->bitmask &
                RRM_SCELL_ADD_MOD_LIST_PRESENT)
        /* SPR 19838 : Coverity 10021 fix end */
	    {
            build_scell_config_for_uecc_modify_rollback(p_uecc_ue_context,
                    p_rrc_uecc_llim_rollback_req);
        }
        if((p_rrc_uecc_llim_rollback_req->modify_drb_entity.scell_config.bitmask & 
                    RRM_SCELL_RELEASE_LIST_PRESENT)
                ||
                (p_rrc_uecc_llim_rollback_req->modify_drb_entity.scell_config.bitmask &
                 RRM_SCELL_ADD_MOD_LIST_PRESENT))
        {
            p_rrc_uecc_llim_rollback_req->modify_drb_entity.bitmask |=
                UECC_LLIM_MODIFY_LC_REQ_SCELL_CONFIG_PRESENT;
        }
    }
    if(p_uecc_ue_context->rel10_ue_category >= 6 && 
            p_uecc_ue_context->rel10_ue_category <=8)
    {
        p_rrc_uecc_llim_rollback_req->bitmask |=
            UECC_LLIM_MODIFY_LC_REQ_R10_UE_CATEGORY_PRESENT;
        p_rrc_uecc_llim_rollback_req->rel10_ue_category = 
            p_uecc_ue_context->rel10_ue_category;
    }

    /* CA UT Fix end */
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

void build_scell_config_for_uecc_modify_rollback(
        uecc_ue_context_t*                    p_ue_context,
        rrc_uecc_llim_modify_rollback_req_t*  p_rrc_uecc_llim_rollback_req)
{
    U8 loop = RRC_NULL;
    U8 loop2 = RRC_NULL;
    U8 index1 = 0;
    U8 index2 = 0;
    U8 cell_index = RRC_NULL;

    rrm_scell_config_t *p_scell_config_dest = PNULL;
    rrm_scell_config_t *p_scell_config = PNULL;

    if((PNULL == p_ue_context)
            ||
            (PNULL == p_rrc_uecc_llim_rollback_req)) 
    {
        /* Coverity Fix 60515*/
        /*    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
              (p_ue_context->p_gb_context)->facility_name,
              RRC_ERROR,
              "p_ue_context / p_rrc_uecc_llim_rollback_req is NULL ");*/
        /* Coverity Fix 60515*/
        return;
    }    

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    p_scell_config_dest = &(p_rrc_uecc_llim_rollback_req->modify_drb_entity.
            scell_config); 

    p_scell_config = p_ue_context->p_curr_proc_data->u.rrm_ue_reconfig_request_data.
        p_scell_config ;

    for( loop = RRC_NULL;
            loop < p_scell_config->scell_add_mod_list.count;
            loop++)
    {
        cell_index = p_scell_config->scell_add_mod_list.
            rrc_scell_to_add_mod[loop].cell_index;

        if((ADD_SCELL ==
                    p_ue_context->scells_operation_list[cell_index].operation_type)
                &&
                (RRC_TRUE == 
                 p_ue_context->scells_operation_list[cell_index].valid_ind))
        {
            p_scell_config_dest->scell_release_list.rrc_scell_to_release[index1].cell_index 
                = cell_index;

            p_scell_config_dest->scell_release_list.rrc_scell_to_release[index1].scellIndex     
                = p_scell_config->scell_add_mod_list.rrc_scell_to_add_mod[loop].scellIndex ;

            index1 = p_scell_config_dest->scell_release_list.count++;

        }    
        else if((MODIFY_SCELL ==
                    p_ue_context->scells_operation_list[cell_index].operation_type)
                &&
                (RRC_TRUE == p_ue_context->scells_operation_list[cell_index].valid_ind))
        {
            for ( loop2 = RRC_NULL ;
                    loop2 < p_ue_context->p_scell_config->scell_add_mod_list.count;
                    loop2++ )
            {
                if(cell_index == 
                        p_ue_context->p_scell_config->scell_add_mod_list.rrc_scell_to_add_mod[loop2].cell_index) 
                {
                    l3_memcpy_wrapper(&(p_scell_config_dest->scell_add_mod_list.rrc_scell_to_add_mod[index2]),
                            &(p_ue_context->p_scell_config->scell_add_mod_list.rrc_scell_to_add_mod[loop2]),
                            sizeof(rrc_scell_to_add_mod_t));
                    index2 = p_scell_config_dest->scell_add_mod_list.count++;
                    break;
                }    
            }
            p_rrc_uecc_llim_rollback_req->scells_operation_list[cell_index].chk_cellid_exist = RRC_TRUE;
            p_rrc_uecc_llim_rollback_req->scells_operation_list[cell_index].operation_type = MODIFY_SCELL;
            p_rrc_uecc_llim_rollback_req->scells_operation_list[cell_index].valid_ind = RRC_TRUE;

        }    
    }
    if(p_scell_config_dest->scell_add_mod_list.count >RRC_NULL)
    {
        p_scell_config_dest->bitmask |=
            RRM_SCELL_ADD_MOD_LIST_PRESENT;
    }    
    if(p_scell_config_dest->scell_release_list.count > RRC_NULL)
    {
        p_scell_config_dest->bitmask |= RRM_SCELL_RELEASE_LIST_PRESENT;
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}    

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_rrm_ue_reconfig_rrc_connection_reconfiguration 
 *   INPUT        : DL_DCCH_Message*           p_dl_dcch_msg
 *                  OSCTXT*                    p_asn1_ctx
 *                  uecc_ue_context_t*         p_uecc_ue_context
 *   DESCRIPTION  : This function builds UECC_LLIM_SRB_DATA_REQ message
 *                  with RRCConnectionReconfiguration to LLIM
 *
 *   RETURNS      : RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_rrm_ue_reconfig_rrc_connection_reconfiguration
(
 DL_DCCH_Message*           p_dl_dcch_msg,
 OSCTXT*                    p_asn1_ctx,
 uecc_ue_context_t*         p_uecc_ue_context
 )
{
    RRCConnectionReconfiguration_r8_IEs*    p_r8 = PNULL;
    RRCConnectionReconfiguration*           p_rrc_conn_recfg = PNULL;
    rrc_return_et                           result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_dl_dcch_msg);
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_uecc_ue_context);

    result = uecc_llim_build_dl_dcch_msg(p_dl_dcch_msg,
            p_asn1_ctx, 
            p_uecc_ue_context,
            &p_rrc_conn_recfg);

    if (result == RRC_SUCCESS)
    {
        p_r8 = rtxMemAllocType(p_asn1_ctx, RRCConnectionReconfiguration_r8_IEs);
        if (PNULL == p_r8)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReconfiguration] ASN malloc failed.");
            result = RRC_FAILURE;
        }
        else
        {
            p_rrc_conn_recfg->criticalExtensions.u.c1->
                u.rrcConnectionReconfiguration_r8 = p_r8;
            asn1Init_RRCConnectionReconfiguration_r8_IEs(
                    p_r8);

            p_r8->m.radioResourceConfigDedicatedPresent = 1;

            if  (RRC_FAILURE == uecc_llim_fill_erb_modify_srb_info(
                        p_r8, p_asn1_ctx, p_uecc_ue_context))
            {
                result = RRC_FAILURE;
            }
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_rrm_ue_reconfig_rrc_connection_reconfiguration
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION  : This function builds and sends UECC_LLIM_SRB_DATA_REQ message
 *                  with RRCConnectionReconfiguration to LLIM
 *
 *   RETURNS      : RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et 
uecc_llim_build_and_send_rrm_ue_reconfig_rrc_connection_reconfiguration(
        uecc_ue_context_t*  p_uecc_ue_context
        )
{
    OSCTXT                  asn1_ctx;
    DL_DCCH_Message         dl_dcch_msg;

    rrc_return_et           result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    RRC_ASSERT(PNULL != p_uecc_ue_context);

    memset_wrapper(&dl_dcch_msg, 0x00, sizeof(DL_DCCH_Message));

    /* Initialize the ASN Context */
    uecc_llim_init_asn_context(&asn1_ctx,p_uecc_ue_context);

    if(RRC_SUCCESS == 
            uecc_llim_build_rrm_ue_reconfig_rrc_connection_reconfiguration( 
                &dl_dcch_msg, &asn1_ctx, 
                p_uecc_ue_context))
    {
        result = uecc_llim_send_rrc_connection_reconfiguration(
                p_uecc_ue_context,
                &asn1_ctx, 
                &dl_dcch_msg);
        if (result == RRC_FAILURE)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReconfiguration] Message sending failed .");
        }
    }

    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}
/******************************************************************************
 *   FUNCTION NAME: 
 *   uecc_llim_build_and_send_erb_modify_rrc_connection_reconfiguration
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function builds and sends UECC_LLIM_SRB_DATA_REQ message
 *       with RRCConnectionReconfiguration to LLIM
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et 
uecc_llim_build_and_send_erb_modify_rrc_connection_reconfiguration(
		uecc_ue_context_t*  p_uecc_ue_context
		)
{
	OSCTXT                  asn1_ctx;
	DL_DCCH_Message         dl_dcch_msg;

	rrc_return_et           result = RRC_FAILURE;


	RRC_ASSERT(PNULL != p_uecc_ue_context);
	RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

	memset_wrapper(&dl_dcch_msg, 0x00, sizeof(DL_DCCH_Message));

	/* Initialize the ASN Context */
	uecc_llim_init_asn_context(&asn1_ctx,p_uecc_ue_context);

	if (RRC_SUCCESS == 
			uecc_llim_build_erb_modify_rrc_connection_reconfiguration( 
				&dl_dcch_msg, &asn1_ctx, 
				p_uecc_ue_context))
	{
		result = uecc_llim_send_rrc_connection_reconfiguration(
				p_uecc_ue_context,
				&asn1_ctx, 
				&dl_dcch_msg);
		if (result == RRC_FAILURE)
		{
			RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
					(p_uecc_ue_context->p_gb_context)->facility_name,
					RRC_ERROR,
					"[RRCConnectionReconfiguration] Message sending failed .");

		}
		/*SPR 20559 start */
		p_uecc_ue_context->erb_modify_running = RRC_FALSE;
		/*SPR 20559 stop */

	}

	rtFreeContext(&asn1_ctx);

	RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
	return result;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_send_rrc_connection_reconfiguration
 *   INPUT        : uecc_ue_context_t*                p_uecc_ue_context
 *                  OSCTXT*                           p_asn1_ctx
 *                  DL_DCCH_Message*                  p_dl_dcch_msg
 *   OUTPUT       : none
 *   DESCRIPTION  : This function sends UECC_LLIM_SRB_DATA_REQ message
 *                  with RRCConnectionReconfiguration to LLIM
 *
 *   RETURNS      : RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_send_rrc_connection_reconfiguration(
        uecc_ue_context_t*                p_uecc_ue_context,
        OSCTXT*                           p_asn1_ctx,
        DL_DCCH_Message*                  p_dl_dcch_msg
        )
{
    rrc_uecc_llim_srb_data_req_t*           p_srb_data_req = PNULL;

    U8  msg[sizeof(rrc_uecc_llim_srb_data_req_t)+UECC_MAX_ASN1_BUF_LEN];

    rrc_return_et                           result = RRC_FAILURE;
    EVENT_EXTERNAL_HEADER                   *p_event_header = PNULL;
    U32                                     encoded_msg_len = 0;
    LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT   *p_event_rrc_protocol_err = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Do ASN1 encode */
    p_srb_data_req = (rrc_uecc_llim_srb_data_req_t*)msg;

    pu_setBuffer(p_asn1_ctx, p_srb_data_req->data_buffer,
            UECC_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);

    if (RT_OK != asn1PE_DL_DCCH_Message(p_asn1_ctx, p_dl_dcch_msg))
    {
        rtxErrPrint(p_asn1_ctx);

        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[RRCConnectionReconfiguration] ASN1 encoding failed.");

        /*Generating Protocol Event LOCAL_EVENT_RRC_PROTOCOL_ERROR*/
        p_event_rrc_protocol_err = rrc_mem_get(sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));
        if (PNULL != p_event_rrc_protocol_err)
        {
            memset_wrapper(p_event_rrc_protocol_err, RRC_NULL, 
                    sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));

            p_event_rrc_protocol_err->header.length = 
                sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT);
            p_event_rrc_protocol_err->header.event_id = LOCAL_EVENT_RRC_PROTOCOL_ERROR;

            l3_strncpy_wrapper(( S8 *)(p_event_rrc_protocol_err->EVENT_PARAM_RRC_MESSAGE_DISCARDED),
                    (const S8 *)"RRC CONNECTION RECONFIGURATION", RRC_MESSAGE_DISCARDED_SIZE);

            rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_rrc_protocol_err);
        }
        return RRC_FAILURE;
    }
    else
    {
        encoded_msg_len = (U32)pe_GetMsgLen(p_asn1_ctx);

        rrc_asn1PrtToStr_DL_DCCH_Message(RRC_ASN,"DL_DCCH_Message",
                p_dl_dcch_msg, "RRCConnectionReconfiguration",
                p_srb_data_req->data_buffer, encoded_msg_len);

        p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                encoded_msg_len);
        if (PNULL != p_event_header)
        {
            memset_wrapper(p_event_header, RRC_NULL, (sizeof(EVENT_EXTERNAL_HEADER) +
                        encoded_msg_len));
            rrc_uecc_fill_protocol_event_params(p_uecc_ue_context,
                    p_event_header,
                    (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                    LOCAL_RRC_CONNECTION_RECONFIGURATION,
                    MESSAGE_DIRECTION_SEND);

            l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                        sizeof(EVENT_EXTERNAL_HEADER)),
                    (const void*)p_srb_data_req->data_buffer,
                    encoded_msg_len);

            rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
        }
    }

    /* cr_220 change */
    p_srb_data_req->data_buffer_length = 
        (rrc_counter_t)pe_GetMsgLen(p_asn1_ctx);

    p_srb_data_req->transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
    p_srb_data_req->ue_index = p_uecc_ue_context->ue_index;
    p_srb_data_req->lc_id = UECC_LTE_RRC_SRB1_LC_ID;
    p_srb_data_req->service_requested =
        UECC_LLIM_SRB_SERVICEREQUESTED_DELIVERY_STATUS_FALSE;
    p_srb_data_req->cell_index = p_uecc_ue_context->cell_index;

    /* TRACE_changes_start */
    /* SPR 16113 Start */
    uecc_rrc_ue_assoc_msg_max_trace_handler(p_uecc_ue_context, p_srb_data_req->data_buffer,
            p_srb_data_req->data_buffer_length, "RRC CONNECTION RECONFIGURATION", RRC_DL_DCCH);
    /* SPR 16113 Stop */
    /* TRACE_changes_start */

    result = uecc_rrc_send_internal_msg(
            RRC_LLIM_MODULE_ID,
            UECC_LLIM_SRB_DATA_REQ,
            (U16)( p_srb_data_req->data_buffer_length+
                sizeof(rrc_uecc_llim_srb_data_req_t)),
            msg);

    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
            (p_uecc_ue_context->p_gb_context)->facility_name,
            RRC_INFO,"RRC_MSG: RRCConnectionReconfiguration %s",
            change_data_to_str(p_srb_data_req->data_buffer_length, p_srb_data_req->data_buffer));


    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_erb_modify_rrc_connection_reconfiguration 
 *   INPUT        : uecc_ue_context_t*                p_uecc_ue_context
 *                  OSCTXT*                           p_asn1_ctx
 *                  DL_DCCH_Message*                  p_dl_dcch_msg
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function builds UECC_LLIM_SRB_DATA_REQ message
 *       with RRCConnectionReconfiguration to LLIM
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_erb_modify_rrc_connection_reconfiguration
(
 DL_DCCH_Message*           p_dl_dcch_msg,
 OSCTXT*                    p_asn1_ctx,
 uecc_ue_context_t*         p_uecc_ue_context
 )
{
    RRCConnectionReconfiguration_r8_IEs*    p_r8 = PNULL;
    RRCConnectionReconfiguration*           p_rrc_conn_recfg = PNULL;

    rrc_return_et             result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_dl_dcch_msg);
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /* SPR:7369 start */
    p_uecc_ue_context->erb_modify_running = RRC_TRUE;
    /* SPR:7369 stop */

    result = uecc_llim_build_dl_dcch_msg(p_dl_dcch_msg,
            p_asn1_ctx, 
            p_uecc_ue_context,
            &p_rrc_conn_recfg);
    if (result == RRC_SUCCESS)
    {
        p_r8 = rtxMemAllocType(p_asn1_ctx, RRCConnectionReconfiguration_r8_IEs);
        if (PNULL == p_r8)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReconfiguration] ASN malloc failed.");
            return result;
        }

        p_rrc_conn_recfg->criticalExtensions.u.c1->
            u.rrcConnectionReconfiguration_r8 = p_r8;
        asn1Init_RRCConnectionReconfiguration_r8_IEs(
                p_r8);

        p_r8->m.radioResourceConfigDedicatedPresent = 1;

        if  (RRC_FAILURE == uecc_llim_fill_erb_modify_srb_info(
                    p_r8, p_asn1_ctx, p_uecc_ue_context))
        {
            return result;
        }


        if ( p_uecc_ue_context->p_curr_proc_data->u.
                erab_modify_request_data.m.meas_config_updated)
        {
            if (RRC_FAILURE == uecc_llim_build_MeasConfig(
                        p_uecc_ue_context,
                        &p_uecc_ue_context->p_curr_proc_data->u.
                        erab_modify_request_data.meas_config,
                        p_asn1_ctx,
                        &p_r8->measConfig))
            {
                return result;
            }
            p_r8->m.measConfigPresent = 1;
        }

        uecc_llim_fill_erb_modify_drb_info(p_r8, p_uecc_ue_context);

        /* Fill reportProximityConfig_r9 if received from RRM */
        if ( p_uecc_ue_context->p_curr_proc_data->u.erab_modify_request_data.
                m.proximity_config_present)
        {
            p_r8->m.nonCriticalExtensionPresent = 1;
            p_r8->nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
            p_r8->nonCriticalExtension.nonCriticalExtension.m.otherConfig_r9Present = 1;
            p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.m.
                reportProximityConfig_r9Present= 1;

            if ( p_uecc_ue_context->p_curr_proc_data->u.erab_modify_request_data.
                    proximity_config.bitmask &
                    RRM_PROXIMITY_IND_EUTRA_PRESENT)
            {
                p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                    reportProximityConfig_r9.proximityIndicationEUTRA_r9 =
                    p_uecc_ue_context->p_curr_proc_data->u.erab_modify_request_data.
                    proximity_config.proximity_ind_eutra;

                p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                    reportProximityConfig_r9.m.proximityIndicationEUTRA_r9Present= 1;
            }

            if ( p_uecc_ue_context->p_curr_proc_data->u.erab_modify_request_data.
                    proximity_config.bitmask &
                    RRM_PROXIMITY_IND_UTRA_PRESENT)
            {
                p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                    reportProximityConfig_r9.proximityIndicationUTRA_r9 =
                    p_uecc_ue_context->p_curr_proc_data->u.erab_modify_request_data.
                    proximity_config.proximity_ind_utra;

                p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                    reportProximityConfig_r9.m.proximityIndicationUTRA_r9Present= 1;
            }
        }

        result = RRC_SUCCESS;    
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_init_asn_context
 *   INPUT        : uecc_ue_context_t*                p_uecc_ue_context
 *                  OSCTXT*                           p_asn1_ctx
 *   OUTPUT       : none
 *
 *   DESCRIPTION: This function initializes the ASN context for 
 *   RRCConnectionReconfiguration message sent to LLIM
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_init_asn_context
(
 OSCTXT             *p_asn1_ctx,
 uecc_ue_context_t  *p_uecc_ue_context
 )
{
    rrc_return_et   result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Init ASN1 context */
    if (RT_OK != rtInitContext(p_asn1_ctx))
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[RRCConnectionReconfiguration] "
                "ASN1 context initialization failed.");
        result = RRC_FAILURE;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;     
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_dl_dcch_meas_msg
 *   INPUT        : uecc_ue_context_t*                p_uecc_ue_context
 *                  OSCTXT*                           p_asn1_ctx
 *                  DL_DCCH_Message*              p_dl_dcch_msg
 *                  RRCConnectionReconfiguration** p_rrc_conn_recfg
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function builds the DL-DCCH message for
 *       RRCConnectionReconfiguration message sent to LLIM
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_dl_dcch_meas_msg
(
 DL_DCCH_Message*              p_dl_dcch_msg,
 OSCTXT*                       p_asn1_ctx,
 uecc_ue_context_t*            p_uecc_ue_context,
 RRCConnectionReconfiguration** p_rrc_conn_recfg

 )
{

    rrc_return_et    result = RRC_SUCCESS;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /* Fill the values in the ASN structures that shall be encoded by
     * ASN Encoder */
    /* Downlink DCCH message type */

    p_dl_dcch_msg->message.t = T_DL_DCCH_MessageType_c1;
    p_dl_dcch_msg->message.u.c1 =
        rtxMemAllocType(p_asn1_ctx, DL_DCCH_MessageType_c1);
    do
    {
        if (PNULL == p_dl_dcch_msg->message.u.c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReconfiguration] ASN malloc failed.");
            result = RRC_FAILURE;
            return result;
        }

        /* Choose RRCConnectionReconfiguration */
        p_dl_dcch_msg->message.u.c1->t =
            T_DL_DCCH_MessageType_c1_rrcConnectionReconfiguration;

        p_dl_dcch_msg->message.u.c1->u.rrcConnectionReconfiguration =
            rtxMemAllocType(p_asn1_ctx, RRCConnectionReconfiguration);
        if (PNULL == p_dl_dcch_msg->message.u.c1->u.rrcConnectionReconfiguration)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReconfiguration] ASN malloc failed.");
            result = RRC_FAILURE;
            break;
        }

        *p_rrc_conn_recfg =
            p_dl_dcch_msg->message.u.c1->u.rrcConnectionReconfiguration;

        /* transaction id */
        (*p_rrc_conn_recfg)->rrc_TransactionIdentifier =
            (RRC_TransactionIdentifier) (uecc_ue_ctx_get_meas_transction_id
                    (p_uecc_ue_context) &
                    UECC_LTE_RRC_TRANSACTION_ID_MASK);

        (*p_rrc_conn_recfg)->criticalExtensions.t =
            T_RRCConnectionReconfiguration_criticalExtensions_c1;

        (*p_rrc_conn_recfg)->criticalExtensions.u.c1 = rtxMemAllocType(p_asn1_ctx,
                RRCConnectionReconfiguration_criticalExtensions_c1);
        if (PNULL == (*p_rrc_conn_recfg)->criticalExtensions.u.c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReconfiguration] ASN malloc failed.");
            result = RRC_FAILURE;
            break;
        }
        else
        {
            (*p_rrc_conn_recfg)->criticalExtensions.u.c1->t =
                T_RRCConnectionReconfiguration_criticalExtensions_c1_rrcConnectionReconfiguration_r8;
        }
    }while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_dl_dcch_msg
 *   INPUT        : uecc_ue_context_t*                p_uecc_ue_context
 *                  OSCTXT*                           p_asn1_ctx
 *                  DL_DCCH_Message*              p_dl_dcch_msg
 *                  RRCConnectionReconfiguration** p_rrc_conn_recfg
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function builds the DL-DCCH message for
 *       RRCConnectionReconfiguration message sent to LLIM
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_dl_dcch_msg
(
 DL_DCCH_Message*              p_dl_dcch_msg,
 OSCTXT*                       p_asn1_ctx,
 uecc_ue_context_t*            p_uecc_ue_context,
 RRCConnectionReconfiguration** p_rrc_conn_recfg

 )
{

    rrc_return_et    result = RRC_SUCCESS;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /* Fill the values in the ASN structures that shall be encoded by
     * ASN Encoder */
    /* Downlink DCCH message type */

    p_dl_dcch_msg->message.t = T_DL_DCCH_MessageType_c1;
    p_dl_dcch_msg->message.u.c1 =
        rtxMemAllocType(p_asn1_ctx, DL_DCCH_MessageType_c1);
    do
    {
        if (PNULL == p_dl_dcch_msg->message.u.c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReconfiguration] ASN malloc failed.");
            result = RRC_FAILURE;
            return result;
        }

        /* Choose RRCConnectionReconfiguration */
        p_dl_dcch_msg->message.u.c1->t =
            T_DL_DCCH_MessageType_c1_rrcConnectionReconfiguration;

        p_dl_dcch_msg->message.u.c1->u.rrcConnectionReconfiguration =
            rtxMemAllocType(p_asn1_ctx, RRCConnectionReconfiguration);
        if (PNULL == p_dl_dcch_msg->message.u.c1->u.rrcConnectionReconfiguration)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReconfiguration] ASN malloc failed.");
            result = RRC_FAILURE;
            break;
        }

        *p_rrc_conn_recfg =
            p_dl_dcch_msg->message.u.c1->u.rrcConnectionReconfiguration;

        /* transaction id */
        (*p_rrc_conn_recfg)->rrc_TransactionIdentifier =
            (RRC_TransactionIdentifier) (uecc_ue_ctx_get_op_transction_id
                    (p_uecc_ue_context) &
                    UECC_LTE_RRC_TRANSACTION_ID_MASK);

        (*p_rrc_conn_recfg)->criticalExtensions.t =
            T_RRCConnectionReconfiguration_criticalExtensions_c1;

        (*p_rrc_conn_recfg)->criticalExtensions.u.c1 = rtxMemAllocType(p_asn1_ctx,
                RRCConnectionReconfiguration_criticalExtensions_c1);
        if (PNULL == (*p_rrc_conn_recfg)->criticalExtensions.u.c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReconfiguration] ASN malloc failed.");
            result = RRC_FAILURE;
            break;
        }
        else
        {
            (*p_rrc_conn_recfg)->criticalExtensions.u.c1->t =
                T_RRCConnectionReconfiguration_criticalExtensions_c1_rrcConnectionReconfiguration_r8;
        }
    }while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_fill_erb_modify_srb_info
 *   INPUT        : RRCConnectionReconfiguration_r8_IEs    *p_r8
 *                  OSCTXT                                 *p_asn1_ctx
 *                  uecc_ue_context_t                      *p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds the DL-DCCH message for
 *       RRCConnectionReconfiguration message sent to LLIM
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_fill_erb_modify_srb_info
(
 RRCConnectionReconfiguration_r8_IEs    *p_r8,
 OSCTXT                                 *p_asn1_ctx,
 uecc_ue_context_t                      *p_uecc_ue_context
 )
{
    rrc_return_et                           result = RRC_SUCCESS;
    rrm_ue_reconfig_request_data_t  *p_rrm_ue_reconfig_request_data = PNULL;

    S8*             s_id = PNULL;


    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);      
    /* Fill RadioResourceConfigDedicated*/
    if (RRC_SUCCESS != uecc_llim_build_erb_modify_radio_resource_cfg_dedicated(
                p_uecc_ue_context,
                &p_r8->radioResourceConfigDedicated,
                p_asn1_ctx))
    {
        result = RRC_FAILURE;
    }      


    if(PNULL != p_uecc_ue_context->p_curr_proc_data)
    {

        s_id = p_uecc_ue_context->uecc_fsm.proc_descriptor.p_active_proc->s_id;
        if(!(strncmp_wrapper((const S8*)s_id,(const S8 *)"UE_RRM_UE_RECONFIG_P",
                        strlen_wrapper((const Char8*)s_id))))
        {
            p_rrm_ue_reconfig_request_data = &(p_uecc_ue_context->p_curr_proc_data->u.
                    rrm_ue_reconfig_request_data);
            if (p_rrm_ue_reconfig_request_data->m.scell_config_updated)
            {
                if (RRC_SUCCESS != uecc_llim_build_scell_config(
                            p_uecc_ue_context,
                            p_r8,
                            p_asn1_ctx))
                {
                    RRC_TRACE(RRC_FATAL,"uecc_llim_fill_erb_modify_srb_info :"
                            "failed in building scell_config ");
                    result = RRC_FAILURE;
                }
            }
        }

    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_erb_modify_radio_resource_cfg_dedicated
 *   INPUT        : uecc_ue_context_t               *p_uecc_ue_context
 *                  RadioResourceConfigDedicated    *p_asn1_rrc
 *                  OSCTXT                          *p_asn1_ctx
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds RadioResourceConfigDedicated
 *       structure for ASN1 encoding from given ue_adm_radio_res_config_t
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_erb_modify_radio_resource_cfg_dedicated(
        uecc_ue_context_t               *p_uecc_ue_context,
        RadioResourceConfigDedicated    *p_asn1_rrc,
        OSCTXT                          *p_asn1_ctx
        )
{
    rrc_return_et result = RRC_FAILURE;
    erab_modify_request_data_t   *p_mod_req_data = PNULL;
    rrm_ue_reconfig_request_data_t  *p_rrm_ue_reconfig_request_data = PNULL;
    /* GDB Fix - compiler warning */
    S8*             s_id = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_uecc_ue_context);

    s_id = p_uecc_ue_context->uecc_fsm.proc_descriptor.p_active_proc->s_id;

    if(!(strncmp_wrapper((const S8 *)s_id,(const S8 *)"UE_ERABMOD_P",
                    strlen_wrapper((const Char8*)s_id))))
    {
        p_mod_req_data = &(p_uecc_ue_context->p_curr_proc_data->u.
                erab_modify_request_data);
        do
        {
            asn1Init_RadioResourceConfigDedicated(p_asn1_rrc);
              
/*SPR_16942_START*/
/* SPR:7369 start */
/* SPR:7369 stop */

                /* RadioResourceConfigDedicated_mac_MainConfig */
                if ((p_mod_req_data->m.mac_config_updated) &&
                        (RRM_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT &
                         p_mod_req_data->mac_config.bitmask))
                {
                    p_asn1_rrc->m.mac_MainConfigPresent = 1;

                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,"ERAB_modify_RCR: mac_main_config present");

                    if (RRC_SUCCESS != uecc_llim_build_asn1_mac_main_config(
                                p_uecc_ue_context,
                                &(p_mod_req_data->mac_config),
                                &p_asn1_rrc->mac_MainConfig,
                                p_asn1_ctx))
                    {
                        break;
                    }
                }
            /* SPR:7369 start */

           /* SPR:7369 stop */
/*SPR_16942_END*/            

            /* DRB_ToAddModList */
            if ( 0 < p_mod_req_data->erab_modify_list.erab_modify_list_counter)
            {
                p_asn1_rrc->m.drb_ToAddModListPresent = 1;

                /* Generate DRB Information */
                if (RRC_SUCCESS != 
                        uecc_llim_build_erb_modify_asn1_drb_to_add_mod_list(
                            p_uecc_ue_context,
                            &p_asn1_rrc->drb_ToAddModList,
                            p_asn1_ctx))
                {
                    break;
                }
            }
            /*SPR 22036 Fix Start*/
            /* DRB_ToReleaseList */
            if(RRC_TRUE == 
                    p_uecc_ue_context->p_curr_proc_data->u.erab_modify_request_data.is_erab_del_ongoing)
            {
                if (0 < p_uecc_ue_context->p_curr_proc_data->u.erab_modify_request_data.
                        erab_release_command_data.erab_release_list.counter)
                {
                    p_asn1_rrc->m.drb_ToReleaseListPresent = 1; 

                    /* Generate DRB Information */
                    if (RRC_SUCCESS != uecc_llim_build_asn1_modify_drb_to_release_list(
                                p_uecc_ue_context,
                                &p_asn1_rrc->drb_ToReleaseList,
                                p_asn1_ctx))
                    {
                        break;
                    }
                }
            }
            /*SPR 22036 Fix Stop*/

            /* SPS Configuration */
            if ( p_mod_req_data->m.sps_config_updated )
            {
                p_asn1_rrc->m.sps_ConfigPresent = 1;

                if (RRC_SUCCESS != uecc_llim_build_asn1_sps_config(
                            p_uecc_ue_context, 
                            &(p_mod_req_data->sps_config),
                            &p_asn1_rrc->sps_Config,
                            p_asn1_ctx))
                {
                    break;
                }
            }

            /* cr_220 RLF TIMERS & CONSTANTS */
            if( p_uecc_ue_context->m.rlf_timers_and_constants_r9_present )
            {
                p_asn1_rrc->m.rlf_TimersAndConstants_r9Present = 1;
                p_asn1_rrc->m._v2ExtPresent = 1;

                if (RRC_SUCCESS != uecc_llim_build_asn1_rlf_timers_and_constants_r9(
                            p_uecc_ue_context, 
                            (p_uecc_ue_context->p_rlf_timers_and_constants_r9),
                            &p_asn1_rrc->rlf_TimersAndConstants_r9,
                            p_asn1_ctx)
                   )
                {
                    break;
                } 
            } 


            /* main extElem1 */
            rtxDListInit(&p_asn1_rrc->extElem1);

            result = RRC_SUCCESS;
        }
        while(0);
    }
    else if(!(strncmp_wrapper((const S8 *)s_id,(const S8 *)"UE_RRM_UE_RECONFIG_P",
                    strlen_wrapper((const Char8*)s_id))))
    {
        p_rrm_ue_reconfig_request_data = &(p_uecc_ue_context->p_curr_proc_data->u.
                rrm_ue_reconfig_request_data);
        do
        {
            asn1Init_RadioResourceConfigDedicated(p_asn1_rrc);

            /* RadioResourceConfigDedicated_mac_MainConfig */
            if ((p_rrm_ue_reconfig_request_data->m.mac_config_updated) &&
                    (RRM_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT &
                     p_rrm_ue_reconfig_request_data->mac_config.bitmask))
            {
                p_asn1_rrc->m.mac_MainConfigPresent = 1;

                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_INFO,"RRM_UE_RECONFIG: mac_main_config present");


                if (RRC_SUCCESS != uecc_llim_build_asn1_mac_main_config(
                            p_uecc_ue_context,
                            &(p_rrm_ue_reconfig_request_data->mac_config),
                            &p_asn1_rrc->mac_MainConfig,
                            p_asn1_ctx))
                {
                    break;
                }
            }

            /* PhysicalConfigDedicated */
            if ( (p_rrm_ue_reconfig_request_data->m.physical_config_dedicated_updated) &&
                    ((RRC_PHY_TPC_PDCCH_CONFIG_PUCCH_PRESENT &
                      p_rrm_ue_reconfig_request_data->physical_config_dedicated.bitmask) ||
                     (RRC_PHY_TPC_PDCCH_CONFIG_PUSCH_PRESENT &
                      p_rrm_ue_reconfig_request_data->physical_config_dedicated.bitmask) ||
                     (RRC_PHY_CQI_REPORTING_PRESENT &
                      p_rrm_ue_reconfig_request_data->physical_config_dedicated.bitmask) ||
                     (RRC_PHY_SOUNDING_RS_UL_CONFIG_DEDICATED_PRESENT &
                      p_rrm_ue_reconfig_request_data->physical_config_dedicated.bitmask) ||
                     (RRC_PHY_ANTENNA_INFORMATION_PRESENT &
                      p_rrm_ue_reconfig_request_data->physical_config_dedicated.bitmask) ||
                     (RRC_PHY_SCHEDULING_REQUEST_CONFIG_PRESENT &
                      p_rrm_ue_reconfig_request_data->physical_config_dedicated.bitmask) ||
                     /*Dynamic_ue_reconfig+*/
                     (RRC_PHY_PDSCH_CONFIGURATION_DEDICATED_PRESENT &
                      p_rrm_ue_reconfig_request_data->physical_config_dedicated.bitmask)||
                     (RRC_PHY_ANTENNA_INFO_V920_PRESENT &
                      p_rrm_ue_reconfig_request_data->physical_config_dedicated.bitmask)||
                     (RRC_PHY_UPLINK_POWER_CONTROL_DEDICATED_PRESENT &
                      p_rrm_ue_reconfig_request_data->physical_config_dedicated.bitmask) ||
                     //		(RRC_PHY_PUSCH_CONFIGURATION_DEDICATED_PRESENT &
                     //		 p_rrm_ue_reconfig_request_data->physical_config_dedicated.bitmask))
                     /*Dynamic_ue_reconfig-*/
                     /*Bug_12444_fix_start*/
                     (RRC_PHY_ANTENNA_INFO_R10_PRESENT &
                      p_rrm_ue_reconfig_request_data->physical_config_dedicated.bitmask) ||
                     (RRC_PHY_ANTENNA_INFO_UL_R10_PRESENT &
                      p_rrm_ue_reconfig_request_data->physical_config_dedicated.bitmask) ||
                     (RRC_PHY_CQI_REPORT_CONFIG_R10_PRESENT &
                      p_rrm_ue_reconfig_request_data->physical_config_dedicated.bitmask) ||
                     (RRC_PHY_CONFIG_DEDICATED_EXTENDED_PRESENT &
                      p_rrm_ue_reconfig_request_data->physical_config_dedicated.bitmask)
                     /*Bug_12444_fix_stop*/

                     ) )
                     {
                         p_asn1_rrc->m.physicalConfigDedicatedPresent = 1;

                         RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                 (p_uecc_ue_context->p_gb_context)->facility_name,
                                 RRC_INFO,"RRM_UE_RECONFIG: rrc_phy_physical_config_dedicated present");

                         if (RRC_SUCCESS != uecc_llim_build_asn1_physical_config_dedicated(
                                     p_uecc_ue_context,
                                     &(p_rrm_ue_reconfig_request_data->physical_config_dedicated),
                                     &p_asn1_rrc->physicalConfigDedicated,
                                     p_asn1_ctx))
                         {
                             RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                     (p_uecc_ue_context->p_gb_context)->facility_name,
                                     RRC_ERROR, "[DynamicUeReconf] : ERROR IN BUILDING PHY CONFIG DEDICATED");
                             break;
                         }
                     }
            /* eICIC ue reconfig changes start */
            /* SPR 19838 : Coverity 10057 fix start */
            if ( (p_rrm_ue_reconfig_request_data->m.meas_subframe_pattern_pcell_updated) && 
                    (p_rrm_ue_reconfig_request_data->rrc_meas_subframe_pattern_pcell_r10.bitmask & 
                     MEAS_SUBFRAME_PATTERN_PCELL_R10_SETUP_PRESENT))
            /* SPR 19838 : Coverity 10057 fix end */
            {
                p_asn1_rrc->m._v3ExtPresent = 1;
                p_asn1_rrc->m.measSubframePatternPCell_r10Present = 1;

                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_INFO,"RRM_UE_RECONFIG: rrc_meas_subframe_pattern_pcell_r10 present");

                if (RRC_SUCCESS != uecc_llim_build_asn1_meas_subframe_pattern_pcell_r10(
                            p_uecc_ue_context,
                            &(p_rrm_ue_reconfig_request_data->rrc_meas_subframe_pattern_pcell_r10),
                            &(p_asn1_rrc->measSubframePatternPCell_r10),
                            p_asn1_ctx))
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR, "[DynamicUeReconf] : ERROR IN BUILDING MEAS SUBFRAME PATTERN PCELL R10");
                    break;
                }

            }
            /* eICIC ue reconfig changes stop */

            /* main extElem1 */
            rtxDListInit(&p_asn1_rrc->extElem1);

            result = RRC_SUCCESS;
        }
        while(0);
    }


    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_fill_erb_modify_drb_info
 *   INPUT        : RRCConnectionReconfiguration_r8_IEs    *p_r8
 *                  uecc_ue_context_t                      *p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function fills the DRB information for the 
 *       RRCConnectionReconfiguration message sent to LLIM
 *
 *   RETURNS:
 *       void
 *
 ******************************************************************************/
void uecc_llim_fill_erb_modify_drb_info
(
 RRCConnectionReconfiguration_r8_IEs    *p_r8,
 uecc_ue_context_t                      *p_uecc_ue_context 
 )
{
    rrc_counter_t drb_index = RRC_NULL;
    rrc_counter_t count     = RRC_NULL;

    erab_modify_list_t    *p_mod_list = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_mod_list = &(p_uecc_ue_context->p_curr_proc_data->u.
            erab_modify_request_data.erab_modify_list);

    count =  p_mod_list->erab_modify_list_counter;


    for (drb_index =0; drb_index <count; drb_index++)
    {
        /* Add  DedicatedInfoNAS */
        if  (0 < count )  
        {
            p_r8->m.dedicatedInfoNASListPresent = 1;
            p_r8->dedicatedInfoNASList.n++;
            p_r8->dedicatedInfoNASList.elem[drb_index] =
                p_mod_list->erab_modify_item[drb_index].nAS_PDU;
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_add_rollback_resp
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_ADD_ROLLBACK_RESP message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_add_rollback_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*                   p_ue_context             = PNULL;
    rrc_uecc_llim_add_rollback_resp_t*    p_llim_add_rollback_resp = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_add_rollback_resp =
        (rrc_uecc_llim_add_rollback_resp_t*)((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_add_rollback_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_add_rollback_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_ADD_ROLLBACK_RESP] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context,p_llim_add_rollback_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_ADD_ROLLBACK_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Check transaction_id */
    if (p_llim_add_rollback_resp->transaction_id !=
            uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /* Error. Invalid transaction id */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_ADD_ROLLBACK_RESP] Invalid transaction id.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_RM_EVENT_LLIM_RECONFIG_UE_RESP event handler in RM FSM *
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_ADD_ROLLBACK_RESP,
            p_llim_add_rollback_resp);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_radio_link_failure_ind
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_RADIO_LINK_FAILURE_IND  message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
/* SPR 15644 fix start */
void uecc_llim_process_sync_status_ind
/* SPR 15644 fix end */
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{

    rrc_uecc_llim_radio_link_failure_ind_t*
        p_uecc_llim_radio_link_failure_ind_t = PNULL ;
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_rrm_ue_sync_status_t ue_sync_status_api;

    memset_wrapper(&ue_sync_status_api,0,sizeof(rrc_rrm_ue_sync_status_t));
    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_uecc_llim_radio_link_failure_ind_t =
        (rrc_uecc_llim_radio_link_failure_ind_t*)((U8*)p_api + RRC_API_HEADER_SIZE);    
    /* SPR 15790 Fix Delete Start */ 
    /* SPR 15790 Fix Delete Stop */

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_radio_link_failure_ind_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                /* SPR 15644 fix start */
                "[UECC_LLIM_SYNC_STATUS_IND - ue_index[%d] ue_sync_status[%d]]"
                " Wrong message size - ignore.", 
                p_uecc_llim_radio_link_failure_ind_t->ue_index,
                p_uecc_llim_radio_link_failure_ind_t->ue_sync_status);
        /* SPR 15644 fix end */
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            p_uecc_llim_radio_link_failure_ind_t->ue_index);

    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            /* SPR 15644 fix start */
            RRC_INFO, "RRC_MSG: UECC_LLIM_SYNC_STATUS_IND received - ue_index[%d] "
            "cell_index[%d] ue_sync_status[%d] ",
            p_uecc_llim_radio_link_failure_ind_t->ue_index,
            p_uecc_llim_radio_link_failure_ind_t->cell_index,
            p_uecc_llim_radio_link_failure_ind_t->ue_sync_status );
    /* SPR 15644 fix end */

    if(RRC_NULL != p_ue_context)
    {
        /* SPR 15912 Start */
        /* Code Removed */
        /* SPR 15912 Stop */
        /* sync changes start */
        if(RRC_MAC_OUT_OF_SYN_MAX_RETRIES >= p_uecc_llim_radio_link_failure_ind_t->ue_sync_status)
        {
            ue_sync_status_api.ue_index = p_uecc_llim_radio_link_failure_ind_t->ue_index;
            ue_sync_status_api.rrc_rrm_ue_sync_status = p_uecc_llim_radio_link_failure_ind_t->ue_sync_status;

            rrc_rrm_il_send_rrc_rrm_ue_sync_status(
                    &ue_sync_status_api,
                    RRC_UECC_MODULE_ID,
                    RRC_RRM_MODULE_ID,
                    rrc_get_transaction_id(p_api),
                    p_uecc_llim_radio_link_failure_ind_t->cell_index);
        }
        if ((RRC_MAC_OUT_OF_SYN_MAX_RETRIES == p_uecc_llim_radio_link_failure_ind_t->ue_sync_status) ||
                (RRC_INVALID_UE_SYNC_NUM == p_uecc_llim_radio_link_failure_ind_t->ue_sync_status))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "INVALID UE MAC SYNC STATUS or RRC_MAC_OUT_OF_SYNC_MAX_RETRIES REACHED");
            /*SPR 17421 Fix Start*/
            if (RRC_TRUE == p_ue_context->is_meas_transaction_id_valid)
            {
                uecc_ue_timer_stop(
                        p_uecc_gb_context, 
                        UECC_UE_MEAS_CONFIG_GUARD_TIMER, 
                        &p_ue_context->timers_data);

                /* Reset the transaction-id */
                p_ue_context->is_meas_transaction_id_valid = RRC_FALSE;

                /*Rollback the Measurement Gap Configuration at MAC*/

                if ((p_ue_context->p_meas_config) && (p_ue_context->
                            p_meas_config->bitmask & UE_ADM_MEAS_GAP_CONFIG_PRESENT))
                {
                    if (RRC_SUCCESS != uecc_llim_build_and_send_rollback_meas_config_req
                            (p_ue_context))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_ERROR,
                                "[UECC_LLIM_MEAS_CONFIG_REQ] Message sending failed .");
                    }
                }
                /* Build and send the RRC_RRM_MEAS_CONFIG_RESP(Failure) to RRM */
                if (RRC_SUCCESS != uecc_rrm_build_and_send_meas_config_resp(
                            p_ue_context,RRC_FAILURE, RRC_RADIO_LINK_FAILURE_TRIGGERED))
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "Failure to build and send meas config resp to RRM.");
                }
            }
            /*SPR 17421 Fix End*/ 
        }
        else
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "UE MAC SYNC STATUS RECEIVED");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }
        /* sync changes stop */

        /* SPR 15912 Start */
        /* meas changes start */
        /*Check for ongoing meas_config procedure */
        if (RRC_TRUE == p_ue_context->is_meas_transaction_id_valid)
        {
            /* SPR 14289 Fix Start */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO,
                    "RRC Reconfiguration ongoing for MEAS - ignore.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
            /* SPR 14289 Fix Stop */
        }
        /* meas changes end */
        /* SPR 15912 Stop */

        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_LLIM_RADIO_LINK_FAILURE_IND,
                p_uecc_llim_radio_link_failure_ind_t);
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: 
 *       uecc_llim_build_and_send_ics_rrc_connection_reconfiguration
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds and sends UECC_LLIM_SRB_DATA_REQ message
 *       with RRCConnectionReconfiguration to LLIM
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et 
uecc_llim_build_and_send_ics_rrc_connection_reconfiguration(
        uecc_ue_context_t*  p_uecc_ue_context
        )
{
    OSCTXT                                  asn1_ctx;
    DL_DCCH_Message                         dl_dcch_msg;
    RRCConnectionReconfiguration*           p_rrc_conn_recfg = PNULL;
    RRCConnectionReconfiguration_r8_IEs*    p_r8             = PNULL;
    rrc_return_et                           result           = RRC_FAILURE;
    rrm_srb_info_t      srb_info;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&dl_dcch_msg, 0, sizeof(dl_dcch_msg));

    /* Initialize the ASN Context */
    uecc_llim_init_asn_context(&asn1_ctx,p_uecc_ue_context);

    do {
        if (RRC_SUCCESS ==  uecc_llim_build_dl_dcch_msg(
                    &dl_dcch_msg,
                    &asn1_ctx,
                    p_uecc_ue_context,
                    &p_rrc_conn_recfg))
        {

            p_r8 = 
                rtxMemAllocType(&asn1_ctx, RRCConnectionReconfiguration_r8_IEs);
            if (PNULL == p_r8)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[RRCConnectionReconfiguration] ASN malloc failed.");
                break;
            }
            p_rrc_conn_recfg->criticalExtensions.u.c1->
                u.rrcConnectionReconfiguration_r8 = p_r8;
            asn1Init_RRCConnectionReconfiguration_r8_IEs(
                    p_r8);

            p_r8->m.radioResourceConfigDedicatedPresent = 1;

            /* SRB 2 INFO */
            if (p_uecc_ue_context->m.srb2_config_present && 
                    p_uecc_ue_context->m.srb2_config_updated)
            {    
                srb_info.bitmask = RRM_SRB_INFO_SRB2_CONFIG_PRESENT;
                srb_info.srb2_config = p_uecc_ue_context->srb2_config;
            }
            /* Fill RadioResourceConfigDedicated*/
            if (RRC_SUCCESS != 
                    uecc_llim_build_ics_asn1_radio_resource_cfg_dedicated(
                        p_uecc_ue_context,
                        &p_r8->radioResourceConfigDedicated,
                        &srb_info,
                        &asn1_ctx))
            {
                break;
            }       

            p_uecc_ue_context->curr_meas_config.is_meas_config_valid = 
                RRM_RRC_MC_VALIDATE_FAILURE;
            /* Measurment Re-config START */
            /* Meas Config */
            if ( p_uecc_ue_context->m.meas_config_updated )
            {
                /* SPR_5736 Start */
                if (p_uecc_ue_context->p_meas_config != PNULL)
                {	       
                    if ((UE_ADM_MEAS_OBJECT_TO_REMOVE_LIST_PRESENT & 
                                p_uecc_ue_context->p_meas_config->bitmask) ||
                            (UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT &
                             p_uecc_ue_context->p_meas_config->bitmask)||
                            (UE_ADM_MEAS_ID_TO_REMOVE_LIST_PRESENT &
                             p_uecc_ue_context->p_meas_config->bitmask))
                    {
                        p_uecc_ue_context->curr_meas_config.is_meas_config_valid = 
                            RRM_RRC_MC_VALIDATE_FAILURE;
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_WARNING,
                                "[RRCConnectionReconfiguration] "
                                "Remove meas config List is present.");
                        break;
                    }
                    else if (RRC_SUCCESS != uecc_llim_build_MeasConfig(
                                p_uecc_ue_context,
                                p_uecc_ue_context->p_meas_config,
                                &asn1_ctx,
                                &p_r8->measConfig))
                    {
                        break;
                    }
                    p_uecc_ue_context->curr_meas_config.is_meas_config_valid =
                        RRM_RRC_MC_VALIDATE_SUCCESS;
                    p_r8->m.measConfigPresent = 1;
                }
                /* SPR_5736 Stop */
            }
            /* Measurment Re-config END */

            /* Fill reportProximityConfig_r9 if received from RRM */
            if ( p_uecc_ue_context->m.proximity_config_present)
            {
                p_r8->m.nonCriticalExtensionPresent = 1;
                p_r8->nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
                p_r8->nonCriticalExtension.nonCriticalExtension.m.otherConfig_r9Present = 1;
                p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.m.
                    reportProximityConfig_r9Present= 1;

                if ( p_uecc_ue_context->proximity_config.bitmask &
                        RRM_PROXIMITY_IND_EUTRA_PRESENT)
                {
                    p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                        reportProximityConfig_r9.proximityIndicationEUTRA_r9 =
                        p_uecc_ue_context->proximity_config.proximity_ind_eutra;

                    p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                        reportProximityConfig_r9.m.proximityIndicationEUTRA_r9Present= 1;
                }

                if (p_uecc_ue_context->proximity_config.bitmask &
                        RRM_PROXIMITY_IND_UTRA_PRESENT)
                {
                    p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                        reportProximityConfig_r9.proximityIndicationUTRA_r9 =
                        p_uecc_ue_context->proximity_config.proximity_ind_utra;

                    p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                        reportProximityConfig_r9.m.proximityIndicationUTRA_r9Present= 1;
                }
            }

#ifdef ENDC_ENABLED
            /*NR_DC Code Change Start*/
            uecc_llim_build_nr_rrc_connection_reconfig_r15_ies(
                    &asn1_ctx,
                    p_r8,
                    p_uecc_ue_context,
                    ICS_SETUP
                    );
            /*NR_DC Code Change Stop*/
#endif

            /* Fix for NAS PDU missing*/
            uecc_llim_build_erb_setup_dedicated_nas_info(
                    p_r8,
                    p_uecc_ue_context
                    );

            result = uecc_llim_send_rrc_connection_reconfiguration(
                    p_uecc_ue_context,
                    &asn1_ctx, &dl_dcch_msg);
            if (result == RRC_FAILURE)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[RRCConnectionReconfiguration] Message sending failed .");

            }
        }
    }while(0);

    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}



/******************************************************************************
 *   FUNCTION NAME: 
 *       uecc_llim_build_and_send_erb_setup_rrc_connection_reconfiguration
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function builds and sends UECC_LLIM_SRB_DATA_REQ message
 *       with RRCConnectionReconfiguration to LLIM
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et 
uecc_llim_build_and_send_erb_setup_rrc_connection_reconfiguration(
        uecc_ue_context_t*  p_uecc_ue_context
        )
{
    OSCTXT                                  asn1_ctx;
    DL_DCCH_Message                         dl_dcch_msg;
    RRCConnectionReconfiguration*           p_rrc_conn_recfg = PNULL;
    RRCConnectionReconfiguration_r8_IEs*    p_r8             = PNULL;
    rrc_return_et                           result           = RRC_FAILURE;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&dl_dcch_msg, 0, sizeof(dl_dcch_msg));

    /* Initialize the ASN Context */
    uecc_llim_init_asn_context(&asn1_ctx,p_uecc_ue_context);

    do {
        if (RRC_SUCCESS ==  uecc_llim_build_dl_dcch_msg(
                    &dl_dcch_msg,
                    &asn1_ctx,
                    p_uecc_ue_context,
                    &p_rrc_conn_recfg))
        {

            p_r8 = 
                rtxMemAllocType(&asn1_ctx, RRCConnectionReconfiguration_r8_IEs);
            if (PNULL == p_r8)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[RRCConnectionReconfiguration] ASN malloc failed.");
                break;
            }
            p_rrc_conn_recfg->criticalExtensions.u.c1->
                u.rrcConnectionReconfiguration_r8 = p_r8;
            asn1Init_RRCConnectionReconfiguration_r8_IEs(
                    p_r8);

            p_r8->m.radioResourceConfigDedicatedPresent = 1;


            /*HANDOVER_CHANGES_REVANTH_01_begin*/
            /* If this is case of target HO then SRB1 config,
               mobilityControlInfo and securityConfigHO are present */
            if (p_uecc_ue_context->ho_info.p_ho_info &&
                    p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info)
            {
                /* SPR 18253 Fix Start */
                /* Use SRB1 configuration from UE context hear */
                /* srb_info.bitmask = RRM_SRB_INFO_SRB1_CONFIG_PRESENT;
                srb_info.srb1_config = p_uecc_ue_context->srb1_config; */

                /*The field is mandatory present in case of handover 
                  within E-UTRA or to E-UTRA; otherwise the field is not present.*/
                if ( (INVALID_HO != p_uecc_ue_context->ho_info.s1_or_x2_handover) &&
                        (p_uecc_ue_context->ho_info.p_ho_info->ho_type == 
                        HANDOVER_TYPE_INTRA_LTE_S1 ||
                        p_uecc_ue_context->ho_info.s1_or_x2_handover ==
                        X2_HO ||
                        p_uecc_ue_context->ho_info.p_ho_info->
                        ho_type == HANDOVER_TYPE_UTRAN_TO_LTE ||
                        p_uecc_ue_context->ho_info.p_ho_info->
                        ho_type == HANDOVER_TYPE_GERAN_TO_LTE ||
                        p_uecc_ue_context->ho_info.s1_or_x2_handover ==
                        INTER_CELL_HO )) 
                /* SPR 18253 Fix Stop */

                {
                    /*MobilityControlInfo*/
                    p_r8->m.mobilityControlInfoPresent = 1;

                    if (RRC_FAILURE == uecc_llim_encode_mobilityControlInfo(
                                p_uecc_ue_context,
                                &asn1_ctx,
                                &p_r8->mobilityControlInfo ))
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_WARNING,
                                "uecc_llim_encode_mobilityControlInfo failed.");
                        break;
                    }

                    /*SecurityConfigHO*/
                    p_r8->m.securityConfigHOPresent = 1;
                    if (p_uecc_ue_context->ho_info.p_ho_info->ho_type == 
                            HANDOVER_TYPE_INTRA_LTE_S1 ||
                            p_uecc_ue_context->ho_info.s1_or_x2_handover ==
                            X2_HO || 
                            p_uecc_ue_context->ho_info.s1_or_x2_handover ==
                            INTER_CELL_HO)
                    {
                        p_r8->securityConfigHO.handoverType.t = 
                            T_SecurityConfigHO_handoverType_intraLTE;

                        p_r8->securityConfigHO.handoverType.u.intraLTE
                            = (SecurityConfigHO_handoverType_intraLTE*)
                            rtxMemAllocType(&asn1_ctx, 
                                    SecurityConfigHO_handoverType_intraLTE);

                        if (PNULL == p_r8->securityConfigHO.
                                handoverType.u.intraLTE)
                        {
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_ERROR,
                                    "[RRCConnectionReconfiguration] ASN "
                                    "malloc failed.");
                            break;
                        }

                        p_r8->securityConfigHO.handoverType.u.intraLTE->m.
                            securityAlgorithmConfigPresent = 1;

                        /* Presently setting FALSE*/
                        p_r8->securityConfigHO.handoverType.u.
                            intraLTE->keyChangeIndicator = RRC_FALSE;

                        p_r8->securityConfigHO.handoverType.u.intraLTE->
                            nextHopChainingCount 
                            = p_uecc_ue_context->ncc;

                        p_r8->securityConfigHO.handoverType.u.intraLTE->
                            securityAlgorithmConfig.cipheringAlgorithm =
                            p_uecc_ue_context->configure_ciphering.algorithm_id;

                        p_r8->securityConfigHO.handoverType.u.intraLTE->
                            securityAlgorithmConfig.integrityProtAlgorithm =
                            p_uecc_ue_context->configure_integrity_protection.
                            algorithm_id;
                    }
                    else
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_INFO,
                                "Only INTRA_LTE supported presently!!");
                    }
                }
            }
            /*HANDOVER_CHANGES_REVANTH_01_end*/


            /* Fill RadioResourceConfigDedicated*/
            if (RRC_SUCCESS != 
                    uecc_llim_build_erb_setup_asn1_radio_resource_cfg_dedicated(
                        p_uecc_ue_context,
                        &p_r8->radioResourceConfigDedicated,
                        &asn1_ctx))
            {
                break;
            }       

            /* Meas Config */
            #ifdef ENDC_ENABLED
            if ( ( UECC_RRM_DC_BEARER_CHANGE_PROC == p_uecc_ue_context->
                    p_curr_proc_data->t ) &&
                 ( p_uecc_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data.
                   m.endc_meas_config_updated )
               )
            {
                if (RRC_SUCCESS != uecc_llim_build_MeasConfig_endc(
                            p_uecc_ue_context,
                            &p_uecc_ue_context->p_curr_proc_data->u.
                            rrm_dc_bearer_change_request_data.endc_meas_config,
                            &asn1_ctx,
                            &p_r8->measConfig))
                {
                    break;
                }
                p_r8->m.measConfigPresent = 1;
            }
            #endif

            /* Meas Config */
            if ( p_uecc_ue_context->m.meas_config_updated )
            {
                if (RRC_SUCCESS != uecc_llim_build_MeasConfig(
                            p_uecc_ue_context,
                            &p_uecc_ue_context->p_curr_proc_data->u.
                            erab_setup_request_data.erab_op_params.meas_config,
                            &asn1_ctx,
                            &p_r8->measConfig))
                {
                    break;
                }
                p_r8->m.measConfigPresent = 1;
            }

            /* Fix for NAS PDU missing*/
            uecc_llim_build_erb_setup_dedicated_nas_info(
                    p_r8,
                    p_uecc_ue_context
                    );

            /* Fill reportProximityConfig_r9 if received from RRM */
            if ( p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                    erab_op_params.m.proximity_config_present)
            {
                p_r8->m.nonCriticalExtensionPresent = 1;
                p_r8->nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
                p_r8->nonCriticalExtension.nonCriticalExtension.m.otherConfig_r9Present = 1;
                p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.m.
                    reportProximityConfig_r9Present= 1;

                if ( p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                        erab_op_params.proximity_config.bitmask &
                        RRM_PROXIMITY_IND_EUTRA_PRESENT)
                {
                    p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                        reportProximityConfig_r9.proximityIndicationEUTRA_r9 = 
                        p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                        erab_op_params.proximity_config.proximity_ind_eutra;

                    p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                        reportProximityConfig_r9.m.proximityIndicationEUTRA_r9Present= 1;
                }

                if ( p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                        erab_op_params.proximity_config.bitmask &
                        RRM_PROXIMITY_IND_UTRA_PRESENT)
                {
                    p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                        reportProximityConfig_r9.proximityIndicationUTRA_r9 = 
                        p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                        erab_op_params.proximity_config.proximity_ind_utra;

                    p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                        reportProximityConfig_r9.m.proximityIndicationUTRA_r9Present= 1;
                }
            }


#ifdef ENDC_ENABLED
            /*NR_DC Code Change Start*/
            uecc_llim_build_nr_rrc_connection_reconfig_r15_ies(
                    &asn1_ctx,
                    p_r8,
                    p_uecc_ue_context,
                    ERAB_SETUP
                    );
            /*NR_DC Code Change Stop*/
#endif
            result = uecc_llim_send_rrc_connection_reconfiguration(
                    p_uecc_ue_context,
                    &asn1_ctx, &dl_dcch_msg);
            if (result == RRC_FAILURE)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[RRCConnectionReconfiguration] Message sending failed .");

            }
            else
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_INFO,
                        "[RRC PROTOCOL] RRC CONNECTION RECONFIGURATION SENT\n");
            }

        }
    }while(0);

    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/* Measurment Re-config START */
/******************************************************************************
 *   FUNCTION NAME: 
 *       uecc_llim_build_and_send_meas_reconfig_rrc_connection_reconfiguration
 *   INPUT        :OSCTXT                                  asn1_ctx
 *                 DL_DCCH_Message                         dl_dcch_msg
 *                 RRCConnectionReconfiguration*           p_rrc_conn_recfg = PNULL
 *                 RRCConnectionReconfiguration_r8_IEs*    p_r8             = PNULL;
 *                 rrc_return_et                           result           = RRC_FAILURE
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds and sends UECC_LLIM_SRB_DATA_REQ message
 *       with RRCConnectionReconfiguration to LLIM
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_meas_reconfig_rrc_connection_reconfiguration(
        uecc_ue_context_t*  p_uecc_ue_context
        )
{
    OSCTXT                                  asn1_ctx;
    DL_DCCH_Message                         dl_dcch_msg;
    RRCConnectionReconfiguration*           p_rrc_conn_recfg = PNULL;
    RRCConnectionReconfiguration_r8_IEs*    p_r8             = PNULL;
    rrc_return_et                           result           = RRC_FAILURE;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&dl_dcch_msg, 0, sizeof(dl_dcch_msg));

    /* Initialize the ASN Context */
    uecc_llim_init_asn_context(&asn1_ctx,p_uecc_ue_context);

    do {
        /* save the transaction_id in meas_transaction_id variable in UE context */
        uecc_ue_ctx_set_meas_transction_id(p_uecc_ue_context,
                uecc_ue_ctx_get_next_transction_id(p_uecc_ue_context));

        if (RRC_SUCCESS ==  uecc_llim_build_dl_dcch_meas_msg(
                    &dl_dcch_msg,
                    &asn1_ctx,
                    p_uecc_ue_context,
                    &p_rrc_conn_recfg))
        {

            p_r8 = 
                rtxMemAllocType(&asn1_ctx, RRCConnectionReconfiguration_r8_IEs);
            if (PNULL == p_r8)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[RRCConnectionReconfiguration] ASN malloc failed.");
                break;
            }
            p_rrc_conn_recfg->criticalExtensions.u.c1->
                u.rrcConnectionReconfiguration_r8 = p_r8;
            asn1Init_RRCConnectionReconfiguration_r8_IEs(
                    p_r8);

            /* Measurment Re-config START */
            /* For Testing purpose */
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_INFO,
                    "[RRC_RRM_MEAS_CONFIG_REQ] start rrcConnectionReconfig");

            p_uecc_ue_context->is_meas_transaction_id_valid = RRC_TRUE;

            if (p_uecc_ue_context->curr_meas_config.is_meas_config_valid ==
                    RRM_RRC_MC_VALIDATE_SUCCESS)
            {
                if (RRC_SUCCESS != uecc_llim_build_MeasConfig(
                            p_uecc_ue_context,
                            p_uecc_ue_context->p_meas_config,
                            &asn1_ctx,
                            &p_r8->measConfig))
                {
                    break;
                }
                p_r8->m.measConfigPresent = 1;
            }
            result = uecc_llim_send_rrc_connection_reconfiguration(
                    p_uecc_ue_context,
                    &asn1_ctx, &dl_dcch_msg);
            if (result == RRC_FAILURE)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[RRCConnectionReconfiguration] Message sending failed .");

            }
        }
    }while(0);

    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}
/* Measurment Re-config END */


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_erb_setup_dedicated_nas_info
 *   INPUT        : RRCConnectionReconfiguration_r8_IEs*    p_r8
 *                  uecc_ue_context_t*    p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function fills dedicated NAS Info
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
void uecc_llim_build_erb_setup_dedicated_nas_info(
        RRCConnectionReconfiguration_r8_IEs*    p_r8,     
        uecc_ue_context_t*    p_uecc_ue_context
        )
{

    U8 erab_counter  = RRC_NULL;
    U8 erab_id_count = RRC_NULL;
    U8 erab_id       = RRC_NULL;
    U8 nas_pdu_count = RRC_NULL;

    uecc_rm_erab_setup_info_t*    p_erab_setup_list = &p_uecc_ue_context->
        p_curr_proc_data->u.erab_setup_request_data.erab_info_data;


    RRC_ASSERT(PNULL != p_r8);
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Count of temporary ERAB List */
    erab_id_count = p_erab_setup_list->count;

    /* Copy NAS PDU for Successful ERAB from UE Context */
    for (erab_counter = 0; erab_counter < erab_id_count; erab_counter++)
    {
        if (RRC_NO_ERROR == p_erab_setup_list->erab_info[erab_counter].status)
        {
            erab_id = p_erab_setup_list->erab_info[erab_counter].erab_id;
            if (p_uecc_ue_context->p_e_rab_list[erab_id]->m.nAS_PDUPresent)
            {
                p_r8->dedicatedInfoNASList.elem[nas_pdu_count] =
                    p_uecc_ue_context->p_e_rab_list[erab_id]->nAS_PDU;
                nas_pdu_count++;
            }
        }
    }

    if ( nas_pdu_count > 0)
    {
        p_r8->m.dedicatedInfoNASListPresent = 1;
        p_r8->dedicatedInfoNASList.n = nas_pdu_count;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_s1ap_cause
 *   INPUT        : uecc_gb_context_t   *p_uecc_gb_context
 *                  s1ap_Cause*         p_cause
 *                  rrc_response_t      response_code
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds s1ap_Cause
 *
 *   RETURNS:
 *       None
 *
 *******************************************************************************/
rrc_return_et uecc_llim_build_s1ap_cause(
        uecc_gb_context_t   *p_uecc_gb_context,
        s1ap_Cause*         p_cause,
        rrc_response_t      response_code
        )
{

    rrc_return_et result = RRC_SUCCESS;
    U32 error_code = RRC_NULL;

   RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
    RRC_ASSERT(PNULL != p_cause);
    /* Fetch 16 bit error code */
    error_code = (U32)(response_code & 0x00FF);

    /* MAP APPROPRIATE RESPONSE CODE IN FUTURE */
    /* Currently Map to unspecified */
    p_cause->t = T_s1ap_Cause_radioNetwork; 

    if (RRC_RADIO_LINK_FAILURE_TRIGGERED == error_code)
    {
        p_cause->u.radioNetwork = s1ap_radio_connection_with_ue_lost;
    }
    else if (RRC_REESTABLISHMENT_TRIGGERED == error_code)
    {
        p_cause->u.radioNetwork = s1ap_interaction_with_other_procedure;
    }
    else if (RRC_HANDOVER_TRIGGERED == error_code)
    {
        p_cause->u.radioNetwork = s1ap_interaction_with_other_procedure;
    }
    /*SPR 15473 Fix Start*/
    else if (RRC_TIMER_EXPIRY == error_code)
    {
        p_cause->u.radioNetwork = s1ap_failure_in_radio_interface_procedure;
    }
    /*SPR 15473 Fix Stop*/ 
    else
    {
        p_cause->u.radioNetwork = s1ap_unspecified_2;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return result;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_suspend_ue_entity_cnf
 *   INPUT        : void*                p_api
 *                  uecc_gb_context_t*   p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function processes UECC_LLIM_SUSPEND_UE_ENTITY_CNF  message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_suspend_ue_entity_resp
(
 void*                p_api,             /* Input API buffer */
 uecc_gb_context_t*   p_uecc_gb_context  /* UECC global context */
 )
{
    rrc_uecc_llim_suspend_ue_entity_req_t*
        p_rrc_uecc_llim_suspend_ue_entity_req = PNULL ;
    uecc_ue_context_t               *p_ue_context = PNULL;

    RRC_ASSERT(PNULL != p_api );
    RRC_ASSERT(PNULL != p_uecc_gb_context );
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);


    p_rrc_uecc_llim_suspend_ue_entity_req = 
        (rrc_uecc_llim_suspend_ue_entity_req_t*)((U8*)p_api + RRC_API_HEADER_SIZE); 

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_rrc_uecc_llim_suspend_ue_entity_req->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            p_rrc_uecc_llim_suspend_ue_entity_req->ue_index);

    if (p_ue_context == PNULL)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR ,
                "[UECC_EV_LLIM_SUSPEND_UE_ENTITY_RESP] UE Context not found ");
    }
    else
    {
        if( p_rrc_uecc_llim_suspend_ue_entity_req->transaction_id !=
                uecc_ue_ctx_get_op_transction_id(p_ue_context))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR ,
                    "[UECC_EV_LLIM_SUSPEND_UE_ENTITY_RESP] mismatching transaction id ");

        }

        uecc_event_queue_push_event (UECC_EV_LLIM_SUSPEND_UE_ENTITY_RESP,
                p_ue_context,
                p_rrc_uecc_llim_suspend_ue_entity_req);
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);


}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_modify_rollback_resp
 *   INPUT        : void*                p_api
 *                  uecc_gb_context_t*   p_uecc_gb_context
 *   OUTPUT       : none
 *   
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_MODIFY_ROLLBACK_RESP message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_modify_rollback_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*                      p_ue_context             = PNULL;
    rrc_uecc_llim_modify_rollback_resp_t*   p_llim_mod_rollback_resp = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);

    p_llim_mod_rollback_resp =
        (rrc_uecc_llim_modify_rollback_resp_t*)((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_mod_rollback_resp->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }


    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_modify_rollback_resp_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_MODIFY_ROLLBACK_RESP] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context,p_llim_mod_rollback_resp->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_MODIFY_ROLLBACK_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Check transaction_id */
    if (p_llim_mod_rollback_resp->transaction_id !=
            uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /* Error. Invalid transaction id */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_MODIFY_ROLLBACK_RESP] Invalid transaction id.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_MODIFY_ROLLBACK_RESP,
            p_llim_mod_rollback_resp);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_rrc_uecc_llim_ho_rach_resource_req
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *                  rrc_bool_et         enable_intra_enb_ho
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds and sends rrc_uecc_llim_ho_rach_resource_req message
 *       to LLIM module. 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_rrc_uecc_llim_ho_rach_resource_req
(
 uecc_ue_context_t*  p_uecc_ue_context
 /*BUG 604 changes start*/
 //rrc_bool_et         enable_intra_enb_ho
 /*BUG 604 changes start*/
 )
{
    rrc_return_et response =RRC_FAILURE;
    rrc_uecc_llim_ho_rach_resource_req_t        
        rrc_uecc_llim_ho_rach_resource_req;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&rrc_uecc_llim_ho_rach_resource_req, RRC_NULL,
            sizeof(rrc_uecc_llim_ho_rach_resource_req));
    /* Fill message */
    rrc_uecc_llim_ho_rach_resource_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
    rrc_uecc_llim_ho_rach_resource_req.ue_index = 
        p_uecc_ue_context->ue_index;
    rrc_uecc_llim_ho_rach_resource_req.cell_index = 
        p_uecc_ue_context->cell_index;

    /*BUG 604 changes start*/
    /*BUG 604 changes stop*/

    /* Sending UECC_LLIM_HO_RACH_RESOURCE_REQ to LLIM */
    response = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_HO_RACH_RESOURCE_REQ ,
            sizeof(rrc_uecc_llim_ho_rach_resource_req),
            &rrc_uecc_llim_ho_rach_resource_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_rrc_uecc_llim_ho_rach_rel_resource_ind
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds and sends 
 rrc_uecc_llim_ho_rach_rel_resource_ind message to LLIM module. 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_rrc_uecc_llim_ho_rach_rel_resource_ind
(
 uecc_ue_context_t*  p_uecc_ue_context
 )
{
    rrc_return_et response = RRC_FAILURE;
    rrc_uecc_llim_ho_rach_rel_resource_ind_t        
        rrc_uecc_llim_ho_rach_rel_resource_ind;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* initializing */
    memset_wrapper(&rrc_uecc_llim_ho_rach_rel_resource_ind,
            0, sizeof(rrc_uecc_llim_ho_rach_rel_resource_ind));
    /* Fill message */
    if (RRC_INVALID_RNTI != p_uecc_ue_context->crnti)
    {
        rrc_uecc_llim_ho_rach_rel_resource_ind.bitmask |=
            RRC_UECC_LLIM_HO_RACH_REL_RESOURCE_IND_CRNTI_PRESENT;

        rrc_uecc_llim_ho_rach_rel_resource_ind.crnti =
            p_uecc_ue_context->crnti;
    }
    rrc_uecc_llim_ho_rach_rel_resource_ind.transaction_id = 
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
    rrc_uecc_llim_ho_rach_rel_resource_ind.ue_index = 
        p_uecc_ue_context->ue_index;
    rrc_uecc_llim_ho_rach_rel_resource_ind.cell_index = 
        p_uecc_ue_context->cell_index;

    response = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_HO_REL_RACH_RESOURCE_IND ,
            sizeof(rrc_uecc_llim_ho_rach_rel_resource_ind),
            &rrc_uecc_llim_ho_rach_rel_resource_ind);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_sn_hfn_status_ind
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *                  rrc_s1ap_mme_status_transfer_t * p_rrc_s1ap_mme_status_transfer
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds and sends rrc_uecc_llim_sn_hfn_status_ind message
 *       to LLIM module. 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_sn_hfn_status_ind
(
 uecc_ue_context_t*  p_uecc_ue_context,
 rrc_s1ap_mme_status_transfer_t * p_rrc_s1ap_mme_status_transfer
 )
{
    U8 sn_hfn_count =0;
    rrc_return_et response = RRC_FAILURE;
    U32 count = 0;
    rrc_uecc_llim_sn_hfn_status_ind_t        
        rrc_uecc_llim_sn_hfn_status_ind;
    OSRTDListNode * p_node = PNULL;
    OSRTDList * p_bearer_list = PNULL;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_s1ap_mme_status_transfer);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&rrc_uecc_llim_sn_hfn_status_ind,0,
            sizeof(rrc_uecc_llim_sn_hfn_status_ind));

    /* Fill message */
    rrc_uecc_llim_sn_hfn_status_ind.transaction_id = 
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
    rrc_uecc_llim_sn_hfn_status_ind.ue_index = 
        p_uecc_ue_context->ue_index;
    rrc_uecc_llim_sn_hfn_status_ind.cell_index = 
        p_uecc_ue_context->cell_index;

    p_bearer_list = &p_rrc_s1ap_mme_status_transfer->
        e_nb_status_transfer_transparent_container.
        bearers_SubjectToStatusTransferList;

    p_node = p_bearer_list->head;

    for (count = 0; count < p_bearer_list->count &&
            sn_hfn_count < MAX_ERAB_COUNT ; count++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);
        RRC_ASSERT(PNULL != (((s1ap_Bearers_SubjectToStatusTransferList_element *)
                        p_node->data)->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1));

        if (PNULL == 
                p_uecc_ue_context->p_e_rab_list[(
                    (s1ap_Bearers_SubjectToStatusTransferList_element *)
                    p_node->data)->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->e_RAB_ID])
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "[%s]Erab id %d not present\n ",__FUNCTION__,
                    ((s1ap_Bearers_SubjectToStatusTransferList_element *)p_node->data)->
                    value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->e_RAB_ID);
            p_node = p_node->next;
            continue;
        }
        rrc_uecc_llim_sn_hfn_status_ind.sn_hfn_status[sn_hfn_count].lc_id = 
            p_uecc_ue_context->p_e_rab_list[(
                    (s1ap_Bearers_SubjectToStatusTransferList_element *)
                    p_node->data)->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->e_RAB_ID]->drb_config.
            logical_channel_identity;
        rrc_uecc_llim_sn_hfn_status_ind.sn_hfn_status[sn_hfn_count].ul_count_value.
            sn_count = 
            ((s1ap_Bearers_SubjectToStatusTransferList_element *)
             p_node->data)->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->uL_COUNTvalue.pDCP_SN;
        rrc_uecc_llim_sn_hfn_status_ind.sn_hfn_status[sn_hfn_count].ul_count_value.
            hfn_count = 
            ((s1ap_Bearers_SubjectToStatusTransferList_element *)
             p_node->data)->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->uL_COUNTvalue.hFN;
        rrc_uecc_llim_sn_hfn_status_ind.sn_hfn_status[sn_hfn_count].dl_count_value.
            sn_count = 
            ((s1ap_Bearers_SubjectToStatusTransferList_element *)
             p_node->data)->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->dL_COUNTvalue.pDCP_SN;
        rrc_uecc_llim_sn_hfn_status_ind.sn_hfn_status[sn_hfn_count].dl_count_value.
            hfn_count = 
            ((s1ap_Bearers_SubjectToStatusTransferList_element *)
             p_node->data)->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->dL_COUNTvalue.hFN;

        if (((s1ap_Bearers_SubjectToStatusTransferList_element *)
                    p_node->data)->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->m.receiveStatusofULPDCPSDUsPresent)
        {
            rrc_uecc_llim_sn_hfn_status_ind.sn_hfn_status[sn_hfn_count].bitmask |= 
                UECC_LLIM_RECEIVE_STATUS_OF_UL_PDCP_SDU_PRESENT;

            l3_memcpy_wrapper(&rrc_uecc_llim_sn_hfn_status_ind.sn_hfn_status[sn_hfn_count].
                    status_of_ul_pdcp_sdu.receive_status_of_ul_pdcp_sdu,
                    &((s1ap_Bearers_SubjectToStatusTransferList_element *)
                        p_node->data)->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->receiveStatusofULPDCPSDUs.data,
                    ((s1ap_Bearers_SubjectToStatusTransferList_element *)
                     p_node->data)->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->receiveStatusofULPDCPSDUs.numbits/8);
        }
        sn_hfn_count++;
        p_node = p_node->next;
    }
    rrc_uecc_llim_sn_hfn_status_ind.count = sn_hfn_count;


    response = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_SN_HFN_STATUS_IND, 
            sizeof(rrc_uecc_llim_sn_hfn_status_ind_t),
            &rrc_uecc_llim_sn_hfn_status_ind);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_x2ap_build_and_send_sn_hfn_status_ind
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *                  rrc_x2ap_sn_status_transfer_t* p_rrc_x2ap_sn_status_transfer
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds and sends rrc_uecc_llim_sn_hfn_status_ind message
 *       to LLIM module. 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_x2ap_build_and_send_sn_hfn_status_ind
(
 uecc_ue_context_t*  p_uecc_ue_context,
 rrc_x2ap_sn_status_transfer_t* p_rrc_x2ap_sn_status_transfer
 )
{
    U8 sn_hfn_count =0;
    rrc_return_et response = RRC_FAILURE;
    U32 count = 0;
    rrc_uecc_llim_sn_hfn_status_ind_t        
        rrc_uecc_llim_sn_hfn_status_ind;
    OSRTDListNode * p_node = PNULL;
    OSRTDList * p_bearer_list = PNULL;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_x2ap_sn_status_transfer);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&rrc_uecc_llim_sn_hfn_status_ind,0,
            sizeof(rrc_uecc_llim_sn_hfn_status_ind));

    /* Fill message */
    rrc_uecc_llim_sn_hfn_status_ind.transaction_id = 
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
    rrc_uecc_llim_sn_hfn_status_ind.ue_index = 
        p_uecc_ue_context->ue_index;
    rrc_uecc_llim_sn_hfn_status_ind.cell_index = 
        p_uecc_ue_context->cell_index;

    p_bearer_list = &p_rrc_x2ap_sn_status_transfer->
        erab_subject_to_status_transfer_list; 

    p_node = p_bearer_list->head;

    for (count = 0; count < p_bearer_list->count &&
            sn_hfn_count < MAX_ERAB_COUNT ; count++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        if (PNULL == p_uecc_ue_context->p_e_rab_list[(
                    (x2ap_E_RABs_SubjectToStatusTransfer_List_element *)
                    p_node->data)->value.e_RAB_ID])
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "[%s]Erab id %d not present\n ",__FUNCTION__,
                    ((x2ap_E_RABs_SubjectToStatusTransfer_List_element *)
                     p_node->data)->value.e_RAB_ID);
            p_node = p_node->next;
            continue;
        }
        rrc_uecc_llim_sn_hfn_status_ind.sn_hfn_status[sn_hfn_count].lc_id = 
            p_uecc_ue_context->p_e_rab_list[(
                    (x2ap_E_RABs_SubjectToStatusTransfer_List_element *)
                    p_node->data)->value.e_RAB_ID]->drb_config.
            logical_channel_identity;

        rrc_uecc_llim_sn_hfn_status_ind.sn_hfn_status[sn_hfn_count].ul_count_value.
            sn_count = 
            ((x2ap_E_RABs_SubjectToStatusTransfer_List_element *)
             p_node->data)->value.uL_COUNTvalue.pDCP_SN;

        rrc_uecc_llim_sn_hfn_status_ind.sn_hfn_status[sn_hfn_count].ul_count_value.
            hfn_count = 
            ((x2ap_E_RABs_SubjectToStatusTransfer_List_element *)
             p_node->data)->value.uL_COUNTvalue.hFN;

        rrc_uecc_llim_sn_hfn_status_ind.sn_hfn_status[sn_hfn_count].dl_count_value.
            sn_count = 
            ((x2ap_E_RABs_SubjectToStatusTransfer_List_element *)
             p_node->data)->value.dL_COUNTvalue.pDCP_SN;

        rrc_uecc_llim_sn_hfn_status_ind.sn_hfn_status[sn_hfn_count].dl_count_value.
            hfn_count = 
            ((x2ap_E_RABs_SubjectToStatusTransfer_List_element *)
             p_node->data)->value.dL_COUNTvalue.hFN;

        if (((x2ap_E_RABs_SubjectToStatusTransfer_List_element *)
                    p_node->data)->value.m.receiveStatusofULPDCPSDUsPresent)
        {
            rrc_uecc_llim_sn_hfn_status_ind.sn_hfn_status[sn_hfn_count].bitmask |= 
                UECC_LLIM_RECEIVE_STATUS_OF_UL_PDCP_SDU_PRESENT;

            l3_memcpy_wrapper(&rrc_uecc_llim_sn_hfn_status_ind.sn_hfn_status[sn_hfn_count].
                    status_of_ul_pdcp_sdu.receive_status_of_ul_pdcp_sdu,
                    &((x2ap_E_RABs_SubjectToStatusTransfer_List_element *)
                        p_node->data)->value.receiveStatusofULPDCPSDUs.data,
                    ((x2ap_E_RABs_SubjectToStatusTransfer_List_element *)
                     p_node->data)->value.receiveStatusofULPDCPSDUs.numbits/8);
        }
        sn_hfn_count++;
        p_node = p_node->next;
    }
    rrc_uecc_llim_sn_hfn_status_ind.count = sn_hfn_count;

    response = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_SN_HFN_STATUS_IND, 
            sizeof(rrc_uecc_llim_sn_hfn_status_ind_t),
            &rrc_uecc_llim_sn_hfn_status_ind);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_data_buffer_stop_ind
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds and sends rrc_uecc_llim_data_buffer_stop_ind message
 *       to LLIM module. 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_data_buffer_stop_ind
(
 uecc_ue_context_t*  p_uecc_ue_context
 )
{
    rrc_return_et response = RRC_FAILURE;
    rrc_uecc_llim_data_buffer_stop_ind_t        
        rrc_uecc_llim_data_buffer_stop_ind;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Fill message */
    rrc_uecc_llim_data_buffer_stop_ind.ue_index = 
        p_uecc_ue_context->ue_index;
    rrc_uecc_llim_data_buffer_stop_ind.cell_index = 
        p_uecc_ue_context->cell_index;

    rrc_uecc_llim_data_buffer_stop_ind.transaction_id = 
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    response = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_DATA_BUFFER_STOP_IND, 
            sizeof(rrc_uecc_llim_data_buffer_stop_ind),
            &rrc_uecc_llim_data_buffer_stop_ind);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}



/******************************************************************************
 *   FUNCTION NAME: uecc_llim_encode_mobilityControlInfo
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *                  OSCTXT   *            p_asn1_ctx
 *                  MobilityControlInfo *p_asn_mobilityControlInfo
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds mobilityControlInfo in RRCConnectionReconfiguration
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_encode_mobilityControlInfo(
        uecc_ue_context_t*  p_uecc_ue_context,
        OSCTXT   *            p_asn1_ctx,
        MobilityControlInfo *p_asn_mobilityControlInfo
        )
{
    rrc_return_et                           result = RRC_FAILURE;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_uecc_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_asn_mobilityControlInfo);
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_uecc_ue_context->
                p_gb_context,p_uecc_ue_context->cell_index))
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do {
        if ( p_uecc_ue_context->p_gb_context->p_p_csc_context == PNULL )
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING, "p_p_csc_context is NULL");
            break;
        }
        if (PNULL != p_uecc_ue_context->p_gb_context->p_p_csc_context
                [p_uecc_ue_context->cell_index])
        {
            if (PNULL != p_uecc_ue_context->p_gb_context->p_p_csc_context
                    [p_uecc_ue_context->cell_index]->p_csc_init_setup_ind)
            {
                /*PhysCellId targetPhysCellId */
                p_asn_mobilityControlInfo->targetPhysCellId =
                    p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                    cell_index]->p_csc_init_setup_ind->phys_cell_id;

                /*OPT:CarrierFreqEUTRA carrierFreq;*/
                p_asn_mobilityControlInfo->m.carrierFreqPresent = 1;
                p_asn_mobilityControlInfo->carrierFreq.dl_CarrierFreq = 
                    p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                    cell_index]->p_csc_init_setup_ind->eutra_dl_carrier_freq;
                if (p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                        cell_index]->p_csc_init_setup_ind->sib_type_2_Info.
                        freq_info.presence_bitmask & 
                        FREQ_INFO_UL_CARRER_FREQ_PRESENCE_FLAG)
                {
                    p_asn_mobilityControlInfo->carrierFreq.m.
                        ul_CarrierFreqPresent = 1;
                    p_asn_mobilityControlInfo->carrierFreq.ul_CarrierFreq = 
                        p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                        cell_index]->p_csc_init_setup_ind->sib_type_2_Info.freq_info.ul_carrier_freq;
                }

                /*OPT:CarrierBandwidthEUTRA carrierBandwidth;*/
                p_asn_mobilityControlInfo->m.carrierBandwidthPresent = 1;
                p_asn_mobilityControlInfo->carrierBandwidth.dl_Bandwidth = 
                    p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                    cell_index]->p_csc_init_setup_ind->mib_info.dl_band_width;
                /*** HO TDD changes start ***/

                if(  DUPLEXING_MODE_TDD != p_uecc_ue_context->p_gb_context->
                        p_p_csc_context[p_uecc_ue_context->cell_index]->p_csc_init_setup_ind->
                        duplexing_mode)
                {
                    p_asn_mobilityControlInfo->carrierBandwidth.m.
                        ul_BandwidthPresent = 1;
                    p_asn_mobilityControlInfo->carrierBandwidth.ul_Bandwidth =
                        p_uecc_ue_context->p_gb_context->p_p_csc_context[
                        p_uecc_ue_context->cell_index]->
                        p_csc_init_setup_ind->sib_type_2_Info.freq_info.ul_bandwidth;
                }
                /*** HO TDD changes stop ***/
                p_asn_mobilityControlInfo->m.additionalSpectrumEmissionPresent = 1;
                p_asn_mobilityControlInfo->additionalSpectrumEmission =
                    p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                    cell_index]->p_csc_init_setup_ind->sib_type_2_Info.freq_info.add_spectrum_emission;


                /*MobilityControlInfo_t304 t304;*/
                if (!p_uecc_ue_context->ho_info.p_ho_info ||
                        !p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info ||
                        !p_uecc_ue_context->ho_info.p_ho_info->
                        p_trg_ho_info->p_rrc_rrm_ho_adm_resp)
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "Problem with HO context in UECC UE context!!");
                    break;
                }
                p_asn_mobilityControlInfo->t304 = p_uecc_ue_context->ho_info.
                    p_ho_info->p_trg_ho_info->p_rrc_rrm_ho_adm_resp->
                    mobility_control_info.t304_timer;

                p_asn_mobilityControlInfo->newUE_Identity.numbits
                    = 8 *sizeof(p_uecc_ue_context->crnti);
                /*C_RNTI newUE_Identity;*/

                rrc_pack_U16(
                        p_asn_mobilityControlInfo->newUE_Identity.data,
                        &p_uecc_ue_context->crnti);

                if (RRC_FAILURE == 
                        uecc_llim_fill_mobility_control_info_radio_resource_config_common(
                            p_uecc_ue_context,
                            p_asn1_ctx,
                            &p_asn_mobilityControlInfo->radioResourceConfigCommon
                            ))
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "uecc_llim_fill_mobility_control"
                            "_info_radio_resource_config_common"
                            "failed");
                    break;
                }

                if((RA_PREAMBLE_INDEX_PRESENT ==
                            p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->m.ra_preamble_index_present)
                        && (RA_PRACH_MASK_INDEX_PRESENT ==
                            p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->m.ra_prach_mask_index_present))
                {
                    p_asn_mobilityControlInfo->m.rach_ConfigDedicatedPresent
                        = 1;
                    p_asn_mobilityControlInfo->rach_ConfigDedicated.ra_PreambleIndex =
                        p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                        ra_preamble_index;
                    p_asn_mobilityControlInfo->rach_ConfigDedicated.ra_PRACH_MaskIndex =
                        p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                        ra_PRACH_mask_index;

                }


                result = RRC_SUCCESS;
            }
        }
    }while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME:  
 uecc_llim_fill_mobility_control_info_radio_resource_config_common
 *   INPUT        : uecc_ue_context_t                  *p_uecc_ue_context
 *                  OSCTXT                             *p_asn1_ctx 
 *                  RadioResourceConfigCommon          *p_asn1_cc
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function converts populates
 *       RadioResourceConfigCommon present in mobilityControlInfo 
 *
 *   RETURNS:
 *       RRC_SUCCESS - all data are valid
 *       RRC_FAILURE - data are invalid or if there are not enough memory
 *
 ******************************************************************************/
static rrc_return_et uecc_llim_fill_mobility_control_info_radio_resource_config_common
(
 uecc_ue_context_t                  *p_uecc_ue_context,
 OSCTXT                             *p_asn1_ctx,
 RadioResourceConfigCommon          *p_asn1_cc     /* destination */
 )
{

    RRC_ASSERT (PNULL != p_uecc_ue_context->p_gb_context->p_p_csc_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_uecc_ue_context->p_gb_context,
                p_uecc_ue_context->cell_index))
    {   
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"Cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    if (PNULL != p_uecc_ue_context->p_gb_context->p_p_csc_context
            [p_uecc_ue_context->cell_index])
    {
        if (PNULL != p_uecc_ue_context->p_gb_context->p_p_csc_context
                [p_uecc_ue_context->cell_index]->p_csc_init_setup_ind)
        {
            radio_resource_config_common_sib_t  *p_cc = &p_uecc_ue_context->
                p_gb_context->p_p_csc_context[p_uecc_ue_context->cell_index]->
                p_csc_init_setup_ind->sib_type_2_Info.radio_resource_config_common_sib;

            RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
            RRC_ASSERT(PNULL != p_asn1_ctx);
            RRC_ASSERT(PNULL != p_asn1_cc);
            RRC_ASSERT(PNULL != p_cc);

            /* - rach_Configuration */
            /* -- rach_Configuration/preambleInformation */
            p_asn1_cc->m.rach_ConfigCommonPresent = 1;
            p_asn1_cc->rach_ConfigCommon.preambleInfo.numberOfRA_Preambles =
                p_cc->rach_config_common.preamble_info.ra_preamble_count;

            p_asn1_cc->rach_ConfigCommon.preambleInfo.m.preamblesGroupAConfigPresent = 0;

            if (p_cc->rach_config_common.preamble_info.presence_bitmask &
                    PREAMBLE_INFO_GROUP_A_CONFIG_PRESENCE_FLAG)
            {
                p_asn1_cc->rach_ConfigCommon.preambleInfo.m.
                    preamblesGroupAConfigPresent = 1;

                p_asn1_cc->rach_ConfigCommon.preambleInfo.preamblesGroupAConfig.
                    sizeOfRA_PreamblesGroupA =
                    p_cc->rach_config_common.preamble_info.preambles_group_a_config.
                    ra_preambles_group_a_size;

                p_asn1_cc->rach_ConfigCommon.preambleInfo.preamblesGroupAConfig.
                    messageSizeGroupA =
                    p_cc->rach_config_common.preamble_info.preambles_group_a_config.
                    group_a_msg_size;

                p_asn1_cc->rach_ConfigCommon.preambleInfo.preamblesGroupAConfig.
                    messagePowerOffsetGroupB =
                    p_cc->rach_config_common.preamble_info.preambles_group_a_config.
                    group_b_msg_power_offset;

                rtxDListInit(&p_asn1_cc->rach_ConfigCommon.
                        preambleInfo.preamblesGroupAConfig.
                        extElem1);
            }

            /* -- rach_Configuration/powerRampingParameters */
            p_asn1_cc->rach_ConfigCommon.powerRampingParameters.powerRampingStep =
                p_cc->rach_config_common.power_ramping_params.power_ramping_step;

            p_asn1_cc->rach_ConfigCommon.powerRampingParameters.
                preambleInitialReceivedTargetPower =
                p_cc->rach_config_common.power_ramping_params.
                preamble_init_rec_target_pow;

            /* -- rach_Configuration/ra_SupervisionInformation */
            p_asn1_cc->rach_ConfigCommon.ra_SupervisionInfo.preambleTransMax =
                p_cc->rach_config_common.ra_supervision_info.preamble_trans_max;

            p_asn1_cc->rach_ConfigCommon.ra_SupervisionInfo.ra_ResponseWindowSize =
                p_cc->rach_config_common.ra_supervision_info.ra_resp_win_size;

            p_asn1_cc->rach_ConfigCommon.ra_SupervisionInfo.
                mac_ContentionResolutionTimer =
                p_cc->rach_config_common.ra_supervision_info.mac_cont_resol_timer;

            p_asn1_cc->rach_ConfigCommon.maxHARQ_Msg3Tx =
                p_cc->rach_config_common.max_harq_msg_3_tx;

            rtxDListInit(&p_asn1_cc->rach_ConfigCommon.extElem1);

            /* - prach_Configuration */
            p_asn1_cc->prach_Config.m.prach_ConfigInfoPresent = 1;
            p_asn1_cc->prach_Config.rootSequenceIndex =
                p_cc->prach_config_sib.root_seq_index;

            /* -- prach_Configuration/prach_ConfigInfo */
            p_asn1_cc->prach_Config.prach_ConfigInfo.prach_ConfigIndex =
                p_cc->prach_config_sib.prach_config_info.prach_config_index;

            p_asn1_cc->prach_Config.prach_ConfigInfo.highSpeedFlag =
                p_cc->prach_config_sib.prach_config_info.high_speed_flag;

            p_asn1_cc->prach_Config.prach_ConfigInfo.zeroCorrelationZoneConfig =
                p_cc->prach_config_sib.prach_config_info.zero_cor_zone_config;

            p_asn1_cc->prach_Config.prach_ConfigInfo.prach_FreqOffset =
                p_cc->prach_config_sib.prach_config_info.prach_freq_offset;

            /* - pdsch_Configuration */
            p_asn1_cc->m.pdsch_ConfigCommonPresent = 1;
            p_asn1_cc->pdsch_ConfigCommon.referenceSignalPower =
                p_cc->pdsch_config_common.ref_signal_power;

            p_asn1_cc->pdsch_ConfigCommon.p_b =
                p_cc->pdsch_config_common.pb;

            /* - pusch_Configuration */

            /* -- pusch_Configuration/pusch_ConfigBasic */
            p_asn1_cc->pusch_ConfigCommon.pusch_ConfigBasic.n_SB =
                p_cc->pusch_config_common.pusch_config_basic.nsb;

            p_asn1_cc->pusch_ConfigCommon.pusch_ConfigBasic.hoppingMode =
                p_cc->pusch_config_common.pusch_config_basic.hopping_mode;

            p_asn1_cc->pusch_ConfigCommon.pusch_ConfigBasic.pusch_HoppingOffset =
                p_cc->pusch_config_common.pusch_config_basic.pusch_hopping_offset;

            p_asn1_cc->pusch_ConfigCommon.pusch_ConfigBasic.enable64QAM =
                p_cc->pusch_config_common.pusch_config_basic.enable_64_qam;

            /* -- pusch_Configuration/ul_ReferenceSignalsPUSCH */
            p_asn1_cc->pusch_ConfigCommon.ul_ReferenceSignalsPUSCH.groupHoppingEnabled =
                p_cc->pusch_config_common.ul_ref_signals_pusch.group_hopping_enabled;

            p_asn1_cc->pusch_ConfigCommon.
                ul_ReferenceSignalsPUSCH.groupAssignmentPUSCH =
                p_cc->pusch_config_common.ul_ref_signals_pusch.group_assign_pusch;

            p_asn1_cc->pusch_ConfigCommon.
                ul_ReferenceSignalsPUSCH.sequenceHoppingEnabled =
                p_cc->pusch_config_common.ul_ref_signals_pusch.seq_hopping_enabled;

            p_asn1_cc->pusch_ConfigCommon.ul_ReferenceSignalsPUSCH.cyclicShift =
                p_cc->pusch_config_common.ul_ref_signals_pusch.cyclic_shift;

            /* phich configuration */
            p_asn1_cc->m.phich_ConfigPresent = 1;
            p_asn1_cc->phich_Config.phich_Duration = 
                p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                cell_index]->p_csc_init_setup_ind->mib_info.
                phich_config.phich_duration;
            p_asn1_cc->phich_Config.phich_Resource = 
                p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                cell_index]->p_csc_init_setup_ind->mib_info.
                phich_config.phich_resource;

            /* - pucch_Configuration */
            p_asn1_cc->m.pucch_ConfigCommonPresent = 1;
            p_asn1_cc->pucch_ConfigCommon.deltaPUCCH_Shift =
                p_cc->pucch_config_common.delta_pucch_shift;

            p_asn1_cc->pucch_ConfigCommon.nRB_CQI =
                p_cc->pucch_config_common.n_rb_cqi;

            p_asn1_cc->pucch_ConfigCommon.nCS_AN =
                p_cc->pucch_config_common.n_cs_an;

            p_asn1_cc->pucch_ConfigCommon.n1PUCCH_AN =
                p_cc->pucch_config_common.n_one_pucch_an;

            /* - soundingRS_UL_ConfigCommon */
            p_asn1_cc->m.soundingRS_UL_ConfigCommonPresent = 1;
            p_asn1_cc->pucch_ConfigCommon.deltaPUCCH_Shift =
                p_cc->pucch_config_common.delta_pucch_shift;

            if (p_cc->sounding_rs_ul_config_common.presence_bitmask &
                    SOUNDING_RS_UL_CONFIG_COMMON_SETUP_PRESENCE_FLAG)
            {
                p_asn1_cc->soundingRS_UL_ConfigCommon.t = 
                    T_SoundingRS_UL_ConfigCommon_setup;
                p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup =
                    rtxMemAllocType(p_asn1_ctx, SoundingRS_UL_ConfigCommon_setup);

                if (PNULL == p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup)
                {
                    /* Not enough memory */
                    return RRC_FAILURE;
                }

                p_asn1_cc->soundingRS_UL_ConfigCommon.
                    u.setup->m.srs_MaxUpPtsPresent = 0;

                p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup->srs_BandwidthConfig =
                    p_cc->sounding_rs_ul_config_common.setup.srs_bw_config;

                p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup->srs_SubframeConfig =
                    p_cc->sounding_rs_ul_config_common.setup.srs_subframe_config;

                p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup->
                    ackNackSRS_SimultaneousTransmission =
                    p_cc->sounding_rs_ul_config_common.setup.ack_nack_srs_simul_trans;


                if (DUPLEXING_MODE_TDD == p_uecc_ue_context->
                        p_gb_context->p_p_csc_context[p_uecc_ue_context->cell_index]->p_csc_init_setup_ind->
                        duplexing_mode)
                {

                    if(p_cc->sounding_rs_ul_config_common.setup.presence_bitmask &
                            SOUNDING_RS_UL_CONFIG_COMMON_SETUP_SRS_MAX_UP_PTS_PRESENCE_FLAG)
                    {
                        p_asn1_cc->soundingRS_UL_ConfigCommon.u
                            .setup->m.srs_MaxUpPtsPresent = 1;
                        p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup->srs_MaxUpPts =
                            p_cc->sounding_rs_ul_config_common.setup.srs_max_up_pts;
                    }
                }
            }
            else
            {
                p_asn1_cc->soundingRS_UL_ConfigCommon.t =
                    T_SoundingRS_UL_ConfigCommon_release;
            }

            /* - uplinkPowerControl */
            p_asn1_cc->m.uplinkPowerControlCommonPresent = 1;
            p_asn1_cc->uplinkPowerControlCommon.p0_NominalPUSCH =
                p_cc->uplink_power_control_common.p_zero_nominal_Pusch;

            p_asn1_cc->uplinkPowerControlCommon.alpha =
                p_cc->uplink_power_control_common.alpha;

            p_asn1_cc->uplinkPowerControlCommon.p0_NominalPUCCH =
                p_cc->uplink_power_control_common.p_zero_nominal_pucch;

            p_asn1_cc->uplinkPowerControlCommon.deltaPreambleMsg3 =
                p_cc->uplink_power_control_common.delta_preamble_msg_three;

            /* -- uplinkPowerControl/deltaFList_PUCCH */
            p_asn1_cc->uplinkPowerControlCommon.deltaFList_PUCCH.deltaF_PUCCH_Format1 =
                p_cc->uplink_power_control_common.delta_f_list_pucch.
                delta_f_pucch_format_one;

            p_asn1_cc->uplinkPowerControlCommon.deltaFList_PUCCH.deltaF_PUCCH_Format1b =
                p_cc->uplink_power_control_common.delta_f_list_pucch.
                delta_f_pucch_format_one_b;

            p_asn1_cc->uplinkPowerControlCommon.deltaFList_PUCCH.deltaF_PUCCH_Format2 =
                p_cc->uplink_power_control_common.delta_f_pucch_format_two.
                delta_f_pucch_format_two;

            p_asn1_cc->uplinkPowerControlCommon.deltaFList_PUCCH.deltaF_PUCCH_Format2a =
                p_cc->uplink_power_control_common.delta_f_pucch_format_two.
                delta_f_pucch_format_two_a;

            p_asn1_cc->uplinkPowerControlCommon.deltaFList_PUCCH.deltaF_PUCCH_Format2b =
                p_cc->uplink_power_control_common.delta_f_pucch_format_two.
                delta_f_pucch_format_two_b;

            p_asn1_cc->ul_CyclicPrefixLength =
                p_cc->ul_cyc_prefix_len;

            /* antennaInfoCommon:antennaInfoCommonPresent*/
            p_asn1_cc->m.antennaInfoCommonPresent = 1;

            /* SPR 3052 Start */
            switch(p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                    cell_index]->p_csc_init_setup_ind->num_of_antennas)
            {
                case 1:
                    p_asn1_cc->antennaInfoCommon.antennaPortsCount = an1;
                    break;
                case 2:
                    p_asn1_cc->antennaInfoCommon.antennaPortsCount = an2;
                    break;
                case 4:
                    p_asn1_cc->antennaInfoCommon.antennaPortsCount = an4;
                    break;
                default:
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR, "Invalid Num of Antenna in global context = %u",
                            p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                            cell_index]->p_csc_init_setup_ind->num_of_antennas);
                    return RRC_FAILURE;
            }
            /* SPR 3052 Stop */


            /* p_Max:p_MaxPresent*/
            if (SIB_TYPE_1_P_MAX_PRESENCE_FLAG &
                    p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                    cell_index]->p_csc_init_setup_ind->sib_type_1_Info.presence_bitmask)
            {
                p_asn1_cc->m.p_MaxPresent = 1;
                p_asn1_cc->p_Max =
                    p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                    cell_index]->p_csc_init_setup_ind->sib_type_1_Info.p_max;
            }

            /* tdd_Config:tdd_ConfigPresent*/
            if (DUPLEXING_MODE_TDD == 
                    p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                    cell_index]->p_csc_init_setup_ind->duplexing_mode)
            {
                p_asn1_cc->m.tdd_ConfigPresent = 1;
                p_asn1_cc->tdd_Config.subframeAssignment =
                    p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                    cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                    tdd_config.sub_frame_assignment;
                p_asn1_cc->tdd_Config.specialSubframePatterns=
                    p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                    cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                    tdd_config.special_sub_frame_pattern;
            }
        }
    }
    rtxDListInit(&p_asn1_cc->extElem1);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: 
 uecc_delete_fwd_tunnels_llim_build_and_send_s1u_reconfigure_req
 *   INPUT        : rrc_uecc_llim_s1u_end_marker_ind_t * p_rrc_uecc_llim_s1u_end_marker_ind
 *                  uecc_ue_context_t                  *p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds and sends s1u_reconfigure_req message from
 to delete tunnels for which end marker indication is received.
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_delete_fwd_tunnels_llim_build_and_send_s1u_reconfigure_req
(
 rrc_uecc_llim_s1u_end_marker_ind_t * p_rrc_uecc_llim_s1u_end_marker_ind,
 uecc_ue_context_t                  *p_uecc_ue_context
 )
{
    rrc_return_et                               response = RRC_FAILURE;
    rrc_uecc_llim_s1u_reconfigure_req_t  rrc_uecc_llim_s1u_reconfigure_req;
    /* Bug 817 Fix Start */
    U8                                   rrc_fwd_tunnel_cnt = RRC_NULL;
    U8                                   tunnel_count = RRC_NULL;
    rrc_lc_id_t                          lc_id = RRC_NULL;
    /* Bug 817 Fix Stop */

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&rrc_uecc_llim_s1u_reconfigure_req,0,
            sizeof(rrc_uecc_llim_s1u_reconfigure_req_t));

    rrc_uecc_llim_s1u_reconfigure_req.bitmask |=
        RRC_UECC_LLIM_S1U_REL_SAP_REQ_LIST_PRESENT;

    rrc_uecc_llim_s1u_reconfigure_req.ue_index = 
        p_rrc_uecc_llim_s1u_end_marker_ind->ue_index;
    rrc_uecc_llim_s1u_reconfigure_req.cell_index = 
        p_rrc_uecc_llim_s1u_end_marker_ind->cell_index;

    rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
        rel_sap_req[0].lc_id =
        p_rrc_uecc_llim_s1u_end_marker_ind->lc_id;

    /* Bug 817 Fix Start */
    lc_id = p_rrc_uecc_llim_s1u_end_marker_ind->lc_id;

    /* SPR 16087 Start */
    rrc_uecc_llim_s1u_reconfigure_req.transaction_id =
                uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
    /* SPR 16087 Stop */


    if (p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.drb_tunnel_info_count > RRC_NULL)
    {
        /* SPR 16087 Start */
        rrc_uecc_llim_s1u_reconfigure_req.transaction_id =
            RRC_S1U_END_MARKER_RESERVED_TRANSACTION_ID;
        /* SPR 16087 Stop */

        if (PNULL != p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.
                p_uecc_drb_fwd_tnl_list[lc_id])
        {
            for(rrc_fwd_tunnel_cnt = 0; rrc_fwd_tunnel_cnt < p_uecc_ue_context->
                    rrc_trg_ho_fwd_tnl_info.p_uecc_drb_fwd_tnl_list[lc_id]->
                    tunnel_info_count; ++rrc_fwd_tunnel_cnt)
            {

                if (RRC_PDCP_RB_DIR_BOTH != p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.
                        p_uecc_drb_fwd_tnl_list[lc_id]->uecc_fwd_tnl_list[rrc_fwd_tunnel_cnt].rb_direction)
                {
                    tunnel_count = rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.rel_sap_req[0].tunnel_count;


                    rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
                        rel_sap_req[0].release_tunnel_info
                        [tunnel_count].bitmask |=
                        RRC_S1U_IE_RELEASE_TUNNEL_INFO_TRANSPORT_ADDR_PRESENT;

                    rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
                        rel_sap_req[0].release_tunnel_info[tunnel_count].teid_self = 
                        p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.p_uecc_drb_fwd_tnl_list[lc_id]->
                        uecc_fwd_tnl_list[rrc_fwd_tunnel_cnt].teid_self;

                    rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
                        rel_sap_req[0].release_tunnel_info[tunnel_count].
                        transport_addr = 
                        p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.p_uecc_drb_fwd_tnl_list[lc_id]->
                        uecc_fwd_tnl_list[rrc_fwd_tunnel_cnt].transport_addr;

                    rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
                        rel_sap_req[0].tunnel_count++;

                }
            }
            if (RRC_NULL == rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
                    rel_sap_req[0].tunnel_count)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR, 
                        "DL/UL Forwarding Info for LC Id [%d] is not available", 
                        p_rrc_uecc_llim_s1u_end_marker_ind->lc_id);
                return RRC_FAILURE;
            }
            else
            {
                rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
                    num_rel_sap_req = 1;
            }
            rrc_mem_free (p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.
                    p_uecc_drb_fwd_tnl_list[lc_id]);
            p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.
                p_uecc_drb_fwd_tnl_list[lc_id] = PNULL;
            p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.drb_tunnel_info_count--;

        }
        else
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, 
                    "Forwarding Info for LC Id [%d] is not available", 
                    p_rrc_uecc_llim_s1u_end_marker_ind->lc_id);
            return RRC_FAILURE;
        }
    }
    /* Bug 817 Fix Stop */

    /* SPR 16087 Start */
    /* Code Removed */
    /* SPR 16087 Stop */

    /* Bug 817 Fix Start */
    if (RRC_NULL == p_uecc_ue_context->
            rrc_trg_ho_fwd_tnl_info.drb_tunnel_info_count)
    {
        /* Stop timer */
        uecc_ue_timer_stop(p_uecc_ue_context->p_gb_context,
                UECC_UE_INTRA_CELL_HO_GUARD_TIMER, 
                &p_uecc_ue_context->timers_data); 
    }
    /* Bug 817 Fix Stop */

    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
            (p_uecc_ue_context->p_gb_context)->facility_name,
            RRC_INFO, 
            "Sending UECC_LLIM_S1U_RECONFIGURE_REQ to LLIM");
    response = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_S1U_RECONFIGURE_REQ,
            sizeof(rrc_uecc_llim_s1u_reconfigure_req_t),
            &rrc_uecc_llim_s1u_reconfigure_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}


/*SPR_19066_START*/
/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_ho_prep_info_req 
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:    This is the function for building and sending
 *                   UECC_LLIM_HO_PREP_INFO_REQ message to the LLIM.
 ****************************************************************************/

rrc_return_t uecc_llim_build_and_send_ho_prep_info_req(
        uecc_ue_context_t   *p_ue_context      /* UECC UE context */
        )
{
    static rrc_uecc_llim_ho_prep_info_req_t rrc_uecc_llim_ho_prep_info_req;
    rrc_return_et                   result = RRC_FAILURE;
    rrm_sourceenb_to_targetenb_transparent_cotainer_t *p_enb_container = PNULL;
    rrc_rrm_ho_required_t           *p_rrc_rrm_ho_required = PNULL;
    rrc_uecc_llim_message_t         *p_message = PNULL;
    rrc_counter_t  i = 0;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if((PNULL != p_ue_context->ho_info.p_ho_info) &&
            (PNULL!= p_ue_context->ho_info.p_ho_info->p_src_ho_info))
    {
        /* getting ho required messge */
        p_rrc_rrm_ho_required = p_ue_context->ho_info.p_ho_info
            ->p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required;
    }
    if (PNULL == p_rrc_rrm_ho_required)
    {

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,"p_rrc_rrm_ho_required failure");
        return RRC_FAILURE; 

    }
    /* Reset */
    memset_wrapper(&rrc_uecc_llim_ho_prep_info_req, RRC_NULL,
            sizeof(rrc_uecc_llim_ho_prep_info_req_t));

    /* ue_index */
    rrc_uecc_llim_ho_prep_info_req.ue_index =  p_ue_context->ue_index;
    rrc_uecc_llim_ho_prep_info_req.cell_index =  p_ue_context->cell_index;
    /* Transaction ID */
    rrc_uecc_llim_ho_prep_info_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_ue_context);

    /* lc Id initially lc_id use the default value i.e. all set to 1s */
    rrc_uecc_llim_ho_prep_info_req.mac_i_msg_req.lc_id =  (rrc_lc_id_t)LC_ID_VAL_TO_CAL_MAC_I; 
    /* lc RB Direction */
    rrc_uecc_llim_ho_prep_info_req.mac_i_msg_req.rb_direction =  RB_DIR_VAL_TO_CAL_MAC_I; 
    rrc_uecc_llim_ho_prep_info_req.mac_i_msg_req.rnti =  p_ue_context->crnti; 

    p_enb_container = &(p_rrc_rrm_ho_required->source_to_target_container
            .eNBContainer);
    if (PNULL == p_enb_container)
    {

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,"p_enb_container failure");
        return RRC_FAILURE; 
    }
    /* verifying that target_cell_id list is present using bitmask */
    if( p_enb_container->rrc_container.bitmask &
            RRM_RRC_CONTAINER_TARGET_CELL_IDENTITY_LIST_PRESENT)
    {
        if (MAX_NO_OF_MESSAGES < (rrc_uecc_llim_ho_prep_info_req.mac_i_msg_req.message_count = 
                    p_enb_container->rrc_container.target_cell_identity_list
                    .target_cell_count ) )
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[UECC_LLIM_HO_PREP_INFO_REQ] count exceeds max limit %d",
                    rrc_uecc_llim_ho_prep_info_req.mac_i_msg_req.message_count);
            return RRC_FAILURE;    
        }
    }

    /* copying the target cell_id into mac_i request at the first location*/
    p_message = &(rrc_uecc_llim_ho_prep_info_req.mac_i_msg_req.message[0]);

    /* CSR00057536_CHANGES_START */
    /* SPR 11711 Fix Start */
    /* copy the cell_identity */
    l3_memcpy_wrapper ((U8*)&p_message->cell_identity,
            p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_identity,
            sizeof (p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_identity));
    /* SPR 11711 Fix Stop */
    /* CSR00057536_CHANGES_END */

    memset_wrapper(p_message->encodedVarShortMac,RRC_NULL,
            sizeof(p_message->encodedVarShortMac));
    if(RRC_SUCCESS != uecc_s1ap_build_VarShortMAC_Input(p_ue_context, 
                &(p_message->cell_identity),
                p_message->encodedVarShortMac,
                &(p_message->num_of_bytes)))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[UECC_LLIM_HO_PREP_INFO_REQ] Fail to create encoded "
                "var short maci msg");
        return RRC_FAILURE;
    }
    /* incrementing message_count by 1 as one mac_i request for target cell has already filled */
    rrc_uecc_llim_ho_prep_info_req.mac_i_msg_req.message_count++;    

    /* COVERITY_23254 */
    for ( i = 1; (i < rrc_uecc_llim_ho_prep_info_req.mac_i_msg_req.message_count) &&
            (i < MAX_NO_OF_MESSAGES); i++ )
    {
        p_message = &(rrc_uecc_llim_ho_prep_info_req.mac_i_msg_req.message[i]);

        /* CSR00057536_CHANGES_START */
        /* SPR 11711 Fix Start */
        /* copy the cell_identity */
        l3_memcpy_wrapper((U8*)&p_message->cell_identity,
                p_enb_container->rrc_container.target_cell_identity_list.
                target_cell_identity[i-1].target_cell_Id, sizeof (p_enb_container->
                    rrc_container.target_cell_identity_list.
                    target_cell_identity[i-1].target_cell_Id));
        /* SPR 11711 Fix Stop */
        /* CSR00057536_CHANGES_END */

        memset_wrapper(p_message->encodedVarShortMac,RRC_NULL,
                sizeof(p_message->encodedVarShortMac));
        if(RRC_SUCCESS != uecc_s1ap_build_VarShortMAC_Input(p_ue_context, 
                    &(p_message->cell_identity),
                    p_message->encodedVarShortMac,
                    &(p_message->num_of_bytes)))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[UECC_LLIM_HO_PREP_INFO_REQ] Failed to create encoded "
                    "var short maci msg");
            return RRC_FAILURE;
        }
    }

    rrc_uecc_llim_ho_prep_info_req.bitmask |= RRC_UECC_LLIM_MACI_MSG_REQ_PRESENT;
    rrc_uecc_llim_ho_prep_info_req.ue_inactive_time_val.
        ue_inactive_time_val_flag = RRC_TRUE;
    rrc_uecc_llim_ho_prep_info_req.bitmask |= 
        RRC_UECC_LLIM_HO_PREP_INACTIVE_TIME_REQ_PRESENT;
    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_HO_PREP_INFO_REQ,
            sizeof(rrc_uecc_llim_ho_prep_info_req_t),
            &rrc_uecc_llim_ho_prep_info_req);
    if (result == RRC_SUCCESS)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "Successfully sent the UECC_LLIM_HO_PREP_INFO_REQ");

    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}
/*SPR_19066_END*/

/****************************************************************************
 * Function Name  : uecc_llim_rlf_ind_build_and_send_mac_i_req
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t
 * Description:   : This is the function for building and sending
 *                  UECC_LLIM_MAC_I_REQ message to the LLIM.
 ****************************************************************************/
rrc_return_t uecc_llim_rlf_ind_build_and_send_mac_i_req(
        uecc_ue_context_t   *p_ue_context)
{
    static rrc_uecc_llim_mac_i_req_t       rrc_uecc_llim_mac_i_req;
    rrc_return_et                   result = RRC_FAILURE;
    rrc_uecc_llim_message_t         *p_message = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&rrc_uecc_llim_mac_i_req, 0,
            sizeof(rrc_uecc_llim_mac_i_req_t));

    /* ue_index */
    rrc_uecc_llim_mac_i_req.ue_index =  p_ue_context->ue_index;
    rrc_uecc_llim_mac_i_req.cell_index =  p_ue_context->cell_index;
    rrc_uecc_llim_mac_i_req.rnti =  p_ue_context->crnti;
    /* Transaction ID */
    rrc_uecc_llim_mac_i_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_ue_context);
    /* lc Id initially lc_id use the default value i.e. all set to 1s */
    rrc_uecc_llim_mac_i_req.lc_id =  (rrc_lc_id_t)LC_ID_VAL_TO_CAL_MAC_I; 
    /* lc RB Direction */
    rrc_uecc_llim_mac_i_req.rb_direction =  RB_DIR_VAL_TO_CAL_MAC_I; 

    /* copying the target cell_id into mac_i request at the first location*/
    p_message = &(rrc_uecc_llim_mac_i_req.message[0]);
    /* copy the cell_identity */
    l3_memcpy_wrapper((U8*)&p_message->cell_identity,
            p_ue_context->x2ap_rlf_ind.re_est_cell_ecgi.eutran_cell_id,
            sizeof(p_ue_context->x2ap_rlf_ind.re_est_cell_ecgi.eutran_cell_id));

    memset_wrapper(p_message->encodedVarShortMac,0,
            sizeof(p_message->encodedVarShortMac));
    if(RRC_SUCCESS != uecc_s1ap_build_VarShortMAC_Input(p_ue_context, 
                &(p_message->cell_identity),
                p_message->encodedVarShortMac,
                &(p_message->num_of_bytes)))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[UECC_LLIM_MAC_I_REQ] Fail to create encoded "
                "var short maci msg");
        return RRC_FAILURE;
    }

    rrc_uecc_llim_mac_i_req.message_count++;
    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_MAC_I_REQ,
            sizeof(rrc_uecc_llim_mac_i_req_t),
            &rrc_uecc_llim_mac_i_req);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_VarShortMAC_Input  
 *   INPUTS       : uecc_ue_context_t   *p_ue_context
 *                  U32                 *p_cell_identity
 *                  U8                  *p_encoded_mac_i
 *                  U16                 *p_encoded_msg_length
 *   OUTPUTS      : None  
 *   DESCRIPTION:
 *       This function builds VarShortMAC_Input  
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_VarShortMAC_Input(
        uecc_ue_context_t   *p_ue_context,
        U32                 *p_cell_identity,
        U8                  *p_encoded_mac_i,
        U16                 *p_encoded_msg_length )
{
    OSCTXT asn1_ctx;
    VarShortMAC_Input  *p_var_short_mac_i = PNULL;        
    rrc_return_et    ret = RRC_SUCCESS;


    RRC_ASSERT(PNULL!=p_ue_context);
    RRC_ASSERT(PNULL!=p_cell_identity);
    RRC_ASSERT(PNULL!=p_encoded_mac_i);
    RRC_ASSERT(PNULL!=p_encoded_msg_length);
    RRC_ASSERT(PNULL!=p_ue_context->p_gb_context->p_p_csc_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                p_ue_context->cell_index))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    do{
        /* Init ASN context */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_HandoverCancel] ASN context initialization failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;

        }

        p_var_short_mac_i =
            (VarShortMAC_Input*)rtxMemAlloc(&asn1_ctx,
                    sizeof(VarShortMAC_Input));
        if (PNULL == p_var_short_mac_i)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
    	                RRC_FATAL, "ASN malloc failed.");
           /*SPR_18125_START*/
            rtFreeContext(&asn1_ctx);
            /*SPR_18125_END*/
    	    return RRC_FAILURE;
        }

        /* assigning number of bits of cell_identity */
        p_var_short_mac_i->cellIdentity.numbits = CELL_ID_NBITS;

        /* SPR 14238 FIX START */
        /* SPR 13750 Start */
        l3_memcpy_wrapper ( p_var_short_mac_i->cellIdentity.data,
                p_cell_identity, sizeof(U32));
        /* SPR 13750 Stop */
        /* SPR 14238 FIX END */

        if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                [p_ue_context->cell_index])
        {
            if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                    [p_ue_context->cell_index]->p_csc_init_setup_ind)
            {

                p_var_short_mac_i->physCellId = p_ue_context->p_gb_context->p_p_csc_context[
                    p_ue_context->cell_index]->p_csc_init_setup_ind->phys_cell_id;
            }
        }    
        /* assigning crnti_numbits */
        p_var_short_mac_i->c_RNTI.numbits = CRNTI_NBITS; 


        /*SPR_17121_START*/
        rrc_pack_U16(
                p_var_short_mac_i->c_RNTI.data,
                &p_ue_context->crnti);
        /*SPR_17121_END*/


        if( RRC_SUCCESS != rrc_var_short_mac_input_intrl_enc(
                    p_ue_context->p_gb_context,
                    &asn1_ctx,
                    p_encoded_mac_i,
                    p_encoded_msg_length,
                    p_var_short_mac_i))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "Failed to encode p_var_short_mac_i");
            ret = RRC_FAILURE;
            break;
        }
    }while(0);
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return ret;
}


/******************************************************************************
 * Function Name  : uecc_llim_build_and_send_ue_inactive_time_req 
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:    This is the function for building and sending
 *                   UECC_LLIM_UE_INACTIVE_TIME_REQ message to the LLIM.
 ****************************************************************************/
rrc_return_t uecc_llim_build_and_send_ue_inactive_time_req(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_uecc_llim_ue_inactive_time_req_t rrc_uecc_llim_ue_inactive_time_req;
    rrc_return_et                   result = RRC_FAILURE;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Reset */
    memset_wrapper(&rrc_uecc_llim_ue_inactive_time_req, 0,
            sizeof(rrc_uecc_llim_ue_inactive_time_req_t));

    /* ue_index */
    rrc_uecc_llim_ue_inactive_time_req.ue_index =  p_uecc_ue_context->ue_index;
    rrc_uecc_llim_ue_inactive_time_req.cell_index =  p_uecc_ue_context->cell_index;
    /* Transaction ID */
    rrc_uecc_llim_ue_inactive_time_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_UE_INACTIVE_TIME_REQ,
            sizeof(rrc_uecc_llim_ue_inactive_time_req_t),
            &rrc_uecc_llim_ue_inactive_time_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_sn_hfn_status_transfer_req 
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:    This is the function for building and sending
 *                   UECC_LLIM_SN_HFN_STATUS_REQ message to the LLIM.
 ****************************************************************************/

rrc_return_t uecc_llim_build_and_send_sn_hfn_status_transfer_req(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_uecc_llim_sn_hfn_status_req_t rrc_uecc_llim_sn_hfn_status_req;
    rrc_return_et                   result = RRC_FAILURE;
    /* lossy ho changes start */
    U8  drb_id = 0;
    /* lossy ho changes stop */
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&rrc_uecc_llim_sn_hfn_status_req, 0,
            sizeof(rrc_uecc_llim_sn_hfn_status_req_t));    

    /* ue_index */
    rrc_uecc_llim_sn_hfn_status_req.ue_index =  p_uecc_ue_context->ue_index;
    rrc_uecc_llim_sn_hfn_status_req.cell_index =  p_uecc_ue_context->cell_index;
    /* Transaction ID */
    rrc_uecc_llim_sn_hfn_status_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    /* for i-RAT, Set SN_HFN_status_required as False as no need of this */
    if ((HANDOVER_TYPE_LTE_TO_UTRAN == p_uecc_ue_context->ho_info.p_ho_info->\
                p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type) ||
            (HANDOVER_TYPE_LTE_TO_GERAN == p_uecc_ue_context->ho_info.p_ho_info->\
             p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type)|| 
            /*BUG 604 changes start*/
            /*(HANDOVER_TYPE_INTRA_CELL == p_uecc_ue_context->ho_info.p_ho_info->\
              p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type)||*/
            /*BUG 604 changes stop*/
            (HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT== p_uecc_ue_context->ho_info.p_ho_info->\
             p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type)|| 
            (HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD == p_uecc_ue_context->ho_info.p_ho_info->\
             p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type)|| 
            (HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD == p_uecc_ue_context->ho_info.p_ho_info->\
             p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type) ||
            (HANDOVER_TYPE_CCO == p_uecc_ue_context->ho_info.p_ho_info->\
             p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type)) 

    {
        rrc_uecc_llim_sn_hfn_status_req.sn_hfn_required = RRC_FALSE;
    }
    else
    {
        /* The status should go as RRC_TRUE for AM Mode only*/
        if(RRC_TRUE == is_am_mode_configured_drb_present(p_uecc_ue_context))
        {
            /* Set SN_HFN_status required as True  */
            rrc_uecc_llim_sn_hfn_status_req.sn_hfn_required = RRC_TRUE;
        }
        else
        {
            rrc_uecc_llim_sn_hfn_status_req.sn_hfn_required = RRC_FALSE;
        }
    }
    /* lossy ho changes start */
    if( ERAB_LOSSY_HO_LIST_PRESENT &  p_uecc_ue_context->ho_info.p_ho_info->
            p_src_ho_info->s1_src_ho_info.bitmask )
    {
        for (drb_id = 0; drb_id < (U8)(p_uecc_ue_context->ho_info.p_ho_info->
                    p_src_ho_info->s1_src_ho_info.erab_lossy_ho_list.count); drb_id++)
        {
            rrc_uecc_llim_sn_hfn_status_req.lossy_lc_id[drb_id] = 
                p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info->
                s1_src_ho_info.erab_lossy_ho_list.lc_id[drb_id];

        }

        rrc_uecc_llim_sn_hfn_status_req.lossy_drb_counter = 
            p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info->
            s1_src_ho_info.erab_lossy_ho_list.count;
    }

    /* lossy ho changes stop */
    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_SN_HFN_STATUS_REQ,
            sizeof(rrc_uecc_llim_sn_hfn_status_req_t),
            &rrc_uecc_llim_sn_hfn_status_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}


/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_re_est_req 
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:    This is the function for building and sending
 *                   UECC_LLIM_RE_EST_REQ message to the LLIM.
 ****************************************************************************/

rrc_return_t uecc_llim_build_and_send_re_est_req(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_uecc_llim_re_establish_ue_entity_req_t
        rrc_uecc_llim_re_est_req;
    rrc_return_et                   result = RRC_FAILURE;
    rrc_counter_t  erab_idx = 0, lc_count = 0;
    rrc_uecc_llim_lc_id_list_t    *p_lc_id_list = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /*initializing the variable */
    memset_wrapper(&rrc_uecc_llim_re_est_req, 0, sizeof(rrc_uecc_llim_re_est_req));

    /* ue_index */
    rrc_uecc_llim_re_est_req.ue_index = p_uecc_ue_context->ue_index;
    rrc_uecc_llim_re_est_req.cell_index = p_uecc_ue_context->cell_index;
    /* Transaction ID */
    rrc_uecc_llim_re_est_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    p_lc_id_list = &rrc_uecc_llim_re_est_req.lc_id_list;
    /* filling the list of LCs */
    for(erab_idx = 0; erab_idx < MAX_ERAB_COUNT; erab_idx ++)
    {
        if(p_uecc_ue_context->p_e_rab_list[erab_idx])
        {
#ifdef ENDC_ENABLED
            /*OPTION3X Changes Start*/
            U8 count = 0;
            if(p_uecc_ue_context->p_curr_proc_data  //add for bugid 117724
				&&(UECC_RRM_DC_BEARER_CHANGE_PROC == p_uecc_ue_context->p_curr_proc_data->t))
            {
                if((RRM_DRB_CONFIG_DC_BEARER_TYPE_PRESENT &
                            p_uecc_ue_context->p_e_rab_list[erab_idx]->drb_config.bitmask) &&
                        (SN_TERMINATED_SPLIT_BEARER ==
                         p_uecc_ue_context->p_e_rab_list[erab_idx]->drb_config.dc_bearer_type))
                    /*OPTION3X Changes Stop*/
                {
                	/*Logical_Error*/
					for(count = 0; count < p_uecc_ue_context->p_curr_proc_data->u.
                	  	    rrm_dc_bearer_change_request_data.drb_to_modify_list.drb_count;
                	  	    count++)
                	{
                	  	if((p_uecc_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data.
                	  	      		drb_to_modify_list.drb_config[count].erab_id == erab_idx) &&
                	  	      	(p_uecc_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data.
                	  	      	 drb_to_modify_list.drb_config[count].erab_success == RRC_TRUE))
                	  	{
                	/*Logical_Error*/

                    		p_lc_id_list->lc_id_state[lc_count].lc_id = 
                        		p_uecc_ue_context->p_e_rab_list[erab_idx]->
                        		drb_config.logical_channel_identity;
                    		if (p_uecc_ue_context->p_e_rab_list[erab_idx]->
                            		drb_config.rlc_config_enb.rlc_config.bitmask &
                            		RRC_RLC_CONFIG_AM_CONFIG_PRESENT)
                    		{
                        		rrc_uecc_llim_re_est_req.lc_id_list.lc_id_state[lc_count].
                            		state = RLC_LLIM_FREEZE;
                    		}
                    		else
                    		{
                        		rrc_uecc_llim_re_est_req.lc_id_list.lc_id_state[lc_count].
                            		state = RLC_LLIM_NO_ACTION;
                    		}
                    		lc_count++;
	  	  					break;
                    	}
                    }

                }
            }
            else
#endif
            {
                p_lc_id_list->lc_id_state[lc_count].lc_id = 
                    p_uecc_ue_context->p_e_rab_list[erab_idx]->
                    drb_config.logical_channel_identity;
                if (p_uecc_ue_context->p_e_rab_list[erab_idx]->
                        drb_config.rlc_config_enb.rlc_config.bitmask &
                        RRC_RLC_CONFIG_AM_CONFIG_PRESENT)
                {
                    rrc_uecc_llim_re_est_req.lc_id_list.lc_id_state[lc_count].
                        state = RLC_LLIM_FREEZE;
                }
                else
                {
                    rrc_uecc_llim_re_est_req.lc_id_list.lc_id_state[lc_count].
                        state = RLC_LLIM_NO_ACTION;
                }
                lc_count++;
            }
        }
    }
    p_lc_id_list->lc_count = (U8)lc_count;

    /* sending the message to LLIM */
    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_RE_ESTABLISH_UE_ENTITY_REQ,
            sizeof(rrc_uecc_llim_re_establish_ue_entity_req_t),
            &rrc_uecc_llim_re_est_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

#ifdef ENDC_ENABLED
/*OPTION3X Changes Start*/
/****************************************************************************
 * Function Name  : uecc_llim_build_s1u_reconfig_req_for_dc_bearer_change 
 * Inputs         : rrc_uecc_llim_s1u_setup_sap_req_list_t  *p_s1u_setup_sap_req_list
 *                  uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_et 
 * Description:    This is the function for building 
 *                   UECC_LLIM_S1U_RECONFIG_REQ during DC_BEARER_CHANGE_PROC
 ****************************************************************************/
/* coverity_277525_fix_start */ 
rrc_return_et uecc_llim_build_s1u_reconfig_req_for_dc_bearer_change(
/* coverity_277525_fix_end */ 
        rrc_uecc_llim_s1u_setup_sap_req_list_t  *p_s1u_setup_sap_req_list,
        rrc_bitmask_t       *p_bitmask,
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )

{
    U8                                  count                   = RRC_ZERO;
    U8                                  num_sap_req                   = RRC_ZERO;
/* coverity_277525_fix_start */
    rrc_return_et                        result                  = RRC_SUCCESS;
/* coverity_277525_fix_end */
    rrc_drb_to_modify_list_t*           p_drb_to_modify_list    = PNULL;
    rrc_drb_to_mod_item_t*              p_drb_config            = PNULL;
    rrc_uecc_llim_s1u_setup_sap_req_t*  p_setup_sap_req         = PNULL; 
    uecc_erab_failed_to_setup_list_t*   p_failed_erab_data;

    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
            (p_uecc_ue_context->p_gb_context)->facility_name,
            RRC_DETAILED, "[%s][%d]", __func__, __LINE__);

//    if( RRC_ONE ==
  //          p_uecc_ue_context->p_curr_proc_data->u.
    //        rrm_dc_bearer_change_request_data.m.drb_config_updated)
    {
        p_drb_to_modify_list = 
            &p_uecc_ue_context->p_curr_proc_data->u.
            rrm_dc_bearer_change_request_data.drb_to_modify_list;

		/*Logical_Error*/
		p_failed_erab_data = 
		    &p_uecc_ue_context->p_curr_proc_data->u.
        	rrm_dc_bearer_change_request_data.failed_erab_data;
		/*Logical_Error*/

        for(count = 0; count < p_drb_to_modify_list->drb_count; count++)
        {
            if(count < RRC_S1U_MAX_NUM_LC)
            {
                /*Logical_Error*/
    			if((!strcmp_wrapper(p_uecc_ue_context->uecc_fsm.proc_descriptor.p_current_state->s_name, 
            					(const S8 *)("UECC_RRM_DC_BEARER_CHANGE_S1U_RECONFIG_ONGOING"))) ||
            			(p_drb_to_modify_list->drb_config[num_sap_req].erab_success != RRC_FALSE))	
            	{
            		*p_bitmask |= RRC_UECC_LLIM_S1U_SETUP_SAP_REQ_LIST_PRESENT;
                /*Logical_Error*/

                	p_setup_sap_req = 
                    	&(p_s1u_setup_sap_req_list->setup_sap_req[num_sap_req++]);

                	p_drb_config = 
                    	&(p_drb_to_modify_list->drb_config[count]);

                	/*bitmask*/
                	p_setup_sap_req->bitmask = 0;

                	/*lc_id - update the new lc_id received from rrm in 
                 	 * dc_bearer_change_request_data_t*/
                	p_setup_sap_req->lc_id = p_drb_config->new_lc_id;

                	/*qos id*/
                	p_setup_sap_req->qos_id = p_drb_config->qos_id;

                	/*tunnel_count*/
                	p_setup_sap_req->tunnel_count = 1 ;

                	/*tunnel_info*/
                	{
                    	/*check if dc_bearer_type is SN_TERMINATED_SPLIT_BEARER,
                     	 * if not there is some error hence return*/
                    	if(SN_TERMINATED_SPLIT_BEARER == p_drb_config->dc_bearer_type)
                    	{
                        	/*update the sap_flag for X2U tunnel*/
                        	p_setup_sap_req->tunnel_info[0].sap_flag =
                            	RRC_S1U_RECONFIG_UE_X2U_TUNNEL_SAP_FLAG;
                    	}
                    	else
                    	{
                        	RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                	(p_uecc_ue_context->p_gb_context)->facility_name,
                                	RRC_FATAL,
                                	"[UECC_LLIM_S1U_RECONFIG_REQ] "
                                	"Invalid dc_bearer_type[%d] is present in "
                                	"DC_BEARER_CHANGE_PROC message", 
                                	p_drb_config->dc_bearer_type);

                        	result = RRC_FAILURE;
                    	}

                    	/*teid_peer */
                    	if(RRC_ONE == p_drb_config->m.rrc_x2u_ul_teid_peer_updated)
                    	{
                        	/*teid_peer - shall only be updated when the teid_self is present*/
                        	if(RRC_ONE != p_drb_config->m.rrc_x2u_dl_teid_self_updated)
                        	{
                            	RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    	(p_uecc_ue_context->p_gb_context)->facility_name,
                                    	RRC_FATAL,
                                    	"[UECC_LLIM_S1U_RECONFIG_REQ] "
                                    	"TEID PEER is present without SELF TEID in "
                                    	"DC_BEARER_CHANGE_PROC message for new_lc_id[%d] "
                                    	"and old_cl_id[%d]", 
                                    	p_drb_config->new_lc_id,
                                    	p_drb_config->old_lc_id);

                            	result = RRC_FAILURE;
                        	}
                        	rrc_unpack_U32((U8*)&(p_setup_sap_req->tunnel_info[0].teid_peer),
                                	p_drb_config->ul_x2u_teid_peer.data);

                        	p_setup_sap_req->tunnel_info[0].bitmask |=
                            	RRC_UECC_LLIM_S1U_TUNNEL_INFO_TEID_PEER_PRESENT;
                    	}

                    	if(RRC_ONE == p_drb_config->m.rrc_x2u_ul_trasport_addr_updated)
                    	{
                        	RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                	(p_uecc_ue_context->p_gb_context)->facility_name,
                                	RRC_DETAILED,
                                	"[UECC_LLIM_S1U_RECONFIG_REQ] "
                                	"transportLayerAddress length =%d",
                                	p_drb_config->ul_x2u_transport_layer_addr.numbits);

                        	/* IPV6  or IPV4 */
                        	if ((RRC_MAX_IP_ADDR_LEN_IPV6*8 
                                    	== p_drb_config->ul_x2u_transport_layer_addr.numbits) 
                                	|| (RRC_MAX_IP_ADDR_LEN*8 
                                    	== p_drb_config->ul_x2u_transport_layer_addr.numbits) 
                           	   )
                        	{
                            	p_setup_sap_req->tunnel_info[0].bitmask |=
                                	RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;

                            	p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                                	(U8)(p_drb_config->ul_x2u_transport_layer_addr.numbits/8);

                            	l3_memcpy_wrapper(
                                    	p_setup_sap_req->tunnel_info[0]
                                    	.transport_addr.data,
                                    	p_drb_config->ul_x2u_transport_layer_addr.data,
                                    	p_setup_sap_req->tunnel_info[0].transport_addr.data_length);

                        	}
                        	else
                        	{
                            	RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    	(p_uecc_ue_context->p_gb_context)->facility_name,
                                    	RRC_WARNING,
                                    	"[UECC_LLIM_ADD_LC_REQ] "
                                    	"transportLayerAddress has invalid size");
                            	/*unset the bitmask */
                            	p_setup_sap_req->tunnel_info[0].bitmask &=
                                	~RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                        	}
                    	}
                	}

                	/*qos_profile*/
                	{
                    	p_setup_sap_req->qos_profile.allocation_retention_priority =
                        	p_drb_config->qos_profile.allocation_retention_priority;

                    	p_setup_sap_req->qos_profile.qos_profile_data_length =
                        	p_drb_config->qos_profile.qos_profile_data_size;

                    	l3_memcpy_wrapper(p_setup_sap_req->qos_profile.qos_profile_data,
                            	p_drb_config->qos_profile.qos_profile_data,
                            	p_drb_config->qos_profile.qos_profile_data_size);
                	}

                	/*teid_self*/
                	if(RRC_ONE == p_drb_config->m.rrc_x2u_dl_teid_self_updated)
                	{
                    	p_setup_sap_req->teid_self =
                        	p_drb_config->dl_x2u_teid_self;

                    	p_setup_sap_req->bitmask |=
                        	RRC_UECC_LLIM_S1U_TEID_SELF_PRESENT;
                	}

                	/*dc_bearer_type*/
                	{
                    	p_setup_sap_req->dc_bearer_type =
                        	p_drb_config->dc_bearer_type;

                     	p_setup_sap_req->bitmask |=
                         	RRC_UECC_LLIM_S1U_DC_BEARER_TYPE_PRESENT;
                	}
                    if ( RRC_ONE == p_uecc_ue_context->p_e_rab_list[p_drb_config->erab_id]->
                         	m.rlcModePresent )
                    {
                        p_setup_sap_req->rlc_mode_endc =
                            p_uecc_ue_context->p_e_rab_list[p_drb_config->erab_id]->
                            rlc_mode_sgnb;
                        p_setup_sap_req->bitmask |=
                            RRC_UECC_LLIM_S1U_RLC_MODE_ENDC_PRESENT;

                    }
                    if ( RRC_ONE == p_uecc_ue_context->p_e_rab_list[p_drb_config->erab_id]->
                         	m.pdcpSnSizePresent )
                    {
                        p_setup_sap_req->pdcp_sn_size_endc =
                            p_uecc_ue_context->p_e_rab_list[p_drb_config->erab_id]->
                            pdcp_sn_size_sgnb;
                        p_setup_sap_req->bitmask |=
                            RRC_UECC_LLIM_S1U_PDCP_SN_SIZE_ENDC_PRESENT;

                    }
                /*Logical_Error*/
  				}
                else 
                {
                	/* Put Fail Erab ID recv from SgNB in Fail List */
                	p_failed_erab_data->erab_failed_to_setup_item[p_failed_erab_data->count].
                	    e_RAB_ID = p_drb_to_modify_list->drb_config[count].erab_id;
                    /* MAP CAUSE VALUE HERE AND STORE IN FAILED LIST */
                    x2ap_Cause x2apCause;
                    x2apCause.t = T_x2ap_Cause_transport;
                    x2apCause.u.transport = x2ap_unspecified_3;

                	map_x2ap_cause_to_s1ap_cause(
                		    x2apCause,
                		    &p_failed_erab_data->erab_failed_to_setup_item[p_failed_erab_data->count].
                		    cause
                		    );
					p_failed_erab_data->erab_failed_to_setup_item[p_failed_erab_data->count++].new_lcId = 
                		p_drb_to_modify_list->drb_config[count].new_lc_id;


                }
                /*Logical_Error*/

            }
            else
            {
                /*lc count is greater than supported lc_id*/

                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "[UECC_LLIM_S1U_RECONFIG_REQ] "
                        "Total LC count[%d] is greater than supported lc count",
                        count);

                result = RRC_FAILURE;
            }
        }
            /*Logical_Error*/
        /*num_setup_sap_req*/
        p_s1u_setup_sap_req_list->num_setup_sap_req = num_sap_req;

        /*prepare rel_sap_req*/
		/* bitmask */
		uecc_drb_ctx_t              *p_erab_ctx             = PNULL;
		if(p_failed_erab_data->count)
		{
			rrc_uecc_llim_s1u_reconfigure_req_t rrc_uecc_llim_s1u_reconfigure_req;
    		memset_wrapper(&rrc_uecc_llim_s1u_reconfigure_req, 0, 
            		sizeof(rrc_uecc_llim_s1u_reconfigure_req_t));

			rrc_uecc_llim_s1u_reconfigure_req.bitmask |= RRC_UECC_LLIM_S1U_REL_SAP_REQ_LIST_PRESENT;
    		/* ue_index */
    		rrc_uecc_llim_s1u_reconfigure_req.ue_index =  p_uecc_ue_context->ue_index;
    		rrc_uecc_llim_s1u_reconfigure_req.cell_index =  p_uecc_ue_context->cell_index;

    		/* Transaction ID */
    		rrc_uecc_llim_s1u_reconfigure_req.transaction_id =
        		uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);


        	rrc_uecc_llim_s1u_rel_sap_req_list_t       *p_rel_sap_req_list =PNULL;
            p_rel_sap_req_list = &rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list;
    		for(count = 0; count < p_failed_erab_data->count; count++)
        	{
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_DETAILED, "DC Beraer Change for New DRB ID[%d] with "
                        "new_lc_id[%d]  has failed",
                        p_failed_erab_data->erab_failed_to_setup_item[count].e_RAB_ID,
                        p_failed_erab_data->erab_failed_to_setup_item[count].new_lcId)

                	p_rel_sap_req_list->rel_sap_req[count].
                    lc_id = p_failed_erab_data->erab_failed_to_setup_item[count].new_lcId;

   				/* Rollback All the data for the Failed ERABs, erab_failed needs to be set
         		 * beforehand
         		 */
         		U16 erab_id = p_failed_erab_data->erab_failed_to_setup_item[count].e_RAB_ID;
         		U8  erab_count = 0;
         		p_erab_ctx = p_uecc_ue_context->p_e_rab_list[erab_id];
        		if(PNULL != p_erab_ctx)
        		{
        			for(erab_count = 0; erab_count < p_drb_to_modify_list->drb_count; erab_count++)
        			{
        				if(erab_id == p_drb_to_modify_list->drb_config[erab_count].erab_id)
        				{
            				/* Rollback LogicalChannelId to old LCID*/
            				p_erab_ctx->drb_config.logical_channel_identity =
                				p_drb_to_modify_list->drb_config[erab_count].old_lc_id;

            				/* Rollback DC_bearer_type in uecc_erab_ctxt*/
            				p_erab_ctx->dc_bearer_type = RRC_ZERO;
            				p_erab_ctx->m.DC_BearerTypePresent = RRC_ZERO;

            				/* Rollback DC_bearer_type in uecc_erab_ctxt->drb_config*/
            				p_erab_ctx->drb_config.dc_bearer_type = RRC_ZERO;
            				p_erab_ctx->drb_config.bitmask ^=
                				RRM_DRB_CONFIG_DC_BEARER_TYPE_PRESENT;

            				/*RollBack sgnb_s1ap_gtp_id in uecc_erab_context*/
            				memset_wrapper(
                    				&p_erab_ctx->sgnb_s1ap_gtp_id,
                    				RRC_ZERO,
                    				sizeof(x2ap_GTP_TEI));

            				/*RollBack sgnb_s1ap_transportLayerAddress in uecc_erab_context*/
            				memset_wrapper(
                    				&p_erab_ctx->sgnb_s1ap_transportLayerAddress,
                    				RRC_ZERO,
                    				sizeof(x2ap_TransportLayerAddress));
						}
                	}

        		}

        	}
        	p_rel_sap_req_list->num_rel_sap_req = p_failed_erab_data->count;
			result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            		UECC_LLIM_S1U_RECONFIGURE_REQ,
            		sizeof(rrc_uecc_llim_s1u_reconfigure_req_t),
            		&rrc_uecc_llim_s1u_reconfigure_req);
            /*Logical_Error*/

        }


    }
    return result;
}
/*OPTION3X Changes Stop*/
#endif

/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_s1u_reconfig_req 
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:    This is the function for building and sending
 *                   UECC_LLIM_S1U_RECONFIG_REQ message to the LLIM.
 ****************************************************************************/
rrc_return_t uecc_llim_build_and_send_s1u_reconfig_req(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_uecc_llim_s1u_reconfigure_req_t rrc_uecc_llim_s1u_reconfigure_req;
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ho_src_drb_forward_info_t *p_uecc_ho_src_drb_forward_info = PNULL;
    uecc_ho_src_drb_admitted_info_t *p_uecc_ho_src_drb_admitted_info = PNULL;
    uecc_drb_ctx_t      *p_erab_ctx = PNULL;
    rrc_counter_t i =0;
    rrc_uecc_llim_s1u_setup_sap_req_t *p_setup_sap_req = PNULL; 
    rrc_counter_t req_count = 0;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    memset_wrapper(&rrc_uecc_llim_s1u_reconfigure_req, 0, 
            sizeof(rrc_uecc_llim_s1u_reconfigure_req_t));

    /* ue_index */
    rrc_uecc_llim_s1u_reconfigure_req.ue_index =  p_uecc_ue_context->ue_index;
    rrc_uecc_llim_s1u_reconfigure_req.cell_index =  p_uecc_ue_context->cell_index;

    /* Transaction ID */
    rrc_uecc_llim_s1u_reconfigure_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    /* bitmask */
    rrc_uecc_llim_s1u_reconfigure_req.bitmask |= 
        RRC_UECC_LLIM_S1U_SETUP_SAP_REQ_LIST_PRESENT;

    /* If S1 Handover */  
    if ( S1_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover)
    {
        /* num_setup_sap_req */
        rrc_uecc_llim_s1u_reconfigure_req.setup_sap_req_list.
            num_setup_sap_req = 
            p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info
            ->s1_src_ho_info.src_drb_fwd_list.count;
        req_count = 0;

        for(i = 0; i < MAX_ERAB_COUNT ; i++ )
        {
            if( PNULL != p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info
                    ->s1_src_ho_info.src_drb_fwd_list.
                    erab_ho_src_drb_forward_list[i])
            {
                if( req_count < RRC_S1U_MAX_NUM_LC)
                {
                    p_setup_sap_req 
                        = &(rrc_uecc_llim_s1u_reconfigure_req.setup_sap_req_list.
                                setup_sap_req[req_count]);

                    p_uecc_ho_src_drb_forward_info 
                        = p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info
                        ->s1_src_ho_info.src_drb_fwd_list.
                        erab_ho_src_drb_forward_list[i]; 

                    p_erab_ctx = p_uecc_ue_context->p_e_rab_list[i];
                    if(!p_erab_ctx)
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_INFO, "erab_context corresponding to "
                                " erab id [%d] is missing ",i);
                        continue;
                    }

                    /* bitmask */
                    p_setup_sap_req->bitmask = 0;

                    /* lc_id */
                    p_setup_sap_req->lc_id = p_erab_ctx->drb_config.
                        logical_channel_identity; 

                    /* qos_id */
                    p_setup_sap_req->qos_id = p_erab_ctx->drb_config.s1u_config.qos_id;

                    /* tunnel_count */
                    p_setup_sap_req->tunnel_count = 1 ;
                    /* tunnel_info */
                    if ((UECC_FORWARDING_DIRECTION_DL== 
                                p_uecc_ho_src_drb_forward_info->forward_direction)
                            || (UECC_FORWARDING_DIRECTION_BOTH ==  
                                p_uecc_ho_src_drb_forward_info->forward_direction))
                    {
                        /* HO Integration Fix.*/
                        p_setup_sap_req->tunnel_info[0].sap_flag =
                            RRC_S1U_RECONFIG_UE_DL_FORWARDING_TUNNEL_SAP_FLAG;

                        rrc_unpack_U32(
                                &(p_setup_sap_req->tunnel_info[0].teid_peer),
                                p_uecc_ho_src_drb_forward_info->dl_teid_peer.data);

                        p_setup_sap_req->tunnel_info[0].bitmask |=
                            RRC_UECC_LLIM_S1U_TUNNEL_INFO_TEID_PEER_PRESENT;

                        /* SPR 15627 FIX Start*/
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_DETAILED,
                                "[UECC_LLIM_ADD_LC_REQ] "
                                "transportLayerAddress length =%d", p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits);

                        /* IPV6  or IPV4 */
                        if ((RRC_MAX_IP_ADDR_LEN_IPV6*8 
                                    == p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits)
                                || (RRC_MAX_IP_ADDR_LEN*8 
                                    == p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits)
                           )
                        {
                            p_setup_sap_req->tunnel_info[0].bitmask |=
                                RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;

                            p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                                (U8)(p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits/8);

                            l3_memcpy_wrapper(
                                    p_setup_sap_req->tunnel_info[0]
                                    .transport_addr.data,
                                    p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.data,
                                    p_setup_sap_req->tunnel_info[0].transport_addr.data_length);

                        }
                        /*IPV4 and IPV6 160 bit*/
                        else if((RRC_MAX_IP_ADDR_LEN*8 + RRC_MAX_IP_ADDR_LEN_IPV6*8)
                                == p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits)  
                        {
                            p_setup_sap_req->tunnel_info[0].bitmask |=
                                RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                            /* set IPV6 or IPV4 as per active mme info*/
                            /*
                             * if both IPv4 and IPv6 addresses are signaled, 
                             * then IPv4 address is contained in the first 32 bits
                             */
                            if(p_uecc_ue_context->p_gb_context->mme_ctx[p_uecc_ue_context->mme_id].connection_info.bitmask
                                    & MME_COMM_INFO_IPV6_ADDR_PRESENT) /*IPV6 */
                            {
                                /*extract ipv6 from transportLayerAddress*/
                                p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                                    RRC_MAX_IP_ADDR_LEN_IPV6;

                                l3_memcpy_wrapper(
                                        p_setup_sap_req->tunnel_info[0]
                                        .transport_addr.data,
                                        (U8*)(p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.data)+ RRC_MAX_IP_ADDR_LEN ,
                                        RRC_MAX_IP_ADDR_LEN_IPV6);
                            }
                            else /*fill IPV4*/
                            {
                                p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                                    RRC_MAX_IP_ADDR_LEN;

                                l3_memcpy_wrapper(
                                        p_setup_sap_req->tunnel_info[0]
                                        .transport_addr.data,
                                        p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.data,
                                        RRC_MAX_IP_ADDR_LEN);
                            }

                        }
                        else
                        {
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_WARNING,
                                    "[UECC_LLIM_ADD_LC_REQ] "
                                    "transportLayerAddress has invalid size");
                            /*unset the bitmask */
                            p_setup_sap_req->tunnel_info[0].bitmask &=
                                ~RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                            //error
                        }
                        /* SPR 15627 FIX End*/
                    }
                    else
                    {
                        p_setup_sap_req->tunnel_info[0].sap_flag =
                            RRC_S1U_RECONFIG_UE_UL_FORWARDING_TUNNEL_SAP_FLAG;

                        rrc_unpack_U32(
                                &p_setup_sap_req->tunnel_info[0].teid_peer,
                                p_uecc_ho_src_drb_forward_info->ul_teid_peer.data);

                        p_setup_sap_req->tunnel_info[0].bitmask |=
                            RRC_UECC_LLIM_S1U_TUNNEL_INFO_TEID_PEER_PRESENT;

                        /* SPR 15627 FIX Start*/
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_DETAILED,
                                "[UECC_LLIM_ADD_LC_REQ] "
                                "transportLayerAddress length =%d", p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits);

                        /* IPV6  or IPV4 */
                        if ((RRC_MAX_IP_ADDR_LEN_IPV6*8 
                                    == p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits)
                                || (RRC_MAX_IP_ADDR_LEN*8 
                                    == p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits)
                           )
                        {
                            p_setup_sap_req->tunnel_info[0].bitmask |=
                                RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;

                            p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                                (U8)(p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits/8);

                            l3_memcpy_wrapper(
                                    p_setup_sap_req->tunnel_info[0]
                                    .transport_addr.data,
                                    p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.data,
                                    p_setup_sap_req->tunnel_info[0].transport_addr.data_length);

                        }
                        /*IPV4 and IPV6 160 bit*/
                        else if((RRC_MAX_IP_ADDR_LEN*8 + RRC_MAX_IP_ADDR_LEN_IPV6*8)
                                == p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits)  
                        {
                            p_setup_sap_req->tunnel_info[0].bitmask |=
                                RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                            /* set IPV6 or IPV4 as per active mme info*/
                            /*
                             * if both IPv4 and IPv6 addresses are signaled, 
                             * then IPv4 address is contained in the first 32 bits
                             */
                            if(p_uecc_ue_context->p_gb_context->mme_ctx[p_uecc_ue_context->mme_id].connection_info.bitmask
                                    & MME_COMM_INFO_IPV6_ADDR_PRESENT) /*IPV6 */
                            {
                                /*extract ipv6 from transportLayerAddress*/
                                p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                                    RRC_MAX_IP_ADDR_LEN_IPV6;

                                l3_memcpy_wrapper(
                                        p_setup_sap_req->tunnel_info[0]
                                        .transport_addr.data,
                                        (U8*)(p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.data)+ RRC_MAX_IP_ADDR_LEN ,
                                        RRC_MAX_IP_ADDR_LEN_IPV6);
                            }
                            else /*fill IPV4*/
                            {
                                p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                                    RRC_MAX_IP_ADDR_LEN;

                                l3_memcpy_wrapper(
                                        p_setup_sap_req->tunnel_info[0]
                                        .transport_addr.data,
                                        p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.data,
                                        RRC_MAX_IP_ADDR_LEN);
                            }

                        }
                        else
                        {
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_WARNING,
                                    "[UECC_LLIM_ADD_LC_REQ] "
                                    "transportLayerAddress has invalid size");
                            /*unset the bitmask */
                            p_setup_sap_req->tunnel_info[0].bitmask &=
                                ~RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                            //error
                        }
                        /* SPR 15627 FIX End*/

                    }
                    if (UECC_FORWARDING_DIRECTION_BOTH 
                            == p_uecc_ho_src_drb_forward_info->forward_direction ) 
                    {
                        p_setup_sap_req->tunnel_count = 2 ;
                        p_setup_sap_req->tunnel_info[1].sap_flag =
                            RRC_S1U_RECONFIG_UE_UL_FORWARDING_TUNNEL_SAP_FLAG;

                        rrc_unpack_U32(
                                &p_setup_sap_req->tunnel_info[1].teid_peer,
                                p_uecc_ho_src_drb_forward_info->ul_teid_peer.data);

                        p_setup_sap_req->tunnel_info[1].bitmask |=
                            RRC_UECC_LLIM_S1U_TUNNEL_INFO_TEID_PEER_PRESENT;

                        /* SPR 15627 FIX Start*/
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_DETAILED,
                                "[UECC_LLIM_ADD_LC_REQ] "
                                "transportLayerAddress length =%d", p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits);

                        /* IPV6  or IPV4 */
                        if ((RRC_MAX_IP_ADDR_LEN_IPV6*8 
                                    == p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits)
                                || (RRC_MAX_IP_ADDR_LEN*8 
                                    == p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits)
                           )
                        {
                            p_setup_sap_req->tunnel_info[1].bitmask |=
                                RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;

                            p_setup_sap_req->tunnel_info[1].transport_addr.data_length =
                                (U8)(p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits/8);

                            l3_memcpy_wrapper(
                                    p_setup_sap_req->tunnel_info[1]
                                    .transport_addr.data,
                                    p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.data,
                                    p_setup_sap_req->tunnel_info[1].transport_addr.data_length);

                        }
                        /*IPV4 and IPV6 160 bit*/
                        else if((RRC_MAX_IP_ADDR_LEN*8 + RRC_MAX_IP_ADDR_LEN_IPV6*8)
                                == p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.numbits)  
                        {
                            p_setup_sap_req->tunnel_info[1].bitmask |=
                                RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                            /* set IPV6 or IPV4 as per active mme info*/
                            /*
                             * if both IPv4 and IPv6 addresses are signaled, 
                             * then IPv4 address is contained in the first 32 bits
                             */
                            if(p_uecc_ue_context->p_gb_context->mme_ctx[p_uecc_ue_context->mme_id].connection_info.bitmask
                                    & MME_COMM_INFO_IPV6_ADDR_PRESENT) /*IPV6 */
                            {
                                /*extract ipv6 from transportLayerAddress*/
                                p_setup_sap_req->tunnel_info[1].transport_addr.data_length =
                                    RRC_MAX_IP_ADDR_LEN_IPV6;

                                l3_memcpy_wrapper(
                                        p_setup_sap_req->tunnel_info[1]
                                        .transport_addr.data,
                                        (U8*)(p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.data)+ RRC_MAX_IP_ADDR_LEN ,
                                        RRC_MAX_IP_ADDR_LEN_IPV6);
                            }
                            else /*fill IPV4*/
                            {
                                p_setup_sap_req->tunnel_info[1].transport_addr.data_length =
                                    RRC_MAX_IP_ADDR_LEN;

                                l3_memcpy_wrapper(
                                        p_setup_sap_req->tunnel_info[1]
                                        .transport_addr.data,
                                        p_uecc_ho_src_drb_forward_info->dl_transportLayerAddress.data,
                                        RRC_MAX_IP_ADDR_LEN);
                            }

                        }
                        else
                        {
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_WARNING,
                                    "[UECC_LLIM_ADD_LC_REQ] "
                                    "transportLayerAddress has invalid size");
                            /*unset the bitmask */
                            p_setup_sap_req->tunnel_info[1].bitmask &=
                                ~RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                            //error
                        }
                        /* SPR 15627 FIX End*/
                    }

                    /* qos_profile */
                    p_setup_sap_req->qos_profile.allocation_retention_priority = 
                        p_erab_ctx->drb_config.s1u_config.qos_profile.
                        allocation_retention_priority;
                    p_setup_sap_req->qos_profile.qos_profile_data_length= 
                        p_erab_ctx->drb_config.s1u_config.qos_profile.
                        qos_profile_data_size;
                    l3_memcpy_wrapper(p_setup_sap_req->qos_profile.qos_profile_data,
                            p_erab_ctx->drb_config.s1u_config.qos_profile.
                            qos_profile_data,p_erab_ctx->drb_config.s1u_config.
                            qos_profile.qos_profile_data_size);

                    if ((PNULL != p_uecc_ue_context->ho_info.p_ho_info->
                                p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required) &&
                            ((HANDOVER_TYPE_LTE_TO_UTRAN == p_uecc_ue_context->ho_info.p_ho_info->\
                              p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type) ||
                             (HANDOVER_TYPE_LTE_TO_GERAN == p_uecc_ue_context->ho_info.p_ho_info->\
                              p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type) ||
                             (HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT == p_uecc_ue_context->ho_info.p_ho_info->\
                              p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type) || 
                             (HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD == p_uecc_ue_context->ho_info.p_ho_info->\
                              p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type) || 
                             (HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD == p_uecc_ue_context->ho_info.p_ho_info->\
                              p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type))) 

                    {
                        p_setup_sap_req->bitmask |= RRC_UECC_LLIM_S1U_PDCP_EXT_FLAG_PRESENT;
                        p_setup_sap_req->pdcp_ext.pdcp_ext_flag =  S1U_PDCP_EXT_DISABLE;
                    }            

                    req_count ++;
                }
            }
        }
    }
    else if ((X2_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover) ||
            (INTER_CELL_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover))
    {

        req_count = 0;

        for(i = 0; i < MAX_ERAB_COUNT ; i++ )
        {
            if( PNULL != p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info
                    ->s1_src_ho_info.src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[i])
            {
                if ( UECC_FORWARDING_DIRECTION_ABSENT != p_uecc_ue_context->ho_info.p_ho_info->
                        p_src_ho_info->s1_src_ho_info.src_erab_admitted_list.
                        erab_ho_src_drb_admitted_info[i]->forward_direction )
                {
                    if ( req_count < RRC_S1U_MAX_NUM_LC) 

                    {
                        /* increment num_setup_sap_req */
                        rrc_uecc_llim_s1u_reconfigure_req.setup_sap_req_list.
                            num_setup_sap_req++; 


                        p_setup_sap_req 
                            = &(rrc_uecc_llim_s1u_reconfigure_req.setup_sap_req_list.
                                    setup_sap_req[req_count]);

                        p_uecc_ho_src_drb_admitted_info 
                            = p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info
                            ->s1_src_ho_info.src_erab_admitted_list.
                            erab_ho_src_drb_admitted_info[i]; 

                        p_erab_ctx = p_uecc_ue_context->p_e_rab_list[i];
                        if(!p_erab_ctx)
                        {
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_INFO, "erab_context corresponding to "
                                    " erab id [%d] is missing ",i);
                            continue;
                        }

                        /* bitmask */
                        p_setup_sap_req->bitmask = 0;

                        /* lc_id */
                        p_setup_sap_req->lc_id = p_erab_ctx->drb_config.
                            logical_channel_identity; 

                        /* qos_id */
                        p_setup_sap_req->qos_id = p_erab_ctx->drb_config.s1u_config.qos_id;

                        /* tunnel_count */
                        p_setup_sap_req->tunnel_count = 1 ;
                        /* tunnel_info */
                        if ((UECC_FORWARDING_DIRECTION_DL== 
                                    p_uecc_ho_src_drb_admitted_info->forward_direction)
                                || (UECC_FORWARDING_DIRECTION_BOTH ==  
                                    p_uecc_ho_src_drb_admitted_info->forward_direction))
                        {
                            /* HO Integration Fix.*/
                            p_setup_sap_req->tunnel_info[0].sap_flag =
                                RRC_S1U_RECONFIG_UE_DL_FORWARDING_TUNNEL_SAP_FLAG;

                            rrc_unpack_U32((U8*)&(p_setup_sap_req->tunnel_info[0].teid_peer),
                                    p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.teid_peer.data);

                            p_setup_sap_req->tunnel_info[0].bitmask |=
                                RRC_UECC_LLIM_S1U_TUNNEL_INFO_TEID_PEER_PRESENT;

                            /* SPR 15627 FIX Start*/
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_DETAILED,
                                    "[UECC_LLIM_ADD_LC_REQ] "
                                    "transportLayerAddress length =%d", p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits);

                            /* IPV6  or IPV4 */
                            if ((RRC_MAX_IP_ADDR_LEN_IPV6*8 
                                        == p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits)
                                    || (RRC_MAX_IP_ADDR_LEN*8 
                                        == p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits)
                               )
                            {
                                p_setup_sap_req->tunnel_info[0].bitmask |=
                                    RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;

                                p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                                    (U8)(p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits/8);

                                l3_memcpy_wrapper(
                                        p_setup_sap_req->tunnel_info[0]
                                        .transport_addr.data,
                                        p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.data,
                                        p_setup_sap_req->tunnel_info[0].transport_addr.data_length);

                            }
                            /*IPV4 and IPV6 160 bit*/
                            else if((RRC_MAX_IP_ADDR_LEN*8 + RRC_MAX_IP_ADDR_LEN_IPV6*8)
                                    == p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits)  
                            {
                                p_setup_sap_req->tunnel_info[0].bitmask |=
                                    RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                                /* set IPV6 or IPV4 as per active mme info*/
                                /*
                                 * if both IPv4 and IPv6 addresses are signaled, 
                                 * then IPv4 address is contained in the first 32 bits
                                 */
                                if(p_uecc_ue_context->p_gb_context->mme_ctx[p_uecc_ue_context->mme_id].connection_info.bitmask
                                        & MME_COMM_INFO_IPV6_ADDR_PRESENT) /*IPV6 */
                                {
                                    /*extract ipv6 from transportLayerAddress*/
                                    p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                                        RRC_MAX_IP_ADDR_LEN_IPV6;

                                    l3_memcpy_wrapper(
                                            p_setup_sap_req->tunnel_info[0]
                                            .transport_addr.data,
                                            (U8*)(p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.data)+ RRC_MAX_IP_ADDR_LEN ,
                                            RRC_MAX_IP_ADDR_LEN_IPV6);
                                }
                                else /*fill IPV4*/
                                {
                                    p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                                        RRC_MAX_IP_ADDR_LEN;

                                    l3_memcpy_wrapper(
                                            p_setup_sap_req->tunnel_info[0]
                                            .transport_addr.data,
                                            p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.data,
                                            RRC_MAX_IP_ADDR_LEN);
                                }

                            }
                            else
                            {
                                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                        (p_uecc_ue_context->p_gb_context)->facility_name,
                                        RRC_WARNING,
                                        "[UECC_LLIM_ADD_LC_REQ] "
                                        "transportLayerAddress has invalid size");
                                /*unset the bitmask */
                                p_setup_sap_req->tunnel_info[0].bitmask &=
                                    ~RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                                //error
                            }
                            /* SPR 15627 FIX End*/

                            if (UECC_FORWARDING_DIRECTION_BOTH 
                                    == p_uecc_ho_src_drb_admitted_info->forward_direction ) 
                            {
                                p_setup_sap_req->tunnel_count = 2 ;
                                p_setup_sap_req->tunnel_info[1].sap_flag =
                                    RRC_S1U_RECONFIG_UE_UL_FORWARDING_TUNNEL_SAP_FLAG;

                                rrc_unpack_U32((U8*)&p_setup_sap_req->tunnel_info[1].teid_peer,
                                        p_uecc_ho_src_drb_admitted_info->ul_gtp_tunnel_end_point.teid_peer.data);

                                p_setup_sap_req->tunnel_info[1].bitmask |=
                                    RRC_UECC_LLIM_S1U_TUNNEL_INFO_TEID_PEER_PRESENT;

                                /* SPR 15627 FIX Start*/
                                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                        (p_uecc_ue_context->p_gb_context)->facility_name,
                                        RRC_DETAILED,
                                        "[UECC_LLIM_ADD_LC_REQ] "
                                        "transportLayerAddress length =%d", p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits);

                                /* IPV6  or IPV4 */
                                if ((RRC_MAX_IP_ADDR_LEN_IPV6*8 
                                            == p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits)
                                        || (RRC_MAX_IP_ADDR_LEN*8 
                                            == p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits)
                                   )
                                {
                                    p_setup_sap_req->tunnel_info[1].bitmask |=
                                        RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;

                                    p_setup_sap_req->tunnel_info[1].transport_addr.data_length =
                                        (U8)(p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits/8);

                                    l3_memcpy_wrapper(
                                            p_setup_sap_req->tunnel_info[1]
                                            .transport_addr.data,
                                            p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.data,
                                            p_setup_sap_req->tunnel_info[1].transport_addr.data_length);

                                }
                                /*IPV4 and IPV6 160 bit*/
                                else if((RRC_MAX_IP_ADDR_LEN*8 + RRC_MAX_IP_ADDR_LEN_IPV6*8)
                                        == p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits)  
                                {
                                    p_setup_sap_req->tunnel_info[1].bitmask |=
                                        RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                                    /* set IPV6 or IPV4 as per active mme info*/
                                    /*
                                     * if both IPv4 and IPv6 addresses are signaled, 
                                     * then IPv4 address is contained in the first 32 bits
                                     */
                                    if(p_uecc_ue_context->p_gb_context->mme_ctx[p_uecc_ue_context->mme_id].connection_info.bitmask
                                            & MME_COMM_INFO_IPV6_ADDR_PRESENT) /*IPV6 */
                                    {
                                        /*extract ipv6 from transportLayerAddress*/
                                        p_setup_sap_req->tunnel_info[1].transport_addr.data_length =
                                            RRC_MAX_IP_ADDR_LEN_IPV6;

                                        l3_memcpy_wrapper(
                                                p_setup_sap_req->tunnel_info[1]
                                                .transport_addr.data,
                                                (U8*)(p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.data)+ RRC_MAX_IP_ADDR_LEN ,
                                                RRC_MAX_IP_ADDR_LEN_IPV6);
                                    }
                                    else /*fill IPV4*/
                                    {
                                        p_setup_sap_req->tunnel_info[1].transport_addr.data_length =
                                            RRC_MAX_IP_ADDR_LEN;

                                        l3_memcpy_wrapper(
                                                p_setup_sap_req->tunnel_info[1]
                                                .transport_addr.data,
                                                p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.data,
                                                RRC_MAX_IP_ADDR_LEN);
                                    }

                                }
                                else
                                {
                                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                            (p_uecc_ue_context->p_gb_context)->facility_name,
                                            RRC_WARNING,
                                            "[UECC_LLIM_ADD_LC_REQ] "
                                            "transportLayerAddress has invalid size");
                                    /*unset the bitmask */
                                    p_setup_sap_req->tunnel_info[1].bitmask &=
                                        ~RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                                    //error
                                }
                                /* SPR 15627 FIX End*/
                            }

                        }
                        else if(UECC_FORWARDING_DIRECTION_UL == 
                                p_uecc_ho_src_drb_admitted_info->forward_direction )
                        {
                            p_setup_sap_req->tunnel_info[0].sap_flag =
                                RRC_S1U_RECONFIG_UE_UL_FORWARDING_TUNNEL_SAP_FLAG;

                            rrc_unpack_U32((U8*)&p_setup_sap_req->tunnel_info[0].teid_peer,
                                    p_uecc_ho_src_drb_admitted_info->ul_gtp_tunnel_end_point.teid_peer.data);

                            p_setup_sap_req->tunnel_info[0].bitmask |=
                                RRC_UECC_LLIM_S1U_TUNNEL_INFO_TEID_PEER_PRESENT;

                            /* SPR 15627 FIX Start*/
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_DETAILED,
                                    "[UECC_LLIM_ADD_LC_REQ] "
                                    "transportLayerAddress length =%d", p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits);

                            /* IPV6  or IPV4 */
                            if ((RRC_MAX_IP_ADDR_LEN_IPV6*8 
                                        == p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits)
                                    || (RRC_MAX_IP_ADDR_LEN*8 
                                        == p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits)
                               )
                            {
                                p_setup_sap_req->tunnel_info[0].bitmask |=
                                    RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;

                                p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                                    (U8)(p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits/8);

                                l3_memcpy_wrapper(
                                        p_setup_sap_req->tunnel_info[0]
                                        .transport_addr.data,
                                        p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.data,
                                        p_setup_sap_req->tunnel_info[0].transport_addr.data_length);

                            }
                            /*IPV4 and IPV6 160 bit*/
                            else if((RRC_MAX_IP_ADDR_LEN*8 + RRC_MAX_IP_ADDR_LEN_IPV6*8)
                                    == p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.numbits)  
                            {
                                p_setup_sap_req->tunnel_info[0].bitmask |=
                                    RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                                /* set IPV6 or IPV4 as per active mme info*/
                                /*
                                 * if both IPv4 and IPv6 addresses are signaled, 
                                 * then IPv4 address is contained in the first 32 bits
                                 */
                                if(p_uecc_ue_context->p_gb_context->mme_ctx[p_uecc_ue_context->mme_id].connection_info.bitmask
                                        & MME_COMM_INFO_IPV6_ADDR_PRESENT) /*IPV6 */
                                {
                                    /*extract ipv6 from transportLayerAddress*/
                                    p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                                        RRC_MAX_IP_ADDR_LEN_IPV6;

                                    l3_memcpy_wrapper(
                                            p_setup_sap_req->tunnel_info[0]
                                            .transport_addr.data,
                                            (U8*)(p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.data)+ RRC_MAX_IP_ADDR_LEN ,
                                            RRC_MAX_IP_ADDR_LEN_IPV6);
                                }
                                else /*fill IPV4*/
                                {
                                    p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                                        RRC_MAX_IP_ADDR_LEN;

                                    l3_memcpy_wrapper(
                                            p_setup_sap_req->tunnel_info[0]
                                            .transport_addr.data,
                                            p_uecc_ho_src_drb_admitted_info->dl_gtp_tunnel_end_point.transportLayerAddress.data,
                                            RRC_MAX_IP_ADDR_LEN);
                                }

                            }
                            else
                            {
                                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                        (p_uecc_ue_context->p_gb_context)->facility_name,
                                        RRC_WARNING,
                                        "[UECC_LLIM_ADD_LC_REQ] "
                                        "transportLayerAddress has invalid size");
                                /*unset the bitmask */
                                p_setup_sap_req->tunnel_info[0].bitmask &=
                                    ~RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                                //error
                            }
                            /* SPR 15627 FIX End*/

                        }


                        /* qos_profile */
                        p_setup_sap_req->qos_profile.allocation_retention_priority = 
                            p_erab_ctx->drb_config.s1u_config.qos_profile.
                            allocation_retention_priority;
                        p_setup_sap_req->qos_profile.qos_profile_data_length= 
                            p_erab_ctx->drb_config.s1u_config.qos_profile.
                            qos_profile_data_size;
                        l3_memcpy_wrapper(p_setup_sap_req->qos_profile.qos_profile_data,
                                p_erab_ctx->drb_config.s1u_config.qos_profile.
                                qos_profile_data,p_erab_ctx->drb_config.s1u_config.
                                qos_profile.qos_profile_data_size);
                        req_count ++;
                    }
                }
            }
        }
        /* Updating forwarding DRB count in ue_context */
        p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info->
            s1_src_ho_info.src_erab_admitted_list.drb_fwd_count = 
            (U8)rrc_uecc_llim_s1u_reconfigure_req.setup_sap_req_list.
            num_setup_sap_req;
    }
#ifdef ENDC_ENABLED
    /*OPTION3X Changes Start*/
    /* Check if the current procedure is DC_BEARER_CHANGE_PROC intiated
     * by RRM */

    else if( (PNULL != p_uecc_ue_context->p_curr_proc_data) &&
            UECC_RRM_DC_BEARER_CHANGE_PROC ==
            p_uecc_ue_context->p_curr_proc_data->t)
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_DETAILED,
                "[UECC_LLIM_S1U_RECONFIGURE_REQ] "
                "UECC_RRM_DC_BEARER_CHANGE_PROC request is received");
        /*Logical_Error*/
       rrc_uecc_llim_s1u_reconfigure_req.bitmask = 0; 
        /*Logical_Error*/
        result = uecc_llim_build_s1u_reconfig_req_for_dc_bearer_change
                (&rrc_uecc_llim_s1u_reconfigure_req.setup_sap_req_list,
                &rrc_uecc_llim_s1u_reconfigure_req.bitmask,
                 p_uecc_ue_context);

        if(RRC_FAILURE == result)
        {    
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_S1U_RECONFIGURE_REQ] "
                "Failed in building S1U RECONFIG REQ");
    
            RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
            return result;
        }
    }
    else
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_S1U_RECONFIGURE_REQ] "
                "Invalid reconfig received");
    }
    /*OPTION3X Changes Stop*/
#endif

    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_S1U_RECONFIGURE_REQ,
            sizeof(rrc_uecc_llim_s1u_reconfigure_req_t),
            &rrc_uecc_llim_s1u_reconfigure_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}
/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_s1u_delete_forwarding_tunnel_req 
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:    This is the function for building and sending
 *                   UECC_LLIM_S1U_RECONFIG_REQ to delete forwarding tunnels 
 *                   message to the LLIM.
 ****************************************************************************/

rrc_return_t uecc_llim_build_and_send_s1u_delete_forwarding_tunnel_req(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_uecc_llim_s1u_reconfigure_req_t rrc_uecc_llim_s1u_reconfigure_req;
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ho_src_drb_forward_info_t *p_uecc_ho_src_drb_forward_info = PNULL;
    uecc_ho_src_drb_admitted_info_t *p_uecc_ho_src_drb_admitted_info = PNULL;
    uecc_drb_ctx_t      *p_erab_ctx = PNULL;
    rrc_counter_t i =0;
    rrc_uecc_llim_s1u_rel_sap_req_t   *p_rel_sap_req = PNULL;
    U8 teid_count  = RRC_NULL;
    U8 rel_req_count = RRC_NULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    memset_wrapper(&rrc_uecc_llim_s1u_reconfigure_req, 0, 
            sizeof(rrc_uecc_llim_s1u_reconfigure_req_t));

    /* ue_index */
    rrc_uecc_llim_s1u_reconfigure_req.ue_index =  p_uecc_ue_context->ue_index;
    rrc_uecc_llim_s1u_reconfigure_req.cell_index =  p_uecc_ue_context->cell_index;

    /* Transaction ID */
    rrc_uecc_llim_s1u_reconfigure_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    /* bitmask */
    rrc_uecc_llim_s1u_reconfigure_req.bitmask |=
        RRC_UECC_LLIM_S1U_REL_SAP_REQ_LIST_PRESENT;

    if ( S1_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover)
    {
        /* num_rel_sap_req */
        rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
            num_rel_sap_req = 
            p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info
            ->s1_src_ho_info.src_drb_fwd_list.count;

        for(i = 0; i < MAX_ERAB_COUNT ; i++ )
        {
            if( PNULL != p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info
                    ->s1_src_ho_info.src_drb_fwd_list.
                    erab_ho_src_drb_forward_list[i] &&
                    (RRC_S1U_MAX_NUM_LC > rel_req_count))
            {
                p_rel_sap_req = &(rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
                        rel_sap_req[rel_req_count++]);

                p_uecc_ho_src_drb_forward_info 
                    = p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info
                    ->s1_src_ho_info.src_drb_fwd_list.
                    erab_ho_src_drb_forward_list[i]; 

                p_erab_ctx = p_uecc_ue_context->p_e_rab_list[i];

                /* lc_id */
                p_rel_sap_req->lc_id = p_erab_ctx->drb_config.
                    logical_channel_identity; 

                /* tunnel_count */
                p_rel_sap_req->tunnel_count = p_uecc_ho_src_drb_forward_info->teid_count;


                /* Copy TE-ID received from S1U in S1U RECONFIG CNF */
                for (teid_count = 0;
                        ((teid_count < p_rel_sap_req->tunnel_count) &&
                         (RRC_S1U_MAX_TUNNELS_PER_LC  > teid_count));
                        teid_count++)
                {
                    p_rel_sap_req->release_tunnel_info[teid_count].teid_self =
                        p_uecc_ho_src_drb_forward_info->s1u_fwd_teid[teid_count];
                }
            }
        }
    }
    else if ((X2_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover) ||
            (INTER_CELL_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover))
    {
        /* num_rel_sap_req */
        rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
            num_rel_sap_req = 
            p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info
            ->s1_src_ho_info.src_erab_admitted_list.count;

        for(i = 0; i < MAX_ERAB_COUNT ; i++ )
        {
            if( PNULL != p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info
                    ->s1_src_ho_info.src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[i] &&
                    (RRC_S1U_MAX_NUM_LC > rel_req_count))
            {
                p_rel_sap_req = &(rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
                        rel_sap_req[rel_req_count++]);

                p_uecc_ho_src_drb_admitted_info 
                    = p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info
                    ->s1_src_ho_info.src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[i]; 

                p_erab_ctx = p_uecc_ue_context->p_e_rab_list[i];

                /* lc_id */
                p_rel_sap_req->lc_id = p_erab_ctx->drb_config.
                    logical_channel_identity; 

                /* tunnel_count */
                p_rel_sap_req->tunnel_count = p_uecc_ho_src_drb_admitted_info->teid_count;


                /* Copy TE-ID received from S1U in S1U RECONFIG CNF */
                for (teid_count = 0;
                        ((teid_count < p_rel_sap_req->tunnel_count) &&
                         (RRC_S1U_MAX_TUNNELS_PER_LC  > teid_count));
                        teid_count++)
                {
                    p_rel_sap_req->release_tunnel_info[teid_count].teid_self =
                        p_uecc_ho_src_drb_admitted_info->s1u_fwd_teid[teid_count];
                }
            }
        }
    }
    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_S1U_RECONFIGURE_REQ,
            sizeof(rrc_uecc_llim_s1u_reconfigure_req_t),
            &rrc_uecc_llim_s1u_reconfigure_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_stop_data_buffer_ind
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:    This is the function for building and sending
 *                   UECC_LLIM_DATA_BUFFER_STOP_IND message to the LLIM.
 ****************************************************************************/

rrc_return_t uecc_llim_build_and_send_stop_data_buffer_ind(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_uecc_llim_data_buffer_stop_ind_t rrc_uecc_llim_data_buffer_stop_ind;
    rrc_return_et                   result = RRC_FAILURE;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    memset_wrapper(&rrc_uecc_llim_data_buffer_stop_ind, 0,
            sizeof(rrc_uecc_llim_data_buffer_stop_ind_t));


    rrc_uecc_llim_data_buffer_stop_ind.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
    /* ue_index */
    rrc_uecc_llim_data_buffer_stop_ind.ue_index =  p_uecc_ue_context->ue_index;
    rrc_uecc_llim_data_buffer_stop_ind.cell_index =  p_uecc_ue_context->cell_index;

    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_DATA_BUFFER_STOP_IND,
            sizeof(rrc_uecc_llim_data_buffer_stop_ind_t),
            &rrc_uecc_llim_data_buffer_stop_ind);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: 
 *                uecc_llim_build_and_send_rrc_connection_reestablishment_reject
 *   INPUTS      :  uecc_gb_context_t*  p_uecc_gb_context
 *                  rrc_rnti_t          rnti
 *                  U32                 reestablishmentCause
 *                  rrc_cell_index_t    cell_index
 *                  rrc_module_id_t     dst_module_id
 *   OUTPUTS     : None
 *   DESCRIPTION:
 *       This function builds and sends RRC connection reestablishment reject
 *       message to LLIM module within 
 *       UECC_LLIM_UE_CON_RE_ESTABLISH_REJ_REQ message.
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_rrc_connection_reestablishment_reject 
(
 uecc_gb_context_t*  p_uecc_gb_context,
 rrc_rnti_t          rnti,        /* UE rnti */
 U32                 reestablishmentCause,
 rrc_cell_index_t    cell_index,
 rrc_module_id_t     dst_module_id
 )
{
    U8  msg[sizeof(rrc_uecc_llim_con_re_establish_rej_req_t)+UECC_MAX_ASN1_BUF_LEN];
    rrc_uecc_llim_con_re_establish_rej_req_t*  
        p_llim_con_re_establish_rej_req = PNULL;
    OSCTXT                                      asn1_ctx;
    DL_CCCH_Message                             dl_ccch_msg;
    DL_CCCH_MessageType_c1*                     p_dl_ccch_c1 = PNULL;
    RRCConnectionReestablishmentReject_r8_IEs*  
        p_rrc_con_reestablishment_reject_r8_ies = PNULL;

    rrc_return_et                               response = RRC_FAILURE;
    EVENT_EXTERNAL_HEADER                       *p_event_header = PNULL;
    U32                                         encoded_msg_len = 0;
    LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT *p_event_rrc_protocol_err = PNULL;
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    /* Init ASN1 context */
    if ( RT_OK != rtInitContext(&asn1_ctx) )
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "[RRCConnectionReestablishmentReject]"
                " ASN context initialization failed.");
        return RRC_FAILURE;
    }

    do {
        /* Fill the values in the ASN structures that shall be encoded
         * by ASN Encoder */
        /* Set Downlink CCCH message type */
        asn1Init_DL_CCCH_MessageType(&(dl_ccch_msg.message));

        dl_ccch_msg.message.t = T_DL_CCCH_MessageType_c1;

        /* Allocate and choose RRCConnectionReject */
        p_dl_ccch_c1 = rtxMemAllocType(&asn1_ctx, DL_CCCH_MessageType_c1);
        if (PNULL == p_dl_ccch_c1)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReestablishmentReject] ASN malloc failed.");
            break;
        }

        /* Intialize */
        asn1Init_DL_CCCH_MessageType_c1(p_dl_ccch_c1);
        dl_ccch_msg.message.u.c1 = p_dl_ccch_c1;

        p_dl_ccch_c1->t = 
            T_DL_CCCH_MessageType_c1_rrcConnectionReestablishmentReject;
        p_dl_ccch_c1->u.rrcConnectionReestablishmentReject =
            rtxMemAllocType(&asn1_ctx, RRCConnectionReestablishmentReject);
        if (PNULL == p_dl_ccch_c1->u.rrcConnectionReestablishmentReject)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReestablishmentReject] ASN malloc failed.");
            break;
        }

        asn1Init_RRCConnectionReestablishmentReject
            (p_dl_ccch_c1->u.rrcConnectionReestablishmentReject);

        p_dl_ccch_c1->u.rrcConnectionReestablishmentReject->criticalExtensions.t =
            T_RRCConnectionReestablishmentReject_criticalExtensions_rrcConnectionReestablishmentReject_r8;
        p_rrc_con_reestablishment_reject_r8_ies = rtxMemAllocType(&asn1_ctx,
                RRCConnectionReestablishmentReject_r8_IEs);
        if (PNULL == p_rrc_con_reestablishment_reject_r8_ies)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReestablishmentReject] ASN malloc failed.");
            break;
        }
        asn1Init_RRCConnectionReestablishmentReject_r8_IEs(
                p_rrc_con_reestablishment_reject_r8_ies);

        p_dl_ccch_c1->u.rrcConnectionReestablishmentReject->criticalExtensions.u.
            rrcConnectionReestablishmentReject_r8 = 
            p_rrc_con_reestablishment_reject_r8_ies;


        /* Prepare pointer on RRC internal message */
        p_llim_con_re_establish_rej_req = (rrc_uecc_llim_con_re_establish_rej_req_t*)msg;

        /* ASN Encode message */
        pu_setBuffer(&asn1_ctx, p_llim_con_re_establish_rej_req->data_buffer,
                UECC_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);

        if (RT_OK != asn1PE_DL_CCCH_Message(&asn1_ctx, &dl_ccch_msg))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReestablishmentReject] ASN1 encoding failed.");

            /*Generating Protocol Event LOCAL_EVENT_RRC_PROTOCOL_ERROR*/
            p_event_rrc_protocol_err = rrc_mem_get(sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));
            if (PNULL != p_event_rrc_protocol_err)
            {
                memset_wrapper(p_event_rrc_protocol_err, RRC_NULL, 
                        sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));

                p_event_rrc_protocol_err->header.length = 
                    sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT);
                p_event_rrc_protocol_err->header.event_id = LOCAL_EVENT_RRC_PROTOCOL_ERROR;

                l3_strncpy_wrapper((S8 *)(p_event_rrc_protocol_err->EVENT_PARAM_RRC_MESSAGE_DISCARDED),
                        (const S8 *)"RRC CONNECTION REESTABLISHMENT REJECT", RRC_MESSAGE_DISCARDED_SIZE);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_rrc_protocol_err);
            }
            break;
        }
        else
        {
            /*Generating Protocol Event LOCAL_RRC_CONNECTION_RE_ESTABLISHMENT_REJECT*/
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_DL_CCCH_Message(RRC_ASN, "DL_CCCH_Message",
                    &dl_ccch_msg, "RRCConnectionReestablishmentReject",
                    p_llim_con_re_establish_rej_req->data_buffer,
                    encoded_msg_len);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL == p_event_header)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_FATAL, "Memory Allocation Failed ");
                break;
            }
            memset_wrapper(p_event_header, RRC_NULL, (sizeof(EVENT_EXTERNAL_HEADER) +
                        encoded_msg_len));

            p_event_header->length = (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len);
            p_event_header->event_id = LOCAL_RRC_CONNECTION_RE_ESTABLISHMENT_REJECT;

            if ((PNULL != p_uecc_gb_context->p_p_csc_context) && (PNULL != p_uecc_gb_context->
                        p_p_csc_context[cell_index]) && (PNULL != p_uecc_gb_context->
                            p_p_csc_context[cell_index]->p_csc_init_setup_ind))
            {
                l3_memcpy_wrapper(&p_event_header->EVENT_PARAM_CELL_ID, p_uecc_gb_context->
                        p_p_csc_context[cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                        cell_access_related_info.cell_Id, sizeof(U32));
            }

            p_event_header->EVENT_PARAM_EUTRANCELL_FROID = p_event_header->
                EVENT_PARAM_CELL_ID;
            p_event_header->EVENT_PARAM_MESSAGE_DIRECTION = MESSAGE_DIRECTION_SEND;
            p_event_header->EVENT_PARAM_L3MESSAGE_LENGTH = (p_event_header->length - 
                    (sizeof(EVENT_EXTERNAL_HEADER)));

            l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                        sizeof(EVENT_EXTERNAL_HEADER)),
                    (const void*)p_llim_con_re_establish_rej_req->data_buffer,
                    encoded_msg_len);

            rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
        }
        p_llim_con_re_establish_rej_req->data_buffer_length = 
            (rrc_counter_t)pe_GetMsgLen(&asn1_ctx);
        p_llim_con_re_establish_rej_req->crnti = rnti;
        p_llim_con_re_establish_rej_req->cell_index = cell_index;
        /* Send message to LLIM  */
        response = uecc_rrc_send_internal_msg(
                dst_module_id,
                UECC_LLIM_UE_CON_RE_ESTABLISH_REJ_REQ,
                (U16)(sizeof(rrc_uecc_llim_con_re_establish_rej_req_t) +
                    p_llim_con_re_establish_rej_req->data_buffer_length),
                msg);

        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "RRC_MSG: RRCConnectionReestablishmentReject %s",
                change_data_to_str(p_llim_con_re_establish_rej_req->data_buffer_length, p_llim_con_re_establish_rej_req->data_buffer));
    } while (0);

    /* Free ASN1 context */
    rtFreeContext(&asn1_ctx);
    if (PNULL != g_rrc_stats.p_rrc_stats) 
        /* Update the performace counter */
    {
        RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_gb_context ,
                g_rrc_stats.p_rrc_stats->
                rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_gb_context->offset_uecc_mod_id].
                rrc_uecc_cell_stats[cell_index].rrc_connection_related_stats.
                rrc_connection_reestablishment.
                rrc_connReEstabFail_cause[reestablishmentCause],
                reestablishmentCause, (RRC_REESTABLISHMENT_CAUSE_INDEX-1));

        RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_gb_context ,
                g_rrc_stats.p_rrc_stats->
                rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_gb_context->offset_uecc_mod_id].
                rrc_uecc_cell_stats[cell_index].rrc_connection_related_stats.
                rrc_connection_reestablishment.
                rrc_connReEstabFail_sum, reestablishmentCause,
                (RRC_REESTABLISHMENT_CAUSE_INDEX-1));
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return response;
}

/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_rrc_connnection_reestablishment
 * Inputs         : uecc_ue_context_t*  p_uecc_ue_context
 * Outputs        : None
 * Description    : This is the function for building and sending messages from
 *                : the UECC to LLIM
 * Returns        : rrc_return_et
 ****************************************************************************/
rrc_return_et uecc_llim_build_and_send_rrc_connection_reestablishment(
        uecc_ue_context_t*  p_uecc_ue_context
        )
{
    OSCTXT                                      asn1_ctx;
    DL_CCCH_Message                             dl_ccch_msg;
    rrc_return_et                               result = RRC_FAILURE;

    rrc_uecc_llim_ccch_data_req_t               *p_ccch_data_req = PNULL;
    U8  msg[sizeof(rrc_uecc_llim_ccch_data_req_t)+UECC_MAX_ASN1_BUF_LEN];
    EVENT_EXTERNAL_HEADER                       *p_event_header = PNULL;
    U32                                         encoded_msg_len = 0;
    LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT *p_event_rrc_protocol_err = PNULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Init ASN1 context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[RRCConnectionReestablishment] ASN1 context initialization failed.");
        return RRC_FAILURE;
    }

    do
    {
        /* Fill the values in the ASN structures that shall be encoded by
         * ASN Encoder */
        /* Downlink CCCH message type */
        dl_ccch_msg.message.t = T_DL_CCCH_MessageType_c1;
        dl_ccch_msg.message.u.c1 =
            rtxMemAllocType(&asn1_ctx, DL_CCCH_MessageType_c1);
        if (PNULL == dl_ccch_msg.message.u.c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReestablishment] ASN malloc failed.");
            break;
        }

        /* Choose RRCConnectionReestablishment */
        dl_ccch_msg.message.u.c1->t =
            T_DL_CCCH_MessageType_c1_rrcConnectionReestablishment;

        dl_ccch_msg.message.u.c1->u.rrcConnectionReestablishment =
            rtxMemAllocType(&asn1_ctx, RRCConnectionReestablishment);
        if (PNULL == dl_ccch_msg.message.u.c1->u.rrcConnectionReestablishment)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReestablishment] ASN malloc failed.");
            break;
        }

        /* Generate RRC Transaction Identifier */
        dl_ccch_msg.message.u.c1->u.rrcConnectionReestablishment->
            rrc_TransactionIdentifier =
            (RRC_TransactionIdentifier) (uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context) &
                    UECC_LTE_RRC_TRANSACTION_ID_MASK);

        /* critical extensions c1 */
        dl_ccch_msg.message.u.c1->u.rrcConnectionReestablishment->criticalExtensions.t =
            T_RRCConnectionReestablishment_criticalExtensions_c1;

        dl_ccch_msg.message.u.c1->u.rrcConnectionReestablishment->criticalExtensions.u.c1=
            rtxMemAllocType(&asn1_ctx,RRCConnectionReestablishment_criticalExtensions_c1);
        if (PNULL == dl_ccch_msg.message.u.c1->u.rrcConnectionReestablishment->
                criticalExtensions.u.c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReestablishment] ASN malloc failed.");
            break;
        }

        /* Choose RRCConnectionReestablishment_r8 */
        dl_ccch_msg.message.u.c1->u.rrcConnectionReestablishment->
            criticalExtensions.u.c1->t =
            T_RRCConnectionReestablishment_criticalExtensions_c1_rrcConnectionReestablishment_r8;

        /* RRCConnectionReestablishment_r8 Structure */
        dl_ccch_msg.message.u.c1->u.rrcConnectionReestablishment->
            criticalExtensions.u.c1->u.rrcConnectionReestablishment_r8 =
            rtxMemAllocType(&asn1_ctx, RRCConnectionReestablishment_r8_IEs);
        if (PNULL == dl_ccch_msg.message.u.c1->u.rrcConnectionReestablishment->
                criticalExtensions.u.c1->u.rrcConnectionReestablishment_r8)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,RRC_ERROR,
                    "[RRCConnectionReestablishment] ASN malloc failed.");
            break;
        }
        asn1Init_RRCConnectionReestablishment_r8_IEs(
                dl_ccch_msg.message.u.c1->u.rrcConnectionReestablishment->
                criticalExtensions.u.c1->u.rrcConnectionReestablishment_r8);

        /* Fill nextHopChainingCount parameter */
        dl_ccch_msg.message.u.c1->u.rrcConnectionReestablishment->
            criticalExtensions.u.c1->u.rrcConnectionReestablishment_r8->
            nextHopChainingCount = p_uecc_ue_context->ncc;  

        /* Fill RadioResourceConfigDedicated*/
        if (RRC_SUCCESS !=
                uecc_llim_build_reestablishment_asn1_radio_resource_cfg_dedicated(
                    p_uecc_ue_context,
                    &dl_ccch_msg.message.u.c1->u.rrcConnectionReestablishment->
                    criticalExtensions.u.c1->u.rrcConnectionReestablishment_r8->
                    radioResourceConfigDedicated,
                    &asn1_ctx))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReestablishment] Radio Resource Config Dedicated Failed .");
            break;
        }


        /* Prepare pointer on RRC internal message */
        p_ccch_data_req = (rrc_uecc_llim_ccch_data_req_t*)msg;

        /* Do ASN1 encode */
        pu_setBuffer(&asn1_ctx, p_ccch_data_req->data_buffer,
                UECC_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);

        if (RT_OK != asn1PE_DL_CCCH_Message(&asn1_ctx, &dl_ccch_msg))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[RRCConnectionReestablishment] ASN1 encoding failed.");

            /*Generating Protocol Event LOCAL_EVENT_RRC_PROTOCOL_ERROR*/
            p_event_rrc_protocol_err = rrc_mem_get(sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));
            if (PNULL != p_event_rrc_protocol_err)
            {
                memset_wrapper(p_event_rrc_protocol_err, RRC_NULL, 
                        sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT));

                p_event_rrc_protocol_err->header.length = 
                    sizeof(LOCAL_EVENT_RRC_PROTOCOL_ERROR_STRUCT);
                p_event_rrc_protocol_err->header.event_id = LOCAL_EVENT_RRC_PROTOCOL_ERROR;

                l3_strncpy_wrapper((S8 *)(p_event_rrc_protocol_err->EVENT_PARAM_RRC_MESSAGE_DISCARDED),
                        (const S8 *)"RRC CONNECTION REESTABLISHMENT", RRC_MESSAGE_DISCARDED_SIZE);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_rrc_protocol_err);
            }
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_DL_CCCH_Message(RRC_ASN,"DL_CCCH_Message",
                    &dl_ccch_msg, "RRCConnectionReestablishment",
                    p_ccch_data_req->data_buffer, encoded_msg_len);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                memset_wrapper(p_event_header, RRC_NULL, (sizeof(EVENT_EXTERNAL_HEADER) +
                            encoded_msg_len));
                rrc_uecc_fill_protocol_event_params(p_uecc_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_RRC_CONNECTION_RE_ESTABLISHMENT,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_ccch_data_req->data_buffer,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        p_ccch_data_req->data_buffer_length = (rrc_counter_t)pe_GetMsgLen(&asn1_ctx);
        p_ccch_data_req->rnti = p_uecc_ue_context->crnti;
        p_ccch_data_req->cell_index = p_uecc_ue_context->cell_index;

        /* trace_fix */
        /* SPR 16113 Start */
        uecc_rrc_ue_assoc_msg_max_trace_handler(p_uecc_ue_context, p_ccch_data_req->data_buffer, 
                p_ccch_data_req->data_buffer_length, "RRC Connection Reestablishment", RRC_DL_CCCH);
        /* SPR 16113 Stop */
        /* trace_fix */

        /* Send message to LLIM  */
        result = uecc_rrc_send_internal_msg(
                RRC_LLIM_MODULE_ID,
                UECC_LLIM_CCCH_DATA_REQ,
                (U16)( p_ccch_data_req->data_buffer_length +
                    sizeof(rrc_uecc_llim_ccch_data_req_t)),
                msg);

        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_INFO,
                "RRC_MSG: RRCConnectionReestablishment %s",
                change_data_to_str(p_ccch_data_req->data_buffer_length, p_ccch_data_req->data_buffer));

    } while(0);

    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}
/******************************************************************************
 *   FUNCTION NAME: 
 *       uecc_llim_build_ho_rrc_connection_reconfiguration
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *                  DL_DCCH_Message                         * p_dl_dcch_msg 
 *                  OSCTXT                                  * p_asn1_ctx
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       Builds HO command 
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et 
uecc_llim_build_ho_rrc_connection_reconfiguration(
        uecc_ue_context_t*  p_uecc_ue_context,
        DL_DCCH_Message                         * p_dl_dcch_msg,
        OSCTXT                                  * p_asn1_ctx
        )
{
    RRCConnectionReconfiguration*           p_rrc_conn_recfg = PNULL;
    RRCConnectionReconfiguration_r8_IEs*    p_r8             = PNULL;
    rrc_return_et                           result           = RRC_FAILURE;
    rrm_srb_info_t      srb_info;
    U8                  drb_count = 0;
    U8                  drb_idx = 0;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(p_dl_dcch_msg, 0, sizeof(DL_DCCH_Message));
    memset_wrapper(&srb_info, 0, sizeof(srb_info));


    do {
        if (RRC_SUCCESS ==  uecc_llim_build_dl_dcch_msg(
                    p_dl_dcch_msg,
                    p_asn1_ctx,
                    p_uecc_ue_context,
                    &p_rrc_conn_recfg))
        {

            p_r8 = 
                rtxMemAllocType(p_asn1_ctx, RRCConnectionReconfiguration_r8_IEs);
            if (PNULL == p_r8)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[RRCConnectionReconfiguration] ASN malloc failed.");
                break;
            }
            p_rrc_conn_recfg->criticalExtensions.u.c1->
                u.rrcConnectionReconfiguration_r8 = p_r8;
            asn1Init_RRCConnectionReconfiguration_r8_IEs(
                    p_r8);
            /*SPR 13469 Fix Start*/
            if (p_uecc_ue_context->m.full_config_present) 
            {
                if ((RRC_UE_REL_9 == p_uecc_ue_context->access_stratum_release) ||(RRC_UE_REL_10 == p_uecc_ue_context->access_stratum_release))
                {
                    p_r8->m.nonCriticalExtensionPresent = 1;
                    p_r8->nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
                    p_r8->nonCriticalExtension.nonCriticalExtension.m.fullConfig_r9Present = 1;
                }
                else
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,
                            "UE access_stratum_release not compatible for full config!!");

                }

                p_r8->nonCriticalExtension.nonCriticalExtension.fullConfig_r9 = true__4 ;
            }
            /*SPR 13469 Fix Stop*/
            p_r8->m.radioResourceConfigDedicatedPresent = 1;

            /* If this is case of target HO then SRB1 config,
               mobilityControlInfo and securityConfigHO are present */
            if (p_uecc_ue_context->ho_info.p_ho_info &&
                    p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info)
            {
                /* Use SRB1 configuration from UE context hear */
                srb_info.bitmask = RRM_SRB_INFO_SRB1_CONFIG_PRESENT;
                srb_info.srb1_config = p_uecc_ue_context->srb1_config;

                /*The field is mandatory present in case of handover 
                  within E-UTRA or to E-UTRA; otherwise the field is not present.*/
                if ( p_uecc_ue_context->ho_info.p_ho_info->ho_type == 
                        HANDOVER_TYPE_INTRA_LTE_S1 ||
                        p_uecc_ue_context->ho_info.s1_or_x2_handover ==
                        X2_HO ||
                        p_uecc_ue_context->ho_info.p_ho_info->
                        ho_type == HANDOVER_TYPE_UTRAN_TO_LTE ||
                        p_uecc_ue_context->ho_info.p_ho_info->
                        ho_type == HANDOVER_TYPE_GERAN_TO_LTE ||
                        /*BUG 604 changes start*/
                        p_uecc_ue_context->ho_info.s1_or_x2_handover ==
                        INTER_CELL_HO ||
                        p_uecc_ue_context->ho_info.s1_or_x2_handover ==
                        INTRA_CELL_HO)
                    /*BUG 604 changes stop*/
                {
                    /*MobilityControlInfo*/
                    p_r8->m.mobilityControlInfoPresent = 1;

                    if (RRC_FAILURE == uecc_llim_encode_mobilityControlInfo(
                                p_uecc_ue_context,
                                p_asn1_ctx,
                                &p_r8->mobilityControlInfo ))
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_WARNING,
                                "uecc_llim_encode_mobilityControlInfo failed.");
                        break;
                    }

                    /*SecurityConfigHO*/
                    p_r8->m.securityConfigHOPresent = 1;
                    if (p_uecc_ue_context->ho_info.p_ho_info->ho_type == 
                            HANDOVER_TYPE_INTRA_LTE_S1 ||
                            p_uecc_ue_context->ho_info.s1_or_x2_handover ==
                            X2_HO || 
                            p_uecc_ue_context->ho_info.s1_or_x2_handover ==
                            /*BUG 604 changes start*/
                            INTER_CELL_HO ||
                            p_uecc_ue_context->ho_info.s1_or_x2_handover ==
                            INTRA_CELL_HO)
                        /*BUG 604 changes stop*/
                    {
                        p_r8->securityConfigHO.handoverType.t = 
                            T_SecurityConfigHO_handoverType_intraLTE;

                        p_r8->securityConfigHO.handoverType.u.intraLTE
                            = (SecurityConfigHO_handoverType_intraLTE*)
                            rtxMemAllocType(p_asn1_ctx, 
                                    SecurityConfigHO_handoverType_intraLTE);

                        if (PNULL == p_r8->securityConfigHO.
                                handoverType.u.intraLTE)
                        {
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_ERROR,
                                    "[RRCConnectionReconfiguration] ASN "
                                    "malloc failed.");
                            break;
                        }

                        p_r8->securityConfigHO.handoverType.u.intraLTE->m.
                            securityAlgorithmConfigPresent = 1;

                        /*BUG 604 changes start*/
                        if ( (INTRA_CELL_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover) &&
                                (p_uecc_ue_context->ho_info.security_key_present) )
                        {
                            p_r8->securityConfigHO.handoverType.u.
                                intraLTE->keyChangeIndicator = RRC_TRUE;
                        }
                        else
                        {
                            p_r8->securityConfigHO.handoverType.u.
                                intraLTE->keyChangeIndicator = RRC_FALSE;
                        }
                        /*BUG 604 changes stop*/

                        p_r8->securityConfigHO.handoverType.u.intraLTE->
                            nextHopChainingCount = p_uecc_ue_context->nh_ncc_pair.ncc;

                        p_r8->securityConfigHO.handoverType.u.intraLTE->
                            securityAlgorithmConfig.cipheringAlgorithm =
                            p_uecc_ue_context->configure_ciphering.algorithm_id;

                        p_r8->securityConfigHO.handoverType.u.intraLTE->
                            securityAlgorithmConfig.integrityProtAlgorithm =
                            p_uecc_ue_context->configure_integrity_protection.
                            algorithm_id;
                    }
                    /* Changes for interRAT  HO */
                    else if((p_uecc_ue_context->ho_info.p_ho_info->ho_type ==
                                HANDOVER_TYPE_UTRAN_TO_LTE)||
                            (p_uecc_ue_context->ho_info.p_ho_info->ho_type ==
                             HANDOVER_TYPE_GERAN_TO_LTE))
                    {
                        p_r8->securityConfigHO.handoverType.t =
                            T_SecurityConfigHO_handoverType_interRAT;

                        p_r8->securityConfigHO.handoverType.u.interRAT =
                            (SecurityConfigHO_handoverType_interRAT *)
                            rtxMemAllocType(p_asn1_ctx,
                                    SecurityConfigHO_handoverType_interRAT);
                        if (PNULL == p_r8->securityConfigHO.
                                handoverType.u.interRAT)
                        {
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_ERROR,
                                    "[RRCConnectionReconfiguration] ASN "
                                    "malloc failed.");
                            break;
                        }
                        asn1Init_SecurityConfigHO_handoverType_interRAT(
                                p_r8->securityConfigHO.handoverType.u.interRAT);
                        p_r8->securityConfigHO.handoverType.u.interRAT->
                            securityAlgorithmConfig.cipheringAlgorithm =
                            p_uecc_ue_context->configure_ciphering.algorithm_id;
                        p_r8->securityConfigHO.handoverType.u.interRAT->
                            securityAlgorithmConfig.integrityProtAlgorithm =
                            p_uecc_ue_context->configure_integrity_protection.algorithm_id;

                        /* Fill nas_SecurityParamToEUTRA */
                        p_r8->securityConfigHO.handoverType.u.interRAT->
                            nas_SecurityParamToEUTRA.numocts = p_uecc_ue_context->
                            nas_security_eutra_numocts ;
                        l3_memcpy_wrapper(p_r8->securityConfigHO.handoverType.u.interRAT->
                                nas_SecurityParamToEUTRA.data,
                                p_uecc_ue_context->nas_security_eutra,
                                p_uecc_ue_context->nas_security_eutra_numocts);

                    }

                    else
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_INFO,
                                "Invalid HO_Type!!");
                    }
                }
            }

            /* SRB 2 INFO */
            if (p_uecc_ue_context->m.srb2_config_present && 
                    p_uecc_ue_context->m.srb2_config_updated)
            {    
                srb_info.bitmask |= RRM_SRB_INFO_SRB2_CONFIG_PRESENT;
                srb_info.srb2_config = p_uecc_ue_context->srb2_config;
            }
            /* Fill RadioResourceConfigDedicated*/
            if (RRC_SUCCESS != 
                    uecc_llim_build_ics_asn1_radio_resource_cfg_dedicated(
                        p_uecc_ue_context,
                        &p_r8->radioResourceConfigDedicated,
                        &srb_info,
                        p_asn1_ctx))
            {
                break;
            }
            else
            {

                if ( ( PNULL != p_uecc_ue_context->ho_info.p_ho_info ) &&
                        ( PNULL != 
                          p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info ) &&
                        ( p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                          s1_trg_ho_info.erab_failed_list.count > 0 ))
                {
                    asn1Init_DRB_ToReleaseList(&p_r8->radioResourceConfigDedicated.drb_ToReleaseList);
                    drb_count = p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                        s1_trg_ho_info.erab_failed_list.count;

                    if ( drb_count > MAX_ERAB_COUNT )
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_ERROR,
                                "generate_drb_release_info_list: invalid"
                                " drb_count=%i",
                                drb_count);
                        return RRC_FAILURE;
                    }

                    p_r8->radioResourceConfigDedicated.drb_ToReleaseList.n =
                        RRC_NULL;
                    for (drb_idx = 0; drb_idx < drb_count &&
                            drb_idx < RRC_MAX_NUM_DRB; drb_idx++)
                    {
                        /*SPR 15086 Fix Start */
                        if (RRC_NULL != p_uecc_ue_context->ho_info.p_ho_info->
                                p_trg_ho_info->s1_trg_ho_info.erab_failed_list.
                                e_rab_failed_to_add_list[drb_idx].drb_id)
                        {
                            p_r8->radioResourceConfigDedicated.drb_ToReleaseList.
                                elem[drb_idx] = p_uecc_ue_context->ho_info.p_ho_info->
                                p_trg_ho_info->s1_trg_ho_info.erab_failed_list.
                                e_rab_failed_to_add_list[drb_idx].drb_id;
                            p_r8->radioResourceConfigDedicated.drb_ToReleaseList.n++;
                        }
                    }
                    if( 0 < p_r8->radioResourceConfigDedicated.drb_ToReleaseList.n )
                    {
                        p_r8->radioResourceConfigDedicated.m.drb_ToReleaseListPresent = 1; 
                    }
                    /*SPR 15086 Fix Stop */
                }
            }

            /* Meas Config */
            if ( p_uecc_ue_context->m.meas_config_updated )
            {
                if (RRC_SUCCESS != uecc_llim_build_MeasConfig(
                            p_uecc_ue_context,
                            p_uecc_ue_context->p_meas_config,
                            p_asn1_ctx,
                            &p_r8->measConfig))
                {
                    break;
                }
                p_r8->m.measConfigPresent = 1;
            }

            /* Fill reportProximityConfig_r9 if received from RRM */
            if ( p_uecc_ue_context->m.proximity_config_present)
            {
                p_r8->m.nonCriticalExtensionPresent = 1;
                p_r8->nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
                p_r8->nonCriticalExtension.nonCriticalExtension.m.otherConfig_r9Present = 1;
                p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.m.
                    reportProximityConfig_r9Present= 1;

                if ( p_uecc_ue_context->proximity_config.bitmask &
                        RRM_PROXIMITY_IND_EUTRA_PRESENT)
                {
                    p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                        reportProximityConfig_r9.proximityIndicationEUTRA_r9 =
                        p_uecc_ue_context->proximity_config.proximity_ind_eutra;

                    p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                        reportProximityConfig_r9.m.proximityIndicationEUTRA_r9Present= 1;
                }

                if ( p_uecc_ue_context->proximity_config.bitmask &
                        RRM_PROXIMITY_IND_UTRA_PRESENT)
                {
                    p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                        reportProximityConfig_r9.proximityIndicationUTRA_r9 =
                        p_uecc_ue_context->proximity_config.proximity_ind_utra;

                    p_r8->nonCriticalExtension.nonCriticalExtension.otherConfig_r9.
                        reportProximityConfig_r9.m.proximityIndicationUTRA_r9Present= 1;
                }
            }

            if ((p_uecc_ue_context->m.scell_config_present == 1) && (PNULL != 
                        p_uecc_ue_context->p_scell_config))
            {
                result = uecc_llim_build_scell_config(p_uecc_ue_context,
                        p_r8, p_asn1_ctx);

                if (result == RRC_FAILURE)
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR, "Failed to build Scell config ");
                    break;
                }
            }

            result = RRC_SUCCESS;
        }
    }while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_suspend_ue_entity_req
 *   INPUT        : uecc_ue_context_t *p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       Send internal message UECC_LLIM_SUSPEND_UE_ENTITY_REQ to LLIM
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_suspend_ue_entity_req
(
 uecc_ue_context_t *p_uecc_ue_context
 )
{
    rrc_uecc_llim_suspend_ue_entity_req_t    uecc_llim_suspend_ue_entity_req;
    rrc_return_et                            response = RRC_FAILURE;
    /* spr_fix_12666_start */
    rrc_counter_t lc_count = 0, erab_idx = 0;
    /* spr_fix_12666_stop */


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Reset */
    memset_wrapper(&uecc_llim_suspend_ue_entity_req, RRC_NULL,
            sizeof(rrc_uecc_llim_suspend_ue_entity_req_t));

    /* Fill message */
    uecc_llim_suspend_ue_entity_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
    /* Fill ue index */
    uecc_llim_suspend_ue_entity_req.ue_index = p_uecc_ue_context->ue_index;
    uecc_llim_suspend_ue_entity_req.cell_index = p_uecc_ue_context->cell_index;

    /* spr_fix_12666_start */
    /* filling the list of LCs */

    if (p_uecc_ue_context->m.srb2_created)
    {
        uecc_llim_suspend_ue_entity_req.lc_id_list.lc_id_state[lc_count].lc_id = RRC_SRB2_LC_ID;
        uecc_llim_suspend_ue_entity_req.lc_id_list.lc_id_state[lc_count].state = RLC_LLIM_NO_ACTION;
        lc_count++;
    }
    /* cyclomatic_FIX start */
    for(erab_idx = 0; ((erab_idx < MAX_ERAB_COUNT) && (lc_count < MAX_ERAB_COUNT)); erab_idx ++)
        /* cyclomatic_FIX stop */
    {
        if(p_uecc_ue_context->p_e_rab_list[erab_idx])
        {
            uecc_llim_suspend_ue_entity_req.lc_id_list.lc_id_state[lc_count].lc_id =
                p_uecc_ue_context->p_e_rab_list[erab_idx]->
                drb_config.logical_channel_identity;

            uecc_llim_suspend_ue_entity_req.lc_id_list.lc_id_state[lc_count].state = RLC_LLIM_NO_ACTION;
            lc_count++;
        }
    }
    uecc_llim_suspend_ue_entity_req.lc_id_list.lc_count = (U8)lc_count;
    /* spr_fix_12666_stop */

    /* RE_EST */
/* SPR_18953 start */
    if (RRC_TRUE == p_uecc_ue_context->share_data.uecc_rcr_data.rlf_detected)
    {
        uecc_llim_suspend_ue_entity_req.rlf_detected_flag = RRC_TRUE;
    }
    else
    {
        uecc_llim_suspend_ue_entity_req.rlf_detected_flag = RRC_FALSE;
    }
/* SPR_18953 stop */

    response = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_SUSPEND_UE_ENTITY_REQ,
            sizeof(uecc_llim_suspend_ue_entity_req),
            &uecc_llim_suspend_ue_entity_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return response;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_reestablish_ue_entity_req
 *   INPUT        : uecc_ue_context_t *p_uecc_ue_context
 *                  rrc_lc_id_t        lc_id
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       Send internal message UECC_LLIM_RE_ESTABLISH_UE_ENTITY_REQ to LLIM
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_reestablish_ue_entity_req 
(
 uecc_ue_context_t *p_uecc_ue_context,
 rrc_lc_id_t        lc_id,
/* SPR 18926 Fix Start */
    rrc_bool_et        rlc_reestablish_required
/* SPR 18926 Fix Stop */

 )
{
    rrc_uecc_llim_re_establish_ue_entity_req_t 
        uecc_llim_re_establish_ue_entity_req;
    rrc_counter_t            erab_idx = RRC_NULL, lc_count = RRC_NULL;
    rrc_return_et            response = RRC_FAILURE;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Reset Message */
    memset_wrapper(&uecc_llim_re_establish_ue_entity_req, RRC_NULL,
            sizeof(rrc_uecc_llim_re_establish_ue_entity_req_t));

    /* Fill message */
    uecc_llim_re_establish_ue_entity_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    /* Fill ue index */
    uecc_llim_re_establish_ue_entity_req.ue_index = p_uecc_ue_context->ue_index;
    uecc_llim_re_establish_ue_entity_req.cell_index = p_uecc_ue_context->cell_index;

    /* SPR 18926 Fix Start*/
    uecc_llim_re_establish_ue_entity_req.rlc_reestablish_required = RRC_FALSE;
    /* SPR 18926 Fix Stop*/

    do {
        /* Check for srb1 had been created prior re-establishment */
        if (RRC_SRB1_LC_ID == lc_id)
        {
               /* SPR 18926 Fix Start*/
               uecc_llim_re_establish_ue_entity_req.rlc_reestablish_required =
                                                                    RRC_TRUE;
               /* SPR 18926 Fix Stop*/
            /* Check whether HO is ongoing at target eNB or not */
            if (RRC_TRUE != p_uecc_ue_context->trg_ho_fail_rrc_cre_flag)
            {
                if (p_uecc_ue_context->m.srb1_created)
                {
                    uecc_llim_re_establish_ue_entity_req.lc_id_list.
                        lc_id_state[lc_count].lc_id= RRC_SRB1_LC_ID;
                    uecc_llim_re_establish_ue_entity_req.lc_id_list.
                        lc_id_state[lc_count].state = RLC_LLIM_NO_ACTION;

                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,"Re-establish LC id=[%i]",
                            uecc_llim_re_establish_ue_entity_req.lc_id_list.
                            lc_id_state[lc_count].lc_id);
                    lc_count++;
                    uecc_llim_re_establish_ue_entity_req.lc_id_list.
                        lc_count = (U8)lc_count;
                    response = RRC_SUCCESS;
                       /* SPR 18926 Fix Start*/
                       /* Code Removed */
                       /* SPR 18926 Fix Stop*/
                }
                else
                { 
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "srb1 had not been created ");
                       /* SPR 18926 Fix Start*/
                       /* Code Removed */
                       /* SPR 18926 Fix Stop*/
                }
            }
            else /* Do when HO on going at target eNB */ 
            {
                uecc_llim_re_establish_ue_entity_req.lc_id_list.
                    lc_id_state[lc_count].lc_id = RRC_SRB1_LC_ID;
                uecc_llim_re_establish_ue_entity_req.lc_id_list.
                    lc_id_state[lc_count].state = RLC_LLIM_NO_ACTION;

                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_INFO,"Re-establish LC id=[%i]",
                        uecc_llim_re_establish_ue_entity_req.lc_id_list.
                        lc_id_state[lc_count].lc_id);
                lc_count++;
                uecc_llim_re_establish_ue_entity_req.lc_id_list.
                    lc_count =(U8) lc_count;
                response = RRC_SUCCESS;
                       /* SPR 18926 Fix Start*/
                       /* Code Removed */
                       /* SPR 18926 Fix Stop*/
            }
        }
           /* SPR 18926 Fix Start */
           if ((RRC_SRB2_LC_ID == lc_id) ||
               (RRC_TRUE == rlc_reestablish_required))
           /* SPR 18926 Fix Stop */
        {
            /* Check whether HO is ongoing at target eNB or not */
            if (RRC_TRUE != p_uecc_ue_context->trg_ho_fail_rrc_cre_flag)
            {
                if (p_uecc_ue_context->m.srb2_created)
                {
                    uecc_llim_re_establish_ue_entity_req.lc_id_list.
                        lc_id_state[lc_count].lc_id = RRC_SRB2_LC_ID;
                    uecc_llim_re_establish_ue_entity_req.lc_id_list.
                        lc_id_state[lc_count].state = RLC_LLIM_NO_ACTION;

                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,"Re-establish LC id=[%i]",
                            uecc_llim_re_establish_ue_entity_req.lc_id_list.
                            lc_id_state[lc_count].lc_id);
                    lc_count++;

                    /* filling the list of LCs */
                    for(erab_idx = 0; 
                            erab_idx < MAX_ERAB_COUNT && lc_count < MAX_ERAB_COUNT;
                            erab_idx ++)
                    {
                        if (p_uecc_ue_context->p_e_rab_list[erab_idx])
                        {
#ifdef ENDC_ENABLED
                            if((RRC_TRUE ==
                                        p_uecc_ue_context->p_e_rab_list[erab_idx]->m.DC_BearerTypePresent) &&
                                    (SN_TERMINATED_SCG_BEARER ==
                                     p_uecc_ue_context->p_e_rab_list[erab_idx]->dc_bearer_type))
                            {
                                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                        (p_uecc_ue_context->p_gb_context)->facility_name,
                                        RRC_INFO,"LC id=[%i] is SN_TERMINATED_SCG_BEARER",
                                        p_uecc_ue_context->p_e_rab_list[erab_idx]->
                                        drb_config.logical_channel_identity);

                                continue;
                            }
#endif
                            uecc_llim_re_establish_ue_entity_req.
                                lc_id_list.lc_id_state[lc_count].lc_id =
                                p_uecc_ue_context->p_e_rab_list[erab_idx]->
                                drb_config.logical_channel_identity;
                            /*SPR 15738 Fix Start*/
                            uecc_llim_re_establish_ue_entity_req.lc_id_list.
                                lc_id_state[lc_count].state = RLC_LLIM_FREEZE;
                            /*SPR 15738 Fix Stop*/
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_INFO,"Re-establish LC id=[%i]",
                                    uecc_llim_re_establish_ue_entity_req.lc_id_list.
                                    lc_id_state[lc_count].lc_id);
                            lc_count++;
                        }
                    }
                    uecc_llim_re_establish_ue_entity_req.lc_id_list.
                        lc_count =(U8) lc_count;
                    response = RRC_SUCCESS;
                    break;
                }
            }
            else /* when HO ongoing at target eNB */
            {
                uecc_llim_re_establish_ue_entity_req.lc_id_list.
                    lc_id_state[lc_count].lc_id = RRC_SRB2_LC_ID;
                uecc_llim_re_establish_ue_entity_req.lc_id_list.
                    lc_id_state[lc_count].state = RLC_LLIM_NO_ACTION;

                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_INFO,"Re-establish LC id=[%i]",
                        uecc_llim_re_establish_ue_entity_req.lc_id_list.
                        lc_id_state[lc_count].lc_id);
                lc_count++;

                /* filling the list of LCs */
                for(erab_idx = 0; 
                        erab_idx < MAX_ERAB_COUNT && lc_count < MAX_ERAB_COUNT;
                        erab_idx ++)
                {
                    if (p_uecc_ue_context->p_e_rab_list[erab_idx])
                    {
#ifdef ENDC_ENABLED
                        if((RRC_TRUE ==
                                    p_uecc_ue_context->p_e_rab_list[erab_idx]->m.DC_BearerTypePresent) &&
                                (SN_TERMINATED_SCG_BEARER ==
                                 p_uecc_ue_context->p_e_rab_list[erab_idx]->dc_bearer_type))
                        {
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_INFO,"LC id=[%i] is SN_TERMINATED_SCG_BEARER",
                                    p_uecc_ue_context->p_e_rab_list[erab_idx]->
                                    drb_config.logical_channel_identity);

                            continue;
                        }
#endif
                        uecc_llim_re_establish_ue_entity_req.
                            lc_id_list.lc_id_state[lc_count].lc_id =
                            p_uecc_ue_context->p_e_rab_list[erab_idx]->
                            drb_config.logical_channel_identity;
                        /*SPR 15738 Fix Start*/
                        uecc_llim_re_establish_ue_entity_req.lc_id_list.
                            lc_id_state[lc_count].state = RLC_LLIM_FREEZE;
                        /*SPR 15738 Fix Stop*/

                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_INFO,"Re-establish LC id=[%i]",
                                uecc_llim_re_establish_ue_entity_req.lc_id_list.
                                lc_id_state[lc_count].lc_id);
                        lc_count++;
                    }
                }
                uecc_llim_re_establish_ue_entity_req.lc_id_list.
                    lc_count =(U8) lc_count;
                response = RRC_SUCCESS;
                break;
            }
        }
        else
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,"Invalid LC id=[%i]",lc_id);
        }

    } while(0);

    if (RRC_SUCCESS == response)
    {
        response = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
                UECC_LLIM_REESTABLISH_UE_ENTITY_REQ,
                sizeof(uecc_llim_re_establish_ue_entity_req),
                &uecc_llim_re_establish_ue_entity_req);
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return response;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_reconfig_security_req
 *   INPUT        : uecc_ue_context_t *p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       Send internal message UECC_LLIM_RECONFIG_SECURITY_REQ to LLIM
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_reconfig_security_req
(
 uecc_ue_context_t *p_uecc_ue_context
 )
{
    rrc_uecc_llim_reconfig_security_req_t    uecc_llim_reconfig_security_req;
    rrc_return_et                            response = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Reset */
    memset_wrapper(&uecc_llim_reconfig_security_req, RRC_NULL,
            sizeof(rrc_uecc_llim_reconfig_security_req_t));

    /* Fill message */
    uecc_llim_reconfig_security_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    /* Fill ue index */
    uecc_llim_reconfig_security_req.ue_index = 
        p_uecc_ue_context->ue_index;
    uecc_llim_reconfig_security_req.cell_index = 
        p_uecc_ue_context->cell_index;

    /* Configure_security_offset needs to be filled only in case of Intra-ENB HO
     * and its value should be set to 1 */
    if((PNULL != p_uecc_ue_context->ho_info.p_ho_info)&&
            (PNULL != p_uecc_ue_context->ho_info.p_ho_info->
             p_src_ho_info) && (PNULL != p_uecc_ue_context->ho_info.p_ho_info->
                 p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required) &&
            (HANDOVER_TYPE_INTRA_CELL == p_uecc_ue_context->ho_info.p_ho_info->
             p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type))
    {
        uecc_llim_reconfig_security_req.bitmask |=
            RRC_UECC_LLIM_RECONFIG_SECURITY_REQ_CONFIGURE_SECURITY_OFFSET_PRESENT;
        uecc_llim_reconfig_security_req.configure_security_offset = 1;

    }

    /* KRRCint For SRB */
    uecc_llim_reconfig_security_req.reconfig_integrity = 
        p_uecc_ue_context->configure_integrity_protection;
    uecc_llim_reconfig_security_req.bitmask |=
        RRC_UECC_LLIM_RECONFIG_SECURITY_REQ_RECONFIG_INTEGRITY_PRESENT;

    /* KRRCenc For SRB */ 
    uecc_llim_reconfig_security_req.reconfig_srb_ciphering = 
        p_uecc_ue_context->configure_ciphering;
    uecc_llim_reconfig_security_req.bitmask |=
        RRC_UECC_LLIM_RECONFIG_SECURITY_REQ_RECONFIG_SRB_CIPHERING_PRESENT;

    /* KUPenc For DRB */
    uecc_llim_reconfig_security_req.reconfig_drb_ciphering = 
        p_uecc_ue_context->configure_ciphering_user_plane;
    uecc_llim_reconfig_security_req.bitmask |=
        RRC_UECC_LLIM_RECONFIG_SECURITY_REQ_RECONFIG_DRB_CIPHERING_PRESENT;
    /*SPR_17121_START*/
    /* Populate Mac-I req */
    rrc_mac_i_msg_t              *p_mac_i_req = RRC_PNULL;
    uecc_llim_reconfig_security_req.bitmask |= 
        UECC_LLIM_RECONFIGURE_SECURITY_MACI_REQ_PRESENT;

    p_mac_i_req = &(uecc_llim_reconfig_security_req.mac_i_req);

    rrc_populate_maci_req(p_mac_i_req, p_uecc_ue_context );
    /*SPR_17121_END*/

    response = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_RECONFIG_SECURITY_REQ,
            sizeof(uecc_llim_reconfig_security_req),
            &uecc_llim_reconfig_security_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_resume_ue_entity_req
 *   INPUT        : uecc_ue_context_t *p_uecc_ue_context
 *                  rrc_lc_id_t        lc_id
 *                  rrc_rb_direction_t resume_dir
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       Send internal message UECC_LLIM_RESUME_UE_ENTITY_REQ to LLIM
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_resume_ue_entity_req 
(
 uecc_ue_context_t *p_uecc_ue_context,
 rrc_lc_id_t        lc_id,
 rrc_rb_direction_t resume_dir
 )
{
    rrc_uecc_llim_resume_ue_entity_req_t 
        uecc_llim_resume_ue_entity_req;
    rrc_counter_t            erab_idx = RRC_NULL, lc_count = RRC_NULL;
    rrc_return_et            response = RRC_FAILURE;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Reset Message */
    memset_wrapper(&uecc_llim_resume_ue_entity_req, RRC_NULL,
            sizeof(rrc_uecc_llim_resume_ue_entity_req_t));

    /* Fill message */
    uecc_llim_resume_ue_entity_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    /* Fill ue index */
    uecc_llim_resume_ue_entity_req.ue_index = p_uecc_ue_context->ue_index;
    uecc_llim_resume_ue_entity_req.cell_index = p_uecc_ue_context->cell_index;

    do {

        /* BUG_11163 start */
        if ((RRC_SRB1_LC_ID == lc_id) || (RRC_SRB0_LC_ID == lc_id))
            /* BUG_11163 stop */
        {
            uecc_llim_resume_ue_entity_req.rb_info.lc_id[lc_count]= 
                RRC_SRB1_LC_ID;

            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_INFO,"Re-establish LC id=[%i]",
                    uecc_llim_resume_ue_entity_req.rb_info.lc_id[lc_count]);
            lc_count++;
            uecc_llim_resume_ue_entity_req.rb_info.lc_count = (U8)lc_count;
            uecc_llim_resume_ue_entity_req.resume_direction = resume_dir;
            /* BUG_11163 start */
            response = RRC_SUCCESS;
            /* BUG_11163 stop */
        }
        /* BUG_11163 start */
        if ((RRC_SRB2_LC_ID == lc_id) || (RRC_SRB0_LC_ID == lc_id))
            /* BUG_11163 stop */
        {
            uecc_llim_resume_ue_entity_req.rb_info.lc_id[lc_count] = 
                RRC_SRB2_LC_ID;


            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_INFO,"Re-establish LC id=[%i]",
                    uecc_llim_resume_ue_entity_req.rb_info.lc_id[lc_count]);
            lc_count++;

            /* filling the list of LCs */
            for(erab_idx = 0; 
                    erab_idx < MAX_ERAB_COUNT && lc_count < MAX_ERAB_COUNT; 
                    erab_idx ++)
            {
                if (p_uecc_ue_context->p_e_rab_list[erab_idx])
                {
#ifdef ENDC_ENABLED
                    if((RRC_TRUE ==
                                p_uecc_ue_context->p_e_rab_list[erab_idx]->m.DC_BearerTypePresent) &&
                            (SN_TERMINATED_SCG_BEARER ==
                             p_uecc_ue_context->p_e_rab_list[erab_idx]->dc_bearer_type))
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_INFO,"LC id=[%i] is SN_TERMINATED_SCG_BEARER",
                                p_uecc_ue_context->p_e_rab_list[erab_idx]->
                                drb_config.logical_channel_identity);

                        continue;
                    }
#endif
                    if (RRC_MAX_NUM_RB > lc_count)
                    {
                        uecc_llim_resume_ue_entity_req.rb_info.lc_id[lc_count] =
                            p_uecc_ue_context->p_e_rab_list[erab_idx]->
                            drb_config.logical_channel_identity;

                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_INFO,"Re-establish LC id=[%i]",
                                uecc_llim_resume_ue_entity_req.rb_info.lc_id[lc_count]);
                        lc_count++;
                    }
                }
            }
            uecc_llim_resume_ue_entity_req.rb_info.lc_count = (U8)lc_count;
            uecc_llim_resume_ue_entity_req.resume_direction = resume_dir;
            response = RRC_SUCCESS;
            break;
        }
        else
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,"Invalid LC id=[%i]",lc_id);
        }

    } while(0);

    if (RRC_SUCCESS == response)
    {
        response = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
                UECC_LLIM_RESUME_UE_ENTITY_REQ,
                sizeof(uecc_llim_resume_ue_entity_req),
                &uecc_llim_resume_ue_entity_req);
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_reestablishment_asn1_radio_resource_cfg_dedicated
 *   INPUT        : uecc_ue_context_t               *p_uecc_ue_context
 *                  RadioResourceConfigDedicated    *p_asn1_rrc
 *                  OSCTXT                          *p_asn1_ctx
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds RadioResourceConfigDedicated
 *       structure for ASN1 encoding from given ue_adm_radio_res_config_t
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_reestablishment_asn1_radio_resource_cfg_dedicated(
        uecc_ue_context_t               *p_uecc_ue_context,
        RadioResourceConfigDedicated    *p_asn1_rrc,
        OSCTXT                          *p_asn1_ctx
        )
{
    rrc_return_et result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {

        /* RadioResourceConfigDedicated_mac_MainConfig */
        if ( p_uecc_ue_context->m.mac_config_present )
        {
            if (p_uecc_ue_context->m.mac_main_config_present)
            {
                p_asn1_rrc->m.mac_MainConfigPresent = 1;

                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_INFO, "[RRCConnectionReestablishment] : mac_main_config present");
                if (RRC_SUCCESS != uecc_llim_build_asn1_mac_main_config(
                            p_uecc_ue_context,
                            &(p_uecc_ue_context->mac_config),
                            &p_asn1_rrc->mac_MainConfig,
                            p_asn1_ctx))
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_INFO, "[RRCConnectionReestablishment] : ERROR IN BUILDING MAC MAIN CONFIG");
                    break;
                }
            }
        }

        /* SPS Configuration */
        if ( p_uecc_ue_context->m.sps_config_present )
        {
            p_asn1_rrc->m.sps_ConfigPresent = 1;

            if (RRC_SUCCESS != uecc_llim_build_asn1_sps_config(
                        p_uecc_ue_context,
                        /* SPS Start */
                        p_uecc_ue_context->p_sps_config,
                        /* SPS Stop */
                        &p_asn1_rrc->sps_Config,
                        p_asn1_ctx))
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_INFO, "[RRCConnectionReestablishment] : ERROR IN BUILDING SPS CONFIG");
                break;
            }
        }

        /* PhysicalConfigDedicated */
        if (  p_uecc_ue_context->m.physical_config_dedicated_present )
        {
            p_asn1_rrc->m.physicalConfigDedicatedPresent = 1;

            if (RRC_SUCCESS != uecc_llim_build_asn1_physical_config_dedicated(
                        p_uecc_ue_context,
                        &(p_uecc_ue_context->physical_config_dedicated),
                        &p_asn1_rrc->physicalConfigDedicated,
                        p_asn1_ctx))
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_INFO, "[RRCConnectionReestablishment] : ERROR IN BUILDING PHY CONFIG DEDICATED");
                break;
            }
        }
        /* eICIC reestab changes start */
        if (  p_uecc_ue_context->m.meas_subframe_pattern_pcell_present )
        {
            p_asn1_rrc->m._v3ExtPresent = 1;
            p_asn1_rrc->m.measSubframePatternPCell_r10Present = 1;

            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_INFO, "[RRCConnectionReestablishment] : meas subframe pattern for pcell  present.");

            if(RRC_SUCCESS != uecc_llim_build_asn1_meas_subframe_pattern_pcell_r10(
                        p_uecc_ue_context,
                        &(p_uecc_ue_context->rrc_meas_subframe_pattern_pcell_r10),
                        &(p_asn1_rrc->measSubframePatternPCell_r10),
                        p_asn1_ctx))
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_INFO, "[RRCConnectionReestablishment] : ERROR IN BUILDING MEAS SUBFRAME PATTERN FOR PCELL");
                break;
            }
        }
        /* eICIC reestab changes stop */
        /* main extElem1 */
        rtxDListInit(&p_asn1_rrc->extElem1);

        result = RRC_SUCCESS;

    }while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;

}

/****************************************************************************
 * Function Name  : 
 *              uecc_llim_build_and_send_s1u_reconfig_req_for_ul_switched_list 
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:    This is the function for building and sending
 *                 UECC_LLIM_S1U_RECONFIG_REQ message to the LLIM.
 ****************************************************************************/

rrc_return_et 
uecc_llim_build_and_send_s1u_reconfig_req_for_ul_switched_list(
        uecc_ue_context_t   *p_uecc_ue_context      
        )
{
    rrc_uecc_llim_s1u_reconfigure_req_t rrc_uecc_llim_s1u_reconfigure_req;
    rrc_return_et                   result = RRC_FAILURE;
    uecc_erab_to_be_switched_item_t *p_uecc_erab_switched_info = PNULL;
    uecc_drb_ctx_t      *p_erab_ctx = PNULL;
    rrc_counter_t i =0;
    rrc_uecc_llim_s1u_setup_sap_req_t *p_setup_sap_req = PNULL; 
    rrc_counter_t req_count = 0;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    memset_wrapper(&rrc_uecc_llim_s1u_reconfigure_req, 0, 
            sizeof(rrc_uecc_llim_s1u_reconfigure_req_t));

    if (!(p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                s1_trg_ho_info.bitmask
                & ERAB_TO_BE_SWITCHED_UL_LIST_PRESENT))
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_INFO, 
                "[%s] The bitmask ERAB_TO_BE_SWITCHED_UL_LIST_PRESENT is not" 
                " present and so can't send rrc_uecc_llim_s1u_reconfigure_req_t. "
                ,__FUNCTION__);
        return result;
    }

    /* ue_index */
    rrc_uecc_llim_s1u_reconfigure_req.ue_index =  p_uecc_ue_context->ue_index;
    rrc_uecc_llim_s1u_reconfigure_req.cell_index =  p_uecc_ue_context->cell_index;

    /* Transaction ID */
    rrc_uecc_llim_s1u_reconfigure_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    /* bitmask */
    rrc_uecc_llim_s1u_reconfigure_req.bitmask |= 
        RRC_UECC_LLIM_S1U_SETUP_SAP_REQ_LIST_PRESENT;

    /* num_setup_sap_req */
    rrc_uecc_llim_s1u_reconfigure_req.setup_sap_req_list.
        num_setup_sap_req = 
        p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info
        ->s1_trg_ho_info.erab_switched_list.count;


    req_count = 0;

    for(i = 0; i < (p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->
                s1_trg_ho_info.erab_switched_list.count) ; i++)
    {
        if(req_count < RRC_S1U_MAX_NUM_LC)
        {
            p_setup_sap_req 
                = &(rrc_uecc_llim_s1u_reconfigure_req.setup_sap_req_list.
                        setup_sap_req[req_count]);

            p_uecc_erab_switched_info 
                = &(p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info
                        ->s1_trg_ho_info.erab_switched_list.
                        erab_to_be_switched_item[i]); 

            p_erab_ctx = p_uecc_ue_context->p_e_rab_list
                [p_uecc_erab_switched_info->e_RAB_ID];
            if(!p_erab_ctx)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING, 
                        "[%s] UECC UE ERAB CONTEXT is not present for e_RAB_ID[%d]" 
                        ,__FUNCTION__,p_uecc_erab_switched_info->e_RAB_ID);
                continue;
            }
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_INFO, 
                    "[%s] Filling values for e_RAB_ID[%d]" 
                    ,__FUNCTION__,p_uecc_erab_switched_info->e_RAB_ID);
            /* filling rrc_uecc_llim_s1u_setup_sap_req_t */
            /* bitmask */
            p_setup_sap_req->bitmask = 0;

            /* lc_id */
            p_setup_sap_req->lc_id = p_erab_ctx->drb_config.
                logical_channel_identity; 

            /* qos_id */
            p_setup_sap_req->qos_id = p_erab_ctx->drb_config.s1u_config.qos_id;

            /* tunnel_count */
            p_setup_sap_req->tunnel_count = 1 ;
            /* tunnel_info */
            p_setup_sap_req->tunnel_info[0].sap_flag = 0x0F; 

            rrc_unpack_U32((U8*)&p_setup_sap_req->tunnel_info[0].teid_peer,
                    p_uecc_erab_switched_info->gTP_TEID.data);

            p_setup_sap_req->tunnel_info[0].bitmask |=
                RRC_UECC_LLIM_S1U_TUNNEL_INFO_TEID_PEER_PRESENT;

            p_setup_sap_req->bitmask |= RRC_UECC_LLIM_S1U_TEID_SELF_PRESENT;

            p_setup_sap_req->teid_self = p_erab_ctx->teid_self;

            /* SPR 15627 FIX Start*/
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_DETAILED,
                    "[UECC_LLIM_ADD_LC_REQ] "
                    "transportLayerAddress length =%d", p_uecc_erab_switched_info->transportLayerAddress.numbits);

            /* IPV6  or IPV4 */
            if ((RRC_MAX_IP_ADDR_LEN_IPV6*8 
                        == p_uecc_erab_switched_info->transportLayerAddress.numbits)
                    || (RRC_MAX_IP_ADDR_LEN*8 
                        == p_uecc_erab_switched_info->transportLayerAddress.numbits)
               )
            {
                p_setup_sap_req->tunnel_info[0].bitmask |=
                    RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;

                p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                    (U8)(p_uecc_erab_switched_info->transportLayerAddress.numbits/8);

                l3_memcpy_wrapper(
                        p_setup_sap_req->tunnel_info[0]
                        .transport_addr.data,
                        p_uecc_erab_switched_info->transportLayerAddress.data,
                        p_setup_sap_req->tunnel_info[0].transport_addr.data_length);

            }
            /*IPV4 and IPV6 160 bit*/
            else if((RRC_MAX_IP_ADDR_LEN*8 + RRC_MAX_IP_ADDR_LEN_IPV6*8)
                    == p_uecc_erab_switched_info->transportLayerAddress.numbits)  
            {
                p_setup_sap_req->tunnel_info[0].bitmask |=
                    RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                /* set IPV6 or IPV4 as per active mme info*/
                /*
                 * if both IPv4 and IPv6 addresses are signaled, 
                 * then IPv4 address is contained in the first 32 bits
                 */
                if(p_uecc_ue_context->p_gb_context->mme_ctx[p_uecc_ue_context->mme_id].connection_info.bitmask
                        & MME_COMM_INFO_IPV6_ADDR_PRESENT) /*IPV6 */
                {
                    /*extract ipv6 from transportLayerAddress*/
                    p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                        RRC_MAX_IP_ADDR_LEN_IPV6;

                    l3_memcpy_wrapper(
                            p_setup_sap_req->tunnel_info[0]
                            .transport_addr.data,
                            (U8*)(p_uecc_erab_switched_info->transportLayerAddress.data)+ RRC_MAX_IP_ADDR_LEN ,
                            RRC_MAX_IP_ADDR_LEN_IPV6);
                }
                else /*fill IPV4*/
                {
                    p_setup_sap_req->tunnel_info[0].transport_addr.data_length =
                        RRC_MAX_IP_ADDR_LEN;

                    l3_memcpy_wrapper(
                            p_setup_sap_req->tunnel_info[0]
                            .transport_addr.data,
                            p_uecc_erab_switched_info->transportLayerAddress.data,
                            RRC_MAX_IP_ADDR_LEN);
                }

            }
            else
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "[UECC_LLIM_ADD_LC_REQ] "
                        "transportLayerAddress has invalid size");
                /*unset the bitmask */
                p_setup_sap_req->tunnel_info[0].bitmask &=
                    ~RRC_UECC_LLIM_S1U_TUNNEL_INFO_TRANSPORT_ADDRESS_PRESENT;
                //error
            }
            /* SPR 15627 FIX End*/
            /* qos_profile */
            p_setup_sap_req->qos_profile.allocation_retention_priority = 
                p_erab_ctx->drb_config.s1u_config.qos_profile.
                allocation_retention_priority;
            p_setup_sap_req->qos_profile.qos_profile_data_length= 
                p_erab_ctx->drb_config.s1u_config.qos_profile.
                qos_profile_data_size;
            l3_memcpy_wrapper(p_setup_sap_req->qos_profile.qos_profile_data,
                    p_erab_ctx->drb_config.s1u_config.qos_profile.
                    qos_profile_data,p_erab_ctx->drb_config.s1u_config.
                    qos_profile.qos_profile_data_size);


            req_count ++;
        }
    }

    if(RRC_SUCCESS == uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
                UECC_LLIM_S1U_RECONFIGURE_REQ,
                sizeof(rrc_uecc_llim_s1u_reconfigure_req_t),
                &rrc_uecc_llim_s1u_reconfigure_req))
    {
        result = RRC_SUCCESS;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}


/******************************************************************************
 *   FUNCTION NAME: rrc_asn1PrtToStr_DL_CCCH_Message
 *   INPUT        : U32 log_level
 *                  const char* name
 *                  DL_CCCH_Message* pvalue
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function prints ASN DL_CCCH_Message using RRC logging mechanism.
 *
 *   RETURNS:
 *       void
 *
 *****************************************************************************/
void rrc_asn1PrtToStr_DL_CCCH_Message(
        U32 log_level, 
        const char* name,         
       DL_CCCH_Message* pvalue,
       const char* msgName,
       U8 *p_buff,
       U16 msgLen)
{
    int rrc_result =0;
   
/* SPR 16017 Fix Start */ 
    if(RRC_SUCCESS == rrc_check_logger_type(log_level))    
/* SPR 16017 Fix Stop */
    {
        if( name != NULL && pvalue !=NULL)
        {
            S8* pBuff = rrc_mem_get(MAX_ASN_PRINT_BUFF_SIZE);

            if(pBuff != NULL)
            {
                memset_wrapper(pBuff,0, MAX_ASN_PRINT_BUFF_SIZE);
                rrc_result = asn1PrtToStr_DL_CCCH_Message(name, pvalue, 
                        (char*)pBuff, MAX_ASN_PRINT_BUFF_SIZE);  /* Converted to char* as required by ASN function */
                if(rrc_result == 0)
                {/* SPR 13700 Fix start */
                    RRC_TRACE_ASN((S32)log_level, "%s\n", pBuff);/* SPR 13700 Fix stop */
                }
                else
                {
                    RRC_TRACE( RRC_WARNING,"Print Buffer size for ASN Msg \
                            needs to be increased\n");
                }
                rrc_mem_free(pBuff);
            }
        }
        else
        {
            RRC_TRACE( RRC_WARNING, "DL_CCCH_Message Info to be printed is missing\n");
        }
    }
    RRC_LOG_ASN_HEX_DUMP(name, msgName, p_buff, msgLen);
}

/******************************************************************************
 *   FUNCTION NAME: rrc_asn1PrtToStr_UL_CCCH_Message
 *   INPUT        : U32 log_level
 *                  const char* name 
 *                  UL_CCCH_Message* pvalue
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function prints ASN UL_CCCH_Message using RRC logging mechanism.
 *
 *   RETURNS:
 *       void
 *
 *****************************************************************************/
void rrc_asn1PrtToStr_UL_CCCH_Message( U32 log_level, 
        const char* name, 
        UL_CCCH_Message* pvalue,
        const char* msgName,
        U8 *p_buff,
        U16 msgLen) 
{
    int rrc_result =0;

/* SPR 16017 Fix Start */ 
    if(RRC_SUCCESS == rrc_check_logger_type(log_level))    
/* SPR 16017 Fix Stop */
    {
        if( name != NULL && pvalue !=NULL)
        {
            S8* pBuff = rrc_mem_get(MAX_ASN_PRINT_BUFF_SIZE);

            if(pBuff != NULL)
            {
                memset_wrapper(pBuff,0, MAX_ASN_PRINT_BUFF_SIZE);
                rrc_result = asn1PrtToStr_UL_CCCH_Message(name, pvalue, 
                        (char*)pBuff, MAX_ASN_PRINT_BUFF_SIZE);  /* Converted to char* as required by ASN function */
                if(rrc_result == 0)
                {/* SPR 13700 Fix start */
                    RRC_TRACE_ASN((S32)log_level, "%s\n", pBuff);/* SPR 13700 Fix stop */
                }
                else
                {
                    RRC_TRACE( RRC_WARNING,"Print Buffer size for ASN Msg \
                            needs to be increased\n");
                }
                rrc_mem_free(pBuff);
            }
        }
        else
        {
            RRC_TRACE(RRC_WARNING, "UL_CCCH_Message Info to be printed is missing\n");
        }
    }
    RRC_LOG_ASN_HEX_DUMP(name, msgName, p_buff, msgLen);
}
#ifdef LTE_EMBMS_SUPPORTED
/******************************************************************************
 *   FUNCTION NAME: rrc_asn1PrtToStr_MCCH_Message
 *   INPUT        : U32 log_level
 *                  const char* name 
 *                  UL_CCCH_Message* pvalue
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function prints ASN MCCH_Message using RRC logging mechanism.
 *
 *   RETURNS:
 *       void
 *
 *****************************************************************************/
void rrc_asn1PrtToStr_MCCH_Message( U32 log_level, 
        const char* name, 
        MCCH_Message* pvalue) 
{
    int rrc_result =0;

    if (rrc_get_loglevel() >= log_level)
    {
        if( name != NULL && pvalue !=NULL)
        {
            S8* pBuff = rrc_mem_get(MAX_ASN_PRINT_BUFF_SIZE);

            if(pBuff != NULL)
            {
                memset_wrapper(pBuff,0, MAX_ASN_PRINT_BUFF_SIZE);
                rrc_result = asn1PrtToStr_MCCH_Message(name, pvalue, 
                        (char*)pBuff, MAX_ASN_PRINT_BUFF_SIZE);  /* Converted to char* as required by ASN function */
                if(rrc_result == 0)
                {/* SPR 13700 Fix start */
                    RRC_TRACE_ASN((S32)log_level, "%s\n", pBuff);/* SPR 13700 Fix stop */
                }
                else
                {
                    RRC_TRACE( RRC_WARNING,"Print Buffer size for ASN Msg \
                            needs to be increased\n");
                }
                rrc_mem_free(pBuff);
            }
        }
        else
        {
            RRC_TRACE(RRC_WARNING, "MCCH_Message Info to be printed is missing\n");
        }
    }
}
#endif

/******************************************************************************
 *   FUNCTION NAME: rrc_asn1PrtToStr_DL_DCCH_Message
 *   INPUT        : U32 log_level
 *                  const char* name 
 *                  DL_DCCH_Message* pvalue
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function prints ASN DL_DCCH_Message using RRC logging mechanism.
 *
 *   RETURNS:
 *       void
 *
 *****************************************************************************/
void rrc_asn1PrtToStr_DL_DCCH_Message( U32 log_level, 
        const char* name, 
        DL_DCCH_Message* pvalue,
        const char* msgName,
        U8 *p_buff,
        U16 msgLen) 
{
    int rrc_result =0;

/* SPR 16017 Fix Start */ 
    if(RRC_SUCCESS == rrc_check_logger_type(log_level))    
/* SPR 16017 Fix Stop */
    {
        if( name != NULL && pvalue !=NULL)
        {
            S8* pBuff = rrc_mem_get(MAX_ASN_PRINT_BUFF_SIZE);

            if(pBuff != NULL)
            {
                memset_wrapper(pBuff,0, MAX_ASN_PRINT_BUFF_SIZE);
                rrc_result = asn1PrtToStr_DL_DCCH_Message(name, pvalue, 
                        (char*)pBuff, MAX_ASN_PRINT_BUFF_SIZE);  /* Converted to char* as required by ASN function */
                if(rrc_result == 0)
                {/* SPR 13700 Fix start */
                    RRC_TRACE_ASN((S32)log_level, "%s\n", pBuff);/* SPR 13700 Fix stop */
                }
                else
                {
                    RRC_TRACE(RRC_WARNING,"Print Buffer size for ASN Msg \
                            needs to be increased\n");
                }
                rrc_mem_free(pBuff);
            }
        }
        else
        {
            RRC_TRACE(RRC_WARNING, "DL_DCCH_Message Info to be printed is missing\n");
        }
    }
    RRC_LOG_ASN_HEX_DUMP(name, msgName, p_buff, msgLen);
}


/******************************************************************************
 *   FUNCTION NAME: rrc_asn1PrtToStr_UL_DCCH_Message
 *   INPUT        : U32 log_level
 *                  const char* name 
 *                  UL_DCCH_Message* pvalue
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function prints ASN UL_DCCH_Message using RRC logging mechanism.
 *
 *   RETURNS:
 *       void
 *
 *****************************************************************************/
void rrc_asn1PrtToStr_UL_DCCH_Message( U32 log_level, 
        const char* name, 
        UL_DCCH_Message* pvalue,
        const char* msgName,
        U8 *p_buff,
        U16 msgLen) 
{
    int rrc_result =0;

/* SPR 16017 Fix Start */ 
    if(RRC_SUCCESS == rrc_check_logger_type(log_level))    
/* SPR 16017 Fix Stop */
    {
        if( name != NULL && pvalue !=NULL)
        {
            S8* pBuff = rrc_mem_get(MAX_ASN_PRINT_BUFF_SIZE);

            if(pBuff != NULL)
            {
                memset_wrapper(pBuff,0, MAX_ASN_PRINT_BUFF_SIZE);
                rrc_result = asn1PrtToStr_UL_DCCH_Message(name, pvalue, 
                        (char*)pBuff, MAX_ASN_PRINT_BUFF_SIZE);  /* Converted to char* as required by ASN function */
                if(rrc_result == 0)
                {/* SPR 13700 Fix start */
                    RRC_TRACE_ASN((S32)log_level, "%s\n", pBuff);/* SPR 13700 Fix stop */
                }
                else
                {
                    RRC_TRACE(RRC_WARNING,"Print Buffer size for ASN Msg \
                            needs to be increased\n");
                }
                rrc_mem_free(pBuff);
            }
        }
        else
        {
            RRC_TRACE(RRC_WARNING, "UL_DCCH_Message Info to be printed is missing\n");
        }
    }
    RRC_LOG_ASN_HEX_DUMP(name, msgName, p_buff, msgLen);
}


/* HO Integration fix taken form rel 3.3*/
/****************************************************************************
 ** Function Name  : is_am_mode_configured_drb_present
 ** Inputs         : uecc_ue_context_t* - pointer to UE context
 ** Outputs        : None
 ** Returns        : None
 ** Description    : This will reuturn RRC_TRUE in case of at least one
 **                  AM configured DRB present
 *****************************************************************************/
static rrc_bool_et is_am_mode_configured_drb_present(
        uecc_ue_context_t*  p_ue_context
        )
{
    rrc_bool_et ret = RRC_FALSE;
    rrc_counter_t drbCnt = 0;
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    for(drbCnt = 0; drbCnt < MAX_ERAB_COUNT;
            drbCnt++ )
    {
        if(PNULL != p_ue_context->p_e_rab_list[drbCnt])
        {
            if (p_ue_context->p_e_rab_list[drbCnt]->drb_config.bitmask
                    & RRM_DRB_CONFIG_RLC_CONFIG_PRESENT )
            {
                if (p_ue_context->p_e_rab_list[drbCnt]->drb_config.
                        rlc_config_enb.rlc_config.bitmask
                        & RRC_RLC_CONFIG_AM_CONFIG_PRESENT )
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,
                            "AM Configured DRB present with DRB id [%d]",drbCnt);
                    ret = RRC_TRUE;
                    break;
                }
            }
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return ret;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_meas_config_req
 *   INPUT        : uecc_ue_context_t* p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       Send internal message UECC_LLIM_MEAS_CONFIG_REQ to LLIM
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_meas_config_req
(
 uecc_ue_context_t* p_uecc_ue_context
 )
{
    U8*             p_msg = PNULL;
    rrc_return_et   rrc_response = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_msg = uecc_alloc_intrl_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_MEAS_CONFIG_REQ,
            sizeof(rrc_uecc_llim_meas_config_req_t));

    if (PNULL != p_msg)
    {
        uecc_llim_build_meas_config_req(p_uecc_ue_context,
                (rrc_uecc_llim_meas_config_req_t*)(p_msg + RRC_API_HEADER_SIZE));

        /* Send the built API to LLIM  module*/
        rrc_send_message(p_msg, RRC_LLIM_MODULE_ID);
        rrc_response = RRC_SUCCESS;

        /* SPR 2616 Start */
        p_uecc_ue_context->is_meas_transaction_id_valid = RRC_TRUE;
        /* SPR 2616 Stop */
    }
    else
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,
                "Build and Send [UECC_LLIM_MEAS_CONFIG_REQ]:Memory Allocation Failed.");
        rrc_response = RRC_FAILURE;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return rrc_response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_inactive_ues_ind
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_INACTIVE_UES_IND message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_inactive_ues_ind
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    rrc_uecc_llim_inactive_ues_ind_t*  p_llim_inactive_ues_ind = PNULL;
    rrc_rrm_inactive_ues_ind_t         rrc_rrm_inactive_ues_ind;
    U8                                 inactive_ue_counter = RRC_NULL;
    rrc_return_et  result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);


    /* Point to message */
    p_llim_inactive_ues_ind =
        (rrc_uecc_llim_inactive_ues_ind_t *)((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_inactive_ues_ind->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }
    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_inactive_ues_ind_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "UECC: UECC_LLIM_INACTIVE_UES_IND: Wrong message size-ignore");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }


    /* Reset */
    memset_wrapper(&rrc_rrm_inactive_ues_ind, RRC_NULL,
            sizeof(rrc_rrm_inactive_ues_ind_t));

    /* Fill and send RRC_RRM_INACTIVE_UES_IND msg to RRM */
    /* number_of_inactive_ues */
    rrc_rrm_inactive_ues_ind.num_of_inactive_ue = 
        p_llim_inactive_ues_ind->num_of_inactive_ue;

    for (inactive_ue_counter = RRC_NULL; 
            inactive_ue_counter < p_llim_inactive_ues_ind->num_of_inactive_ue; 
            inactive_ue_counter++)
    {
        rrc_rrm_inactive_ues_ind.inactive_ue_info[inactive_ue_counter].
            ue_index = 
            p_llim_inactive_ues_ind->inactive_ue_info[inactive_ue_counter].
            ue_index;
    }

    /* Send to RRM */
    /* Encode and send message */
    result = rrc_rrm_il_send_rrc_rrm_inactive_ues_ind(
            &rrc_rrm_inactive_ues_ind,
            RRC_UECC_MODULE_ID,
            RRC_RRM_MODULE_ID,
            RRC_NULL,
            p_llim_inactive_ues_ind->cell_index);

    if (RRC_SUCCESS == result)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO,
                "Msg: RRC_RRM_INACTIVE_UES_IND send to RRM.");
    }
    else
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "Failed to send RRC_RRM_INACTIVE_UES_IND msg.");
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_curr_meas_object_id_keyof
 *   INPUT        : const YLNODE *p_ylnode
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function is the keyof function for the uecc_meas_object_to_add_mod_t
 *       linked list.
 *
 *   RETURNS:
 *
 ******************************************************************************/

const void * uecc_curr_meas_object_id_keyof (const YLNODE *p_ylnode)
{
    return  &(((uecc_meas_object_to_add_mod_t*)p_ylnode)->meas_object_id);
}
/******************************************************************************
 *   FUNCTION NAME: uecc_curr_meas_compare
 *   INPUT        : const void *p_key1
 *                  const void *p_key2
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function compares the key passed to retrieve correct node
 *       from linked list.
 *
 *   RETURNS:
 *
 ******************************************************************************/

int uecc_curr_meas_compare (const void *p_key1, const void *p_key2)
{
    if (*(U8*)p_key1 == *(U8*)p_key2)
    {
        return (0);
    }
    else
    {
        return (1);
    }
}
/******************************************************************************
 *   FUNCTION NAME: uecc_curr_report_config_id_keyof
 *   INPUT        : const YLNODE *p_ylnode
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function is the keyof function for the uecc_meas_object_to_add_mod_t
 *       linked list.
 *
 *   RETURNS:
 *
 ******************************************************************************/

const void * uecc_curr_report_config_id_keyof ( const YLNODE *p_ylnode)
{
    return &(((uecc_report_config_to_add_mod_t *)p_ylnode)->report_config_id);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_rat_type_compare
 *   INPUT        : const void *p_key1
 *                  const void *p_key2
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function compares the key passed to retrieve correct node
 *       from linked list.
 *
 *   RETURNS:
 *
 ******************************************************************************/

int uecc_rat_type_compare (const void *p_key1, const void *p_key2)
{
    if (*(RAT_Type*)p_key1 == *(RAT_Type*)p_key2)
    {
        return (0);
    }
    else
    {
        return (1);
    }
}
/******************************************************************************
 *   FUNCTION NAME: uecc_rat_type_keyof
 *   INPUT        : const YLNODE *p_ylnode
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function is the keyof function for the UE capability
 *       linked list.
 *
 *   RETURNS:
 *
 ******************************************************************************/

const void * uecc_rat_type_keyof ( const YLNODE *p_ylnode)
{
    return &(((UE_Radio_Capability_RAT_Container_t *)p_ylnode)->rat_type);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_count_wraparound_ind 
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *   This function processes UECC_LLIM_COUNT_WRAPAROUND_IND
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_count_wraparound_ind
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*        p_ue_context = PNULL;
    rrc_uecc_llim_count_wraparound_ind_t* 
        p_llim_count_wraparound_ind = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);

    p_llim_count_wraparound_ind =
        (rrc_uecc_llim_count_wraparound_ind_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_count_wraparound_ind_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "[UECC_LLIM_COUNT_WRAPAROUND_IND]"
                "Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_count_wraparound_ind->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context, 
                p_llim_count_wraparound_ind->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "[UECC_LLIM_COUNT_WRAPAROUND_IND] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Build and send the RRC_RRM_INTRA_ENB_HO_IND to RRM */
    if(RRC_SUCCESS != uecc_llim_build_and_send_rrc_rrm_intra_enb_ho_ind
            (p_ue_context))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "[RRC_RRM_INTRA_ENB_HO_IND]message sending failed"); 
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_reset_ue_entity_req 
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:     This is the function for building and sending
 *                  UECC_LLIM_RESET_UE_ENTITY_REQ message to the LLIM.
 ****************************************************************************/

rrc_return_t uecc_llim_build_and_send_reset_ue_entity_req(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_uecc_llim_reset_ue_entity_req_t
        rrc_uecc_llim_reset_req;
    rrc_return_t                   result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /*initializing the variable */
    memset_wrapper(&rrc_uecc_llim_reset_req, 0, sizeof(rrc_uecc_llim_reset_ue_entity_req_t));

    /* ue_index */
    rrc_uecc_llim_reset_req.ue_index = p_uecc_ue_context->ue_index;
    /* cell index */
    rrc_uecc_llim_reset_req.cell_index = p_uecc_ue_context->cell_index;
    /* Transaction ID */
    rrc_uecc_llim_reset_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    /* sending the message to LLIM */
    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_RESET_UE_ENTITY_REQ,
            sizeof(rrc_uecc_llim_reset_ue_entity_req_t),
            &rrc_uecc_llim_reset_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/*BUG 604 changes start*/
/*BUG 604 changes stop*/

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_reset_ue_entity_cnf 
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *   This function processes UECC_LLIM_RESET_UE_ENTITY_CNF
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_reset_ue_entity_cnf
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*        p_ue_context = PNULL;
    rrc_uecc_llim_reset_ue_entity_cnf_t* 
        p_uecc_llim_reset_ue_entity_cnf = PNULL;

    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_uecc_llim_reset_ue_entity_cnf =
        (rrc_uecc_llim_reset_ue_entity_cnf_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_reset_ue_entity_cnf_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_RESET_UE_ENTITY_CNF]"
                "Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_uecc_llim_reset_ue_entity_cnf->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context, 
                p_uecc_llim_reset_ue_entity_cnf->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_RESET_UE_ENTITY_CNF] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_EV_LLIM_RESET_UE_ENTITY_RESP event handler in SRC_HO_FSM *
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_RESET_UE_ENTITY_RESP,
            p_uecc_llim_reset_ue_entity_cnf);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: 
 *       uecc_llim_build_and_send_erb_setup_erab_del_rrc_connection_reconfiguration
 *   INPUTS      : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUTS     : None
 *
 *   DESCRIPTION:
 *       This function builds and sends UECC_LLIM_SRB_DATA_REQ message
 *       with RRCConnectionReconfiguration to LLIM
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_erb_setup_erab_del_rrc_connection_reconfiguration(
        uecc_ue_context_t*  p_uecc_ue_context
        )
{
    OSCTXT                                  asn1_ctx;
    DL_DCCH_Message                         dl_dcch_msg;
    RRCConnectionReconfiguration*           p_rrc_conn_recfg = PNULL;
    RRCConnectionReconfiguration_r8_IEs*    p_r8             = PNULL;
    rrc_return_et                           result           = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&dl_dcch_msg, 0, sizeof(dl_dcch_msg));

    /* Initialize the ASN Context */
    uecc_llim_init_asn_context(&asn1_ctx,
            p_uecc_ue_context);

    do {
        if (RRC_SUCCESS ==  uecc_llim_build_dl_dcch_msg(
                    &dl_dcch_msg,
                    &asn1_ctx,
                    p_uecc_ue_context,
                    &p_rrc_conn_recfg))
        {

            p_r8 = 
                rtxMemAllocType(&asn1_ctx, RRCConnectionReconfiguration_r8_IEs);
            if (PNULL == p_r8)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[RRCConnectionReconfiguration] ASN malloc failed.");
                break;
            }
            p_rrc_conn_recfg->criticalExtensions.u.c1->
                u.rrcConnectionReconfiguration_r8 = p_r8;
            asn1Init_RRCConnectionReconfiguration_r8_IEs(
                    p_r8);

            p_r8->m.radioResourceConfigDedicatedPresent = 1;

            /* ARP CHANGES START */
            /* DRB_ToReleaseList */

            asn1Init_RadioResourceConfigDedicated(&p_r8->radioResourceConfigDedicated);

            p_r8->radioResourceConfigDedicated.m.drb_ToReleaseListPresent = 1; 

            /* Generate DRB Information */
            if (RRC_SUCCESS != uecc_llim_build_asn1_setup_drb_to_release_list(
                        p_uecc_ue_context,
                        &p_r8->radioResourceConfigDedicated.drb_ToReleaseList,
                        &asn1_ctx))
            {
                break;
            }

            /* ARP CHANGES END */

            result = uecc_llim_send_rrc_connection_reconfiguration(
                    p_uecc_ue_context,
                    &asn1_ctx, &dl_dcch_msg);
            if (result == RRC_FAILURE)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[RRCConnectionReconfiguration] Message sending failed .");

            }
            else
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_INFO,
                        "[RRC PROTOCOL] RRC CONNECTION RECONFIGURATION SENT\n");
            }

        }
    }while(0);

    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/* ARP changes end */
/* SPR 4118 Start */

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_notify_integrity_failure
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_ADD_ROLLBACK_RESP message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_notify_integrity_failure
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*                   p_ue_context             = PNULL;
    rrc_uecc_llim_notify_integrity_failure_t*    p_llim_notify_int_fail = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);

    p_llim_notify_int_fail =
        (rrc_uecc_llim_notify_integrity_failure_t*)((U8*)p_api + RRC_API_HEADER_SIZE);

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_notify_integrity_failure_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_ADD_ROLLBACK_RESP] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context,p_llim_notify_int_fail->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_ADD_ROLLBACK_RESP] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO,"Notify Integrity Failure received for"
            "UE Index = %u and lc_id = %u",
            p_llim_notify_int_fail->ue_index,
            p_llim_notify_int_fail->lc_id);


    /* Call UECC_RM_EVENT_LLIM_RECONFIG_UE_RESP event handler in RM FSM *
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_NOTIFY_INTEGRITY_FAILURE,
            p_llim_notify_int_fail);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return;
}

/* SPR 4118 Stop */

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_rlc_reest_ue_entity_comp_ind
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds and sends rrc_uecc_llim_reest_ue_entity_comp_ind message
 *       to LLIM module. 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_rlc_reest_ue_entity_comp_ind
(
 uecc_ue_context_t*  p_uecc_ue_context
 )
{
    rrc_return_et response = RRC_FAILURE;
    rrc_counter_t  erab_idx = 0, lc_count = 0;
    rrc_uecc_llim_re_establish_ue_entity_complete_ind_t        
        rrc_uecc_llim_reest_ue_entity_comp_ind;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Fill message */
    rrc_uecc_llim_reest_ue_entity_comp_ind.ue_index = 
        p_uecc_ue_context->ue_index;
    rrc_uecc_llim_reest_ue_entity_comp_ind.cell_index = 
        p_uecc_ue_context->cell_index;

    rrc_uecc_llim_reest_ue_entity_comp_ind.transaction_id = 
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);


    /* filling the list of LCs */
    for(erab_idx = 0; erab_idx < MAX_ERAB_COUNT; erab_idx ++)
    {
        if(p_uecc_ue_context->p_e_rab_list[erab_idx])
        {
            rrc_uecc_llim_reest_ue_entity_comp_ind.lc_id_list.
                lc_id[lc_count] = p_uecc_ue_context->p_e_rab_list[erab_idx]->
                drb_config.logical_channel_identity;
            lc_count++;
        }
    }
    rrc_uecc_llim_reest_ue_entity_comp_ind.lc_id_list.lc_count = lc_count;
    response = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_RE_ESTABLISH_UE_ENTITY_COMPLETE_IND, 
            sizeof(rrc_uecc_llim_reest_ue_entity_comp_ind),
            &rrc_uecc_llim_reest_ue_entity_comp_ind);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}
/******************************************************************************
 *   FUNCTION NAME: rrc_uecc_fill_protocol_event_params 
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context
 *                  EVENT_EXTERNAL_HEADER *p_event_header 
 *                  U32 total_length
 *                  U16 event_id
 *                  U32 message_direction
 *   OUTPUT       : none
 *   DESCRIPTION  : Fills the Local Events' parameters .
 *
 *   RETURNS      :none
 *       
 *
 ******************************************************************************/
void rrc_uecc_fill_protocol_event_params(
        uecc_ue_context_t* p_uecc_ue_context,
        EVENT_EXTERNAL_HEADER *p_event_header,
        U32 total_length,
        U16 event_id,
        U32 message_direction)
{
    RRC_ASSERT (PNULL != p_event_header);

    p_event_header->length = total_length;
    p_event_header->event_id = event_id;
    p_event_header->EVENT_PARAM_MESSAGE_DIRECTION = message_direction;
    p_event_header->EVENT_PARAM_L3MESSAGE_LENGTH = (total_length - 
            (sizeof(EVENT_EXTERNAL_HEADER)));

    if (PNULL != p_uecc_ue_context)
    {
        if ((PNULL != p_uecc_ue_context->p_gb_context) && (PNULL != 
                    p_uecc_ue_context->p_gb_context->p_p_csc_context) && (PNULL !=
                        p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->cell_index])
                && (PNULL != p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->cell_index]->
                    p_csc_init_setup_ind))
        {
            l3_memcpy_wrapper(&p_event_header->EVENT_PARAM_CELL_ID, p_uecc_ue_context->p_gb_context->
                    p_p_csc_context[p_uecc_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                    cell_access_related_info.cell_Id, sizeof(U32));
        }
        p_event_header->EVENT_PARAM_EUTRANCELL_FROID = p_event_header->
            EVENT_PARAM_CELL_ID;

        if (p_uecc_ue_context->m.mme_ue_id_present)
        {
            p_event_header->EVENT_PARAM_MMES1APID = p_uecc_ue_context->mme_ue_id;
        }
        p_event_header->EVENT_PARAM_RAC_UE_REF = p_uecc_ue_context->s1ap_ue_id;
    }
}


/* SPS Start */
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_mac_reconfig_complete_ind
 *   INPUT        : uecc_gb_context_t   *p_uecc_gb_context
 *                  uecc_ue_context_t*  p_uecc_ue_context
 *                  U8    response
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function sends to LLIM UECC_LLIM_MAC_RECONFIG_COMPLETE_IND message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_build_and_send_mac_reconfig_complete_ind(
        uecc_gb_context_t   *p_uecc_gb_context,
        uecc_ue_context_t*  p_uecc_ue_context,
        U8    response)
{
    U8 *p_msg  = PNULL;
    rrc_uecc_llim_mac_reconfig_complete_ind_t    *p_mac_reconfig_complete_ind = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
            RRC_DETAILEDALL, "Unused variable"
            "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
    p_msg = uecc_alloc_intrl_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_MAC_RECONFIG_COMPLETE_IND,
            sizeof(rrc_uecc_llim_mac_reconfig_complete_ind_t));

    if (PNULL != p_msg)
    {
        p_mac_reconfig_complete_ind = (rrc_uecc_llim_mac_reconfig_complete_ind_t *)
            (p_msg + RRC_API_HEADER_SIZE);


        p_mac_reconfig_complete_ind->ue_index = p_uecc_ue_context->ue_index;
        p_mac_reconfig_complete_ind->cell_index = p_uecc_ue_context->cell_index;
        p_mac_reconfig_complete_ind->response = response;

        /* Send the built API to LLIM  module*/
        rrc_send_message(p_msg, RRC_LLIM_MODULE_ID);
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return;

}
/* SPS Stop */

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_drb_count_msb_req
 *   INPUT        : uecc_ue_context_t   *p_uecc_ue_contex
 *                   void                *p_api
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds and sends DRB_COUNT_MSB_REQ message
 *       to LLIM module. (UECC_LLIM_DRB_COUNT_MSB_REQ)
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_drb_count_msb_req
(
 uecc_ue_context_t   *p_uecc_ue_context, /* UE context */
 void                *p_api
 )
{
    rrc_uecc_llim_drb_count_msb_req_t          uecc_llim_drb_count_msb_req;
    rrc_return_et                              response = RRC_FAILURE;
    rrc_rrm_counter_check_req_t                *p_counter_check_req = PNULL;
    U8                                         index = RRC_NULL;
    U8                                         drb_index = RRC_NULL;
    U8                                         count = RRC_NULL;
    rrc_rb_direction_t                         rb_direction = RRC_NULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_api);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_counter_check_req = (rrc_rrm_counter_check_req_t*)(p_api);


    memset_wrapper(&uecc_llim_drb_count_msb_req, RRC_NULL, sizeof(rrc_uecc_llim_drb_count_msb_req_t)); 

    /* Fill message */
    uecc_llim_drb_count_msb_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
    uecc_llim_drb_count_msb_req.ue_index = p_uecc_ue_context->ue_index;
    uecc_llim_drb_count_msb_req.cell_index = p_uecc_ue_context->cell_index;

    if ( p_counter_check_req->bitmask & COUNTER_CHECK_REQ_DRB_LIST_PRESENCE_FLAG)
    {

        uecc_llim_drb_count_msb_req.drb_list.drb_count = 
            p_counter_check_req->drb_list.drb_count;

        for (index=0; index<p_counter_check_req->drb_list.drb_count; index++)
        {
            for (drb_index=0; drb_index<MAX_ERAB_COUNT; drb_index++)
            {
                if ( (p_uecc_ue_context->p_e_rab_list[drb_index] != PNULL) && 
                        (p_counter_check_req->drb_list.drb_Identity[index] == 
                         p_uecc_ue_context->p_e_rab_list[drb_index]->drb_config.drb_id))
                {
                    break;
                }
            }
            if ( drb_index == MAX_ERAB_COUNT)
            {
                return RRC_FAILURE;
            }
            if ( RRC_FAILURE == rrc_get_rb_direction(p_uecc_ue_context, 
                        drb_index, &rb_direction))
            {
                return RRC_FAILURE;
            }
            uecc_llim_drb_count_msb_req.drb_list.drb_info[index].rb_direction = rb_direction;

            uecc_llim_drb_count_msb_req.drb_list.drb_info[index].
                lc_id = p_uecc_ue_context->p_e_rab_list[drb_index]->drb_config.logical_channel_identity;
        }

    }
    else
    {

        for (index=0; index<MAX_ERAB_COUNT; index++)
        {
            if ( p_uecc_ue_context->p_e_rab_list[index] == PNULL)
            {
                continue;
            }
            /* klockwork fix */
            if(count< MAX_LC_COUNT)
            {
                uecc_llim_drb_count_msb_req.drb_list.drb_info[count].
                    lc_id = p_uecc_ue_context->p_e_rab_list[index]->drb_config.logical_channel_identity;

                if ( RRC_FAILURE == rrc_get_rb_direction(p_uecc_ue_context, 
                            p_uecc_ue_context->p_e_rab_list[index]->drb_config.erab_id, &rb_direction))
                {
                    return RRC_FAILURE;
                }

                uecc_llim_drb_count_msb_req.drb_list.drb_info[count].rb_direction = rb_direction;
            }
            /* klockwork fix */
            count++;
        }
        if (count == RRC_NULL)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "Counter Check received for a UE but p_e_rab_list is Empty\n");
            return RRC_FAILURE;
        }
        uecc_llim_drb_count_msb_req.drb_list.drb_count = 
            count;
    }

    response = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_DRB_COUNT_MSB_REQ,
            sizeof(rrc_uecc_llim_drb_count_msb_req_t),
            &uecc_llim_drb_count_msb_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_drb_count_msb_resp 
 *   INPUT        :  void                *p_api
 *                   uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       :  none
 *   DESCRIPTION:
 *   This function processes UECC_LLIM_DRB_COUNT_MSB_RESP message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_drb_count_msb_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*        p_ue_context = PNULL;
    rrc_uecc_llim_drb_count_msb_resp_t* 
        p_uecc_llim_drb_count_msb_resp = PNULL;
    rrc_bool_t     is_procedure_fail = RRC_FALSE;
    U8             cause = RRC_NULL;
    U8             drb_index = RRC_NULL;
    U8             index = RRC_NULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_uecc_llim_drb_count_msb_resp =
        (rrc_uecc_llim_drb_count_msb_resp_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);
    do
    {

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context,p_uecc_llim_drb_count_msb_resp->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"cell not active");
            break;
        }


        /* Precondition - p_api should point to right message */
        if (rrc_get_api_buf_size(p_api) !=
                RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_drb_count_msb_resp_t))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[UECC_LLIM_DRB_COUNT_MSB_RESP]"
                    "Wrong message size - ignore.");
            break;
        }

        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context, 
                p_uecc_llim_drb_count_msb_resp->ue_index);

        if (PNULL == p_ue_context)
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[UECC_LLIM_DRB_COUNT_MSB_RESP] UE context not found.");
            break;
        }

        if(p_uecc_llim_drb_count_msb_resp->transaction_id !=
                uecc_ue_ctx_get_op_transction_id(p_ue_context))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR ,
                    "[UECC_LLIM_DRB_COUNT_MSB_RESP] mismatching transaction id ");
            break;
        }

        if (p_ue_context->counter_check_info.counter_check_proc_running != RRC_TRUE )
        {
            /* Error. Counter Check Procedure not running */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[UECC_LLIM_DRB_COUNT_MSB_RESP] Counter Check Proc not running.");
            break;
        }
        /*Klockwork Fix*/
        if ( ( PNULL != p_ue_context->uecc_fsm.p_current_state->s_name )
                &&
                !strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name, 
                    (const S8 *)"UECC_UE_CONNECTION_RECONFIGURATION_ONGOING" ))
            /*Klockwork Fix*/
        {
            is_procedure_fail = RRC_TRUE;
            cause = RRM_RRC_INTERACTION_WITH_OTHER_PROCEDURE_FAILURE;
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[UECC_LLIM_DRB_COUNT_MSB_RESP]Reconfiguration Ongoing: sending failure ");
            break;
        }

        if (RRC_SUCCESS == p_uecc_llim_drb_count_msb_resp->response)
        {
            if (p_ue_context->uecc_fsm.p_current_state->s_name != PNULL)
            {
                if ((!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                (const S8 *)"UECC_UE_IDLE")) ||
                        (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                         (const S8 *)"UECC_UE_CONNECTION_SETUP_ONGOING")) ||
                        (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                         (const S8 *)"UECC_UE_WAIT_FOR_CONNECTION_RELEASE")) ||
                        (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                         (const S8 *)"UECC_UE_CONNECTION_RELEASE_ONGOING")) ||
                        (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                         (const S8 *)"UECC_UE_WAIT_FOR_S1_CONNECTION")) ||                        
                        (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                         (const S8 *)"UECC_UE_SRC_HO_ONGOING")))
                {
                    is_procedure_fail = RRC_TRUE;
                    cause = RRM_RRC_INTERACTION_WITH_OTHER_PROCEDURE_FAILURE;
                    break;
                }
                else
                { 
                    if ( !(p_uecc_llim_drb_count_msb_resp->bitmask & UECC_LLIM_DRB_COUNTMSB_INFO_LIST_PRESENT))
                    {
                        is_procedure_fail = RRC_TRUE;
                        cause = RRM_RRC_INTERNAL_FAILURE;
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,
                                "Drb List not received from LLIM ");

                        break;
                    }

                    p_ue_context->counter_check_info.drb_countMSB_info_list.
                        drb_count = p_uecc_llim_drb_count_msb_resp->
                        drb_countMSB_info_list.drb_count;

                    for (index=0; index<p_uecc_llim_drb_count_msb_resp->drb_countMSB_info_list.
                            drb_count; index++)
                    {
                        p_ue_context->counter_check_info.drb_countMSB_info_list.
                            drb_countMSB_info[index].bitmask = RRC_NULL;

                        if ( (p_uecc_llim_drb_count_msb_resp->drb_countMSB_info_list.
                                    drb_countMSB_info[index].bitmask) & 
                                UECC_LLIM_DRB_COUNTMSB_UPLINK_PRESENT)
                        {

                            p_ue_context->counter_check_info.drb_countMSB_info_list.
                                drb_countMSB_info[index].countMSB_Uplink =
                                p_uecc_llim_drb_count_msb_resp->drb_countMSB_info_list.
                                drb_countMSB_info[index].countMSB_Uplink;
                        }
                        else
                        {
                            p_ue_context->counter_check_info.drb_countMSB_info_list.
                                drb_countMSB_info[index].countMSB_Uplink = RRC_NULL;
                        }

                        if ( (p_uecc_llim_drb_count_msb_resp->drb_countMSB_info_list.
                                    drb_countMSB_info[index].bitmask) & 
                                UECC_LLIM_DRB_COUNTMSB_DOWNLINK_PRESENT)
                        {
                            p_ue_context->counter_check_info.drb_countMSB_info_list.
                                drb_countMSB_info[index].countMSB_Downlink =
                                p_uecc_llim_drb_count_msb_resp->drb_countMSB_info_list.
                                drb_countMSB_info[index].countMSB_Downlink;
                        }
                        else
                        {
                            p_ue_context->counter_check_info.drb_countMSB_info_list.
                                drb_countMSB_info[index].countMSB_Downlink = RRC_NULL;
                        }

                        for (drb_index=0; drb_index<MAX_ERAB_COUNT; drb_index++)
                        {
                            if (p_ue_context->p_e_rab_list[drb_index] != PNULL )
                            {
                                if (p_ue_context->p_e_rab_list[drb_index]->drb_config.
                                        logical_channel_identity == p_uecc_llim_drb_count_msb_resp->
                                        drb_countMSB_info_list.drb_countMSB_info[index].lc_id)
                                {

                                    p_ue_context->counter_check_info.drb_countMSB_info_list.
                                        drb_countMSB_info[index].drb_Identity =
                                        p_ue_context->p_e_rab_list[drb_index]->drb_config.
                                        drb_id;

                                    break;
                                }
                            }
                        }
                        if (drb_index == MAX_ERAB_COUNT)
                        {
                            is_procedure_fail = RRC_TRUE;
                            cause = RRM_RRC_INTERNAL_FAILURE;
                            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                    p_uecc_gb_context->facility_name,
                                    RRC_WARNING,
                                    "Failure to build and send "
                                    "uecc_llim_build_and_send_counter_check_req DRB Index Mismatch");
                            break;
                        }
                    }

                    /* build and send uecc_llim_build_and_send_counter_check_req
                     * message to UE */
                    if ((is_procedure_fail == RRC_FALSE) && (RRC_SUCCESS !=
                                uecc_llim_build_and_send_counter_check_req(
                                    p_ue_context)))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,
                                "Failure to build and send "
                                "uecc_llim_build_and_send_counter_check_req"
                                "to LLIM.");
                    }
                }
            }
        }
        else
        {
            is_procedure_fail = RRC_TRUE;
            cause = RRM_RRC_LL_CONFIG_FAILURE;
        }
    }while(0);

    if ( is_procedure_fail )
    {
        /* Stop UECC_UE_COUNTER_CHECK_GUARD_TIMER timer */
        uecc_rrm_counter_check_stop_timer(p_ue_context);

        /* Build and send the
         * RRC_RRM_COUNTER_CHECK_RESP(failure) to RRM. */
        if (RRC_SUCCESS != uecc_rrm_build_and_send_counter_check_failure(
                    p_ue_context, cause))

        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "Failure to send counter check resp failure message to RRM.");
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: 
 *   INPUT        :  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       :  none
 *       uecc_llim_build_and_send_counter_check_req
 *
 *   DESCRIPTION:
 *       This function builds and sends UECC_LLIM_SRB_DATA_REQ message
 *       with CounterCheckReq to LLIM
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_counter_check_req(
        uecc_ue_context_t*  p_uecc_ue_context
        )
{
    OSCTXT                                  asn1_ctx;
    DL_DCCH_Message                         dl_dcch_msg;
    rrc_return_et                           result = RRC_FAILURE;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&dl_dcch_msg, 0, sizeof(dl_dcch_msg));

    /* Initialize the ASN Context */

    do {

        if ( RRC_SUCCESS != uecc_llim_init_asn_context(&asn1_ctx,p_uecc_ue_context))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_llim_build_and_send_counter_check_req] ASN Context \
                    Init failed .");
            break;
        }
        /* save the transaction_id in meas_transaction_id variable in UE context */
        uecc_ue_ctx_set_counter_check_transction_id(p_uecc_ue_context,
                uecc_ue_ctx_get_next_transction_id(p_uecc_ue_context));

        if (RRC_SUCCESS ==  uecc_llim_build_dl_dcch_counter_check_msg(
                    &dl_dcch_msg,
                    &asn1_ctx,
                    p_uecc_ue_context
                    ))
        {
            /* Counter Check START */
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_INFO,
                    "[uecc_llim_build_and_send_counter_check_req] start CounterCheck");

            result = uecc_llim_send_counter_check_req(
                    p_uecc_ue_context,
                    &asn1_ctx, &dl_dcch_msg);


            if (result == RRC_FAILURE)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[uecc_llim_build_and_send_counter_check_req] Message sending failed .");
                break;

            }
            p_uecc_ue_context->counter_check_info.counter_check_req_sent = RRC_TRUE;
        }

    }while(0);

    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_dl_dcch_counter_check_msg
 *   INPUT        : DL_DCCH_Message*              p_dl_dcch_msg
 *                  OSCTXT*                       p_asn1_ctx
 *                  uecc_ue_context_t*            p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds the DL-DCCH message for
 *       Counter Check message sent to LLIM
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_dl_dcch_counter_check_msg
(
 DL_DCCH_Message*              p_dl_dcch_msg,
 OSCTXT*                       p_asn1_ctx,
 uecc_ue_context_t*            p_uecc_ue_context
 )
{

    rrc_return_et                   result = RRC_SUCCESS;
    CounterCheck                    *p_counter_check = PNULL;
    CounterCheck_r8_IEs             *p_counter_check_r8_IEs = PNULL;
    OSRTDListNode                   *p_node = PNULL;
    DRB_CountMSB_Info               *p_asn1_drb_elem = PNULL;
    U8                              drb_count = RRC_NULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /* Fill the values in the ASN structures that shall be encoded by
     * ASN Encoder */
    /* Downlink DCCH message type */

    p_dl_dcch_msg->message.t = T_DL_DCCH_MessageType_c1;
    p_dl_dcch_msg->message.u.c1 =
        rtxMemAllocType(p_asn1_ctx, DL_DCCH_MessageType_c1);
    do
    {
        if (PNULL == p_dl_dcch_msg->message.u.c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_llim_build_dl_dcch_counter_check_msg] ASN malloc failed.");
            result = RRC_FAILURE;
            break;
        }

        /* Choose Counter Check */
        p_dl_dcch_msg->message.u.c1->t =
            T_DL_DCCH_MessageType_c1_counterCheck;

        p_dl_dcch_msg->message.u.c1->u.counterCheck =
            rtxMemAllocType(p_asn1_ctx, CounterCheck);
        if (PNULL == p_dl_dcch_msg->message.u.c1->u.counterCheck)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_llim_build_dl_dcch_counter_check_msg] ASN malloc failed for Counter Check.");
            result = RRC_FAILURE;
            break;
        }

        p_counter_check =
            p_dl_dcch_msg->message.u.c1->u.counterCheck;

        /* transaction id */
        p_counter_check->rrc_TransactionIdentifier =
            (RRC_TransactionIdentifier) (uecc_ue_ctx_get_counter_check_transction_id
                    (p_uecc_ue_context) &
                    UECC_LTE_RRC_TRANSACTION_ID_MASK);

        p_counter_check->criticalExtensions.t =
            T_CounterCheck_criticalExtensions_c1;

        p_counter_check->criticalExtensions.u.c1 = rtxMemAllocType(p_asn1_ctx,
                CounterCheck_criticalExtensions_c1);
        if (PNULL == p_counter_check->criticalExtensions.u.c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_llim_build_dl_dcch_counter_check_msg] ASN malloc failed.");
            result = RRC_FAILURE;
            break;
        }
        p_counter_check->criticalExtensions.u.c1->t =
            T_CounterCheck_criticalExtensions_c1_counterCheck_r8;

        p_counter_check_r8_IEs = rtxMemAllocType(p_asn1_ctx,CounterCheck_r8_IEs);

        if (PNULL == p_counter_check_r8_IEs)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_llim_build_dl_dcch_counter_check_msg] ASN malloc failed.");
            result = RRC_FAILURE;
            break;
        }
        p_counter_check->criticalExtensions.u.c1->u.counterCheck_r8 = p_counter_check_r8_IEs;
        asn1Init_CounterCheck_r8_IEs(p_counter_check_r8_IEs);

        rtxDListInit(&(p_counter_check_r8_IEs->drb_CountMSB_InfoList));

        for (drb_count = 0; drb_count<p_uecc_ue_context->counter_check_info.
                drb_countMSB_info_list.drb_count; drb_count++)
        {
            rtxDListAllocNodeAndData(p_asn1_ctx, DRB_CountMSB_Info,
                    &p_node, &p_asn1_drb_elem);
            if (PNULL == p_node)
            {
                RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                        p_uecc_ue_context->p_gb_context->facility_name, RRC_ERROR,
                        "DRB_CountMSB_Info: ASN malloc failed");
                break;
            }
            p_asn1_drb_elem->drb_Identity = p_uecc_ue_context->counter_check_info.
                drb_countMSB_info_list.drb_countMSB_info[drb_count].drb_Identity;
            p_asn1_drb_elem->countMSB_Uplink = p_uecc_ue_context->counter_check_info.
                drb_countMSB_info_list.drb_countMSB_info[drb_count].countMSB_Uplink;
            p_asn1_drb_elem->countMSB_Downlink = p_uecc_ue_context->counter_check_info.
                drb_countMSB_info_list.drb_countMSB_info[drb_count].countMSB_Downlink;

            /* append node to the list */
            rtxDListAppendNode(&(p_counter_check_r8_IEs->drb_CountMSB_InfoList), p_node);
        }

    }while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_counterCheckResponse
 *   INPUT        : uecc_gb_context_t   *p_uecc_gb_context
 *                  rrc_ue_index_t      ue_index
 *                  CounterCheckResponse *p_counterCheckResponse
 *                  rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function processes CounterCheckResponse message
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_process_dcch_counterCheckResponse(
        uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
        rrc_ue_index_t      ue_index,           /* UE index  */
        CounterCheckResponse *p_counterCheckResponse,  /* UE message */
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
        )
{
    uecc_ue_context_t*                  p_ue_context = PNULL;
    CounterCheckResponse_r8_IEs* 
        p_counterCheckResponse_r8 = PNULL;
    rrc_return_et                       result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        /* Check message */
        if ( (T_CounterCheckResponse_criticalExtensions_counterCheckResponse_r8 !=
                    p_counterCheckResponse->criticalExtensions.t)
                || (PNULL==p_counterCheckResponse->criticalExtensions.
                    u.counterCheckResponse_r8))
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[counterCheckResponse]"
                    " Invalid message format.");
            break;
        }

        /* Get pointer on message data */
        p_counterCheckResponse_r8 =
            p_counterCheckResponse->criticalExtensions.u.
            counterCheckResponse_r8;

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[CounterCheckResponse] UE context not found.");
            break;
        }

        /* TRACE_changes_start */
        /* SPR 16113 Start */
        uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_srb_data_ind->data_buffer,
                p_srb_data_ind->data_buffer_length, "Counter Check Response", RRC_UL_DCCH);
        /* SPR 16113 Stop */
        /* TRACE_changes_start */

        /* Check  rrc_TransactionIdentifier 
         * received with "ll_counter_check_transaction_id" in UE context */
        if ((RRC_TRUE == p_ue_context->counter_check_info.counter_check_req_sent) &&
                (p_counterCheckResponse->rrc_TransactionIdentifier ==
                 (uecc_ue_ctx_get_counter_check_transction_id(p_ue_context) & UECC_LTE_RRC_TRANSACTION_ID_MASK)))
        {
            /* stop the meas config guard timer */
            uecc_rrm_counter_check_stop_timer(p_ue_context);

            /* Build and send the RRC_RRM_COUNTER_CHECK_RESP(success) to RRM */
            if (RRC_SUCCESS != uecc_rrm_build_and_send_counter_check_success(p_ue_context,
                        p_counterCheckResponse_r8))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "Failure to build and send counter_check_resp to RRM.");
                break;
            }
        }
        /* Check RRC_TransactionIdentifier rrc_TransactionIdentifier */
        else
        {
            /* Error. Invalid transaction id OR Counter Check request not sent
             * to UE */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "Invalid transaction id. OR Counter Check request not sent \
                    to UE");
            break;
        }

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_send_counter_check_req
 *   INPUT        : uecc_ue_context_t*                p_uecc_ue_context
 *                  OSCTXT*                           p_asn1_ctx
 *                  DL_DCCH_Message*                  p_dl_dcch_msg
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function sends UECC_LLIM_SRB_DATA_REQ message
 *       with RRCConnectionReconfiguration to LLIM
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_send_counter_check_req(
        uecc_ue_context_t*                p_uecc_ue_context,
        OSCTXT*                           p_asn1_ctx,
        DL_DCCH_Message*                  p_dl_dcch_msg
        )
{
    rrc_uecc_llim_srb_data_req_t*           p_srb_data_req = PNULL;

    U8  msg[sizeof(rrc_uecc_llim_srb_data_req_t)+UECC_MAX_ASN1_BUF_LEN];

    rrc_return_et                           result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Do ASN1 encode */
    p_srb_data_req = (rrc_uecc_llim_srb_data_req_t*)msg;

    pu_setBuffer(p_asn1_ctx, p_srb_data_req->data_buffer,
            UECC_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);

    if (RT_OK != asn1PE_DL_DCCH_Message(p_asn1_ctx, p_dl_dcch_msg))
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[Counter Check Req] ASN1 encoding failed.");
        return RRC_FAILURE;
    }
    else
    {
        rrc_asn1PrtToStr_DL_DCCH_Message(RRC_ASN,"DL_DCCH_Message",
                p_dl_dcch_msg, "CounterCheckRequest",
		p_srb_data_req->data_buffer, (U16)pe_GetMsgLen(p_asn1_ctx));  
    }

    p_srb_data_req->data_buffer_length = 
        (rrc_counter_t)pe_GetMsgLen(p_asn1_ctx);

    p_srb_data_req->transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);
    p_srb_data_req->ue_index = p_uecc_ue_context->ue_index;
    p_srb_data_req->lc_id = UECC_LTE_RRC_SRB1_LC_ID;
    p_srb_data_req->service_requested =
        UECC_LLIM_SRB_SERVICEREQUESTED_DELIVERY_STATUS_FALSE;
    p_srb_data_req->cell_index = p_uecc_ue_context->cell_index;

    /* TRACE_changes_start */
    /* SPR 16113 Start */
    uecc_rrc_ue_assoc_msg_max_trace_handler(p_uecc_ue_context, p_srb_data_req->data_buffer,
            p_srb_data_req->data_buffer_length, "Counter Check", RRC_DL_DCCH);
    /* SPR 16113 Stop */
    /* TRACE_changes_start */

    result = uecc_rrc_send_internal_msg(
            RRC_LLIM_MODULE_ID,
            UECC_LLIM_SRB_DATA_REQ,
            (U16)( p_srb_data_req->data_buffer_length+
                sizeof(rrc_uecc_llim_srb_data_req_t)),
            msg);

    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
            (p_uecc_ue_context->p_gb_context)->facility_name,
            RRC_INFO,"RRC_MSG: CounterCheckRequest %s",
            change_data_to_str(p_srb_data_req->data_buffer_length, p_srb_data_req->data_buffer));


    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_and_send_ue_information_req
 *   INPUT        : uecc_ue_context_t   *p_uecc_ue_context
 *                  void   *p_api
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds and sends ueInformationReq message
 *       to LLIM module. (UECC_LLIM_SRB_DATA_REQ)
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_llim_build_and_send_rrc_ue_information
(
 uecc_ue_context_t   *p_uecc_ue_context, /* UE context */
 void   *p_api        
 )
{
    rrc_return_et                        response = RRC_FAILURE;
    rrc_uecc_llim_srb_data_req_t*        p_srb_data_req = PNULL;


    OSCTXT                               asn1_ctx;
    DL_DCCH_Message                      dl_dcch_msg;
    DL_DCCH_MessageType_c1*              p_dl_dcch_c1 = PNULL;
    UEInformationRequest_r9_IEs          *p_UEInformationReq_r9 = PNULL;

    U8  msg[sizeof(rrc_uecc_llim_srb_data_req_t)+UECC_MAX_ASN1_BUF_LEN];

    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_ue_context);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Init ASN1 context */
    if ( RT_OK != rtInitContext(&asn1_ctx) )
    {
        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                p_uecc_ue_context->p_gb_context->facility_name,
                RRC_ERROR,
                "[RRCUEInformationRequest] ASN context initialization failed.");

        return RRC_FAILURE;
    }

    do {
        /* Fill the values in the ASN structures that
         * shall be encoded by ASN Encoder */
        /* Set Downlink DCCH message type */
        dl_dcch_msg.message.t = T_DL_DCCH_MessageType_c1;

        p_dl_dcch_c1 = rtxMemAllocType(&asn1_ctx, DL_DCCH_MessageType_c1);
        if (PNULL == p_dl_dcch_c1)
        {
            RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                    p_uecc_ue_context->p_gb_context->facility_name,
                    RRC_ERROR,
                    "[RRCUEInformationRequest] ASN malloc failed.");
            break;
        }
        dl_dcch_msg.message.u.c1 = p_dl_dcch_c1;

        p_dl_dcch_c1->t = T_DL_DCCH_MessageType_c1_ueInformationRequest_r9;
        p_dl_dcch_c1->u.ueInformationRequest_r9 =
            rtxMemAllocType(&asn1_ctx, UEInformationRequest_r9 );
        if (PNULL == p_dl_dcch_c1->u.ueInformationRequest_r9)
        {
            RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                    p_uecc_ue_context->p_gb_context->facility_name, 
                    RRC_ERROR,
                    "[RRCUEInformationRequest] ASN malloc failed.");
            break;
        }

        /* transaction id */
        p_dl_dcch_c1->u.ueInformationRequest_r9->rrc_TransactionIdentifier =
            (RRC_TransactionIdentifier)(uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context)
                    & UECC_LTE_RRC_TRANSACTION_ID_MASK);

        p_dl_dcch_c1->u.ueInformationRequest_r9->criticalExtensions.t =
            T_UEInformationRequest_r9_criticalExtensions_c1;
        p_dl_dcch_c1->u.ueInformationRequest_r9->criticalExtensions.u.c1 =
            rtxMemAllocType(&asn1_ctx, UEInformationRequest_r9_criticalExtensions_c1);
        if (PNULL ==
                p_dl_dcch_c1->u.ueInformationRequest_r9->criticalExtensions.u.c1)
        {
            RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                    p_uecc_ue_context->p_gb_context->facility_name, 
                    RRC_ERROR,
                    "[RRCUEInformationRequest] ASN malloc failed.");
            break;
        }

        p_dl_dcch_c1->u.ueInformationRequest_r9->criticalExtensions.u.c1->t =
            T_UEInformationRequest_r9_criticalExtensions_c1_ueInformationRequest_r9;
        p_UEInformationReq_r9 =
            rtxMemAllocType(&asn1_ctx, UEInformationRequest_r9_IEs);
        if (PNULL == p_UEInformationReq_r9)
        {
            RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                    p_uecc_ue_context->p_gb_context->facility_name, 
                    RRC_ERROR,
                    "[RRCUEInformationRequest] ASN malloc failed.");
            break;
        }
        asn1Init_UEInformationRequest_r9_IEs(p_UEInformationReq_r9);
        p_dl_dcch_c1->u.ueInformationRequest_r9->criticalExtensions.u.c1->
            u.ueInformationRequest_r9 = p_UEInformationReq_r9;



        p_UEInformationReq_r9->rach_ReportReq_r9 =((rrc_rrm_ue_information_req_t*)p_api)->rach_report_req;

        p_UEInformationReq_r9->rlf_ReportReq_r9 = ((rrc_rrm_ue_information_req_t*)p_api)->rlf_report_req;



        /* Prepare pointer on RRC internal message */
        p_srb_data_req = (rrc_uecc_llim_srb_data_req_t*)msg;

        /* ASN Encode message */
        pu_setBuffer(&asn1_ctx,
                p_srb_data_req->data_buffer, UECC_MAX_ASN1_BUF_LEN,
                ASN_RRC_BUF_TYPE);

        if (RT_OK != asn1PE_DL_DCCH_Message(&asn1_ctx, &dl_dcch_msg))
        {
            RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                    p_uecc_ue_context->p_gb_context->facility_name, 
                    RRC_ERROR,
                    "[RRCUEInformationRequest] ASN1 encoding failed.");
            break;
        }
        else
        {
            rrc_asn1PrtToStr_DL_DCCH_Message(RRC_ASN,"DL_DCCH_Message",
                    &dl_dcch_msg, "UEInformationRequest",
                    p_srb_data_req->data_buffer, (U16)pe_GetMsgLen(&asn1_ctx));
        }

        p_srb_data_req->data_buffer_length = (rrc_counter_t)pe_GetMsgLen(&asn1_ctx);
        p_srb_data_req->transaction_id =
            uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

        p_srb_data_req->cell_index = p_uecc_ue_context->cell_index;
        p_srb_data_req->ue_index = p_uecc_ue_context->ue_index;
        p_srb_data_req->lc_id = UECC_LTE_RRC_SRB1_LC_ID;
        p_srb_data_req->service_requested =
            UECC_LLIM_SRB_SERVICEREQUESTED_DELIVERY_STATUS_FALSE;

        /* TRACE_changes_start */
        /* SPR 16113 Start */
        uecc_rrc_ue_assoc_msg_max_trace_handler(p_uecc_ue_context, p_srb_data_req->data_buffer,
                p_srb_data_req->data_buffer_length, "UE INFORMATION REQUEST", RRC_DL_DCCH);
        /* SPR 16113 Stop */
        /* TRACE_changes_start */

        /* SPR 13394 Fix Start */
        p_uecc_ue_context->rlf_proc_flags.m.
            rrc_conn_setup_reconfigure_rlf_info_present = RRC_FALSE;
        /* SPR 13394 Fix Stop */

        /* Send message to LLIM  */
        response = uecc_rrc_send_internal_msg(
                RRC_LLIM_MODULE_ID,
                UECC_LLIM_SRB_DATA_REQ,
                (U16)(sizeof(rrc_uecc_llim_srb_data_req_t) +
                    p_srb_data_req->data_buffer_length),
                msg);

        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                p_uecc_ue_context->p_gb_context->facility_name, 
                RRC_INFO, "RRC_MSG: UEInformationRequest %s",
                change_data_to_str(p_srb_data_req->data_buffer_length, p_srb_data_req->data_buffer));

    } while (0);

    /* Free ASN1 context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_interFreqRstdMeasurement_r10 
 *
 *   DESCRIPTION:
 *       This function processes interFreqRstdMeasurement message
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/

rrc_return_et uecc_llim_process_dcch_interFreqRstdMeasurement_r10(
        uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
        rrc_ue_index_t      ue_index,           /* UE index  */
        InterFreqRSTDMeasurementIndication_r10 *p_inter_freq_rstd_meas_ind, /* UE message */
        rrc_uecc_llim_srb_data_ind_t*      p_srb_data_ind
        )
{
    uecc_ue_context_t*                  p_ue_context = PNULL;
    InterFreqRSTDMeasurementIndication_r10_IEs_rstd_InterFreqIndication_r10 *p_rstd_inter_freq_ind = PNULL; 
    rrc_return_et                       result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_gb_context);

    RRC_ASSERT(PNULL != p_inter_freq_rstd_meas_ind);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        /* Check message */
        if ( (T_InterFreqRSTDMeasurementIndication_r10_criticalExtensions_c1 !=
                    p_inter_freq_rstd_meas_ind->criticalExtensions.t)
                || (PNULL==p_inter_freq_rstd_meas_ind->criticalExtensions.
                    u.c1))
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[InterFreqRSTDMeasurementIndication]"
                    " Invalid message format.");
            break;
        }

        if ( (T_InterFreqRSTDMeasurementIndication_r10_criticalExtensions_c1_interFreqRSTDMeasurementIndication_r10 !=
                    p_inter_freq_rstd_meas_ind->criticalExtensions.u.c1->t)
                || (PNULL==p_inter_freq_rstd_meas_ind->criticalExtensions.
                    u.c1->u.interFreqRSTDMeasurementIndication_r10))
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[InterFreqRSTDMeasurementIndication]"
                    " Invalid message format.");
            break;
        }

        p_rstd_inter_freq_ind = &p_inter_freq_rstd_meas_ind->criticalExtensions.u.c1->u.interFreqRSTDMeasurementIndication_r10->rstd_InterFreqIndication_r10;

        if ( (T_InterFreqRSTDMeasurementIndication_r10_IEs_rstd_InterFreqIndication_r10_start ==
                    p_rstd_inter_freq_ind->t) &&
                (PNULL==p_rstd_inter_freq_ind->u.start))
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[InterFreqRSTDMeasurementIndication]"
                    " Invalid message format.");
            break;
        }


        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[InterFreqRSTDMeasurementIndication] UE context not found.");
            break;
        }
        /* TRACE_changes_start */
        /* SPR 16113 Start */
        uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_srb_data_ind->data_buffer,
                p_srb_data_ind->data_buffer_length, "InterFreq RSTD Measurement Indication", RRC_UL_DCCH);
        /* SPR 16113 Stop */
        /* TRACE_changes_start */

        if (RRC_SUCCESS != uecc_rrm_build_and_send_inter_freq_meas_ind(p_ue_context,
                    p_rstd_inter_freq_ind))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "Failure to build and send inter_freq_meas_ind to RRM.");
            break;
        }

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return result;
}

#ifdef ENDC_ENABLED
/*NR_DC Code Change Start*/
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_dcch_scgFailureInformationNR_r15
 *   INPUT        : uecc_gb_context_t       *p_uecc_gb_context
 *                  rrc_ue_index_t          ue_index
 *                  SCGFailureInformationNR_r15 *p_scgFailureInformationNR
 *   OUTPUT       : none
 *   DESCRIPTION  : This function processes SCGFailureInformationNR_r15 message
 *
 *   RETURNS      : RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_llim_process_dcch_scgFailureInformationNR_r15(
        uecc_gb_context_t       *p_uecc_gb_context,         /* UECC global context*/
        rrc_ue_index_t          ue_index,                   /* UE index  */
        SCGFailureInformationNR_r15 *p_scgFailureInformationNR /* UE message */
        )
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;

    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do {
        /* Check message */
        if ( (T_SCGFailureInformationNR_r15_criticalExtensions_c1 !=
                    p_scgFailureInformationNR->criticalExtensions.t)
                || (PNULL == p_scgFailureInformationNR->criticalExtensions.u.c1)
                || (T_SCGFailureInformationNR_r15_criticalExtensions_c1_scgFailureInformationNR_r15
                    != p_scgFailureInformationNR->criticalExtensions.u.c1->t)
                || (PNULL == p_scgFailureInformationNR->criticalExtensions.u.c1->
                    u.scgFailureInformationNR_r15)
           )
        {
            /* Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING, "[RRCSCGFailureInformationNR] "
                    "Invalid message format.");
            break;
        }

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get( p_uecc_gb_context, ue_index );
        if ( PNULL == p_ue_context )
        {
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING, "[RRCSCGFailureInformationNR] "
                    "UE context not found.");
            break;
        }
        if(p_scgFailureInformationNR->criticalExtensions.u.c1->
                    u.scgFailureInformationNR_r15->m.failureReportSCG_NR_r15Present)
        {
            fill_sgnb_cause_for_scgFailureInformationNR_failure_type(
                    p_ue_context,
                    (UInt32 *)&(p_scgFailureInformationNR->criticalExtensions.u.c1->
                    u.scgFailureInformationNR_r15->failureReportSCG_NR_r15.failureType_r15)
                    );

            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, "[RRCSCGFailureInformationNR] "
                    "SCGFailure Type [%d]",
                    p_scgFailureInformationNR->criticalExtensions.u.c1->
                    u.scgFailureInformationNR_r15->failureReportSCG_NR_r15.failureType_r15);
        }

        /* Send event to UE Main FSM and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_SCG_FAILURE_INFORMATION_NR,
                PNULL);

        result = RRC_SUCCESS;
    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return result;
}
/*NR_DC Code Change Stop*/
#endif
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_check_and_send_rrc_ue_information
 *
 *   DESCRIPTION:
 *       This function is used to check for the condition to send
 *       ue information request
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/

void uecc_llim_check_and_send_rrc_ue_information
(
 uecc_ue_context_t*  p_ue_context
 )
{
    if (p_ue_context->rlf_proc_flags.m.rrc_reestab_comp_rlf_info_present == 1 || 
            p_ue_context->rlf_proc_flags.m.rrc_conn_setup_reconfigure_rlf_info_present == 1)
    {
        rrc_rrm_ue_information_req_t ue_info_req;
        memset_wrapper(&ue_info_req, 0, sizeof(rrc_rrm_ue_information_req_t));
        ue_info_req.ue_Index   = p_ue_context->ue_index;
        ue_info_req.rach_report_req = 0;
        ue_info_req.rlf_report_req  = 1;
        /* Start timer */
        uecc_fsm_rrm_ue_information_req_start_timer(p_ue_context);

        /* Set UE Information intrl procedure flag in ue context */
        p_ue_context->ue_info_proc_running = RRC_TRUE;

        p_ue_context->rlf_proc_flags.ue_info_proc_intrl = RRC_TRUE;

        if(1 == p_ue_context->rlf_proc_flags.m.rrc_conn_setup_reconfigure_rlf_info_present)
        {
            p_ue_context->rlf_proc_flags.ue_info_proc_setup_reconfig_rlf = RRC_TRUE;
            p_ue_context->rlf_proc_flags.ue_info_proc_intrl = RRC_FALSE;
        }

        /* UE INFORMATION REQ */
        if (RRC_SUCCESS != uecc_llim_build_and_send_rrc_ue_information(
                    p_ue_context, &ue_info_req))
        {
            uecc_rrm_ue_information_req_stop_timer(p_ue_context);
        }
    }
    return;
}

/*SPR:6462 start*/
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_reestab_comp_cnf
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *   This function processes UECC_LLIM_RE_ESTABLISH_UE_ENTITY_COMP_CNF message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_reestab_comp_cnf
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*        p_ue_context = PNULL;
    rrc_uecc_llim_re_establish_ue_entity_complete_cnf_t* 
        p_llim_reestab_ue_entity_comp_cnf = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_reestab_ue_entity_comp_cnf =
        (rrc_uecc_llim_re_establish_ue_entity_complete_cnf_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_reestab_ue_entity_comp_cnf->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }


    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + 
            sizeof(rrc_uecc_llim_re_establish_ue_entity_complete_cnf_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_RE_ESTABLISH_UE_ENTITY_COMPLETE_CNF]"
                "Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context, 
                p_llim_reestab_ue_entity_comp_cnf->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_RE_ESTABLISH_UE_ENTITY_COMPLETE_CNF] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_EV_LLIM_REESTAB_UE_ENTITY_COMP_CNF event handler
     *      * and pass API data to FSM. */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_REESTAB_UE_ENTITY_COMP_CNF,
            p_llim_reestab_ue_entity_comp_cnf);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/*SPR:6462 stop */
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_modify_rollback_req_for_ue_ctx_mod 
 *   INPUT        : uecc_ue_context_t*                    p_uecc_ue_context
 *                  rrc_uecc_llim_modify_rollback_req_t*  p_rrc_uecc_llim_rollback_req
 *   OUTPUT       : none
 *   DESCRIPTION  : Build UECC Triggered internal message UECC_LLIM_MODIFY_ROLLBACK_REQ 
 *                  for UE_CTX_MOD
 *   RETURNS      : None
 ******************************************************************************/
void uecc_llim_build_modify_rollback_req_for_ue_ctx_mod
(
 uecc_ue_context_t*              p_uecc_ue_context,
 rrc_uecc_llim_modify_rollback_req_t*  p_rrc_uecc_llim_rollback_req
 )
{
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_uecc_llim_rollback_req);

    /* Fill message */
    p_rrc_uecc_llim_rollback_req->transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);


    p_rrc_uecc_llim_rollback_req->ue_index = p_uecc_ue_context->ue_index;
    p_rrc_uecc_llim_rollback_req->cell_index = p_uecc_ue_context->cell_index;

    /* Fill AMBR */
    p_rrc_uecc_llim_rollback_req->modify_drb_entity.bitmask |= 
        UECC_LLIM_MODIFY_LC_REQ_UE_AMBR_PRESENT;
    /*securitykey*/
    p_rrc_uecc_llim_rollback_req->modify_drb_entity.ue_ambr.dl_ambr = 
        (U32)p_uecc_ue_context->
        ue_aggregate_maximum_bitrate.uEaggregateMaximumBitRateDL;        

    p_rrc_uecc_llim_rollback_req->modify_drb_entity.ue_ambr.ul_ambr =
        (U32)p_uecc_ue_context->
        ue_aggregate_maximum_bitrate.uEaggregateMaximumBitRateUL; 
    /*securitykey*/
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}
/*BUG 604 changes start*/
/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_s1u_intra_enb_data_fwd_req 
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:    This is the function for building and sending
 *                   UECC_LLIM_S1U_INTRA_ENB_DATA_FWD_REQ message to the LLIM.
 ****************************************************************************/

rrc_return_t uecc_llim_build_and_send_s1u_intra_enb_data_fwd_req(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_uecc_llim_s1u_intra_enb_data_fwd_req_t rrc_uecc_llim_s1u_data_fwd_req;
    rrc_return_et                   result = RRC_FAILURE;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    memset_wrapper(&rrc_uecc_llim_s1u_data_fwd_req, 0, 
            sizeof(rrc_uecc_llim_s1u_intra_enb_data_fwd_req_t));

    /* Source ue_index */
    rrc_uecc_llim_s1u_data_fwd_req.ue_index =  p_uecc_ue_context->ue_index;
    /* Target ue_index */
    rrc_uecc_llim_s1u_data_fwd_req.target_ue_index = 
        p_uecc_ue_context->ho_info.target_ue_index;
    rrc_uecc_llim_s1u_data_fwd_req.cell_index = p_uecc_ue_context->cell_index;
    /* Transaction ID */
    rrc_uecc_llim_s1u_data_fwd_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_S1U_INTRA_ENB_DATA_FWD_REQ,
            sizeof(rrc_uecc_llim_s1u_intra_enb_data_fwd_req_t),
            &rrc_uecc_llim_s1u_data_fwd_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_intra_enb_data_fwd_cnf
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_S1U_INTRA_ENB_DATA_FWD_CNF message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_intra_enb_data_fwd_cnf
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_uecc_llim_s1u_intra_enb_data_fwd_cnf_t*    p_llim_s1u_data_fwd_cnf = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_s1u_data_fwd_cnf = (rrc_uecc_llim_s1u_intra_enb_data_fwd_cnf_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_s1u_data_fwd_cnf->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_s1u_intra_enb_data_fwd_cnf_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_S1U_INTRA_ENB_DATA_FWD_CNF] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context,p_llim_s1u_data_fwd_cnf->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_S1U_INTRA_ENB_DATA_FWD_CNF] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Check transaction_id */
    if (p_llim_s1u_data_fwd_cnf->transaction_id !=
            uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /* Error. Invalid transaction id */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_S1U_INTRA_ENB_DATA_FWD_CNF] Invalid transaction id.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_EV_LLIM_S1U_INTRA_ENB_DATA_FWD_CNF event handler
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_S1U_INTRA_ENB_DATA_FWD_CNF,
            p_llim_s1u_data_fwd_cnf);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_s1u_path_switch_req 
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:    This is the function for building and sending
 *                   UECC_LLIM_S1U_LOCAL_PATH_SWITCH_REQ message to the LLIM.
 ****************************************************************************/

rrc_return_t uecc_llim_build_and_send_s1u_path_switch_req(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_uecc_llim_s1u_local_path_switch_req_t rrc_uecc_llim_s1u_path_switch_req;
    rrc_return_et                   result = RRC_FAILURE;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    memset_wrapper(&rrc_uecc_llim_s1u_path_switch_req, 0, 
            sizeof(rrc_uecc_llim_s1u_local_path_switch_req_t));

    /* UeIndex */
    rrc_uecc_llim_s1u_path_switch_req.ue_index = p_uecc_ue_context->ue_index;

    /* UeIndex used for path_switch*/
    if((PNULL != p_uecc_ue_context->ho_info.p_ho_info)&&
            (PNULL != p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info)&&
            (p_uecc_ue_context->ho_info.p_ho_info->p_src_ho_info->
             s1u_reconfigured ))
    {
        rrc_uecc_llim_s1u_path_switch_req.ue_index_for_path_switch = 
            p_uecc_ue_context->ue_index;
    }
    else
    {
        rrc_uecc_llim_s1u_path_switch_req.ue_index_for_path_switch = 
            p_uecc_ue_context->ho_info.source_ue_index;
    }
    rrc_uecc_llim_s1u_path_switch_req.cell_index = p_uecc_ue_context->cell_index;
    /* Transaction ID */
    rrc_uecc_llim_s1u_path_switch_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_S1U_LOCAL_PATH_SWITCH_REQ,
            sizeof(rrc_uecc_llim_s1u_local_path_switch_req_t),
            &rrc_uecc_llim_s1u_path_switch_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_llim_process_local_path_switch_cnf
 *   INPUT        : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUT       : none
 *
 *   DESCRIPTION:
 *       This function processes LLIM UECC_LLIM_S1U_LOCAL_PATH_SWITCH_CNF message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_llim_process_local_path_switch_cnf
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_uecc_llim_s1u_local_path_switch_cnf_t*    p_llim_s1u_path_switch_cnf = PNULL;


    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_llim_s1u_path_switch_cnf = (rrc_uecc_llim_s1u_local_path_switch_cnf_t*)
        ((U8*)p_api + RRC_API_HEADER_SIZE);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                p_uecc_gb_context,p_llim_s1u_path_switch_cnf->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            RRC_API_HEADER_SIZE + sizeof(rrc_uecc_llim_s1u_local_path_switch_cnf_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_S1U_LOCAL_PATH_SWITCH_CNF] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Process message */
    p_ue_context =
        uecc_ue_ctx_get(p_uecc_gb_context,p_llim_s1u_path_switch_cnf->ue_index);

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_S1U_LOCAL_PATH_SWITCH_CNF] UE context not found.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Check transaction_id */
    if (p_llim_s1u_path_switch_cnf->transaction_id !=
            uecc_ue_ctx_get_op_transction_id(p_ue_context))
    {
        /* Error. Invalid transaction id */
        /* - Drop message */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[UECC_LLIM_S1U_LOCAL_PATH_SWITCH_CNF] Invalid transaction id.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* Call UECC_EV_LLIM_S1U_LOCAL_PATH_SWITCH_CNF event handler
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't be used here because
     * the stack variable is used for storing the API data
     * */
    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_LLIM_S1U_LOCAL_PATH_SWITCH_CNF,
            p_llim_s1u_path_switch_cnf);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/*BUG 604 changes stop*/
/*Bug 357 Fix Start*/
/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_re_est_req_for_srbs 
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:    This is the function for building and sending
 *                   UECC_LLIM_RE_EST_REQ message to the LLIM.
 ****************************************************************************/

rrc_return_t uecc_llim_build_and_send_re_est_req_for_srbs(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_uecc_llim_re_establish_ue_entity_req_t
        rrc_uecc_llim_re_est_req;
    rrc_return_et                   result = RRC_FAILURE;
    rrc_counter_t  count = 0;
    rrc_uecc_llim_lc_id_list_t    *p_lc_id_list = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /*initializing the variable */
    memset_wrapper(&rrc_uecc_llim_re_est_req, 0, sizeof(rrc_uecc_llim_re_est_req));

    /* ue_index */
    rrc_uecc_llim_re_est_req.ue_index = p_uecc_ue_context->ue_index;
    rrc_uecc_llim_re_est_req.cell_index = p_uecc_ue_context->cell_index;
    /* Transaction ID */
    rrc_uecc_llim_re_est_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    p_lc_id_list = &rrc_uecc_llim_re_est_req.lc_id_list;
    p_lc_id_list->lc_count = 2;

    /* filling the LC corresponding to SRB1 */
    p_lc_id_list->lc_id_state[count].lc_id = RRC_SRB1_LC_ID;
    rrc_uecc_llim_re_est_req.lc_id_list.lc_id_state[count].
        state = RLC_LLIM_NO_ACTION;

    /* filling the LC corresponding to SRB2 */
    count++;
    p_lc_id_list->lc_id_state[count].lc_id = RRC_SRB2_LC_ID;
    rrc_uecc_llim_re_est_req.lc_id_list.lc_id_state[count].
        state = RLC_LLIM_NO_ACTION;

    /* sending the message to LLIM */
    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_RE_ESTABLISH_UE_ENTITY_REQ,
            sizeof(rrc_uecc_llim_re_establish_ue_entity_req_t),
            &rrc_uecc_llim_re_est_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
} 

/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_pdcp_re_est_req
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:    This is the function for building and sending
 *                   UECC_LLIM_PDCP_RE_EST_REQ message to the LLIM.
 ****************************************************************************/
rrc_return_t uecc_llim_build_and_send_pdcp_re_est_req(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_uecc_llim_re_establish_ue_entity_req_t
        rrc_uecc_llim_re_est_req;
    rrc_return_et                   result = RRC_FAILURE;
    rrc_counter_t  erab_idx = 0, lc_count = 0;
    rrc_uecc_llim_lc_id_list_t    *p_lc_id_list = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /*initializing the variable */
    memset_wrapper(&rrc_uecc_llim_re_est_req, 0, sizeof(rrc_uecc_llim_re_est_req));

    /* ue_index */
    rrc_uecc_llim_re_est_req.ue_index = p_uecc_ue_context->ue_index;
    rrc_uecc_llim_re_est_req.cell_index = p_uecc_ue_context->cell_index;
    /* Transaction ID */
    rrc_uecc_llim_re_est_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    p_lc_id_list = &rrc_uecc_llim_re_est_req.lc_id_list;

    /* filling the LC corresponding to SRB1 */
    p_lc_id_list->lc_id_state[lc_count].lc_id = RRC_SRB1_LC_ID;
    rrc_uecc_llim_re_est_req.lc_id_list.lc_id_state[lc_count].
        state = RLC_LLIM_NO_ACTION;
    lc_count++;

    /* filling the LC corresponding to SRB2 */
    p_lc_id_list->lc_id_state[lc_count].lc_id = RRC_SRB2_LC_ID;
    rrc_uecc_llim_re_est_req.lc_id_list.lc_id_state[lc_count].
        state = RLC_LLIM_NO_ACTION;
    lc_count++;

    /* filling the LC corresponding to DRB */
    /*Klokwork fix*/
    for(erab_idx = 0; (((erab_idx < MAX_ERAB_COUNT) && 
                    (lc_count < MAX_ERAB_COUNT))); erab_idx ++)
        /*Klokwork fix*/
    {
        if(p_uecc_ue_context->p_e_rab_list[erab_idx])
        {
            p_lc_id_list->lc_id_state[lc_count].lc_id = 
                p_uecc_ue_context->p_e_rab_list[erab_idx]->
                drb_config.logical_channel_identity;
            if (p_uecc_ue_context->p_e_rab_list[erab_idx]->
                    drb_config.rlc_config_enb.rlc_config.bitmask &
                    RRC_RLC_CONFIG_AM_CONFIG_PRESENT)
            {
                rrc_uecc_llim_re_est_req.lc_id_list.lc_id_state[lc_count].
                    state = RLC_LLIM_FREEZE;
            }
            else
            {
                rrc_uecc_llim_re_est_req.lc_id_list.lc_id_state[lc_count].
                    state = RLC_LLIM_NO_ACTION;
            }
            lc_count++;
        }
    }
    p_lc_id_list->lc_count = (U8)lc_count;


    /* sending the message to LLIM */
    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_PDCP_RE_ESTABLISH_UE_ENTITY_REQ,
            sizeof(rrc_uecc_llim_re_establish_ue_entity_req_t),
            &rrc_uecc_llim_re_est_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}
/*Bug 357 Fix Stop*/

/*SPR 15304 Start*/
/******************************************************************************
*   FUNCTION NAME: uecc_llim_build_and_send_rollback_meas_config_req
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       Send internal message UECC_LLIM_MEAS_CONFIG_REQ to LLIM to rollback
*       the meas gap configuration at the lower layers.
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_llim_build_and_send_rollback_meas_config_req
(
    uecc_ue_context_t* p_uecc_ue_context
)
{
    U8*             p_msg = PNULL;
    rrc_return_et   rrc_response = RRC_FAILURE;
    rrc_uecc_llim_meas_config_req_t* p_rrc_uecc_llim_meas_config_req = PNULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_msg = uecc_alloc_intrl_msg(RRC_LLIM_MODULE_ID,
        UECC_LLIM_MEAS_CONFIG_REQ,
        sizeof(rrc_uecc_llim_meas_config_req_t));

    if (PNULL != p_msg)
    {
	    memset_wrapper(p_msg, 0, sizeof(rrc_uecc_llim_meas_config_req_t));
	    p_rrc_uecc_llim_meas_config_req = (rrc_uecc_llim_meas_config_req_t*)
		    (p_msg + RRC_API_HEADER_SIZE);
	    /* Fill message: transaction_id */
	    p_rrc_uecc_llim_meas_config_req->transaction_id =
		    uecc_ue_ctx_get_meas_transction_id(p_uecc_ue_context);

	    /* Fill message: ue_index */
	    p_rrc_uecc_llim_meas_config_req->cell_index = 
		    p_uecc_ue_context->cell_index;
	    p_rrc_uecc_llim_meas_config_req->ue_index = 
		    p_uecc_ue_context->ue_index;
	    p_rrc_uecc_llim_meas_config_req->meas_config.bitmask |=
				UE_ADM_MEAS_GAP_CONFIG_PRESENT;
	    if ((p_uecc_ue_context->curr_meas_config.m.curr_meas_gap_config_present)
		&& (p_uecc_ue_context->curr_meas_config.curr_meas_gap_config.
			bitmask & MEAS_GAP_CONFIG_SETUP_CONFIG_INFO_PRESENT))
	    {
	    	l3_memcpy_wrapper(&p_rrc_uecc_llim_meas_config_req->meas_config.meas_gap_config,
			&p_uecc_ue_context->curr_meas_config.curr_meas_gap_config,
			sizeof(meas_gap_config_t));
	    }
	    else
	    {
		p_rrc_uecc_llim_meas_config_req->meas_config.meas_gap_config.
			bitmask = 0;
		p_rrc_uecc_llim_meas_config_req->meas_config.meas_gap_config.
			meas_gap_config_type = 0;
	    }

	    /* Send the built API to LLIM  module*/
	    rrc_send_message(p_msg, RRC_LLIM_MODULE_ID);
	    rrc_response = RRC_SUCCESS;

    }
    else
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
            (p_uecc_ue_context->p_gb_context)->facility_name,
            RRC_FATAL,
            "Build and Send [UECC_LLIM_MEAS_CONFIG_REQ]:Memory Allocation Failed.");
        rrc_response = RRC_FAILURE;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return rrc_response;
}
/*SPR 15304 Stop*/
/* Bug 817 Fix Start */
/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_delete_trg_forwarding_tunnel_req 
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:    This is the function for building and sending
 *                   UECC_LLIM_S1U_RECONFIG_REQ to delete forwarding tunnels 
 *                   message to the LLIM.
 ****************************************************************************/

rrc_return_t uecc_llim_build_and_send_delete_trg_forwarding_tunnel_req(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_uecc_llim_s1u_reconfigure_req_t rrc_uecc_llim_s1u_reconfigure_req;
    rrc_return_et                   result = RRC_FAILURE;
    U8 rel_req_count = RRC_NULL;
    U8 rrc_fwd_tunnel_cnt = RRC_NULL;
    U8 drb_count = RRC_NULL;
    U8 tunnel_count = RRC_NULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    if (p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.drb_tunnel_info_count == RRC_NULL)
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_INFO, 
                "No Forwading tunnels exist for UE-Id [%d]", 
                p_uecc_ue_context->ue_index);
        return result;

    }

    memset_wrapper(&rrc_uecc_llim_s1u_reconfigure_req, 0, 
            sizeof(rrc_uecc_llim_s1u_reconfigure_req_t));

    /* ue_index */
    rrc_uecc_llim_s1u_reconfigure_req.ue_index =  p_uecc_ue_context->ue_index;
    rrc_uecc_llim_s1u_reconfigure_req.cell_index =  p_uecc_ue_context->cell_index;

    /* Transaction ID */
    /* SPR 16087 Start */
    rrc_uecc_llim_s1u_reconfigure_req.transaction_id =
        RRC_S1U_END_MARKER_RESERVED_TRANSACTION_ID;
    /* SPR 16087 Stop */

    /* bitmask */
    rrc_uecc_llim_s1u_reconfigure_req.bitmask |=
        RRC_UECC_LLIM_S1U_REL_SAP_REQ_LIST_PRESENT;

    rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
        num_rel_sap_req = p_uecc_ue_context->
        rrc_trg_ho_fwd_tnl_info.drb_tunnel_info_count;

    for (drb_count = 0; drb_count < MAX_ERAB_COUNT; drb_count++)
    {
        if ((PNULL != p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.
                    p_uecc_drb_fwd_tnl_list[drb_count]) &&
                (RRC_S1U_MAX_NUM_LC > rel_req_count))
        {
            rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
                rel_sap_req[rel_req_count].lc_id = drb_count;
            /* klocwork fix */		
            for(rrc_fwd_tunnel_cnt = 0; (rrc_fwd_tunnel_cnt < p_uecc_ue_context->
                        rrc_trg_ho_fwd_tnl_info.p_uecc_drb_fwd_tnl_list[drb_count]->
                        tunnel_info_count) && (rrc_fwd_tunnel_cnt < RRC_S1U_MAX_TUNNELS_PER_LC); ++rrc_fwd_tunnel_cnt)
            {
                if (RRC_PDCP_RB_DIR_BOTH != p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.
                        p_uecc_drb_fwd_tnl_list[drb_count]->
                        uecc_fwd_tnl_list[rrc_fwd_tunnel_cnt].rb_direction)
                {
                    tunnel_count = rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
                        rel_sap_req[rel_req_count].tunnel_count;

                    rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
                        rel_sap_req[rel_req_count].release_tunnel_info
                        [tunnel_count].bitmask |=
                        RRC_S1U_IE_RELEASE_TUNNEL_INFO_TRANSPORT_ADDR_PRESENT;

                    rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
                        rel_sap_req[rel_req_count].release_tunnel_info[tunnel_count].teid_self = 
                        p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.p_uecc_drb_fwd_tnl_list[drb_count]->
                        uecc_fwd_tnl_list[rrc_fwd_tunnel_cnt].teid_self;

                    rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
                        rel_sap_req[rel_req_count].release_tunnel_info[tunnel_count].
                        transport_addr = 
                        p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.p_uecc_drb_fwd_tnl_list[drb_count]->
                        uecc_fwd_tnl_list[rrc_fwd_tunnel_cnt].transport_addr;

                    rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.
                        rel_sap_req[rel_req_count].tunnel_count++;

                }
            }
            rrc_mem_free (p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.
                    p_uecc_drb_fwd_tnl_list[drb_count]);
            p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.
                p_uecc_drb_fwd_tnl_list[drb_count] = PNULL;
            rel_req_count++;
        }
    }

    p_uecc_ue_context->rrc_trg_ho_fwd_tnl_info.drb_tunnel_info_count = RRC_NULL;

    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_S1U_RECONFIGURE_REQ,
            sizeof(rrc_uecc_llim_s1u_reconfigure_req_t),
            &rrc_uecc_llim_s1u_reconfigure_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}
/* Bug 817 Fix Stop */
/*SPR_17121_START*/
/******************************************************************************
 *   FUNCTION NAME: rrc_populate_maci_req 
 *   INPUTS       : rrc_mac_i_msg_t*   p_mac_i_req
 *                  uecc_ue_context_t* p_ue_context
 *   OUTPUTS      : mac_i_req structure
 *   DESCRIPTION  : This function populates mac_i_req structure.
 *   RETURNS:     : None
 *******************************************************************************/
void rrc_populate_maci_req(
        rrc_mac_i_msg_t*    p_mac_i_req,
        uecc_ue_context_t*  p_ue_context)
{
    RRC_ASSERT(p_mac_i_req != RRC_PNULL);
    RRC_ASSERT(p_ue_context != RRC_PNULL);

    /* Fill LCID */
    p_mac_i_req->lc_id =  (rrc_lc_id_t)LC_ID_VAL_TO_CAL_MAC_I; 

    /* Fill RB-Direction */
    p_mac_i_req->rb_direction =  RB_DIR_VAL_TO_CAL_MAC_I; 

    /* Fill encoded_var_short_mac_i */
    if(RRC_SUCCESS != uecc_s1ap_build_VarShortMAC_Input(p_ue_context,
                (U32*)(p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                p_csc_init_setup_ind->sib_type_1_Info.cell_access_related_info.cell_Id),
                p_mac_i_req->encoded_var_short_mac_i,
                &(p_mac_i_req->encoded_var_short_mac_i_data_length)))
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,p_ue_context->
                p_gb_context->facility_name,RRC_ERROR,
                "[UECC_LLIM_MAC_I_REQ] Fail to create encoded "
                "var short maci msg");
    }

}

/*SPR_17121_END*/
/*CA_START*/
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_scell_config
 *   INPUT        : uecc_ue_context_t               *p_uecc_ue_context
 *                  RRCConnectionReconfiguration_r8_IEs    *p_r8
 *                  OSCTXT                          *p_asn1_ctx
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds RRCConnectionReconfiguration_v1020_IEs
 *       structure for ASN1 encoding from p_uecc_ue_context
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/

rrc_return_et uecc_llim_build_scell_config
(
 uecc_ue_context_t                    *p_uecc_ue_context,
 RRCConnectionReconfiguration_r8_IEs  *p_r8,
 OSCTXT                               *p_asn1_ctx
 )
{
    rrc_return_et result = RRC_SUCCESS;
    rrm_scell_config_t  *p_temp_scell_config = PNULL;        

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_r8);
    RRC_ASSERT(PNULL != p_asn1_ctx);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do {

        /*If rrm_scell_config is present in UE context then HO is ongoing   */
        if ((PNULL != p_uecc_ue_context->uecc_fsm.proc_descriptor.
                    p_active_proc) && 
                ( PNULL != p_uecc_ue_context->p_curr_proc_data) &&
                ( PNULL != p_uecc_ue_context->p_curr_proc_data->
                  u.rrm_ue_reconfig_request_data.p_scell_config))
        {
            if (!(strcmp_wrapper(p_uecc_ue_context->uecc_fsm.proc_descriptor.
                            p_active_proc->s_id, (const S8 *)"UE_RRM_UE_RECONFIG_P")))
            {
                p_temp_scell_config = p_uecc_ue_context->p_curr_proc_data->
                    u.rrm_ue_reconfig_request_data.p_scell_config;
            }
        }
        else if ( PNULL != p_uecc_ue_context->p_rrm_scell_config )
        {
            p_temp_scell_config = p_uecc_ue_context->p_rrm_scell_config;
        }

        if(PNULL != p_temp_scell_config)
        {
            p_r8->m.nonCriticalExtensionPresent = 1;
            p_r8->nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
            p_r8->nonCriticalExtension.nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
            if(RRM_SCELL_ADD_MOD_LIST_PRESENT & p_temp_scell_config->bitmask) 
            {
                p_r8->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.m.
                    sCellToAddModList_r10Present = 1;

                if (RRC_SUCCESS != uecc_llim_build_asn1_add_modify_scell_config(
                            p_uecc_ue_context,
                            &p_temp_scell_config->scell_add_mod_list,
                            &p_r8->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                            sCellToAddModList_r10,
                            p_asn1_ctx))
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR, "Scell config error in Add or Modify ");
                    result = RRC_FAILURE;
                    break;
                }
            }


            if(RRM_SCELL_RELEASE_LIST_PRESENT & p_temp_scell_config->bitmask)
            {
                p_r8->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.m.
                    sCellToReleaseList_r10Present = 1;

                if (RRC_SUCCESS != uecc_llim_build_asn1_rel_scell_config(
                            p_uecc_ue_context,
                            &p_temp_scell_config->scell_release_list,
                            &p_r8->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                            sCellToReleaseList_r10))/*SPR 17777 +-*/
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR, "Scell config error in release ");
                    result = RRC_FAILURE;
                    break;
                }
            }
        }
        else
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "scell config not present ");
            result = RRC_FAILURE;
            break;
        }
    }while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/* SPR 23209 FIXED START */
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_search_plmn_idx_in_sib1
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *   OUTPUTS      : p_plmn_idx_sib1
 *   DESCRIPTION  : This function searches the UE selected PLMN in SIB1 and returns the
 *                  position of required PLMN in SIB1 in p_plmn_idx_sib1.
 *   RETURNS:     : None
 *******************************************************************************/
rrc_return_et
uecc_llim_search_plmn_idx_in_sib1
(
 uecc_ue_context_t *p_ue_context,
 U8                *p_plmn_idx_sib1
)
{
    RRC_ASSERT(p_ue_context != RRC_PNULL);
    U8 plmn_count      = RRC_NULL ;
    U8 sib1_plmn_count = RRC_NULL;
    rrc_return_et plmn_identity_flag = RRC_FAILURE;
    /*MOCN SPR 21988 Fix Start*/
    plmn_identity_t    plmn_identity = {0};
    memset_wrapper(&plmn_identity,RRC_NULL,sizeof(plmn_identity_t));
    /*MOCN SPR 21988 Fix End*/

    sib1_plmn_count = p_ue_context->p_gb_context->
        p_p_csc_context[p_ue_context->cell_index]->
        p_csc_init_setup_ind->sib_type_1_Info.
        cell_access_related_info.plmn_Id_info_list.count;

    /*MOCN SPR 21988 Fix Start*/
    uecc_s1ap_generate_plmn_identity_to_int(
            &(plmn_identity),
            p_ue_context->gummei.plmn_identity.data
            );
    /*MOCN SPR 21988 Fix End*/

    for (plmn_count = RRC_NULL; plmn_count < sib1_plmn_count; plmn_count++)
    {
        //if(RRC_NULL == memcmp_wrapper(&p_ue_context->plmn_identity.plmn_identity,
        /*MOCN SPR 21988 Fix Start*/
        if(RRC_NULL == memcmp_wrapper(&plmn_identity,
                    /*MOCN SPR 21988 Fix End*/
                    &p_ue_context->p_gb_context->
                    p_p_csc_context[p_ue_context->cell_index]->
                    p_csc_init_setup_ind->sib_type_1_Info.
                    cell_access_related_info.plmn_Id_info_list.
                    plmn_identity_info[plmn_count].plmn_identity,
                    sizeof(p_ue_context->plmn_identity.plmn_identity)))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_INFO,
                    "[uecc_llim_search_plmn_idx_in_sib1] "
                    "plmn_identity is matched at [%u] index",plmn_count);
            *p_plmn_idx_sib1 = plmn_count;
            plmn_identity_flag = RRC_SUCCESS;
            break;
        }
    }

    return plmn_identity_flag;
}
/* SPR 23209 FIXED END */



#ifdef ENDC_ENABLED
/*NR_DC Code Change Start*/
/******************************************************************************
 *   FUNCTION NAME: uecc_llim_build_nr_rrc_connection_reconfig_r15_ies
 *   INPUT        : OSCTXT*      p_asn1_ctx,
 *                  RRCConnectionReconfiguration_r8_IEs*    p_r8
 *                  uecc_ue_context_t*    p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function fills RRCConnectionReconfiguration-v1510-r15 IEs.
 *
 *   RETURNS:
 *
 ******************************************************************************/
void uecc_llim_build_nr_rrc_connection_reconfig_r15_ies(
        OSCTXT*                                 p_asn1_ctx,
        RRCConnectionReconfiguration_r8_IEs*    p_r8,     
        uecc_ue_context_t*    p_uecc_ue_context,
        uecc_currcent_proc_et current_proc
        )
{
    U8      erab_id = RRC_ZERO;
    U8      erab_index = RRC_ZERO;
    U8      erab_count = RRC_ZERO;
    U8      ics_rab_count = RRC_ZERO;
    rrc_bool_et is_scg_bearer_present = RRC_FALSE;

    RRCConnectionReconfiguration_v1510_IEs *p_rrc_reconf_r15 = PNULL;
    RRCConnectionReconfiguration_v1510_IEs_nr_Config_r15_setup
        *p_nr_conf_setup = PNULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_r8);
    RRC_ASSERT(PNULL != p_asn1_ctx);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    if(RRC_NULL != p_uecc_ue_context->p_curr_proc_data)
    {
        if(ERAB_SETUP == current_proc && 
                UECC_ERAB_SETUP_PROC == p_uecc_ue_context->p_curr_proc_data->t &&
                0 < p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                erab_info_data.count)
        {
            erab_count = p_uecc_ue_context->p_curr_proc_data->u.
                erab_setup_request_data.erab_info_data.count;
        }
        else if(ERAB_RELEASE == current_proc &&
                0 < p_uecc_ue_context->p_curr_proc_data->u.
                erab_release_command_data.erab_release_list.counter)
        {
            erab_count = p_uecc_ue_context->p_curr_proc_data->u.
                erab_release_command_data.erab_release_list.counter;
        }
        else if(ICS_SETUP == current_proc &&
                UECC_ICS_PROC == p_uecc_ue_context->p_curr_proc_data->t)
        {
            erab_count = p_uecc_ue_context->e_rab_list_count;
        }
        /*OPTION3X Changes start*/
        else if(ERAB_SETUP == current_proc &&
                UECC_RRM_DC_BEARER_CHANGE_PROC == p_uecc_ue_context->p_curr_proc_data->t &&
                0 < p_uecc_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data.
                drb_to_modify_list.drb_count)
        {
            erab_count = p_uecc_ue_context->p_curr_proc_data->u.
                rrm_dc_bearer_change_request_data.drb_to_modify_list.drb_count;
        }
        /*OPTION3X Changes stop*/
        else if ( ( p_uecc_ue_context->sgnbInitiatedSgnbReleaseFlag ) &&
            ( ERAB_RELEASE == current_proc ))
        {
            erab_count = p_uecc_ue_context->endc_erab_release_list.counter;
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING, "[RRC CONNECTION RECONFIG R15] for erab release"
                   );
        }
        else if ( ( ERAB_RELEASE == current_proc ) &&
             ( RRC_FALSE == p_uecc_ue_context->sgnbInitiatedSgnbReleaseFlag ) )          
        {
            erab_count = p_uecc_ue_context->endc_erab_release_list.counter;
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_DETAILED, "[RRC CONNECTION RECONFIG R15] for erab release"
                   );
        }
        else
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL, "[RRC CONNECTION RECONFIG R15]"
                    "INVALID current proc[%d] of Ue Context[%d]",
                    p_uecc_ue_context->p_curr_proc_data->t,
                    p_uecc_ue_context->ue_index);

            return;
        }

        if(ICS_SETUP != current_proc &&
              UECC_ICS_PROC != p_uecc_ue_context->p_curr_proc_data->t)
        {
            if ( (( ERAB_RELEASE == current_proc ) &&
                        ( UECC_ERAB_RELEASE_PROC == p_uecc_ue_context->p_curr_proc_data->t )))
            {
                for(ics_rab_count = RRC_ZERO; ics_rab_count < RRC_MAX_NUM_DRB;
                        ics_rab_count++)
                {
                    if(PNULL != p_uecc_ue_context->p_e_rab_list[ics_rab_count])
                    {
                        erab_id = p_uecc_ue_context->p_e_rab_list[ics_rab_count]->e_RAB_ID;

                        if(RRC_ONE == p_uecc_ue_context->p_e_rab_list[erab_id]->
                                m.DC_BearerTypePresent &&
                                (SN_TERMINATED_SCG_BEARER ==
                                 p_uecc_ue_context->p_e_rab_list[erab_id]->dc_bearer_type
                                 /*OPTION3X Changes Start*/
                                 || SN_TERMINATED_SPLIT_BEARER ==
                                 p_uecc_ue_context->p_e_rab_list[erab_id]->dc_bearer_type)
                                /*OPTION3X Changes Stop*/
                          )
                        {
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_DETAILED, "[RRC CONNECTION RECONFIG R15]"
                                    "ERAB ID[%d] of Ue Context[%d] is SCG Bearer",
                                    erab_id, p_uecc_ue_context->ue_index);

                            is_scg_bearer_present = RRC_TRUE;
                            break;
                        }
                        else
                        {
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_DETAILED, "[RRC CONNECTION RECONFIG R15]"
                                    "ERAB ID[%d] of Ue Context[%d] is MCG Bearer",
                                    erab_id, p_uecc_ue_context->ue_index);
                            continue;
                        }
                    }
                }
            }
            else
            {
                /*check if any of the erab in the current_proc is SN_TERMINATED_SCG_BEARER
                 * then include the R15 IEs, else return*/
                for( erab_index = 0; erab_index < erab_count &&
                        erab_index < RRC_MAX_NUM_DRB; erab_index++)
                {
                    if(ERAB_SETUP == current_proc &&
                            UECC_ERAB_SETUP_PROC == p_uecc_ue_context->p_curr_proc_data->t)
                    {
                        erab_id = p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                            erab_info_data.erab_info[erab_index].erab_id;
                    }
                    else if(((ERAB_RELEASE == current_proc) &&
                            ( UECC_ERAB_RELEASE_PROC == p_uecc_ue_context->p_curr_proc_data->t)) &&
                            ( RRC_FALSE == p_uecc_ue_context->sgnbInitiatedSgnbReleaseFlag ))
                    {
                        erab_id = p_uecc_ue_context->p_curr_proc_data->u.erab_release_command_data.
                            erab_release_list.erab_item[erab_index].e_RAB_ID;
                    }
                    /*OPTION3X Changes Start*/
                    else if(ERAB_SETUP == current_proc &&
                            UECC_RRM_DC_BEARER_CHANGE_PROC == p_uecc_ue_context->p_curr_proc_data->t)
                    {
                        erab_id = p_uecc_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data.
                            drb_to_modify_list.drb_config[erab_index].erab_id;
                    }
                    /*OPTION3X Changes Stop*/
                    /*check if the erab_id is SN_TERMINATED_SCG_BEARER then include the R15*/
                    if(PNULL != p_uecc_ue_context->p_e_rab_list[erab_id])
                    {
                        if(RRC_ONE == p_uecc_ue_context->p_e_rab_list[erab_id]->
                                m.DC_BearerTypePresent &&
                                (SN_TERMINATED_SCG_BEARER == 
                                 p_uecc_ue_context->p_e_rab_list[erab_id]->dc_bearer_type 
                                 /*OPTION3X Changes Start*/
                                 || SN_TERMINATED_SPLIT_BEARER == 
                                 p_uecc_ue_context->p_e_rab_list[erab_id]->dc_bearer_type)
                                /*OPTION3X Changes Stop*/
                          )
                        {
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_DETAILED, "[RRC CONNECTION RECONFIG R15]"
                                    "ERAB ID[%d] of Ue Context[%d] is SCG Bearer",
                                    erab_id, p_uecc_ue_context->ue_index);

                            is_scg_bearer_present = RRC_TRUE;
                            break;
                        }
                        else
                        {
#if 0
                            if(ERAB_SETUP == current_proc &&
                                    UECC_ERAB_SETUP_PROC == p_uecc_ue_context->p_curr_proc_data->t)
                            {
                                erab_id = p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                                    erab_info_data.erab_info[erab_index].erab_id;
                            }
                            else if((ERAB_RELEASE == current_proc) &&
                                    ( UECC_ERAB_RELEASE_PROC == p_uecc_ue_context->p_curr_proc_data->t ) &&
                                    ( RRC_FALSE == p_uecc_ue_context->sgnbInitiatedSgnbReleaseFlag ))
                            {
                                erab_id = p_uecc_ue_context->p_curr_proc_data->u.erab_release_command_data.
                                    erab_release_list.erab_item[erab_index].e_RAB_ID;
                            }
                            /*OPTION3X Changes Start*/
                            else if(ERAB_SETUP == current_proc &&
                                    UECC_RRM_DC_BEARER_CHANGE_PROC == p_uecc_ue_context->p_curr_proc_data->t)
                            {
                                erab_id = p_uecc_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data.
                                    drb_to_modify_list.drb_config[erab_index].erab_id;
                            }
                            /*OPTION3X Changes Stop*/

                            /*check if the erab_id is SN_TERMINATED_SCG_BEARER then include the R15*/
                            if(PNULL != p_uecc_ue_context->p_e_rab_list[erab_id])
                            {
                                if(RRC_ONE == p_uecc_ue_context->p_e_rab_list[erab_id]->
                                        m.DC_BearerTypePresent &&
                                        (SN_TERMINATED_SCG_BEARER == 
                                         p_uecc_ue_context->p_e_rab_list[erab_id]->dc_bearer_type 
                                         /*OPTION3X Changes Start*/
                                         || SN_TERMINATED_SPLIT_BEARER == 
                                         p_uecc_ue_context->p_e_rab_list[erab_id]->dc_bearer_type)
                                        /*OPTION3X Changes Stop*/
                                  )
                                {
                                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                            (p_uecc_ue_context->p_gb_context)->facility_name,
                                            RRC_DETAILED, "[RRC CONNECTION RECONFIG R15]"
                                            "ERAB ID[%d] of Ue Context[%d] is SCG Bearer",
                                            erab_id, p_uecc_ue_context->ue_index);

                                    is_scg_bearer_present = RRC_TRUE;
                                    break;
                                }
                                else
                                {
                                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                            (p_uecc_ue_context->p_gb_context)->facility_name,
                                            RRC_DETAILED, "[RRC CONNECTION RECONFIG R15]"
                                            "ERAB ID[%d] of Ue Context[%d] is MCG Bearer",
                                            erab_id, p_uecc_ue_context->ue_index);
                                    continue;
                                }
                            }
#endif
                        	RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                	(p_uecc_ue_context->p_gb_context)->facility_name,
                                	RRC_DETAILED, "[RRC CONNECTION RECONFIG R15]"
                                	"ERAB ID[%d] of Ue Context[%d] is MCG Bearer",
                                	erab_id, p_uecc_ue_context->ue_index);
                        	continue;
                        }
                        }
                    else
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_DETAILED, "[RRC CONNECTION RECONFIG R15]"
                                "erabid[%d]",
                                erab_id);
                    }
                }
            }
        }
        else
        {
            for(ics_rab_count = RRC_ZERO; ics_rab_count < RRC_MAX_NUM_DRB;
                    ics_rab_count++)
            {
                if(PNULL != p_uecc_ue_context->p_e_rab_list[ics_rab_count])
                {
                    erab_id = p_uecc_ue_context->p_e_rab_list[ics_rab_count]->e_RAB_ID;

                    if(RRC_ONE == p_uecc_ue_context->p_e_rab_list[erab_id]->
                            m.DC_BearerTypePresent &&
                            (SN_TERMINATED_SCG_BEARER ==
                             p_uecc_ue_context->p_e_rab_list[erab_id]->dc_bearer_type
                             /*OPTION3X Changes Start*/
                             || SN_TERMINATED_SPLIT_BEARER ==
                             p_uecc_ue_context->p_e_rab_list[erab_id]->dc_bearer_type)
                            /*OPTION3X Changes Stop*/
                      )
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_DETAILED, "[RRC CONNECTION RECONFIG R15]"
                                "ERAB ID[%d] of Ue Context[%d] is SCG Bearer",
                                erab_id, p_uecc_ue_context->ue_index);

                        is_scg_bearer_present = RRC_TRUE;
                        break;
                    }
                    else
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_DETAILED, "[RRC CONNECTION RECONFIG R15]"
                                "ERAB ID[%d] of Ue Context[%d] is MCG Bearer",
                                erab_id, p_uecc_ue_context->ue_index);
                        continue;
                    }
                }
            }
        }

        if(RRC_TRUE == is_scg_bearer_present)
        {
            p_r8->m.nonCriticalExtensionPresent = 1;
            p_r8->nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
            p_r8->nonCriticalExtension.nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
            p_r8->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.\
                m.nonCriticalExtensionPresent = 1;
            p_r8->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.\
                nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
            p_r8->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.\
                nonCriticalExtension.nonCriticalExtension.m.nonCriticalExtensionPresent = 1;
            p_r8->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.\
                nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.\
                m.nonCriticalExtensionPresent = 1;
            p_r8->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.\
                nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.\
                nonCriticalExtension.m.nonCriticalExtensionPresent = 1;


            p_rrc_reconf_r15 = (RRCConnectionReconfiguration_v1510_IEs *)
                &(p_r8->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.\
                        nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.\
                        nonCriticalExtension.nonCriticalExtension);

            /* Fill nr_Config_r15 */
            {
                p_nr_conf_setup = 
                    rtxMemAllocType(p_asn1_ctx, 
                            RRCConnectionReconfiguration_v1510_IEs_nr_Config_r15_setup);
                if (PNULL == p_nr_conf_setup)
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,
                            "[RRCConnectionReconfiguration] ASN malloc failed.");
                    return;
                }
                p_rrc_reconf_r15->m.nr_Config_r15Present = RRC_ONE;

                /*check the current proc in the ue context*/
                if((ERAB_SETUP == current_proc &&
                            UECC_ERAB_SETUP_PROC == p_uecc_ue_context->p_curr_proc_data->t) ||
                        (ICS_SETUP == current_proc &&
                         UECC_ICS_PROC == p_uecc_ue_context->p_curr_proc_data->t)
                        /*OPTION3X Changes Start*/
                        || (ERAB_SETUP == current_proc &&
                            UECC_RRM_DC_BEARER_CHANGE_PROC == p_uecc_ue_context->p_curr_proc_data->t)
                        /*OPTION3X Changes Stop*/
                  )
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_DETAILED, "[RRC CONNECTION RECONFIG R15]"
                            "NR CONFIG R15 SETUP is included");

                    p_rrc_reconf_r15->nr_Config_r15.t = 
                        T_RRCConnectionReconfiguration_v1510_IEs_nr_Config_r15_setup;
                    p_rrc_reconf_r15->nr_Config_r15.u.setup = p_nr_conf_setup;
                    asn1Init_RRCConnectionReconfiguration_v1510_IEs_nr_Config_r15_setup(
                            p_nr_conf_setup);

                    /*populate endc-ReleaseAndAdd-r15*/
                    /* Since not Using SRB3 for RRCConnectionReconfiguration Msg*/
                    p_rrc_reconf_r15->nr_Config_r15.u.setup->endc_ReleaseAndAdd_r15 = RRC_FALSE;

                    if(PNULL == p_uecc_ue_context->p_sn_cg_config)
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_FATAL, "[RRC CONNECTION RECONFIG R15]"
                                "CG Config in Ue Context[%d] is NULL",p_uecc_ue_context->ue_index);
                        return;
                    }

                    /*populate nr-SecondaryCellGroupConfig-r15*/
                    if ( p_uecc_ue_context->p_sn_cg_config->bitmask & 
                            X2AP_SN_CG_CONFIG_SCG_CELLGROUP_CONFIG_PRESENT )
                    {
                        p_rrc_reconf_r15->nr_Config_r15.u.setup->m.nr_SecondaryCellGroupConfig_r15Present =
                            RRC_ONE;
                        p_rrc_reconf_r15->nr_Config_r15.u.setup->nr_SecondaryCellGroupConfig_r15.numocts =
                            p_uecc_ue_context->p_sn_cg_config->scg_CellGroupConfig.numocts;

                        if(PNULL ==
                                (p_rrc_reconf_r15->nr_Config_r15.u.setup->nr_SecondaryCellGroupConfig_r15.data =
                                 (OSOCTET*)
                                 (rrc_mem_get(p_rrc_reconf_r15->nr_Config_r15.u.setup->\
                                              nr_SecondaryCellGroupConfig_r15.numocts))))
                        {
                            RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                                    p_uecc_ue_context->p_gb_context->facility_name,
                                    RRC_FATAL, "[Process RC CONNECTION RECONFIG R15]"
                                    "Memory Allocation Failed");
                            return;
                        }

                        l3_memcpy_wrapper(
                                (U8*)p_rrc_reconf_r15->nr_Config_r15.u.setup->nr_SecondaryCellGroupConfig_r15.data,
                                (const U8*)p_uecc_ue_context->p_sn_cg_config->scg_CellGroupConfig.data,
                                p_rrc_reconf_r15->nr_Config_r15.u.setup->nr_SecondaryCellGroupConfig_r15.numocts
                                );
                    }

                    /*populate p-MaxEUTRA-r15*/
                    if (SIB_TYPE_1_P_MAX_PRESENCE_FLAG &
                            p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                            cell_index]->p_csc_init_setup_ind->sib_type_1_Info.presence_bitmask)
                    {
                        p_rrc_reconf_r15->nr_Config_r15.u.setup->m.p_MaxEUTRA_r15Present = 1;

                        p_rrc_reconf_r15->nr_Config_r15.u.setup->p_MaxEUTRA_r15 =
                            p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->
                            cell_index]->p_csc_init_setup_ind->sib_type_1_Info.p_max;
                    }

                    /* Fill sk_Counter_r15 */
                    p_rrc_reconf_r15->m.sk_Counter_r15Present = RRC_ONE;
                    p_rrc_reconf_r15->sk_Counter_r15 = (OSUINT16)p_uecc_ue_context->sk_counter_r15;


                    /* Fill nr_RadioBearerConfig1_r15 */
                    if ( p_uecc_ue_context->p_sn_cg_config->bitmask & 
                            X2AP_SN_CG_CONFIG_SCG_RB_CONFIG_PRESENT )
                    {
                        p_rrc_reconf_r15->m.nr_RadioBearerConfig1_r15Present = RRC_ONE;

                        p_rrc_reconf_r15->nr_RadioBearerConfig1_r15.numocts = 
                            p_uecc_ue_context->p_sn_cg_config->scg_RB_Config.numocts;

                        if(PNULL ==
                                (p_rrc_reconf_r15->nr_RadioBearerConfig1_r15.data =
                                 (OSOCTET*)
                                 (rrc_mem_get(p_rrc_reconf_r15->nr_RadioBearerConfig1_r15.numocts))))
                        {
                            RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                                    p_uecc_ue_context->p_gb_context->facility_name,
                                    RRC_FATAL, "[Process RC CONNECTION RECONFIG R15]"
                                    "Memory Allocation Failed");
                            return;
                        }

                        l3_memcpy_wrapper(
                                (U8*)p_rrc_reconf_r15->nr_RadioBearerConfig1_r15.data,
                                (const U8*)p_uecc_ue_context->p_sn_cg_config->scg_RB_Config.data,
                                p_rrc_reconf_r15->nr_RadioBearerConfig1_r15.numocts
                                );
                    }
                }
                else if(ERAB_RELEASE == current_proc)
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_DETAILED, "[RRC CONNECTION RECONFIG R15]"
                            "NR CONFIG R15 RELEASE is included");

                    p_rrc_reconf_r15->nr_Config_r15.t = 
                        T_RRCConnectionReconfiguration_v1510_IEs_nr_Config_r15_release;

                    p_uecc_ue_context->is_sgnb_add_reqd = RRC_FALSE;
                }
            }
        }
        else
        {
            /*is_scg_bearer_present is not true*/
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_DETAILED, "[RRC CONNECTION RECONFIG R15]"
                    "SCG NR R15 is not present");
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}
/*NR_DC Code Change Stop*/

/*OPTION3X Changes Start*/
/****************************************************************************
 * Function Name  : uecc_llim_build_and_send_delete_new_lc_s1u_reconfig_req
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : rrc_return_t 
 * Description:    This is the function for building and sending
 *                   UECC_LLIM_S1U_RECONFIG_REQ to delete NEW LC on S1U during
 *                   DC_BEARER_CHANGE_PROC
 ****************************************************************************/

rrc_return_t uecc_llim_build_and_send_delete_new_lc_s1u_reconfig_req(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    U8 count= RRC_NULL;
    U8 drb_count= RRC_NULL;
    rrc_return_et                   result = RRC_FAILURE;
    rrc_drb_to_modify_list_t*       p_drb_to_modify_list    = PNULL;
    rrc_uecc_llim_s1u_reconfigure_req_t rrc_uecc_llim_s1u_reconfigure_req;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    
    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
            (p_uecc_ue_context->p_gb_context)->facility_name,
            RRC_DETAILED, "[%s][%d]", __func__, __LINE__);

    memset_wrapper(&rrc_uecc_llim_s1u_reconfigure_req, 0, 
            sizeof(rrc_uecc_llim_s1u_reconfigure_req_t));

    /* ue_index */
    rrc_uecc_llim_s1u_reconfigure_req.ue_index =  p_uecc_ue_context->ue_index;
    rrc_uecc_llim_s1u_reconfigure_req.cell_index =  p_uecc_ue_context->cell_index;

    /* Transaction ID */
    rrc_uecc_llim_s1u_reconfigure_req.transaction_id =
        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context);

    /* bitmask */
    rrc_uecc_llim_s1u_reconfigure_req.bitmask |=
        RRC_UECC_LLIM_S1U_REL_SAP_REQ_LIST_PRESENT;

    if( (PNULL != p_uecc_ue_context->p_curr_proc_data) &&         
            UECC_RRM_DC_BEARER_CHANGE_PROC ==                          
            p_uecc_ue_context->p_curr_proc_data->t)                    
    {
        p_drb_to_modify_list =                                    
            &p_uecc_ue_context->p_curr_proc_data->u.              
            rrm_dc_bearer_change_request_data.drb_to_modify_list; 

        for(count = 0; count < p_drb_to_modify_list->drb_count; count++)
        {
            if(RRC_TRUE == p_drb_to_modify_list->drb_config[count].erab_failed)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_DETAILED, "DC Beraer Change for New DRB ID[%d] with "
                        "new_lc_id[%d] and old_lc_id[%d] has failed",
                        p_drb_to_modify_list->drb_config[count].new_drb_id,
                        p_drb_to_modify_list->drb_config[count].new_lc_id,
                        p_drb_to_modify_list->drb_config[count].old_lc_id);

                rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.rel_sap_req[drb_count].
                    lc_id = p_drb_to_modify_list->drb_config[count].new_lc_id;

                drb_count++;
            }
        }
        rrc_uecc_llim_s1u_reconfigure_req.rel_sap_req_list.num_rel_sap_req = drb_count;
    }

    result = uecc_rrc_send_internal_msg(RRC_LLIM_MODULE_ID,
            UECC_LLIM_S1U_RECONFIGURE_REQ,
            sizeof(rrc_uecc_llim_s1u_reconfigure_req_t),
            &rrc_uecc_llim_s1u_reconfigure_req);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}
/*OPTION3X Changes Stop*/
#endif
