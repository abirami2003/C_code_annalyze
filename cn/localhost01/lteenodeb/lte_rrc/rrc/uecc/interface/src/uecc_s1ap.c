/******************************************************************************
 *
 *   FILE NAME:
 *       uecc_s1ap.c
 *
 *   DESCRIPTION:
 *       This is the source file of the UECC S1AP.
 *
 *   DATE            AUTHOR      REFERENCE       REASON
 *   28 Jul 2009     AndriyT     ---------       Initial
 *
 *   Copyright (c) 2009, Aricent Inc. All Rights Reserved
 *
 ******************************************************************************/

/****************************************************************************
 * Includes
 ****************************************************************************/
#include "uecc_s1ap.h"
#include "uecc_global_ctx.h"
#include "rrc_msg_mgmt.h"
#include "uecc_mainfsm.h"
#include "uecc_logger.h"

#include "uecc_fsm_engine.h"
#include "uecc_fsm_common.h"
#include "rrc_s1ap_asn_intrl_dec_3gpp.h"
#include "rrc_s1ap_asn_intrl_enc_3gpp.h"
/* + SPR 15630 */
#include "InformationElements.h"
#include "Constant-definitions.h"
#include "InformationElements_1.h"
#include "InformationElements_2.h"
#include "InformationElements_3.h"
#include "Internode-definitions.h"
#include "PDU-definitions.h"
#include "PDU-definitions_1.h"
/* - SPR 15630 */
#include "rrc_intrl_api.h"
#include "rrc_s1ap_uecc_intf.h"
#include "uecc_llim_utils.h"
#include "uecc_llim.h"
#include "rrc_rrm_intf.h"
#include "rrc_s1ap_asn_intrl_3gpp.h"
#include "rrc_uecc_error_indication.h"
#include "uecc_common.h"
#include "rrc_oamh_intf.h"
#include "uecc_statistic.h"
#include "uecc_rrm.h"
#include "uecc_llim.h"
#include "rrc_common_md.h"
#include "rrc_shared_stats.h"
#include "rrc_common_utils.h"
#include "s1ap_asn_enc_dec_3gpp.h"
#include "rrc_logging.h"
/* CR 101 changes start*/
#include "rrc_mac_intf.h"
/* CR 101 changes stop*/
#include <rrc_porting.h>
/*SPR 19592 FIX START*/
#include <rrc_cp_common.h>
/*SPR 19592 FIX END*/
#include <lteMisc.h>

/* SPR 20635 Fix - SRVCC to GERAN - Starts */
/* Source BSS to Target BSS Transparent Container Parameters IEs - Starts */
#define SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_IE           0x64
#define SOURCE_BSS_TARGET_BSS_MS_RADIO_ACCESS_CAPABILITY_IE         0x13
#define SOURCE_BSS_TARGET_BSS_PAGE_MODE_IE                          0x6D
#define SOURCE_BSS_TARGET_BSS_CONTAINER_ID_IE                       0x6E
#define SOURCE_BSS_TARGET_BSS_GLOBAL_TFI_IE                         0x6F
#define SOURCE_BSS_TARGET_BSS_INTER_RAT_HANDOVER_INFO_IE            0x73
#define SOURCE_BSS_TARGET_BSS_PS_HANDOVER_INDICATION_IE             0x75
#define SOURCE_BSS_TARGET_BSS_CS_INDICATION_IE                      0x7A
/*SPR 14320 Fix Start*/
#define SOURCE_BSS_TARGET_BSS_E_UTRAN_INTER_RAT_HANDOVER_INFO_IE    0x80
/*SPR 14320 Fix End*/
#define SOURCE_BSS_TARGET_BSS_IRAT_MEASUREMENT_CONFIGURATION_IE     0x8B
#define SOURCE_BSS_TARGET_BSS_SOURCE_CELL_ID_IE                     0x90
/* Source BSS to Target BSS Transparent Container Parameters IEs - Ends */

/* Old BSS to New BSS Information Parameters IEs - Starts */
#define OLD_BSS_TO_NEW_BSS_INFORMATION_IE                   0x3A
#define OLD_BSS_NEW_BSS_EXTRA_INFORMATION_IE                0x01
#define OLD_BSS_NEW_BSS_EXTRA_INFORMATION_LENGTH            0x01
#define OLD_BSS_NEW_BSS_CURRENT_CHANNEL_TYPE_2_IE           0x02
#define OLD_BSS_NEW_BSS_CURRENT_CHANNEL_TYPE_2_LENGTH       0x02
#define OLD_BSS_NEW_BSS_TARGET_CELL_RADIO_INFORMAION_IE     0x03
#define OLD_BSS_NEW_BSS_TARGET_CELL_RADIO_INFORMAION_LENGTH 0x01
#define OLD_BSS_NEW_BSS_INTER_RAT_HANDOVER_INFO_IE          0x07
#define OLD_BSS_NEW_BSS_CDMA2000_CAPABILITY_INFO_IE         0x08
#define OLD_BSS_NEW_BSS_PS_INDICATION_IE                    0x0D
#define OLD_BSS_NEW_BSS_PS_INDICATION_LENGTH                0x01
#define OLD_BSS_NEW_BSS_IRAT_MEASUREMENT_CONFIGURATION_IE   0x0F
#define OLD_BSS_NEW_BSS_SOURCE_CELL_ID_IE                   0x10
/* Old BSS to New BSS Information Parameters IEs - Ends */

/* Target BSS to Source BSS Transparent Container Parameters IEs - Starts */
#define TARGET_BSS_TO_SOURCE_BSS_TRANSPARENT_CONTAINER_IE   0x65
#define TARGET_BSS_SOURCE_BSS_PS_HANDOVER_COMMAND_IE        0x74
#define TARGET_BSS_SOURCE_BSS_SI_PSI_CONTAINER_IE           0x76
#define TARGET_BSS_SOURCE_BSS_DTM_HANDOVER_COMMAND_IE       0x79
/* Target BSS to Source BSS Transparent Container Parameters IEs - Ends */

/* New BSS to Old BSS Information Parameters IEs - Starts */
#define NEW_BSS_TO_OLD_BSS_INFORMATION_IE                   0x61
#define NEW_BSS_OLD_BSS_DOWNLINK_CELL_LOAD_INFO_IE          0x09
#define NEW_BSS_OLD_BSS_UPLINK_CELL_LOAD_INFO_IE            0x0A
#define NEW_BSS_OLD_BSS_DTM_HO_COMMAND_INDICATION_IE        0x0E
#define NEW_BSS_OLD_BSS_LAYER_3_INFORMATION_IE              0x17
/* New BSS to Old BSS Information Parameters IEs - Ends */

#define MS_CLASSMARK_2_IE           0x12
#define MS_CLASSMARK_3_IE           0x13
#define MS_CLASSMARK_2_OCTETS       0x05
#define MS_CLASSMARK_2_LENGTH       0x03
#define PSI_TYPE                    0x01
#define PSI_MSG_LENGTH_IN_OCTETS    0x16
#define SI_MSG_LENGTH_IN_OCTETS     0x15
#define HEADER_IE_PLUS_LENGTH       0x02
/* SPR 20635 Fix - SRVCC to GERAN - Ends */

#define USER_MESSAGE_BUFFER_SIZE            1000
#define IE_CRITICALITY_DIAGNOSTICS_PRESENT  1
#define NORMAL_IE_LEN                       100
#define MAX_IE_LEN                          100
#define MAX_DATE_LEN                        85
#define MAX_NAME_LEN                        80
#define MAX_FILE_LEN                        256
#define SEVEN                               7
#define TWO                                 2
/* cr_745 macro */
#define RRC_S1AP_SET_MEMBER                 1
/* cr_592 macro */
#define CSG_ID_BITSTRING_SIZE               27
/* cr_726 macro */
#define EUTRAN_TRACE_ID_VAL_CHECK           3
#define MAX_TRACE_ID_VAL                    0x09 
#define CSG_RESET_VAL                       0xE0
/*SPR 19592 FIX START*/
#define NUM_OCTET                           127
/*SPR 19592 FIX END*/

static U8 start_trace_count;
static U8 de_trace_count;

extern uecc_fsm_activity_state_t uecc_fsm_ue_connection_release_ongoing;
extern void fill_s1ap_fail_cause(uecc_ue_context_t *p_ue_context, U32 *p_fail_cause);

typedef enum
{
    INITIAL_CTX_SETUP_RESPONSE,
    ERAB_SETUP_RESPONSE
} rrc_uecc_calling_proc_et;

/****************************************************************************
 * Local Functions Prototypes
 ****************************************************************************/

/*SPR 15896 Fix Start*/
static void rrc_trace_max_fprintf( uecc_ue_context_t *p_ue_context, 
                  U8 interface, U32 buffer_len,  U8 *buffer);
/*SPR 15896 Fix Stop*/

void uecc_s1ap_ue_assoc_msg_max_trace_handler( 
              uecc_ue_context_t  *p_ue_context, 
              U8                 *buffer, 
              U32                buffer_len,
              char               *msg_name,
              U8                 recv_or_send);

static rrc_return_et uecc_s1ap_build_E_RABSetupListCtxtSURes(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        s1ap_E_RABSetupListCtxtSURes *p_e_rab_setup_list
        );

static rrc_return_et uecc_s1ap_build_e_rab_failed_to_setup_list(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        s1ap_E_RABList *p_list,
        rrc_uecc_calling_proc_et calling_proc
        );

static void uecc_s1ap_generate_plmn_identity_int(
        OSOCTET                 *p_s1ap_plmn_identity,
        plmn_identity_t    *p_plmn_identity);

static rrc_return_et uecc_s1ap_build_s1ap_e_rab_admitted_list
(
 uecc_ue_context_t* p_ue_context,
 OSCTXT *p_asn1_ctx,
 s1ap_E_RABAdmittedList *p_e_rab_admitted_list
 );
static rrc_return_et uecc_s1ap_build_E_RABReleaseListBearerRelComp(
        uecc_ue_context_t* p_ue_context,
        OSCTXT* p_asn1_ctx,
        s1ap_E_RABReleaseListBearerRelComp* p_e_rab_release_list
        );
/*srvcc-u start*/
static rrc_return_et uecc_s1ap_build_s1ap_Irat_meas_config_info(
        rrm_source_rnc_to_target_rnc_transparent_container_t *p_rnc_container,
        OSCTXT                      *p_asn1_ctx,
        ranap_IRAT_Measurement_Configuration  *p_asn_irat_meas_config,
        uecc_ue_context_t           *p_ue_context);
static rrc_return_et  uecc_s1ap_IRAT_meas_config_info_intrnl_enc(
        uecc_ue_context_t               *p_ue_context,
        OSCTXT                          *pctxt,
        ranap_ProtocolExtensionField    *p_elem,
        ranap_IRAT_Measurement_Configuration  *p_irat_meas_config);
/*srvcc-u stop*/

static rrc_return_et uecc_s1ap_build_s1ap_e_rab_failed_to_setup_list
(
 uecc_ue_context_t* p_ue_context,
 OSCTXT *p_asn1_ctx,
 s1ap_E_RABFailedtoSetupListHOReqAck *p_e_rab_failed_to_setup_list
 );


static rrc_return_et uecc_s1ap_build_e_rab_failed_to_release_list(
        uecc_ue_context_t* p_ue_context,
        OSCTXT* p_asn1_ctx,
        s1ap_E_RABList* p_list
        );

static rrc_return_et uecc_s1ap_build_rrc_ho_command(
        uecc_ue_context_t   *p_uecc_ue_context, /* CSR 101813 Fix Start */
        void            *p_transparent_container,/*CSR 101813 Fix Stop */
        OSCTXT         *pctxt
        );

static rrc_return_et uecc_s1ap_build_s1ap_TargeteNB_ID(
        rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required, 
        OSCTXT            *p_asn1_ctx,
        s1ap_TargeteNB_ID *p_target_enb_id,
        uecc_ue_context_t *p_ue_context
        );

rrc_return_et uecc_s1ap_build_HandoverPreparationInformation(
        uecc_ue_context_t *p_ue_context,
        OSCTXT            *p_asn1_ctx,
        HandoverPreparationInformation_r8_IEs  *p_handover_prep_info
        );

static rrc_return_et uecc_s1ap_build_UE_CapabilityRAT_ContainerList(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        UE_CapabilityRAT_ContainerList *p_ue_capability_list 
        );

static rrc_return_et uecc_s1ap_build_AdditionalReestabInfoList(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        AdditionalReestabInfoList *p_additional_re_estab_list 
        );

static rrc_return_et uecc_s1ap_build_s1ap_E_RABInformationList(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        s1ap_E_RABInformationList *p_erab_info_list
        );
static rrc_return_et uecc_s1ap_build_e_rab_failed_to_modify_list(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        s1ap_E_RABList *p_list
        );
static rrc_return_et uecc_s1ap_build_e_rab_released_list_arp(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        s1ap_E_RABList *p_list,
        erab_list_t* p_erab_list
        );

static rrc_return_et uecc_s1ap_build_e_rab_released_list(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        s1ap_E_RABList *p_list
        );

static rrc_return_et uecc_s1ap_build_s1ap_UE_HistoryInformation
(
 ue_history_t                *p_ue_history_at_rrc_rrm_intf,
 OSCTXT                      *p_asn1_ctx,
 s1ap_UE_HistoryInformation  *p_ue_history_info,
 uecc_ue_context_t           *p_ue_context
 );

static rrc_return_et uecc_s1ap_build_enb_status_transfer_transparent_container
(
 uecc_ue_context_t* p_ue_context,
 rrc_uecc_llim_sn_hfn_status_resp_t  *p_sn_hfn_status_resp,
 OSCTXT *p_asn1_ctx,
 s1ap_ENB_StatusTransfer_TransparentContainer *p_enb_status_transfer_transparent_container
 );    

static rrc_return_et uecc_m_check_and_convert_sib1
(
 OSCTXT                      *pctxt,             /* for memory allocation */
 SystemInformationBlockType1 *p_asn1_sib1,       /* destination */
 sib_type_1_Info_t           *p_sib1,           /* source */
 uecc_ue_context_t           *p_ue_context
 );

static rrc_return_et check_and_convert_sib1_cell_ari
(
 /* for memory allocation */
 OSCTXT                                                      *pctxt,
 /* destination */
 SystemInformationBlockType1_cellAccessRelatedInfo           *p_asn1_cell_ari
 ,
 /* source */
 cell_access_related_info_t                                  *p_cell_ari,
 uecc_ue_context_t                                           *p_ue_context
 );

static rrc_return_et check_and_convert_sib1_sched_inf
(
 OSCTXT                     *pctxt,             /* for memory allocation */
 SchedulingInfoList         *p_asn1_sched_inf,  /* destination */
 scheduling_info_list_t      *p_sched_inf,       /* source */
 uecc_ue_context_t           *p_ue_context
 );

static rrc_return_et uecc_m_check_and_convert_sib2
(
 OSCTXT                      *p_asn1_ctx,    /* for memory allocation */
 SystemInformationBlockType2 *p_asn1_sib2,   /* destination */
 sib_type_2_Info_t           *p_sib2,         /* source */
 uecc_ue_context_t           *p_ue_context
 );

static rrc_return_et fill_access_class_barring_info
(
 /* for memory allocation */
 AC_BarringConfig                *p_asn1_access_class,   /* destination */
 access_class_barring_Info_t     *p_access_class,         /* source */
 uecc_ue_context_t               *p_ue_context
 );

static rrc_return_et fill_radio_resource_config_common
(
 /* for memory allocation */
 uecc_gb_context_t*                  p_uecc_gb_context, 
 OSCTXT                              *p_asn1_ctx,
 RadioResourceConfigCommonSIB        *p_asn1_cc,     /* destination */
 radio_resource_config_common_sib_t  *p_cc           /* source */
 );

static rrc_return_et fill_subframe_config
(
 uecc_gb_context_t*               p_uecc_gb_context,
 OSCTXT                          *p_asn1_ctx,    /* for memory allocation */
 MBSFN_SubframeConfigList        *p_asn1_sc,     /* destination */
 mbsfn_subframe_config_list_t    *p_sc,           /* source */
 uecc_ue_context_t               *p_ue_context
 );

/*SPR_16778_START*/
/*SPR_16778_END*/

void uecc_s1ap_process_dl_s1_cdma2000_tunneling
(
 S1AP_PDU            *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
 U8                  mme_id,
 U8          *p_buff,        /* ASN.1 encoded message */
/*BUG 604 changes start*/ 
 U16         buff_size,      /* encoded buf size - just for check*/
 U16         ue_index
/*BUG 604 changes stop*/ 
 );
/* Bug 12190 Fix Start */
void  rrc_fill_pilot_entry_octet(
    uecc_ue_context_t* p_uecc_ue_context,
    U8**  p_buf, U8* bitPos,
    pilot_entry_t *pilot_entry
);
/* Bug 12190 Fix Stop */
OSDynOctStr* rrc_fill_pilot_list_octet(
    uecc_ue_context_t* p_ue_context,
    pilot_list_t *pilot_list
);

static rrc_return_et uecc_s1ap_build_cdma2000_1x_srvcc
(
 rrc_s1ap_uplink_s1_cdma2000_tunneling_t *p_s1ap_msg,
 uecc_ue_context_t                       *p_ue_context,
 OSCTXT                                  *p_asn1_ctxt
);

static rrc_return_et uecc_s1ap_fill_cellChangeOrder_targetRAT_Type(
        OSCTXT                           *p_asn1_ctx,
        uecc_ue_context_t                *p_ue_context,
        rrc_target_rat_type_t            *p_target_rat_params,
        CellChangeOrder_targetRAT_Type   *p_targetRAT_Type);



void uecc_s1ap_process_ue_context_modification_request
(
 S1AP_PDU            *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
 U8                  mme_id,
 U8                  *p_buff,        /* ASN.1 encoded message */
/*BUG 604 changes start*/ 
 U16                 buffer_length,      /* encoded buf size - just for check*/
 U16                 ue_index
/*BUG 604 changes stop*/ 
 );

static rrc_return_et uecc_s1ap_build_ranap_RAB_TrCH_Mapping
(
 rrm_source_rnc_to_target_rnc_transparent_container_t *p_rnc_container,
 OSCTXT *p_asn1_ctx,
 ranap_RAB_TrCH_Mapping *p_ranap_RAB_TrCH_Mapping,
 U8 no_of_rab_trch_mappings,
 uecc_ue_context_t               *p_ue_context
 );

static rrc_return_et uecc_s1ap_cn_domain_indicator_intrnl_enc 
(
 uecc_ue_context_t               *p_ue_context, 
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_ele_cn_domain,
 U8                              cn_domain_ind
 );

static rrc_return_et uecc_s1ap_hS_DSCH_MAC_d_Flow_ID_intrnl_enc 
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_ele_mac_flow,
 U8                              hs_dsch_mac_flow_id
 );

static rrc_return_et uecc_s1ap_E_DCH_MAC_d_Flow_ID_intrnl_enc 
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_ele_mac_flow,
 U8                              e_dch_mac_flow_id
 );

static void  uecc_s1ap_build_s1ap_TargetRNC_ID
(
 uecc_gb_context_t*               p_uecc_gb_context,
 rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required, 
 /*SPR 17777 +-*/
 s1ap_TargetRNC_ID *p_target_rnc_id 
 );

static rrc_return_et uecc_s1ap_Trace_Rec_Session_info_intrnl_enc
(
 uecc_ue_context_t                       *p_ue_context,
 OSCTXT                                  *pctxt,
 ranap_ProtocolExtensionField            *p_elem,
 ranap_TraceRecordingSessionInformation  *p_trace_rec_sess_info
 );

static rrc_return_et uecc_s1ap_MBMS_Linking_info_intrnl_enc
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 U8                              mbms_link_info
 );

static rrc_return_et uecc_s1ap_d_rnti_intrnl_enc
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 U32                              d_rnti
 );

static rrc_return_et uecc_s1ap_ue_history_intrnl_enc
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 s1ap_UE_HistoryInformation      *p_ue_history_info
 );

static rrc_return_et uecc_s1ap_subs_profile_id_rfp_intrnl_enc
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 U16                              subs_profile_id
 );

static rrc_return_et uecc_s1ap_srvcc_info_intrnl_enc
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 ranap_SRVCC_Information         *p_srvcc_info
 );

static rrc_return_et uecc_s1ap_ps_rab_replace_intrnl_enc
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 ranap_RAB_ID                    *p_rab_id
 );

static rrc_return_et uecc_s1ap_CSFB_info_intrnl_enc
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 U8                              csfb_info
 );

static rrc_return_et uecc_s1ap_build_n_encode_rrc_container
(
 uecc_ue_context_t              *p_ue_context, 
 OSCTXT                         *pctxt,
 ranap_RRC_Container            *p_rrc_container
 );

static void uecc_s1ap_fill_rnc_container_security_info
(
 uecc_gb_context_t*               p_uecc_gb_context,
 ranap_SourceRNC_ToTargetRNC_TransparentContainer 
 *p_s1ap_rnc_container, /*dst*/
 security_info_t     *p_security_info /*src*/
 );

static rrc_return_et uecc_s1ap_SRB_TrCH_Mapping_intrnl_enc
(
 uecc_ue_context_t              *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 ranap_SRB_TrCH_MappingItem      *p_srb_trch_map
 );

static rrc_return_et uecc_s1ap_build_Protocol_extn_container
(
 rrm_source_rnc_to_target_rnc_transparent_container_t *p_rnc_container, 
 OSCTXT *p_asn1_ctx,
 ranap_SourceRNC_ToTargetRNC_TransparentContainer *p_srcRNC_totrgtRNC_con,
 uecc_ue_context_t               *p_ue_context
 );

static void  uecc_s1ap_build_s1ap_Target_CGI
(
 uecc_gb_context_t*      p_uecc_gb_context,
 rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required, 
 /*SPR 17777 +-*/
 s1ap_CGI                *p_cGI
 );
static rrc_return_et uecc_s1ap_fill_si_psi_container
(
 U8*                  p_data,
 SI_OrPSI_GERAN*           p_system_info,
 U32                       si_psi_index,
 OSCTXT*                              p_asn1_ctx,
 uecc_ue_context_t*                p_ue_context
 );

static rrc_return_et uecc_s1ap_fill_intrl_si_psi 
(
 SystemInfoListGERAN *p_si_psi_container,
 U8* p_data,
 U32 si_psi_index,
 U32 msg_len,
 uecc_ue_context_t*        p_ue_context
 );

static rrc_return_et uecc_s1ap_fill_old_bss_to_new_bss_info_container
(
 OSCTXT                               *p_asn1_ctx,
 rrc_s1ap_handover_required_t*         p_msg,
 uecc_ue_context_t*                    p_ue_context,
 rrm_old_bss_to_new_bss_information_t* p_old_bss_to_new_bss_info,
 U8                                    ho_domain_flag
 );

static rrc_return_et uecc_s1ap_fill_source_bss_to_target_bss_container 
(
 OSCTXT                       *p_asn1_ctx,
 uecc_ue_context_t*            p_ue_context,
 rrc_s1ap_handover_required_t* p_msg
 );

static rrc_return_et uecc_s1ap_build_sourceENB_to_targetENB_transparent_container
(
 rrc_s1ap_handover_required_t    *p_s1ap_msg,
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *p_asn1_ctxt,
 rrc_rrm_ho_required_t           *p_rrc_rrm_ho_required
 );

static rrc_return_et uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container
(
 rrc_s1ap_handover_required_t    *p_s1ap_msg,
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *p_asn_ctxt,
 rrc_rrm_ho_required_t           *p_rrc_rrm_ho_required
 );

void uecc_oamh_s1_ho_start_cell_traffic_trace
(
 uecc_gb_context_t *p_uecc_gb_context,
 uecc_ue_context_t *p_ue_context
);


void uecc_s1ap_process_location_reporting_message
(    
 S1AP_PDU *              s1ap_pdu,
 uecc_gb_context_t*      p_uecc_gb_context,  
 U8                      mme_id,
 U8                  *p_buff,        /* ASN.1 encoded message */
/*BUG 604 changes start*/ 
 U16                 buffer_length,      /* encoded buf size - just for check*/
 U16                 ue_index
/*BUG 604 changes stop*/ 
 );


rrc_return_et uecc_s1ap_location_report_intrl_enc
(
 uecc_gb_context_t   *p_uecc_gb_context,  /* UECC global context */
 rrc_s1ap_location_report_t*     p_report_msg,
 U8*                             p_buff,
 U16*                            p_size
 );


rrc_return_et uecc_s1ap_ue_associated_location_report_failure_intrl_enc
(
 uecc_gb_context_t   *p_uecc_gb_context,  /* UECC global context */
 rrc_s1ap_failure_report_t*      p_failure_msg,
 U8*                             p_buff,
 U16*                            p_size
 ); 

/*x2ap-start*/
static rrc_return_et uecc_s1ap_build_s1ap_erab_to_be_switched_dl_list
(
 uecc_ue_context_t* p_ue_context,
 OSCTXT *p_asn1_ctx,
 s1ap_E_RABToBeSwitchedDLList *p_erab_to_be_switched_dl_list
 );
/*x2ap-end*/

/* cr_726 trace_id check function */
rrc_return_et check_trace_id_validity(U8 index, U8 octateValue);

static rrc_return_et uecc_s1ap_fillMobilityFromEUTRACommand_r8 
(
    uecc_ue_context_t*            p_ue_context,
    MobilityFromEUTRACommand_r8_IEs  *p_mobilityFromEUTRACommand_r8,
    U8                            *p_data_buffer,
    OSCTXT                        *p_asn1_ctx,
    rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required,
    uecc_s1_src_ho_info_t    *p_s1_src_ho_info,
    DL_DCCH_Message                  *msg
);
/* SPR 1643 Start */
static rrc_return_et validate_ho_restriction_list_plmn_identity
(
    s1ap_HandoverRestrictionList     *p_s1ap_HandoverRestrictionList,
    uecc_gb_context_t                *p_uecc_gb_context  /* UECC global context */
);
/* added*/
static rrc_return_et validate_source_to_target_transparent_container_plmn_identity
(
      rrc_source_enb_to_target_enb_transparent_container_t*
                    p_source_enb_to_target_enb_transparent_container,
      uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
);
/* SPR 1643 Stop */
static rrc_return_et uecc_s1ap_fillMobilityFromEUTRACommand_r9 
(
    uecc_ue_context_t*                p_ue_context,
    MobilityFromEUTRACommand_r9_IEs  *p_mobilityFromEUTRACommand_r9,
    U8                               *p_data_buffer,
    OSCTXT                           *p_asn1_ctx,
    rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required,
    uecc_s1_src_ho_info_t   *p_s1_src_ho_info,
    DL_DCCH_Message                  *msg
);

static rrc_return_et uecc_s1ap_fillMobilityFromEUTRACommand_r9_purpose_e_csfb
(
    uecc_ue_context_t*                p_ue_context,
    E_CSFB_r9                         *p_e_csfb_r9,
    /*SPR 17777 +-*/
    OSCTXT                           *p_asn1_ctx,
    rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required
);
//Trace Change Start
static void uecc_s1ap_set_enbId_from_s1ap_status_msg_ind
(
        uecc_gb_context_t   *p_uecc_gb_context,  /* UECC global context */
        s1ap_status_msg_ind_t *p_s1ap_status_msg_ind /* Message Structure of S1AP Status Message Indication */
);
//Trace Change End

 
/****************************************************************************
 * Functions implementation
 ****************************************************************************/
/******************************************************************************
 *   FUNCTION NAME: uecc_fsm_validate_and_fill_erab_forwarding_list 
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  s1ap_E_RABSubjecttoDataForwardingList *p_erab_forward_list
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function validate the erab_fowarding_list 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_PARTIAL_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_fsm_validate_and_fill_erab_forwarding_list(
        uecc_ue_context_t* p_ue_context,
        s1ap_E_RABSubjecttoDataForwardingList *p_erab_forward_list
        )
{
    OSRTDListNode* p_node = PNULL;
    rrc_return_et ret = RRC_SUCCESS;
    s1ap_E_RABSubjecttoDataForwardingList_element *p_elem = PNULL;
    uecc_ho_src_drb_forward_list_t *p_uecc_ho_src_drb_forward_list = PNULL;
    rrc_bool_et     tunnel_info_present = RRC_FALSE;
    U8      erab_idx = 0;
    U8 fwd_list_count = 0;
    RRC_ASSERT(PNULL!=p_ue_context);
    RRC_ASSERT(PNULL!=p_erab_forward_list);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* SPR 13401 Fix Start */
    if (!((PNULL != p_ue_context->ho_info.p_ho_info) && (PNULL !=
                    p_ue_context->ho_info.p_ho_info->p_src_ho_info)))
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                p_ue_context->p_gb_context->facility_name, RRC_WARNING,
                "CDMA Handover is not ongoing");
        return RRC_FAILURE;
    }
    /* SPR 13401 Fix Stop */

    p_uecc_ho_src_drb_forward_list = &(p_ue_context->ho_info.p_ho_info->
            p_src_ho_info->s1_src_ho_info.src_drb_fwd_list);

    /* INCREMENTING THE DRB TO FWD LIST COUNT IN CASE OF ECSFB_CONC_PS_HO
     * WHEN BOTH DL_TUNNELING FOR 1XRTT AND HRPD HAS ERAB FWDING LIST*/
    if( (RRC_TRUE == p_ue_context->ho_info.dl_s1_cdma2000_tunneling_received_once) 
            &&
            (HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD == 
             p_ue_context->ho_info.p_ho_info->p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type) )
    {
        fwd_list_count = p_uecc_ho_src_drb_forward_list->count;
    }    
    else
    {
        p_uecc_ho_src_drb_forward_list->count = 0 ;
    }

    for( p_node = p_erab_forward_list->head;
            PNULL!=p_node;
            /*SPR_17799_Fix_Start*/
            p_node=p_node->next) 
        /*SPR_17799_Fix_End*/
    {
        p_elem = (s1ap_E_RABSubjecttoDataForwardingList_element*)p_node->data;
        if (PNULL == p_elem || p_elem->value.u._E_RABDataForwardingItemIEs_1 == PNULL)
        {
            continue;
        }
        if (ASN1V_s1ap_id_E_RABDataForwardingItem != p_elem->id)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_WARNING,
                    "ASN1V_s1ap_id_E_RABDataForwardingItem != p_elem"
                    "->id (%i)",
                    p_elem->id);
            p_ue_context->ho_info.cause.t= T_s1ap_Cause_protocol;
            p_ue_context->ho_info.cause.u.protocol = s1ap_transfer_syntax_error;
            ret = RRC_FAILURE;
            break;

        }
        /* memory allocation */
        erab_idx = (U8)p_elem->value.u._E_RABDataForwardingItemIEs_1->e_RAB_ID;
        if(INVALID_ERAB_ID <= erab_idx )
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_WARNING,
                    "INVALID ERAB ID PRESENT [%d]",erab_idx);
            p_ue_context->ho_info.cause.t= T_s1ap_Cause_protocol;
            p_ue_context->ho_info.cause.u.protocol = s1ap_transfer_syntax_error;
            ret = RRC_FAILURE;
            break;
        }
        if( PNULL == 
                (p_uecc_ho_src_drb_forward_list->
                 erab_ho_src_drb_forward_list[erab_idx]
                 = (uecc_ho_src_drb_forward_info_t *)
                 rrc_mem_get(sizeof(uecc_ho_src_drb_forward_info_t))))
        {

            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "Memory Allocation Failed");

            p_ue_context->ho_info.cause.t= T_s1ap_Cause_misc;
            p_ue_context->ho_info.cause.u.misc = s1ap_unspecified;
            /*SPR_17799_Fix_Start*/
            ret = RRC_FAILURE;
            break;
            /*SPR_17799_Fix_End */
        }

        /* SES-508 Fix Start */
        /* Code Removed */
        /* SES-508 Fix End */

        /* Check if at least one DL transport address, TEID pair or
           UL transport address, TEID pair shall present */

        tunnel_info_present = RRC_FALSE;
        if (p_elem->value.u._E_RABDataForwardingItemIEs_1->m.dL_transportLayerAddressPresent &&
                p_elem->value.u._E_RABDataForwardingItemIEs_1->m.dL_gTP_TEIDPresent )
        {
            p_uecc_ho_src_drb_forward_list->
                erab_ho_src_drb_forward_list[erab_idx]
                ->forward_direction = UECC_FORWARDING_DIRECTION_DL;
            p_uecc_ho_src_drb_forward_list->erab_ho_src_drb_forward_list
                [erab_idx]->dl_teid_peer =  p_elem->value.u._E_RABDataForwardingItemIEs_1->dL_gTP_TEID;

            asn1Copy_s1ap_TransportLayerAddress(&p_ue_context->
                    s1ap_asn1_ctx,
                    &p_elem->value.u._E_RABDataForwardingItemIEs_1->dL_transportLayerAddress,
                    &p_uecc_ho_src_drb_forward_list->
                    erab_ho_src_drb_forward_list[erab_idx]->
                    dl_transportLayerAddress);
            tunnel_info_present = RRC_TRUE;
            /*SPR_17799_Fix_Start*/
            p_uecc_ho_src_drb_forward_list->count++;
            /*SPR_17799_Fix_End*/
        }
        if(p_elem->value.u._E_RABDataForwardingItemIEs_1->m.uL_TransportLayerAddressPresent &&
                p_elem->value.u._E_RABDataForwardingItemIEs_1->m.uL_GTP_TEIDPresent)
        {
            if (p_elem->value.u._E_RABDataForwardingItemIEs_1->m.dL_transportLayerAddressPresent &&
                    p_elem->value.u._E_RABDataForwardingItemIEs_1->m.dL_gTP_TEIDPresent )
            {
                p_uecc_ho_src_drb_forward_list->erab_ho_src_drb_forward_list
                    [erab_idx]->forward_direction = 
                    UECC_FORWARDING_DIRECTION_BOTH; 
            }
            else
            {
                p_uecc_ho_src_drb_forward_list->erab_ho_src_drb_forward_list
                    [erab_idx]->forward_direction = UECC_FORWARDING_DIRECTION_UL;
                /*SPR_17799_Fix_Start*/
                p_uecc_ho_src_drb_forward_list->count++;
                /*SPR_17799_Fix_End*/
            }

            p_uecc_ho_src_drb_forward_list->erab_ho_src_drb_forward_list
                [erab_idx]->ul_teid_peer = p_elem->value.u._E_RABDataForwardingItemIEs_1->uL_GTP_TEID;

            asn1Copy_s1ap_TransportLayerAddress(&p_ue_context->
                    s1ap_asn1_ctx,
                    &p_elem->value.u._E_RABDataForwardingItemIEs_1->uL_TransportLayerAddress,
                    &p_uecc_ho_src_drb_forward_list->
                    erab_ho_src_drb_forward_list[erab_idx]->
                    ul_transportLayerAddress);
        }
        else if( RRC_FALSE == tunnel_info_present ) 
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "Erab_id [%i] does not contain tunnel info",
                    erab_idx);
            /*SPR_17799_Fix_Start*/
            /*SPR_18888_Fix_Start*/
            if (PNULL != p_uecc_ho_src_drb_forward_list->
                    erab_ho_src_drb_forward_list[erab_idx])
            {
                rrc_mem_free(p_uecc_ho_src_drb_forward_list->
                        erab_ho_src_drb_forward_list[erab_idx]);
                p_uecc_ho_src_drb_forward_list->erab_ho_src_drb_forward_list
                    [erab_idx] = PNULL;
            }
            /*SPR_17799_Fix_End*/
            /*SPR_18888_Fix_Stop*/
        }
    }
    if(RRC_FAILURE == ret )
    {
        /* releasing the allocated memory */
        for( erab_idx = 0; erab_idx < MAX_ERAB_COUNT; erab_idx++)
        {
            if(p_uecc_ho_src_drb_forward_list->erab_ho_src_drb_forward_list[erab_idx])
            {
                rrc_mem_free(p_uecc_ho_src_drb_forward_list->
                        erab_ho_src_drb_forward_list[erab_idx]);
                p_uecc_ho_src_drb_forward_list->erab_ho_src_drb_forward_list
                    [erab_idx] = PNULL;
            }
        }
        if ((RRC_TRUE == p_ue_context->ho_info.dl_s1_cdma2000_tunneling_received_once)
                &&
                (HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD == 
                 p_ue_context->ho_info.p_ho_info->p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type ))  
        {
            p_uecc_ho_src_drb_forward_list->count = fwd_list_count;
        }
        else 
        {
            /* setting the count as zero */
            p_uecc_ho_src_drb_forward_list->count = RRC_NULL;
        }
    }
    else
    {
        if ((RRC_FALSE == p_ue_context->ho_info.dl_s1_cdma2000_tunneling_received_once)
                &&
                ( HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD == 
                  p_ue_context->ho_info.p_ho_info->p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required->ho_type))
        {
            p_ue_context->ho_info.dl_s1_cdma2000_tunneling_received_once = RRC_TRUE;
        }
    }
    if(p_uecc_ho_src_drb_forward_list->count)
    {
        p_ue_context->ho_info.p_ho_info->
            p_src_ho_info->s1_src_ho_info.bitmask |=
            ERAB_SUBJECT_TO_DATA_FORWARDING_LIST_PRESENT;
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return ret;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_get_enb_s1ap_id_from_ue_s1ap_ids
 *
 *   INPUTS       : s1ap_UE_S1AP_IDs    *p_ue_s1ap_ids
 *                  U32                 *enb_ue_s1ap_id
 *   OUTPUTS      : None
 *
 *   DESCRIPTION:
 *       This function retreives enb_s1ap_id from s1ap_UE_S1AP_IDs
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_s1ap_get_enb_s1ap_id_from_ue_s1ap_ids(
        s1ap_UE_S1AP_IDs    *p_ue_s1ap_ids,
        U32                 *enb_ue_s1ap_id
        )
{
    RRC_ASSERT(PNULL!=p_ue_s1ap_ids);
    RRC_ASSERT(PNULL!=enb_ue_s1ap_id);

    if ((T_s1ap_UE_S1AP_IDs_uE_S1AP_ID_pair == p_ue_s1ap_ids->t) &&
            (PNULL != p_ue_s1ap_ids->u.uE_S1AP_ID_pair))
    {
        *enb_ue_s1ap_id = p_ue_s1ap_ids->u.uE_S1AP_ID_pair->eNB_UE_S1AP_ID;
        return RRC_SUCCESS;
    }

    return RRC_FAILURE;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_get_mme_s1ap_id_from_ue_s1ap_ids
 *
 *   INPUTS       : s1ap_UE_S1AP_IDs    *p_ue_s1ap_ids
 *                  U32                 *mme_ue_s1ap_id
 *   OUTPUTS      : None
 *
 *   DESCRIPTION:
 *       This function retreives mme_s1ap_id from s1ap_UE_S1AP_IDs
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_s1ap_get_mme_s1ap_id_from_ue_s1ap_ids(
        s1ap_UE_S1AP_IDs    *p_ue_s1ap_ids,
        U32                 *mme_ue_s1ap_id
        )
{
    RRC_ASSERT(PNULL!=p_ue_s1ap_ids);
    RRC_ASSERT(PNULL!=mme_ue_s1ap_id);

    switch(p_ue_s1ap_ids->t)
    {
        case T_s1ap_UE_S1AP_IDs_uE_S1AP_ID_pair:
            *mme_ue_s1ap_id = p_ue_s1ap_ids->u.uE_S1AP_ID_pair->mME_UE_S1AP_ID;
            return RRC_SUCCESS;
        case T_s1ap_UE_S1AP_IDs_mME_UE_S1AP_ID:
            *mme_ue_s1ap_id = p_ue_s1ap_ids->u.mME_UE_S1AP_ID;
            return RRC_SUCCESS;
    }

    return RRC_FAILURE;
}
        
/* SPR:5840 start */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_p_rrc_trace_for_cause
 *
 *   INPUTS       : uecc_ue_context_t    *p_ue_context
 *                  s1ap_Cause           cause
 *   OUTPUTS      : None
 *
 *   DESCRIPTION:
 *
 *   RETURNS:
 *       void
 *
 ******************************************************************************/
void uecc_s1ap_p_rrc_trace_for_cause(
        uecc_ue_context_t    *p_ue_context,
        s1ap_Cause           cause
        )
{
    switch(cause.t)
    {
         case T_s1ap_Cause_radioNetwork: 
    /*SPR 15896 Fix Start*/
    /* SPR 15783 Start */
         P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"cause type\">%d</ie>",cause.t - 1);
    /* SPR 15783 Stop */
         P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"cause value\">%d</ie>",cause.u.radioNetwork);
    /*SPR 15896 Fix Stop*/
         break;

         case T_s1ap_Cause_transport: 
    /*SPR 15896 Fix Start*/
    /* SPR 15783 Start */
         P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"cause type\">%d</ie>",cause.t - 1);
    /* SPR 15783 Stop */
         P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"cause value\">%d</ie>",cause.u.transport);
    /*SPR 15896 Fix Stop*/
         break;

         case T_s1ap_Cause_nas: 
    /*SPR 15896 Fix Start*/
    /* SPR 15783 Start */
         P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"cause type\">%d</ie>",cause.t - 1);
    /* SPR 15783 Stop */
         P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"cause value\">%d</ie>",cause.u.nas);
    /*SPR 15896 Fix Stop*/
         break; 

         case T_s1ap_Cause_protocol:
    /*SPR 15896 Fix Start*/
    /* SPR 15783 Start */
         P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"cause type\">%d</ie>",cause.t - 1);
    /* SPR 15783 Stop */
         P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"cause value\">%d</ie>",cause.u.protocol);
    /*SPR 15896 Fix Stop*/
         break; 

         case T_s1ap_Cause_misc:
    /*SPR 15896 Fix Start*/
    /* SPR 15783 Start */
         P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"cause type\">%d</ie>",cause.t - 1);
    /* SPR 15783 Stop */
         P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"cause value\">%d</ie>",cause.u.misc);
    /*SPR 15896 Fix Stop*/
         break; 
    }
}

/*SPR 15896 Fix Start*/
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_ue_assoc_msg_max_trace_handler
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  U8    *buffer
 *                  U32   buffer_len
 *                  char  *msg_name    : Message name
 *                  U8    recv_or_send : 0 - msg received / 1 - msg sent
 *   OUTPUTS      : None
 *   DESCRIPTION  : This function handles the UE Trace for S1AP messages.
 *   RETURNS:     : None
 *******************************************************************************/
void uecc_s1ap_ue_assoc_msg_max_trace_handler( 
              uecc_ue_context_t  *p_ue_context, 
              U8                 *buffer, 
              U32                buffer_len,
              char               *msg_name,
              U8                 recv_or_send)
{
    U8 header_buffer[100];
    U8  end[20] ;

    /* klockwork Fix */ 
    memset_wrapper(header_buffer,RRC_NULL,sizeof(header_buffer));
    memset_wrapper(end,RRC_NULL,sizeof(end));
    /* klockwork Fix */ 
    
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if ((p_ue_context->m.traceActivated) )
    {
        /*SPR 15875 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1) &&
                ((MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                 (MAXIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
        {
            P_RRC_TRACE(p_ue_context, set_maximum_bitmask(),GEN_MME, "\n <msg function=\"S1AP\" name=\"%s\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    msg_name, difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1) &&
                ((MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                 (MAXIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
        {
            P_RRC_TRACE(p_ue_context, set_maximum_bitmask(),GEN_CELL, "\n <msg function=\"S1AP\" name=\"%s\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    msg_name, difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }

        /*SPR 15875 Fix Stop*/
        if(0 == recv_or_send)
        {
            P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), S1,"\n <initiator type=\"MME\">%s</initiator>",
                    p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
        }
        else
        {
            P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
                    p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
        }
        P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), S1,"<rawMsg protocol=\"S1AP\" version=\"001\">");

        rrc_trace_max_fprintf(p_ue_context, S1, buffer_len, buffer);
        P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), S1," </rawMsg>\n </msg>");
    }
    
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}
/*SPR 15896 Fix Stop*/

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_ue_assoc_sig_msg_ind_initiatingMessage
 *
 *   DESCRIPTION:
 *       This function processes S1AP_UE_ASSOCIATED_SIG_MSG_IND 
 *       message type InitiatingMessage
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
static void uecc_s1ap_process_ue_assoc_sig_msg_ind_initiatingMessage(
        uecc_gb_context_t   *p_uecc_gb_context,
        S1AP_PDU            *p_s1ap_pdu,
        s1ap_ue_associated_sig_msg_ind_t *p_s1ap_ue_associated_sig_msg_ind,
        U8              mme_id,
        U16         encoded_len)
{
    RRC_ASSERT(PNULL!=p_uecc_gb_context);
    RRC_ASSERT(PNULL!=p_s1ap_ue_associated_sig_msg_ind);
    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    if (PNULL == p_s1ap_pdu->u.initiatingMessage)
    {
        /* Should not happen */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[S1AP_UE_ASSOCIATED_SIG_MSG_IND] Invalid initiatingMessage "
                "field value");
        return;
    }

    /* Check procedureCode */
    if (ASN1V_s1ap_id_UEContextRelease==
            p_s1ap_pdu->u.initiatingMessage->procedureCode)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: UEContextReleaseCommand %s",
                change_data_to_str(encoded_len, p_s1ap_ue_associated_sig_msg_ind->message_buff_p));

        uecc_s1ap_process_ue_context_release_command(p_s1ap_pdu,
                p_uecc_gb_context,
                mme_id,
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
                encoded_len,
/*BUG 604 changes start*/ 
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;
    }
    else if (ASN1V_s1ap_id_downlinkNASTransport==
            p_s1ap_pdu->u.initiatingMessage->procedureCode)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: DownlinkNASTransport %s",
                change_data_to_str(encoded_len, p_s1ap_ue_associated_sig_msg_ind->message_buff_p));
        uecc_s1ap_process_downlink_nas_transport(p_s1ap_pdu,
                p_uecc_gb_context,
                mme_id,
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
/*BUG 604 changes start*/ 
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;
    }
    else if (ASN1V_s1ap_id_InitialContextSetup==
            p_s1ap_pdu->u.initiatingMessage->procedureCode)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: InitialContextSetupRequest %s",
                change_data_to_str(encoded_len, p_s1ap_ue_associated_sig_msg_ind->message_buff_p));
        uecc_s1ap_process_initial_context_setup_request(p_s1ap_pdu,
                p_uecc_gb_context,
                p_s1ap_ue_associated_sig_msg_ind,
/*BUG 604 changes start*/ 
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;

    }
    else if (ASN1V_s1ap_id_HandoverResourceAllocation == 
            p_s1ap_pdu->u.initiatingMessage->procedureCode)
    {

        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: HandoverRequest %s",
                change_data_to_str(encoded_len, p_s1ap_ue_associated_sig_msg_ind->message_buff_p));
        uecc_s1ap_process_handover_request(
                p_s1ap_pdu,
                p_uecc_gb_context,
                p_s1ap_ue_associated_sig_msg_ind,
                encoded_len,
                p_uecc_gb_context->uecc_module_id);
        return;
    }
    else if (ASN1V_s1ap_id_MMEStatusTransfer == 
            p_s1ap_pdu->u.initiatingMessage->procedureCode)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: MMEStatusTransfer %s",
                change_data_to_str(encoded_len, p_s1ap_ue_associated_sig_msg_ind->message_buff_p));
        uecc_s1ap_process_mme_status_transfer(p_s1ap_pdu,
                p_uecc_gb_context,
                mme_id,
                p_s1ap_ue_associated_sig_msg_ind,
/*BUG 604 changes start*/ 
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;
    }
    else if (ASN1V_s1ap_id_ErrorIndication == 
            p_s1ap_pdu->u.initiatingMessage->procedureCode)
    {
        if (p_s1ap_pdu->u.initiatingMessage->value.t ==
                T1_errorIndication)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, "S1AP_MSG: ErrorIndication %s",
                change_data_to_str(encoded_len, p_s1ap_ue_associated_sig_msg_ind->message_buff_p));
            /* Message Type Criticality is s1ap_ignore*/
            uecc_s1ap_process_error_indication(p_s1ap_pdu,
                    p_uecc_gb_context,
                    &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
/*BUG 604 changes start*/ 
                    encoded_len,
                    p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
            return;
        }
    }
    else if (ASN1V_s1ap_id_E_RABSetup==
            p_s1ap_pdu->u.initiatingMessage->procedureCode)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: E-RABSetupRequest %s",
                change_data_to_str(encoded_len, p_s1ap_ue_associated_sig_msg_ind->message_buff_p));
        uecc_s1ap_process_erab_setup_request(p_s1ap_pdu,
                p_uecc_gb_context,
                mme_id,
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
/*BUG 604 changes start*/ 
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;
    }
    else if (ASN1V_s1ap_id_E_RABModify ==
            p_s1ap_pdu->u.initiatingMessage->procedureCode)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: E-RABModifyRequest %s",
                change_data_to_str(encoded_len, p_s1ap_ue_associated_sig_msg_ind->message_buff_p));
        /* Process the E-RAB Modify request received from MME */
        uecc_s1ap_process_erab_modify_request(p_s1ap_pdu,
                p_uecc_gb_context,
                mme_id,
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
/*BUG 604 changes start*/ 
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;
    }
    else if (ASN1V_s1ap_id_UEContextModification==
            p_s1ap_pdu->u.initiatingMessage->procedureCode)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: UEContextModificationRequest %s",
                change_data_to_str(encoded_len, p_s1ap_ue_associated_sig_msg_ind->message_buff_p));
        uecc_s1ap_process_ue_context_modification_request(p_s1ap_pdu,
                p_uecc_gb_context,
                mme_id,
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
/*BUG 604 changes start*/ 
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;
    }
    else if (ASN1V_s1ap_id_DownlinkS1cdma2000tunnelling ==
            p_s1ap_pdu->u.initiatingMessage->procedureCode)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: DownlinkS1cdma2000tunneling %s",
                change_data_to_str(encoded_len, p_s1ap_ue_associated_sig_msg_ind->message_buff_p));
        uecc_s1ap_process_dl_s1_cdma2000_tunneling(p_s1ap_pdu,
                p_uecc_gb_context,
                mme_id,
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
/*BUG 604 changes start*/ 
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;
    }
    else if (ASN1V_s1ap_id_E_RABRelease==
            p_s1ap_pdu->u.initiatingMessage->procedureCode)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: E-RABReleaseCommand %s",
                change_data_to_str(encoded_len, p_s1ap_ue_associated_sig_msg_ind->message_buff_p));
        uecc_s1ap_process_erb_release_command(p_s1ap_pdu,
                p_uecc_gb_context,
                mme_id,
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
/*BUG 604 changes start*/ 
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;
    }
    else if ( ASN1V_s1ap_id_LocationReportingControl ==
            p_s1ap_pdu->u.initiatingMessage->procedureCode )
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: LocationReport %s",
                change_data_to_str(encoded_len, p_s1ap_ue_associated_sig_msg_ind->message_buff_p));
        uecc_s1ap_process_location_reporting_message(p_s1ap_pdu,
                p_uecc_gb_context,
                mme_id,
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
/*BUG 604 changes start*/ 
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;
    }
    /* Trace Start Procedure start */
    else if (ASN1V_s1ap_id_TraceStart ==
            p_s1ap_pdu->u.initiatingMessage->procedureCode)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: TraceStart %s",
                change_data_to_str(encoded_len, p_s1ap_ue_associated_sig_msg_ind->message_buff_p));
        /* SPR 22628 Fix Start */
        uecc_s1ap_process_trace_start(p_s1ap_pdu,
        /*BUG 604 changes start*/ 
                p_uecc_gb_context,
                mme_id);
                /*SPR 17777 +-*/
        /*BUG 604 changes stop*/ 
        /* SPR 22628 Fix End */
        return;
    }
    /* Trace Start Procedure end */
    /* Deactivate Trace Procedure start */
    else if (ASN1V_s1ap_id_DeactivateTrace ==
            p_s1ap_pdu->u.initiatingMessage->procedureCode)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: DeactivateTrace %s",
                change_data_to_str(encoded_len, p_s1ap_ue_associated_sig_msg_ind->message_buff_p));
        /* SPR 22628 Fix Start */
        uecc_s1ap_process_deactivate_trace(p_s1ap_pdu,
        /*BUG 604 changes start*/ 
                p_uecc_gb_context,
                p_s1ap_ue_associated_sig_msg_ind->ue_index,
                mme_id);
        /*BUG 604 changes stop*/ 
        /* SPR 22628 Fix End */
        return;
    }
    else
    {
        /* Unknown Procedure Code */
        if (s1ap_ignore != p_s1ap_pdu->u.initiatingMessage->criticality)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, "%d - Unexpected Procedure Code,"
                    "Sending Error Indication",
                    p_s1ap_pdu->u.initiatingMessage->procedureCode);

            build_and_send_error_indication_unknown_proc(
                    p_uecc_gb_context,
                    mme_id,
                    p_s1ap_pdu->u.initiatingMessage->procedureCode,
                    p_s1ap_pdu->u.initiatingMessage->criticality,
                    T_S1AP_PDU_initiatingMessage);
            return; 
        }
        else
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, "%d - Ignored Unexpected Procedure Code,"
                    " with Ignore Criticality", 
                    p_s1ap_pdu->u.initiatingMessage->procedureCode);
            return;
        }
        /* Deactivate Trace Procedure end */
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_ue_assoc_sig_msg_ind_successfulOutcome
 *
 *   DESCRIPTION:
 *       This function processes S1AP_UE_ASSOCIATED_SIG_MSG_IND 
 *       message type successfulOutcome
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
static void uecc_s1ap_process_ue_assoc_sig_msg_ind_successfulOutcome(
        uecc_gb_context_t   *p_uecc_gb_context,
        S1AP_PDU            *p_s1ap_pdu,
        s1ap_ue_associated_sig_msg_ind_t *p_s1ap_ue_associated_sig_msg_ind,
        U8              mme_id,
        U16         encoded_len)
{
    RRC_ASSERT(PNULL!=p_uecc_gb_context);
    RRC_ASSERT(PNULL!=p_s1ap_ue_associated_sig_msg_ind);
    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    if (PNULL==p_s1ap_pdu->u.successfulOutcome)
    {
        /* Should not happen */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[S1AP_UE_ASSOCIATED_SIG_MSG_IND] Invalid successOutcome "
                "field value");
        return;
    }

    /* Check procedureCode */
    if (ASN1V_s1ap_id_HandoverPreparation ==
            p_s1ap_pdu->u.successfulOutcome->procedureCode)
    {
        uecc_s1ap_process_handover_command(p_s1ap_pdu,
                p_uecc_gb_context,mme_id,   
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
/*BUG 604 changes start*/ 
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;
    }
    else if (ASN1V_s1ap_id_HandoverCancel ==
            p_s1ap_pdu->u.successfulOutcome->procedureCode)
    {
        uecc_s1ap_process_handover_cancel_ack(p_s1ap_pdu,
                p_uecc_gb_context,
                mme_id,
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
/*BUG 604 changes start*/ 
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;
    }

    /*x2ap-start*/
    else if (ASN1V_s1ap_id_PathSwitchRequest ==
            p_s1ap_pdu->u.successfulOutcome->procedureCode)
    {
        uecc_s1ap_process_path_switch_request_ack(
                p_s1ap_pdu,
                p_uecc_gb_context,
                mme_id,
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
/*BUG 604 changes start*/ 
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;
    }
/* OPTION3X Changes Start */
#ifdef ENDC_ENABLED
    else if (ASN1V_s1ap_id_E_RABModificationIndication ==
            p_s1ap_pdu->u.successfulOutcome->procedureCode)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: E-RABModificationConfirmation");
        uecc_s1ap_process_erab_modification_cnf(
                p_s1ap_pdu,
                p_uecc_gb_context,
                mme_id,
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
        return;
    }
#endif
/* OPTION3X Changes End */
    /*x2ap-end*/
    else
    {
        /* Unknown Procedure Code */
        if (s1ap_ignore != p_s1ap_pdu->u.successfulOutcome->criticality)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, "%d - Unexpected Procedure Code,"
                    "Sending Error Indication",
                    p_s1ap_pdu->u.successfulOutcome->procedureCode);

            build_and_send_error_indication_unknown_proc(
                    p_uecc_gb_context,
                    mme_id,
                    p_s1ap_pdu->u.successfulOutcome->procedureCode,
                    p_s1ap_pdu->u.successfulOutcome->criticality,
                    T_S1AP_PDU_successfulOutcome);
            return;
        }
        else
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, "%d - Ignored Unexpected Procedure Code,"
                    " with Ignore Criticality", 
                    p_s1ap_pdu->u.successfulOutcome->procedureCode);
            return;
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_ue_assoc_sig_msg_ind_unsuccessfulOutcome
 *
 *   DESCRIPTION:
 *       This function processes S1AP_UE_ASSOCIATED_SIG_MSG_IND 
 *       message type UnsuccessfulOutcome
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
static void uecc_s1ap_process_ue_assoc_sig_msg_ind_unsuccessfulOutcome(
        uecc_gb_context_t   *p_uecc_gb_context,
        S1AP_PDU            *p_s1ap_pdu,
        s1ap_ue_associated_sig_msg_ind_t *p_s1ap_ue_associated_sig_msg_ind,
        U8              mme_id,
        U16         encoded_len)
{
    RRC_ASSERT(PNULL!=p_uecc_gb_context);
    RRC_ASSERT(PNULL!=p_s1ap_ue_associated_sig_msg_ind);
    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    if (PNULL==p_s1ap_pdu->u.unsuccessfulOutcome)
    {
        /* Should not happen */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[S1AP_UE_ASSOCIATED_SIG_MSG_IND] Invalid unsuccessOutcome "
                "field value");
        return;
    }

    /* Check procedureCode */
    if (ASN1V_s1ap_id_HandoverPreparation ==
            p_s1ap_pdu->u.unsuccessfulOutcome->procedureCode)
    {
        uecc_s1ap_process_handover_preparation_failure(p_s1ap_pdu,
                p_uecc_gb_context,mme_id,
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
/*BUG 604 changes start*/ 
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;
    }
    /*x2ap-start*/
    if (ASN1V_s1ap_id_PathSwitchRequest ==
            p_s1ap_pdu->u.unsuccessfulOutcome->procedureCode)
    {
        uecc_s1ap_process_path_switch_request_failure(
                p_s1ap_pdu,
                p_uecc_gb_context,
                mme_id,
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
/*BUG 604 changes start*/ 
                encoded_len,
                p_s1ap_ue_associated_sig_msg_ind->ue_index);
/*BUG 604 changes stop*/ 
        return;
    }

    /*x2ap-end*/
    else
    {
        /* Unknown Procedure Code */
        if (s1ap_ignore != p_s1ap_pdu->u.unsuccessfulOutcome->criticality)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, "%d - Unexpected Procedure Code,"
                    "Sending Error Indication",
                    p_s1ap_pdu->u.unsuccessfulOutcome->procedureCode);

            build_and_send_error_indication_unknown_proc(
                    p_uecc_gb_context,
                    mme_id,
                    p_s1ap_pdu->u.unsuccessfulOutcome->procedureCode,
                    p_s1ap_pdu->u.unsuccessfulOutcome->criticality,
                    T_S1AP_PDU_unsuccessfulOutcome);
            return;
        }
        else
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, "%d - Ignored Unexpected Procedure Code,"
                    " with Ignore Criticality", 
                    p_s1ap_pdu->u.unsuccessfulOutcome->procedureCode);
            return;
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/* SPR:5840 stop */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_ue_associated_sig_msg_ind
 *
 *   INPUTS       :  void                *p_api
 *                  ecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes S1AP_UE_ASSOCIATED_SIG_MSG_IND
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_ue_associated_sig_msg_ind
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    s1ap_ue_associated_sig_msg_ind_t *p_s1ap_ue_associated_sig_msg_ind;
    OSCTXT      asn1_ctx;
    S1AP_PDU    s1ap_pdu;
    U16         encoded_len;

    rrc_return_et response = RRC_SUCCESS;
    U8              mme_id = RRC_NULL;
    /*SPR_17976_START*/
    uecc_ue_context_t               *p_ue_context = PNULL;
    /*SPR_17976_END*/
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/


    RRC_ASSERT(PNULL!=p_api);
    RRC_ASSERT(PNULL!=p_uecc_gb_context);
    memset_wrapper(&s1ap_pdu,0,sizeof(S1AP_PDU));
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);


    p_s1ap_ue_associated_sig_msg_ind =
        (s1ap_ue_associated_sig_msg_ind_t *)((U8*)p_api + RRC_API_HEADER_SIZE);

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) <
            RRC_API_HEADER_SIZE + sizeof(s1ap_ue_associated_sig_msg_ind_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[S1AP_UE_ASSOCIATED_SIG_MSG_IND] Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /* SPR 22634 Fix - Starts */
    encoded_len = (U16)(rrc_get_api_buf_size(p_api) - 
            (RRC_API_HEADER_SIZE + sizeof(s1ap_ue_associated_sig_msg_ind_t)));
    /* SPR 22634 Fix - Ends */

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "[S1AP_UE_ASSOCIATED_SIG_MSG_IND] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    mme_id = p_s1ap_ue_associated_sig_msg_ind->mme_id;

    do
    {
        response = rrc_s1ap_pdu_intrl_dec(p_uecc_gb_context,
                &asn1_ctx,
                &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0],
                encoded_len,
                &s1ap_pdu);

        if (RRC_FAILURE == response)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP_UE_ASSOCIATED_SIG_MSG_IND] s1ap_pdu decoding failure");
            /* Send Error Indication with Transfer Syntax Error.
             * Criticality Diagnostics are not required. */ 

            uecc_s1ap_build_and_send_err_indication(p_uecc_gb_context,
                RRC_S1AP_MODULE_ID,mme_id, PNULL);
            break;
        }

        /*SPR_17976_START*/
        if(((T_S1AP_PDU_initiatingMessage == s1ap_pdu.t) &&
                    (ASN1V_s1ap_id_MMEStatusTransfer == 
                    s1ap_pdu.u.initiatingMessage->procedureCode)) ||
                ((T_S1AP_PDU_successfulOutcome == s1ap_pdu.t) &&
                    (ASN1V_s1ap_id_PathSwitchRequest ==
                      s1ap_pdu.u.successfulOutcome->procedureCode)) ||
                     ((T_S1AP_PDU_unsuccessfulOutcome == s1ap_pdu.t) &&
                      (ASN1V_s1ap_id_PathSwitchRequest ==
                       s1ap_pdu.u.unsuccessfulOutcome->procedureCode)))
        {
            p_ue_context = uecc_ue_ctx_get(
                            p_uecc_gb_context,
                            p_s1ap_ue_associated_sig_msg_ind->ue_index);

            if(PNULL != p_ue_context && 
                    RRC_TRUE == p_ue_context->trg_ho_fail_rrc_cre_flag)
            {
                if(0 == 
                        TENB_CRE_Q_GET_COUNT(&p_ue_context->p_tenb_cre_event_queue))
                {
                   /* Coverity Fix 98786 Start */ 
                    uecc_event_queue_push_tenb_cre_event(
                      ( uecc_fsm_event_et)s1ap_pdu.u.initiatingMessage->procedureCode, 
                            p_ue_context, 
                            p_api, 
                            &p_ue_context->p_tenb_cre_event_queue);
                   /* Coverity Fix 98786 End */ 
                }
                else
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->
                            facility_name, RRC_WARNING,
                            "Event %u is ignored because reestablishment "
                            "procedure ongoing during handover for ue_index: %d"
                            " and one event is already queued",
                            s1ap_pdu.u.initiatingMessage->procedureCode,
                            p_ue_context->ue_index );
                }
                break;
            }
        }

        rrc_asn1PrtToStr_S1AP_PDU(RRC_ASN,"S1AP_PDU", &s1ap_pdu);
        /*SPR_17976_END*/

        if (T_S1AP_PDU_initiatingMessage==s1ap_pdu.t)
        {
            uecc_s1ap_process_ue_assoc_sig_msg_ind_initiatingMessage(
                    p_uecc_gb_context, &s1ap_pdu, 
                    p_s1ap_ue_associated_sig_msg_ind, mme_id, encoded_len);

        }
        else if (T_S1AP_PDU_successfulOutcome==s1ap_pdu.t)
        {
            uecc_s1ap_process_ue_assoc_sig_msg_ind_successfulOutcome(
                    p_uecc_gb_context, &s1ap_pdu, 
                    p_s1ap_ue_associated_sig_msg_ind, mme_id, encoded_len);
        }
        else if (T_S1AP_PDU_unsuccessfulOutcome==s1ap_pdu.t)
        {
            uecc_s1ap_process_ue_assoc_sig_msg_ind_unsuccessfulOutcome(
                    p_uecc_gb_context, &s1ap_pdu, 
                    p_s1ap_ue_associated_sig_msg_ind, mme_id, encoded_len);
        }
        else
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"Wrong s1ap_pdu.t=%i",s1ap_pdu.t);
        }
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_ue_context_release_command_trace_handler
 *
 *   DESCRIPTION:
 *       This function handles TraceActivation for ue_context_release_command
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
static void uecc_s1ap_ue_context_release_command_trace_handler(
        uecc_ue_context_t  *p_ue_context,
        U8                 *buffer,
        U32                buffer_length,
        rrc_s1ap_ue_context_release_command_t msg)
{
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

        /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated)
    {
        /*SPR 15875 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
            (p_ue_context->p_ue_trace_activation_info != PNULL) &&
            (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
            P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(),GEN_MME, "\n <msg function=\"S1AP\" name=\"Ue Context Release Command\" changeTime=\"%.3f\" vendorSpecific=\"false\">",\
            difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
            (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
            (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
            P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(),GEN_CELL, "\n <msg function=\"S1AP\" name=\"Ue Context Release Command\" changeTime=\"%.3f\" vendorSpecific=\"false\">",\
            difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        /*SPR 15875 Fix Stop*/
        P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), S1,"\n <initiator type=\"MME\">%s</initiator>",
            p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);

        rrc_trace_max_file_write(p_ue_context, UE_CONTEXT_RELEASE_COMMAND, buffer_length, buffer, S1);

        /*SPR 15875 Fix Start*/
        /* SPR:5840 start */ 
        uecc_s1ap_p_rrc_trace_for_cause(p_ue_context,msg.cause);            
        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n </msg>");
        /* SPR:5840 stop */ 
        /*SPR 15896 Fix Stop*/
        /* TRACE_fix */
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: generate_protocol_event_LOCAL_S1_UE_CONTEXT_RELEASE_COMMAND
 *
 *   DESCRIPTION:
 *       This function Generates Protocol Event for
 *       LOCAL_S1_UE_CONTEXT_RELEASE_COMMAND
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
static void generate_protocol_event_LOCAL_S1_UE_CONTEXT_RELEASE_COMMAND(
        uecc_ue_context_t  *p_ue_context,
        U32                encoded_msg_len,
        U8                 *buffer,
        rrc_s1ap_ue_context_release_command_t msg)
{
    LOCAL_S1_UE_CONTEXT_RELEASE_COMMAND_STRUCT  *p_s1_ue_ctx_rel_cmd = PNULL;
    p_s1_ue_ctx_rel_cmd = rrc_mem_get(sizeof(LOCAL_S1_UE_CONTEXT_RELEASE_COMMAND_STRUCT) + 
            encoded_msg_len);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    if (PNULL != p_s1_ue_ctx_rel_cmd)
    {
        /* SES-508 Fix Start */
        /* Code Removed */
        /* SES-508 Fix End */

        p_s1_ue_ctx_rel_cmd->header.length = sizeof(LOCAL_S1_UE_CONTEXT_RELEASE_COMMAND_STRUCT) + 
            encoded_msg_len;
        p_s1_ue_ctx_rel_cmd->header.event_id = LOCAL_S1_UE_CONTEXT_RELEASE_COMMAND;

        if ((PNULL != p_ue_context->p_gb_context) && (PNULL != 
                    p_ue_context->p_gb_context->p_p_csc_context) && (PNULL !=
                        p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index])
                && (PNULL != p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                    p_csc_init_setup_ind))
        {
            l3_memcpy_wrapper(&p_s1_ue_ctx_rel_cmd->header.EVENT_PARAM_CELL_ID, 
                    p_ue_context->p_gb_context->
                    p_p_csc_context[p_ue_context->cell_index]->
                    p_csc_init_setup_ind->sib_type_1_Info.
                    cell_access_related_info.cell_Id, sizeof(U32));
        }
        p_s1_ue_ctx_rel_cmd->header.EVENT_PARAM_EUTRANCELL_FROID = 
            p_s1_ue_ctx_rel_cmd->header.EVENT_PARAM_CELL_ID;

        if (p_ue_context->m.mme_ue_id_present)
        {
            p_s1_ue_ctx_rel_cmd->header.EVENT_PARAM_MMES1APID = p_ue_context->mme_ue_id;
        }

        p_s1_ue_ctx_rel_cmd->header.EVENT_PARAM_RAC_UE_REF = p_ue_context->s1ap_ue_id;
        p_s1_ue_ctx_rel_cmd->EVENT_PARAM_MESSAGE_DIRECTION = MESSAGE_DIRECTION_RECEIVED;

        p_s1_ue_ctx_rel_cmd->EVENT_PARAM_L3MESSAGE_LENGTH = encoded_msg_len;

        p_s1_ue_ctx_rel_cmd->EVENT_PARAM_3GPP_CAUSE_GROUP = (U32)msg.cause.t; 

        switch(p_s1_ue_ctx_rel_cmd->EVENT_PARAM_3GPP_CAUSE_GROUP)
        { 
            case T_s1ap_Cause_radioNetwork: 
                p_s1_ue_ctx_rel_cmd->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.radioNetwork;
                break;

            case T_s1ap_Cause_transport: 
                p_s1_ue_ctx_rel_cmd->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.transport;
                break;

            case T_s1ap_Cause_nas: 
                p_s1_ue_ctx_rel_cmd->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.nas;
                break; 

            case T_s1ap_Cause_protocol:
                p_s1_ue_ctx_rel_cmd->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.protocol;
                break; 

            case T_s1ap_Cause_misc:
                p_s1_ue_ctx_rel_cmd->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.misc;
                break; 
        }

        l3_memcpy_wrapper((void *)(((U8*)p_s1_ue_ctx_rel_cmd) + 
                    sizeof(LOCAL_S1_UE_CONTEXT_RELEASE_COMMAND_STRUCT)),
                (const void*)buffer,
                encoded_msg_len);
        rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_s1_ue_ctx_rel_cmd);
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: generate_protocol_event_LOCAL_UE_CTXT_RELEASE_ATTEMPT_ENB
 *
 *   DESCRIPTION:
 *       This function Generates Protocol Event for
 *       LOCAL_UE_CTXT_RELEASE_ATTEMPT_ENB
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
static void generate_protocol_event_LOCAL_UE_CTXT_RELEASE_ATTEMPT_ENB(
        uecc_ue_context_t  *p_ue_context,
        rrc_s1ap_ue_context_release_command_t msg)
{
    U8 counter = 0;
    U8 qci_value = 0;
    LOCAL_UE_CTXT_RELEASE_ATTEMPT_ENB_STRUCT    *p_ue_ctx_rel_attempt_enb = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    p_ue_ctx_rel_attempt_enb = rrc_mem_get(sizeof(LOCAL_UE_CTXT_RELEASE_ATTEMPT_ENB_STRUCT));

    if (PNULL != p_ue_ctx_rel_attempt_enb)
    {
        /* SES-508 Fix Start */
        /* Code Removed */
        /* SES-508 Fix End */
        p_ue_ctx_rel_attempt_enb->header.length = 
            sizeof(LOCAL_UE_CTXT_RELEASE_ATTEMPT_ENB_STRUCT);
        p_ue_ctx_rel_attempt_enb->header.event_id = LOCAL_UE_CTXT_RELEASE_ATTEMPT_ENB;

        if ((PNULL != p_ue_context->p_gb_context) && (PNULL != 
                    p_ue_context->p_gb_context->p_p_csc_context) && (PNULL !=
                        p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index])
                && (PNULL != p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                    p_csc_init_setup_ind))
        {
            l3_memcpy_wrapper(&p_ue_ctx_rel_attempt_enb->header.EVENT_PARAM_CELL_ID, 
                    p_ue_context->p_gb_context->
                    p_p_csc_context[p_ue_context->cell_index]->
                    p_csc_init_setup_ind->sib_type_1_Info.
                    cell_access_related_info.cell_Id, sizeof(U32));
        }
        p_ue_ctx_rel_attempt_enb->header.EVENT_PARAM_EUTRANCELL_FROID = 
            p_ue_ctx_rel_attempt_enb->header.EVENT_PARAM_CELL_ID;

        if (p_ue_context->m.mme_ue_id_present)
        {
            p_ue_ctx_rel_attempt_enb->header.EVENT_PARAM_MMES1APID = p_ue_context->mme_ue_id;
        }

        p_ue_ctx_rel_attempt_enb->header.EVENT_PARAM_RAC_UE_REF = p_ue_context->s1ap_ue_id;

        p_ue_ctx_rel_attempt_enb->EVENT_PARAM_3GPP_CAUSE_GROUP = (U32)msg.cause.t;

        switch(p_ue_ctx_rel_attempt_enb->EVENT_PARAM_3GPP_CAUSE_GROUP)
        { 
            case T_s1ap_Cause_radioNetwork: 
                p_ue_ctx_rel_attempt_enb->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.radioNetwork;
                break;

            case T_s1ap_Cause_transport: 
                p_ue_ctx_rel_attempt_enb->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.transport;
                break;

            case T_s1ap_Cause_nas: 
                p_ue_ctx_rel_attempt_enb->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.nas;
                break; 

            case T_s1ap_Cause_protocol:
                p_ue_ctx_rel_attempt_enb->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.protocol;
                break; 

            case T_s1ap_Cause_misc:
                p_ue_ctx_rel_attempt_enb->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.misc;
                break; 
        } 
    }

    if (PNULL != p_ue_context->p_gb_context)
    {
        for (counter = 0; counter < MAX_ERAB_COUNT; counter++)
        {
            if (PNULL != p_ue_context->p_e_rab_list[counter])
            {
                /* update the performance counter */
                qci_value = p_ue_context->p_e_rab_list[counter]->
                    e_RABlevelQoSParameters.qCI;
                /* SPR 21070 Fix Start */ 
                if ((PNULL != g_rrc_stats.p_rrc_stats) &&
                    (PNULL != p_ue_context->uecc_fsm.p_current_state->s_name) && 
                    (strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                    (const S8 *)"UECC_UE_CONNECTION_RELEASE_ONGOING")))
                /* SPR 21070 Fix End */
                {
                    /* SPR 13441 Fix Start */
                    if ( (RRC_MIN_QCI_GBR_LIMIT <= qci_value) &&
                            (RRC_MAX_QCI_NON_GBR_LIMIT >= qci_value) )
                    {
                        RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context, 
                            g_rrc_stats.p_rrc_stats->
                            rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                            p_gb_context->offset_uecc_mod_id].
                            rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                            erab_release_stats.
                            erab_relAttNbr_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
                            RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

                    RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context, 
                            g_rrc_stats.p_rrc_stats->
                            rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                            p_gb_context->offset_uecc_mod_id].
                            rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                            erab_release_stats.erab_relAttNbr_sum, 
                            RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);
                    }
                    /* SPR 13441 Fix End */
                }

                if (PNULL != p_ue_ctx_rel_attempt_enb)
                {
                    p_ue_ctx_rel_attempt_enb->EVENT_ARRAY_ERAB_SETUP_REQ_ARP[counter] =
                        p_ue_context->p_e_rab_list[counter]->e_RABlevelQoSParameters.
                        allocationRetentionPriority.priorityLevel;

                    p_ue_ctx_rel_attempt_enb->EVENT_ARRAY_ERAB_SETUP_REQ_PCI[counter] =
                        p_ue_context->p_e_rab_list[counter]->e_RABlevelQoSParameters.
                        allocationRetentionPriority.pre_emptionCapability;

                    p_ue_ctx_rel_attempt_enb->EVENT_ARRAY_ERAB_SETUP_REQ_PVI[counter] =
                        p_ue_context->p_e_rab_list[counter]->e_RABlevelQoSParameters.
                        allocationRetentionPriority.pre_emptionVulnerability;
                }
            }
        }
    }

    if (PNULL != p_ue_ctx_rel_attempt_enb)
    {
        rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_ue_ctx_rel_attempt_enb);
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_ue_context_release_command
 *
 *   INPUTS       : S1AP_PDU            *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  U8                  mme_id
 *                  U8                 *buffer
 *                  U32                buffer_length
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes s1ap_UEContextReleaseCommand
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_ue_context_release_command
(
 S1AP_PDU            *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context,  /* UECC global context */
 U8                  mme_id,
 U8                 *buffer,
/*BUG 604 changes start*/ 
 U32                buffer_length,
 U16                ue_index
/*BUG 604 changes stop*/ 
 )
{
    U32                 enb_ue_s1ap_id;
    /* GDB fix - compiler warning */
    U32                 mme_ue_s1ap_id  = 0;
    uecc_ue_context_t   *p_ue_context = PNULL;
    
    /*SPR_19239_start*/
    rrc_s1ap_ue_context_release_command_t *p_msg = PNULL;
    /*SPR_19239_stop*/

    /* SPR 2399 Start */
    rrc_s1ap_error_indication_t     error_indication;
    rrc_return_et                   result = RRC_SUCCESS;
    /* SPR 2399 Stop */
    ueccmd_ue_context_release_ongoing_ind_t     ue_context_release;
    /* SPR 22634 Fix +- */

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    /*SPR_19695_FIX_START*/
    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO, "Received UE CONTEXT RELEASE CMD for ue_index[%u]", ue_index);
    /*SPR_19695_FIX_STOP*/

    /* SPR 2399 Start */
    memset_wrapper(&error_indication, 0, sizeof(rrc_s1ap_error_indication_t));
    /* SPR 2399 Stop */

    memset_wrapper(&ue_context_release, 0, 
            sizeof(ueccmd_ue_context_release_ongoing_ind_t));

    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_ASSERT(PNULL!=p_s1ap_pdu->u.initiatingMessage);

    ue_context_release.result = RRC_FAILURE;
    /*SPR_19239_start*/
    p_msg = rrc_mem_get(sizeof(rrc_s1ap_ue_context_release_command_t));
    if(PNULL == p_msg)
    {
       /* Memory Allocation Failed */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,  p_uecc_gb_context->facility_name, RRC_WARNING,
                    "Memory Allocation Failure");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return;
    }
    /* SES-508 Fix Start */
    /* Code Removed */
    /* SES-508 Fix End */
    /*SPR_19239_stop*/

    do
    {
        if (PNULL==p_s1ap_pdu->u.initiatingMessage->value.u.uEContextRelease)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_UEContextReleaseCommand] uEContextRelease field is PNULL");
            result = RRC_FAILURE;
            /* Drop message */
            break;
        }

        /*SPR_19239_start*/
        /* Decode message */
        if (RRC_FAILURE == rrc_s1ap_ue_context_release_command_intrl_dec(
                    p_uecc_gb_context,
                    mme_id, /* just copy fields without allocation */
                    p_s1ap_pdu->u.initiatingMessage->value.u.uEContextRelease,
                    p_msg))
        {
            /* Message parsing error */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_UEContextReleaseCommand] Parsing error");
            result = RRC_FAILURE;
            break;
        }
        /* Process message */
        if (p_msg->ue_s1ap_ids.t == T_s1ap_UE_S1AP_IDs_uE_S1AP_ID_pair)
        {
            /* Get context using S1AP id */
            if (RRC_SUCCESS != uecc_s1ap_get_enb_s1ap_id_from_ue_s1ap_ids(
                        &p_msg->ue_s1ap_ids,&enb_ue_s1ap_id))
            {
                /*SPR_19695_FIX_START*/
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[s1ap_UEContextReleaseCommand] Can't get enb_ue_s1ap_id for ue_index[%u]", ue_index);
                /*SPR_19695_FIX_STOP*/
                result = RRC_FAILURE;
                /* Drop message */
                break;
            }
            else
            {
                /*BUG 604 changes start*/
                p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,ue_index);
                /*BUG 604 changes stop*/
            }
        }
        else if (p_msg->ue_s1ap_ids.t == T_s1ap_UE_S1AP_IDs_mME_UE_S1AP_ID)
        {
            /*SPR_19695_FIX_START*/
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO,
                    "[s1ap_UEContextReleaseCommand] Only MME UE S1AP ID [%u] present\n", p_msg->ue_s1ap_ids.u.mME_UE_S1AP_ID);
            /*SPR_19695_FIX_STOP*/
            {
                p_ue_context = uecc_ue_ctx_get_by_mme_s1ap_id(
                    p_uecc_gb_context,
                    p_msg->ue_s1ap_ids.u.mME_UE_S1AP_ID);
            }
        }

        if (PNULL==p_ue_context )
        {
            /* Error. Can't find UE context */
            /* Drop message */
            /*SPR_19695_FIX_START*/
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_UEContextReleaseCommand] UE context not found for ueIndex [%u]", ue_index);
            /*SPR_19695_FIX_STOP*/
            /* SPR 2399 Start */
            error_indication.bitmask |=
                RRC_S1AP_ERROR_INDICATION_MME_UE_S1AP_ID_PRESENT;
            if (p_msg->ue_s1ap_ids.t == T_s1ap_UE_S1AP_IDs_uE_S1AP_ID_pair)
            {
                error_indication.mme_ue_s1ap_id =
                      p_msg->ue_s1ap_ids.u.uE_S1AP_ID_pair->mME_UE_S1AP_ID;
            }
            else if (p_msg->ue_s1ap_ids.t == T_s1ap_UE_S1AP_IDs_mME_UE_S1AP_ID)
            {
                error_indication.mme_ue_s1ap_id =
                      p_msg->ue_s1ap_ids.u.mME_UE_S1AP_ID;
            }
            /*SPR_19239_stop*/
            error_indication.bitmask |= RRC_S1AP_ERROR_INDICATION_CAUSE_PRESENT;
            error_indication.cause.t = T_s1ap_Cause_radioNetwork;
            error_indication.cause.u.radioNetwork = s1ap_unknown_mme_ue_s1ap_id;
            result = RRC_FAILURE;
            /* SPR 2399 Stop */
            break;
        }
       
        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_UEContextReleaseCommand]"
                    "message dropped - "
                    "UECC isn't initialized by CSC ");

            /*SPR 21947 Start */
            result = RRC_FAILURE;
            break;

            /*SPR 21947 Stop */
        }

        /*SPR_19239_start*/
        if (RRC_SUCCESS ==
                uecc_s1ap_get_mme_s1ap_id_from_ue_s1ap_ids(
                    &p_msg->ue_s1ap_ids,
                    &mme_ue_s1ap_id))
        /*SPR_19239_stop*/
        {
            if (0!=p_ue_context->m.mme_ue_id_present)
            {
                if (mme_ue_s1ap_id != p_ue_context->mme_ue_id)
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "[s1ap_UEContextReleaseCommand] "
                            "mme_ue_s1ap_id (%i) != p_ue_context->mme_ue_id (%i)",
                            mme_ue_s1ap_id,
                            p_ue_context->mme_ue_id);
                    /* Drop message */
                    /* SPR 22491 Fix Start */
                    result = RRC_FAILURE;
                    /* SPR 22491 Fix End */
                    break;
                }
            }
            else
            {
                /* store mme_ue_s1ap_id in UE context */
                p_ue_context->m.mme_ue_id_present = 1;
                p_ue_context->mme_ue_id = mme_ue_s1ap_id;

                /*spr_22511_changes_start*/
                if ( PNULL != g_rrc_stats.p_rrc_stats )
                {
                    RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                            g_rrc_stats.p_rrc_stats->
                            rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                            p_gb_context->offset_uecc_mod_id].
                            rrc_uecc_cell_stats[p_ue_context->cell_index].
                            rrc_ue_assoc_s1_conn_related_stats.
                            s1sig_connEstabSucc, 0, DUMMY_RANGE_CHECK_INDEX);
                }
                /*spr_22511_changes_end*/
            }
        }
        /*SPR_19239_start*/
        /* Generating Protocol Event LOCAL_S1_UE_CONTEXT_RELEASE_COMMAND*/
        /* SPR 22634 Fix - Starts */
        generate_protocol_event_LOCAL_S1_UE_CONTEXT_RELEASE_COMMAND(
            p_ue_context, (U32) buffer_length, buffer, *p_msg);
        /* SPR 22634 Fix - Ends */

        /* Is trace activated */
        uecc_s1ap_ue_context_release_command_trace_handler(
            p_ue_context, buffer, buffer_length, *p_msg);

        /* Generating Protocol Event LOCAL_UE_CTXT_RELEASE_ATTEMPT_ENB*/
        generate_protocol_event_LOCAL_UE_CTXT_RELEASE_ATTEMPT_ENB(p_ue_context, *p_msg);
        /*SPR_19239_stop*/
        /* SPR 22491 Fix Start */
        /* Result = rrc_success as UE Context for this particular 
         * mme UE S1AP ID is found on this particular UECC instance */
        ue_context_release.result = RRC_SUCCESS;
        ue_context_release.mme_ue_s1ap_id = mme_ue_s1ap_id;

        if (p_msg->ue_s1ap_ids.t == T_s1ap_UE_S1AP_IDs_mME_UE_S1AP_ID)
        {
            if(RRC_FAILURE != uecc_rrc_send_internal_msg(RRC_UECCMD_MODULE_ID,
                    UECCMD_UE_CONTEXT_RELEASE_ONGOING_IND,
                    sizeof(ueccmd_ue_context_release_ongoing_ind_t),
                    &ue_context_release))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[uecc_s1ap_process_ue_context_release_command]"
                    "uecc_rrc_send_internal_msg failed");
            }
        }
        /* SPR 22491 Fix End */
        /* Call UECC_UE_EVENT_UE_RELEASE_REQ event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */

        /*SPR_19239_start*/
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_UE_RELEASE_REQ,
               (void*)p_msg);

        /*SPR_19239_stop*/
        /* SPR 22491 Fix +- */

    } while (0);

    /* SPR 2399 Start */
    if (RRC_FAILURE == result)
    {
        if ((RRC_S1AP_ERROR_INDICATION_MME_UE_S1AP_ID_PRESENT &
             error_indication.bitmask) ||
             (RRC_S1AP_ERROR_INDICATION_ENB_UE_S1AP_ID_PRESENT &
              error_indication.bitmask) ||
             (RRC_S1AP_ERROR_INDICATION_CAUSE_PRESENT &
              error_indication.bitmask))
        {
            uecc_s1ap_build_and_send_err_indication(p_uecc_gb_context,
                RRC_UECCMD_MODULE_ID,mme_id,
                &error_indication);
        }

         /*SPR_19239_start*/
        if (PNULL != p_msg)
        {
           rrc_mem_free(p_msg);
           p_msg = PNULL;
        }
        /*SPR_19239_stop*/
    }
    /* SPR 22491 Fix +- */
   /* SPR 2399 End */

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/* ERAB SETUP Start */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_erab_setup_request
 *
 *   INPUTS       : S1AP_PDU            *p_s1ap_pd
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  U8                  mme_id
 *                  U8          *p_buff
 *                  U16         buff_size
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes s1ap_E_RABSETUP
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_erab_setup_request
(
 S1AP_PDU            *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
 U8                  mme_id,
 U8          *p_buff,        /* ASN.1 encoded message */
/*BUG 604 changes start*/ 
 U16         buff_size,      /* encoded buf size - just for check*/
 U16         ue_index
/*BUG 604 changes stop*/ 
 )
{
    uecc_ue_context_t              *p_ue_context = PNULL;
    OSRTDListNode  *p_node_msg = PNULL;
    s1ap_E_RABToBeSetupListBearerSUReq_element *p_erab_elem = PNULL;
    rrc_s1ap_erab_setup_request_t  msg;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER          *p_event_header = PNULL;
    U32                            encoded_msglen = 0;

    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_ASSERT(PNULL!=p_s1ap_pdu->u.initiatingMessage);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    /*Initilize the time*/
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    do
    {

        if (PNULL==p_s1ap_pdu->u.initiatingMessage->value.u.e_RABSetup)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_E_RABSetupRequest] erabSetup field is PNULL");
            break;
        }

        memset_wrapper(&msg, 0, sizeof(rrc_s1ap_erab_setup_request_t));

        /* Decode message */
        if( RRC_FAILURE == rrc_s1ap_erab_setup_request_intrl_dec(
                    mme_id,
                    p_s1ap_pdu->u.initiatingMessage->value.u.e_RABSetup,
                    &msg,
                    p_uecc_gb_context
                    ))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, " ERAB Setup REquest "
                    "Decoding Failure, Sending Error Indication");
            break;
        }

        /* Process message */
        /*BUG 604 changes start*/ 
        /* Get context using ue_index */
        /*p_ue_context = uecc_ue_ctx_get_by_s1ap_id(p_uecc_gb_context,
                msg.enb_ue_s1ap_id);*/
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,ue_index);
        /*BUG 604 changes stop*/ 

        if (PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_E_RABSetupRequest] UE context not found");

            break;
        }
        
        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_E_RABSetupRequest]"
                    "message dropped - "
                    "UECC isn't initialized by CSC" );
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }
        if (0!=p_ue_context->m.mme_ue_id_present)
        {
            if (msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[s1ap_E_RABSetupRequest] "
                        "mme_ue_s1ap_id (%i) != p_ue_context->mme_ue_id (%i)",
                        msg.mme_ue_s1ap_id,
                        p_ue_context->mme_ue_id);

                break;
            }
        }
        else
        {
            /* store mme_ue_s1ap_id in UE context */
            p_ue_context->m.mme_ue_id_present = 1;
            p_ue_context->mme_ue_id = msg.mme_ue_s1ap_id;
        }
        
        if (PNULL != p_ue_context)
        {
            /*Generating Protocol Events */
            /* SPR 22634 Fix - Starts */
            encoded_msglen = (U32)(buff_size);
            /* SPR 22634 Fix - Ends */
            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msglen);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msglen),
                        LOCAL_S1_ERAB_SETUP_REQUEST,
                        MESSAGE_DIRECTION_RECEIVED);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_buff,
                        encoded_msglen);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        /* Is trace activated */
        if (p_ue_context->m.traceActivated)
        {
            /*SPR 15896 Fix Start*/
            /*SPR 15875 Fix Start*/
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
            {
                P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), GEN_MME, "\n<msg function=\"S1AP\" name=\"E-RAB Setup Request\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
            }
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
            {
                P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), GEN_CELL, "\n<msg function=\"S1AP\" name=\"E-RAB Setup Request\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
            }
            /*SPR 15875 Fix Stop*/
            P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), S1,"\n <initiator type=\"MME\">%s</initiator>",
                p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);

            rrc_trace_max_file_write(p_ue_context, ERAB_SETUP_REQ , buff_size, p_buff, S1);
            /*SPR 15896 Fix Stop*/

                for (p_node_msg = msg.e_rab_to_be_setup_list.head; PNULL!=p_node_msg;
                        p_node_msg=p_node_msg->next)
                {
                    p_erab_elem=(s1ap_E_RABToBeSetupListBearerSUReq_element*)p_node_msg->data;
                    if ((p_erab_elem == PNULL) || (p_erab_elem->value.u._E_RABToBeSetupItemBearerSUReqIEs_1 == PNULL ))
                    {
                        continue;
                    }

                    /*SPR 15896 Fix Start*/
                    if (p_ue_context->m.traceActivated )
                    {
                        /* QOS PARAMETER */
                        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ieGroup name=\"Erab-Id Qos Paramter\" value=\"%d\">", p_erab_elem->value.u._E_RABToBeSetupItemBearerSUReqIEs_1->e_RAB_ID);
                        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"QCI\">%d</ie>",p_erab_elem->value.u._E_RABToBeSetupItemBearerSUReqIEs_1->e_RABlevelQoSParameters.qCI) ;
                        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1, "\n <ie name=\"Allocation Retenion-Priority Level\">%d</ie>",p_erab_elem->value.u._E_RABToBeSetupItemBearerSUReqIEs_1->e_RABlevelQoSParameters.allocationRetentionPriority.priorityLevel);
                        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"Allocation Retenion-Premeption Capability\">%d</ie>",
                                p_erab_elem->value.u._E_RABToBeSetupItemBearerSUReqIEs_1->e_RABlevelQoSParameters.allocationRetentionPriority.pre_emptionCapability);
                        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"Allocation Retenion-Premeption Venerability\">%d</ie>",
                                p_erab_elem->value.u._E_RABToBeSetupItemBearerSUReqIEs_1->e_RABlevelQoSParameters.allocationRetentionPriority.pre_emptionVulnerability);
                        if((p_erab_elem->value.u._E_RABToBeSetupItemBearerSUReqIEs_1->e_RABlevelQoSParameters.qCI >0) && (p_erab_elem->value.u._E_RABToBeSetupItemBearerSUReqIEs_1->e_RABlevelQoSParameters.qCI <5))
                        {
                            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"GBR_QosInformation-Max Bitrate DL\">%u</ie>",
                                p_erab_elem->value.u._E_RABToBeSetupItemBearerSUReqIEs_1->e_RABlevelQoSParameters.gbrQosInformation.e_RAB_MaximumBitrateDL);
                            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"GBR_QosInformation-Max Bitrate UL\">%u</ie>",
                                p_erab_elem->value.u._E_RABToBeSetupItemBearerSUReqIEs_1->e_RABlevelQoSParameters.gbrQosInformation.e_RAB_MaximumBitrateUL);
                            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"GBR_QosInformation-Guranteed Bitrate DL\">%u</ie>",
                                p_erab_elem->value.u._E_RABToBeSetupItemBearerSUReqIEs_1->e_RABlevelQoSParameters.gbrQosInformation.e_RAB_GuaranteedBitrateDL);
                            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"GBR_QosInformation-Guranteed Bitrate UL\">%u</ie>",
                                p_erab_elem->value.u._E_RABToBeSetupItemBearerSUReqIEs_1->e_RABlevelQoSParameters.gbrQosInformation.e_RAB_GuaranteedBitrateUL);
                        }
                        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n </ieGroup> ");
                    }
                    /*SPR 15896 Fix Stop*/
                }
        }
        /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated) 
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n </msg> ");  
        /*SPR 15896 Fix Stop*/

        /* Call UECC_UE_EVENT_UE_CTX_SETUP_REQ event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_S1AP_ERAB_SETUP_REQ,
                &msg);
    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_ics_req_trace_handler
 *
 *   DESCRIPTION:
 *       This function processes s1ap_InitialContextSetup TraceActivation
 *
 *   RETURNS:
 *       RRC_SUCCESS, RRC_FAILURE
 *
 ******************************************************************************/
static rrc_return_et uecc_s1ap_process_ics_req_trace_handler(
        uecc_gb_context_t   *p_uecc_gb_context,
        uecc_ue_context_t   *p_ue_context,
        U16                 buff_size,
        U8                  *p_buff,
        rrc_s1ap_initial_context_setup_request_t *p_msg)
{
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    OSRTDListNode   *p_node_msg = PNULL;
    s1ap_E_RABToBeSetupListCtxtSUReq_element *p_erab_elem = PNULL;
    /*SPR 15896 Fix Start*/
    /* Code Removed */
    /*SPR 15896 Fix Stop*/

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* TRACE_fix */
    /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) 
    /*SPR 15896 Fix Stop*/
    {
        /* Build and send CELL_TRAFFIC_TRACE to S1AP */
        if (RRC_SUCCESS !=
                uecc_s1ap_build_and_send_cell_traffic_trace(p_ue_context))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "Send to fail [CELL TAFFIC TRACE] for %d ue_index", 
                    p_ue_context->ue_index);
        }
    }
    /* TRACE_fix */
    if (p_msg->bitmask & 
            RRC_S1AP_INITIAL_CONTEXT_SETUP_REQUEST_TRACE_ACTIVATION_PRESENT)
    {
        /*SPR 15896 Fix Start*/
        /* Code Removed */
        /*SPR 15896 Fix Stop*/
        if (PNULL == (p_ue_context->p_ue_trace_activation_info =
                    (ue_trace_activation_info_t*)
                    rrc_mem_get(sizeof(ue_trace_activation_info_t))))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_FATAL,
                    "[TraceActivation]"
                    "Memory Allocation Failed");
            return RRC_FAILURE;
        }
        else
        {
            /* SES-508 Fix Start */
            /* Code Removed */
            /* SES-508 Fix End */

            /*SPR 15896 Fix Start*/
            /* Set trace activation flag */
            p_ue_context->m.traceActivated |= 
                RRC_TRACE_ACTIVATION_MME_INITIATE;
            /*SPR 15896 Fix Stop*/
            /* store e_utran_trace_id */
            l3_memcpy_wrapper(
                    p_ue_context->p_ue_trace_activation_info->trace_id_info.
                    eutran_trace_id.data,
                    p_msg->trace_activation.e_UTRAN_Trace_ID.data,
                    p_msg->trace_activation.e_UTRAN_Trace_ID.numocts);

            p_ue_context->p_ue_trace_activation_info->trace_id_info.
                eutran_trace_id.numoctet = 
                p_msg->trace_activation.e_UTRAN_Trace_ID.numocts;

            /* store interfaces to trace */
            p_ue_context->p_ue_trace_activation_info->interfaces_to_trace = 0;
            if (p_msg->trace_activation.interfacesToTrace.data[0] & TRACE_S1AP_INTERFACE)
                p_ue_context->p_ue_trace_activation_info->interfaces_to_trace |= S1;
            if (p_msg->trace_activation.interfacesToTrace.data[0] & TRACE_X2AP_INTERFACE)
                p_ue_context->p_ue_trace_activation_info->interfaces_to_trace |= X2;
            if (p_msg->trace_activation.interfacesToTrace.data[0] & TRACE_UU_INTERFACE)
                p_ue_context->p_ue_trace_activation_info->interfaces_to_trace |= UU;

            /* store trace depth */
            p_ue_context->p_ue_trace_activation_info->trace_depth =
                (trace_depth_et)p_msg->trace_activation.traceDepth;

            /* store trace collection entity info */
            if (!(p_msg->trace_activation.traceCollectionEntityIPAddress.numbits
                        % RRC_OCTET_SIZE)) 
            {
                p_ue_context->p_ue_trace_activation_info->
                    trace_collection_entity_info.length = 
                    (U8)(p_msg->trace_activation.traceCollectionEntityIPAddress.numbits
                            / RRC_OCTET_SIZE);
            }
            else
            {
                p_ue_context->p_ue_trace_activation_info->
                    trace_collection_entity_info.length = 
                    (U8)((p_msg->trace_activation.traceCollectionEntityIPAddress.numbits
                                / RRC_OCTET_SIZE) + 1);
            }
            l3_memcpy_wrapper(p_ue_context->p_ue_trace_activation_info->
                    trace_collection_entity_info.data, 
                    p_msg->trace_activation.traceCollectionEntityIPAddress.data,
                    p_ue_context->p_ue_trace_activation_info->
                    trace_collection_entity_info.length);
            /*SPR 15896 Fix Start*/
            if (PNULL == p_ue_context->p_ue_trace_activation_info->fp)
            {
                uecc_generate_trace_file_name(p_ue_context,TRACE_S1AP_INITIATED);
            }

            /*SPR 15896 Fix Stop*/
        }
    }
    /* Is trace activated */
    /*coverity_87769_indentation_fix*/
    if (p_ue_context->m.traceActivated )
    {
        /*SPR 15896 Fix Start*/
        /*SPR 15875 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_MME, "\n<msg function=\"S1AP\" name=\"Initial Context Setup Request\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_CELL, "\n<msg function=\"S1AP\" name=\"Initial Context Setup Request\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        /*SPR 15875 Fix Stop*/
        P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),S1,"\n <initiator type=\"MME\">%s</initiator>",
                p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
        /* ASN.1 encoded message to logged */
        rrc_trace_max_file_write(p_ue_context, INITIAL_CONTEXT_SETUP_REQ , buff_size, p_buff, S1);
        /*SPR 15896 Fix Stop*/
        for (p_node_msg = p_msg->e_rab_to_be_setup_list.head; PNULL!=p_node_msg;
                p_node_msg=p_node_msg->next)
        {
            p_erab_elem=(s1ap_E_RABToBeSetupListCtxtSUReq_element*)p_node_msg->data;
            if ((p_erab_elem == PNULL) || (p_erab_elem->value.u._E_RABToBeSetupItemCtxtSUReqIEs_1 == PNULL ))
            {
                continue;
            }

            /*SPR 15896 Fix Start*/
            /* QOS PARAMETER */
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n <ieGroup name=\"Erab-Id Qos Paramter\" value=\"%d\">", 
                    p_erab_elem->value.u._E_RABToBeSetupItemCtxtSUReqIEs_1->e_RAB_ID);
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask (),S1,"\n <ie name=\"QCI\">%d</ie>",
                    p_erab_elem->value.u._E_RABToBeSetupItemCtxtSUReqIEs_1->e_RABlevelQoSParameters.qCI) ;
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1, "\n <ie name=\"Allocation Retenion-Priority Level\">%d</ie>",
                    p_erab_elem->value.u._E_RABToBeSetupItemCtxtSUReqIEs_1->e_RABlevelQoSParameters.allocationRetentionPriority.priorityLevel);
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"Allocation Retenion-Premeption Capability\">%d</ie>",
                    p_erab_elem->value.u._E_RABToBeSetupItemCtxtSUReqIEs_1->e_RABlevelQoSParameters.allocationRetentionPriority.pre_emptionCapability);
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"Allocation Retenion-Premeption Venerability\">%d</ie>",
                    p_erab_elem->value.u._E_RABToBeSetupItemCtxtSUReqIEs_1->e_RABlevelQoSParameters.allocationRetentionPriority.pre_emptionVulnerability);
            if((p_erab_elem->value.u._E_RABToBeSetupItemCtxtSUReqIEs_1->e_RABlevelQoSParameters.qCI >0) && 
                    (p_erab_elem->value.u._E_RABToBeSetupItemCtxtSUReqIEs_1->e_RABlevelQoSParameters.qCI <5))
            {
                P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"GBR_QosInformation-Max Bitrate DL\">%u</ie>",
                        p_erab_elem->value.u._E_RABToBeSetupItemCtxtSUReqIEs_1->e_RABlevelQoSParameters.gbrQosInformation.e_RAB_MaximumBitrateDL);
                P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"GBR_QosInformation-Max Bitrate UL\">%u</ie>",
                        p_erab_elem->value.u._E_RABToBeSetupItemCtxtSUReqIEs_1->e_RABlevelQoSParameters.gbrQosInformation.e_RAB_MaximumBitrateUL);                            
                P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"GBR_QosInformation-Guranteed Bitrate DL\">%u</ie>",
                        p_erab_elem->value.u._E_RABToBeSetupItemCtxtSUReqIEs_1->e_RABlevelQoSParameters.gbrQosInformation.e_RAB_GuaranteedBitrateDL);
                P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"GBR_QosInformation-Guranteed Bitrate UL\">%u</ie>",
                        p_erab_elem->value.u._E_RABToBeSetupItemCtxtSUReqIEs_1->e_RABlevelQoSParameters.gbrQosInformation.e_RAB_GuaranteedBitrateUL);
            }
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n </ieGroup> ");  
        }
    }
    /* SPR:7524 start */
    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n </msg> ");  
    /*SPR 15896 Fix Stop*/
    /* SPR:7524 stop */
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_initial_context_setup_request
 *
 *   INPUTS       : S1AP_PDU            *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  s1ap_ue_associated_sig_msg_ind_t 
 *                                             *p_s1ap_ue_associated_sig_msg_ind
 *                   U16         buff_size
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes s1ap_InitialContextSetup
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_initial_context_setup_request
(
 S1AP_PDU            *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
 s1ap_ue_associated_sig_msg_ind_t *p_s1ap_ue_associated_sig_msg_ind, /* UE Associated Sig Msg Ind */
/*BUG 604 changes start*/
 U16         buff_size,      /* encoded buf size - just for check*/
 U16         ue_index
/*BUG 604 changes stop*/ 
 )
{
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_s1ap_initial_context_setup_request_t msg;
    rrc_s1ap_error_indication_t              error_indication;
    uecc_s1ap_error_ind_bool_t               send_err_ind;
    rrc_return_et resp = RRC_SUCCESS;
    OSCTXT asn1_ctx;
    U8     *p_buff = &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0]; 
    U8     mme_id = p_s1ap_ue_associated_sig_msg_ind->mme_id;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;

    memset_wrapper(&error_indication, 0, sizeof(rrc_s1ap_error_indication_t));
    memset_wrapper(&send_err_ind, 0, sizeof(uecc_s1ap_error_ind_bool_t));

    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_ASSERT(PNULL!=p_s1ap_pdu->u.initiatingMessage);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "[s1ap_ErrorIndication] ASN context initialization failed");
        return;
    }

    do
    {
        if (PNULL==p_s1ap_pdu->u.initiatingMessage->value.u.initialContextSetup)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_InitialContextSetup] initialContextSetup field is PNULL");
            break;
        }

        memset_wrapper(&msg,0,sizeof(rrc_s1ap_initial_context_setup_request_t));
        /* Decode message */
        resp = rrc_s1ap_initial_context_setup_request_intrl_dec(
                &asn1_ctx,
                mme_id,
                p_s1ap_pdu->u.initiatingMessage->value.u.initialContextSetup,
                &msg,
                &error_indication,
                &send_err_ind,
                p_uecc_gb_context);

        if (RRC_SUCCESS != resp)
        {
            /* Message parsing error */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_InitialContextSetup] Parsing error");
            /* Drop. */
            break;
        }

        /* SPR 1643 Start */
        /* PLMN Identity Validation */
        if( 
           RRC_S1AP_INITIAL_CONTEXT_SETUP_REQUEST_HANDOVER_RESTRICTION_LIST_PRESENT 
           &
           msg.bitmask)
        {
            if (RRC_FAILURE == validate_ho_restriction_list_plmn_identity(
                        &msg.handover_restriction_list,p_uecc_gb_context))
            {
                /* PLMN ID range check error */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[s1ap_InitialContextSetup] PLMN ID Range Invalid");
                /* Drop. */
                break;
            }
        }
        /* SPR 1643 Stop */

        /* Process message */
        /* Get context using S1AP id */
        /*BUG 604 changes start*/ 
        /*p_ue_context = uecc_ue_ctx_get_by_s1ap_id(p_uecc_gb_context,
                msg.enb_ue_s1ap_id);*/
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,ue_index);
        /*BUG 604 changes stop*/ 

        if (PNULL==p_ue_context )
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_InitialContextSetup] UE context not found");

            break;
        }
        
        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"[s1ap_InitialContextSetup]"
                    "message dropped - "
                    "UECC isn't initialized by CSC" );
            /*SPR_18125_START*/
            rtFreeContext(&asn1_ctx);
            /*SPR_18125_END*/
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }

        p_ue_context->m.rel_of_mme_present = 0;
        if (p_s1ap_ue_associated_sig_msg_ind->bitmask & 
                UE_ASSOC_SIG_MSG_IND_REL_OF_MME_PRESENT)
        {
            /* store release info of MME in UE context */
            p_ue_context->m.rel_of_mme_present = 1;
            p_ue_context->rel_of_mme =
                (rel_info_of_mme_et)p_s1ap_ue_associated_sig_msg_ind->rel_of_mme;
        }

        if (0!=p_ue_context->m.mme_ue_id_present)
        {
            if (msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[s1ap_InitialContextSetup] "
                        "mme_ue_s1ap_id (%i) != p_ue_context->mme_ue_id (%i)",
                        msg.mme_ue_s1ap_id,
                        p_ue_context->mme_ue_id);

                break;
            }
        }
        else
        {
            /* store mme_ue_s1ap_id in UE context */
            p_ue_context->m.mme_ue_id_present = 1;
            p_ue_context->mme_ue_id = msg.mme_ue_s1ap_id;
            /* SPR 11814 Fix start */
            if ( PNULL != g_rrc_stats.p_rrc_stats )
            {
                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                        p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].
                        rrc_ue_assoc_s1_conn_related_stats.
                        s1sig_connEstabSucc, 0, DUMMY_RANGE_CHECK_INDEX);
            }
            /* SPR 11814 Fix stop */
        }

        if(msg.bitmask & RRC_S1AP_INITIAL_CONTEXT_SETUP_REQUEST_MME_UE_S1AP_ID2_PRESENT )
        {
            /*36413_CR0798_start*/
            /* store mme_ue_s1ap_id2 in UE context */
            p_ue_context->m.mme_ue_id2_present = 1;
            p_ue_context->mme_ue_id2 = msg.mme_ue_s1ap_id2;
             /*36413_CR0798_stop*/
        }

        if(msg.bitmask & RRC_S1AP_INITIAL_CONTEXT_SETUP_REQUEST_GUMMEI_PRESENT)
        {
            /*36413_CR0798_start*/
            /* mme grp id feature changes start */
            p_ue_context->m.source_gummei_present = 1;
            /* mme grp id feature changes stop */
            p_ue_context->gummei.plmn_identity = msg.gummei.pLMN_Identity;
            p_ue_context->gummei.grp_id = msg.gummei.mME_Group_ID;
            p_ue_context->gummei.mme_code = msg.gummei.mME_Code;
            /*36413_CR0798_stop*/
        }

        if(msg.bitmask & RRC_S1AP_INITIAL_CONTEXT_SETUP_REQUEST_CSG_MEMBERSHIP_STATUS_PRESENT)
        {
            p_ue_context->m.CsgMembershipStatus = RRC_TRUE;
            p_ue_context->csg_membership_status = msg.csg_membership_status;
        }

        if (PNULL != p_ue_context)
        {
            /*Generating Protocol Events */
            /* SPR 22634 Fix - Starts */
            encoded_msg_len = (U32)(buff_size);
            /* SPR 22634 Fix - Ends */
            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_INITIAL_CONTEXT_SETUP_REQUEST,
                        MESSAGE_DIRECTION_RECEIVED);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_s1ap_ue_associated_sig_msg_ind->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }
        /* Send Cell traffic trace if cell traffic trace is activated */
        //SPR 5804 fix
        if (RRC_SUCCESS != uecc_s1ap_process_ics_req_trace_handler(
                    p_uecc_gb_context, p_ue_context, buff_size, p_buff, &msg))
        {
            break;
        }

        /* Call UECC_UE_EVENT_UE_CTX_SETUP_REQ event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */

        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_S1AP_INITIAL_CTX_SETUP_IND,
                &msg);
    } while (0);

    /* Decode failure */
    if (RRC_SUCCESS != resp)
    {
        /* Check for Error Indication */
        /* Check if Criticality Diagnostics present in the message */
        if (RRC_S1AP_ERROR_INDICATION_CRITICALITY_DIAGNOSTICS_PRESENT & 
                error_indication.bitmask)
        {
            /* Now we have to decide if we have to send the error indication
             * message or the failure message */
            /*BUG 604 changes start*/ 
            if ((RRC_S1AP_ERROR_INDICATION_MME_UE_S1AP_ID_PRESENT & 
                        error_indication.bitmask)
                    && (RRC_S1AP_ERROR_INDICATION_ENB_UE_S1AP_ID_PRESENT & 
                        error_indication.bitmask) && 
                        (PNULL != (p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
                        ue_index))))
            /*BUG 604 changes stop*/ 
            {
                /* if both are present we have we can send the failure message */
                uecc_s1ap_build_and_send_initial_context_setup_failure(
                        p_ue_context,
                        msg.mme_ue_s1ap_id,
                        msg.enb_ue_s1ap_id,
                        &error_indication.cause,
                        &error_indication.criticality_diagnostics);
            }
            else if (RRC_S1AP_ERROR_INDICATION_CAUSE_PRESENT & 
                    error_indication.bitmask)
            {
                /* EI will be sent in this case*/
                uecc_s1ap_build_and_send_err_indication(p_uecc_gb_context,
                        RRC_S1AP_MODULE_ID,mme_id,
                        &error_indication);
            }
            else 
            {
                /* Set the cause and send Error Indication */
                /* Set the cause and send Error Indication */
                error_indication.cause.t = T_s1ap_Cause_radioNetwork;
                error_indication.cause.u.radioNetwork = 
                    s1ap_unknown_mme_ue_s1ap_id;
                uecc_s1ap_build_and_send_err_indication(p_uecc_gb_context,
                        RRC_S1AP_MODULE_ID,mme_id,
                        &error_indication);
            }
        }
    }

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_downlink_nas_transport
 *
 *   INPUTS       : S1AP_PDU            *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  U8                  mme_id
 *                  U8                  *buffer
 *                  U16                 buffer_length
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes s1ap_DownlinkNASTransport
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_downlink_nas_transport
(
 S1AP_PDU            *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
 U8                  mme_id,
 U8                  *buffer,
/*BUG 604 changes start*/ 
 U16                 buffer_length,
 U16                 ue_index
/*BUG 604 changes stop*/ 
 )
{
    uecc_ue_context_t                 *p_ue_context = PNULL;

    s1ap_Cause                        result;
    rrc_s1ap_downlink_nas_transport_t msg;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;

    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_ASSERT(PNULL!=p_s1ap_pdu->u.initiatingMessage);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    memset_wrapper(&msg, 0, sizeof(rrc_s1ap_downlink_nas_transport_t));

    result.t = S1AP_CAUSE_SUCCESS;
    do
    {
        if(PNULL==p_s1ap_pdu->u.initiatingMessage->value.u.downlinkNASTransport)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_DownlinkNASTransport] downlinkNASTransport field"
                    " is PNULL");
            break;
        }

        /* Decode message */
        if (RRC_FAILURE == rrc_s1ap_downlink_nas_transport_intrl_dec(
                    p_uecc_gb_context,
                    mme_id, /* just copy fields without allocation */
                    p_s1ap_pdu->u.initiatingMessage->value.u.downlinkNASTransport,
                    &msg))
        {
            /* Message parsing error */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_DownlinkNASTransport] Parsing error");
            /* Drop. */
            break;
        }

        /* SPR 1643 Start */
        if (
            RRC_S1AP_DOWNLINK_NAS_TRANSPORT_HANDOVER_RESTRICTION_LIST_PRESENT 
            &
            msg.bitmask)
        {
            /* PLMN Identity Validation */
            if (RRC_FAILURE == validate_ho_restriction_list_plmn_identity(
                         &msg.handover_restriction_list,
                         p_uecc_gb_context))
            {
                result.t = T_s1ap_Cause_misc;
                result.u.misc = s1ap_unknown_PLMN;
                /* PLMN ID range check error */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[s1ap_DownlinkNASTransport] PLMN ID Range Invalid");
                /* Drop. */
                break;
            }
        }
        /* SPR 1643 Stop*/

        /* Process message */
        /* Get context using S1AP id */
        /*BUG 604 changes start*/ 
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,ue_index);
        /*BUG 604 changes stop*/ 

        if (PNULL==p_ue_context )
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_DownlinkNASTransport] UE context not found");

            /* Send failure response */
            result.t = T_s1ap_Cause_radioNetwork;
            result.u.radioNetwork = s1ap_unknown_enb_ue_s1ap_id;

            /* Drop message */
            break;
        }

        if(PNULL != p_ue_context)  
        {
        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"[s1ap_DownlinkNASTransport]"
                    "message dropped - "
                    "UECC isn't initialized by CSC" );
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }

        if (0!=p_ue_context->m.mme_ue_id_present)
        {
            if (msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[s1ap_DownlinkNASTransport] "
                        "mme_ue_s1ap_id (%i) != p_ue_context->mme_ue_id (%i)",
                        msg.mme_ue_s1ap_id,
                        p_ue_context->mme_ue_id);

                /* Send failure response */
                result.t = T_s1ap_Cause_radioNetwork;
                result.u.radioNetwork = s1ap_unknown_mme_ue_s1ap_id;

                /* Drop message */
                break;
            }
        }
        else
        {
            /* store mme_ue_s1ap_id in UE context */
            p_ue_context->m.mme_ue_id_present = 1;
            p_ue_context->mme_ue_id = msg.mme_ue_s1ap_id;
            /* SPR 12324 Fix start */
            if ( PNULL != g_rrc_stats.p_rrc_stats )
            {
                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                        p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].
                        rrc_ue_assoc_s1_conn_related_stats.
                        s1sig_connEstabSucc, 0, DUMMY_RANGE_CHECK_INDEX);
            }
            /* SPR 12324 Fix stop */
        }

        if (PNULL != p_ue_context)
        {
            /*Generating Protocol Events */
            /* SPR 22634 Fix - Starts */
            encoded_msg_len = (U32)(buffer_length); 
            /* SPR 22634 Fix - Ends */
            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_DOWNLINK_NAS_TRANSPORT,
                        MESSAGE_DIRECTION_RECEIVED);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)buffer,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, buffer, encoded_msg_len, 
                                             "Downlink NAS Transport", 0);
        } 
        /* TRACE_changes_start */

        /* Call UECC_EV_S1AP_DL_NAS_TRANSPORT_IND event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_S1AP_DL_NAS_TRANSPORT_IND,
                &msg);

    } while (0);

    if (S1AP_CAUSE_SUCCESS != result.t)
    {
        if (T_s1ap_Cause_radioNetwork == result.t)
        {
            if (RRC_SUCCESS !=
                    uecc_s1ap_build_and_send_nas_non_delivery_ind(
                        p_uecc_gb_context,
                        msg.mme_ue_s1ap_id,
                        msg.enb_ue_s1ap_id,
                        &msg.nas_pdu,
                        &result))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[s1ap_NASNonDeliveryIndication] delivery fail");
            }
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_status_msg_ind
 *
 *   INPUTS       : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes S1AP_STATUS_MSG_IND
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_status_msg_ind(
        void                *p_api,             /* Input API buffer */
        uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
        )
{
    s1ap_status_msg_ind_t *p_s1ap_status_msg_ind = PNULL;
    U8 mme_count = 0;


    RRC_ASSERT(PNULL!=p_api);
    RRC_ASSERT(PNULL!=p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            (RRC_API_HEADER_SIZE + sizeof(s1ap_status_msg_ind_t)))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[S1AP_STATUS_MSG_IND] Wrong message size - ignore");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    p_s1ap_status_msg_ind =
        (s1ap_status_msg_ind_t *)((U8*)p_api + RRC_API_HEADER_SIZE);

    p_uecc_gb_context->mme_ctx[p_s1ap_status_msg_ind->mme_id].mme_id = 
        p_s1ap_status_msg_ind->mme_id;
    p_uecc_gb_context->mme_ctx[p_s1ap_status_msg_ind->mme_id].
        mme_connection_status = 
        p_s1ap_status_msg_ind->status;

    if (1 == p_s1ap_status_msg_ind->status)
    {
        if(SERVED_GUMMEI_INFO_PRESENT & p_s1ap_status_msg_ind->bitmask)
        {
            p_uecc_gb_context->mme_ctx[p_s1ap_status_msg_ind->mme_id].gummei = 
                p_s1ap_status_msg_ind->gummei;
        }
        else
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,"Served GUMMEI Info for MME ID [%d] is"
                    "NOT present", p_s1ap_status_msg_ind->mme_id);
        }
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_BRIEF,
                "[S1AP_STATUS_MSG_IND] MME[%d] connection - connected", 
                p_s1ap_status_msg_ind->mme_id);
        //Trace Change Start
        uecc_s1ap_set_enbId_from_s1ap_status_msg_ind(p_uecc_gb_context,p_s1ap_status_msg_ind);

        //Set EnbName in the UECC Global Context
        l3_memcpy_wrapper(&(p_uecc_gb_context->enbName),
                &(p_s1ap_status_msg_ind->enbName),
                sizeof(p_s1ap_status_msg_ind->enbName));

        //Set MME Connection Info in the
        //MME Context under UECC Global Context
        l3_memcpy_wrapper(&(p_uecc_gb_context->mme_ctx[p_s1ap_status_msg_ind->mme_id].connection_info),
                &(p_s1ap_status_msg_ind->connection_info),
                sizeof(p_s1ap_status_msg_ind->connection_info));
        //Trace Change End
    }
    else if (0 == p_s1ap_status_msg_ind->status)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_BRIEF,
                "[S1AP_STATUS_MSG_IND] MME[%d] connection - disconnected",
                p_s1ap_status_msg_ind->mme_id);
    }
    else
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[S1AP_STATUS_MSG_IND] Invalid status field value - ignore");
    }

    /* SPR:4432  start*/
    p_uecc_gb_context->mme_connection_status = RRC_FALSE;
    /* SPR:4432  end*/

    /*Update MME Connection status flag in UECC global Ctx */
    for(mme_count = 0; mme_count <MAX_NUM_MME; mme_count++)
    {
        p_uecc_gb_context->mme_connection_status |=
            p_uecc_gb_context->mme_ctx[mme_count].
            mme_connection_status;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_ue_associated_mme_update_status_ind
 *
 *   INPUTS       : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes S1AP_UE_ASSOCIATED_MME_UPDATE_STATUS_IND 
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_ue_associated_mme_update_status_ind(
        void                *p_api,             /* Input API buffer */
        uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    /* coverity_fix_62423_start */
    s1ap_ue_associated_mme_update_status_ind_t 
        *p_s1ap_update_ue_associated_msg_ind = PNULL;

    uecc_ue_context_t          *p_ue_context = PNULL;

    RRC_ASSERT(PNULL!=p_api);
    RRC_ASSERT(PNULL!=p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_s1ap_update_ue_associated_msg_ind =
        (s1ap_ue_associated_mme_update_status_ind_t *)(
                (U8*)p_api + RRC_API_HEADER_SIZE
                );

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) <
            RRC_API_HEADER_SIZE + 
            sizeof(s1ap_ue_associated_mme_update_status_ind_t))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[S1AP_UE_ASSOCIATED_MME_UPDATE_STATUS_IND] "
                "Wrong message size - ignore.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    /*BUG 604 changes start*/ 
    /* Get UE Context using eNB UE S1AP ID */
    /*p_ue_context = uecc_ue_ctx_get_by_s1ap_id(p_uecc_gb_context,
      p_s1ap_update_ue_associated_msg_ind->enb_ue_s1ap_id);*/
    p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            p_s1ap_update_ue_associated_msg_ind->ue_index);
    /*BUG 604 changes stop*/ 

    if (PNULL == p_ue_context)
    {
        /* Error. Can't find UE context */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[S1AP_UE_ASSOCIATED_MME_UPDATE_STATUS_IND] "
                "UE context not found");

        return;
    }
    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                p_ue_context->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"[S1AP_UE_ASSOCIATED_MME_UPDATE_STATUS_IND]"
                "message dropped - UECC isn't initialized by CSC" );
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    p_ue_context->gummei = 
        p_s1ap_update_ue_associated_msg_ind->gummei;

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/* coverity_fix_62423_stop */

/******************************************************************************
 *   FUNCTION NAME: update_performance_counter_erab_rel_stats_2
 *
 *   DESCRIPTION:
 *       This function updates performance counter for rrc_erab_related_stats
 *
 *   RETURNS: None
 ******************************************************************************/
static void update_performance_counter_erab_rel_stats_2(
        uecc_ue_context_t*      p_uecc_context,
        U8 qci_value )
{
    /* SPR 13441 Fix Start */
    if ( (RRC_MIN_QCI_GBR_LIMIT <= qci_value) &&
            (RRC_MAX_QCI_NON_GBR_LIMIT >= qci_value) )
    {
        RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_context->p_gb_context,
            g_rrc_stats.p_rrc_stats->
            rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_context->
            p_gb_context->offset_uecc_mod_id].
            rrc_uecc_cell_stats[p_uecc_context->cell_index].
            rrc_erab_related_stats.erab_release_stats.
            erab_relAttNbr_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
            RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

    RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_context->p_gb_context,
            g_rrc_stats.p_rrc_stats->
            rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_context->
            p_gb_context->offset_uecc_mod_id].
            rrc_uecc_cell_stats[p_uecc_context->cell_index].rrc_erab_related_stats.
            erab_release_stats.erab_relAttNbr_sum, 
            RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

    RRC_UPDATE_PERFORMANCE_COUNTER_WITH_DECREMENT(p_uecc_context->p_gb_context,
            g_rrc_stats.p_rrc_stats->
            rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_context->
            p_gb_context->offset_uecc_mod_id].
            rrc_uecc_cell_stats[p_uecc_context->cell_index].rrc_erab_related_stats.
            erab_sim_num_stats.erabSimNumber_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
            RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

    RRC_UPDATE_PERFORMANCE_COUNTER_WITH_DECREMENT(p_uecc_context->p_gb_context,
            g_rrc_stats.p_rrc_stats->
            rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_context->
            p_gb_context->offset_uecc_mod_id].
            rrc_uecc_cell_stats[p_uecc_context->cell_index].rrc_erab_related_stats.
            erab_sim_num_stats.erabSimNumber_sum,
            RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);
    }
    /* SPR 13441 Fix End */
}

/******************************************************************************
 *   FUNCTION NAME: update_performance_counter_erab_rel_stats_1
 *
 *   DESCRIPTION:
 *       This function updates performance counter for rrc_erab_related_stats
 *
 *   RETURNS: None
 ******************************************************************************/
static void update_performance_counter_erab_rel_stats_1(
        uecc_ue_context_t*      p_uecc_context,
        U8 qci_value )
{
    /* BUG 12722 Fix Start */
    /* SPR Fix 8377 */
    /* SPR Fix 8377 */
    /* BUG 12722 Fix Stop */

    RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_context->p_gb_context,                                    
            g_rrc_stats.p_rrc_stats->
            rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_context->
            p_gb_context->offset_uecc_mod_id].
            rrc_uecc_cell_stats[p_uecc_context->cell_index].
            rrc_erab_related_stats.erab_release_stats.
            erab_relEnbNbr_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
            RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

    RRC_UPDATE_PERFORMANCE_COUNTER(p_uecc_context->p_gb_context,
            g_rrc_stats.p_rrc_stats->
            rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_context->
            p_gb_context->offset_uecc_mod_id].
            rrc_uecc_cell_stats[p_uecc_context->cell_index].
            rrc_erab_related_stats.erab_release_stats.
            erab_relEnbNbr_sum, RRC_UPDATED_QCI_INDEX(qci_value), 
            RRC_MAX_QCI_INDEX);
}

/******************************************************************************
 *   FUNCTION NAME: update_performance_counter_erab_release_stats
 *
 *   DESCRIPTION:
 *       This function updates performance counter for rrc_erab_related_stats
 *       erab_release_stats
 *
 *   RETURNS: None
 *
 ******************************************************************************/
static void update_performance_counter_erab_release_stats(
        uecc_ue_context_t*      p_uecc_context,
        s1ap_Cause cause,
        U8         counter)
{
    U8 qci_value = 0;
    if (PNULL != p_uecc_context->p_e_rab_list[counter])
    {     
        qci_value = p_uecc_context->p_e_rab_list[counter]->
            e_RABlevelQoSParameters.qCI;

        update_performance_counter_erab_rel_stats_1(p_uecc_context, qci_value);

        RRC_UPDATE_PERFORMANCE_COUNTER_S1AP_CAUSE(p_uecc_context,
                g_rrc_stats.p_rrc_stats->
                rrc_uecc_stats.rrc_uecc_instance_stats[p_uecc_context->
                p_gb_context->offset_uecc_mod_id].
                rrc_uecc_cell_stats[p_uecc_context->cell_index].rrc_erab_related_stats.
                erab_release_stats.erab_rel_enb_cause_stats.
                erab_relEnbNbr_cause, cause);

        update_performance_counter_erab_rel_stats_2(p_uecc_context, qci_value);
    }
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_reset_msg_ind_reset_ue_default
 *
 *   DESCRIPTION:
 *       This function processes S1AP_RESET_MSG_IND  Reset All UEs
 *
 *   RETURNS:
 *       RRC_SUCCESS, RRC_FAILURE
 *
 ******************************************************************************/
static rrc_return_et uecc_s1ap_process_reset_msg_ind_reset_ue_default(
        uecc_gb_context_t      *p_uecc_gb_context,
        /*SPR 17777 +-*/
        s1ap_Cause cause)
{
    U16 i=0;
    U8 counter = 0;
    uecc_ue_context_t*      p_uecc_context = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    for(i=0; i < p_uecc_gb_context->total_ue_supported; i++)
    {
        p_uecc_context = p_uecc_gb_context->ue_db.ue_contexts[i];
        if(PNULL != p_uecc_context)
        {
            if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                        p_uecc_context->p_gb_context,
                        p_uecc_context->cell_index))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,"[S1AP_RESET_MSG_IND]"
                        "messsage dropped -"
                        "UECC isn't initialized by CSC ");
                return RRC_FAILURE;
            }
            /* SPR 21070 Fix Start */
            if (( PNULL != g_rrc_stats.p_rrc_stats) && 
                ( PNULL != p_uecc_context->uecc_fsm.p_current_state->s_name ) &&
                ( strcmp_wrapper(p_uecc_context->uecc_fsm.p_current_state->s_name,
                (const S8 *)"UECC_UE_CONNECTION_RELEASE_ONGOING")))
            /* SPR 21070 Fix End */
            {
                for (counter = 0; counter < MAX_ERAB_COUNT; counter++)
                {     
                    update_performance_counter_erab_release_stats(
                            p_uecc_context, cause, counter);
                }
            }

            /* Send event to specified UE */
            uecc_fsm_process_event(
                    p_uecc_context,
                    UECC_EV_S1AP_RESET_MSG_IND,
                    PNULL);
            /* BUG 12722 Fix Start */
            p_uecc_gb_context->count_use_ue_reset_req ++;
            /* BUG 12722 Fix Stop */
        }

    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_reset_msg_ind_mme_ue_s1ap_id_list
 *
 *   DESCRIPTION:
 *       This function processes S1AP_RESET_MSG_IND MME_UE_S1AP_ID_LIST_PRESENT
 *       and Reset specified UEs
 *
 *   RETURNS:
 *       RRC_SUCCESS, RRC_FAILURE
 *
 ******************************************************************************/
static rrc_return_et uecc_s1ap_process_reset_msg_ind_mme_ue_s1ap_id_list(
        uecc_gb_context_t      *p_uecc_gb_context,
        s1ap_reset_msg_ind_t*  p_s1ap_reset_msg_ind,
        s1ap_Cause cause)
{
    U16 i=0;
    U8 counter = 0;
    uecc_ue_context_t*      p_uecc_context = PNULL;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    for(i=0; i < p_s1ap_reset_msg_ind->mme_ue_s1ap_id_list.count; i++)
    {
        /* find specified UE */
        p_uecc_context = uecc_ue_ctx_get_by_mme_s1ap_id(
                p_uecc_gb_context,
                p_s1ap_reset_msg_ind->mme_ue_s1ap_id_list.mme_ue_s1ap_id[i]);

        if(PNULL != p_uecc_context)
        {
            if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_uecc_context->p_gb_context,
                        p_uecc_context->cell_index))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,"[S1AP_RESET_MSG_IND]"
                        "messsage dropped -"
                        "UECC isn't initialized by CSC ");
                return RRC_FAILURE;
            }
            /* SPR 21070 Fix Start */
            if (( PNULL != g_rrc_stats.p_rrc_stats) && 
                (PNULL != p_uecc_context->uecc_fsm.p_current_state->s_name) &&
                (strcmp_wrapper(p_uecc_context->uecc_fsm.p_current_state->s_name,(const S8 *)"UECC_UE_CONNECTION_RELEASE_ONGOING")))
            /* SPR 21070 Fix End */
            {
                for (counter = 0; counter < MAX_ERAB_COUNT; counter++)
                {     
                    update_performance_counter_erab_release_stats(
                            p_uecc_context, cause, counter);
                }
            }

            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO,
                    "[%s] S1AP RESET IND received for mme ue s1ap id %d",
                    __FUNCTION__,
                    p_s1ap_reset_msg_ind->mme_ue_s1ap_id_list.mme_ue_s1ap_id[i]);
            /* Send event to specified UE */
            uecc_fsm_process_event(
                    p_uecc_context,
                    UECC_EV_S1AP_RESET_MSG_IND,
                    PNULL);
        }
        else
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP_STATUS_MSG_IND] Wrong S1AP UE index");
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_reset_msg_ind_enb_ue_s1ap_id_list
 *
 *   DESCRIPTION:
 *       This function processes S1AP_RESET_MSG_IND ENB_UE_S1AP_ID_LIST_PRESENT
 *       and Reset specified UEs
 *
 *   RETURNS:
 *       RRC_SUCCESS, RRC_FAILURE
 *
 ******************************************************************************/
static rrc_return_et uecc_s1ap_process_reset_msg_ind_enb_ue_s1ap_id_list(
        uecc_gb_context_t      *p_uecc_gb_context,
        s1ap_reset_msg_ind_t*  p_s1ap_reset_msg_ind,
        s1ap_Cause cause)
{
    U16 i=0;
    U8 counter = 0;
    uecc_ue_context_t*      p_uecc_context = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    /*BUG 604 changes start*/
    for(i=0; i < p_s1ap_reset_msg_ind->ue_index_list.count; i++)
    {
        if ((p_uecc_gb_context->uecc_module_id - RRC_UECC_1_MODULE_ID) != 
            RRC_GET_UECC_MODULE_INDEX(p_s1ap_reset_msg_ind->ue_index_list.ue_index[i]))
    /*BUG 604 changes stop*/
        {
            continue;
        }
        /* find specified UE */

        /*BUG 604 changes start*/
        p_uecc_context = uecc_ue_ctx_get(
                p_uecc_gb_context,
                p_s1ap_reset_msg_ind->ue_index_list.ue_index[i]);
        /*BUG 604 changes stop*/

        if(PNULL != p_uecc_context)
        {
            if (PNULL != p_uecc_context->p_gb_context)
            {
                if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_uecc_context->p_gb_context,
                            p_uecc_context->cell_index))
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,"[S1AP_RESET_MSG_IND]"
                            "messsage dropped -"
                            "UECC isn't initialized by CSC ");
                    return RRC_FAILURE;
                }
                /* SPR 21070 Fix Start */ 
                if ((PNULL != g_rrc_stats.p_rrc_stats) &&
                    (PNULL != p_uecc_context->uecc_fsm.p_current_state->s_name) && 
                    (strcmp_wrapper(p_uecc_context->uecc_fsm.p_current_state->s_name,
                    (const S8 *)"UECC_UE_CONNECTION_RELEASE_ONGOING")))
                /* SPR 21070 Fix End */
                {
                    for (counter = 0; counter < MAX_ERAB_COUNT; counter++)
                    {   
                        update_performance_counter_erab_release_stats(
                                p_uecc_context, cause, counter);
                    }
                }
                /* Send event to specified UE */
                uecc_fsm_process_event(
                        p_uecc_context,
                        UECC_EV_S1AP_RESET_MSG_IND,
                        PNULL);
            }
       }

        else
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP_STATUS_MSG_IND] Wrong S1AP UE index");
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_reset_msg_ind
 *
 *   INPUTS       : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes S1AP_RESET_MSG_IND
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_reset_msg_ind(
        void                *p_api,             /* Input API buffer */
        uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
        )
{
    s1ap_reset_msg_ind_t*   p_s1ap_reset_msg_ind = PNULL;
    s1ap_Cause cause;
    /* BUG_11901 start */
    /* setting the reset ongoing flag */
    p_uecc_gb_context->reset_ongoing = 1;
    /* BUG_11901 stop */


    RRC_ASSERT(PNULL!=p_api);
    RRC_ASSERT(PNULL!=p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO, "Received S1AP_RESET_MSG_IND.");

    memset_wrapper(&cause, RRC_NULL, sizeof(cause));

    cause.t = T_s1ap_Cause_misc;
    cause.u.misc = s1ap_om_intervention;

    do
    {

        /* Precondition - p_api should point to right message */
        if (rrc_get_api_buf_size(p_api) <
                (RRC_API_HEADER_SIZE + sizeof(s1ap_reset_msg_ind_t)))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP_RESET_MSG_IND] Wrong message size - ignore");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }

        p_s1ap_reset_msg_ind =
            (s1ap_reset_msg_ind_t *)((U8*)p_api + RRC_API_HEADER_SIZE);

        /*BUG 604 changes start*/
        if (S1AP_RESET_MSG_IND_UE_INDEX_LIST_PRESENT &
                p_s1ap_reset_msg_ind->bitmask)
        {
            /* check list size */
            if (MAX_RESET_UE_S1AP_ID_COUNT <
                    p_s1ap_reset_msg_ind->ue_index_list.count)
        /*BUG 604 changes stop*/
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[S1AP_RESET_MSG_IND] Wrong counter value in list");
                RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
                return;
            }
            /* reset specified UE's */
            if(RRC_SUCCESS != uecc_s1ap_process_reset_msg_ind_enb_ue_s1ap_id_list(
                                    p_uecc_gb_context, p_s1ap_reset_msg_ind, cause))
            {
                RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
                return;
            }
        }
        else if (S1AP_RESET_MSG_IND_MME_UE_S1AP_ID_LIST_PRESENT &
                p_s1ap_reset_msg_ind->bitmask)
        {
            /* check list size */
            if (MAX_RESET_UE_S1AP_ID_COUNT <
                    p_s1ap_reset_msg_ind->mme_ue_s1ap_id_list.count)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[S1AP_RESET_MSG_IND] Wrong counter value in list");
                RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
                return;
            }
            /* reset specified UE's */
            if(RRC_SUCCESS != uecc_s1ap_process_reset_msg_ind_mme_ue_s1ap_id_list(
                                    p_uecc_gb_context, p_s1ap_reset_msg_ind, cause))
            {
                RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
                return;
            }
        }
        else
        {
            /* reset all UE's */
            if(RRC_SUCCESS != uecc_s1ap_process_reset_msg_ind_reset_ue_default(
                                    p_uecc_gb_context, cause))/*SPR 17777 +-*/
            {
                RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
                return;
            }
        }
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/* CT FIX Start */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_ue_rel_req_int
 *
 *   INPUTS       : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes S1AP_UE_REL_REQ_INT
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_ue_rel_req_int(
        void                *p_api,             /* Input API buffer */
        uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
        )
{
    s1ap_ue_rel_req_int_t*   p_s1ap_ue_rel_req_int = PNULL;
    uecc_ue_context_t*      p_uecc_context = PNULL;

    RRC_ASSERT(PNULL!=p_api);
    RRC_ASSERT(PNULL!=p_uecc_gb_context);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) <
            (RRC_API_HEADER_SIZE + sizeof(s1ap_ue_rel_req_int_t)))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                       p_uecc_gb_context->facility_name,
                       RRC_WARNING,
                       "[S1AP_UE_REL_REQ_INT] Wrong message size - ignore");
        return;
    }

    p_s1ap_ue_rel_req_int =
        (s1ap_ue_rel_req_int_t *)((U8*)p_api + RRC_API_HEADER_SIZE);

    /* find specified UE */
    /*BUG 604 changes start*/ 
    /*p_uecc_context = uecc_ue_ctx_get_by_s1ap_id(
            p_uecc_gb_context,
            p_s1ap_ue_rel_req_int->enb_ue_s1ap_id);*/
    p_uecc_context = uecc_ue_ctx_get(
            p_uecc_gb_context,
            p_s1ap_ue_rel_req_int->ue_index);
    /*BUG 604 changes stop*/ 

    if (PNULL != p_uecc_context)
    {
        /* Send event to specified UE */
        uecc_fsm_process_event(
            p_uecc_context,
            UECC_EV_S1AP_UE_REL_REQ_INT,
            PNULL);
    }
    else
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                       p_uecc_gb_context->facility_name,
                       RRC_WARNING,
                "[S1AP_UE_REL_REQ_INT] Wrong S1AP UE index");
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/* CT FIX Stop */

/****************************************************************************
 ****************************************************************************
 * Build and Send Functions implementation
 ****************************************************************************
 ****************************************************************************/

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_initial_ue_msg_req
 *
 *   INPUTS       : uecc_ue_context_t   *p_ue_context
 *                  U8                  rel_of_mme
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends RRC_S1AP_INITIAL_UE_MSG_REQ message
 *       to S1AP module.
 *
 *   RETURNS:
 *       rrc_return_et
 *
 ******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_initial_ue_msg_req
(
 uecc_ue_context_t   *p_ue_context, /* Pointer to the UECC UE context data */
 U8                  rel_of_mme
 )
{
    U8 *p_plmn_id_as_s1ap = PNULL;
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_initial_ue_message_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;
    /* SPR 13807 Fix Start */
    plmn_identity_t   plmn_identity;
    /* SPR 13807 Fix Stop */

    /* 15046_start */
    memset_wrapper(&plmn_identity,RRC_NULL ,sizeof(plmn_identity_t));
    /* 15046_end */

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* Coverity Fix 69780 Start */
    memset_wrapper(&plmn_identity, RRC_NULL, sizeof(plmn_identity_t));
    /* Coverity Fix 69780 Stop */

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                p_ue_context->cell_index))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    if (RRC_FALSE == p_ue_context->p_gb_context->mme_connection_status)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[S1AP_INITIAL_UE_MSG_REQ] MME connection isn't present");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* All pointer in p_rrcConnectionSetupComplete should be checked
     * by UECC LLIM interface unit */

    /* Clean up message */
    memset_wrapper(&msg, 0, sizeof(msg));
    memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

    /* Is trace activated */
    /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated) 
    {
        /*SPR 15875 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
            (p_ue_context->p_ue_trace_activation_info != PNULL) &&
            (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_MME, "\n<msg function=\"S1AP\" name=\"Initial Ue Message\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
            difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
            (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
            (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_CELL, "\n<msg function=\"S1AP\" name=\"Initial Ue Message\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
            difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        /*SPR 15875 Fix Stop*/
        //Trace Change Start
        P_RRC_TRACE(p_ue_context,set_all_trace_bitmask (),S1,"\n <target type=\"MME\">%s</target>",
            p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
        /*SPR 15896 Fix Stop*/
        //Trace Change End
    }

    p_plmn_id_as_s1ap = p_sig_msg_req->plmn_identity.data;

    p_sig_msg_req->plmn_identity.numocts = MCC_OCTET_SIZE;

    uecc_s1ap_generate_plmn_identity_int(
            p_plmn_id_as_s1ap,
            &p_ue_context->plmn_identity.plmn_identity);

    if (p_ue_context->registered_mme_info_present)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,
                "%s Registered MME info present",__FUNCTION__);
        /* Registered MME Infomation is present */

        p_sig_msg_req->bitmask |= REGISTERED_MMEGI_PRESENT;
        p_sig_msg_req->mme_group_id.numocts =
            ( p_ue_context->registered_mme.mmegi.numbits % 8) ?
            p_ue_context->registered_mme.mmegi.numbits/8 +1 :
            p_ue_context->registered_mme.mmegi.numbits/8;

        /* SPR 13529 Fix Start */
        p_sig_msg_req->mme_group_id.data[0] = 
            p_ue_context->registered_mme.mmegi.data[0];
        p_sig_msg_req->mme_group_id.data[1] = 
            p_ue_context->registered_mme.mmegi.data[1];
        /* SPR 13529 Fix Stop */

        p_sig_msg_req->bitmask |= REGISTERED_MMEC_PRESENT;

        /* Else assign MMEC from registered MME recvd in 
         * rrcConnSetupComp*/
        p_sig_msg_req->mmec.numocts =
            ( p_ue_context->registered_mme.mmec.numbits % 8) ?
            p_ue_context->registered_mme.mmec.numbits/8 +1 :
            p_ue_context->registered_mme.mmec.numbits/8;

        l3_memcpy_wrapper(p_sig_msg_req->mmec.data,
                p_ue_context->registered_mme.mmec.data,
                p_sig_msg_req->mmec.numocts);

    }

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[S1AP_INITIAL_UE_MSG_REQ] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* disable masks by default */
        msg.bitmask = 0;

        asn1Init_s1ap_NAS_PDU(&msg.nas_pdu);
        asn1Init_s1ap_TAI(&msg.tai);
        asn1Init_s1ap_EUTRAN_CGI(&msg.eutran_cgi);
        asn1Init_s1ap_S_TMSI(&msg.s_tmsi);
        asn1Init_s1ap_CSG_Id(&msg.csg_id);
        /* SPR 13807 Fix Start */
        asn1Init_s1ap_GUMMEI(&msg.gummei);
        /* SPR 13807 Fix Stop */
        /*lipa start */
        asn1Init_s1ap_TransportLayerAddress(&msg.transport_layer_address);
        /* lipa end */

        /* enb_ue_s1ap_id */
        /* This is first usage of s1ap_ue_id which was assigned at UE context
         * initialization time according to
         * TS 3GPP TS 36.413 V8.5.1 - 8.6.2.1 Initial UE Message */
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

        /* nas_pdu */
        /* In this case we can just assign OSDynOctStr (numocts + OSOCTET* data)
         * to avoid unnecessary NAS buffer copy */
        if (  p_ue_context->nas_pdu.data != PNULL)
        {
            msg.nas_pdu =
                p_ue_context->nas_pdu;
        }

        /* TAI */
        /* tai.pLMNidentity */
        uecc_s1ap_generate_plmn_identity_int(
                msg.tai.pLMNidentity.data,
                &p_ue_context->plmn_identity.plmn_identity);
        msg.tai.pLMNidentity.numocts = sizeof(msg.tai.pLMNidentity.data);

        if (PNULL != p_ue_context->p_gb_context->p_p_csc_context)
        {
            if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                    [p_ue_context->cell_index])
            {
                if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                        [p_ue_context->cell_index]->p_csc_init_setup_ind)
                {
                    /* tai.tAC */
                    RRC_ASSERT(sizeof(msg.tai.tAC.data) ==
                            sizeof(p_ue_context->p_gb_context->p_p_csc_context[
                                p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                                cell_access_related_info.tac));
                    l3_memcpy_wrapper(msg.tai.tAC.data,
                            p_ue_context->p_gb_context->p_p_csc_context[
                            p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.tac,
                            sizeof(msg.tai.tAC.data));
                    msg.tai.tAC.numocts = sizeof(msg.tai.tAC.data);

                    /* eutran_cgi */
                    /* eutran_cgi.pLMNidentity */
                    uecc_s1ap_generate_plmn_identity_int(
                            msg.eutran_cgi.pLMNidentity.data,
                            &p_ue_context->plmn_identity.plmn_identity);
                    msg.eutran_cgi.pLMNidentity.numocts =
                        sizeof(msg.eutran_cgi.pLMNidentity.data); /*3*/

                    /* eutran_cgi.cell_ID */
                    /* 28 bits */
                    RRC_ASSERT(sizeof(msg.eutran_cgi.cell_ID.data) ==
                            sizeof(p_ue_context->p_gb_context->p_p_csc_context[
                                p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                                cell_access_related_info.cell_Id));
                    l3_memcpy_wrapper(msg.eutran_cgi.cell_ID.data,
                            p_ue_context->p_gb_context->p_p_csc_context[
                            p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.cell_Id,
                            sizeof(msg.eutran_cgi.cell_ID.data));
                    msg.eutran_cgi.cell_ID.numbits = RRC_CELL_IDENTITY_BITS;

                    /*SPR 15896 Fix Start*/
                    if (p_ue_context->m.traceActivated)
                    {

                        //Tarun 5534 fix
                        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"E-UTRAN CGI-pLMNidentity\">%02x%02x%02x</ie> ",
                                msg.eutran_cgi.pLMNidentity.data[0],msg.eutran_cgi.pLMNidentity.data[1],msg.eutran_cgi.pLMNidentity.data[2]);

                        /*SPR 5534 Fix Start */
                        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"E-UTRAN-CELLID \">%02x%02x%02x%x</ie>",
                                                   msg.eutran_cgi.cell_ID.data[0], msg.eutran_cgi.cell_ID.data[1], 
                                msg.eutran_cgi.cell_ID.data[2], msg.eutran_cgi.cell_ID.data[3]>>4);
                        /*SPR 5534 Fix Start */
                    }
                    /*SPR 15896 Fix Stop*/

                    /* s_tmsi */
                    /* Send nothing in case of random value */
                    if ( RRC_INITIAL_UE_IDENTITY_S_TMSI_PRESENT &
                            p_ue_context->rcs_stmsi.bitmask )
                    {
                        /* s_tmsi - add if it's not random value */
                        msg.bitmask |= RRC_S1AP_INITIAL_UE_MESSAGE_S_TMSI_PRESENT;

                        /* s_tmsi.mMEC */
                        RRC_ASSERT(sizeof(msg.s_tmsi.mMEC.data) ==
                                sizeof(p_ue_context->rcs_stmsi.s_tmsi.mmec));
                        l3_memcpy_wrapper(msg.s_tmsi.mMEC.data,
                                p_ue_context->rcs_stmsi.s_tmsi.mmec,
                                sizeof(msg.s_tmsi.mMEC.data));
                        msg.s_tmsi.mMEC.numocts = sizeof(msg.s_tmsi.mMEC.data);

                        /* s_tmsi.m_TMSI */
                        RRC_ASSERT(sizeof(msg.s_tmsi.m_TMSI.data) ==
                                sizeof(p_ue_context->rcs_stmsi.s_tmsi.m_tmsi));
                        l3_memcpy_wrapper(msg.s_tmsi.m_TMSI.data,
                                p_ue_context->rcs_stmsi.s_tmsi.m_tmsi,
                                sizeof(msg.s_tmsi.m_TMSI.data));
                        msg.s_tmsi.m_TMSI.numocts = sizeof(msg.s_tmsi.m_TMSI.data);
                    }

                    /* csg_id */
                    if (CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG &
                            p_ue_context->p_gb_context->p_p_csc_context[
                            p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.presence_bitmask)
                    {
                        msg.bitmask |= RRC_S1AP_INITIAL_UE_MESSAGE_CSG_ID_PRESENT;

                        RRC_ASSERT(sizeof(msg.csg_id.data) ==
                                sizeof(p_ue_context->p_gb_context->p_p_csc_context[
                                    p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                                    cell_access_related_info.csg_identity));
                        l3_memcpy_wrapper(msg.csg_id.data,
                                p_ue_context->p_gb_context->p_p_csc_context[
                                p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                                cell_access_related_info.csg_identity,
                                sizeof(msg.csg_id.data));
                        msg.csg_id.data[CSG_ID_OCTET_SIZE-1] &= CSG_RESET_VAL;
                        msg.csg_id.numbits = RRC_CSG_ID_BITS;
                   }
                    /* SPR 13807 Fix Start */
                    if(p_ue_context->registered_mme_info_present==1)
                    {
                        msg.bitmask |= RRC_S1AP_INITIAL_UE_MESSAGE_GUMMEI_PRESENT;

                        msg.gummei.pLMN_Identity.numocts = sizeof (msg.
                                    gummei.pLMN_Identity.data);

                        if (p_ue_context->registered_mme.m.plmn_IdentityPresent)
                        {
                            if (p_ue_context->registered_mme.plmn_Identity.m.mccPresent)
                            {
                                plmn_identity.presence_bitmask = PLMN_IDENTITY_MCC_PRESENCE_FLAG;
                                l3_memcpy_wrapper (plmn_identity.mcc,
                                    p_ue_context->registered_mme.plmn_Identity.mcc.elem,
                                    MCC_OCTET_SIZE);
                            }
                            plmn_identity.mnc.count = p_ue_context->registered_mme.plmn_Identity.mnc.n;
                            
                            l3_memcpy_wrapper (plmn_identity.mnc.mnc,
                                    p_ue_context->registered_mme.plmn_Identity.mnc.elem, 
                                    p_ue_context->registered_mme.plmn_Identity.mnc.n);
                                              
                            uecc_s1ap_generate_plmn_identity_int(
                                msg.gummei.pLMN_Identity.data,
                                &plmn_identity);
                        }
                        else
                        {
                            uecc_s1ap_generate_plmn_identity_int(
                                msg.gummei.pLMN_Identity.data,
                                &p_ue_context->plmn_identity.plmn_identity);
                        }

                        msg.gummei.mME_Group_ID.numocts = 
                            ( p_ue_context->registered_mme.mmegi.numbits % 8) ?
                            p_ue_context->registered_mme.mmegi.numbits/8 +1 :
                            p_ue_context->registered_mme.mmegi.numbits/8;

                        /* SPR 15668 Start */
                        msg.gummei.mME_Group_ID.data[0] =
                            p_ue_context->registered_mme.mmegi.data[0];
                        msg.gummei.mME_Group_ID.data[1] =
                            p_ue_context->registered_mme.mmegi.data[1];
                        /* SPR 15668 End */

                        msg.gummei.mME_Code.numocts =
                            ( p_ue_context->registered_mme.mmec.numbits % 8) ?
                                p_ue_context->registered_mme.mmec.numbits/8 +1 :
                                p_ue_context->registered_mme.mmec.numbits/8;
                        l3_memcpy_wrapper(&msg.gummei.mME_Code.data,
                                 p_ue_context->registered_mme.mmec.data,
                                msg.gummei.mME_Code.numocts);
                    }
                    /* SPR 13807 Fix Stop */

                   /* cell Access Mode */
                   /* If Cell_indication false but cell broadcast CSG identity then 
                    * Cell is an hybrid cell */
                   if ((CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG &
                          p_ue_context->p_gb_context->p_p_csc_context[
                          p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                          cell_access_related_info.presence_bitmask) && 
                           (p_ue_context->p_gb_context->p_p_csc_context[
                             p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                                 cell_access_related_info.csg_indication == RRC_FALSE) &&
                           (rel_of_mme >= MME_REL9))
                   {
                        msg.bitmask |= RRC_S1AP_INITIAL_CELL_ACCESS_MODE_PRESENT;
                        /* This param indicates cell as an Hybrid cell */
                        msg.cell_access_mode = 0;
                   }
                }
            }
        }
        /* rrc_establishment_cause */
        msg.rrc_establishment_cause = p_ue_context->rcs_establishmentCause;

        /* Populate the rrc_establishment_cause for Overload Start processing */
        p_sig_msg_req->rrc_establishment_cause =  p_ue_context->rcs_establishmentCause;

        /* lipa start */
        /* Populate LGW transport layer address */
        if (p_ue_context->p_gb_context->lgw_configured_status)
        {
           msg.bitmask |= RRC_S1AP_TRANSPORT_LAYER_ADDRESS_PRESENT; 
           msg.transport_layer_address.numbits = 
            (OSUINT32)p_ue_context->p_gb_context->lgw_data_length * 
                                                    RRC_OCTET_SIZE;
           msg.transport_layer_address.data = 
                        p_ue_context->p_gb_context->lgw_ip_addr;

        }
        /* lipa end*/
        /* Encode message */
        result=rrc_s1ap_initial_ue_message_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                &msg);

        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[S1AP_INITIAL_UE_MSG_REQ] Build failed");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_S1AP_PDU(RRC_ASN,"S1AP_PDU",
                    &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                                 encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_INITIAL_UE_MESSAGE,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        /* ASN.1 encoded message to logged */
        /*SPR 15896 Fix Start*/
        rrc_trace_max_file_write(p_ue_context,INITIAL_UE_MESSAGE,p_sig_msg_req->message_buff_size,
                &p_sig_msg_req->message_buff_p[0], S1) ;
        /*SPR 15896 Fix Stop*/

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_initialUEMessage;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
        /*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
        /*BUG 604 changes stop*/

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,"S1AP_MSG: InitialUEMessage %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));
    } while (0);
    /*SPR 15896 Fix Start*/
    /* TRACE_fix */
    if (p_ue_context->m.traceActivated)
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n </msg>");
    }
    /*SPR 15896 Fix Stop*/
    /* TRACE_fix */

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: update_performance_counter_erab_setup_stats_estab
 *
 *   DESCRIPTION:
 *       This function updates performance counter for rrc_erab_related_stats
 *       erab_setup_stats
 *
 *   RETURNS: None
 *
 *******************************************************************************/
static void update_performance_counter_erab_setup_stats_estab(
        uecc_ue_context_t* p_ue_context,
        U8 erab_id,
        U32 erab_estab_time)
{
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    if ( PNULL != g_rrc_stats.p_rrc_stats)
    {
        /* SPR 13441 Fix Start */
        if ( (RRC_MIN_QCI_GBR_LIMIT <= p_ue_context->p_e_rab_list[erab_id]->
                    e_RABlevelQoSParameters.qCI) &&
                (RRC_MAX_QCI_NON_GBR_LIMIT >= p_ue_context->p_e_rab_list[erab_id]->
                    e_RABlevelQoSParameters.qCI) )
        {
            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context, 
                g_rrc_stats.p_rrc_stats->
                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->p_gb_context->
                offset_uecc_mod_id].rrc_uecc_cell_stats[p_ue_context->
                cell_index].rrc_erab_related_stats.erab_setup_stats.
                erab_estabAddSuccNbr_qci[RRC_UPDATED_QCI_INDEX(p_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI)],
                RRC_UPDATED_QCI_INDEX(p_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI),
                RRC_MAX_QCI_INDEX);

        RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context, 
                g_rrc_stats.p_rrc_stats->
                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->p_gb_context->
                offset_uecc_mod_id].rrc_uecc_cell_stats[p_ue_context->
                cell_index].rrc_erab_related_stats.erab_setup_stats.
                erab_estabAddSuccNbr_sum, 
                RRC_UPDATED_QCI_INDEX(p_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI),
                RRC_MAX_QCI_INDEX);

        RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                g_rrc_stats.p_rrc_stats->
                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->p_gb_context->
                offset_uecc_mod_id].rrc_uecc_cell_stats[p_ue_context->
                cell_index].rrc_erab_related_stats.erab_sim_num_stats.
                erabSimNumber_qci[RRC_UPDATED_QCI_INDEX(p_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI)],
                RRC_UPDATED_QCI_INDEX(p_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI),
                RRC_MAX_QCI_INDEX);

        RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                g_rrc_stats.p_rrc_stats->
                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->p_gb_context->
                offset_uecc_mod_id].rrc_uecc_cell_stats[p_ue_context->
                cell_index].rrc_erab_related_stats.erab_sim_num_stats.
                erabSimNumber_sum,RRC_UPDATED_QCI_INDEX(p_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI),
                RRC_MAX_QCI_INDEX);

        if ((RRC_UPDATED_QCI_INDEX(p_ue_context->p_e_rab_list[erab_id]->
                        e_RABlevelQoSParameters.qCI)) <= RRC_MAX_QCI_INDEX)
        {
            RRC_CALCULATE_TIMEDIFF_AND_UPDATE_COUNTER(p_ue_context->p_gb_context, 
                    p_ue_context->ue_stats.ue_timer_stats[RRC_UE_ERAB_SETUP_TIME],
                    g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                    rrc_uecc_instance_stats[p_ue_context->p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                    erab_setup_stats.erab_estabTime_qci[p_ue_context->p_e_rab_list[erab_id]->
                    e_RABlevelQoSParameters.qCI].erab_estabTime_Sum, 0, DUMMY_RANGE_CHECK_INDEX);

            /*Passing a local variable erab_estab_time as a counter name inorder to calculate
             * erab establishment time . No counter updation takes place */
            RRC_CALCULATE_TIMEDIFF_AND_UPDATE_COUNTER(p_ue_context->p_gb_context, 
                    p_ue_context->ue_stats.ue_timer_stats[RRC_UE_ERAB_SETUP_TIME],
                    erab_estab_time, 0, DUMMY_RANGE_CHECK_INDEX);

            if ( erab_estab_time > (g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                        rrc_uecc_instance_stats[p_ue_context->p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                        erab_setup_stats.erab_estabTime_qci[p_ue_context->p_e_rab_list[erab_id]->
                        e_RABlevelQoSParameters.qCI].erab_estabTime_Max))
            {
                g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                    rrc_uecc_instance_stats[p_ue_context->p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                    erab_setup_stats.erab_estabTime_qci[p_ue_context->p_e_rab_list[erab_id]->
                    e_RABlevelQoSParameters.qCI].erab_estabTime_Max = erab_estab_time;
            }

            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context, 
                    g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                    rrc_uecc_instance_stats[p_ue_context->p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].
                    rrc_erab_related_stats.erab_setup_stats.erab_estabTime_qci[p_ue_context->
                    p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI].count, 0,
                    DUMMY_RANGE_CHECK_INDEX);
            }
        }
        /* SPR 13441 Fix End */
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_E_RABSetupListBearerSURes
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  OSCTXT *p_asn1_ct
 *                  s1ap_E_RABSetupListBearerSURes *p_e_rab_setup_list
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds E_RABSetupListBearerSURes
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_E_RABSetupListBearerSURes(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        s1ap_E_RABSetupListBearerSURes *p_e_rab_setup_list
        )
{
    OSRTDListNode* p_node = PNULL;
    s1ap_E_RABSetupListBearerSURes_element *p_elem = PNULL;
    U8 erab_id = 0;
    U8 erab_counter = 0;
    U8 erab_id_count = 0;
    U32 erab_estab_time = 0;

    RRC_ASSERT(PNULL!=p_ue_context);
    RRC_ASSERT(PNULL!=p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL!=p_asn1_ctx);
    RRC_ASSERT(PNULL!=p_e_rab_setup_list);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    asn1Init_s1ap_E_RABSetupListBearerSURes(p_e_rab_setup_list);
    /*SPR 15896 Fix Start*/
    if(p_ue_context->m.traceActivated)
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n <ieGroup name=\"E-RAB Setup List\">");
    }
    /*SPR 15896 Fix Stop*/

    if(PNULL != p_ue_context->p_curr_proc_data)
    {
        erab_id_count = p_ue_context->p_curr_proc_data->u.
            erab_setup_request_data.erab_info_data.count;
    }

    for (erab_counter = 0; erab_counter < erab_id_count; erab_counter++)
    {
        if(PNULL != p_ue_context->p_curr_proc_data)
        {
            if (RRC_NO_ERROR != p_ue_context->p_curr_proc_data->u.
                    erab_setup_request_data.erab_info_data.erab_info[erab_counter].
                    status)
            {
                continue;
            }
        }
        
        rtxDListAllocNodeAndData(p_asn1_ctx,
                s1ap_E_RABSetupListBearerSURes_element,
                &p_node,
                &p_elem);
        if (PNULL==p_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate p_node");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        if(PNULL != p_ue_context->p_curr_proc_data)
        {
            erab_id = p_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                erab_info_data.erab_info[erab_counter].erab_id;
        }

        /*COVERITY_FIX_20434_START*/
        /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated)
        /*COVERITY_FIX_20434_END*/
        {
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n<ie name=\"E-RABID\">%d</ie>",erab_id);
        }
        /*SPR 15896 Fix Stop*/

        asn1Init_s1ap_E_RABSetupListBearerSURes_element(p_elem);
        p_elem->value.u._E_RABSetupItemBearerSUResIEs_1 =
            (s1ap_E_RABSetupItemBearerSURes*)rtxMemAlloc(p_asn1_ctx,
                    sizeof(s1ap_E_RABSetupItemBearerSURes));

        if (PNULL==p_elem->value.u._E_RABSetupItemBearerSUResIEs_1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "ASN malloc failed.");
            return RRC_FAILURE;
        }
        asn1Init_s1ap_E_RABSetupItemBearerSURes(p_elem->value.u._E_RABSetupItemBearerSUResIEs_1);
        p_elem->value.t = T32__E_RABSetupItemBearerSUResIEs_1;

        p_elem->id = ASN1V_s1ap_id_E_RABSetupItemBearerSURes;
        p_elem->criticality = s1ap_ignore;

        p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->e_RAB_ID = erab_id;

        /* transportLayerAddress */
#ifdef ENDC_ENABLED
        /*NR_DC Code Change Start*/
        if(PNULL != p_ue_context->p_e_rab_list[erab_id] &&
                SN_TERMINATED_SCG_BEARER == 
                p_ue_context->p_e_rab_list[erab_id]->dc_bearer_type)
        {
            p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->transportLayerAddress.data =
                (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                        p_ue_context->p_e_rab_list[erab_id]->
                        sgnb_s1ap_transportLayerAddress.numbits/8);
            if (PNULL==p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->transportLayerAddress.data)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR, "ASN malloc failed.");
                return RRC_FAILURE;
            }
            l3_memcpy_wrapper(((void*)p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->transportLayerAddress.data),
                    p_ue_context->p_e_rab_list[erab_id]->
                    sgnb_s1ap_transportLayerAddress.data,
                    p_ue_context->p_e_rab_list[erab_id]->
                    sgnb_s1ap_transportLayerAddress.numbits/8
                    );

            p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->transportLayerAddress.numbits =
                (OSUINT32)(p_ue_context->p_e_rab_list[erab_id]->
                        sgnb_s1ap_transportLayerAddress.numbits);
        }
        else if(PNULL != p_ue_context->p_e_rab_list[erab_id])
/*NR_DC Code Change Stop*/
#endif
        {
            p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->transportLayerAddress.data =
                (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                        p_ue_context->p_e_rab_list[erab_id]->
                        self_transport_address_length);
            if (PNULL==p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->transportLayerAddress.data)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR, "ASN malloc failed.");
                return RRC_FAILURE;
            }
            l3_memcpy_wrapper(((void*)p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->transportLayerAddress.data),
                    (p_ue_context->p_e_rab_list[erab_id]->
                     self_transport_address),
                    p_ue_context->p_e_rab_list[erab_id]->
                    self_transport_address_length
                    );

            p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->transportLayerAddress.numbits =
                (OSUINT32)(p_ue_context->p_e_rab_list[erab_id]->
                        self_transport_address_length*8);
        }

        /* gTP_TEID */
#ifdef ENDC_ENABLED
/*NR_DC Code Change Start*/
        if(PNULL != p_ue_context->p_e_rab_list[erab_id] &&
                SN_TERMINATED_SCG_BEARER == 
                p_ue_context->p_e_rab_list[erab_id]->dc_bearer_type)
        {
            p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->gTP_TEID.numocts =
                p_ue_context->p_e_rab_list[erab_id]->sgnb_s1ap_gtp_id.numocts;

            l3_memcpy_wrapper(p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->gTP_TEID.data,
                    p_ue_context->p_e_rab_list[erab_id]->sgnb_s1ap_gtp_id.data,
                    p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->gTP_TEID.numocts
                    );
        }
        else if(PNULL != p_ue_context->p_e_rab_list[erab_id])
/*NR_DC Code Change Stop*/
#endif
        {
            p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->gTP_TEID.numocts =
                sizeof(p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->gTP_TEID.data);
            rrc_pack_U32(
                    p_elem->value.u._E_RABSetupItemBearerSUResIEs_1->gTP_TEID.data,
                    &p_ue_context->p_e_rab_list[erab_id]->teid_self);
        }
        if(PNULL != p_ue_context->p_e_rab_list[erab_id])
        update_performance_counter_erab_setup_stats_estab(p_ue_context, erab_id, erab_estab_time);

        rtxDListAppendNode(p_e_rab_setup_list,p_node);
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    /*COVERITY_FIX_20434_START*/
    /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated)
    /*COVERITY_FIX_20434_END*/
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n </ieGroup> ");
    }
    /*SPR 15896 Fix Stop*/

    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: update_performance_counter_erab_setup_stats_init
 *
 *   DESCRIPTION:
 *       This function updates performance counter for rrc_erab_related_stats
 *       erab_setup_stats
 *
 *   RETURNS: None
 *
 *******************************************************************************/
static void update_performance_counter_erab_setup_stats_init(
        uecc_ue_context_t* p_ue_context,
        U8 erab_id,
        U32 erab_estab_time)
{
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    if ( PNULL != g_rrc_stats.p_rrc_stats)
    {
        /* SPR 13441 Fix Start */
        if ( (RRC_MIN_QCI_GBR_LIMIT <= p_ue_context->p_e_rab_list[erab_id]->
                    e_RABlevelQoSParameters.qCI) &&
                (RRC_MAX_QCI_NON_GBR_LIMIT >= p_ue_context->p_e_rab_list[erab_id]->
                    e_RABlevelQoSParameters.qCI) )
        {
            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context, 
                g_rrc_stats.p_rrc_stats->
                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                p_gb_context->offset_uecc_mod_id].
                rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.erab_setup_stats.
                erab_estabInitSuccNbr_qci[RRC_UPDATED_QCI_INDEX(p_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI)],
                RRC_UPDATED_QCI_INDEX(p_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI),
                RRC_MAX_QCI_INDEX);

            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                    p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].
                    rrc_erab_related_stats.erab_setup_stats.erab_estabInitSuccNbr_sum, 
                    RRC_UPDATED_QCI_INDEX(p_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI),
                    RRC_MAX_QCI_INDEX);

            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                    p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.erab_sim_num_stats.
                    erabSimNumber_qci[RRC_UPDATED_QCI_INDEX(p_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI)],
                    RRC_UPDATED_QCI_INDEX(p_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI),
                    RRC_MAX_QCI_INDEX);        

            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                    p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].
                    rrc_erab_related_stats.erab_sim_num_stats.
                    erabSimNumber_sum, RRC_UPDATED_QCI_INDEX(p_ue_context->p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI),
                    RRC_MAX_QCI_INDEX);

            if ((RRC_UPDATED_QCI_INDEX(p_ue_context->p_e_rab_list[erab_id]->
                            e_RABlevelQoSParameters.qCI)) <= RRC_MAX_QCI_INDEX)
            {
                RRC_CALCULATE_TIMEDIFF_AND_UPDATE_COUNTER(p_ue_context->p_gb_context, 
                        p_ue_context->ue_stats.ue_timer_stats[RRC_UE_ERAB_SETUP_TIME],
                        g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                        rrc_uecc_instance_stats[p_ue_context->p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                        erab_setup_stats.erab_estabTime_qci[p_ue_context->p_e_rab_list[erab_id]->
                        e_RABlevelQoSParameters.qCI].erab_estabTime_Sum, 0, DUMMY_RANGE_CHECK_INDEX);

                /*Passing a local variable erab_estab_time as a counter name inorder to calculate
                 * erab establishment time . No counter updation takes place */
                RRC_CALCULATE_TIMEDIFF_AND_UPDATE_COUNTER(p_ue_context->p_gb_context, 
                        p_ue_context->ue_stats.ue_timer_stats[RRC_UE_ERAB_SETUP_TIME],
                        erab_estab_time, 0, DUMMY_RANGE_CHECK_INDEX);

                if ( erab_estab_time > (g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                            rrc_uecc_instance_stats[p_ue_context->p_gb_context->offset_uecc_mod_id].
                            rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                            erab_setup_stats.erab_estabTime_qci[p_ue_context->p_e_rab_list[erab_id]->
                            e_RABlevelQoSParameters.qCI].erab_estabTime_Max))
                {
                    g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                        rrc_uecc_instance_stats[p_ue_context->p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                        erab_setup_stats.erab_estabTime_qci[p_ue_context->p_e_rab_list[erab_id]->
                        e_RABlevelQoSParameters.qCI].erab_estabTime_Max = erab_estab_time;
                }

                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context, 
                        g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                        rrc_uecc_instance_stats[p_ue_context->p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].
                        rrc_erab_related_stats.erab_setup_stats.erab_estabTime_qci[p_ue_context->
                        p_e_rab_list[erab_id]->e_RABlevelQoSParameters.qCI].count, 0,
                        DUMMY_RANGE_CHECK_INDEX);

            }
        }
        /* SPR 13441 Fix End */
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_E_RABSetupListCtxtSURes
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  OSCTXT *p_asn1_ctx
 *                  s1ap_E_RABSetupListCtxtSURes *p_e_rab_setup_list
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds E_RABSetupListCtxtSURes
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_E_RABSetupListCtxtSURes(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        s1ap_E_RABSetupListCtxtSURes *p_e_rab_setup_list
        )
{
    OSRTDListNode* p_node = PNULL;
    s1ap_E_RABSetupListCtxtSURes_element *p_elem = PNULL;
    /* ICS START */

    U8 erab_id = 0;
    U8 erab_counter = 0;
    U8 erab_id_count = 0;
    U32 erab_estab_time = 0;

    /* ICS STOP */
    /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated) 
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n <ieGroup name=\"E-RAB Setup  List \">");
    }
    /*SPR 15896 Fix Stop*/

    RRC_ASSERT(PNULL!=p_ue_context);
    RRC_ASSERT(PNULL!=p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL!=p_asn1_ctx);
    RRC_ASSERT(PNULL!=p_e_rab_setup_list);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    asn1Init_s1ap_E_RABSetupListCtxtSURes(p_e_rab_setup_list);

    if (PNULL != p_ue_context->p_curr_proc_data)
    {
        erab_id_count = p_ue_context->p_curr_proc_data->u.erab_setup_request_data.
            erab_info_data.count;
    }

    for ( erab_counter = 0; erab_counter < erab_id_count; erab_counter++ )
    {
        if (PNULL != p_ue_context->p_curr_proc_data)
        {
            if (RRC_NO_ERROR != p_ue_context->p_curr_proc_data->u.
                    erab_setup_request_data.erab_info_data.
                    erab_info[erab_counter].status)
            {
                continue;
            }
        }

        rtxDListAllocNodeAndData(p_asn1_ctx,
                s1ap_E_RABSetupListCtxtSURes_element,
                &p_node,
                &p_elem);
        if (PNULL==p_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate p_node");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        if (PNULL != p_ue_context->p_curr_proc_data)
        {
            erab_id = p_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                erab_info_data.erab_info[erab_counter].erab_id;
        }

        asn1Init_s1ap_E_RABSetupListCtxtSURes_element(p_elem);
        p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1 =
            (s1ap_E_RABSetupItemCtxtSURes*)rtxMemAlloc(p_asn1_ctx,
                                  sizeof(s1ap_E_RABSetupItemCtxtSURes) );

        if (PNULL==p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "ASN malloc failed.");
            return RRC_FAILURE;
        }
        asn1Init_s1ap_E_RABSetupItemCtxtSURes(p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1);
        p_elem->value.t = T49__E_RABSetupItemCtxtSUResIEs_1;
        p_elem->id = ASN1V_s1ap_id_E_RABSetupItemCtxtSURes;
        p_elem->criticality = s1ap_ignore;

        p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->e_RAB_ID = erab_id;
        /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated) 
        {
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"E-RABID\">%d</ie>",
            p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->e_RAB_ID);
        }
        /*SPR 15896 Fix Stop*/

        /* transportLayerAddress */
#ifdef ENDC_ENABLED
        /*NR_DC Code Change Start*/
        if(PNULL != p_ue_context->p_e_rab_list[erab_id] &&
                SN_TERMINATED_SCG_BEARER == 
                p_ue_context->p_e_rab_list[erab_id]->dc_bearer_type)
        {
            p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->transportLayerAddress.data =
                (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                        p_ue_context->p_e_rab_list[erab_id]->
                        sgnb_s1ap_transportLayerAddress.numbits/8 );

            if (PNULL==p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->transportLayerAddress.data)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR, "ASN malloc failed.");
                return RRC_FAILURE;
            }
            l3_memcpy_wrapper(((void*)p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->transportLayerAddress.data),
                        p_ue_context->p_e_rab_list[erab_id]->
                        sgnb_s1ap_transportLayerAddress.data,
                        p_ue_context->p_e_rab_list[erab_id]->
                        sgnb_s1ap_transportLayerAddress.numbits/8
                     );

            p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->transportLayerAddress.numbits =
                (OSUINT32)(p_ue_context->p_e_rab_list[erab_id]->
                        sgnb_s1ap_transportLayerAddress.numbits);
        }
        else
/*NR_DC Code Change Stop*/
#endif
        {
            p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->transportLayerAddress.data =
                (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                        p_ue_context->p_e_rab_list[erab_id]->
                        self_transport_address_length );

            if (PNULL==p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->transportLayerAddress.data)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR, "ASN malloc failed.");
                return RRC_FAILURE;
            }
            l3_memcpy_wrapper(((void*)p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->transportLayerAddress.data),
                    (p_ue_context->p_e_rab_list[erab_id]->
                     self_transport_address),
                    p_ue_context->p_e_rab_list[erab_id]->
                    self_transport_address_length );

            p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->transportLayerAddress.numbits =
                (OSUINT32)(p_ue_context->p_e_rab_list[erab_id]->
                        self_transport_address_length*8 );
        }
        /* gTP_TEID */
#ifdef ENDC_ENABLED
/*NR_DC Code Change Start*/
        if(PNULL != p_ue_context->p_e_rab_list[erab_id] &&
                SN_TERMINATED_SCG_BEARER == 
                p_ue_context->p_e_rab_list[erab_id]->dc_bearer_type)
        {
            p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->gTP_TEID.numocts = 
                p_ue_context->p_e_rab_list[erab_id]->sgnb_s1ap_gtp_id.numocts;

            l3_memcpy_wrapper(p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->gTP_TEID.data,
                    p_ue_context->p_e_rab_list[erab_id]->sgnb_s1ap_gtp_id.data,
                    p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->gTP_TEID.numocts
                    );
        }
        else
/*NR_DC Code Change Stop*/
#endif
        {
            p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->gTP_TEID.numocts = sizeof(p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->gTP_TEID.data);

            rrc_pack_U32(
                    p_elem->value.u._E_RABSetupItemCtxtSUResIEs_1->gTP_TEID.data,
                    &p_ue_context->p_e_rab_list[erab_id]->teid_self);
        }
        
        update_performance_counter_erab_setup_stats_init(p_ue_context, erab_id, erab_estab_time);

        rtxDListAppendNode(p_e_rab_setup_list,p_node);
    }
    /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated) 
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n </ieGroup> ");
    }
    /*SPR 15896 Fix Stop*/
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}
/* ERB RELEASE COMMAND START */

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_E_RABReleaseListBearerRelComp
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  SCTXT* p_asn1_ctx
 *                  s1ap_E_RABReleaseListBearerRelComp* p_e_rab_release_list
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds E_RABReleaseListBearerRelComp 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_E_RABReleaseListBearerRelComp(
        uecc_ue_context_t* p_ue_context,
        OSCTXT* p_asn1_ctx,
        s1ap_E_RABReleaseListBearerRelComp* p_e_rab_release_list
        )
{
    OSRTDListNode* p_node = PNULL;
    erab_list_t* p_erab_list = PNULL;    
    s1ap_E_RABReleaseListBearerRelComp_element* p_elem = PNULL;
    U8 e_rab_index = RRC_NULL;
    U8 qci_value = 0;
    U8 counter = 0;

    /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated)
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n <ieGroup name=\"E-RAB Release List\">");
    }
    /*SPR 15896 Fix Stop*/

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_e_rab_release_list);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    asn1Init_s1ap_E_RABReleaseListBearerRelComp(p_e_rab_release_list);

    /* point to erab_release_list in erab_release_command_data */
    p_erab_list = &p_ue_context->p_curr_proc_data->u.
        erab_release_command_data.erab_release_list;

    if (PNULL != p_erab_list)
    {
        /* This allocation should be made inside of loop for multy-E-RAB*/
        for (e_rab_index=0; 
                e_rab_index < p_erab_list->counter; 
                e_rab_index++)
        {
            rtxDListAllocNodeAndData(p_asn1_ctx,
                    s1ap_E_RABReleaseListBearerRelComp_element,
                    &p_node,
                    &p_elem);

            if (PNULL == p_node)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"Can't allocate p_node");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            asn1Init_s1ap_E_RABReleaseListBearerRelComp_element(p_elem);
            p_elem->value.u._E_RABReleaseItemBearerRelCompIEs_1 =
                (s1ap_E_RABReleaseItemBearerRelComp*)rtxMemAlloc(p_asn1_ctx,
                        sizeof(s1ap_E_RABReleaseItemBearerRelComp));

            if (PNULL==p_elem->value.u._E_RABReleaseItemBearerRelCompIEs_1)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR, "ASN malloc failed.");
                return RRC_FAILURE;
            }
            asn1Init_s1ap_E_RABReleaseItemBearerRelComp(p_elem->value.u._E_RABReleaseItemBearerRelCompIEs_1);
            p_elem->value.t = T42__E_RABReleaseItemBearerRelCompIEs_1;

            p_elem->id = ASN1V_s1ap_id_E_RABReleaseItemBearerRelComp;
            p_elem->criticality = s1ap_ignore;

            p_elem->value.u._E_RABReleaseItemBearerRelCompIEs_1->e_RAB_ID = 
                p_erab_list->erab_item[e_rab_index].e_RAB_ID;

            /*SPR 15896 Fix Start*/
            /*COVERITY_FIX_20433_START*/
            if (p_ue_context->m.traceActivated) 
            /*COVERITY_FIX_20433_END*/
            {
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"E-RABID\">%d</ie>",p_elem->value.u._E_RABReleaseItemBearerRelCompIEs_1->e_RAB_ID);
            }
            /*SPR 15896 Fix Stop*/
            
            if ( PNULL != g_rrc_stats.p_rrc_stats)
            {
                for (counter = 0; counter < MAX_ERAB_COUNT; counter++)
                {
                    if ((PNULL != p_ue_context->p_e_rab_list[counter]) && 
                        (p_erab_list->erab_item[e_rab_index].e_RAB_ID == 
                         p_ue_context->p_e_rab_list[counter]->e_RAB_ID))
                    {
                        qci_value = p_ue_context->p_e_rab_list[counter]->e_RABlevelQoSParameters.qCI;
                        /* SPR 13441 Fix Start */
                        if ( (RRC_MIN_QCI_GBR_LIMIT <= qci_value) &&
                                (RRC_MAX_QCI_NON_GBR_LIMIT >= qci_value) )
                        { 
                            /* SPR Fix 8377 */
                            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                                    g_rrc_stats.p_rrc_stats->
                                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                                    p_gb_context->offset_uecc_mod_id].
                                    rrc_uecc_cell_stats[p_ue_context->cell_index].
                                    rrc_erab_related_stats.erab_release_stats.
                                    erab_relSuccNbr_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
                                    RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

                            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                                    g_rrc_stats.p_rrc_stats->
                                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                                    p_gb_context->offset_uecc_mod_id].
                                    rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                                    erab_release_stats.erab_relSuccNbr_sum, 
                                    RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);
                            /* SPR Fix 8377 */

                            RRC_UPDATE_PERFORMANCE_COUNTER_WITH_DECREMENT(p_ue_context->p_gb_context,
                                    g_rrc_stats.p_rrc_stats->
                                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                                    p_gb_context->offset_uecc_mod_id].
                                    rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                                    erab_sim_num_stats.erabSimNumber_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
                                    RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

                            RRC_UPDATE_PERFORMANCE_COUNTER_WITH_DECREMENT(p_ue_context->p_gb_context,
                                    g_rrc_stats.p_rrc_stats->
                                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                                    p_gb_context->offset_uecc_mod_id].
                                    rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                                    erab_sim_num_stats.erabSimNumber_sum,
                                    RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

                            /* CR 101 changes start*/
                            if ((MAC_DELETE_LC_ACTIVE == p_erab_list->erab_item[e_rab_index].lc_status) &&
                               (!((p_erab_list->erab_item[e_rab_index].cause.t == T_s1ap_Cause_nas) &&
                                (p_erab_list->erab_item[e_rab_index].cause.u.nas == s1ap_normal_release ))) )
                            {
                                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                                        g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                                        rrc_uecc_instance_stats[p_ue_context->p_gb_context->offset_uecc_mod_id].
                                        rrc_uecc_cell_stats[p_ue_context->cell_index].
                                        rrc_erab_related_stats.erab_release_stats.
                                        erab_relActNbr_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
                                        RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

                                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                                        g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                                        rrc_uecc_instance_stats[p_ue_context->p_gb_context->offset_uecc_mod_id].
                                        rrc_uecc_cell_stats[p_ue_context->cell_index].
                                        rrc_erab_related_stats.erab_release_stats.
                                        erab_relActNbr_sum, RRC_UPDATED_QCI_INDEX(qci_value), 
                                        RRC_MAX_QCI_INDEX);

                            }
                            /* CR 101 changes stop*/
                        }
                        /* SPR 13441 Fix End */
                    }
                }
            }
            rtxDListAppendNode(p_e_rab_release_list,p_node);
        }

    }

    /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated)
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n </ieGroup> ");
    }
    /*SPR 15896 Fix Stop*/

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_e_rab_failed_to_release_list
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  OSCTXT* p_asn1_ctx
 *                  s1ap_E_RABList* p_list
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds e_rab_failed_to_release_list
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_e_rab_failed_to_release_list(
        uecc_ue_context_t* p_ue_context,
        OSCTXT* p_asn1_ctx,
        s1ap_E_RABList* p_list
        )
{
    OSRTDListNode* p_node = PNULL;
    s1ap_E_RABList_element *p_elem = PNULL;
    erab_list_t* p_erab_list = PNULL;
    U8 e_rab_index = RRC_NULL;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_list);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);


    asn1Init_s1ap_E_RABList(p_list);

    /* point to erab_failed_to_release_list in erab_release_command_data */
    /*SPR 18758 Fix Start*/
    if (PNULL != p_ue_context->p_failed_curr_proc_data)
    {
        p_erab_list = &p_ue_context->p_failed_curr_proc_data->u.
            erab_release_command_data.erab_failed_to_release_list;
    }
    else
    {
    p_erab_list = &p_ue_context->p_curr_proc_data->u.
        erab_release_command_data.erab_failed_to_release_list;
    }
    /*SPR 18758 Fix Stop*/

    /*SPR 5532 Fix Start */
    /*SPR 15896 Fix Start*/
    if ((PNULL != p_erab_list) && (p_erab_list->counter != 0) &&
            p_ue_context->m.traceActivated )
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n<ieGroup name=\"E-RAB Failed to Release List \">");
    }
    /*SPR 15896 Fix Stop*/
    /*SPR 5532 Fix End */
    if (PNULL != p_erab_list)
    {
        for (e_rab_index = 0;
                e_rab_index < p_erab_list->counter;
                e_rab_index++)
        {
            rtxDListAllocNodeAndData(p_asn1_ctx,
                    s1ap_E_RABList_element,
                    &p_node,
                    &p_elem);
            if (PNULL == p_node)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"Can't allocate p_node");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }

            asn1Init_s1ap_E_RABList_element(p_elem);
            p_elem->value.u._E_RABItemIEs_1 =
                (s1ap_E_RABItem*)rtxMemAlloc(p_asn1_ctx,
                        sizeof(s1ap_E_RABItem));

            if (PNULL==p_elem->value.u._E_RABItemIEs_1)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR, "ASN malloc failed.");
                return RRC_FAILURE;
            }
            asn1Init_s1ap_E_RABItem(p_elem->value.u._E_RABItemIEs_1);
            /* SPR 21660 changes start */
            p_elem->value.t = T180__E_RABItemIEs_1; //T173__E_RABItemIEs_1
            /* SPR 21660 changes end */

            p_elem->id = ASN1V_s1ap_id_E_RABItem;
            p_elem->criticality = s1ap_ignore;

            p_elem->value.u._E_RABItemIEs_1->e_RAB_ID =
                p_erab_list->erab_item[e_rab_index].e_RAB_ID;

            /*SPR 15896 Fix Start*/
            if (p_ue_context->m.traceActivated) 
            {
                P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n<ie name=\"E-RABID\">%d</ie>",p_elem->value.u._E_RABItemIEs_1->e_RAB_ID);
            }
            /*SPR 15896 Fix Stop*/
            p_elem->value.u._E_RABItemIEs_1->cause =
                p_erab_list->erab_item[e_rab_index].cause;
            
            if ( PNULL != g_rrc_stats.p_rrc_stats)
            {
                RRC_UPDATE_PERFORMANCE_COUNTER_S1AP_CAUSE(p_ue_context,
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                        p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                        erab_release_stats.rel_fail_cause_stats.
                        erab_relFailNbr_cause, p_elem->value.u._E_RABItemIEs_1->cause);

                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                        p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                        erab_release_stats.erab_relFailNbr_sum, 0, 
                        DUMMY_RANGE_CHECK_INDEX);
            }
            rtxDListAppendNode(p_list,p_node);
        }
    }
    /*SPR 5532 Fix Start */
    /*SPR 15896 Fix Start*/
    if ((PNULL != p_erab_list) && (p_erab_list->counter != 0) &&
            p_ue_context->m.traceActivated )
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n</ieGroup>" );
    }
    /*SPR 15896 Fix Stop*/
    /*SPR 5532 Fix End */

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}
/* ERB RELEASE COMMNAD END */
/* ERB RELEASE INDICATION START */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_e_rab_released_list_arp
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  OSCTXT*  p_asn1_ctx
 *                  s1ap_E_RABList* p_list
 *                  erab_list_t* p_erab_lis
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds e_rab_released_list
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_e_rab_released_list_arp(
        uecc_ue_context_t* p_ue_context,
        OSCTXT*  p_asn1_ctx,
        s1ap_E_RABList* p_list,
        erab_list_t* p_erab_list
        )
{
    OSRTDListNode* p_node = PNULL;
    s1ap_E_RABList_element* p_elem = PNULL;
    U8 e_rab_index = RRC_NULL;
    #ifdef ENDC_ENABLED
    U8 counter = RRC_NULL;
    U8 qci_value = RRC_NULL;
    #endif


    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_list);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);


    asn1Init_s1ap_E_RABList(p_list);

    for (e_rab_index = 0;
            e_rab_index < p_erab_list->counter;
            e_rab_index++)
    {
        rtxDListAllocNodeAndData(p_asn1_ctx,
                s1ap_E_RABList_element,
                &p_node,
                &p_elem);
        if (PNULL==p_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate p_node");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        asn1Init_s1ap_E_RABList_element(p_elem);
        p_elem->value.u._E_RABItemIEs_1 =
            (s1ap_E_RABItem*)rtxMemAlloc(p_asn1_ctx,
                    sizeof(s1ap_E_RABItem));

        if (PNULL==p_elem->value.u._E_RABItemIEs_1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "ASN malloc failed.");
            return RRC_FAILURE;
        }
        asn1Init_s1ap_E_RABItem(p_elem->value.u._E_RABItemIEs_1);
        /* SPR 21660 changes start */
        p_elem->value.t  = T180__E_RABItemIEs_1; //T173__E_RABItemIEs_1
        /* SPR 21660 changes end */

        p_elem->id = ASN1V_s1ap_id_E_RABItem;
        p_elem->criticality = s1ap_ignore;

        p_elem->value.u._E_RABItemIEs_1->e_RAB_ID =
            p_erab_list->erab_item[e_rab_index].e_RAB_ID;

        #ifdef ENDC_ENABLED
        if ( PNULL != g_rrc_stats.p_rrc_stats)
        {
            /* Find the E-RAB ID in the UE Context to get the Qci */
            for (counter = 0; counter < MAX_ERAB_COUNT; counter++)
            {
                if ((PNULL != p_ue_context->p_e_rab_list[counter]) && 
                    (p_elem->value.u._E_RABItemIEs_1->e_RAB_ID == 
                     p_ue_context->p_e_rab_list[counter]->e_RAB_ID))
                {
                    /* update the performance counter */
                    qci_value = p_ue_context->p_e_rab_list[counter]->
                        e_RABlevelQoSParameters.qCI;
                    /* SPR 13441 Fix Start */
                    if ( (RRC_MIN_QCI_GBR_LIMIT <= qci_value) &&
                                (RRC_MAX_QCI_NON_GBR_LIMIT >= qci_value) )
                    { 
                        RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                                g_rrc_stats.p_rrc_stats->
                                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                                p_gb_context->offset_uecc_mod_id].
                                rrc_uecc_cell_stats[p_ue_context->cell_index].
                                rrc_erab_related_stats.erab_release_stats.
                                erab_relEnbNbr_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
                                RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

                        RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                                g_rrc_stats.p_rrc_stats->
                                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                                p_gb_context->offset_uecc_mod_id].
                                rrc_uecc_cell_stats[p_ue_context->cell_index].
                                rrc_erab_related_stats.erab_release_stats.
                                erab_relEnbNbr_sum, RRC_UPDATED_QCI_INDEX(qci_value), 
                                RRC_MAX_QCI_INDEX);

                        RRC_UPDATE_PERFORMANCE_COUNTER_S1AP_CAUSE(p_ue_context,
                                g_rrc_stats.p_rrc_stats->
                                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                                p_gb_context->offset_uecc_mod_id].
                                rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                                erab_release_stats.erab_rel_enb_cause_stats.
                                erab_relEnbNbr_cause, p_erab_list->erab_item[e_rab_index].cause);
                        /* BUG 13094 Fix Start */
                        /* BUG 13094 Fix Stop */
                        
                        /* CR 90 changes start*/
                        /* SPR Fix 8377 */
                        RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                                g_rrc_stats.p_rrc_stats->
                                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                                p_gb_context->offset_uecc_mod_id].
                                rrc_uecc_cell_stats[p_ue_context->cell_index].
                                rrc_erab_related_stats.erab_release_stats.
                                erab_relSuccNbr_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
                                RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

                        RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                                g_rrc_stats.p_rrc_stats->
                                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                                p_gb_context->offset_uecc_mod_id].
                                rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                                erab_release_stats.erab_relSuccNbr_sum, 
                                RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);
                        /* SPR Fix 8377 */
                        /* CR 90 changes stop*/

                        /* CR 101 changes start*/
                        if (MAC_DELETE_LC_ACTIVE == p_erab_list->erab_item[e_rab_index].lc_status) 
                        {
                            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                                    g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                                    rrc_uecc_instance_stats[p_ue_context->p_gb_context->offset_uecc_mod_id].
                                    rrc_uecc_cell_stats[p_ue_context->cell_index].
                                    rrc_erab_related_stats.erab_release_stats.
                                    erab_relActNbr_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
                                    RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

                            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                                    g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                                    rrc_uecc_instance_stats[p_ue_context->p_gb_context->offset_uecc_mod_id].
                                    rrc_uecc_cell_stats[p_ue_context->cell_index].
                                    rrc_erab_related_stats.erab_release_stats.
                                    erab_relActNbr_sum, RRC_UPDATED_QCI_INDEX(qci_value), 
                                    RRC_MAX_QCI_INDEX);
                        }
                        /* CR 101 changes stop*/
                    }
                    /* SPR 13441 Fix Start */
                }
            }
        }
#endif
        /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated )
        {
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"E-RABID\">%d</ie>",p_elem->value.u._E_RABItemIEs_1->e_RAB_ID);
        }
        /*SPR 15896 Fix Stop*/

        p_elem->value.u._E_RABItemIEs_1->cause = p_erab_list->erab_item[e_rab_index].cause;

        rtxDListAppendNode(p_list,p_node);
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated )
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n </msg>");
    }
    /*SPR 15896 Fix Stop*/
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: update_performance_counter_erab_estab_init_fail_stats
 *
 *   DESCRIPTION:
 *       This function updates performance counter for erab_setup_stats
 *       erab_estab_init_fail_stats
 *
 *   RETURNS: None
 *
 *******************************************************************************/
static void update_performance_counter_erab_estab_init_fail_stats(
        uecc_ue_context_t* p_ue_context,
        uecc_erab_failed_to_setup_list_t* p_erab_fail_list,
        U8 fail_erab_counter,
        rrc_uecc_calling_proc_et calling_proc)
{
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    if (INITIAL_CTX_SETUP_RESPONSE == calling_proc)
    {
        if ( PNULL != g_rrc_stats.p_rrc_stats)
        {
            /* Update the performance Counter E-RAB Failed List */
            RRC_UPDATE_PERFORMANCE_COUNTER_S1AP_CAUSE(p_ue_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                    p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                    erab_setup_stats.erab_estab_init_fail_stats.
                    erab_estabInitFailNbr_cause,
                    p_erab_fail_list->erab_failed_to_setup_item[fail_erab_counter].cause);

            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                    p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                    erab_setup_stats.erab_estabInitFailNbr_sum, 0,
                    DUMMY_RANGE_CHECK_INDEX);
        }
    }
    else if (ERAB_SETUP_RESPONSE == calling_proc)
    {
        if ( PNULL != g_rrc_stats.p_rrc_stats)
        {
            /* Update the performance counter for Erab setup addtional Success*/
            RRC_UPDATE_PERFORMANCE_COUNTER_S1AP_CAUSE(p_ue_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                    p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                    erab_setup_stats.erab_estab_add_fail_stats.
                    erab_estabAddFailNbr_cause,
                    p_erab_fail_list->erab_failed_to_setup_item[fail_erab_counter].cause);

            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                    p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                    erab_setup_stats.erab_estabAddFailNbr_sum, 0,
                    DUMMY_RANGE_CHECK_INDEX);
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/* ERB RELEASE INDICATION END */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_e_rab_failed_to_setup_list
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  OSCTXT *p_asn1_ctx
 *                  s1ap_E_RABList *p_list
 *                  rrc_uecc_calling_proc_et calling_proc
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds e_rab_failed_to_setup_list
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_e_rab_failed_to_setup_list(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        s1ap_E_RABList *p_list,
        rrc_uecc_calling_proc_et calling_proc
        )
{
    OSRTDListNode* p_node = PNULL;
    s1ap_E_RABList_element *p_elem = PNULL;
    uecc_erab_failed_to_setup_list_t* p_erab_fail_list = PNULL;

    /* ICS START */
    U8 fail_erab_id_count = 0;
    U8 fail_erab_counter = 0;
    /* ICS STOP */    

    RRC_ASSERT(PNULL!=p_ue_context);
    RRC_ASSERT(PNULL!=p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL!=p_asn1_ctx);
    RRC_ASSERT(PNULL!=p_list);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /*SPR 18758 Fix Start*/
    if (PNULL != p_ue_context->p_failed_curr_proc_data)
    {
        p_erab_fail_list = &p_ue_context->p_failed_curr_proc_data->u.erab_setup_request_data.failed_erab_data;
    }
    /* SPR_20915 - Fix - Starts */
    else if (PNULL != p_ue_context->p_curr_proc_data)
    /* SPR_20915 - Fix - Ends */
    {
        p_erab_fail_list = &p_ue_context->p_curr_proc_data->u.erab_setup_request_data.failed_erab_data;
    }
    /*SPR 18758 Fix Stop*/

    asn1Init_s1ap_E_RABList(p_list);

    /* SPR_20915 - Fix - Starts */
    if ((PNULL != p_erab_fail_list) &&
        (MAX_ERAB_COUNT >= p_erab_fail_list->count))
    {
        fail_erab_id_count = p_erab_fail_list->count;
    }
    /* SPR_20915 - Fix - Ends */

    /*SPR 5532 Fix Start */
    /*SPR 15896 Fix Start*/
    if (fail_erab_id_count != 0 &&
            p_ue_context->m.traceActivated  )
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ieGroup name=\"E-RAB Failed to Setup List \">");
    }
    /*SPR 15896 Fix Stop*/
    /*SPR 5532 Fix End */

    for ( fail_erab_counter = 0; fail_erab_counter < fail_erab_id_count;
            fail_erab_counter++ )
    {

        rtxDListAllocNodeAndData(p_asn1_ctx,
                s1ap_E_RABList_element,
                &p_node,
                &p_elem);

        if (PNULL==p_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate p_node");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        asn1Init_s1ap_E_RABList_element(p_elem);
        p_elem->value.u._E_RABItemIEs_1 =
            (s1ap_E_RABItem*)rtxMemAlloc(p_asn1_ctx,
                    sizeof(s1ap_E_RABItem));

        if (PNULL==p_elem->value.u._E_RABItemIEs_1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "ASN malloc failed.");
            return RRC_FAILURE;
        }
        asn1Init_s1ap_E_RABItem(p_elem->value.u._E_RABItemIEs_1);
        /* SPR 21660 changes start */
        p_elem->value.t = T180__E_RABItemIEs_1; //T173__E_RABItemIEs_1
        /* SPR 21660 changes end */

        p_elem->id = ASN1V_s1ap_id_E_RABItem;
        p_elem->criticality = s1ap_ignore;

        p_elem->value.u._E_RABItemIEs_1->e_RAB_ID =
            p_erab_fail_list->erab_failed_to_setup_item
            [fail_erab_counter].e_RAB_ID;

   /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated )
        {
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1," \n <ie name=\"E-RABID\">%d</ie>",p_elem->value.u._E_RABItemIEs_1->e_RAB_ID);
        }

   /*SPR 15896 Fix Stop*/

        l3_memcpy_wrapper(&p_elem->value.u._E_RABItemIEs_1->cause,
                &p_erab_fail_list->erab_failed_to_setup_item
                [fail_erab_counter].cause,
                sizeof(s1ap_Cause));
        update_performance_counter_erab_estab_init_fail_stats(
            p_ue_context, p_erab_fail_list, fail_erab_counter, calling_proc );

        rtxDListAppendNode(p_list,p_node);
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    /*SPR 5532 Fix Start */
   /*SPR 15896 Fix Start*/
    if (fail_erab_id_count != 0 &&
            p_ue_context->m.traceActivated  )
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n</ieGroup>");
    }
    
    if ( p_ue_context->m.traceActivated ) 
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n</msg>");
    }
   /*SPR 15896 Fix Stop*/
    /*SPR 5532 Fix End */
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_s1ap_cause
 *
 *   INPUTS       : s1ap_Cause*     p_cause
 *                   rrm_cause_t*    p_rrm_cause
 *                   uecc_ue_context_t* p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds s1ap_Cause
 *
 *   RETURNS:
 *       None
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_s1ap_cause(
        s1ap_Cause*     p_cause,
        rrm_cause_t*    p_rrm_cause,
        uecc_ue_context_t* p_ue_context
        )
{
    rrc_return_et result = RRC_SUCCESS;


    RRC_ASSERT(PNULL != p_cause);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    if (PNULL != p_rrm_cause)
    {
        p_cause->t = p_rrm_cause->type;
        p_cause->u.protocol = 0;

        switch (p_cause->t)
        {
            case T_s1ap_Cause_radioNetwork:
            p_cause->u.radioNetwork = p_rrm_cause->value;
            break;
            case T_s1ap_Cause_transport:
            p_cause->u.transport = p_rrm_cause->value;
            break;
            case T_s1ap_Cause_nas:
            p_cause->u.nas = p_rrm_cause->value;
            break;
            case T_s1ap_Cause_protocol:
            p_cause->u.protocol = p_rrm_cause->value;
            break;
            case T_s1ap_Cause_misc:
            p_cause->u.misc = p_rrm_cause->value;
            break;
            default:
            /*SPR 15601 Fix Start*/
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_RECEIVED_MSG] Invalid cause type:%d, setting type to: radioNetwork, value to: unspecified",
                    p_cause->t);
            p_cause->t = T_s1ap_Cause_radioNetwork;
            p_cause->u.radioNetwork = s1ap_unspecified_2 ;
            /*SPR 15601 Fix Stop*/
            result = RRC_FAILURE;
        }
    }
    else
    {
        p_cause->t = T_s1ap_Cause_radioNetwork;
        p_cause->u.radioNetwork = s1ap_unspecified_2 ;
        result = RRC_FAILURE;

    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}

/* ERAB SETUP START */

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_erab_setup_response
 *
 *   INPUTS       : uecc_ue_context_t*             p_ue_context
 *                  U32                            mme_ue_s1ap_id
 *                  U32                            enb_ue_s1ap_id
 *                  s1ap_CriticalityDiagnostics    *p_criticality_diagnostics
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends erab_setup_response message
 *       to S1AP
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_erab_setup_response(
        uecc_ue_context_t*             p_ue_context)

{
    /* coverity_fix_54697_start */
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_erab_setup_response_t msg;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;
    LOCAL_EVENT_S1_ERAB_SETUP_RESPONSE_STRUCT   *p_event_s1_erb_setup_resp = PNULL;
    U8  fail_erab_counter = 0;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);


    /* Is trace activated */
/* Is trace activated */
   /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated) 
            
    {
        /*SPR 15875 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,"\n<msg function=\"S1AP\" name=\"E-RAB SETUP RESPONSE \" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_CELL,"\n<msg function=\"S1AP\" name=\"E-RAB SETUP RESPONSE \" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        /*SPR 15875 Fix Stop*/
            P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
                    p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
    }
   /*SPR 15896 Fix Stop*/




    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                "[s1ap_E_RABSETUP RESPONSE]"
                "   ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */
        msg.bitmask = 0;
        RRC_UE_STOP_TIME_PERFORMANCE_COUNTER(
                p_ue_context,
                p_ue_context->ue_stats.ue_timer_stats[RRC_UE_ERAB_SETUP_TIME],
                RRC_UE_ERAB_SETUP_TIME);

        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

/*SPR 18758 5Sep Fix Start*/
         if (PNULL == p_ue_context->p_failed_curr_proc_data)
         {
            if (RRC_SUCCESS!=uecc_s1ap_build_E_RABSetupListBearerSURes(p_ue_context,
                        &asn1_ctx,&msg.e_rab_setup_list))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[s1ap_E_RABSetupResponse]"
                        "uecc_s1ap_build_E_RABSetupListBearerSURes failure");
                break;
            }

            if(msg.e_rab_setup_list.count > 0)
            {
                msg.bitmask |=
                    RRC_S1AP_ERAB_SETUP_RESPONSE_E_RAB_SETUP_LIST_PRESENT;
            }
    }
/*SPR 18758 5Sep Fix Stop*/



        if (RRC_SUCCESS!=uecc_s1ap_build_e_rab_failed_to_setup_list(
                    p_ue_context,&asn1_ctx,&msg.e_rab_failed_to_setup_list, 
                    ERAB_SETUP_RESPONSE))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_E_RABSETUP Response]"
                    "uecc_s1ap_build_E_RAB_FAILED_TO_SETUP_LIST failure");
            break;
        }

        if(msg.e_rab_failed_to_setup_list.count > 0)
        {
            msg.bitmask |=
                RRC_S1AP_ERAB_SETUP_RESPONSE_E_RAB_FAILED_TO_SETUP_LIST_PRESENT;
        }

        result=rrc_s1ap_erab_setup_response_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                &msg);

        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_E_RABSETUP RESPONSE] Build failure");
            break;
        }
        else
        {
            /* Generating Protocol Event LOCAL_S1_ERAB_SETUP_RESPONSE*/
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

             rrc_asn1PrtToStr_S1AP_PDU(RRC_ASN,
                    "S1AP_PDU", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_ERAB_SETUP_RESPONSE,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            } 

            /* Generating Protocol Event LOCAL_EVENT_S1_ERAB_SETUP_RESPONSE*/
            p_event_s1_erb_setup_resp = rrc_mem_get(sizeof(LOCAL_EVENT_S1_ERAB_SETUP_RESPONSE_STRUCT));

            if (PNULL != p_event_s1_erb_setup_resp)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */

                p_event_s1_erb_setup_resp->header.length = 
                    sizeof(LOCAL_EVENT_S1_ERAB_SETUP_RESPONSE_STRUCT);
                p_event_s1_erb_setup_resp->header.event_id = LOCAL_EVENT_S1_ERAB_SETUP_RESPONSE;

                /*klockwork Fix*/   
                if ((PNULL != p_ue_context->p_gb_context->p_p_csc_context) && (PNULL !=
                            p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index])
                        && (PNULL != p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                            p_csc_init_setup_ind))/*klockwork Fix*/
                {
                    l3_memcpy_wrapper(&p_event_s1_erb_setup_resp->header.EVENT_PARAM_CELL_ID, 
                            p_ue_context->p_gb_context->
                            p_p_csc_context[p_ue_context->cell_index]->
                            p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.cell_Id, sizeof(U32));
                }
                p_event_s1_erb_setup_resp->header.EVENT_PARAM_EUTRANCELL_FROID = 
                    p_event_s1_erb_setup_resp->header.EVENT_PARAM_CELL_ID;

                if (p_ue_context->m.mme_ue_id_present)
                {
                    p_event_s1_erb_setup_resp->header.EVENT_PARAM_MMES1APID = p_ue_context->mme_ue_id;
                }

                p_event_s1_erb_setup_resp->header.EVENT_PARAM_RAC_UE_REF = p_ue_context->s1ap_ue_id;

                if (PNULL != p_ue_context->p_curr_proc_data)
                {
                    for (fail_erab_counter = 0; (fail_erab_counter < p_ue_context->p_curr_proc_data->u.
                                erab_setup_request_data.failed_erab_data.count) && 
                            (fail_erab_counter < MAX_ERAB_COUNT); fail_erab_counter++)
                    {
                        p_event_s1_erb_setup_resp->EVENT_ARRAY_ERAB_SETUP_FAILURE_3GPP_CAUSE_GROUP[fail_erab_counter] = 
                            (U32)p_ue_context->p_curr_proc_data->u.erab_setup_request_data.failed_erab_data.
                            erab_failed_to_setup_item[fail_erab_counter].cause.t;

                        switch(p_event_s1_erb_setup_resp->EVENT_ARRAY_ERAB_SETUP_FAILURE_3GPP_CAUSE_GROUP[fail_erab_counter])
                        { 
                            case T_s1ap_Cause_radioNetwork: 
                                p_event_s1_erb_setup_resp->EVENT_ARRAY_ERAB_SETUP_FAILURE_3GPP_CAUSE[fail_erab_counter] = 
                                    (U32)p_ue_context->p_curr_proc_data->u.erab_setup_request_data.failed_erab_data.
                                    erab_failed_to_setup_item[fail_erab_counter].cause.u.radioNetwork;
                                break;

                            case T_s1ap_Cause_transport: 
                                p_event_s1_erb_setup_resp->EVENT_ARRAY_ERAB_SETUP_FAILURE_3GPP_CAUSE[fail_erab_counter] = 
                                    (U32)p_ue_context->p_curr_proc_data->u.erab_setup_request_data.failed_erab_data.
                                    erab_failed_to_setup_item[fail_erab_counter].cause.u.transport;
                                break;

                            case T_s1ap_Cause_nas: 
                                p_event_s1_erb_setup_resp->EVENT_ARRAY_ERAB_SETUP_FAILURE_3GPP_CAUSE[fail_erab_counter] = 
                                    (U32)p_ue_context->p_curr_proc_data->u.erab_setup_request_data.failed_erab_data.
                                    erab_failed_to_setup_item[fail_erab_counter].cause.u.nas;
                                break; 

                            case T_s1ap_Cause_protocol:
                                p_event_s1_erb_setup_resp->EVENT_ARRAY_ERAB_SETUP_FAILURE_3GPP_CAUSE[fail_erab_counter] = 
                                    (U32)p_ue_context->p_curr_proc_data->u.erab_setup_request_data.failed_erab_data.
                                    erab_failed_to_setup_item[fail_erab_counter].cause.u.protocol;
                                break; 

                            case T_s1ap_Cause_misc:
                                p_event_s1_erb_setup_resp->EVENT_ARRAY_ERAB_SETUP_FAILURE_3GPP_CAUSE[fail_erab_counter] = 
                                    (U32)p_ue_context->p_curr_proc_data->u.erab_setup_request_data.failed_erab_data.
                                    erab_failed_to_setup_item[fail_erab_counter].cause.u.misc;
                                break; 
                        }
                    }
                }
                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_s1_erb_setup_resp);
            }
        }

        if (PNULL != p_ue_context->p_ue_trace_activation_info && 
                p_ue_context->m.traceActivated) 

        {
            /* ASN.1 encoded message to logged */
            rrc_trace_max_file_write(p_ue_context, ERAB_SETUP_RESP, p_sig_msg_req->message_buff_size , 
                    &p_sig_msg_req->message_buff_p[0], S1);
        }
/*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated) 
        {
            /* ASN.1 encoded message to logged */
            rrc_trace_max_file_write(p_ue_context, ERAB_SETUP_RESP, p_sig_msg_req->message_buff_size , 
                          &p_sig_msg_req->message_buff_p[0], S1);
        }
    /*SPR 15896 Fix Stop*/

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_E_RABSetup;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
        /*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
        /*BUG 604 changes stop*/

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                    p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "S1AP_MSG: E-RABSetupResponse %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));

    }while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;

}
/* coverity_fix_54697_stop */

/* ERAB SETUP STOP */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_initial_context_setup_response
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends initial_context_setup_response message
 *       to S1AP
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_initial_context_setup_response(
        uecc_ue_context_t* p_ue_context)
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_initial_context_setup_response_t msg;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;

    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if(p_ue_context->m.traceActivated) 
            
    {
        /*SPR 15875 Fix Start*/
        /*SPR 15896 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_MME,"\n<msg function=\"S1AP\" name=\"INITIAL CONTEXT SETUP RESPONSE \" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_CELL,"\n<msg function=\"S1AP\" name=\"INITIAL CONTEXT SETUP RESPONSE \" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        /*SPR 15875 Fix Stop*/
            P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
                    p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
        /*SPR 15896 Fix Stop*/
    }

    RRC_UE_STOP_TIME_PERFORMANCE_COUNTER(
            p_ue_context,
            p_ue_context->ue_stats.ue_timer_stats[RRC_UE_ERAB_SETUP_TIME],
            RRC_UE_ERAB_SETUP_TIME);
    
    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_InitialContextSetupResponse]"
                "   ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */
        msg.bitmask = 0;

        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

        if (RRC_SUCCESS!=uecc_s1ap_build_E_RABSetupListCtxtSURes(p_ue_context,
                    &asn1_ctx,&msg.e_rab_setup_list))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_InitialContextSetupResponse]"
                    "uecc_s1ap_build_E_RABSetupListCtxtSURes failure");
            break;
        }

        if (RRC_SUCCESS!=uecc_s1ap_build_e_rab_failed_to_setup_list(
                    p_ue_context,&asn1_ctx,&msg.e_rab_failed_to_setup_list,
                    INITIAL_CTX_SETUP_RESPONSE))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_InitialContextSetupResponse]"
                    "uecc_s1ap_build_E_RABSetupListCtxtSURes failure");
            break;
        }
        if(msg.e_rab_failed_to_setup_list.count > 0)
        {
            msg.bitmask |=
                RRC_S1AP_INITIAL_CONTEXT_SETUP_RESPONSE_E_RAB_FAILED_TO_SETUP_LIST_PRESENT;
        }

        /* Encode message */
        result=rrc_s1ap_initial_context_setup_response_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                &msg);

        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_InitialContextSetupResponse] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            
            rrc_asn1PrtToStr_S1AP_PDU(RRC_ASN,
                    "S1AP_PDU", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                                 encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_INITIAL_CONTEXT_SETUP_RESPONSE,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }
        if (p_ue_context->m.traceActivated )
                
        {
            /* ASN.1 encoded message to logged */
       /*SPR 15896 Fix Start*/
            rrc_trace_max_file_write(p_ue_context, INITIAL_CONTEXT_SETUP_RESP,
                    p_sig_msg_req->message_buff_size , &p_sig_msg_req->message_buff_p[0], S1);
        /*SPR 15896 Fix Stop*/
        }


        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_InitialContextSetup;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/
      
    /* SPR 19273 Fix Start */
        SET_UE_INDEX(p_ue_context->ue_index);
        /* SPR 19273 Fix End */
  
        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "S1AP_MSG: InitialContextSetupResponse %s",
                change_data_to_str(p_sig_msg_req->message_buff_size,p_sig_msg_req->message_buff_p));
 
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;

}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_initial_context_setup_failure
 *
 *   INPUTS       : uecc_ue_context_t   *p_ue_context
 *                  U32        mme_ue_s1ap_id
 *                  U32        enb_ue_s1ap_id
 *                  s1ap_Cause *p_cause
 *                  s1ap_CriticalityDiagnostics    *p_criticality_diagnostics
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends s1ap_InitialContextSetupFailure message
 *       to S1AP
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_initial_context_setup_failure(
        uecc_ue_context_t   *p_ue_context,
        U32        mme_ue_s1ap_id,
        U32        enb_ue_s1ap_id,
        s1ap_Cause *p_cause,
        s1ap_CriticalityDiagnostics    *p_criticality_diagnostics
        )
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_initial_context_setup_failure_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;

    RRC_ASSERT(PNULL != p_cause);
    RRC_ASSERT(PNULL != p_ue_context);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_InitialContextSetupFailure] "
                "ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */

        msg.mme_ue_s1ap_id = mme_ue_s1ap_id;
        msg.enb_ue_s1ap_id = enb_ue_s1ap_id;
        msg.cause = *p_cause;

        /* Is trace activated */
        if (p_ue_context->m.traceActivated )
                
        {
            /*SPR 15875 Fix Start*/
        /*SPR 15896 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), GEN_MME, "\n<msg function=\"S1AP\" name=\"Initial Context Setup Failure\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), GEN_CELL, "\n<msg function=\"S1AP\" name=\"Initial Context Setup Failure\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
            /*SPR 15875 Fix Stop*/
            //Trace Change Start
            P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
                    p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
            //Trace Change End

               /* SPR:5840 start */
                uecc_s1ap_p_rrc_trace_for_cause(p_ue_context,msg.cause);
                P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), S1,"\n</msg>");
        
               /* SPR:5840 stop */
            /*SPR 15896 Fix Stop*/
        }

        if (p_criticality_diagnostics != PNULL)
        {
            msg.bitmask |= 
                RRC_S1AP_INITIAL_CONTEXT_SETUP_FAILURE_CRITICALITY_DIAGNOSTICS_PRESENT;
            msg.criticality_diagnostics = *p_criticality_diagnostics;
        }

        /* Encode message */
        result=rrc_s1ap_initial_context_setup_failure_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                &msg);
        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_InitialContextSetupFailure] "
                    "Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            
            rrc_asn1PrtToStr_S1AP_PDU(RRC_ASN,
                    "S1AP_PDU", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                                 encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_INITIAL_CONTEXT_SETUP_FAILURE,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }
        /* ASN.1 encoded message to logged */
    /*SPR 15896 Fix Start*/
        rrc_trace_max_file_write(p_ue_context, INITIAL_CONTEXT_SETUP_FAILURE, p_sig_msg_req->message_buff_size , 
                      &p_sig_msg_req->message_buff_p[0], S1);
    /*SPR 15896 Fix Stop*/

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_InitialContextSetup;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "S1AP_MSG: InitialContextSetupFailure %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/* Trace Start Procedure start */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_trace_failure_indication
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  void*              p_msg
 *                  s1ap_Cause*        p_cause
 *                  U8                 flag
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends s1ap_TraceFailureIndication message
 *       to S1AP module
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_trace_failure_indication(
        uecc_ue_context_t* p_ue_context,
        void* p_msg,
        s1ap_Cause*         p_cause,
        U8                  flag
        )
{
    rrc_s1ap_trace_start_t* p_trace_start_msg = PNULL;
    rrc_s1ap_deactivate_trace_t* p_deactivate_trace_msg = PNULL;
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_trace_failure_indication_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_msg);
    RRC_ASSERT(PNULL != p_cause);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);


    if (flag == RRC_FALSE)  /* trace_start msg */
    {
        p_trace_start_msg = (rrc_s1ap_trace_start_t*)p_msg;
    }
    if (flag == RRC_TRUE)  /* deactivate trace msg */
    {
        p_deactivate_trace_msg = (rrc_s1ap_deactivate_trace_t*)p_msg;
    }

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_TraceFailureIndication] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    do
    {
        /* Reset message */
        memset_wrapper(&msg, RRC_NULL, sizeof(msg));
        memset_wrapper(sig_msg_req_buf, RRC_NULL,
                sizeof(s1ap_ue_associated_sig_msg_req_t));

        if (flag == RRC_FALSE)
        {
            /* Fill info in RRC_UECC_TRACE_failure_indication msg */
            msg.mme_ue_s1ap_id = p_trace_start_msg->mme_ue_s1ap_id;
            msg.enb_ue_s1ap_id = p_trace_start_msg->enb_ue_s1ap_id;
            msg.e_utran_trace_id = p_trace_start_msg->trace_activation.e_UTRAN_Trace_ID;
        }
        if (flag == RRC_TRUE)
        {
            /* Fill info in RRC_UECC_TRACE_failure_indication msg */
            msg.mme_ue_s1ap_id = p_deactivate_trace_msg->mme_ue_s1ap_id;
            msg.enb_ue_s1ap_id = p_deactivate_trace_msg->enb_ue_s1ap_id;
            msg.e_utran_trace_id = p_deactivate_trace_msg->e_utran_trace_id;
        }
        /* assign received cause */
        msg.cause = *p_cause;

        /* Encode message */
        result = rrc_s1ap_trace_failure_indication_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                &msg);

        if (RRC_SUCCESS != result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_TraceFailureIndication] Build failure");
            break;
        }

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_TraceFailureIndication;

        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}
/* Trace Start Procedure end */

/******************************************************************************
 *   FUNCTION NAME: update_performance_counter_erab_release_stats_relENB
 *
 *   DESCRIPTION:
 *       This function updates performance counter erab_release_stats
 *
 *   RETURNS: None
 *
 *******************************************************************************/
static void update_performance_counter_erab_release_stats_relENB(
        uecc_ue_context_t*      p_ue_context,
        s1ap_Cause cause,
        U8 counter)
{
    U8 qci_value = 0;
    if (PNULL != p_ue_context->p_e_rab_list[counter])
    {
        qci_value = p_ue_context->p_e_rab_list[counter]->
            e_RABlevelQoSParameters.qCI;

        /* SPR 13441 Fix Start */
        if ( (RRC_MIN_QCI_GBR_LIMIT <= qci_value) &&
                (RRC_MAX_QCI_NON_GBR_LIMIT >= qci_value) )
        { 
        RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                g_rrc_stats.p_rrc_stats->
                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                p_gb_context->offset_uecc_mod_id].
                rrc_uecc_cell_stats[p_ue_context->cell_index].
                rrc_erab_related_stats.erab_release_stats.
                erab_relEnbNbr_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
                RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

        RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                g_rrc_stats.p_rrc_stats->
                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                p_gb_context->offset_uecc_mod_id].
                rrc_uecc_cell_stats[p_ue_context->cell_index].
                rrc_erab_related_stats.erab_release_stats.
                erab_relEnbNbr_sum, RRC_UPDATED_QCI_INDEX(qci_value), 
                RRC_MAX_QCI_INDEX);

        RRC_UPDATE_PERFORMANCE_COUNTER_S1AP_CAUSE(p_ue_context,
                g_rrc_stats.p_rrc_stats->
                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                p_gb_context->offset_uecc_mod_id].
                rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                erab_release_stats.erab_rel_enb_cause_stats.
                erab_relEnbNbr_cause, cause);
    }
        /* SPR 13441 Fix End */
    }
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_enb_ue_ctx_rel_req_update_performance_counter 
 *
 *   DESCRIPTION:
 *       This function updates performance counter in
 *       uecc_s1ap_build_and_send_enb_ue_ctx_release_req
 *
 *   RETURNS: None
 *
 *******************************************************************************/
static void uecc_s1ap_enb_ue_ctx_rel_req_update_performance_counter(
        uecc_ue_context_t*      p_ue_context,
        s1ap_Cause cause)
{
    U8 counter = 0;
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    if ( PNULL != g_rrc_stats.p_rrc_stats)
    {
        for (counter = 0; counter < MAX_ERAB_COUNT; counter++)
        {
            update_performance_counter_erab_release_stats_relENB(
                    p_ue_context, cause, counter);
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_enb_ue_ctx_release_req
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  s1ap_Cause              *p_cause
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends s1ap_UEContextReleaseRequest message
 *       to S1AP module
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_enb_ue_ctx_release_req(
        uecc_ue_context_t*      p_ue_context,
        s1ap_Cause              *p_cause
        )
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    s1ap_Cause s1apCause;
    s1ap_Cause cause;
    rrc_s1ap_ue_context_release_request_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_cause);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&cause, 0 , sizeof(cause));

    /*CR 101 changes start*/
    memset_wrapper(&p_ue_context->ue_ctx_rel_req_cause, RRC_NULL,
            sizeof(s1ap_Cause));
    p_ue_context->ue_ctx_rel_req_cause = *p_cause;
    /*CR 101 changes stop*/

    cause = *p_cause;
    if (RRC_FALSE == p_ue_context->p_gb_context->mme_connection_status)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_UEContextReleaseRequest] MME connection isn't present");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_UEContextReleaseRequest] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {   
        uecc_s1ap_enb_ue_ctx_rel_req_update_performance_counter(p_ue_context, cause);

        /* Is trace activated */
        if (p_ue_context->m.traceActivated ) 
        {
            /*SPR 15875 Fix Start*/
        /*SPR 15896 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_MME, "\n<msg function=\"S1AP\" name=\"Ue Context Release Req\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_CELL, "\n<msg function=\"S1AP\" name=\"Ue Context Release Req\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
            /*SPR 15875 Fix Stop*/
            //Trace Change Start
            P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
                p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
        /*SPR 15896 Fix Stop*/
            //Trace Change End
        }
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */
        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

        msg.cause = *p_cause;

        /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated) 

        {
            /*SPR:5840 start*/
            uecc_s1ap_p_rrc_trace_for_cause(p_ue_context,msg.cause);
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n</msg>"); 
            /*SPR:5840 stop*/
        }
        /*SPR 15896 Fix Stop*/
        if(p_ue_context->m.gw_context_release_indication_present)
        {
            msg.bitmask |=
                RRC_S1AP_CONTEXT_RELEASE_REQUEST_GW_RELEASE_INDICATION;
            msg.gw_context_release_indication = 0;
        }

        /* Encode message */
        result=rrc_s1ap_ue_context_release_request_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                &msg);
        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_UEContextReleaseRequest] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                                 encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_UE_CONTEXT_RELEASE_REQUEST,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        if (p_ue_context->m.traceActivated )
                
        {
            /* ASN.1 encoded message to logged */
        /*SPR 15896 Fix Start*/
            rrc_trace_max_file_write(p_ue_context, UE_CONTEXT_RELEASE_REQ,
                    p_sig_msg_req->message_buff_size , &p_sig_msg_req->message_buff_p[0], S1);
        /*SPR 15896 Fix Stop*/
        }
        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_UEContextReleaseRequest;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_MME_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->mme_ue_s1ap_id = p_ue_context->mme_ue_id;

        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_MME_ID_PRESENT;
        p_sig_msg_req->mme_id = p_ue_context->mme_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "S1AP_MSG: UEContextReleaseRequest %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));


        memset_wrapper(&s1apCause, 0, sizeof(s1apCause));

        s1apCause = *p_cause;

        if ( PNULL != g_rrc_stats.p_rrc_stats)
        {
            /* Update the performace counter */
            RRC_UPDATE_PERFORMANCE_COUNTER_S1AP_CAUSE(p_ue_context, 
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                    p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_connection_related_stats.
                    ue_contxt_rel_stats.ueCtxt_relReq_cause.ueCtxt_relReq_cause,
                    s1apCause);

            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                    p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].
                    rrc_connection_related_stats.ue_contxt_rel_stats.
                    ueCtxt_relReq_sum, 0, DUMMY_RANGE_CHECK_INDEX);
        }
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_ue_ctx_release_comp_resp
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends ue_context_release_complete
 *       message to S1AP module
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_ue_ctx_release_comp_resp(
        uecc_ue_context_t*      p_ue_context)
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_ue_context_release_complete_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    U8 qci_value = 0;
    U8 counter = 0;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;
    LOCAL_UE_CTXT_RELEASE_READY_STRUCT *p_local_ue_ctx_rel_ready = PNULL;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if (RRC_FALSE == p_ue_context->p_gb_context->mme_connection_status)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[S1AP_UE_CTX_RELEASE_COMP_RESP] MME connection isn't present");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[S1AP_UE_CTX_RELEASE_COMP_RESP] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Clean up message */
        memset_wrapper(&msg,0,sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */
        msg.bitmask = 0;

        asn1Init_s1ap_CriticalityDiagnostics(&msg.criticality_diagnostics);

        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);

        /* Encode message */
        result=rrc_s1ap_ue_context_release_complete_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                &msg);
        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[S1AP_UE_CTX_RELEASE_COMP_RESP] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);
 
            rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                                 encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_UE_CONTEXT_RELEASE_COMPLETE,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }
                
        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, &p_sig_msg_req->message_buff_p[0], 
                        p_sig_msg_req->message_buff_size, "UE Context Release Complete Response", 1);
        /* TRACE_changes_start */
        
        if ( PNULL != g_rrc_stats.p_rrc_stats)
        {
          for (counter = 0; counter < MAX_ERAB_COUNT; counter++)
         {    /* SPR 11462 Fix Start*/ 
            if ((PNULL != p_ue_context->p_e_rab_list[counter]) && 
                   (p_ue_context->m.srb1_created))  /* SPR 11462 Fix Stop*/
            {     
                qci_value = p_ue_context->p_e_rab_list[counter]->
                    e_RABlevelQoSParameters.qCI;
                
                /* SPR Fix 10108 */ 
                /* SPR Fix 10108 */
                
                /* SPR 13441 Fix Start */
                if ( (RRC_MIN_QCI_GBR_LIMIT <= qci_value) &&
                        (RRC_MAX_QCI_NON_GBR_LIMIT >= qci_value) )
                { 
                RRC_UPDATE_PERFORMANCE_COUNTER_WITH_DECREMENT(p_ue_context->p_gb_context,
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                        p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                        erab_sim_num_stats.erabSimNumber_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
                        RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

                RRC_UPDATE_PERFORMANCE_COUNTER_WITH_DECREMENT(p_ue_context->p_gb_context,
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                        p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                        erab_sim_num_stats.erabSimNumber_sum,
                        RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);
                }
                /* SPR 13441 Fix End */
            }
          }
        }
        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_UEContextRelease;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_MME_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->mme_ue_s1ap_id = p_ue_context->mme_ue_id;

        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_MME_ID_PRESENT;
        p_sig_msg_req->mme_id = p_ue_context->mme_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                    p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "S1AP_MSG: UEContextReleaseComplete %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));
        if ( PNULL != g_rrc_stats.p_rrc_stats)
        {
            /* Update the performace counter */
            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                    p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_connection_related_stats.
                    ue_contxt_rel_stats.ueContext_RelSuccNbr, RRC_NULL, 
                    DUMMY_RANGE_CHECK_INDEX);
        }

        p_local_ue_ctx_rel_ready = rrc_mem_get(sizeof(LOCAL_UE_CTXT_RELEASE_READY_STRUCT));
        if (PNULL != p_local_ue_ctx_rel_ready)
        {
            /* SES-508 Fix Start */
            /* Code Removed */
            /* SES-508 Fix End */
            
            p_local_ue_ctx_rel_ready->header.length = 
                sizeof(LOCAL_UE_CTXT_RELEASE_READY_STRUCT);
            p_local_ue_ctx_rel_ready->header.event_id = LOCAL_UE_CTXT_RELEASE_READY;

            if ((PNULL != p_ue_context->p_gb_context->p_p_csc_context) && 
                (PNULL != p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index])
                && (PNULL != p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                        p_csc_init_setup_ind))
            {
                l3_memcpy_wrapper(&p_local_ue_ctx_rel_ready->header.EVENT_PARAM_CELL_ID, 
                        p_ue_context->p_gb_context->
                        p_p_csc_context[p_ue_context->cell_index]->
                        p_csc_init_setup_ind->sib_type_1_Info.
                        cell_access_related_info.cell_Id, sizeof(U32));
            }

            p_local_ue_ctx_rel_ready->header.EVENT_PARAM_EUTRANCELL_FROID = 
                p_local_ue_ctx_rel_ready->header.EVENT_PARAM_CELL_ID;

            if (p_ue_context->m.mme_ue_id_present)
            {
                p_local_ue_ctx_rel_ready->header.EVENT_PARAM_MMES1APID = p_ue_context->mme_ue_id;
            }

            p_local_ue_ctx_rel_ready->header.EVENT_PARAM_RAC_UE_REF = p_ue_context->s1ap_ue_id;
            rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_local_ue_ctx_rel_ready);
        }
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_ul_nas_transport_req
 *
 *   INPUTS       : uecc_ue_context_t       *p_ue_context
 *                  DedicatedInfoNAS        *p_dedicatedInfoNAS
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends s1ap_uplinkNASTransport message
 *       to S1AP module
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_ul_nas_transport_req(
        uecc_ue_context_t       *p_ue_context,
        DedicatedInfoNAS        *p_dedicatedInfoNAS
        )
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_uplink_nas_transport_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_dedicatedInfoNAS);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                p_ue_context->cell_index))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    if (RRC_FALSE == p_ue_context->p_gb_context->mme_connection_status)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "[s1ap_uplinkNASTransport] MME connection isn't present");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    if ( !p_ue_context->m.mme_ue_id_present )
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "[s1ap_uplinkNASTransport] MME isn't ready");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_uplinkNASTransport] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        if (PNULL != p_ue_context->p_gb_context->p_p_csc_context)
        {
            if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                    [p_ue_context->cell_index])
            {
                if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                        [p_ue_context->cell_index]->p_csc_init_setup_ind)
                {
                    /* Is trace activated */
                    if (p_ue_context->m.traceActivated)
                    {
                /*SPR 15896 Fix Start*/
                    /*SPR 15875 Fix Start*/
                if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                        (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                        (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
                {
                                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_MME, "\n<msg function=\"S1\" name=\"Uplink Nas Transport\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                            difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
                }
                if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                        (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                        (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
                {
                                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_CELL, "\n<msg function=\"S1\" name=\"Uplink Nas Transport\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                            difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
                }
                    /*SPR 15875 Fix Stop*/
                        //Trace Change Start
                        P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
                           p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
                /*SPR 15896 Fix Stop*/
                        //Trace Change End
                    }
                    
                    /* Reset message */
                    memset_wrapper(&msg, 0, sizeof(msg));
                    memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));
                    
                    /* lipa start */
                    /* disable masks by default */
                    msg.bitmask = 0;
                    /* lipa end */
                    /* Fill message */
                    msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
                    msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

                    /* nas_pdu */
                    msg.nas_pdu = *p_dedicatedInfoNAS;

                    /* TAI */
                    /* tai.pLMNidentity should be the same as eutran_cgi.pLMNidentity*/
                    uecc_s1ap_generate_plmn_identity_int(
                            msg.tai.pLMNidentity.data,
                            &p_ue_context->plmn_identity.plmn_identity);   /*Mukesh*/
                    msg.tai.pLMNidentity.numocts = sizeof(msg.tai.pLMNidentity.data);

                /*SPR 15896 Fix Start*/

                    if (p_ue_context->m.traceActivated )
                    {
            /* SPR:5903 start */
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"TAI-pLMNidentity\">%02x%02x%02x</ie>",
                                            msg.tai.pLMNidentity.data[0],msg.tai.pLMNidentity.data[1],msg.tai.pLMNidentity.data[2]);
                /*SPR 15896 Fix Stop*/
            /* SPR:5903 stop */
                    }

                    /* tai.tAC */
                    RRC_ASSERT(sizeof(msg.tai.tAC.data) ==
                            sizeof(p_ue_context->p_gb_context->p_p_csc_context[
                                p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                                cell_access_related_info.tac));
                    l3_memcpy_wrapper(msg.tai.tAC.data,
                            p_ue_context->p_gb_context->p_p_csc_context[
                            p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.tac,
                            sizeof(msg.tai.tAC.data));
                    msg.tai.tAC.numocts = sizeof(msg.tai.tAC.data);

                /*SPR 15896 Fix Start*/
                    if (p_ue_context->m.traceActivated )
                    {
            /* SPR:5903 start */
                        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"TAI-tac\">%02x%02x</ie>",
                                msg.tai.tAC.data[0],msg.tai.tAC.data[1]);
            /* SPR:5903 stop */
                    }
                /*SPR 15896 Fix Stop*/

                    /* EUTRAN_CGI */
                    /* eutran_cgi.pLMNidentity */
                    msg.eutran_cgi.pLMNidentity.numocts =
                        sizeof(msg.eutran_cgi.pLMNidentity.data); /*3*/
                    /* eutran_cgi.pLMNidentity */
                    uecc_s1ap_generate_plmn_identity_int(
                            msg.eutran_cgi.pLMNidentity.data,
                            &p_ue_context->p_gb_context->p_p_csc_context[
                            p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.plmn_Id_info_list.
                            plmn_identity_info[0].plmn_identity);  

                /*SPR 15896 Fix Start*/
                    if (p_ue_context->m.traceActivated  )
                    {
            /* SPR:5903 start */
                        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n<ie name=\"E-UTRAN CGI-pLMNidentity\">%02x%02x%02x</ie>",
                                msg.eutran_cgi.pLMNidentity.data[0],msg.eutran_cgi.pLMNidentity.data[1],msg.eutran_cgi.pLMNidentity.data[2]);
            /* SPR:5903 stop */
                    }
                /*SPR 15896 Fix Stop*/


                    /* eutran_cgi.cell_ID */
                    /* 28 bits */
                    RRC_ASSERT(sizeof(msg.eutran_cgi.cell_ID.data) ==
                            sizeof(p_ue_context->p_gb_context->p_p_csc_context[
                                p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                                cell_access_related_info.cell_Id));
                    l3_memcpy_wrapper(msg.eutran_cgi.cell_ID.data,
                            p_ue_context->p_gb_context->p_p_csc_context[
                            p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.cell_Id,
                            sizeof(msg.eutran_cgi.cell_ID.data));
                    msg.eutran_cgi.cell_ID.numbits = RRC_CELL_IDENTITY_BITS;

                /*SPR 15896 Fix Start*/
                    if (p_ue_context->m.traceActivated )
                    {
            /* SPR:5903 start */
                        /* SPR_7798 */
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"E-UTRAN CELL_ID\">%02x%02x%02x%x</ie>",
                                            msg.eutran_cgi.cell_ID.data[0],
                                            msg.eutran_cgi.cell_ID.data[1],
                                            msg.eutran_cgi.cell_ID.data[2],
                                            msg.eutran_cgi.cell_ID.data[3]>>4);
            /* SPR:5903 stop */
                        /* SPR_7798 */
                        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n</msg>");
                /*SPR 15896 Fix Stop*/
                    }

                    /* lipa start */
                   /* Populate LGW transport layer address */
                   if (p_ue_context->p_gb_context->lgw_configured_status)
                   {
                      msg.bitmask |=  
                              RRC_LGW_TRANSPORT_LAYER_ADDRESS_PRESENT; 

                      msg.transport_layer_address.numbits = 
                        (OSUINT32)p_ue_context->p_gb_context->lgw_data_length *
                               RRC_OCTET_SIZE;

                      msg.transport_layer_address.data =
                              p_ue_context->p_gb_context->lgw_ip_addr;

                   }
                   /* lipa end*/

                    /* Encode message */
                    result=rrc_s1ap_uplink_nas_transport_intrl_enc(
                            p_ue_context->p_gb_context,
                            &asn1_ctx,
                            &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                            &msg);
                    if (RRC_SUCCESS!=result)
                    {
                        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                (p_ue_context->p_gb_context)->facility_name,
                                RRC_ERROR,
                                "[s1ap_uplinkNASTransport] Build failure");
                        break;
                    }
                    else
                    {
                        encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

                       
                     rrc_asn1PrtToStr_S1AP_PDU(RRC_ASN,
                    "S1AP_PDU", &s1ap_pdu);

                        p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                                encoded_msg_len);
                        if (PNULL != p_event_header)
                        {
                            /* SES-508 Fix Start */
                            /* Code Removed */
                            /* SES-508 Fix End */
                            rrc_uecc_fill_protocol_event_params(p_ue_context,
                                    p_event_header,
                                    (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                                    LOCAL_UPLINK_NAS_TRANSPORT,
                                    MESSAGE_DIRECTION_SEND);

                            l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                                        sizeof(EVENT_EXTERNAL_HEADER)),
                                    (const void*)p_sig_msg_req->message_buff_p,
                                    encoded_msg_len);

                            rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
                        }
                    }


                    /* ASN.1 encoded message to logged */
                /*SPR 15896 Fix Start*/
                    rrc_trace_max_file_write(p_ue_context, UPLINK_NAS_TRANSPORT, 
                            p_sig_msg_req->message_buff_size , &p_sig_msg_req->message_buff_p[0], S1);
                /*SPR 15896 Fix Stop*/

                    p_sig_msg_req->procedure_code = ASN1V_s1ap_id_uplinkNASTransport;
                    p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
                    p_sig_msg_req->enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
                    p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
                    /*Fill ue_index*/
                    p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

                    /* Send message to S1AP  */
                    result = uecc_rrc_send_internal_msg(
                            RRC_S1AP_MODULE_ID,
                            S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                            (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                                p_sig_msg_req->message_buff_size),
                            sig_msg_req_buf);

                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_INFO, "S1AP_MSG: UplinkNASTransport %s",
                    change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));
                }
            }
        }
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_nas_non_delivery_ind
 *
 *   INPUTS       : uecc_gb_context_t   *p_uecc_gb_context
 *                  U32     mme_ue_s1ap_id
 *                  U32     enb_ue_s1ap_id
 *                  s1ap_NAS_PDU *p_nas_pdu
 *                  s1ap_Cause *p_cause
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends s1ap_NASNonDeliveryIndication message
 *       to S1AP module
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_nas_non_delivery_ind(
        uecc_gb_context_t   *p_uecc_gb_context,
        U32     mme_ue_s1ap_id,
        U32     enb_ue_s1ap_id,
        s1ap_NAS_PDU *p_nas_pdu,
        s1ap_Cause *p_cause
        )
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_nas_non_delivery_indication_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    uecc_ue_context_t* p_ue_context = PNULL ;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;
    LOCAL_EVENT_S1_NAS_NON_DELIVERY_INDICATION_STRUCT *p_event_s1_nas_non_delvry = PNULL;

    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_cause);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);


    /* Handle mme_connection_status before sending */
    if ( RRC_FALSE == p_uecc_gb_context->mme_connection_status )
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "[s1ap_NASNonDeliveryIndication] MME connection isn't present");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return RRC_FAILURE;
    }

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "[s1ap_NASNonDeliveryIndication] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return RRC_FAILURE;
    }

    do
    {

        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */
        msg.mme_ue_s1ap_id = mme_ue_s1ap_id;
        msg.enb_ue_s1ap_id = enb_ue_s1ap_id;

        p_ue_context = uecc_ue_ctx_get_by_mme_s1ap_id(p_uecc_gb_context,
                mme_ue_s1ap_id);

        if (PNULL == p_ue_context)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,"Could'nt get the UE Context for tracing");
            break;
        }


        /* nas_pdu */
        if (PNULL!=p_nas_pdu)
        {
            msg.nas_pdu = *p_nas_pdu;
        }
        else
        {
            msg.nas_pdu.numocts = 0;
        }

        /* cause */
        msg.cause = *p_cause;
        /* Is trace activated */

        if (p_ue_context->m.traceActivated )
        {
            /*SPR 15875 Fix Start*/
            /*SPR 15896 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_MME,"\n<msg function=\"S1AP\" name=\"Nas Non Delivery Indication\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_CELL,"\n<msg function=\"S1AP\" name=\"Nas Non Delivery Indication\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
            /*SPR 15875 Fix Stop*/
            //Trace Change Start
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
                p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
            //Trace Change End
                /* SPR:5840 start */
                uecc_s1ap_p_rrc_trace_for_cause(p_ue_context,msg.cause);
                P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),S1,"\n</msg>");
        //      P_RRC_TRACE(p_ue_context,S1,"\n <ie name=\"Cause\">%d</ie> \n </msg>", msg.cause.t);
                /* SPR:5840 stop */
            /*SPR 15896 Fix Stop*/
        }

        /* Encode message */
        result=rrc_s1ap_nas_non_delivery_indication_intrl_enc(
                p_uecc_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                &msg);

        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "[s1ap_NASNonDeliveryIndication] Build failure");
            break;
        }
        else
        {   
            /* Generating Protocol Event LOCAL_NAS_NON_DELIVERY_INDICATION*/
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_S1AP_PDU(RRC_ASN,
                    "S1AP_PDU", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_NAS_NON_DELIVERY_INDICATION,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            } 
            /* Generating Protocol Event
             * LOCAL_EVENT_S1_NAS_NON_DELIVERY_INDICATION */
            
            p_event_s1_nas_non_delvry = 
                rrc_mem_get(sizeof(LOCAL_EVENT_S1_NAS_NON_DELIVERY_INDICATION_STRUCT));

            if (PNULL != p_event_s1_nas_non_delvry)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */

                p_event_s1_nas_non_delvry->header.length = 
                    sizeof(LOCAL_EVENT_S1_NAS_NON_DELIVERY_INDICATION_STRUCT);
                p_event_s1_nas_non_delvry->header.event_id = 
                    LOCAL_EVENT_S1_NAS_NON_DELIVERY_INDICATION;

                if ((PNULL != p_ue_context->p_gb_context) && (PNULL != 
                            p_ue_context->p_gb_context->p_p_csc_context) && (PNULL !=
                                p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index])
                        && (PNULL != p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                            p_csc_init_setup_ind))
                {
                    l3_memcpy_wrapper(&p_event_s1_nas_non_delvry->header.EVENT_PARAM_CELL_ID, 
                            p_ue_context->p_gb_context->
                            p_p_csc_context[p_ue_context->cell_index]->
                            p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.cell_Id, sizeof(U32));
                }

                p_event_s1_nas_non_delvry->header.EVENT_PARAM_EUTRANCELL_FROID = 
                    p_event_s1_nas_non_delvry->header.EVENT_PARAM_CELL_ID;

                if (p_ue_context->m.mme_ue_id_present)
                {
                    p_event_s1_nas_non_delvry->header.EVENT_PARAM_MMES1APID = p_ue_context->mme_ue_id;
                }

                p_event_s1_nas_non_delvry->header.EVENT_PARAM_RAC_UE_REF = p_ue_context->s1ap_ue_id;

                p_event_s1_nas_non_delvry->EVENT_PARAM_3GPP_CAUSE_GROUP = (U32)msg.cause.t;
                
                switch(p_event_s1_nas_non_delvry->EVENT_PARAM_3GPP_CAUSE_GROUP)
                { 
                    case T_s1ap_Cause_radioNetwork: 
                        p_event_s1_nas_non_delvry->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.radioNetwork;
                        break;

                    case T_s1ap_Cause_transport: 
                        p_event_s1_nas_non_delvry->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.transport;
                        break;

                    case T_s1ap_Cause_nas: 
                        p_event_s1_nas_non_delvry->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.nas;
                        break; 

                    case T_s1ap_Cause_protocol:
                        p_event_s1_nas_non_delvry->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.protocol;
                        break; 

                    case T_s1ap_Cause_misc:
                        p_event_s1_nas_non_delvry->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.misc;
                        break; 
                } 
                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_s1_nas_non_delvry);
            }
        }
        /* ASN.1 encoded message to logged */
    /*SPR 15896 Fix Start*/
        rrc_trace_max_file_write(p_ue_context, NAS_NON_DELIVERY_INDICATION, 
                p_sig_msg_req->message_buff_size , &p_sig_msg_req->message_buff_p[0], S1);
    /*SPR 15896 Fix Stop*/

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_NASNonDeliveryIndication;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO, "S1AP_MSG: NASNonDeliveryIndication %s",
            change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));
        
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_generate_plmn_identity_int
 *
 *
 *   INPUTS       : OSOCTET                 *p_s1ap_plmn_identity
 *                  plmn_identity_t    *p_plmn_identity
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function converts PLMN identiy from internal format to
 *       S1AP format according to TS 36.413.
 *
 *   RETURNS:
 *       Number of octets in resulting buffer
 *
 ******************************************************************************/
static void uecc_s1ap_generate_plmn_identity_int(
        OSOCTET                 *p_s1ap_plmn_identity,
        plmn_identity_t    *p_plmn_identity)
{
    /* TS 3GPP TS 36.413 V8.5.1 - 9.2.3.8  PLMN Identity
     * - digits 0 to 9, encoded 0000 to 1001,
     * - 1111 used as filler digit,
     * two digits per octet,
     * - bits 4 to 1 of octet n encoding digit 2n-1
     * - bits 8 to 5 of octet n encoding digit 2n
     *
     * -The Selected PLMN identity consists of 3 digits from MCC
     * followed by either
     * -a filler digit plus 2 digits from MNC (in case of 2 digit MNC) or
     * -3 digits from MNC (in case of a 3 digit MNC).
     * */

    /* MCC should be present always */
    RRC_ASSERT(PLMN_IDENTITY_MCC_PRESENCE_FLAG &
            p_plmn_identity->presence_bitmask);

    /* PLMN Identity 1st octet : Pack first 2 digits of MCC */
    p_s1ap_plmn_identity[0] =
        (OSOCTET)( (p_plmn_identity->mcc[0] & 0xF) |
                   ((p_plmn_identity->mcc[1] & 0xF) << 4));

    /* PLMN Identity 2nd octet: Pack 3rd digit of MCC */
    p_s1ap_plmn_identity[1] =
        (OSOCTET) (p_plmn_identity->mcc[2] & 0xF);

    if (2 == p_plmn_identity->mnc.count)
    {
        /* Add filler digit */
        p_s1ap_plmn_identity[1] |= 0xF0;

        /* PLMN Identity 3rd octet : 1st and 2nd digit of MNC */
        p_s1ap_plmn_identity[2] =
            (OSOCTET) ((p_plmn_identity->mnc.mnc[0] & 0xF) |
                       ((p_plmn_identity->mnc.mnc[1] & 0xF) << 4));
    }
    else
    {
        /* PLMN Identity 3rd octet : Pack 1st digit of MNC */
        p_s1ap_plmn_identity[1] =
            (OSOCTET)(p_s1ap_plmn_identity[1] |
                      ((p_plmn_identity->mnc.mnc[0] & 0xF) << 4));

        /* PLMN Identity 3rd octet : 2nd and 3rd digit of MNC */
        p_s1ap_plmn_identity[2] =
            (OSOCTET)  ((p_plmn_identity->mnc.mnc[1] & 0xF) |
                        ((p_plmn_identity->mnc.mnc[2] & 0xF) << 4));
    }
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_ue_capability_info_ind
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  UECapabilityInformation *p_UECapabilityInformation
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends S1AP UE CAPABILITY INFO INDICATION
 *       message to S1AP module
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_ue_capability_info_ind(
        uecc_ue_context_t*      p_ue_context,
        UECapabilityInformation *p_UECapabilityInformation
        )
{
    /* coverity_fix_54696_start */
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    /* HD-FDD start */
        /* SPR 13502 Fix Start */
    rrc_rrm_ue_capability_ind_t *p_rrc_rrm_ue_capability_ind = PNULL;
    U8 i = 0;
    U8 counter;
    OSRTDListNode*      p_node = PNULL;
    /* HD-FDD stop */
    rrc_s1ap_ue_capability_info_indication_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;

    UERadioAccessCapabilityInformation  capability_info;
    UERadioAccessCapabilityInformation_r8_IEs   *p_r8 = PNULL;
    U8  capability_info_buf[S1AP_MAX_ASN1_BUF_LEN];
    /* SPR 16062 Start */
    rrc_bool_et utra_capability_present = RRC_FALSE;
    U8 utra_capability_index = 0;
    OSRTDListNode* p_utra_node = PNULL;
    /* SPR 16062 Stop */


    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

        p_rrc_rrm_ue_capability_ind = (rrc_rrm_ue_capability_ind_t *)rrc_mem_get
                                  (sizeof(rrc_rrm_ue_capability_ind_t));
        if (PNULL == p_rrc_rrm_ue_capability_ind)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,
                "Memory Allocation Failure.");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /* SES-508 Fix Start */
        /* Code Removed */
        /* SES-508 Fix End */

    if (RRC_FALSE == p_ue_context->p_gb_context->mme_connection_status)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[S1AP_UE_CAPABILITY_INFO_IND] MME connection isn't present");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        /* Coverity Fix 83398 Start */
        rrc_mem_free (p_rrc_rrm_ue_capability_ind);
        p_rrc_rrm_ue_capability_ind = PNULL;
        /* Coverity Fix 83398 Stop */
        return RRC_FAILURE;
    }
    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[S1AP_UE_CAPABILITY_INFO_IND] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        /* Coverity Fix 83398 Start */
        rrc_mem_free (p_rrc_rrm_ue_capability_ind);
        p_rrc_rrm_ue_capability_ind = PNULL;
        /* Coverity Fix 83398 Stop */
        return RRC_FAILURE;
    }
    /* HD-FDD start */
    p_node = p_UECapabilityInformation->criticalExtensions.u.c1->
        u.ueCapabilityInformation_r8->ue_CapabilityRAT_ContainerList.head;
    for(i=0 ; i < p_UECapabilityInformation->criticalExtensions.u.c1->
            u.ueCapabilityInformation_r8->ue_CapabilityRAT_ContainerList.count ; i++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        /*   if(RRC_TRUE == p_ue_context->rrm_ue_capability_enq_ind)  */
        {
            result = uecc_rrm_build_ue_rat_capability(
                    p_ue_context,
                    &p_rrc_rrm_ue_capability_ind->radio_capability_info,
                    p_node->data);
            if(!result) 
            {
                break;
            }
        }
        /* SPR 16062 Start */
        if(RRC_RAT_TYPE_UTRA == ((UE_CapabilityRAT_Container *)(p_node->data))->rat_Type)
        {
            utra_capability_present = RRC_TRUE;
            utra_capability_index = i;
        }

        p_node = p_node->next;
        /* SPR 16062 Stop */

    } 
    /* 36321_CR0538 start */
    p_ue_context->access_stratum_release = p_rrc_rrm_ue_capability_ind->radio_capability_info.
        eutra_radio_capability_info.eutra_radio_capability_info_def.access_stratum_release;
    /* 36321_CR0538 stop */
    p_ue_context->ue_mode = 0;/* Reset */

        /* SPR 11997 Fix Start */
        if (DUPLEXING_MODE_TDD != p_ue_context->p_gb_context->
                p_p_csc_context[p_ue_context->cell_index]->p_csc_init_setup_ind->duplexing_mode)
        {
    for(counter = 0; counter< p_rrc_rrm_ue_capability_ind->radio_capability_info.eutra_radio_capability_info.
            eutra_radio_capability_info_def.rf_parameters.supported_band_list_eutra.count; counter++)
    {
        if(p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                p_csc_init_setup_ind->sib_type_1_Info.freq_band_indicator == 
                p_rrc_rrm_ue_capability_ind->radio_capability_info.eutra_radio_capability_info.
                eutra_radio_capability_info_def.rf_parameters.supported_band_list_eutra.
                supported_band_eutra[counter].band_eutra)
        {
            if(p_rrc_rrm_ue_capability_ind->radio_capability_info.eutra_radio_capability_info.
                    eutra_radio_capability_info_def.rf_parameters.supported_band_list_eutra.
                    supported_band_eutra[counter].half_duplex == 1)
            {
                p_ue_context->ue_mode = 1;
                break;
            }
        }

    }
        }
        /* SPR 11997 Fix Stop */

    /* SPR fix 23005 start */
    if ((DUPLEXING_MODE_FDD == p_ue_context->p_gb_context->
                p_p_csc_context[p_ue_context->cell_index]->p_csc_init_setup_ind->duplexing_mode) &&
            (p_ue_context->ue_mode == 1))
    {

        p_ue_context->share_data.p_uecc_rm_data->cause.t = T_s1ap_Cause_misc;
        p_ue_context->share_data.p_uecc_rm_data->cause.u.misc = s1ap_unspecified;

        /*   RRC_UECC_ICS_FSM_TRACE(RRC_WARNING,"ICS fail triggered for HD-FDD"); */

        uecc_s1ap_build_and_send_initial_context_setup_failure(
                p_ue_context,
                uecc_ue_ctx_get_mme_ue_id(p_ue_context),
                p_ue_context->s1ap_ue_id,
                &p_ue_context->share_data.p_uecc_rm_data->cause,
                PNULL);
        result = RRC_FAILURE;      
    }

    else
    {
        /* HD-FDD stop */
        do
        {
            /* Clean up message */
            memset_wrapper(&msg,0,sizeof(msg));
            memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

            /* Fill UERadioAccessCapabilityInformation */
            asn1Init_UERadioAccessCapabilityInformation(&capability_info);

            capability_info.criticalExtensions.t =
                T_UERadioAccessCapabilityInformation_criticalExtensions_c1;
            capability_info.criticalExtensions.u.c1 =
                rtxMemAllocType(&asn1_ctx,
                        UERadioAccessCapabilityInformation_criticalExtensions_c1);
            if (PNULL == capability_info.criticalExtensions.u.c1)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[S1AP_UE_CAPABILITY_INFO_IND] ASN malloc failed.");
                break;
            }

            capability_info.criticalExtensions.u.c1->t =
                T_UERadioAccessCapabilityInformation_criticalExtensions_c1_ueRadioAccessCapabilityInformation_r8;

            p_r8 = rtxMemAllocType(&asn1_ctx,
                    UERadioAccessCapabilityInformation_r8_IEs);
            if (PNULL == p_r8)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[S1AP_UE_CAPABILITY_INFO_IND] ASN malloc failed.");
                break;
            }
            capability_info.criticalExtensions.u.c1->
                u.ueRadioAccessCapabilityInformation_r8 = p_r8;

            p_r8->m.nonCriticalExtensionPresent = 0;

            /* Copy UECapabilityInformation message inside
             *  ueRadioAccessCapabilityInformation-r8 IE
             *  according to TS 36.331 10.2.2 */

            pu_setBuffer(&asn1_ctx, 0, 0, ASN_RRC_BUF_TYPE);

            /* SPR 16062 Start */
           if(RRC_TRUE == utra_capability_present)
           {
                p_node = p_UECapabilityInformation->criticalExtensions.u.c1->
                        u.ueCapabilityInformation_r8->ue_CapabilityRAT_ContainerList.head;

                if(0 == utra_capability_index)
                {
                        p_utra_node = p_node;
                        p_UECapabilityInformation->criticalExtensions.u.c1->
                            u.ueCapabilityInformation_r8->ue_CapabilityRAT_ContainerList.head = p_node->next;
                }
                else
                {
                        for(i=0 ; i < utra_capability_index - 1 ; i++)
                        {
                            p_node = p_node->next;
                        }
                        p_utra_node = p_node->next;
                        p_node->next = p_utra_node->next;
                }
                p_UECapabilityInformation->criticalExtensions.u.c1->
                u.ueCapabilityInformation_r8->ue_CapabilityRAT_ContainerList.count--;
           }
           /* SPR 16062 Stop */


        if (RT_OK != asn1PE_UECapabilityInformation(
                    &asn1_ctx, p_UECapabilityInformation))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "[S1AP_UE_CAPABILITY_INFO_IND] ASN1 encoding failed");
                break;
            }
      
            /* SPR 16062 Start */
           if(RRC_TRUE == utra_capability_present)
           {
                p_node = p_UECapabilityInformation->criticalExtensions.u.c1->
                        u.ueCapabilityInformation_r8->ue_CapabilityRAT_ContainerList.head;

                if(0 == utra_capability_index)
                {
                        p_UECapabilityInformation->criticalExtensions.u.c1->
                            u.ueCapabilityInformation_r8->ue_CapabilityRAT_ContainerList.head = p_utra_node;
                }
                else
                {
                        for(i=0 ; i < utra_capability_index - 1 ; i++)
                        {
                            p_node = p_node->next;
                        }
                        p_node->next = p_utra_node;
                }
                p_UECapabilityInformation->criticalExtensions.u.c1->
                    u.ueCapabilityInformation_r8->ue_CapabilityRAT_ContainerList.count++;
           }
           /* SPR 16062 Stop */
            p_r8->ue_RadioAccessCapabilityInfo.data =
                pe_GetMsgPtr(
                        &asn1_ctx,
                        (OSINT32*)&p_r8->ue_RadioAccessCapabilityInfo.numocts);

            if (PNULL == p_r8->ue_RadioAccessCapabilityInfo.data)
            { 
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[S1AP_UE_CAPABILITY_INFO_IND] ASN.1 failure");
                break;
            }

            /* ASN Encode UERadioAccessCapabilityInformation  */
            pu_setBuffer(&asn1_ctx,
                    capability_info_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);

            if (RT_OK != asn1PE_UERadioAccessCapabilityInformation(
                        &asn1_ctx, &capability_info))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[S1AP_UE_CAPABILITY_INFO_IND] ASN1 encoding failed.");
                break;
            }

            /* Fill S1AP message */
            asn1Init_s1ap_UERadioCapability(&msg.ue_radio_capability);

            msg.ue_radio_capability.numocts = pe_GetMsgLen(&asn1_ctx);
            msg.ue_radio_capability.data = &capability_info_buf[0];

            /* Now it is stored */

            msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
            msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);

            /* Encode message */
            result=rrc_s1ap_ue_capability_info_indication_intrl_enc(
                    p_ue_context->p_gb_context,
                    &asn1_ctx,
                    &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                    &msg);
            if (RRC_SUCCESS!=result)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[S1AP_UE_CAPABILITY_INFO_IND] Build failure");
                break;
            }
            else
            {
                
                    rrc_asn1PrtToStr_S1AP_PDU(
                          RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);
            }

            p_sig_msg_req->procedure_code = ASN1V_s1ap_id_UECapabilityInfoIndication;
            p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
            p_sig_msg_req->enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
            p_sig_msg_req->cell_index = p_ue_context->cell_index;
            /*BUG 604 changes start*/
            /*Fill ue_index*/
            p_sig_msg_req->ue_index = p_ue_context->ue_index;
            /*BUG 604 changes stop*/

            /* TRACE_changes_start */
            uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, &p_sig_msg_req->message_buff_p[0], 
                    p_sig_msg_req->message_buff_size, "UE Capability Info Ind", 1);
            /* TRACE_changes_start */

            /* Send message to S1AP  */
            result = uecc_rrc_send_internal_msg(
                    RRC_S1AP_MODULE_ID,
                    S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                    (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                        p_sig_msg_req->message_buff_size),
                    sig_msg_req_buf);

            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_INFO, "S1AP_MSG: UECapabilityInfoIndication %s",
                    change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));

        } while (0);
        /* HD-FDD start */
    }
    /* HD-FDD stop */
    /* SPR fix 23005 stop */

    if (PNULL != p_rrc_rrm_ue_capability_ind)
    {
        rrc_mem_free (p_rrc_rrm_ue_capability_ind);
        /* Coverity Fix 83398 Start */
        p_rrc_rrm_ue_capability_ind = PNULL;
        /* Coverity Fix 83398 Stop */
        }
        /* SPR 13502 Fix Stop */
    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}
/* coverity_fix_54696_stop */

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_error_indication
 *
 *   INPUTS       : U8                  mme_id
 *                  s1ap_MME_UE_S1AP_ID mme_ue_s1ap_id
 *                  rrc_bool_et         mme_ue_id_present
 *                  s1ap_ENB_UE_S1AP_ID enb_ue_s1ap_id
 *                  rrc_bool_et         enb_ue_id_present
 *                  s1ap_CriticalityDiagnostics *p_criticality_diagnostics
 *                  rrc_bool_et         criticality_diagnostics_present
 *                  s1ap_Cause*         p_cause
 *                  uecc_ue_context_t*  p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends s1ap_ErrorIndication message
 *       to S1AP module
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_error_indication(
        U8                  mme_id,
        s1ap_MME_UE_S1AP_ID mme_ue_s1ap_id,
        rrc_bool_et         mme_ue_id_present,
        s1ap_ENB_UE_S1AP_ID enb_ue_s1ap_id,
        rrc_bool_et         enb_ue_id_present,
        s1ap_CriticalityDiagnostics *p_criticality_diagnostics,
        rrc_bool_et         criticality_diagnostics_present,
        s1ap_Cause*         p_cause,
        uecc_ue_context_t*  p_ue_context
        )
{
    rrc_return_et result = RRC_FAILURE;
    rrc_bool_et   is_cause_set = RRC_FALSE;
    OSCTXT asn1_ctx;
    rrc_s1ap_error_indication_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;
    LOCAL_EVENT_S1_ERROR_INDICATION_STRUCT *p_event_s1_error_ind = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_cause);

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_ErrorIndication] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* SPR_20915 - Fix - Starts */
    /* Reset message */
    memset_wrapper(&msg, 0, sizeof(msg));
    memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));
    /* SPR_20915 - Fix - Ends */

    p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_MME_ID_PRESENT;
    p_sig_msg_req->mme_id = mme_id;
    do
    {
        /* Fill message */
        msg.bitmask = 0;

        if ((RRC_FALSE == mme_ue_id_present)&&
                (RRC_FALSE == enb_ue_id_present))
        {
            msg.bitmask |= RRC_S1AP_ERROR_INDICATION_CAUSE_PRESENT;
            msg.cause.t = T_s1ap_Cause_radioNetwork;
            msg.cause.u.radioNetwork = s1ap_unknown_pair_ue_s1ap_id;
            is_cause_set = RRC_TRUE;
        }
        if (RRC_TRUE == mme_ue_id_present)
        {
            msg.mme_ue_s1ap_id = mme_ue_s1ap_id;
            msg.bitmask |= RRC_S1AP_ERROR_INDICATION_MME_UE_S1AP_ID_PRESENT;
            p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_MME_UE_S1AP_ID_PRESENT;
            p_sig_msg_req->mme_ue_s1ap_id = mme_ue_s1ap_id;
        }
        else
            if ((RRC_FALSE == mme_ue_id_present) && (is_cause_set == RRC_FALSE))
            {
                msg.bitmask |= RRC_S1AP_ERROR_INDICATION_CAUSE_PRESENT;
                msg.cause.t = T_s1ap_Cause_radioNetwork;
                msg.cause.u.radioNetwork = s1ap_unknown_mme_ue_s1ap_id;
            }

        if (RRC_TRUE == enb_ue_id_present)
        {
            msg.enb_ue_s1ap_id = enb_ue_s1ap_id;
            msg.bitmask |= RRC_S1AP_ERROR_INDICATION_ENB_UE_S1AP_ID_PRESENT;
            p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
            p_sig_msg_req->enb_ue_s1ap_id = enb_ue_s1ap_id;
        }
        else
            if ((RRC_FALSE == enb_ue_id_present) && (is_cause_set == RRC_FALSE))
            {
                msg.bitmask |= RRC_S1AP_ERROR_INDICATION_CAUSE_PRESENT;
                msg.cause.t = T_s1ap_Cause_radioNetwork;
                msg.cause.u.radioNetwork = s1ap_unknown_enb_ue_s1ap_id;
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "[s1ap_ErrorIndication] enb id not present");
                msg.enb_ue_s1ap_id = 0; /*not known*/
            }

        if ((PNULL != p_cause) && (is_cause_set == RRC_FALSE))
        {
            msg.bitmask |= RRC_S1AP_ERROR_INDICATION_CAUSE_PRESENT;
            msg.cause = *p_cause;
        }

        /* CRITICALITY_DIAGNOSTICS*/
        /* Fill criticality_diagnostics */
        if ( criticality_diagnostics_present == RRC_TRUE && (PNULL != p_criticality_diagnostics))
        {

            msg.bitmask |= 
                RRC_S1AP_ERROR_INDICATION_CRITICALITY_DIAGNOSTICS_PRESENT;

            msg.criticality_diagnostics =*p_criticality_diagnostics;
        }

        /* Encode message */
        result=rrc_uecc_error_indication_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                &msg);
        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ErrorIndication] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                                 encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_ERROR_INDICATION,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
            
            p_event_s1_error_ind = rrc_mem_get(sizeof(LOCAL_EVENT_S1_ERROR_INDICATION_STRUCT));

            if (PNULL != p_event_s1_error_ind)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */

                p_event_s1_error_ind->header.length = sizeof(LOCAL_EVENT_S1_ERROR_INDICATION_STRUCT);
                p_event_s1_error_ind->header.event_id = LOCAL_EVENT_S1_ERROR_INDICATION;

                p_event_s1_error_ind->EVENT_PARAM_MESSAGE_DIRECTION = MESSAGE_DIRECTION_SEND;
                if(msg.bitmask & RRC_S1AP_ERROR_INDICATION_CAUSE_PRESENT)
                {
                    p_event_s1_error_ind->EVENT_PARAM_3GPP_CAUSE_GROUP = msg.cause.t;

                /* CSR 51447 START */
                    switch(p_event_s1_error_ind->EVENT_PARAM_3GPP_CAUSE_GROUP)
                    {
                        case T_s1ap_Cause_radioNetwork: 
                            p_event_s1_error_ind->EVENT_PARAM_3GPP_CAUSE = 
                                msg.cause.u.radioNetwork;
                            ALARM_FMT_MSG_L3(RRC_MODULE_ID, RRC_S1AP_ERROR_INDICATION_ALARM_ID, 
                                    NOTIFICATION, "cause type = %d\n and cause value = %d",
                                    msg.cause.t, msg.cause.u.radioNetwork);
                            break;

                        case T_s1ap_Cause_transport: 
                            p_event_s1_error_ind->EVENT_PARAM_3GPP_CAUSE = 
                                msg.cause.u.transport;
                            ALARM_FMT_MSG_L3(RRC_MODULE_ID, RRC_S1AP_ERROR_INDICATION_ALARM_ID, 
                                    NOTIFICATION, "cause type = %d\n and cause value = %d",
                                    msg.cause.t, msg.cause.u.transport);
                            break;

                        case T_s1ap_Cause_nas: 
                            p_event_s1_error_ind->EVENT_PARAM_3GPP_CAUSE = 
                                msg.cause.u.nas;
                            ALARM_FMT_MSG_L3(RRC_MODULE_ID, RRC_S1AP_ERROR_INDICATION_ALARM_ID, 
                                    NOTIFICATION, "cause type = %d\n and cause value = %d",
                                    msg.cause.t, msg.cause.u.nas);
                            break; 

                        case T_s1ap_Cause_protocol:
                            p_event_s1_error_ind->EVENT_PARAM_3GPP_CAUSE = 
                                msg.cause.u.protocol;
                            ALARM_FMT_MSG_L3(RRC_MODULE_ID, RRC_S1AP_ERROR_INDICATION_ALARM_ID, 
                                    NOTIFICATION, "cause type = %d\n and cause value = %d",
                                    msg.cause.t, msg.cause.u.protocol);
                            break; 

                        case T_s1ap_Cause_misc:
                            p_event_s1_error_ind->EVENT_PARAM_3GPP_CAUSE = 
                                msg.cause.u.misc;
                            ALARM_FMT_MSG_L3(RRC_MODULE_ID, RRC_S1AP_ERROR_INDICATION_ALARM_ID, 
                                    NOTIFICATION, "cause type = %d\n and cause value = %d",
                                    msg.cause.t, msg.cause.u.misc);
                            break; 
                    }
                /* CSR 51447 STOP */
                }
                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, 
                        p_event_s1_error_ind);
            }
        }

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_ErrorIndication;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, &p_sig_msg_req->message_buff_p[0], 
                                            p_sig_msg_req->message_buff_size, "Error Indication", 1);
        /* TRACE_changes_start */

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,"S1AP_MSG: ErrorIndication %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_ue_release_msg_req
 *   INPUTS       : U32 enb_ue_s1ap_id
 *                  rrc_bool_et mme_release_required
 *                  uecc_ue_context_t*  p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends S1AP_UE_RELEASE_MSG_REQ message
 *       to S1AP module
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_ue_release_msg_req(
        U32 enb_ue_s1ap_id,
        rrc_bool_et mme_release_required,
        uecc_ue_context_t*  p_ue_context
        )
{
    rrc_return_et result = RRC_FAILURE;
    s1ap_ue_release_msg_req_t ue_release_msg;
    
    /* BUG 13094 Fix Start */
    U8 counter = RRC_NULL;
    U8 qci_value = RRC_NULL;
    /* BUG 13094 Fix Stop */

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* CSR 140218 Fix Start */
    if (RRC_FALSE == p_ue_context->p_gb_context->mme_connection_status)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
            (p_ue_context->p_gb_context)->facility_name, RRC_ERROR,
            "[s1ap_UEContextReleaseRequest] MME connection isn't present");

        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    /* CSR 140218 Fix End */

    /*SPR 15610 Fix Start*/
    ue_release_msg.release_cause_valid = RRC_FALSE;
    /*SPR 15610 Fix Stop*/

    ue_release_msg.enb_ue_s1ap_id = enb_ue_s1ap_id;
    ue_release_msg.mme_release_required = mme_release_required;

    /*SPR 20901 Start*/
    if(RRC_TRUE == mme_release_required)
    {   
        p_ue_context->ue_ctx_del_status.is_s1ap_resp_expected = RRC_TRUE;
    }
    /*SPR 20901 Stop*/

    /*SPR 15610 Fix Start*/
    if (p_ue_context->share_data.uecc_rcr_data.release_cause_valid)
    {
        ue_release_msg.release_cause_valid = RRC_TRUE;
        ue_release_msg.cause = p_ue_context->share_data.uecc_rcr_data.u.cause;
    }
    /*SPR 15610 Fix Stop*/

    /* BUG 13094 Fix Start */
    if ( PNULL != g_rrc_stats.p_rrc_stats )
    {
        for (counter = 0; counter < MAX_ERAB_COUNT; counter++)
        {
            if (PNULL != p_ue_context->p_e_rab_list[counter])
            {
                /* update the performance counter */
                qci_value = p_ue_context->p_e_rab_list[counter]->
                    e_RABlevelQoSParameters.qCI;
                    
                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context, 
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                        p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                        erab_release_stats.
                        erab_relAttNbr_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
                        RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context, 
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                        p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                        erab_release_stats.erab_relAttNbr_sum, 
                        RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);
            }
        }     
    }
    /* BUG 13094 Fix Stop */
    
    /* Send message to S1AP  */
    result = uecc_rrc_send_internal_msg(
            RRC_S1AP_MODULE_ID,
            S1AP_UE_RELEASE_MSG_REQ,
            sizeof(s1ap_ue_release_msg_req_t),
            &ue_release_msg);

    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
            (p_ue_context->p_gb_context)->facility_name,
            RRC_INFO, "S1AP_MSG: UE CONTEXT RELEASE REQUEST");

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_failure_msg_req
 *
 *   INPUTS       : uecc_gb_context_t   *p_uecc_gb_context
 *                   rrc_uecc_llim_s1u_path_failure_ind_t
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends S1AP_FAILURE_MSG_REQ message
 *       to S1AP module
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_failure_msg_req(
        uecc_gb_context_t   *p_uecc_gb_context,  /* UECC global context */
        rrc_uecc_llim_s1u_path_failure_ind_t  *p_llim_s1u_path_failure
        )
{
    rrc_return_et           result = RRC_FAILURE;
    s1ap_failure_msg_req_t  s1ap_failure_msg_req;
    rrc_counter_t           ue_index = RRC_NULL;
    uecc_ue_context_t       *p_ue_context = PNULL;
    U8                      addr_index = RRC_NULL;
    rrc_bool_et             is_mme_ue_id_filled = RRC_FALSE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    memset_wrapper(&s1ap_failure_msg_req, 0, sizeof(s1ap_failure_msg_req_t));

    /* set cell index */
    s1ap_failure_msg_req.cell_index = p_llim_s1u_path_failure->cell_index;

    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_BRIEF,
            "[S1AP_FAILURE_MSG_REQ][CELL:%u] "
            "Reset all UE related to the Transport layer address:",
            s1ap_failure_msg_req.cell_index);

    for (addr_index = 0;
            addr_index < p_llim_s1u_path_failure->ip_address_octet_size;
            addr_index++)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_BRIEF, "ip_address%02u [0x%02X]",
                addr_index,
                p_llim_s1u_path_failure->ip_address[addr_index]);
    }

    /* Prepare UE indexes list to eNB S1AP IDs list */
    for (ue_index = 0;
            ue_index < p_uecc_gb_context->total_ue_supported;
            ue_index++)
    {
        /* Get context */
        p_ue_context = p_uecc_gb_context->ue_db.ue_contexts[ue_index];
        if(PNULL != p_ue_context)
        {
            if (RRC_TRUE ==
                    uecc_ue_ctx_look_for_transport_addr(
                        p_ue_context,
                        p_llim_s1u_path_failure->ip_address_octet_size,
                        p_llim_s1u_path_failure->ip_address))
            {
                if ( PNULL != p_ue_context->ho_info.p_ho_info )
                {
                    if ( ( S1_HO == p_ue_context->ho_info.s1_or_x2_handover ) &&
                        ( PNULL != p_ue_context->ho_info.p_ho_info ) )
                    {
                        if ( PNULL != p_ue_context->ho_info.p_ho_info->
                                p_trg_ho_info )
                         {
                             if ( RRC_FALSE == p_ue_context->ho_info.p_ho_info->
                                     p_trg_ho_info->is_ho_req_ack_sent )
                             {
                                 /* store MME S1AP ID in S1AP_RESET_MSG_IND message
                                    to delete the temprory list maintained at S1AP 
                                    for Handover */
                                 s1ap_failure_msg_req.mme_ue_s1ap_id_list.mme_ue_s1ap_id
                                   [s1ap_failure_msg_req.mme_ue_s1ap_id_list.count] =
                                      p_ue_context->mme_ue_id;

                                 RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                         p_uecc_gb_context->facility_name,
                                         RRC_BRIEF,
                                         "[S1AP_FAILURE_MSG_REQ][UE_INDEX:%u] "
                                         "Added for resetting mme_ue_id[0x%08Xh]",
                                         p_ue_context->ue_index,
                                         p_ue_context->mme_ue_id);
                                 s1ap_failure_msg_req.mme_ue_s1ap_id_list.count++;
                                 is_mme_ue_id_filled = RRC_TRUE;
                             }
                         }
                    }
                }
                /* If MME UE S1AP Id is not filled, then fill eNB Ue S1AP Id */
                if ( RRC_FALSE == is_mme_ue_id_filled )
                {
                    /* store eNB S1AP ID in S1AP_RESET_MSG_IND message*/
                    s1ap_failure_msg_req.enb_ue_s1ap_id_list.enb_ue_s1ap_id
                        [s1ap_failure_msg_req.enb_ue_s1ap_id_list.count] =
                               p_ue_context->s1ap_ue_id;

                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_BRIEF,
                            "[S1AP_FAILURE_MSG_REQ][UE_INDEX:%u] "
                            "Added for resetting s1ap_ue_id[0x%08Xh]",
                            p_ue_context->ue_index,
                            p_ue_context->s1ap_ue_id);

                    s1ap_failure_msg_req.enb_ue_s1ap_id_list.count++;
                }

                /* BUG 13296 Fix Start */
                is_mme_ue_id_filled = RRC_FALSE;
                /* BUG 13296 Fix Stop */

            }
        }
    }

    if ( (0 < s1ap_failure_msg_req.enb_ue_s1ap_id_list.count) ||
            (0 < s1ap_failure_msg_req.mme_ue_s1ap_id_list.count) )
    {
        if (0 < s1ap_failure_msg_req.mme_ue_s1ap_id_list.count)
        {
            s1ap_failure_msg_req.bitmask = 
                S1AP_FAILURE_MSG_REQ_MME_UE_S1AP_ID_LIST_PRESENT; 
        }


        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_FAILURE_MSG_REQ,
                sizeof(s1ap_failure_msg_req_t),
                &s1ap_failure_msg_req);
    }
    else
    {
        /* Nothing to release. It's normal situation*/
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_BRIEF,
                "[S1AP_FAILURE_MSG_REQ] Nothing to release");
        result = RRC_SUCCESS;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_ue_context_modification_request
 *   INPUTS       : S1AP_PDU            *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  U8                  mme_id
 *                  U8                  *p_buff
 *                  U16                 buffer_length
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes s1ap_UeContextModification
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_ue_context_modification_request
(
 S1AP_PDU            *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
 U8                  mme_id,
 U8                  *p_buff,        /* ASN.1 encoded message */
/*BUG 604 changes start*/ 
 U16                 buffer_length, /* encoded buf size - just for check*/
 U16                 ue_index
/*BUG 604 changes stop*/ 
)
{
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_s1ap_ue_context_modification_request_t msg;
    rrc_s1ap_error_indication_t error_indication;
    uecc_s1ap_error_ind_bool_t        send_err_ind;
    rrc_return_et resp = RRC_SUCCESS;
    OSCTXT asn1_ctx;
    //cr_745
    s1ap_Cause                  logical_cause;
    s1ap_CriticalityDiagnostics logical_criti_diag;
    EVENT_EXTERNAL_HEADER       *p_event_header = PNULL;
    U32                         encoded_msglen = 0;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_ASSERT(PNULL!=p_s1ap_pdu->u.initiatingMessage);

    memset_wrapper(&msg, 0, sizeof(rrc_s1ap_ue_context_modification_request_t));
    memset_wrapper(&error_indication, 0, sizeof(rrc_s1ap_error_indication_t));
    memset_wrapper(&send_err_ind, 0, sizeof(uecc_s1ap_error_ind_bool_t));

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "[s1ap_ErrorIndication] ASN context initialization failed");
        return;
    }

    do
    {
        if( PNULL== 
                p_s1ap_pdu->u.initiatingMessage->value.u.uEContextModification)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_UeContextModification] ueContextModification field is PNULL");
            break;
        }

        /* Decode message */
        resp = rrc_s1ap_ue_context_modification_request_intrl_dec(
                p_uecc_gb_context,
                &asn1_ctx,
                mme_id,
                p_s1ap_pdu->u.initiatingMessage->value.u.uEContextModification,
                &msg,
                &error_indication,
                &send_err_ind);

        if (RRC_SUCCESS != resp)
        {
            /* Message parsing error. It is transfer syntax error.
             * Do not send the criticality diagnostics. */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_uEContextModification] Parsing error");
            /* Drop. */
            break;
        }

        /* Process message */
/*BUG 604 changes start*/ 
        /* Get context using ue_index */
        /*p_ue_context = uecc_ue_ctx_get_by_s1ap_id(p_uecc_gb_context,
                msg.enb_ue_s1ap_id);*/
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
                ue_index);
/*BUG 604 changes stop*/ 

        if (PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_uEContextModification] UE context not found");

            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"[s1ap_uEContextModification]"
                    "message dropped -"
                    "UECC isn't initialized by CSC ");
            /*SPR_18125_START*/
            rtFreeContext(&asn1_ctx);
            /*SPR_18125_END*/
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }

        if (0!=p_ue_context->m.mme_ue_id_present)
        {
            if (msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[s1ap_uEContextModification] "
                        "mme_ue_s1ap_id (%i) != p_ue_context->mme_ue_id (%i)",
                        msg.mme_ue_s1ap_id,
                        p_ue_context->mme_ue_id);

                break;
            }
        }
        else
        {
            /* store mme_ue_s1ap_id in UE context */
            p_ue_context->m.mme_ue_id_present = 1;
            p_ue_context->mme_ue_id = msg.mme_ue_s1ap_id;
        }

        if (PNULL != p_ue_context)
        {
            /*Generating Protocol Events */
            /* SPR 22634 Fix - Starts */
            encoded_msglen = (U32)(buffer_length);
            /* SPR 22634 Fix - Ends */
            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msglen);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msglen),
                        LOCAL_UE_CONTEXT_MODIFICATION_REQUEST,
                        MESSAGE_DIRECTION_RECEIVED);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_buff,
                        encoded_msglen);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }
        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, p_buff, encoded_msglen, "UE Context Modification", 0);
        /* TRACE_changes_start */
        
        /* cr_745 changes */
        if( ( RRC_S1AP_UE_CONTEXT_MODFICATION_REQUERST_CS_FALLBACK_INDICATOR_PRESENT
                    & msg.bitmask) &&
                (( RRC_S1AP_UE_CONTEXT_MODFICATION_REQUERST_SECURITY_KEY_PRESENT
                   & msg.bitmask) ||
                 ( RRC_S1AP_UE_CONTEXT_MODFICATION_REQUERST_UE_SECURITY_CAPABILITIES_PRESENT
                   & msg.bitmask))
          )
        {

            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name, RRC_ERROR,
                    "Failure : Concurrent requests for CSFB and Re-keying.");
            //filling cause
            logical_cause.t = T_s1ap_Cause_protocol;
            logical_cause.u.protocol = s1ap_semantic_error;

            //filling criticality diagnostics
            logical_criti_diag.m.procedureCodePresent = RRC_S1AP_SET_MEMBER;
            logical_criti_diag.procedureCode = ASN1V_s1ap_id_UEContextModification;

            logical_criti_diag.m.triggeringMessagePresent = RRC_S1AP_SET_MEMBER;
            logical_criti_diag.triggeringMessage = s1ap_initiating_message;

            logical_criti_diag.m.procedureCriticalityPresent = RRC_S1AP_SET_MEMBER;
            logical_criti_diag.procedureCriticality = s1ap_reject;

            logical_criti_diag.m.iEsCriticalityDiagnosticsPresent = RRC_FALSE;
            logical_criti_diag.m.iE_ExtensionsPresent = RRC_FALSE;

            logical_criti_diag.extElem1.count = RRC_FALSE;
            logical_criti_diag.extElem1.head = RRC_NULL;
            logical_criti_diag.extElem1.tail = RRC_NULL;

           /*COVERITY_FIX_20432_START */
            if( RRC_SUCCESS != 
                 uecc_s1ap_build_and_send_ue_context_modification_failure(
                    p_uecc_gb_context,
                    p_ue_context,
                    msg.mme_ue_s1ap_id,
                    msg.enb_ue_s1ap_id,
                    &logical_cause,
                    &logical_criti_diag))
       {
              RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,"[S1AP_MSG: UE CONTEXT MODIFICATION BUILD AND SEND FAILED");
           } 
           /*COVERITY_FIX_20432_END */
            break;
        }


        /* Call UECC_UE_EVENT_UE_CONTEXT_MOD_REQ event handler *
         * and pass API data to FSM. */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_S1AP_UE_CONTEXT_MOD_REQ,
                &msg);
    } while (0);

    /* Decode failure */
    if (RRC_SUCCESS != resp)
    {
        /* Check for Error Indication */
        /* Check if Criticality Diagnostics present in the message */
        if (RRC_S1AP_ERROR_INDICATION_CRITICALITY_DIAGNOSTICS_PRESENT & 
                error_indication.bitmask)
        {
            /* Now we have to decide if we have to send the error indication
             * message or the failure message */
/*BUG 604 changes start*/ 
            if ((RRC_S1AP_ERROR_INDICATION_MME_UE_S1AP_ID_PRESENT & 
                        error_indication.bitmask)
                    && (RRC_S1AP_ERROR_INDICATION_ENB_UE_S1AP_ID_PRESENT & 
                        error_indication.bitmask)
                    && (PNULL != (p_ue_context = uecc_ue_ctx_get
                        (p_uecc_gb_context, ue_index))))
/*BUG 604 changes stop*/ 
            {
                /* if both are present we have we can send the failure message */
            /*COVERITY_FIX_20432_START */
                if(RRC_SUCCESS != 
                    uecc_s1ap_build_and_send_ue_context_modification_failure(
                        p_uecc_gb_context,
                        p_ue_context,
                        msg.mme_ue_s1ap_id,
                        msg.enb_ue_s1ap_id,
                        &error_indication.cause,
                        &error_indication.criticality_diagnostics))
                {
                   RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                   (p_ue_context->p_gb_context)->facility_name,
                   RRC_INFO,"[S1AP_MSG: UE CONTEXT MODIFICATION BUILD AND SEND FAILED");
                }
            /*COVERITY_FIX_20432_END */
            }
            else if (RRC_S1AP_ERROR_INDICATION_CAUSE_PRESENT & 
                    error_indication.bitmask)
            {
                /* EI will be sent in this case*/
                uecc_s1ap_build_and_send_err_indication(p_uecc_gb_context,
                        RRC_S1AP_MODULE_ID,mme_id,
                        &error_indication);
            }
        }
    }

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_dl_s1_cdma2000_tunneling
 *
 *   INPUTS       : S1AP_PDU            *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  U8                  mme_id
 *                  U8                  *p_buff
 *                  U16                 buffer_length
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes s1ap_DownlinkS1cdma2000tunneling
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_dl_s1_cdma2000_tunneling
(
 S1AP_PDU            *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
 U8                  mme_id,
 U8          *p_buff,        /* ASN.1 encoded message */
/*BUG 604 changes start*/ 
 U16         buff_size,      /* encoded buf size - just for check*/
 U16         ue_index
/*BUG 604 changes stop*/ 
 )
{
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_s1ap_downlink_s1_cdma2000_tunneling_t msg;
    rrc_s1ap_error_indication_t error_indication;
    uecc_s1ap_error_ind_bool_t        send_err_ind;
    rrc_return_et resp = RRC_SUCCESS;
    rrc_return_et result = RRC_SUCCESS;
    OSCTXT asn1_ctx;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    /* SPR 13401 Fix Start */
    s1ap_Cause s1ap_cause;
    /* SPR 13401 Fix Stop */

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_ASSERT(PNULL!=p_s1ap_pdu->u.initiatingMessage);

    memset_wrapper(&msg, 0, sizeof(rrc_s1ap_downlink_s1_cdma2000_tunneling_t));
    memset_wrapper(&error_indication, 0, sizeof(rrc_s1ap_error_indication_t));
    memset_wrapper(&send_err_ind, 0, sizeof(uecc_s1ap_error_ind_bool_t));


    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "[s1ap_ErrorIndication] ASN context initialization failed");
        return;
    }

    do
    {
        if( PNULL == 
                p_s1ap_pdu->u.initiatingMessage->value.u.downlinkS1cdma2000tunnelling )
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_DownlinkS1cdma2000tunneling] downlinkS1cdma2000tunneling field is PNULL");
            break;
        }

        /* Decode message */
        resp = rrc_s1ap_downlink_s1_cdma2000_tunneling_intrl_dec(
                p_uecc_gb_context,
                &asn1_ctx,
                mme_id,
                p_s1ap_pdu->u.initiatingMessage->value.u.downlinkS1cdma2000tunnelling,
                &msg,
                &error_indication,
                &send_err_ind);

        if ( RRC_SUCCESS != resp )
        {
            /* Message parsing error. It is transfer syntax error.
             * Do not send the criticality diagnostics. */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_DownlinkS1cdma2000tunneling] Parsing error");
            /* Drop. */
            break;
        }

        /* Process message */
        /*BUG 604 changes start*/ 
        /* Get context using ue_index */
        /*p_ue_context = uecc_ue_ctx_get_by_s1ap_id(p_uecc_gb_context,
          msg.enb_ue_s1ap_id);*/
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
                ue_index);
        /*BUG 604 changes stop*/ 

        if (PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_DownlinkS1cdma2000tunneling] UE context not found");

            error_indication.bitmask |= RRC_S1AP_ERROR_INDICATION_ENB_UE_S1AP_ID_PRESENT; 
            error_indication.enb_ue_s1ap_id = msg.enb_ue_s1ap_id;

            error_indication.bitmask |= RRC_S1AP_ERROR_INDICATION_CAUSE_PRESENT;
            error_indication.cause.t = T_s1ap_Cause_radioNetwork;
            error_indication.cause.u.radioNetwork  = s1ap_unknown_enb_ue_s1ap_id;

            result = RRC_FAILURE;
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"[s1ap_DownlinkS1cdma2000tunneling]"
                    "message dropped -"
                    "UECC isn't initialized by CSC ");
            /*SPR_18125_START*/
            rtFreeContext(&asn1_ctx);
            /*SPR_18125_END*/
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }

        if (0!= p_ue_context->m.mme_ue_id_present)
        {
            if (msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[s1ap_DownlinkS1cdma2000tunneling] "
                        "mme_ue_s1ap_id (%i) != p_ue_context->mme_ue_id (%i)",
                        msg.mme_ue_s1ap_id,
                        p_ue_context->mme_ue_id);

                /* Send failure response */
                error_indication.bitmask |=  
                    RRC_S1AP_ERROR_INDICATION_MME_UE_S1AP_ID_PRESENT ;
                error_indication.mme_ue_s1ap_id = msg.mme_ue_s1ap_id;
                error_indication.bitmask |= 
                    RRC_S1AP_ERROR_INDICATION_CAUSE_PRESENT;
                error_indication.cause.t = T_s1ap_Cause_radioNetwork;
                error_indication.cause.u.radioNetwork = 
                    s1ap_unknown_mme_ue_s1ap_id;

                result = RRC_FAILURE;
                break;
            }
        }
        else
        {
            /* store mme_ue_s1ap_id in UE context */
            p_ue_context->m.mme_ue_id_present = 1;
            p_ue_context->mme_ue_id = msg.mme_ue_s1ap_id;
        }

        if((RRC_TRUE == p_ue_context->ho_info.cdma_ho_ongoing)&&
                (msg.bitmask & 
                 RRC_S1AP_DL_CDMA2000_TUNNELING_ERAB_SUBJECT_TO_DATA_FORWARDING_LIST_PRESENT ))
        {
            /* SPR 13401 Fix Start */
            if (RRC_FAILURE == uecc_fsm_validate_and_fill_erab_forwarding_list(
                        p_ue_context,&(msg.erab_subject_to_data_forwarding_list)))
            {
                s1ap_cause.t = T_s1ap_Cause_radioNetwork;
                s1ap_cause.u.radioNetwork = s1ap_unspecified_2;

                if (RRC_SUCCESS != uecc_s1ap_build_and_send_nas_non_delivery_ind(
                            p_ue_context->p_gb_context,
                            msg.mme_ue_s1ap_id,
                            msg.enb_ue_s1ap_id,
                            &msg.cdma2000_pdu,
                            &s1ap_cause))
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "[s1ap_NASNonDeliveryIndication] delivery fail");
                }
                /* SPR 14345 Fix Start */
                break;
            }
            /* SPR 14345 Fix Stop */
            /* SPR 13401 Fix Stop */
        }

        if ( p_ue_context->m.traceActivated )
        {
            /*SPR 15875 Fix Start*/
            /*SPR 15896 Fix Start*/
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                    (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                    (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
            {
                P_RRC_TRACE(p_ue_context,set_all_trace_bitmask (),GEN_MME,"\n <msg function=\"S1AP\" name=\"Downlink S1 CDMA2000 Tunnneling\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                        difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
            }
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                    (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                    (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
            {
                P_RRC_TRACE(p_ue_context,set_all_trace_bitmask (),GEN_CELL,"\n <msg function=\"S1AP\" name=\"Downlink S1 CDMA2000 Tunnneling\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                        difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
            }
            /*SPR 15875 Fix Stop*/
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask (),S1,"\n <initiator type=\"MME\">%s</initiator>",
                    p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"CDMA2000 HO Status\">%d</ie>",msg.cdma2000_ho_status);
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"CDMA2000 RAT Type\">%d</ie>",msg.cdma2000_rat_type);
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),S1,"\n </msg> ");
            /*SPR 15896 Fix Stop*/

        }   

        /* Added for i-Rat */
        /* ASN.1 encoded message to logged */
        /*SPR 15896 Fix Start*/
        rrc_trace_max_file_write(p_ue_context, DOWNLINK_S1_CDMA2000_TUNNELING,
             buff_size, p_buff, S1);
        /*SPR 15896 Fix Stop*/
        if(msg.bitmask & RRC_S1AP_DL_CDMA2000_TUNNELING_HO_STATUS_PRESENT)
        {

            uecc_fsm_process_event(
                    p_ue_context,
                    UECC_EV_S1AP_DL_CDMA2000_TUNNELING_HO_ONGOING,
                    &msg);
        }
        else
        {
            uecc_fsm_process_event(
                    p_ue_context,
                    UECC_EV_S1AP_DL_CDMA2000_TUNNELING,
                    &msg);
        }

    } while (0);

    /* Decode failure */
    if (RRC_SUCCESS != result)
    {
        if ((RRC_S1AP_ERROR_INDICATION_MME_UE_S1AP_ID_PRESENT &
                    error_indication.bitmask) ||
                (RRC_S1AP_ERROR_INDICATION_ENB_UE_S1AP_ID_PRESENT &
                 error_indication.bitmask) ||
                (RRC_S1AP_ERROR_INDICATION_CAUSE_PRESENT &
                 error_indication.bitmask))
        {
            uecc_s1ap_build_and_send_err_indication(
                    p_uecc_gb_context,
                    RRC_S1AP_MODULE_ID,
                    mme_id,
                    &error_indication);
        }
    }

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}


/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_ue_context_modification_response
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends ue_context_modification_response message
 *       to S1AP
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_ue_context_modification_response(
        uecc_ue_context_t* p_ue_context)
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_ue_context_modification_response_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_UEContextModificationResponse]"
                "   ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */
        msg.bitmask = 0;

        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

        /* Encode message */
        result=rrc_s1ap_initial_ue_context_modification_response_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                &msg);
        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_UEContextModificationResponse] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                                 encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_UE_CONTEXT_MODIFICATION_RESPONSE,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_UEContextModification;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, &p_sig_msg_req->message_buff_p[0], 
                        p_sig_msg_req->message_buff_size, "UE Context Modification Response", 1);
        /* TRACE_changes_start */
        
        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,"S1AP_MSG: UEContextModificationResponse %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;

}


/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_uplink_s1_cdma2000_tunneling
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  DedicatedInfoCDMA2000 *p_dedicatedInfo
 *                  U32 dedicatedInfoType
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends uplink_s1_cdma2000_tunneling message
 *       to S1AP
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_uplink_s1_cdma2000_tunneling(
        uecc_ue_context_t* p_ue_context,
    DedicatedInfoCDMA2000 *p_dedicatedInfo,
    U32 dedicatedInfoType
    )
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_uplink_s1_cdma2000_tunneling_t msg;
    rrc_rrm_ho_required_t   *p_ho_reqd = PNULL;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/


    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];

    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_dedicatedInfo);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if (RRC_TRUE == p_ue_context->ho_info.cdma_ho_ongoing)
    {  
        if (PNULL ==  p_ue_context->ho_info.p_ho_info->p_src_ho_info->
                         s1_src_ho_info.p_rrc_rrm_ho_required)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_UplinkS1cdma2000tunneling]"
                 " p_rrc_rrm_ho_required is NULL");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        else
        {
            p_ho_reqd = p_ue_context->ho_info.p_ho_info->p_src_ho_info-> \
                s1_src_ho_info.p_rrc_rrm_ho_required;
        }  
    }

    if (RRC_FALSE == p_ue_context->p_gb_context->mme_connection_status)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_UplinkS1cdma2000tunneling] MME connection isn't present");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    
    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_UplinkS1cdma2000tunneling]"
                "   ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

/* TRACE_fix */
        /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated)
    {
        /*SPR 15875 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & UU) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),GEN_MME,"\n <msg function=\"Uu\" name=\"UL Information Transfer\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & UU) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),GEN_CELL,"\n <msg function=\"Uu\" name=\"UL Information Transfer\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        /*SPR 15875 Fix Stop*/
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),UU,"<ie name=\"CDMA2000 Type\">%d</ie>",dedicatedInfoType); 
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),UU,"\n </msg>");
        /*SPR 15896 Fix Stop*/
    }
/* TRACE_fix */

    do
    {
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(rrc_s1ap_uplink_s1_cdma2000_tunneling_t));
        memset_wrapper(sig_msg_req_buf,0,(sizeof(s1ap_ue_associated_sig_msg_req_t)
        + S1AP_MAX_ASN1_BUF_LEN));

        /* Common Messages */

        /*MME UE S1AP ID*/
        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);

        /*ENB UE S1AP ID*/
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

        if(dedicatedInfoType ==
                T_ULInformationTransfer_r8_IEs_dedicatedInfoType_dedicatedInfoCDMA2000_1XRTT)
        {
            /*RAT Type*/
            msg.cdma2000_rat_type = s1ap_onexRTT;

           if ((RRC_TRUE == p_ue_context->ho_info.cdma_ho_ongoing))
           {
              RRC_ASSERT(PNULL != p_ho_reqd);

              /* CSR 00070260 Changes Start */
              /*CDMA2000 Sector ID = 1XRTT CELL ID*/
              if(RRC_RRM_CDMA2000_1XRTT_REF_CELL_ID_PRESENCE_FLAG & 
                         p_ho_reqd->bitmask)
              {
                msg.cdma2000_sector_id.numocts = CDMA2000_1XRTT_REFERENCE_CELL_ID_LENGTH;
                msg.cdma2000_sector_id.data = p_ho_reqd->ref_cell_id_1xrtt.\
                                              cdma2000_1xrtt_ref_cell_id;
              }
            /*CDMA2000 Sector ID = 1XRTT CELL ID*/
              else if (RRC_CSC_UECC_CDMA2000_1XRTT_REF_CELL_ID_PRESENCE_FLAG & 
                    p_ue_context->p_gb_context->
                    p_p_csc_context[p_ue_context->cell_index]->
                    p_csc_init_setup_ind->bitmask)
              {
                  msg.cdma2000_sector_id.numocts = CDMA2000_1XRTT_REFERENCE_CELL_ID_LENGTH;
                  msg.cdma2000_sector_id.data = p_ue_context->p_gb_context->
                                              p_p_csc_context[p_ue_context->cell_index]->
                                              p_csc_init_setup_ind->
                                              ref_cell_id_1xrtt.
                                              cdma2000_1xrtt_ref_cell_id;
              }
              else
              {
                  RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                  (p_ue_context->p_gb_context)->facility_name,
                                RRC_ERROR, "[s1ap_UplinkS1cdma2000tunneling]"
                                   "Failed to build CDMA2000 1xRTT Sector Id");
                  break;
              }
              /* CSR 00070260 Changes Stop */


              /*CDMA2000 1xRTT SRVCC Info*/
              if(RRC_RRM_UE_HO_ADM_REQ_SRVCC_HO_INDICATION_PRESENT & p_ho_reqd->bitmask)
              {
               
                 msg.bitmask |= RRC_S1AP_UL_CDMA2000_TUNNELING_1X_SRVCC_INFO_PRESENT;
 
                 if(RRC_SUCCESS != 
                       uecc_s1ap_build_cdma2000_1x_srvcc(&msg,
                          p_ue_context,&asn1_ctx))
                 {

                       RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                  (p_ue_context->p_gb_context)->facility_name,
                                RRC_ERROR, "[s1ap_UplinkS1cdma2000tunneling]"
                                   "Failed to build CDMA2000 1xRTT SRVCC Info");
                       break;

                 }

              }           
            }
            else 
            {
                 /* CSR 00070260 Changes Start */
                 /*CDMA2000 Sector ID = 1XRTT CELL ID*/
                 if (RRC_CSC_UECC_CDMA2000_1XRTT_REF_CELL_ID_PRESENCE_FLAG & 
                    p_ue_context->p_gb_context->
                    p_p_csc_context[p_ue_context->cell_index]->
                    p_csc_init_setup_ind->bitmask)
                 {
                        msg.cdma2000_sector_id.numocts = CDMA2000_1XRTT_REFERENCE_CELL_ID_LENGTH;
                        msg.cdma2000_sector_id.data = p_ue_context->p_gb_context->
                                              p_p_csc_context[p_ue_context->cell_index]->
                                              p_csc_init_setup_ind->
                                              ref_cell_id_1xrtt.
                                              cdma2000_1xrtt_ref_cell_id;
                 }
                 /* CSR 00070260 Changes Stop */
            }
            /*CDMA2000 1xRTT RAND*/

            msg.cdma2000_1x_rand.numocts = sizeof(U32);

            msg.cdma2000_1x_rand.data = (OSOCTET*)rtxMemAlloc(&asn1_ctx,
                                                    sizeof(U32));
            if (PNULL== msg.cdma2000_1x_rand.data)
            {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL, "ASN malloc failed.");
                    /*SPR_18125_START*/
                    rtFreeContext(&asn1_ctx);
                    /*SPR_18125_END*/
                    return RRC_FAILURE;
            }

            memset_wrapper((void*)msg.cdma2000_1x_rand.data, 0,
                      sizeof(U32));
            
            msg.bitmask |= RRC_S1AP_UL_CDMA2000_TUNNELING_1X_RAND_PRESENT;

            /* CSR 56323/Bug8834 FIX start */
            if( RRC_TRUE == p_ue_context->p_gb_context->
                    p_p_csc_context[p_ue_context->cell_index]->\
                    cdma2000_rand_val_in_use_flag )
            {
                rrc_pack_U32((void*)msg.cdma2000_1x_rand.data,
                             &p_ue_context->p_gb_context->\
                             p_p_csc_context[p_ue_context->cell_index]->
                             cdma2000_rand_val_used) ; 

                p_ue_context->p_gb_context->\
                    p_p_csc_context[p_ue_context->cell_index]\
                    ->cdma2000_rand_val_in_use_flag = RRC_FALSE;
            }
            else
            {
                 rrc_pack_U32((void*)msg.cdma2000_1x_rand.data,&p_ue_context->p_gb_context->\
                    p_p_csc_context[p_ue_context->cell_index]->\
                    p_csc_init_setup_ind->cdma2000_rand);
            }
            /* CSR 56323/Bug8834 FIX stop */
        }
        else if(dedicatedInfoType ==
                T_ULInformationTransfer_r8_IEs_dedicatedInfoType_dedicatedInfoCDMA2000_HRPD)
        {
            /*RAT Type*/
            msg.cdma2000_rat_type = s1ap_hRPD;


            /*CDMA2000 Sector ID = HRPD SECTOR ID*/
            if (RRC_TRUE == p_ue_context->ho_info.cdma_ho_ongoing)
            {
               
                RRC_ASSERT(PNULL != p_ho_reqd);

                /* CSR 00070260 Changes Start */
                if(RRC_RRM_CDMA2000_HRPD_REF_CELL_ID_PRESENCE_FLAG & 
                         p_ho_reqd->bitmask)
                {
                     msg.cdma2000_sector_id.numocts = CDMA2000_HRPD_REFERENCE_SECTOR_ID_LENGTH;
                     msg.cdma2000_sector_id.data = p_ho_reqd->ref_sector_id_hrpd.
                                                         cdma2000_hrpd_ref_sector_id;
                }
                else if (RRC_CSC_UECC_CDMA2000_HRPD_REF_CELL_ID_PRESENCE_FLAG & 
                      p_ue_context->p_gb_context->\
                      p_p_csc_context[p_ue_context->cell_index]->\
                      p_csc_init_setup_ind->bitmask)
                {
                    msg.cdma2000_sector_id.numocts = CDMA2000_HRPD_REFERENCE_SECTOR_ID_LENGTH;
                    msg.cdma2000_sector_id.data = p_ue_context->p_gb_context->\
                                              p_p_csc_context[p_ue_context->cell_index]->\
                                              p_csc_init_setup_ind->\
                                              ref_sector_id_hrpd.\
                                              cdma2000_hrpd_ref_sector_id;
                }
                else
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                  (p_ue_context->p_gb_context)->facility_name,
                                   RRC_ERROR, "[s1ap_UplinkS1cdma2000tunneling]"
                                   "Failed to build CDMA2000 HRPD Sector Id");
                    break;
                }
                /* CSR 00070260 Changes Stop */

                if (RRC_RRM_EUTRAN_ROUND_TRIP_DELAY_EST_INFO_PRESENT & 
                   p_ho_reqd->cdma2000_information.bitmask)
                {
                     /*EUTRAN Round Trip Delay Estimation Info*/
                     msg.bitmask |= 
                     RRC_S1AP_UL_CDMA2000_TUNNELING_ROUND_TRIP_DELAY_ESTIMATION_INFO_PRESENT;
                
                    msg.round_trip_delay_estimation_info = 
                        p_ue_context->ho_info.p_ho_info->p_src_ho_info->\
                        s1_src_ho_info.p_rrc_rrm_ho_required->\
                       cdma2000_information.eutran_round_trip_delay_estimation_info;
                 }
              }
              else
              {
                /* CSR 00070260 Changes Start */
                if (RRC_CSC_UECC_CDMA2000_HRPD_REF_CELL_ID_PRESENCE_FLAG & 
                      p_ue_context->p_gb_context->\
                      p_p_csc_context[p_ue_context->cell_index]->\
                      p_csc_init_setup_ind->bitmask)
                {

                      msg.cdma2000_sector_id.numocts = CDMA2000_HRPD_REFERENCE_SECTOR_ID_LENGTH;
                      msg.cdma2000_sector_id.data = p_ue_context->p_gb_context->\
                                              p_p_csc_context[p_ue_context->cell_index]->\
                                              p_csc_init_setup_ind->\
                                              ref_sector_id_hrpd.\
                                              cdma2000_hrpd_ref_sector_id;
                 }
                /* CSR 00070260 Changes Stop */
             }
        }

        /*CDMA2000 HO Required Indication*/
        if(RRC_TRUE == p_ue_context->ho_info.cdma_ho_ongoing)
        {
            /*If Active procedure is SOURCE HO ONGOING and HO Type is any of the
             * CDMA HO types i.e. eCSFB only, HRPD only, concurrent eCSFB+HRPD
             * then this field will be included, else not*/
            msg.bitmask |= RRC_S1AP_UL_CDMA2000_TUNNELING_HO_REQUIRED_IND_PRESENT;
            msg.cdma2000_ho_required_ind = s1ap_true_;
        }
        else
        {  /*This is the case of UL Tunneling packing during Pre-Registration
            * procedure, this filed won't come*/ 
        }

        /*CDMA2000-PDU*/
        msg.cdma2000_pdu =  *p_dedicatedInfo;

/* TRACE_fix */
        /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated)
        {
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),GEN_MME,"\n <msg function=\"S1AP\" name=\"Uplink S1 CDMA2000 Tunneling\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
            {
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),GEN_CELL,"\n <msg function=\"S1AP\" name=\"Uplink S1 CDMA2000 Tunneling\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
            }
            /*SPR 15875 Fix Stop*/
                P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <target type=\"MME\">%s</target>",
                p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);

                P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"<ie name=\"CDMA2000 RAT Type\">%d</ie>",msg.cdma2000_rat_type);
                /*klockwork Fix*/
        if ((msg.cdma2000_sector_id.numocts != 0) && (PNULL != msg.cdma2000_sector_id.data))/*klockwork Fix*/
                {
 /* CSR 00070260 Changes Start */
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"<ie name=\"CDMA2000 Sector ID\">%02x%02x%02x%02x%02x</ie>",
                                msg.cdma2000_sector_id.data[0], msg.cdma2000_sector_id.data[1],
                                msg.cdma2000_sector_id.data[2], msg.cdma2000_sector_id.data[3],
                                msg.cdma2000_sector_id.data[4]);
 /* CSR 00070260 Changes Stop */
                }
                if (msg.bitmask & RRC_S1AP_UL_CDMA2000_TUNNELING_HO_REQUIRED_IND_PRESENT)
                {
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"<ie name=\"CDMA2000 HO Required Indication\">%d</ie>",
                                msg.cdma2000_ho_required_ind);
                }
                P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n </msg>");
        }
        /*SPR 15896 Fix Stop*/
/* TRACE_fix */

        /*Encode Message*/
        result = rrc_s1ap_uplink_s1_cdma2000_tunneling_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                &msg);
        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_UplinkS1cdma2000tunneling] Build failure");
            break;
        }
        else
        {
            
            rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU", &s1ap_pdu);
        }

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_UplinkS1cdma2000tunnelling;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, &p_sig_msg_req->message_buff_p[0], 
                        p_sig_msg_req->message_buff_size, "Uplink S1 CDMA2000 Tunneling", 1);
        /* TRACE_changes_start */
        
        /* Send message
         * to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                    p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,"S1AP_MSG: UplinkS1cdma2000tunneling %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));


    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;

}




/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_ue_context_modification_failure
 *
 *   INPUTS       : uecc_gb_context_t   *p_uecc_gb_context
 *                  uecc_ue_context_t* p_ue_context
 *                  U32        mme_ue_s1ap_id
 *                  U32        enb_ue_s1ap_id
 *                  s1ap_Cause *p_cause
 *                  s1ap_CriticalityDiagnostics    *p_criticality_diagnostics
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends s1ap_ueContextModificationFailure message
 *       to S1AP
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_ue_context_modification_failure(
        uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
        uecc_ue_context_t* p_ue_context,
        U32        mme_ue_s1ap_id,
        U32        enb_ue_s1ap_id,
        s1ap_Cause *p_cause,
        s1ap_CriticalityDiagnostics    *p_criticality_diagnostics
        )
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_ue_context_modification_failure_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;
    LOCAL_UE_CTXT_MOD_FAIL_STRUCT *p_ue_ctx_mod_fail = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_cause);
    RRC_ASSERT(PNULL != p_uecc_gb_context);

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "[s1ap_ueContextModificationFailure] "
                "ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Is trace activated */
        if (PNULL != p_ue_context && p_ue_context->m.traceActivated)
        {
        /*SPR 15896 Fix Start*/
            /*SPR 15875 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_MME,"\n <msg function=\"S1AP\" name=\"Ue Context Modification Failure\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_CELL,"\n <msg function=\"S1AP\" name=\"Ue Context Modification Failure\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
            /*SPR 15875 Fix Stop*/
            //Trace Change Start
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
                p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
        /*SPR 15896 Fix Stop*/
            //Trace Change End
        }
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */
        msg.bitmask = 0;

        if (p_ue_context != PNULL)
        {
            msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
            msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
        }
        else
        {
            msg.mme_ue_s1ap_id = mme_ue_s1ap_id;
            msg.enb_ue_s1ap_id = enb_ue_s1ap_id;
        }
        msg.cause = *p_cause;

        if ((PNULL != p_ue_context) && (p_ue_context->m.traceActivated))
        {
            /*SPR 15896 Fix Start*/
               /* SPR:5840 start */
                uecc_s1ap_p_rrc_trace_for_cause(p_ue_context,msg.cause);
               /* SPR:5840 stop */
              P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),S1,"\n </msg> ");
            /*SPR 15896 Fix Stop*/
        }

        if (p_criticality_diagnostics != PNULL)
        {
            msg.bitmask |= 
                RRC_S1AP_UE_CONTEXT_MODIFICATION_FAILURE_CRITICALITY_DIAGNOSTICS_PRESENT;
            msg.criticality_diagnostics = *p_criticality_diagnostics;
        }
        else
        {
            /* CD can't be set as the cause for failure is
             * s1ap_radio_connection_with_ue_lost,
             * s1ap_interaction_with_other_procedure,
             * s1ap_unspecified_2,
             * s1ap_s1_intra_system_handover_triggered.
             * No particular IE has gone bad causing the failure.*/
        }
        /* Encode message */
        result= rrc_s1ap_ue_context_modification_failure_intrl_enc(
                p_uecc_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                &msg);
        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "[s1ap_ueContextModificationFailure] "
                    "Build failure");
            break;
        }
        else
        {
            /* Generating Protocol Event LOCAL_UE_CONTEXT_MODIFICATION_FAILURE*/
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);
            /* SPR 17213 Fix Start */
     rrc_asn1PrtToStr_S1AP_PDU(
                  RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);

            /*Coverity 87960 Fix Start*/
            if(PNULL != p_ue_context)
            {
                p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                        encoded_msg_len);
                /*Klockwork fix*/
                /*SPR_17041_START*/
                if(PNULL != p_event_header)
                    /*SPR_17041_END*/
                    /*Klockwork fix*/
                {
                    /* SES-508 Fix Start */
                    /* Code Removed */
                    /* SES-508 Fix End */
                    rrc_uecc_fill_protocol_event_params(p_ue_context,
                            p_event_header,
                            (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                            LOCAL_UE_CONTEXT_MODIFICATION_FAILURE,
                            MESSAGE_DIRECTION_SEND);

                    l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                                sizeof(EVENT_EXTERNAL_HEADER)),
                            (const void*)p_sig_msg_req->message_buff_p,
                            encoded_msg_len);

                    rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
                    /* SPR 17520 Fix Start */
                    p_event_header = PNULL;
                    /* SPR 17520 Fix Stop */
                }
            }
            /*Coverity 87960 Fix End*/
            
            /* Generating Protocol Event LOCAL_UE_CTXT_MOD_FAIL*/
            /*Coverity 87894 Fix Start*/
            if(PNULL != p_ue_context)
            {
                p_ue_ctx_mod_fail = rrc_mem_get(sizeof(LOCAL_UE_CTXT_MOD_FAIL_STRUCT));
                /*Klockwork fix*/
                /*SPR_17041_START*/
                if(PNULL != p_ue_ctx_mod_fail)
                    /*SPR_17041_END*/
                    /*Klockwork fix*/
                {
                    /* SES-508 Fix Start */
                    /* Code Removed */
                    /* SES-508 Fix End */
                    p_ue_ctx_mod_fail->header.length = sizeof(LOCAL_UE_CTXT_MOD_FAIL_STRUCT);
                    p_ue_ctx_mod_fail->header.event_id = LOCAL_UE_CTXT_MOD_FAIL;

                    if ((PNULL != p_ue_context->p_gb_context) && (PNULL != 
                                p_ue_context->p_gb_context->p_p_csc_context) && (PNULL !=
                                    p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index])
                            && (PNULL != p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                                p_csc_init_setup_ind))
                    {
                        /*Klockwork fix*/
                        l3_memcpy_wrapper(&p_ue_ctx_mod_fail->header.EVENT_PARAM_CELL_ID, 
                                p_ue_context->p_gb_context->
                                p_p_csc_context[p_ue_context->cell_index]->
                                p_csc_init_setup_ind->sib_type_1_Info.
                                cell_access_related_info.cell_Id, sizeof(U32));
                    }
                    p_ue_ctx_mod_fail->header.EVENT_PARAM_EUTRANCELL_FROID = 
                        p_ue_ctx_mod_fail->header.EVENT_PARAM_CELL_ID;

                    if (p_ue_context->m.mme_ue_id_present)
                    {
                        p_ue_ctx_mod_fail->header.EVENT_PARAM_MMES1APID = p_ue_context->mme_ue_id;
                    }

                    p_ue_ctx_mod_fail->header.EVENT_PARAM_RAC_UE_REF = p_ue_context->s1ap_ue_id;
                    p_ue_ctx_mod_fail->EVENT_PARAM_3GPP_CAUSE_GROUP = (U32)msg.cause.t;

                    switch(p_ue_ctx_mod_fail->EVENT_PARAM_3GPP_CAUSE_GROUP)
                    { 
                        case T_s1ap_Cause_radioNetwork: 
                        p_ue_ctx_mod_fail->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.radioNetwork;
                        break;

                        case T_s1ap_Cause_transport: 
                        p_ue_ctx_mod_fail->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.transport;
                        break;

                        case T_s1ap_Cause_nas: 
                        p_ue_ctx_mod_fail->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.nas;
                        break; 

                        case T_s1ap_Cause_protocol:
                        p_ue_ctx_mod_fail->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.protocol;
                        break; 

                        case T_s1ap_Cause_misc:
                        p_ue_ctx_mod_fail->EVENT_PARAM_3GPP_CAUSE = msg.cause.u.misc;
                        break; 
                    }

                    rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_ue_ctx_mod_fail);

                    /* SPR 17520 Fix Start */
                    p_ue_ctx_mod_fail = PNULL;
                    /* SPR 17520 Fix Stop */
                }
            }
            /*Coverity 87894 Fix End*/
        }
        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_UEContextModification;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        
        if (PNULL != p_ue_context)
        {
            /* coverity_fix_62465_start */
            /*BUG 604 changes start*/
            /*Fill ue_index*/
            p_sig_msg_req->ue_index = p_ue_context->ue_index;
            /*BUG 604 changes stop*/
            /* coverity_fix_62465_stop */
            p_sig_msg_req->cell_index = p_ue_context->cell_index;

        /*SPR 15896 Fix Start*/
            rrc_trace_max_file_write(p_ue_context,UE_CONTEXT_MOD_FAIL,p_sig_msg_req->message_buff_size,
                    p_sig_msg_req->message_buff_p, S1);
        /*SPR 15896 Fix Stop*/
        }

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                    p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO,"S1AP_MSG: UEContextModificationFailure %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));

    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    /* Coverity Fix 87960_87894 Code Delted */

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return result;
}


/* Start E-RAB Modify */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_erab_modify_request
 *
 *   INPUTS       : S1AP_PDU            *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  U8                  mme_id
 *                  U8                  *p_buff
 *                  U16                 buff_size
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes ASN1V_s1ap_id_E_RABModify Request
 *
 *   RETURNS:
 *       None
 ******************************************************************************/
void uecc_s1ap_process_erab_modify_request
(
 S1AP_PDU            *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
 U8                  mme_id,
 U8                  *p_buff,        /* ASN.1 encoded message */
/*BUG 604 changes start*/ 
 U16                 buff_size,      /* encoded buf size - just for check*/
 U16                 ue_index
/*BUG 604 changes stop*/ 
 )
{
    uecc_ue_context_t               *p_ue_context;
    OSRTDListNode  *p_node_msg = PNULL;
    s1ap_E_RABToBeModifiedListBearerModReq_element* p_erab_elem = PNULL;
    rrc_s1ap_erab_modify_request_t msg;

    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER           *p_event_header = PNULL;
    U32                             encoded_msglen = 0;

    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_s1ap_pdu);
    RRC_ASSERT(PNULL != p_s1ap_pdu->u.initiatingMessage);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    p_ue_context     = PNULL;
    memset_wrapper(&msg, 0, sizeof(rrc_s1ap_erab_modify_request_t));

    do
    {
        if (PNULL == p_s1ap_pdu->u.initiatingMessage->value.u.e_RABModify)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_E_RABModifyRequest] E_RABModify field is PNULL");
            break;
        }

        /* Decode message */
        if( RRC_FAILURE == rrc_s1ap_erab_modify_request_intrl_dec(
                    p_uecc_gb_context,
                    mme_id,
                    p_s1ap_pdu->u.initiatingMessage->value.u.e_RABModify,
                    &msg
                    ))
        {

            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, " ERAB Modify Request"
                    "Decoding Failure, Sending Error Indication");
            break;
        }


        /* Process message */
/*BUG 604 changes start*/ 
        /* Get context using ue_index */
        /*p_ue_context = uecc_ue_ctx_get_by_s1ap_id(p_uecc_gb_context,
                msg.enb_ue_s1ap_id);*/
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,ue_index);
/*BUG 604 changes stop*/ 

        if (PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_E_RABModifyRequest] UE context not found");

            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"[s1ap_E_RABModifyRequest]"
                    "message dropped -"
                    "UECC isn't initialized by CSC ");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }
        if (0 != p_ue_context->m.mme_ue_id_present)
        {
            if (msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[s1ap_E_RABModifyRequest] "
                        "mme_ue_s1ap_id (%i) != p_ue_context->mme_ue_id (%i)",
                        msg.mme_ue_s1ap_id,
                        p_ue_context->mme_ue_id);

                break;
            }
        }
        else
        {
            /* store mme_ue_s1ap_id in UE context */
            p_ue_context->m.mme_ue_id_present = 1;
            p_ue_context->mme_ue_id = msg.mme_ue_s1ap_id;
        }
        
        if (PNULL != p_ue_context)
        {
            /*Generating Protocol Events */
            /* SPR 22634 Fix - Starts */
            encoded_msglen = (U32)(buff_size);
            /* SPR 22634 Fix - Ends */
            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msglen);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msglen),
                        LOCAL_S1_ERAB_MODIFY_REQUEST,
                        MESSAGE_DIRECTION_RECEIVED);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_buff,
                        encoded_msglen);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        /* Is trace activated */
    /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated)
        {
            /*SPR 15875 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_MME, "\n<msg function=\"S1AP\" name=\"E-RAB Modify Request\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_CELL, "\n<msg function=\"S1AP\" name=\"E-RAB Modify Request\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
            /*SPR 15875 Fix Stop*/
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),S1,"\n <initiator type=\"MME\">%s</initiator>",
                        p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
            /* ASN.1 encoded message to logged */
            rrc_trace_max_file_write(p_ue_context, ERAB_MODIFY_REQ , buff_size, p_buff, S1);

                for (p_node_msg = msg.e_rab_to_be_modified_list.head; PNULL!=p_node_msg;
                        p_node_msg=p_node_msg->next)
                {
                    p_erab_elem=(s1ap_E_RABToBeModifiedListBearerModReq_element*)p_node_msg->data;
                    if ( (p_erab_elem == PNULL) || (p_erab_elem->value.u._E_RABToBeModifiedItemBearerModReqIEs_1 == PNULL))
                    {
                        continue;
                    }

                    /* QOS PARAMETER */
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ieGroup name=\"Erab-Id Qos Paramter\" value=\"%d\">", p_erab_elem->value.u._E_RABToBeModifiedItemBearerModReqIEs_1->e_RAB_ID);

                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"QCI\">%d</ie>",p_erab_elem->value.u._E_RABToBeModifiedItemBearerModReqIEs_1->e_RABLevelQoSParameters.qCI) ;
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1, "\n <ie name=\"Allocation Retenion-Priority Level\">%d</ie>",p_erab_elem->value.u._E_RABToBeModifiedItemBearerModReqIEs_1->e_RABLevelQoSParameters.allocationRetentionPriority.priorityLevel);
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"Allocation Retenion-Premeption Capability\">%d</ie>",
                            p_erab_elem->value.u._E_RABToBeModifiedItemBearerModReqIEs_1->e_RABLevelQoSParameters.allocationRetentionPriority.pre_emptionCapability);
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"Allocation Retenion-Premeption Venerability\">%d</ie>",
                            p_erab_elem->value.u._E_RABToBeModifiedItemBearerModReqIEs_1->e_RABLevelQoSParameters.allocationRetentionPriority.pre_emptionVulnerability);
                if((p_erab_elem->value.u._E_RABToBeModifiedItemBearerModReqIEs_1->e_RABLevelQoSParameters.qCI >0) && (p_erab_elem->value.u._E_RABToBeModifiedItemBearerModReqIEs_1->e_RABLevelQoSParameters.qCI <5))
            {
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"GBR_QosInformation-Max Bitrate DL\">%u</ie>",
                            p_erab_elem->value.u._E_RABToBeModifiedItemBearerModReqIEs_1->e_RABLevelQoSParameters.gbrQosInformation.e_RAB_MaximumBitrateDL);
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"GBR_QosInformation-Max Bitrate UL\">%u</ie>",
                            p_erab_elem->value.u._E_RABToBeModifiedItemBearerModReqIEs_1->e_RABLevelQoSParameters.gbrQosInformation.e_RAB_MaximumBitrateUL);                            
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"GBR_QosInformation-Guranteed Bitrate DL\">%u</ie>",
                            p_erab_elem->value.u._E_RABToBeModifiedItemBearerModReqIEs_1->e_RABLevelQoSParameters.gbrQosInformation.e_RAB_GuaranteedBitrateDL);
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"GBR_QosInformation-Guranteed Bitrate UL\">%u</ie>",
                            p_erab_elem->value.u._E_RABToBeModifiedItemBearerModReqIEs_1->e_RABLevelQoSParameters.gbrQosInformation.e_RAB_GuaranteedBitrateUL);
            }

                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n </ieGroup> ");  
                }

                P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),S1,"\n </msg> ");  
            /*SPR 15896 Fix Stop*/

        }
        /* 
         ** Call UECC_EV_S1AP_ERAB_MODIFY_REQ event handler 
         ** and pass API data to FSM. 
         */
        uecc_fsm_process_event(p_ue_context,
                UECC_EV_S1AP_ERAB_MODIFY_REQ,
                &msg);
    } while (0);


    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_E_RABModifyListBearerModRes
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  OSCTXT *p_asn1_ctx
 *                  s1ap_E_RABModifyListBearerModRes *p_e_rab_modify_list
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds s1ap_E_RABModifyListBearerModRes
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_E_RABModifyListBearerModRes(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        s1ap_E_RABModifyListBearerModRes *p_e_rab_modify_list
        )
{
    OSRTDListNode* p_node = PNULL;
    s1ap_E_RABModifyListBearerModRes_element *p_elem = PNULL;
    U8 e_rab_index = RRC_NULL;
    U16 erab_count  = RRC_NULL;
    U8 counter = 0;


    RRC_ASSERT(PNULL!=p_ue_context);
    RRC_ASSERT(PNULL!=p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL!=p_asn1_ctx);
    RRC_ASSERT(PNULL!=p_e_rab_modify_list);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    asn1Init_s1ap_E_RABModifyListBearerModRes(p_e_rab_modify_list);
    /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated)
    {
        /*coverity_87839_fix_start*/
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ieGroup name=\"E-RAB Modify List\">");
        /*coverity_87839_fix_end*/
    }
    /*SPR 15896 Fix Stop*/

    if(PNULL !=  p_ue_context->p_curr_proc_data)
    {
        erab_count = 
            p_ue_context->p_curr_proc_data->u.erab_modify_request_data.
            erab_modify_list.erab_modify_list_counter;
    }

    if (erab_count != RRC_NULL)
    {
        /*This allocation should be made inside of loop for multi-DRB*/
        for (e_rab_index = 0;e_rab_index < MAX_ERAB_COUNT;e_rab_index++)
        {
            if ((PNULL != p_ue_context->p_curr_proc_data) && 
                    (p_ue_context->p_curr_proc_data->u.erab_modify_request_data.
                     erab_modify_list.erab_modify_item[e_rab_index].status 
                     == RRC_SUCCESS))
            {        
                rtxDListAllocNodeAndData(p_asn1_ctx,
                        s1ap_E_RABModifyListBearerModRes_element,
                        &p_node,
                        &p_elem);

                if (PNULL==p_node)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,"Can't allocate p_node");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
                asn1Init_s1ap_E_RABModifyListBearerModRes_element(p_elem);
                p_elem->value.u._E_RABModifyItemBearerModResIEs_1 =
                    (s1ap_E_RABModifyItemBearerModRes*)rtxMemAlloc(p_asn1_ctx,
                            sizeof(s1ap_E_RABModifyItemBearerModRes));

                if (PNULL==p_elem->value.u._E_RABModifyItemBearerModResIEs_1)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR, "ASN malloc failed.");
                    return RRC_FAILURE;
                }
                asn1Init_s1ap_E_RABModifyItemBearerModRes(p_elem->value.u._E_RABModifyItemBearerModResIEs_1);
                p_elem->value.t = T38__E_RABModifyItemBearerModResIEs_1;

                p_elem->id = ASN1V_s1ap_id_E_RABModifyItemBearerModRes;
                p_elem->criticality = s1ap_ignore;

                p_elem->value.u._E_RABModifyItemBearerModResIEs_1->e_RAB_ID = 
                    p_ue_context->p_curr_proc_data->u.erab_modify_request_data.
                    erab_modify_list.erab_modify_item[e_rab_index].drb_config.erab_id;
                /*SPR 15896 Fix Start*/
                if (p_ue_context->m.traceActivated  )
                {
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n<ie name=\"E-RABID\">%d</ie>",p_elem->value.u._E_RABModifyItemBearerModResIEs_1->e_RAB_ID);
                }
                /*SPR 15896 Fix Stop*/
                if ( PNULL != g_rrc_stats.p_rrc_stats)
                {
                    for (counter = 0; counter < MAX_ERAB_COUNT; counter++)
                    {
                        /* SPR 13467 Fix Start */
                        if ((PNULL != p_ue_context->p_curr_proc_data) && 
                                (p_ue_context->p_curr_proc_data->u.erab_modify_request_data.
                                 erab_to_be_modified_list.erab_to_be_modified_item[counter].e_RAB_ID == 
                                 p_ue_context->p_curr_proc_data->u.erab_modify_request_data.
                                 erab_modify_list.erab_modify_item[e_rab_index].drb_config.erab_id))
                        {
                            /* SPR 21309 Fix Start */
                            /* SPR 13441 Fix Start */
                            if ( (PNULL !=p_ue_context->p_e_rab_list[counter]) && 
                                    (RRC_MIN_QCI_GBR_LIMIT <= p_ue_context->p_e_rab_list[counter]->
                                     e_RABlevelQoSParameters.qCI) &&
                                    (RRC_MAX_QCI_NON_GBR_LIMIT >= p_ue_context->
                                     p_e_rab_list[counter]->e_RABlevelQoSParameters.qCI) )
                                /* SPR 21309 Fix End */
                            { 
                                /* Update the ERAB Modification Success*/
                                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                                        g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                                        rrc_uecc_instance_stats[p_ue_context->
                                        p_gb_context->offset_uecc_mod_id].
                                        rrc_uecc_cell_stats[p_ue_context->cell_index].
                                        rrc_erab_related_stats.erab_mod_stats.
                                        erab_modQosSuccNbr_qci[RRC_UPDATED_QCI_INDEX
                                        (p_ue_context->p_curr_proc_data->u.erab_modify_request_data.
                                         erab_to_be_modified_list.erab_to_be_modified_item[counter].
                                         e_RABlevelQoSParameters.qCI)],
                                        RRC_UPDATED_QCI_INDEX( p_ue_context->p_curr_proc_data->u.
                                            erab_modify_request_data.erab_to_be_modified_list.
                                            erab_to_be_modified_item[counter].
                                            e_RABlevelQoSParameters.qCI),
                                        RRC_MAX_QCI_INDEX);

                                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                                        g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                                        rrc_uecc_instance_stats[p_ue_context->
                                        p_gb_context->offset_uecc_mod_id].
                                        rrc_uecc_cell_stats[p_ue_context->cell_index].
                                        rrc_erab_related_stats.erab_mod_stats.
                                        erab_modQosSuccNbr_sum, 
                                        RRC_UPDATED_QCI_INDEX(p_ue_context->p_curr_proc_data->u.
                                            erab_modify_request_data.erab_to_be_modified_list.
                                            erab_to_be_modified_item[counter]. 
                                            e_RABlevelQoSParameters.qCI),RRC_MAX_QCI_INDEX);
                            }
                            /* SPR 13467 Fix Stop */ 
                            /* SPR 13441 Fix End */
                        }
                    }
                }

                /* Criticality Diagnostics : Please fill it!!*/
                rtxDListAppendNode(p_e_rab_modify_list,p_node);
            }
            else
            {
                continue;
            }
        }
    }
    /*SPR 15896 Fix Start*/
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    if (p_ue_context->m.traceActivated )
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n </ieGroup> ");
    }
    /*SPR 15896 Fix Stop*/
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_erab_modify_response
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  U32                            mme_ue_s1ap_id
 *                  U32                            enb_ue_s1ap_id
 *                  s1ap_CriticalityDiagnostics    *p_criticality_diagnostics
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends E-RAB Modify response message
 *       to S1AP
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_erab_modify_response(
        uecc_ue_context_t* p_ue_context)
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_erab_modify_response_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;

    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/

    RRC_ASSERT (PNULL != p_ue_context);
    RRC_ASSERT (PNULL != p_ue_context->p_gb_context);


    if(p_ue_context->m.traceActivated) 
    {
        /*SPR 15875 Fix Start*/
        /*SPR 15896 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_MME,"\n<msg function=\"S1AP\" name=\"E-RAB MODIFY RESPONSE\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_CELL,"\n<msg function=\"S1AP\" name=\"E-RAB MODIFY RESPONSE\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        /*SPR 15875 Fix Stop*/
        P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
                    p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
        /*SPR 15896 Fix Stop*/
    }

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_E_RABModifyResponse]"
                "   ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */
        msg.bitmask = 0;

        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

/*SPR 18758 5Sep Fix Start*/
    if (PNULL == p_ue_context->p_failed_curr_proc_data)
    {
        if (RRC_SUCCESS!=uecc_s1ap_build_E_RABModifyListBearerModRes
                (p_ue_context, &asn1_ctx,&msg.e_rab_modified_list))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_E_RABModifyResponse]"
                    "uecc_s1ap_build_E_RABModifyListBearerModRes failure");
            break;
        }

        if(msg.e_rab_modified_list.count > 0)
        {
            msg.bitmask |=
                RRC_S1AP_ERAB_MODIFY_RESPONSE_TO_BE_MODIFIED_LIST_PRESENT;
        }
    }
/*SPR 18758 5Sep Fix Stop*/

        if (RRC_SUCCESS!=uecc_s1ap_build_e_rab_failed_to_modify_list(
                    p_ue_context,&asn1_ctx,&msg.e_rab_failed_to_modify_list))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_E_RABModifyResponse]"
                    "uecc_s1ap_build_e_rab_failed_to_modify_list failure");
            break;
        }
        if(msg.e_rab_failed_to_modify_list.count > 0)
        {
            msg.bitmask |=
                RRC_S1AP_ERAB_MODIFY_RESPONSE_E_RAB_FAILED_TO_MODIFY_LIST_PRESENT;
        }

        /* Encode message */
        result=rrc_s1ap_erb_modify_response_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                &msg);
        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_E_RABModifyResponse] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);
           rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                                 encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_ERAB_MODIFY_RESPONSE,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }

        }
        if (p_ue_context->m.traceActivated )
                
        {
            /* ASN.1 encoded message to logged */
        /*SPR 15896 Fix Start*/
            rrc_trace_max_file_write(p_ue_context, ERAB_MODIFY_RESP, 
                    p_sig_msg_req->message_buff_size , &p_sig_msg_req->message_buff_p[0], S1);
        /*SPR 15896 Fix Stop*/
        }
        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_E_RABModify;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                    p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,"S1AP_MSG: E-RABModifyResponse:%s", 
                change_data_to_str(p_sig_msg_req->message_buff_size, &p_sig_msg_req->message_buff_p[0]));

    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_e_rab_failed_to_modify_list
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  OSCTXT *p_asn1_ctx
 *                  s1ap_E_RABList *p_list
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds e_rab_failed_to_setup_list
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_e_rab_failed_to_modify_list(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        s1ap_E_RABList *p_list
        )
{
    /* Multi E-ERAB supporting is for future release */

    OSRTDListNode* p_node = PNULL;
    s1ap_E_RABList_element *p_elem = PNULL;
    U8 e_rab_index = 0;
    erab_failed_to_modify_list_t *p_failed_list = PNULL;
    /* SPR_20915 - Fix - Starts */
    U8 fail_list_count = 0;
    /* SPR_20915 - Fix - Ends */

    RRC_ASSERT(PNULL!=p_ue_context);
    RRC_ASSERT(PNULL!=p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL!=p_asn1_ctx);
    RRC_ASSERT(PNULL!=p_list);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /*SPR 18758 Fix Start*/
    if (PNULL != p_ue_context->p_failed_curr_proc_data)
    {
        p_failed_list = &(p_ue_context->p_failed_curr_proc_data->u.
            erab_modify_request_data.erab_failed_to_modify_list);
    }
    /* SPR_20915 - Fix - Starts */
    else if (PNULL != p_ue_context->p_curr_proc_data)
    /* SPR_20915 - Fix - Ends */
    {
        p_failed_list = &(p_ue_context->p_curr_proc_data->u.
            erab_modify_request_data.erab_failed_to_modify_list);
    }
    /*SPR 18758 Fix Stop*/

    /* SPR_20915 - Fix - Starts */
    if ((PNULL != p_failed_list) &&
        (MAX_ERAB_COUNT >= p_failed_list->erab_failed_to_modify_list_counter))
    {
        fail_list_count = p_failed_list->erab_failed_to_modify_list_counter;
    }

    /*SPR 5532 Fix Start */
    /*SPR 15896 Fix Start */
    if (fail_list_count != 0 && p_ue_context->m.traceActivated)
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ieGroup name=\"E-RAB Failed To Modify List\">");
    }
    /*SPR 15896 Fix Stop */
    /*SPR 5532 Fix End */

    asn1Init_s1ap_E_RABList(p_list);
    for (e_rab_index=0;
            e_rab_index < fail_list_count;
            e_rab_index++)
    /* SPR_20915 - Fix - Ends */
    {
        rtxDListAllocNodeAndData(p_asn1_ctx,
                s1ap_E_RABList_element,
                &p_node,
                &p_elem);
        if (PNULL==p_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate p_node");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        asn1Init_s1ap_E_RABList_element(p_elem);
        p_elem->value.u._E_RABItemIEs_1 =
            (s1ap_E_RABItem*)rtxMemAlloc(p_asn1_ctx,
                    sizeof(s1ap_E_RABItem));

        if (PNULL==p_elem->value.u._E_RABItemIEs_1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "ASN malloc failed.");
            return RRC_FAILURE;
        }
        asn1Init_s1ap_E_RABItem(p_elem->value.u._E_RABItemIEs_1);
        /* SPR 21660 changes start */
        p_elem->value.t = T180__E_RABItemIEs_1; //T173__E_RABItemIEs_1
        /* SPR 21660 changes end */

        p_elem->id = ASN1V_s1ap_id_E_RABItem;
        /* SPR 12806 Fix Start */
        p_elem->criticality = s1ap_ignore;
        /* SPR 12806 Fix Stop */

        p_elem->value.u._E_RABItemIEs_1->e_RAB_ID = 
            p_failed_list->erab_failed_to_modify_item[e_rab_index].e_RAB_ID;

        /*SPR 15896 Fix Start */
        if (p_ue_context->m.traceActivated)
        {
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"E-RABID\">%d</ie> ",p_elem->value.u._E_RABItemIEs_1->e_RAB_ID);
        }
        /*SPR 15896 Fix Stop */

        p_elem->value.u._E_RABItemIEs_1->cause.t = 
            p_failed_list->erab_failed_to_modify_item[e_rab_index].cause.t;
        p_elem->value.u._E_RABItemIEs_1->cause.u.radioNetwork = 
            p_failed_list->erab_failed_to_modify_item[e_rab_index].cause.u.
            radioNetwork;
        if ( PNULL != g_rrc_stats.p_rrc_stats)
        {
            /* Update the Erab Modification Failed List */
            RRC_UPDATE_PERFORMANCE_COUNTER_S1AP_CAUSE(p_ue_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                    p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                    erab_mod_stats.erab_mod_fail_cause_stats.erab_modQosFailNbr_cause,
                    p_elem->value.u._E_RABItemIEs_1->cause);

            RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                    g_rrc_stats.p_rrc_stats->
                    rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                    p_gb_context->offset_uecc_mod_id].
                    rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                    erab_mod_stats.erab_modQosFailNbr_sum, 0, DUMMY_RANGE_CHECK_INDEX);
        }
        rtxDListAppendNode(p_list,p_node);
    }
    /* SPR_20915 - Fix - Starts */
    /*SPR 5532 Fix Start */
    /*SPR 15896 Fix Start */
    if (fail_list_count != 0 && p_ue_context->m.traceActivated)
    /* SPR_20915 - Fix - Ends */
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n </ieGroup>");
    }

    if (p_ue_context->m.traceActivated )
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n </msg>");
    }
    /*SPR 15896 Fix Stop */
    /*SPR 5532 Fix  End */
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return RRC_SUCCESS;
}
/* End E-RAB Modify */

/******************************************************************************
 *   FUNCTION NAME: update_performance_counter_erab_release_stats_relAtt
 *
 *   DESCRIPTION:
 *       This function update performance counter erab_release_stats
 *
 *   RETURNS: None
 *
 *******************************************************************************/
static void update_performance_counter_erab_release_stats_relAtt(
        uecc_ue_context_t*              p_ue_context,
        s1ap_E_RABList_element *p_erab_elem,
        U8 counter)
{
    U8 qci_value = 0;
    if ( (p_erab_elem == PNULL) || (p_erab_elem->value.u._E_RABItemIEs_1 == PNULL))
    {
        return;
    }
    if ((PNULL != p_ue_context->p_e_rab_list[counter]) && 
            (p_erab_elem->value.u._E_RABItemIEs_1->e_RAB_ID == 
             p_ue_context->p_e_rab_list[counter]->e_RAB_ID))
    {
        /* update the performance counter */
        qci_value = p_ue_context->p_e_rab_list[counter]->
            e_RABlevelQoSParameters.qCI;

        /* SPR 13441 Fix Start */
        if ( (RRC_MIN_QCI_GBR_LIMIT <= qci_value) &&
                (RRC_MAX_QCI_NON_GBR_LIMIT >= qci_value) )
        { 
        RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                g_rrc_stats.p_rrc_stats->
                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                p_gb_context->offset_uecc_mod_id].
                rrc_uecc_cell_stats[p_ue_context->cell_index].
                rrc_erab_related_stats.erab_release_stats.
                erab_relAttNbr_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
                RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

        RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                g_rrc_stats.p_rrc_stats->
                rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                p_gb_context->offset_uecc_mod_id].
                rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                erab_release_stats.erab_relAttNbr_sum, 
                RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);
        }
        /* SPR 13441 Fix End */
    }
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_erb_release_command_update_performance_counter
 *
 *   DESCRIPTION:
 *       This function update performance counter in
 *       uecc_s1ap_process_erb_release_command
 *
 *   RETURNS: None
 *
 *******************************************************************************/
static void uecc_s1ap_erb_release_command_update_performance_counter(
        uecc_ue_context_t*              p_ue_context,
        rrc_s1ap_erab_release_command_t msg)
{
    OSRTDListNode* p_node_msg = PNULL;
    s1ap_E_RABList_element *p_erab_elem = PNULL;
    U8 counter = 0;

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    if ((PNULL != p_ue_context->p_gb_context) && (PNULL != g_rrc_stats.p_rrc_stats))
    {
        for (p_node_msg = msg.e_rab_to_be_released_list.head; 
                PNULL!=p_node_msg;
                p_node_msg=p_node_msg->next)
        {        
            for (counter = 0; counter < MAX_ERAB_COUNT; counter++)
            {
                p_erab_elem = (s1ap_E_RABList_element*)p_node_msg->data;
                update_performance_counter_erab_release_stats_relAtt(
                        p_ue_context, p_erab_elem, counter);
            }
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_erb_release_command_trace_handler
 *
 *   DESCRIPTION:
 *       This function handles TraceActivation in
 *       uecc_s1ap_process_erb_release_command
 *
 *   RETURNS: None
 *
 *******************************************************************************/
static void uecc_s1ap_erb_release_command_trace_handler(
        uecc_ue_context_t*  p_ue_context,
        U16                 buff_size,
        U8                  *p_buff,
        rrc_s1ap_erab_release_command_t msg)
{
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    OSRTDListNode* p_node_msg = PNULL;
    s1ap_E_RABList_element *p_erab_elem = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    /* Is trace activated */
    if (p_ue_context->m.traceActivated) 
    {
        /*SPR 15875 Fix Start*/
    /*SPR 15896 Fix Start */
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_MME,"\n<msg function=\"S1AP\" name=\"E-RAB RELEASE COMMAND\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_CELL,"\n<msg function=\"S1AP\" name=\"E-RAB RELEASE COMMAND\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        /*SPR 15875 Fix Stop*/
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), S1,"\n <initiator type=\"MME\">%s</initiator>",
                        p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);

            for (p_node_msg = msg.e_rab_to_be_released_list.head; PNULL!=p_node_msg;
                    p_node_msg=p_node_msg->next)
            {
                p_erab_elem = (s1ap_E_RABList_element*)p_node_msg->data;
                if ( (p_erab_elem == PNULL) || (p_erab_elem->value.u._E_RABItemIEs_1 == PNULL))
                {
                    continue;
                }
                P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"E-RABID\">%d</ie>",p_erab_elem->value.u._E_RABItemIEs_1->e_RAB_ID);
            }
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n </msg>" );

        /* ASN.1 encoded message to logged */
        rrc_trace_max_file_write(p_ue_context, ERAB_RELEASE_COMMAND, buff_size, p_buff, S1);
        /*SPR 15896 Fix Stop */
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/* ERB RELEASE COMMAND START */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_erb_release_command 
 *
 *   INPUTS       : S1AP_PDU*            p_s1ap_pdu
 *                  uecc_gb_context_t*   p_uecc_gb_context
 *                  U8                  mme_id
 *                  U8                  *p_buff
 *                  U16                 buff_size
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes s1ap_ERB_RELEASE COMMAND
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_erb_release_command
(
 S1AP_PDU*            p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t*   p_uecc_gb_context, /* UECC global context */
 U8                  mme_id,
 U8                  *p_buff,        /* ASN.1 encoded message */
/*BUG 604 changes start*/ 
 U16                 buff_size,      /* encoded buf size - just for check*/
 U16                 ue_index
/*BUG 604 changes stop*/ 
 )
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_s1ap_erab_release_command_t msg;
    rrc_s1ap_error_indication_t error_indication;
    uecc_s1ap_error_ind_bool_t        send_err_ind;
    rrc_bool_et list_populated = RRC_FALSE;
    OSCTXT asn1_ctx;
    EVENT_EXTERNAL_HEADER           *p_event_header = PNULL;
    U32                             encoded_msglen = 0;

    RRC_ASSERT(PNULL != p_s1ap_pdu);
    RRC_ASSERT(PNULL != p_s1ap_pdu->u.initiatingMessage);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    memset_wrapper(&msg, 0, sizeof(rrc_s1ap_erab_release_command_t));

    memset_wrapper(&error_indication, RRC_NULL,
            sizeof(rrc_s1ap_error_indication_t));
    memset_wrapper(&send_err_ind, RRC_NULL, sizeof(uecc_s1ap_error_ind_bool_t));

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "[s1ap_ErrorIndication] ASN context initialization failed");
        return;
    }

    do
    {
        if (PNULL == p_s1ap_pdu->u.initiatingMessage->value.u.e_RABRelease)

        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_E_RABReleaseCommand] e_RABRelease field is PNULL");
            break;
        }

        /* Decode message */
        if (RRC_FAILURE == rrc_s1ap_erb_release_command_intrl_dec(
                    &asn1_ctx,
                    mme_id,
                    p_s1ap_pdu->u.initiatingMessage->value.u.e_RABRelease,
                    &msg,
                    &error_indication,
                    &send_err_ind,
                    &list_populated,
                    p_uecc_gb_context))
        {
            /* Message parsing error */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_E_RABReleaseCommand] Parsing error");
            /*SPR_18125_START*/
            rtFreeContext(&asn1_ctx);
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            /*SPR_18125_END*/
            return;
        }

        /* Process message */
/*BUG 604 changes start*/ 
        /* Get context using S1AP id */
        /*p_ue_context = uecc_ue_ctx_get_by_s1ap_id(p_uecc_gb_context,
                msg.enb_ue_s1ap_id);*/
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
                ue_index);
/*BUG 604 changes stop*/ 

        if (PNULL == p_ue_context)
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_E_RABReleaseCommand] UE context not found");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"[s1ap_E_RABReleaseCommand]"
                    "message dropped -"
                    "UECC isn't initialized by CSC ");
            /*SPR_18125_START*/
            rtFreeContext(&asn1_ctx);
            /*SPR_18125_END*/
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }
        
        if (0 != p_ue_context->m.mme_ue_id_present)
        {
            if (msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[s1ap_E_RABReleaseCommand] "
                        "mme_ue_s1ap_id (%i) != p_ue_context->mme_ue_id (%i)",
                        msg.mme_ue_s1ap_id,
                        p_ue_context->mme_ue_id);
                break;
            }

            /*Generating Protocol Events */
            /* SPR 22634 Fix - Starts */
            encoded_msglen = (U32)(buff_size);
            /* SPR 22634 Fix - Ends */
            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msglen);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msglen),
                        LOCAL_S1_ERAB_RELEASE_COMMAND,
                        MESSAGE_DIRECTION_RECEIVED);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_buff,
                        encoded_msglen);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        if (RRC_FALSE == list_populated)
        {
            break;
        }

        uecc_s1ap_erb_release_command_trace_handler(
                        p_ue_context, buff_size, p_buff, msg);

        uecc_s1ap_erb_release_command_update_performance_counter(
                        p_ue_context, msg);

        /* Call UECC_EV_S1AP_ERAB_RELEASE_COMMAND event handler *
         * and pass API data to FSM. */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_S1AP_ERAB_RELEASE_COMMAND,
                &msg);

    } while (0);

    if ((PNULL != p_ue_context) &&
        (error_indication.criticality_diagnostics.m.iEsCriticalityDiagnosticsPresent))
    {
        /* Stop the timer in case we are sending ERROR Indication 
         * in the response message, this is due to the fact the error 
         * indication is not triggered from the FSM, its only while
         * parsing the message*/
        uecc_ue_timer_stop(
                p_uecc_gb_context, 
                UECC_ERAB_RELEASE_CMD_GUARD_TIMER, 
                &p_ue_context->timers_data);

        /* Send failure response to MME */
        if(RRC_SUCCESS !=
                uecc_s1ap_build_and_send_e_rab_release_response(
                    p_ue_context,
                    msg.mme_ue_s1ap_id,
                    msg.enb_ue_s1ap_id,
                    &error_indication.criticality_diagnostics,
                    list_populated))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "[s1ap_ErabSetupResp] delivery failure");
        }          
    }
    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_cell_traffic_trace
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends rrc_s1ap_cell_traffic_trace_t message
 *       to S1AP
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_cell_traffic_trace(
        uecc_ue_context_t              *p_ue_context)
{

    OSCTXT asn1_ctx;
    rrc_s1ap_cell_traffic_trace_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t* p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    rrc_return_et result = RRC_FAILURE;


    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                p_ue_context->cell_index))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_CellTrafficTrace]"
                "ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Reset message */
        memset_wrapper(&msg, RRC_NULL, sizeof(msg));
        memset_wrapper(sig_msg_req_buf, RRC_NULL,
                sizeof(s1ap_ue_associated_sig_msg_req_t));

        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

    /*SPR 15896 Fix Start */
        /* TRACE_fix */
        if (PNULL == p_ue_context->p_ue_cell_trace_activation_info)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING, "ue_trace_activation_info is null.");
            /*SPR_18125_START*/
            rtFreeContext(&asn1_ctx);
            /*SPR_18125_END*/
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /* TRACE_fix */
        /* Copy e_utran_trace_id */
        l3_memcpy_wrapper(&msg.e_utran_trace_id.data,
                &p_ue_context->p_ue_cell_trace_activation_info->trace_id_info
                .cell_eutran_trace_id.trace_reference,
                sizeof(p_ue_context->
                    p_ue_cell_trace_activation_info->trace_id_info.
                    cell_eutran_trace_id.trace_reference));
        //SPR 5782 change
        msg.e_utran_trace_id.data[6]=p_ue_context->p_ue_cell_trace_activation_info->
                trace_id_info.cell_eutran_trace_id.trace_recording_session_reference[0];
        msg.e_utran_trace_id.data[7]=p_ue_context->p_ue_cell_trace_activation_info->
                trace_id_info.cell_eutran_trace_id.trace_recording_session_reference[1];

        RRC_TRACE(RRC_INFO,"Eutran Trace ID is : %02x%02x%02x%02x%02x%02x%02x%02x ",
                msg.e_utran_trace_id.data[0], msg.e_utran_trace_id.data[1], msg.e_utran_trace_id.data[2], msg.e_utran_trace_id.data[3],
                msg.e_utran_trace_id.data[4], msg.e_utran_trace_id.data[5], msg.e_utran_trace_id.data[6], msg.e_utran_trace_id.data[7]);

        msg.e_utran_trace_id.numocts = EUTRAN_TRACE_ID;

        /* CELL_TRACE_FIX */
        p_ue_context->p_ue_cell_trace_activation_info->trace_id_info.
                    eutran_trace_id.numoctet = EUTRAN_TRACE_ID;
        l3_memcpy_wrapper(p_ue_context->p_ue_cell_trace_activation_info->
                        trace_id_info.eutran_trace_id.data,
                   msg.e_utran_trace_id.data, EUTRAN_TRACE_ID);
        /* CELL_TRACE_FIX */

        /* eutran_cgi.pLMNidentity*/
        uecc_s1ap_generate_plmn_identity_int(
                msg.e_utran_cgi.pLMNidentity.data,
                &p_ue_context->plmn_identity.plmn_identity);

        msg.e_utran_cgi.pLMNidentity.numocts =
            sizeof(msg.e_utran_cgi.pLMNidentity.data);

        if (PNULL != p_ue_context->p_gb_context->p_p_csc_context)
        {
            if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                    [p_ue_context->cell_index])
            {
                if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                        [p_ue_context->cell_index]->p_csc_init_setup_ind)
                {
                    /* eutran_cgi.cell_ID */
                    /* 28 bits */
                    RRC_ASSERT(sizeof(msg.e_utran_cgi.cell_ID.data) ==
                            sizeof(p_ue_context->p_gb_context->p_p_csc_context[
                                p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                                cell_access_related_info.cell_Id));

                    l3_memcpy_wrapper(msg.e_utran_cgi.cell_ID.data,
                            p_ue_context->p_gb_context->p_p_csc_context[
                            p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.

                            cell_access_related_info.cell_Id,
                            sizeof(msg.e_utran_cgi.cell_ID.data));
                }
            }
        }

        msg.e_utran_cgi.cell_ID.numbits = RRC_CELL_IDENTITY_BITS;

        /* trace collection entity IP address */
        msg.trace_collection_entity.data =
            p_ue_context->p_ue_cell_trace_activation_info->
            trace_collection_entity_info.data;

        /* numbits varify for IPV4 or IPV6 */
        msg.trace_collection_entity.numbits =
            (OSUINT32)((p_ue_context->p_ue_cell_trace_activation_info->
                        trace_collection_entity_info.length) * 8);
        /*SPR 15896 Fix Stop */

        /* Encode message */
        result = rrc_s1ap_cell_traffic_trace_intrl_enc(p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],
                &p_sig_msg_req->message_buff_size,
                &msg);

        if (RRC_SUCCESS != result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_CellTrafficTrace] Build failure");

            break;
        }

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_CellTrafficTrace;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, &p_sig_msg_req->message_buff_p[0], 
                        p_sig_msg_req->message_buff_size, "Cell Traffic Trace", 1);
        /* TRACE_changes_start */
        
        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                    p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}



/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_e_rab_release_response
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *                  U32                            mme_ue_s1ap_id
 *                  U32                            enb_ue_s1ap_id
 *                  s1ap_CriticalityDiagnostics    *p_criticality_diagnostic
 *                  rrc_bool_et                    list_populated
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends e_rab_release_response message
 *       to S1AP
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_e_rab_release_response(
        uecc_ue_context_t              *p_ue_context,
        U32                            mme_ue_s1ap_id,
        U32                            enb_ue_s1ap_id,
        s1ap_CriticalityDiagnostics    *p_criticality_diagnostics,
        rrc_bool_et                    list_populated
        ) 
{

    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;
    LOCAL_EVENT_S1_ERAB_RELEASE_RESPONSE_STRUCT
        *p_event_s1_erab_rel_resp = PNULL;
    U8 e_rab_index;
    OSCTXT asn1_ctx;
    rrc_s1ap_erab_release_response_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t* p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    rrc_return_et result = RRC_FAILURE;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/

    RRC_ASSERT(PNULL != p_ue_context);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* TRACE_fix */
    /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated)
    {
        /*SPR 15875 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),GEN_MME,"\n <msg function=\"S1AP\" name=\"E-RAB RELEASE RESPONSE\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),GEN_CELL,"\n <msg function=\"S1AP\" name=\"E-RAB RELEASE RESPONSE\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <target type=\"MME\">%s</target>",
                    p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
    /*SPR 15896 Fix Stop */
        /*SPR 15875 Fix Stop*/
    }
    /* TRACE_fix */

    /* The below check is done to capture the trace
     * in case of Error Indication also */
    if (RRC_FALSE == list_populated)
    {
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    
    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_ERABReleaseResponse]"
                "ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf, 0, 
                sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */
        msg.bitmask = 0;

        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

        if (RRC_FALSE != list_populated)
        {
/*SPR 18758 5Sep Fix Start*/
            if (PNULL == p_ue_context->p_failed_curr_proc_data)
            {
                if (RRC_SUCCESS != uecc_s1ap_build_E_RABReleaseListBearerRelComp(
                        p_ue_context, &asn1_ctx, &msg.e_rab_release_list))
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[s1ap_E_RABReleaseResponse]"
                        "uecc_s1ap_build_E_RABReleaseListBearerRelComp failure");
                    break;
                }
            }
/*SPR 18758 5Sep Fix Stop*/

            if (RRC_SUCCESS!=uecc_s1ap_build_e_rab_failed_to_release_list(
                        p_ue_context,&asn1_ctx,&msg.e_rab_failed_to_release_list))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[s1ap_ERABReleaseResponse]"
                        "uecc_s1ap_build_e_rab_failed_to_release_list failure");
                break;
            }
        }

        if(msg.e_rab_release_list.count > 0)
        {
            msg.bitmask |=
                RRC_S1AP_ERAB_RELEASE_RESPONSE_E_RAB_RELEASE_LIST_PRESENT;
        }

        if(msg.e_rab_failed_to_release_list.count > 0)
        {
            msg.bitmask |=
                RRC_S1AP_ERAB_RELEASE_RESPONSE_E_RAB_FAILED_TO_RELEASE_LIST_PRESENT;
        }

        if ((PNULL != p_criticality_diagnostics) && 
                (IE_CRITICALITY_DIAGNOSTICS_PRESENT == 
                 p_criticality_diagnostics->m.iEsCriticalityDiagnosticsPresent))
        {
            msg.mme_ue_s1ap_id = mme_ue_s1ap_id;
            msg.enb_ue_s1ap_id = enb_ue_s1ap_id;
            msg.bitmask |= RRC_S1AP_ERAB_RELEASE_RESPONSE_CRITICALITY_DIAGNOSTICS_PRESENT ;
            msg.criticality_diagnostics = *p_criticality_diagnostics;
        }

        /* Encode message */
        result = rrc_s1ap_e_rab_release_response_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],
                &p_sig_msg_req->message_buff_size,
                &msg);

        if (RRC_SUCCESS != result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ERABReleaseResponse] Build failure");

            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            
            rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU ", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                                 encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_ERAB_RELEASE_RESPONSE,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
            
            /* Generating Protocol Event LOCAL_EVENT_S1_ERAB_RELEASE_RESPONSE*/
            p_event_s1_erab_rel_resp = rrc_mem_get(sizeof(LOCAL_EVENT_S1_ERAB_RELEASE_RESPONSE_STRUCT));

            if (PNULL != p_event_s1_erab_rel_resp)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */

                p_event_s1_erab_rel_resp->header.length = 
                    sizeof(LOCAL_EVENT_S1_ERAB_RELEASE_RESPONSE_STRUCT);
                p_event_s1_erab_rel_resp->header.event_id = LOCAL_EVENT_S1_ERAB_RELEASE_RESPONSE;

                if ((PNULL != p_ue_context->p_gb_context->p_p_csc_context) && /*coverity_fix_ssn*/
                    (PNULL != p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index])
                        && (PNULL != p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                            p_csc_init_setup_ind))
                {
                    l3_memcpy_wrapper(&p_event_s1_erab_rel_resp->header.EVENT_PARAM_CELL_ID, 
                            p_ue_context->p_gb_context->
                            p_p_csc_context[p_ue_context->cell_index]->
                            p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.cell_Id, sizeof(U32));
                }
                p_event_s1_erab_rel_resp->header.EVENT_PARAM_EUTRANCELL_FROID = 
                    p_event_s1_erab_rel_resp->header.EVENT_PARAM_CELL_ID;

                if (p_ue_context->m.mme_ue_id_present)
                {
                    p_event_s1_erab_rel_resp->header.EVENT_PARAM_MMES1APID = p_ue_context->mme_ue_id;
                }

                p_event_s1_erab_rel_resp->header.EVENT_PARAM_RAC_UE_REF = p_ue_context->s1ap_ue_id;
                
                if (PNULL != p_ue_context->p_curr_proc_data)
                {
                    for (e_rab_index = 0; (e_rab_index < p_ue_context->p_curr_proc_data->u.
                                erab_release_command_data.erab_failed_to_release_list.counter) &&
                            (e_rab_index < MAX_ERAB_COUNT) ; e_rab_index++)
                    {
                        p_event_s1_erab_rel_resp->EVENT_ARRAY_ERAB_RELEASE_FAILURE_3GPP_CAUSE_GROUP[e_rab_index] = 
                            (U32)p_ue_context->p_curr_proc_data->u.erab_release_command_data.
                            erab_failed_to_release_list.erab_item[e_rab_index].cause.t;

                        switch(p_event_s1_erab_rel_resp->EVENT_ARRAY_ERAB_RELEASE_FAILURE_3GPP_CAUSE_GROUP[e_rab_index])
                        { 
                            case T_s1ap_Cause_radioNetwork: 
                                p_event_s1_erab_rel_resp->EVENT_ARRAY_ERAB_RELEASE_FAILURE_3GPP_CAUSE[e_rab_index] = 
                                    (U32)p_ue_context->p_curr_proc_data->u.erab_release_command_data.
                                    erab_failed_to_release_list.erab_item[e_rab_index].cause.u.radioNetwork;
                                break;

                            case T_s1ap_Cause_transport: 
                                p_event_s1_erab_rel_resp->EVENT_ARRAY_ERAB_RELEASE_FAILURE_3GPP_CAUSE[e_rab_index] = 
                                    (U32)p_ue_context->p_curr_proc_data->u.erab_release_command_data.
                                    erab_failed_to_release_list.erab_item[e_rab_index].cause.u.transport;
                                break;

                            case T_s1ap_Cause_nas: 
                                p_event_s1_erab_rel_resp->EVENT_ARRAY_ERAB_RELEASE_FAILURE_3GPP_CAUSE[e_rab_index] =
                                    (U32)p_ue_context->p_curr_proc_data->u.erab_release_command_data.
                                    erab_failed_to_release_list.erab_item[e_rab_index].cause.u.nas;
                                break; 

                            case T_s1ap_Cause_protocol:
                                p_event_s1_erab_rel_resp->EVENT_ARRAY_ERAB_RELEASE_FAILURE_3GPP_CAUSE[e_rab_index] =
                                    (U32)p_ue_context->p_curr_proc_data->u.erab_release_command_data.
                                    erab_failed_to_release_list.erab_item[e_rab_index].cause.u.protocol;
                                break; 

                            case T_s1ap_Cause_misc:
                                p_event_s1_erab_rel_resp->EVENT_ARRAY_ERAB_RELEASE_FAILURE_3GPP_CAUSE[e_rab_index] =
                                    (U32)p_ue_context->p_curr_proc_data->u.erab_release_command_data.
                                    erab_failed_to_release_list.erab_item[e_rab_index].cause.u.misc;
                                break; 
                        }
                    }
                }
                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_s1_erab_rel_resp);
            }
        }

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_E_RABRelease;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, &p_sig_msg_req->message_buff_p[0], 
                        p_sig_msg_req->message_buff_size, "E-RAB RELEASE RESPONSE", 1);
        /* TRACE_changes_start */
        
        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "S1AP_MSG: E-RABReleaseResponse %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));
    } while (0);

    /*SPR 15896 Fix Start */
    /* Trace_fix */
    if (p_ue_context->m.traceActivated )
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n</msg>" );
    }
    /*SPR 15896 Fix Stop */
    /* Trace_fix */

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}
/* ERB RELEASE COMMAND END */

/* ERB RELEASE INDICATION START */

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_e_rab_release_indication_arp
 *
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends e_rab_release_indication message
 *       to S1AP
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_e_rab_release_indication_arp(
        uecc_ue_context_t* p_ue_context)
{

    OSCTXT asn1_ctx;
    rrc_s1ap_e_rab_release_indication_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t*  p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t*)sig_msg_req_buf;
    rrc_return_et result = RRC_FAILURE;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;

    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if (p_ue_context->m.traceActivated )
    {
        /*SPR 15875 Fix Start*/
        /*SPR 15896 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),GEN_MME,"\n<msg function=\"S1AP\" name=\"E-RAB RELEASE Indication\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),GEN_CELL,"\n<msg function=\"S1AP\" name=\"E-RAB RELEASE Indication\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <target type=\"MME\">%s</target>",
                    p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
        /*SPR 15896 Fix Stop*/
        /*SPR 15875 Fix Stop*/
    }

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_ERABReleaseIndication]"
                "ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf, 0, 
                sizeof(s1ap_ue_associated_sig_msg_req_t));

        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
        /*SPR 22036 Fix Start*/
        if(p_ue_context->p_curr_proc_data->u.erab_setup_request_data.is_erab_del_ongoing == RRC_TRUE)
        {
            if (RRC_SUCCESS != uecc_s1ap_build_e_rab_released_list_arp(
                        p_ue_context, &asn1_ctx, &msg.e_rab_released_list,
                        &p_ue_context->p_curr_proc_data->u.erab_setup_request_data.
                        erab_release_command_data.erab_release_list))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[s1ap_ERABReleaseIndication]"
                        "uecc_s1ap_build_e_rab_released_list_arp failure");
                break;
            }
        }
        else
        {
            if (RRC_SUCCESS != uecc_s1ap_build_e_rab_released_list_arp(
                        p_ue_context, &asn1_ctx, &msg.e_rab_released_list,
                        &p_ue_context->p_curr_proc_data->u.erab_modify_request_data.
                        erab_release_command_data.erab_release_list))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[s1ap_ERABReleaseIndication]"
                        "uecc_s1ap_build_e_rab_released_list_arp failure");
                break;
            }
        }
        /*SPR 22036 Fix Stop*/

        /* Encode message */
        result = rrc_s1ap_e_rab_release_indication_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0], 
                &p_sig_msg_req->message_buff_size,
                &msg);

        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ERABReleaseIndication] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

          
            rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_ERAB_RELEASE_INDICATION,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_E_RABReleaseIndication;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, &p_sig_msg_req->message_buff_p[0], 
                        p_sig_msg_req->message_buff_size, "E-RAB RELEASE Indication", 1);
        /* TRACE_changes_start */
        
        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "S1AP_MSG: E-RABReleaseIndication %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));

    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;

}
/* ERB RELEASE INDICATION END */


/*SPR 22628 Fix Start */
/* Trace Start Procedure start */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_trace_start
 *
 *   INPUTS       : S1AP_PDU*            p_s1ap_pdu
 *                  uecc_gb_context_t*   p_uecc_gb_context
 *                  U8                   mme_id
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes MME initiated Trace Start Message
 *
 *   RETURNS: None
 *
 ******************************************************************************/
void uecc_s1ap_process_trace_start
(
 S1AP_PDU*            p_s1ap_pdu,    /* Pointer to s1ap pdu */
/*BUG 604 changes start*/ 
 uecc_gb_context_t*   p_uecc_gb_context,  /* UECC global context */
 /*SPR 17777 +-*/
 U8           mme_id
/*BUG 604 changes stop*/ 
/*SPR 22628 Fix End */
 )
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    s1ap_Cause                      result;
    rrc_s1ap_trace_start_t msg;
    /* SPR 22628 Fix Start */
    s1ap_CriticalityDiagnostics     logical_criti_diag;
    rrc_bool_et                     send_err_ind = RRC_FALSE;
    /* SPR 22628 Fix End */
    /*SPR 15896 Fix Start*/
    /* Code Removed */
    /*SPR 15896 Fix Stop*/

    RRC_ASSERT(PNULL != p_s1ap_pdu);
    RRC_ASSERT(PNULL != p_s1ap_pdu->u.initiatingMessage);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    memset_wrapper(&msg, 0, sizeof(rrc_s1ap_trace_start_t));

    result.t = S1AP_CAUSE_SUCCESS;
    do
    {
        if (PNULL == p_s1ap_pdu->u.initiatingMessage->value.u.traceStart)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "[s1ap_TraceStart] is PNULL - Drop Message");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }

        /* Decode message */
        rrc_s1ap_trace_start_intrl_dec(
                p_uecc_gb_context,
                p_s1ap_pdu->u.initiatingMessage->value.u.traceStart,
                &msg,
                &result
                );

        if (S1AP_CAUSE_SUCCESS != result.t)
        {
            /* Message parsing error */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "[s1ap_TraceStart] Parsing error - Drop Message");
            /* Drop. */
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }

        /* Process message */
        /*BUG 604 changes start*/ 
        /* Get context using S1AP id */
        p_ue_context = uecc_ue_ctx_get_by_s1ap_id(p_uecc_gb_context,
                msg.enb_ue_s1ap_id);
        if (PNULL == p_ue_context)
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "[s1ap_TraceStart] UE context not found");

            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "[s1ap_TraceStart] messge dropped - UECC isn't initialized by CSC ");
            /* SPR 22628 Fix Start */
            result.t = T_s1ap_Cause_protocol;
            result.u.protocol = s1ap_message_not_compatible_with_receiver_state;
            send_err_ind = RRC_TRUE;
            break;
            /* SPR 22628 Fix End */
        }

        if (0 != p_ue_context->m.mme_ue_id_present)
        {
            if (msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name, RRC_WARNING,
                    "[s1ap_TraceStart] mme_ue_s1ap_id (%i) != p_ue_context->mme_ue_id (%i)",
                    msg.mme_ue_s1ap_id,
                    p_ue_context->mme_ue_id);

                /* Send failure response */
                /* SPR 22628 Fix Start */
                result.t = T_s1ap_Cause_radioNetwork;
                result.u.radioNetwork = s1ap_unknown_mme_ue_s1ap_id;
                send_err_ind = RRC_TRUE;
                /* SPR 22628 Fix End */
                break;
            }
        }
        /* SPR 11814 Fix start */
        else
        {
            /* store mme_ue_s1ap_id in UE context */
            p_ue_context->m.mme_ue_id_present = 1;
            p_ue_context->mme_ue_id = msg.mme_ue_s1ap_id;

            if ( PNULL != g_rrc_stats.p_rrc_stats )
            {
                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                        p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].
                        rrc_ue_assoc_s1_conn_related_stats.
                        s1sig_connEstabSucc, 0, DUMMY_RANGE_CHECK_INDEX);
            }
        }
        /* SPR 11814 Fix stop */

        /* cr_726 check for Eutran trace id */
        for(start_trace_count = 0 ; start_trace_count < EUTRAN_TRACE_ID_VAL_CHECK ; start_trace_count++)
        {
            if(RRC_FAILURE == check_trace_id_validity(start_trace_count,msg.trace_activation.e_UTRAN_Trace_ID.data[start_trace_count]))
            {
                /* SPR 22628 Fix Start */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name, RRC_WARNING,
                    "EUTRAN_TRACE_ID NOT CODED IN PROPER FORMAT --");
                send_err_ind = RRC_TRUE;
                result.t = T_s1ap_Cause_protocol;
                result.u.protocol = s1ap_semantic_error;
                /* Break from FOR loop */
                break;
                /* SPR 22628 Fix End */
            }
        }
        /* SPR 22628 Fix Start */
        /* Break from DO-WHILE loop */
        if (RRC_TRUE == send_err_ind)
            break;
        /* SPR 22628 Fix End */
        /* SPR 22628 Fix Start */
        /* Code Deleted */
        /* SPR 22628 Fix End */

        if (PNULL != p_uecc_gb_context->p_p_csc_context)
        {
            if (PNULL != p_uecc_gb_context->p_p_csc_context[p_ue_context->cell_index])
            {
                /* Check: Is Signaling Trace activated or Handover is ongoing or
                   Cell deletion is ongoing or UE release is ongoing*/
                /*SPR 15896 Fix Start*/
                if (PNULL != p_ue_context->ho_info.p_ho_info ||
                        p_uecc_gb_context->p_p_csc_context[p_ue_context->cell_index]->del_cell_ongoing ||
                    ((PNULL != p_ue_context->uecc_fsm.p_current_state) &&
                    (p_ue_context->uecc_fsm.p_current_state == &uecc_fsm_ue_connection_release_ongoing)) || 
                    (p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE))
                /*SPR 15896 Fix Stop*/
                {
                    result.t = T_s1ap_Cause_radioNetwork;
                    /* SPR:5661 start */
                    if (PNULL != p_ue_context->ho_info.p_ho_info)
                    {
                        /* Bug:8686 */
                        fill_s1ap_fail_cause(p_ue_context, (U32 *)(&result.u.radioNetwork));
                        /* Bug:8686 */
                    }
                    else
                    {
                        result.u.radioNetwork = s1ap_interaction_with_other_procedure;
                    }
                    /* SPR:5661 stop */

                    /* Build and send trace failure indication */
                    if (RRC_SUCCESS != uecc_s1ap_build_and_send_trace_failure_indication(
                                p_ue_context, &msg, &result, RRC_FALSE))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name, RRC_WARNING,
                            "[s1ap_TraceFailureIndication] Delivery Fail");
                    }
                }
                else
                {
                    /* TRACE_fix */
                    /*SPR 15896 Fix Start*/
                    /* Code Removed */
                    /*SPR 15896 Fix Stop*/
                    /* TRACE_fix */
                    /* Allocate memory to store trace activation control and
                     * configuration parameters in Ue context */
                    if (PNULL == (p_ue_context->p_ue_trace_activation_info =
                                (ue_trace_activation_info_t*)
                                rrc_mem_get(sizeof(ue_trace_activation_info_t))))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name, RRC_FATAL,
                            "[s1ap_TraceStart] Memory Allocation Failed");
                        break;
                    }
                    else
                    {
                        /* SES-508 Fix Start */
                        /* Code Removed */
                        /* SES-508 Fix End */

                        /* store e_utran_trace_:id */
                        l3_memcpy_wrapper(
                                p_ue_context->p_ue_trace_activation_info->trace_id_info.
                                eutran_trace_id.data,
                                msg.trace_activation.e_UTRAN_Trace_ID.data,
                                msg.trace_activation.e_UTRAN_Trace_ID.numocts);
                        /*SPR 15896 Fix Start*/
                        /* Set trace activation flag */
                        p_ue_context->m.traceActivated |= RRC_TRACE_ACTIVATION_MME_INITIATE;
                        /*SPR 15896 Fix Stop*/

                        p_ue_context->p_ue_trace_activation_info->trace_id_info.
                            eutran_trace_id.numoctet = 
                            msg.trace_activation.e_UTRAN_Trace_ID.numocts;

                        p_ue_context->p_ue_trace_activation_info->interfaces_to_trace = 0;
                        if (msg.trace_activation.interfacesToTrace.data[0] & TRACE_S1AP_INTERFACE)
                           p_ue_context->p_ue_trace_activation_info->interfaces_to_trace |= S1;
                        if (msg.trace_activation.interfacesToTrace.data[0] & TRACE_X2AP_INTERFACE)
                           p_ue_context->p_ue_trace_activation_info->interfaces_to_trace |= X2;
                        if (msg.trace_activation.interfacesToTrace.data[0] & TRACE_UU_INTERFACE)
                           p_ue_context->p_ue_trace_activation_info->interfaces_to_trace |= UU;

                        /* store trace depth */
                        p_ue_context->p_ue_trace_activation_info->trace_depth =
                            (trace_depth_et)msg.trace_activation.traceDepth;

                        /* store trace collection entity info */
                        if (!(msg.trace_activation.traceCollectionEntityIPAddress.numbits
                                    % RRC_OCTET_SIZE)) 
                        {
                            p_ue_context->p_ue_trace_activation_info->
                                trace_collection_entity_info.length = 
                                (U8)(msg.trace_activation.traceCollectionEntityIPAddress.numbits
                                        / RRC_OCTET_SIZE);
                        }
                        else
                        {
                            p_ue_context->p_ue_trace_activation_info->
                                trace_collection_entity_info.length = 
                                (U8)((msg.trace_activation.traceCollectionEntityIPAddress.numbits
                                            / RRC_OCTET_SIZE) + 1);
                        }
                        l3_memcpy_wrapper(p_ue_context->p_ue_trace_activation_info->
                                trace_collection_entity_info.data, 
                                msg.trace_activation.traceCollectionEntityIPAddress.data,
                                p_ue_context->p_ue_trace_activation_info->
                                trace_collection_entity_info.length);
                        /*SPR 15896 Fix Start*/
                        if (PNULL == p_ue_context->p_ue_trace_activation_info->fp)
                        {
                            /* create and open trace file */
                            uecc_generate_trace_file_name(p_ue_context,TRACE_S1AP_INITIATED);
                        }
                        /*SPR 15896 Fix Stop*/
                    }
                }
            }
        }
    } while (0);
    /* SPR 22628 Fix Start */
    if((RRC_TRUE == send_err_ind) && (PNULL != p_ue_context))
    {
        /* Coverity ID 147600 Fix */
        memset_wrapper(&logical_criti_diag, RRC_NULL, sizeof(s1ap_CriticalityDiagnostics));
        asn1Init_s1ap_CriticalityDiagnostics(&logical_criti_diag);

        /* filling criticality diagnostics */
        logical_criti_diag.m.procedureCodePresent = RRC_S1AP_SET_MEMBER;
        logical_criti_diag.procedureCode = ASN1V_s1ap_id_TraceStart;

        logical_criti_diag.m.triggeringMessagePresent = RRC_S1AP_SET_MEMBER;
        logical_criti_diag.triggeringMessage = s1ap_initiating_message;

        logical_criti_diag.m.iEsCriticalityDiagnosticsPresent = RRC_FALSE;
        logical_criti_diag.m.iE_ExtensionsPresent = RRC_FALSE;

        logical_criti_diag.extElem1.count = RRC_FALSE;
        logical_criti_diag.extElem1.head = RRC_NULL;
        logical_criti_diag.extElem1.tail = RRC_NULL;

        /* Send Error Indication to MME */
        /*Coverity 115990 Fix*/
        if (RRC_SUCCESS != uecc_s1ap_build_and_send_error_indication(mme_id,
                    msg.mme_ue_s1ap_id, RRC_TRUE,
                    msg.enb_ue_s1ap_id, RRC_TRUE,
                    &logical_criti_diag, RRC_TRUE, &result, p_ue_context))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "Failure - Build & Send Error Indication Message");
        }
    }
    /* SPR 22628 Fix End */
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/* Trace Start Procedure end */

/*SPR 22628 Fix Start */
/* Deactivate trace Procedure start */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_deactivate_trace
 *
 *   INPUTS       : S1AP_PDU*            p_s1ap_pdu
 *                  uecc_gb_context_t*   p_uecc_gb_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes MME initiated Deactivate trace Message
 *
 *   RETURNS: None
 *
 ******************************************************************************/
void uecc_s1ap_process_deactivate_trace
(
 S1AP_PDU*            p_s1ap_pdu,    /* Pointer to s1ap pdu */
/*BUG 604 changes start*/ 
 uecc_gb_context_t*   p_uecc_gb_context,  /* UECC global context */
 U16                  ue_index,
 U8                   mme_id
/*BUG 604 changes stop*/
 /*SPR 22628 Fix End */
 )
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_uecc_oamh_trace_file_transfer_start_ind_t *p_out = PNULL;
    U8             *p_msg = PNULL;
    s1ap_Cause                      result;
    rrc_s1ap_deactivate_trace_t     msg;
    /*SPR 22628 Fix Start */
    /* Code Deleted */
    /*SPR 22628 Fix End */
    /*SPR 15875 Fix Start*/
    trace_id_info_t *p_trace_info = PNULL;
    U8 mcc[4] = {RRC_NULL};
    U8 mnc[4] = {RRC_NULL};
    U8 trace_id[7] = {RRC_NULL};
    /*SPR 15875 Fix Stop*/  
    /*SPR 22628 Fix Start */
    s1ap_CriticalityDiagnostics     logical_criti_diag;
    rrc_bool_et                     send_err_ind = RRC_FALSE;
    result.t = S1AP_CAUSE_SUCCESS;
    /*SPR 22628 Fix End */

    RRC_ASSERT(PNULL != p_s1ap_pdu);
    RRC_ASSERT(PNULL != p_s1ap_pdu->u.initiatingMessage);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    memset_wrapper(&msg, 0, sizeof(rrc_s1ap_deactivate_trace_t));

    memset_wrapper(&result, 0, sizeof(s1ap_Cause));
    do
    {
        if (PNULL == p_s1ap_pdu->u.initiatingMessage->value.u.deactivateTrace)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "[s1ap_DeactivateTrace] is PNULL - Drop Message");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }

        /* Decode message */
        rrc_s1ap_deactivate_trace_intrl_dec(
                p_uecc_gb_context,
                p_s1ap_pdu->u.initiatingMessage->value.u.deactivateTrace,
                &msg,
                &result
                );

        /* SPR 22628 Fix Start */
        if (S1AP_CAUSE_SUCCESS != result.t)
        {
            /* Message parsing error */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "[s1ap_deactivateTrace] Parsing error - Drop Message");
            /* Drop. */
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }
        /* SPR 22628 Fix End */

        /* Process message */
        /*BUG 604 changes start*/ 
        /* Get context using ue_index */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,ue_index);
        /*BUG 604 changes stop*/ 
        /*Coverity 88046 Fix Start*/
        /* code moved */
        /*Coverity 88046 Fix Stop*/

        if (PNULL == p_ue_context)
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "[s1ap_DeactivateTrace] UE context not found");

            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }
        /*SPR 15875 Fix Start*/
        p_trace_info = &(p_ue_context->p_ue_trace_activation_info->trace_id_info);
        /*SPR 15875 Fix Stop*/

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "[s1ap_DeactivateTrace] messge dropped - UECC isn't initialized by CSC ");
            /* SPR 22628 Fix Start */
            result.t = T_s1ap_Cause_protocol;
            result.u.protocol = s1ap_message_not_compatible_with_receiver_state;
            send_err_ind = RRC_TRUE;
            break;
            /* SPR 22628 Fix End */
        }

        if (0 != p_ue_context->m.mme_ue_id_present)
        {
            if (msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name, RRC_WARNING,
                    "[s1ap_DeactivateTrace] mme_ue_s1ap_id (%i) != p_ue_context->mme_ue_id (%i)",
                    msg.mme_ue_s1ap_id, p_ue_context->mme_ue_id);

                /* Send failure response */
                result.t = T_s1ap_Cause_radioNetwork;
                result.u.radioNetwork = s1ap_unknown_mme_ue_s1ap_id;
                /* SPR 22628 Fix Start */
                send_err_ind = RRC_TRUE;
                /* SPR 22628 Fix End */
                break;
            }
        }

        if (p_ue_context->p_ue_trace_activation_info == PNULL)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "[s1ap_DeactivateTrace]: No Trace Activation Info Available");
            /* SPR 22628 Fix Start */
            send_err_ind = RRC_TRUE;
            result.t = T_s1ap_Cause_protocol;
            result.u.protocol = s1ap_semantic_error;
            /* SPR 22628 Fix End */
            break;
        }

        /* cr_726 check for Eutran trace id */
        for(de_trace_count = 0 ; de_trace_count < EUTRAN_TRACE_ID_VAL_CHECK ; de_trace_count++)
        {
            if(RRC_FAILURE == check_trace_id_validity(de_trace_count,msg.e_utran_trace_id.data[de_trace_count]))
            {  
                /* SPR 22628 Fix Start */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name, RRC_WARNING,
                    "EUTRAN_TRACE_ID NOT CODED IN PROPER FORMAT --");
                send_err_ind = RRC_TRUE;
                result.t = T_s1ap_Cause_protocol;
                result.u.protocol = s1ap_semantic_error;
                /* Break from FOR loop */
                break;
                /* SPR 22628 Fix End */
            }
        }

        /* SPR 22628 Fix Start */
        /* Break from DO-WHILE loop */
        if (RRC_TRUE == send_err_ind)
            break;
        /* SPR 22628 Fix End */
        /* SPR 22628 Fix Start */
        /* Code Deleted */
        /* SPR 22628 Fix End */

        /* Check: Handover is ongoing */
        if (PNULL != p_ue_context->ho_info.p_ho_info)
        {
            result.t = T_s1ap_Cause_radioNetwork;
            /* Bug:8686 */
            fill_s1ap_fail_cause(p_ue_context, (U32 *)(&result.u.radioNetwork));
            /* Bug:8686 */

            /* Build and send trace failure indication */
            if (RRC_SUCCESS !=
                    uecc_s1ap_build_and_send_trace_failure_indication(
                        p_ue_context, &msg, &result, RRC_TRUE))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                     p_uecc_gb_context->facility_name, RRC_WARNING,
                     "[s1ap_TraceFailureIndication] Delivery Fail");
            }
        }
        else if (memcmp_wrapper(msg.e_utran_trace_id.data, 
                    p_ue_context->p_ue_trace_activation_info->trace_id_info.
                    eutran_trace_id.data,
                    msg.e_utran_trace_id.numocts))
        {
            /* SPR 22628 Fix Start */
            send_err_ind = RRC_TRUE;
            result.t = T_s1ap_Cause_protocol;
            result.u.protocol = s1ap_semantic_error;
            break;
            /* SPR 22628 Fix End */
        }
        else
        {
            /*SPR 15875 Fix Start*/
            p_trace_info = &(p_ue_context->p_ue_trace_activation_info->trace_id_info);
            /*Extracting TRACE_ID*/
            /*SPR 15896 Fix Start*/
            snprintf_wrapper((Char8*)trace_id,7,(const Char8*)"%02X%02X%02X",p_trace_info->eutran_trace_id.data[3],
                    p_trace_info->eutran_trace_id.data[4], p_trace_info->eutran_trace_id.data[5]);

            /*Extracting MCC*/
            snprintf_wrapper((Char8*)mcc,4,(const Char8*)"%d%d%d",(p_trace_info->cell_eutran_trace_id.trace_reference[0] & 0x0F),
                    ((p_trace_info->cell_eutran_trace_id.trace_reference[0] & 0xF0)>>4),
                    (p_trace_info->cell_eutran_trace_id.trace_reference[1] & 0x0F));
 
            /*Extracting MNC*/
            /*Check if the higher nibble contains filler digit*/
            /*If present , discard the filler digit('F')*/
            if(0xF0 == (p_trace_info->cell_eutran_trace_id.trace_reference[1] & 0xF0))
            {
                snprintf_wrapper((Char8*)mnc,4,(const Char8*)"%d%d",(p_trace_info->cell_eutran_trace_id.trace_reference[2] & 0x0F),
                        ((p_trace_info->cell_eutran_trace_id.trace_reference[2] & 0xF0)>>4));
            }
            else
            {
                snprintf_wrapper((Char8*)mnc,4,(const Char8*)"%d%d%d",((p_trace_info->cell_eutran_trace_id.trace_reference[1] & 0xF0)>>4),
                        (p_trace_info->cell_eutran_trace_id.trace_reference[2] & 0x0F),
                        ((p_trace_info->cell_eutran_trace_id.trace_reference[2] & 0xF0)>>4));
            }
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,"\n<traceSessionRef>");
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,"\n<MCC>");
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,mcc);
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,"</MCC>");
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,"\n<MNC>");
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,mnc);
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,"</MNC>");
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,"\n<TRACE_ID>");
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,trace_id);
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,"</TRACE_ID>");
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,"\n</traceSessionRef>");
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,"\n</traceRecSession> \n </traceCollecFile>");
            /*SPR 15896 Fix Stop*/
            /*SPR 15875 Fix Stop*/
            /*SPR 15896 Fix Start*/
            /* Stop Tracing : Reset trace activation flag */
            p_ue_context->m.traceActivated &= (0xFF^RRC_TRACE_ACTIVATION_MME_INITIATE);
            /* close trace file */
            if (PNULL != p_ue_context->p_ue_trace_activation_info->fp)
            {
                rrc_fclose(p_ue_context->p_ue_trace_activation_info->fp);
                p_ue_context->p_ue_trace_activation_info->fp = PNULL;
            }
            /*SPR 15896 Fix Stop*/

            /* allocate memory to send trace_file_transfer_start_ind */
            p_msg = uecc_alloc_intrl_msg(RRC_OAMH_MODULE_ID,
                    UECC_OAMH_TRACE_FILE_TRANSFER_START_IND,
                    sizeof(rrc_uecc_oamh_trace_file_transfer_start_ind_t));
            if (PNULL == p_msg)
            {
                /*out of memory*/
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name, RRC_WARNING,
                    "[S1AP] Low memory for UECC_OAMH_TRACE_FILE_TRANSFER_START_IND ");
                return;
            }
            /* Point to message */
            p_out = (rrc_uecc_oamh_trace_file_transfer_start_ind_t*)(p_msg +
                    RRC_API_HEADER_SIZE);

            /* cell_index */
            p_out->cell_index = p_ue_context->cell_index;

            /* ue_index */
            p_out->ue_index = p_ue_context->ue_index;

            /*SPR 15896 Fix Start*/
            /* e_utran_trace_id: trace reference */
            /*Coverity 88110 Fix Start*/
            l3_memcpy_wrapper(p_out->e_utran_trace_id.trace_reference, 
                    p_ue_context->p_ue_trace_activation_info->trace_id_info.eutran_trace_id.
                    /*SPR_16998_START*/
                    data,
                    /*SPR_16998_END*/
                    sizeof(p_out->e_utran_trace_id.trace_reference)); 
            /*Coverity 88110 Fix End*/

            /* e_utran_trace_id: trace recording session reference */
            l3_memcpy_wrapper(&p_out->e_utran_trace_id.trace_recording_session_reference, 
                    p_ue_context->p_ue_trace_activation_info->trace_id_info.
                    eutran_trace_id.data+6,
                    sizeof(p_out->e_utran_trace_id.
                        trace_recording_session_reference));
            /*SPR 15896 Fix Stop*/
            /* length of file */
            p_out->trace_file.len_file_name = 
                (U16)(strlen_wrapper((const Char8 *)p_ue_context->p_ue_trace_activation_info->trace_file));

            /* trace file name */
            l3_memcpy_wrapper(p_out->trace_file.file_name, 
                    p_ue_context->p_ue_trace_activation_info->trace_file, 
                    (U16)(p_out->trace_file.len_file_name + 1)); /* + 1 for Null Character */

            /* Copy Trace Collection IP Addr */
            l3_memcpy_wrapper(&(p_out->trace_collection_entity), 
                    &(p_ue_context->p_ue_trace_activation_info->
                        trace_collection_entity_info), 
                    sizeof(p_out->trace_collection_entity)); 

            /* Send Message */
            rrc_send_message(p_msg, RRC_OAMH_MODULE_ID);
            /*SPR 19592 :COV ID 108745 Fix Start*/
            /* Deallocate memory used to store trace control and configuration
             * parameters in Ue Context */
            rrc_mem_free(p_ue_context->p_ue_trace_activation_info);
            p_ue_context->p_ue_trace_activation_info = PNULL;
            /*SPR 19592 :COV ID 108745 Fix End*/
        }
    } while (0);
    /* SPR 22628 Fix Start */
    if((RRC_TRUE == send_err_ind) && (PNULL != p_ue_context))
    {
        /* Coverity ID 147601 Fix */
        memset_wrapper(&logical_criti_diag, RRC_NULL, sizeof(s1ap_CriticalityDiagnostics));
        asn1Init_s1ap_CriticalityDiagnostics(&logical_criti_diag);

        /* filling criticality diagnostics */
        logical_criti_diag.m.procedureCodePresent = RRC_S1AP_SET_MEMBER;
        logical_criti_diag.procedureCode = ASN1V_s1ap_id_TraceStart;
        logical_criti_diag.m.triggeringMessagePresent = RRC_S1AP_SET_MEMBER;
        logical_criti_diag.triggeringMessage = s1ap_initiating_message;
        logical_criti_diag.m.iEsCriticalityDiagnosticsPresent = RRC_FALSE;
        logical_criti_diag.m.iE_ExtensionsPresent = RRC_FALSE;
        logical_criti_diag.extElem1.count = RRC_FALSE;
        logical_criti_diag.extElem1.head = RRC_NULL;
        logical_criti_diag.extElem1.tail = RRC_NULL;

        /* Send Error Indication to MME */
        /*Coverity 115990 Fix*/
        if (RRC_SUCCESS != uecc_s1ap_build_and_send_error_indication(mme_id,
                    msg.mme_ue_s1ap_id, RRC_TRUE,
                    msg.enb_ue_s1ap_id, RRC_TRUE,
                    &logical_criti_diag, RRC_TRUE, &result, p_ue_context))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name, RRC_WARNING,
                "Failure - Build & Send Error Indication Message");
        }
    }
    /* SPR 22628 Fix End */
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_oamh_s1_ho_start_cell_traffic_trace 
 *
 *   INPUTS       : uecc_gb_context_t*   p_uecc_gb_context
 *                  uecc_ue_context_t *p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes the cell traffic trace 
 *
 *   RETURNS: None
 *
 ******************************************************************************/
void uecc_oamh_s1_ho_start_cell_traffic_trace
(
uecc_gb_context_t *p_uecc_gb_context,
uecc_ue_context_t *p_ue_context
)
{
    /*SPR 15896 Fix Start*/
    if (PNULL != p_ue_context && !(p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE))
    {
        /* Allocate memory to store trace activation control and
         * configuration parameter */
        if (PNULL == (p_ue_context->p_ue_cell_trace_activation_info =
                    (ue_trace_activation_info_t*)
                    rrc_mem_get(sizeof(ue_trace_activation_info_t))))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->
                    facility_name, RRC_FATAL,
                    "[CELL TRAFFIC TRACE]"
                    "Memory Allocation Failed ");

            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }
        else
        {
            /* CID 118131 Fix Start */
            if (PNULL != p_ue_context->p_gb_context)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                /*SPR 15896 Fix Stop*/

                /* trace reference and trace recording 
                 * session reference */
                uecc_generate_eutran_traceid(p_ue_context);

                /*SPR 15896 Fix Start*/
                /* rrc_trace_activation_flag_et*/
                p_ue_context->m.traceActivated |= RRC_TRACE_ACTIVATION_CELL_INITIATE;
                /* store interfaces to trace */
                p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace = 
                    p_uecc_gb_context->p_p_csc_context[p_ue_context->cell_index]->p_cell_traffic_trace_info->interface_to_trace;  

                /* store trace depth */
                p_ue_context->p_ue_cell_trace_activation_info->trace_depth =
                    (trace_depth_et)(p_uecc_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                            p_cell_traffic_trace_info->trace_depth);

                /* Copy trace collection entity info into Ue Context */
                l3_memcpy_wrapper(&p_ue_context->p_ue_cell_trace_activation_info->
                        trace_collection_entity_info,
                        &p_uecc_gb_context->p_p_csc_context[p_ue_context->cell_index]->p_cell_traffic_trace_info->trace_collection_entity,
                        sizeof(p_uecc_gb_context->p_p_csc_context[p_ue_context->cell_index]->p_cell_traffic_trace_info->trace_collection_entity));

                /*SPR 15896 Fix Stop*/
                /* function to create file name and open file for UE*/
                uecc_generate_trace_file_name(p_ue_context,TRACE_OAM_INITIATED);

                /*SPR 15896 Fix Start*/
                /* Code Removed */

                /*SPR 15896 Fix Stop*/
                /* Send only when mme_ue_s1ap_id is present */
                if (p_ue_context->m.mme_ue_id_present) 
                {
                    /* Build and send CELL_TRAFFIC_TRACE to S1AP */
                    if (RRC_SUCCESS != 
                            uecc_s1ap_build_and_send_cell_traffic_trace(p_ue_context))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index, 
                                p_uecc_gb_context->facility_name, RRC_WARNING,
                                "Send to fail [CELL TAFFIC TRACE]");
                    }
                }
            }
        }
        /* CID 118131 Fix End */
    }
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_ho_req_src_enb_to_trt_enb_transp_container
 *
 *   DESCRIPTION:
 *       This function processes S1AP Handover Request message 
 *       RRC_SOURCE_ENB_TO_TARGET_ENB_TRANSPARENT_CONTAINER_PRESENT
 *
 *   RETURNS:   RRC_FAILURE / RRC_SUCCESS
 *
 ******************************************************************************/
/* SPR 16149 Fix Start*/
static rrc_return_et uecc_s1ap_ho_req_src_enb_to_trt_enb_transp_container(
        uecc_gb_context_t   *p_uecc_gb_context,
        uecc_ue_context_t*   p_ue_context,
         U32  enb_ue_s1ap_id,
        rrc_s1ap_handover_request_t *p_msg,
        rrc_cell_index_t    *cell_index,
        s1ap_Cause          *p_result,
        U8 mme_id,
        U8 *p_index)
/* SPR 16149 Fix Stop*/

{
    U8 index = RRC_NULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    if (( PNULL != p_uecc_gb_context->p_p_csc_context ) && 
            ( RRC_SOURCE_ENB_TO_TARGET_ENB_TRANSPARENT_CONTAINER_PRESENT &
              p_msg->source_to_target_transparent_container.bitmask))
    {
        for ( index = 0; index < MAX_NUM_CELLS; index++ )
        {
            if ( PNULL != p_uecc_gb_context->p_p_csc_context[index] )
            {
                if ( PNULL != p_uecc_gb_context->p_p_csc_context[index]->
                        p_csc_init_setup_ind)
                {
                    if (RRC_NULL == memcmp_wrapper (p_uecc_gb_context->p_p_csc_context[index]->
                                p_csc_init_setup_ind->sib_type_1_Info.
                                cell_access_related_info.cell_Id,
                                p_msg->source_to_target_transparent_container.
                                source_enb_to_target_enb_transparent_container.
                                targetCell_ID.cell_ID.data,
                                CELL_ID_OCTET_SIZE ))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_INFO,
                                "[uecc_s1ap_process_handover_request] "
                                "cell identity is matched at [%u] cell index", index);
                        *cell_index = index;
                        *p_index = index;
                        break;
                    }
                }
            }
        }
        if ( RRC_INVALID_CELL_INDEX == *cell_index )
        {
            /* Send failure response */
            p_result->t = T_s1ap_Cause_radioNetwork;
            /* BZ_9748 Fix Start */
            p_result->u.radioNetwork = s1ap_unknown_targetID;
            /* BZ_9748 Fix Stop */

            /* UE context allocation fail */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Handover Request ] The UE context allocation failure "
                    "- reject");

            /*send HO FAILURE to MME*/
            /* SPR 16149 Fix Start*/
            uecc_s1ap_build_and_send_handover_failure(
                    p_uecc_gb_context,
                    p_ue_context,
                    enb_ue_s1ap_id,
                    p_msg->mme_ue_s1ap_id,
                    mme_id,
                    p_result,
                    (rrc_s1ap_error_indication_t *)PNULL);
            /* SPR 16149 Fix Stop*/
            return RRC_FAILURE;
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_handover_request_trace_handler
 *
 *   DESCRIPTION:
 *       This function processes S1AP Handover Request TraceActivation
 *
 *   RETURNS:   RRC_FAILURE / RRC_SUCCESS
 *
 ******************************************************************************/
static rrc_return_et uecc_s1ap_process_handover_request_trace_handler(
        uecc_gb_context_t   *p_uecc_gb_context,
        uecc_ue_context_t*              p_ue_context,
        U32 buffer_length, 
        rrc_s1ap_handover_request_t *p_msg,
        U8 *buffer)
{
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/

    /* TRACE_fix */
      /*SPR 15896 Fix Start*/
          if (!(p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
          (p_msg->bitmask & RRC_S1AP_HANDOVER_REQUEST_TRACE_ACTIVATION_PRESENT))
      /*SPR 15896 Fix Stop*/
    /* TRACE_fix */
    {
        /* Allocate memory to store trace activation control and
         * configuration parameters in Ue context */
        if (PNULL == (p_ue_context->p_ue_trace_activation_info =
                    (ue_trace_activation_info_t*)
                    rrc_mem_get(sizeof(ue_trace_activation_info_t))))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_FATAL,
                    "[s1ap_TraceStart]"
                    "Memory Allocation Failed");
            return RRC_FAILURE;
        }
        else
        {
            /* SES-508 Fix Start */
            /* Code Removed */
            /* SES-508 Fix End */

            /*SPR 15896 Fix Start*/
            /* Set trace activation flag */
            p_ue_context->m.traceActivated |= RRC_TRACE_ACTIVATION_MME_INITIATE;
            /*SPR 15896 Fix Stop*/

            /* store e_utran_trace_id */
            l3_memcpy_wrapper(
                    p_ue_context->p_ue_trace_activation_info->trace_id_info.
                    eutran_trace_id.data,
                    p_msg->trace_activation.e_UTRAN_Trace_ID.data,
                    p_msg->trace_activation.e_UTRAN_Trace_ID.numocts);

            p_ue_context->p_ue_trace_activation_info->trace_id_info.
                eutran_trace_id.numoctet = 
                p_msg->trace_activation.e_UTRAN_Trace_ID.numocts;

            /* store interfaces to trace */
            p_ue_context->p_ue_trace_activation_info->interfaces_to_trace = 0;
            if (p_msg->trace_activation.interfacesToTrace.data[0] & TRACE_S1AP_INTERFACE)
                p_ue_context->p_ue_trace_activation_info->interfaces_to_trace |= S1;
            if (p_msg->trace_activation.interfacesToTrace.data[0] & TRACE_X2AP_INTERFACE)
                p_ue_context->p_ue_trace_activation_info->interfaces_to_trace |= X2;
            if (p_msg->trace_activation.interfacesToTrace.data[0] & TRACE_UU_INTERFACE)
                p_ue_context->p_ue_trace_activation_info->interfaces_to_trace |= UU;

            /* store trace depth */
            p_ue_context->p_ue_trace_activation_info->trace_depth =
                (trace_depth_et)p_msg->trace_activation.traceDepth; 

            /* store trace collection entity info */
            if (!(p_msg->trace_activation.traceCollectionEntityIPAddress.numbits
                        % RRC_OCTET_SIZE))
            {
                p_ue_context->p_ue_trace_activation_info->
                    trace_collection_entity_info.length =
                    (U8)(p_msg->trace_activation.traceCollectionEntityIPAddress.numbits
                            / RRC_OCTET_SIZE);
            }
            else
            {
                p_ue_context->p_ue_trace_activation_info->
                    trace_collection_entity_info.length =
                    (U8)((p_msg->trace_activation.traceCollectionEntityIPAddress.numbits
                                / RRC_OCTET_SIZE) + 1);
            }
            l3_memcpy_wrapper(p_ue_context->p_ue_trace_activation_info->
                    trace_collection_entity_info.data,
                    p_msg->trace_activation.traceCollectionEntityIPAddress.data,
                    p_ue_context->p_ue_trace_activation_info->
                    trace_collection_entity_info.length);

      /*SPR 15896 Fix Start*/
            /* create and open trace file */
            if (PNULL == p_ue_context->p_ue_trace_activation_info->fp)
            {
                uecc_generate_trace_file_name(p_ue_context,TRACE_S1AP_INITIATED);
            }

      /*SPR 15896 Fix Stop*/
        }
    }
    /* SPR_5906 Start */
      /*SPR 15896 Fix Start*/
    if( !(p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
            p_uecc_gb_context->p_p_csc_context[p_ue_context->cell_index]->cell_trace_ongoing == RRC_TRUE )
      /*SPR 15896 Fix Stop*/
    {

        /* Call the function to activate trace for existing UE's in cell */
        uecc_oamh_s1_ho_start_cell_traffic_trace(p_uecc_gb_context, p_ue_context);
    }

    /* SPR_5906 End */


    /*Code for Trace Activation */
    /* Is trace activated */
    if (p_ue_context->m.traceActivated)
    {
        /*SPR 15875 Fix Start*/
        /*SPR 15896 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,"\n <msg function=\"S1AP\" name=\"Handover Request\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_CELL,"\n <msg function=\"S1AP\" name=\"Handover Request\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        /*SPR 15875 Fix Stop*/
        P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),S1,"\n <initiator type=\"MME\">%s</initiator>",
                    p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
    }

    /* Call UECC_EV_S1AP_HO_REQUEST event handler *
     * and pass API data to FSM. */
    /* WARNING. The uecc_event_queue_push_event can't
     * be used here because
     * the stack variable is used for storing the API data
     */
    /* Trace for the Cause of Handover */

    if (p_ue_context->m.traceActivated)
    {
        P_RRC_TRACE (p_ue_context, set_minimum_medium_both_bitmask(), S1, "\n <ie name=\"Handover-Type\">%d</ie>  ", p_msg->handover_type);
        /* SPR:5840 start */
        uecc_s1ap_p_rrc_trace_for_cause(p_ue_context,p_msg->cause);
    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n </msg>" );
        /* SPR:5840 stop */

    }
    rrc_trace_max_file_write(p_ue_context,HANDOVER_REQUEST,buffer_length, buffer, S1);
    /*SPR 15896 Fix Stop*/
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_handover_request_ue_context
 *
 *   DESCRIPTION:
 *       This function processes S1AP Handover Request message after getting
 *       UE Context
 *
 *   RETURNS:   RRC_FAILURE / RRC_SUCCESS
 *
 ******************************************************************************/
static rrc_return_et uecc_s1ap_process_handover_request_ue_context(
        uecc_gb_context_t   *p_uecc_gb_context,
        uecc_ue_context_t*              p_ue_context,
        s1ap_ue_associated_sig_msg_ind_t *p_s1ap_ue_associated_sig_msg_ind,
        U32 buffer_length, U8 mme_id,
        rrc_s1ap_handover_request_t *p_msg,
        s1ap_Cause                  *p_result,
        U8 *buffer,
        U8 index)
{
    U32                             encoded_msg_len = 0;
    U8 plmn_count = RRC_NULL;
    U8 plmn_identity_flag = RRC_FALSE;
    EVENT_EXTERNAL_HEADER           *p_event_header = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    if ( (PNULL != p_ue_context->p_gb_context) &&
         (PNULL != p_ue_context->p_gb_context-> p_p_csc_context) &&
         (PNULL != p_ue_context->p_gb_context-> p_p_csc_context[p_ue_context->cell_index]))
    {
        p_ue_context->m.rel_of_mme_present = 0;
        if (p_s1ap_ue_associated_sig_msg_ind->bitmask & 
                UE_ASSOC_SIG_MSG_IND_REL_OF_MME_PRESENT)
        {
            /* store release info of MME in UE context */
            p_ue_context->m.rel_of_mme_present = 1;
            p_ue_context->rel_of_mme = 
                (rel_info_of_mme_et)p_s1ap_ue_associated_sig_msg_ind->rel_of_mme;
        }

        p_ue_context->m.mme_ue_id_present = 1;
        p_ue_context->mme_ue_id = p_msg->mme_ue_s1ap_id; 

        if(p_msg->bitmask & RRC_S1AP_HANDOVER_REQUEST_MME_UE_S1AP_ID2_PRESENT)
        {
        /*36413_CR0798_start*/
            /* store mme_ue_s1ap_id2 in UE context */
            p_ue_context->m.mme_ue_id2_present = 1;
            p_ue_context->mme_ue_id2 = p_msg->mme_ue_s1ap_id2;
            /*36413_CR0798_stop*/
        }

        if(p_msg->bitmask & RRC_S1AP_HANDOVER_REQUEST_GUMMEI_PRESENT)
        {
            /*36413_CR0798_start*/
            /* mme grp id feature changes start */
            p_ue_context->m.source_gummei_present = 1;
            /* mme grp id feature changes stop */
            p_ue_context->gummei.plmn_identity = p_msg->gummei.pLMN_Identity;
            p_ue_context->gummei.grp_id = p_msg->gummei.mME_Group_ID;
            p_ue_context->gummei.mme_code = p_msg->gummei.mME_Code;
            /*SPR 22843 Fix Start*/
            uecc_s1ap_generate_plmn_identity_to_int(
                &p_ue_context->plmn_identity.plmn_identity,
                (const OSOCTET *)&p_msg->gummei.pLMN_Identity.data);
            /*SPR 22843 Fix End*/
            /*36413_CR0798_stop*/
        }
        /* CSR 00077102 Fix Start */
        else
        {
            p_ue_context->gummei = p_uecc_gb_context->mme_ctx[mme_id].gummei;
        }
        /* CSR 00077102 Fix Stop */

        /*Generating Protocol Events */
        /* SPR 22634 Fix - Starts */
        encoded_msg_len = (U32)(buffer_length);
        /* SPR 22634 Fix - Ends */
        p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                encoded_msg_len);
        if (PNULL != p_event_header)
        {
            /* SES-508 Fix Start */
            /* Code Removed */
            /* SES-508 Fix End */
            rrc_uecc_fill_protocol_event_params(p_ue_context,
                    p_event_header,
                    (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                    LOCAL_S1_HANDOVER_REQUEST,
                    MESSAGE_DIRECTION_RECEIVED);

            l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                        sizeof(EVENT_EXTERNAL_HEADER)),
                    (const void*)p_s1ap_ue_associated_sig_msg_ind->message_buff_p,
                    encoded_msg_len);

            rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
        }
        /* Update the mme_id to be sent with HO Request Ack or
         *                HO Failure*/
        p_ue_context->mme_id = mme_id;
        if (PNULL != p_ue_context->p_gb_context-> p_p_csc_context
                [p_ue_context->cell_index]->p_rrc_uecc_statistic)
        {
            /* update number of UE */
            uecc_status_cell_update_num_of_ue(p_ue_context->p_gb_context, 
                    p_ue_context->p_gb_context-> p_p_csc_context[p_ue_context->
                    cell_index]->p_rrc_uecc_statistic, RRC_TRUE);
        }

        if (PNULL != p_ue_context->p_gb_context->p_p_csc_context[index]->
                p_csc_init_setup_ind)
        {
            /* Store plmn identity */
            if (p_msg->bitmask &
                    RRC_S1AP_HANDOVER_REQUEST_HO_RESTRICTION_LIST_PRESENT)
            {
                /* Overwrite plmn_identity in UE Context */
                memset_wrapper(&p_ue_context->plmn_identity.plmn_identity,
                        RRC_NULL,
                        sizeof(p_ue_context->plmn_identity.plmn_identity));

                uecc_s1ap_generate_plmn_identity_to_int(
                        &p_ue_context->plmn_identity.plmn_identity,
                        p_msg->ho_restriction_list.servingPLMN.data);

                /*cr_627:Introduction of PLMN-related abnormal conditions 
                 * during HO in network sharing scenarios*/
                for (plmn_count = RRC_NULL; plmn_count < 
                        p_ue_context->p_gb_context->p_p_csc_context[index]->
                        p_csc_init_setup_ind->sib_type_1_Info.
                        cell_access_related_info.plmn_Id_info_list.count; 
                        plmn_count++)
                {
                    if(RRC_NULL == memcmp_wrapper(&p_ue_context->plmn_identity.plmn_identity, 
                                &p_ue_context->p_gb_context->p_p_csc_context[index]->
                                p_csc_init_setup_ind->sib_type_1_Info.
                                cell_access_related_info.plmn_Id_info_list.
                                plmn_identity_info[plmn_count].plmn_identity,
                                sizeof(p_ue_context->plmn_identity.plmn_identity)))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_INFO,
                                "[uecc_s1ap_process_handover_request] "
                                "plmn_identity is matched at [%u] index",plmn_count);
                        plmn_identity_flag = RRC_TRUE;
                        break;
                    }
                }
                if (RRC_TRUE != plmn_identity_flag)
                {
                    /* BZ_9748 Fix Start */
                    /* Send failure response */
            /*SPR 14418 Fix Start*/
                    p_result->t = T_s1ap_Cause_radioNetwork;
           /*SPR 13677 Fix Start*/
                    p_result->u.radioNetwork = s1ap_ho_target_not_allowed;
            /*SPR 14418 Fix Stop*/
           /*SPR 13677 Fix Stop*/
                    /* BZ_9748 Fix Stop */

                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_ERROR,
                            "[uecc_s1ap_process_handover_request ] "
                            "serving plmn is not mtached");

                    /*send HO FAILURE to MME*/
                    /* SPR 16149 Fix Start*/ 
                    uecc_s1ap_build_and_send_handover_failure(
                            p_uecc_gb_context,
                            p_ue_context,
                            p_s1ap_ue_associated_sig_msg_ind->enb_ue_s1ap_id,
                            p_msg->mme_ue_s1ap_id,
                            mme_id,
                            p_result,
                            (rrc_s1ap_error_indication_t *)PNULL);
                    /* SPR 16149 Fix Stop*/ 
                    return RRC_FAILURE;
                }
            }
            else
            {
        /*SPR 13677 Fix Start*/
        if (p_ue_context->p_gb_context->p_p_csc_context[index]->
            p_csc_init_setup_ind->sib_type_1_Info.
            cell_access_related_info.plmn_Id_info_list.count > 1)
        {
            /*SPR 22843 Fix Start*/
            /*Scenario 1 : GUMMEI is received and cell has more than 1 
            PLMN then PLMN received in GUMMEI should be one 
            of the supported PLMN in the SIB1 list */ 
            if(p_ue_context->m.source_gummei_present)
            {
                uecc_s1ap_generate_plmn_identity_to_int(
                        &p_ue_context->plmn_identity.plmn_identity,
                    (const OSOCTET *)&p_msg->gummei.pLMN_Identity.data);
                for (plmn_count = RRC_NULL; plmn_count < 
                    p_ue_context->p_gb_context->p_p_csc_context[index]->
                    p_csc_init_setup_ind->sib_type_1_Info.
                    cell_access_related_info.plmn_Id_info_list.count; 
                    plmn_count++)               
                {
                    if(RRC_NULL == memcmp_wrapper(&p_ue_context->plmn_identity.plmn_identity, 
                        &p_ue_context->p_gb_context->p_p_csc_context[index]->
                            p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.plmn_Id_info_list.
                            plmn_identity_info[plmn_count].plmn_identity,
                        sizeof(p_ue_context->plmn_identity.plmn_identity)))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name, RRC_INFO,
                            "plmn_identity is matched at [%u] index",plmn_count);
                        plmn_identity_flag = RRC_TRUE;
                        break;
                    }
                }
                if(plmn_identity_flag != RRC_TRUE)
                {
                    /*SPR 22843 Fix End*/
                    p_result->t = T_s1ap_Cause_radioNetwork;
                    p_result->u.radioNetwork = s1ap_unspecified_2; 

                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name, RRC_ERROR,
                        "[uecc_s1ap_process_handover_request ] "
                        "HO RESTRICTION LIST not present in case of multi-plmn scenario");
                        /*send HO FAILURE to MME*/
                        /* SPR 16149 Fix Start*/ 
                    uecc_s1ap_build_and_send_handover_failure(
                            p_uecc_gb_context,
                            p_ue_context,
                            p_s1ap_ue_associated_sig_msg_ind->enb_ue_s1ap_id,
                            p_msg->mme_ue_s1ap_id,
                            mme_id,
                            p_result,
                            (rrc_s1ap_error_indication_t *)PNULL);
                    /* SPR 16149 Fix Stop*/ 
                    return RRC_FAILURE;
                /*SPR 22843 Fix Start*/
                }
            }
            /*Scenario 2: In case GUMMEI is not received 
            then failure should be returned with cause s1ap_unspecified_2*/
            else
            {
                p_result->t = T_s1ap_Cause_radioNetwork;
                p_result->u.radioNetwork = s1ap_unspecified_2; 

                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "Reject HO as HO restriction list is not present and" 
                    "GUMMEI information is also missing. Cannot determine the PLMN");
                /*send HO FAILURE to MME*/
                /* SPR 16149 Fix Start*/ 
                uecc_s1ap_build_and_send_handover_failure(
                    p_uecc_gb_context,
                    p_ue_context,
                    p_s1ap_ue_associated_sig_msg_ind->enb_ue_s1ap_id,
                    p_msg->mme_ue_s1ap_id,
                    mme_id,
                    p_result,
                    (rrc_s1ap_error_indication_t *)PNULL);
                /* SPR 16149 Fix Stop*/ 
                return RRC_FAILURE;
            } 
        /*SPR 22843 Fix End*/
        }
        else
        {
            /*SPR 22843 Fix Start*/
            uecc_s1ap_generate_plmn_identity_to_int(
            &p_ue_context->plmn_identity.plmn_identity,
            (const OSOCTET *)&p_msg->gummei.pLMN_Identity.data);
            /*Scenario 3: In case GUMMEI is received 
            then the PLMN received in the GUMMEI should match 
            with the PLMN of the cell else return failure*/
            if(p_ue_context->m.source_gummei_present) 
            {
                if(RRC_NULL != memcmp_wrapper(&p_ue_context->plmn_identity.plmn_identity, 
                    &p_ue_context->p_gb_context->p_p_csc_context[index]->
                    p_csc_init_setup_ind->sib_type_1_Info.
                    cell_access_related_info.plmn_Id_info_list.
                    plmn_identity_info[0].plmn_identity,
                    sizeof(p_ue_context->plmn_identity.plmn_identity)))
                {
                    p_result->t = T_s1ap_Cause_radioNetwork;
                    p_result->u.radioNetwork = s1ap_unspecified_2; 

                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_ERROR,
                        "Reject HO as PLMN received in GUMMEI is not supported by Cell");
                    /*send HO FAILURE to MME*/
                    /* SPR 16149 Fix Start*/ 
                    uecc_s1ap_build_and_send_handover_failure(
                        p_uecc_gb_context,
                        p_ue_context,
                        p_s1ap_ue_associated_sig_msg_ind->enb_ue_s1ap_id,
                        p_msg->mme_ue_s1ap_id,
                        mme_id,
                        p_result,
                        (rrc_s1ap_error_indication_t *)PNULL);
                    /* SPR 16149 Fix Stop*/ 
                    return RRC_FAILURE;
                }
            }
            /*Scenario 4: GUMMEI is not received and cell only broadcast 1 PLMN*/
            else
            {
                /*SPR 22843 Fix End*/
                p_ue_context->plmn_identity.plmn_identity = 
                    p_ue_context->p_gb_context->p_p_csc_context[index]->
                        p_csc_init_setup_ind->sib_type_1_Info.
                        cell_access_related_info.plmn_Id_info_list.
                        plmn_identity_info[0].plmn_identity;
            }
            /*SPR 22843 Fix Start*/
        }
            /*SPR 22843 Fix End*/
        /*SPR 13677 Fix Stop*/
            }
        }

        /* Code for Trace Activation */
        if (RRC_SUCCESS != uecc_s1ap_process_handover_request_trace_handler(
                p_uecc_gb_context, p_ue_context, buffer_length, p_msg, buffer))
        {
            /* SPR 20686 Fix Start */
            p_result->t = T_s1ap_Cause_radioNetwork;
            p_result->u.radioNetwork = s1ap_unspecified_2; 
            /*send HO FAILURE to MME*/
            uecc_s1ap_build_and_send_handover_failure(
                    p_uecc_gb_context,
                    p_ue_context,
                    p_s1ap_ue_associated_sig_msg_ind->enb_ue_s1ap_id,
                    p_msg->mme_ue_s1ap_id,
                    mme_id,
                    p_result,
                    (rrc_s1ap_error_indication_t *)PNULL);

            /* SPR 20686 Fix End */
            return RRC_FAILURE;
        }

        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_S1AP_HO_REQUEST,
                p_msg);
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/* Deactivate trace Procedure end */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_handover_request
 *
 *   INPUTS       : S1AP_PDU              *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_contex
 *                  s1ap_ue_associated_sig_msg_ind_t *p_s1ap_ue_associated_sig_msg_ind
 *                  U32 buffer_length
 *                  rrc_module_id_t   dst_module_id
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes S1AP Handover Request message
 *
 *   RETURNS:     None
 *
 ******************************************************************************/
void uecc_s1ap_process_handover_request
(
 S1AP_PDU              *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context,  /* UECC global context */
 s1ap_ue_associated_sig_msg_ind_t *p_s1ap_ue_associated_sig_msg_ind, /* UE Associated Sig Msg Ind */
 U32 buffer_length,
 rrc_module_id_t   dst_module_id /*Destination Module Id */
 )
{
    rrc_ue_index_t                  ue_index = RRC_NULL;
    uecc_container_asn1_ctxt_t container_asn1_ctxt_arr;
    s1ap_Cause                       result;
    rrc_s1ap_handover_request_t msg;
    rrc_s1ap_error_indication_t error_indication;
    uecc_s1ap_error_ind_bool_t        send_err_ind;
    rrc_return_et response = RRC_FAILURE;
    uecc_ue_context_t*              p_ue_context = PNULL;
    OSCTXT asn1_ctx;
    U8 *buffer = &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0];
    U8 mme_id = p_s1ap_ue_associated_sig_msg_ind->mme_id;

    U8 index = RRC_NULL;
    rrc_cell_index_t cell_index = RRC_INVALID_CELL_INDEX;

    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_ASSERT(PNULL!=p_s1ap_pdu->u.initiatingMessage);
    RRC_ASSERT(PNULL!=p_uecc_gb_context->p_p_csc_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    memset_wrapper(&msg, RRC_NULL, sizeof(msg));
    memset_wrapper(&error_indication, RRC_NULL, sizeof(rrc_s1ap_error_indication_t));
    memset_wrapper(&send_err_ind, RRC_NULL, sizeof(uecc_s1ap_error_ind_bool_t));

    container_asn1_ctxt_arr.count = 0;
    result.t = S1AP_CAUSE_SUCCESS;

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "[s1ap_ErrorIndication] ASN context initialization failed");
        return;
    }

    do
    {
        if (PNULL == p_s1ap_pdu->u.initiatingMessage->
                value.u.handoverResourceAllocation)
        {
            result.t = T_s1ap_Cause_protocol;
            result.u.protocol = s1ap_transfer_syntax_error;

            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Handover Request ] "
                    "handoverResourceAllocation field is PNULL");
            break;
        }

        /* Decode message */
        response = rrc_s1ap_handover_request_intrl_dec(
                p_uecc_gb_context,
                &asn1_ctx,
                mme_id,
                p_s1ap_pdu->u.initiatingMessage->
                value.u.handoverResourceAllocation,
                &container_asn1_ctxt_arr,
                &msg,
                &error_indication,
                &send_err_ind);

        if (response == RRC_FAILURE)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,"[S1AP Handover Request ] Parsing error");
        }
        /* SPR 1643 Start */
        /* PLMN Identity Validation */
        if (
            RRC_S1AP_HANDOVER_REQUEST_HO_RESTRICTION_LIST_PRESENT
            &
            msg.bitmask)
        {
            if (RRC_FAILURE == validate_ho_restriction_list_plmn_identity(
                        &msg.ho_restriction_list,
                        p_uecc_gb_context))
            {
                /* PLMN ID range check error */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,"[s1ap_handover_request]:ho_restriction_list PLMN ID Range Invalid");
                result.t = T_s1ap_Cause_misc;
                result.u.misc = s1ap_unknown_PLMN;

                /* SPR 16149 Fix Start*/ 
                uecc_s1ap_build_and_send_handover_failure(
                        p_uecc_gb_context,
                        p_ue_context,
                        p_s1ap_ue_associated_sig_msg_ind->enb_ue_s1ap_id,
                        msg.mme_ue_s1ap_id,
                        mme_id,
                        &result,
                        &error_indication);
                /* SPR 16149 Fix Stop*/ 
                break;
            }
        }

        if( RRC_SOURCE_ENB_TO_TARGET_ENB_TRANSPARENT_CONTAINER_PRESENT
            &  
            msg.source_to_target_transparent_container.bitmask)
        {
          if (  RRC_FAILURE ==
              validate_source_to_target_transparent_container_plmn_identity(
                &msg.source_to_target_transparent_container.
                source_enb_to_target_enb_transparent_container,
                p_uecc_gb_context))
          {
                /* PLMN ID range check error */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,"[s1ap_handover_request]:source_to_target_transparent_container PLMN ID Range Invalid");
                result.t = T_s1ap_Cause_misc;
                result.u.misc = s1ap_unknown_PLMN;

                /* SPR 16149 Fix Start*/ 
                uecc_s1ap_build_and_send_handover_failure(
                        p_uecc_gb_context,
                        p_ue_context,
                        p_s1ap_ue_associated_sig_msg_ind->enb_ue_s1ap_id,  
                        msg.mme_ue_s1ap_id,
                        mme_id,
                        &result,
                        &error_indication);
                /* SPR 16149 Fix Stop*/ 
                break;
          }
        }
        
        /* SPR 1643 Stop */
        
        if (RRC_TRUE == send_err_ind.send_err_indication_reject_ie_present ||
                response == RRC_FAILURE)
        {
            result.t = T_s1ap_Cause_protocol;
            result.u.protocol = s1ap_abstract_syntax_error_falsely_constructed_message;

            if (RRC_S1AP_ERROR_INDICATION_MME_UE_S1AP_ID_PRESENT & error_indication.bitmask)
            {
                /* SPR 16149 Fix Start*/ 
                uecc_s1ap_build_and_send_handover_failure(
                        p_uecc_gb_context,
                        p_ue_context,
                        p_s1ap_ue_associated_sig_msg_ind->enb_ue_s1ap_id, 
                        msg.mme_ue_s1ap_id,
                        mme_id,
                        &result,
                        &error_indication);
                /* SPR 16149 Fix Stop*/ 
            }
            else
            {
                uecc_s1ap_build_and_send_err_indication(
                        p_uecc_gb_context,
                        RRC_S1AP_MODULE_ID,
                        mme_id,
                        &error_indication);
            }

            break;
        }

        /* SPR 16149 Fix Start*/ 
        if (RRC_SUCCESS != uecc_s1ap_ho_req_src_enb_to_trt_enb_transp_container(
                                p_uecc_gb_context, p_ue_context, p_s1ap_ue_associated_sig_msg_ind->enb_ue_s1ap_id, &msg, 
                                &cell_index, &result, mme_id, &index))
        {
        /* SPR 16149 Fix Stop*/ 
            break;
        }

        /* SPR 18233 Fix Start */
        if( (PNULL != p_uecc_gb_context->p_p_csc_context) && 
              (PNULL != p_uecc_gb_context->p_p_csc_context[cell_index]) &&
                (PNULL != p_uecc_gb_context->p_p_csc_context[cell_index]->p_csc_init_setup_ind) )
        {
            if (RRM_RRC_CELL_BARRED == p_uecc_gb_context->p_p_csc_context[cell_index]->
                    p_csc_init_setup_ind->sib_type_1_Info.cell_access_related_info.cell_barred ) 
            {
                result.t = T_s1ap_Cause_radioNetwork;
                result.u.radioNetwork = s1ap_cell_not_available;
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                               p_uecc_gb_context->facility_name,
                               RRC_WARNING, 
                               "[S1AP Handover Request ] Call "
                               " not allowed in Cell Barred State");
                uecc_s1ap_build_and_send_handover_failure(
                    p_uecc_gb_context,
                    p_ue_context,
                    p_s1ap_ue_associated_sig_msg_ind->enb_ue_s1ap_id, 
                    msg.mme_ue_s1ap_id,
                    mme_id,
                    &result,
                    (rrc_s1ap_error_indication_t *)PNULL);
                break;
            }
        }
        /* SPR 18233 Fix Stop */

        /* allocate UE context */
        ue_index = uecc_ue_ctx_allocate( p_uecc_gb_context, dst_module_id );

        /* Bug 650 Fix Start */
        if (( MAX_NUM_SUPPORTED_UE_PER_UECC == RRC_GET_UE_INDEX(ue_index) ) ||
             (p_uecc_gb_context->total_ue_supported == ue_index ))
        /* Bug 650 Fix End */
        {
            /* Send failure response */
            result.t = T_s1ap_Cause_radioNetwork;
            result.u.radioNetwork = 
                s1ap_no_radio_resources_available_in_target_cell;

            /* UE context allocation fail */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Handover Request ] The UE context allocation failure "
                    "- reject");

            /*send HO FAILURE to MME*/
            /* SPR 16149 Fix Start*/ 
            uecc_s1ap_build_and_send_handover_failure(
                    p_uecc_gb_context,
                    p_ue_context,
                    p_s1ap_ue_associated_sig_msg_ind->enb_ue_s1ap_id, 
                    msg.mme_ue_s1ap_id,
                    mme_id,
                    &result,
                    (rrc_s1ap_error_indication_t *)PNULL);
            /* SPR 16149  Fix Stop*/ 
            break;
        }

        /* init UE context variables, UECC FSM engine and Statistic engine */
        uecc_ue_ctx_init(p_uecc_gb_context, ue_index, RRC_INVALID_RNTI, cell_index);

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_uecc_gb_context,
                    cell_index))
        {
            /* Send failure response */
            result.t = T_s1ap_Cause_radioNetwork;
            result.u.radioNetwork = 
                s1ap_cell_not_available;

            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"Cell not available");
            /* SPR 16149 Fix Start*/ 
            uecc_s1ap_build_and_send_handover_failure(
                    p_uecc_gb_context,
                    p_ue_context,
                    p_s1ap_ue_associated_sig_msg_ind->enb_ue_s1ap_id,  
                    msg.mme_ue_s1ap_id,
                    mme_id,
                    &result,
                    (rrc_s1ap_error_indication_t *)PNULL);
            /* SPR 16149 Fix Stop*/ 
            /* SPR 20686 Fix Start */
            uecc_ue_ctx_free(p_uecc_gb_context, ue_index);
            /* SPR 20686 Fix End */

            break;
        }

        /* Get UE context */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context, ue_index);

        if (PNULL != p_ue_context)
        {
            /*BUG 604 changes start*/
            /*store the enbues1ap id received from S1AP in UE Context*/
            p_ue_context->s1ap_ue_id = 
                p_s1ap_ue_associated_sig_msg_ind->enb_ue_s1ap_id;
            /*BUG 604 changes stop*/
            if(RRC_SUCCESS != uecc_s1ap_process_handover_request_ue_context(
                        p_uecc_gb_context, p_ue_context, p_s1ap_ue_associated_sig_msg_ind, 
                        buffer_length, mme_id, &msg, &result, buffer, index))
            {
                /* SPR 20686 Fix Start */
                uecc_ue_ctx_free(p_uecc_gb_context, ue_index);
                /* SPR 20686 Fix End */
                break;
            }
        }
        else
        {
            /* Send failure response */
            result.t = T_s1ap_Cause_misc;
            result.u.misc = s1ap_unspecified;

            /*send HO FAILURE to MME*/
            /* SPR 16149  Fix Start*/ 
            uecc_s1ap_build_and_send_handover_failure(
                    p_uecc_gb_context,
                    p_ue_context,
                    p_s1ap_ue_associated_sig_msg_ind->enb_ue_s1ap_id,
                    msg.mme_ue_s1ap_id,
                    mme_id,
                    &result,
                    (rrc_s1ap_error_indication_t *)PNULL);
            /* SPR 16149 Fix Stop*/ 
            break;
        }
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&container_asn1_ctxt_arr.asn1_ctxt[0]);
    rtFreeContext(&container_asn1_ctxt_arr.asn1_ctxt[1]);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_mme_status_transfer
 *
 *   INPUTS       : S1AP_PDU              *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_contex
 *                  U8                  mme_id
 *                  s1ap_ue_associated_sig_msg_ind_t *p_s1ap_ue_associated_sig_msg_ind
 *                  U16 buffer_length
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes MME Status Transfer message
 *
 *   RETURNS:     None
 *
 ******************************************************************************/
void uecc_s1ap_process_mme_status_transfer
(
 S1AP_PDU              *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
 U8                  mme_id,
 s1ap_ue_associated_sig_msg_ind_t *p_s1ap_ue_associated_sig_msg_ind, /* UE Associated Sig Msg Ind */
/*BUG 604 changes start*/ 
 U16                 buffer_length,
 U16                 ue_index
/*BUG 604 changes stop*/ 
 )
{
    uecc_ue_context_t             *p_ue_context = PNULL;
    rrc_s1ap_mme_status_transfer_t msg;
    OSRTDListNode  *p_node_msg     = PNULL;
    s1ap_Bearers_SubjectToStatusTransferList_element *p_erab_elem = PNULL;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER           *p_event_header = PNULL;
    U32                             encoded_msg_len = 0;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_ASSERT(PNULL!=p_s1ap_pdu->u.initiatingMessage);
    /* initializing the message with all bits set to zero */
    memset_wrapper(&msg, 0 , sizeof(rrc_s1ap_mme_status_transfer_t));


    do
    {
        /* Decode message */
        if(RRC_FAILURE == rrc_s1ap_mme_status_transfer_intrl_dec(
                    p_uecc_gb_context,
                    mme_id,
                    p_s1ap_pdu->u.initiatingMessage->value.u.mMEStatusTransfer,
                    &msg))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, "MME Status Transfer"
                    "Decoding Failure, Sending Error Indication");
            break;
        }

        /* Process message */
        /* Get context using S1AP id */
        /*BUG 604 changes start*/ 
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,ue_index);
        /*BUG 604 changes stop*/ 
        if (PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP MME Status Transfer Failure] UE context not found");

            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"[S1AP MME Status Transfer Failure]"
                    "messge dropped - "
                    "UECC isn't initialized by CSC ");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }

        /*SPR 15875 Fix Start*/
        /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated )
        {
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                    (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                    (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1) &&
                    ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                    (MEDIUM == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                    (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                    (MINIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
            {
                        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), GEN_MME,"\n <msg function=\"S1AP\" name=\"MME STATUS TRANSFER\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                        difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
            }
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                    (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                    (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1) &&
                    ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                    (MEDIUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                    (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                    (MINIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
            {
                        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), GEN_CELL,"\n <msg function=\"S1AP\" name=\"MME STATUS TRANSFER\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                        difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
            }
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask (),S1,"\n <initiator type=\"MME\">%s</initiator>",
                p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);

        }
        /*SPR 15896 Fix Stop*/
        /*SPR 15875 Fix Stop*/

        for (p_node_msg = 
                msg.e_nb_status_transfer_transparent_container.bearers_SubjectToStatusTransferList.head; 
                PNULL != p_node_msg;
                p_node_msg=p_node_msg->next)
        {
            p_erab_elem = (s1ap_Bearers_SubjectToStatusTransferList_element*)p_node_msg->data;

            RRC_ASSERT(PNULL!=p_erab_elem);
            RRC_ASSERT(PNULL!=p_erab_elem->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1);

            /*SPR 15896 Fix Start*/
            if (p_ue_context->m.traceActivated )
            {       
                P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,
                        "<ie name=\"E-RABID\">%d</ie>",
                        p_erab_elem->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->e_RAB_ID);
            }
        }

        if (p_ue_context->m.traceActivated )
        {
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1, "\n</msg>");
        }
        /*SPR 15896 Fix Stop*/
        if (0!=p_ue_context->m.mme_ue_id_present)
        {
            if (msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[S1AP MME Status Transfer Failure] "
                        "mme_ue_s1ap_id (%i) != p_ue_context->mme_ue_id (%i)",
                        msg.mme_ue_s1ap_id,
                        p_ue_context->mme_ue_id);

                break;
            }

            /*Generating Protocol Events */
            /* SPR 22634 Fix - Starts */
            encoded_msg_len = (U32)(buffer_length);
            /* SPR 22634 Fix - Ends */
            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_MME_STATUS_TRANSFER,
                        MESSAGE_DIRECTION_RECEIVED);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_s1ap_ue_associated_sig_msg_ind->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, 
                                  &p_s1ap_ue_associated_sig_msg_ind->message_buff_p[0], 
                                  encoded_msg_len, "MME STATUS TRANSFER", 0);
        /* TRACE_changes_start */

        /* Call UECC_EV_S1AP_MME_STATUS_TRANSFER event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_S1AP_MME_STATUS_TRANSFER,
                &msg);

    }while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_handover_failure
 *
 *   INPUTS       : uecc_gb_context_t   *p_uecc_gb_contex
 *                  uecc_ue_context_t  *p_ue_context
 *                  U32        mme_ue_s1ap_id
 *                  U8                  mme_id
 *                  s1ap_Cause *p_cause
 *                  rrc_s1ap_error_indication_t *p_err_ind_content
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends s1ap_HandoverFailure message
 *       to S1AP
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
/* SPR 16149  Fix Start*/
rrc_return_et uecc_s1ap_build_and_send_handover_failure(
        uecc_gb_context_t  *p_uecc_gb_context,
        uecc_ue_context_t  *p_ue_context,
        U32        enb_ue_s1ap_id, 
        U32        mme_ue_s1ap_id,
        U8         mme_id,
        s1ap_Cause *p_cause,
        rrc_s1ap_error_indication_t *p_err_ind_content)
{
/* SPR 16149  Fix Stop*/
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_handover_failure_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_cause);

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "[s1ap_HandoverFailure] "
                "ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Is trace activated */
        if (PNULL != p_ue_context && p_ue_context->m.traceActivated)
        {
            /*SPR 15875 Fix Start*/
            /*SPR 15896 Fix Start*/
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                    (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                    (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
            {
                        P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_MME, "\n <msg function=\"S1AP\" name=\"Handover Failure\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                        difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
            }
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                    (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                    (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
            {
                        P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_CELL, "\n <msg function=\"S1AP\" name=\"Handover Failure\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                        difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
            }
            /*SPR 15875 Fix Stop*/
            //Trace Change Start
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
                p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
            /*SPR 15896 Fix Stop*/
            //Trace Change End
        }

        /* Reset message */
        memset_wrapper(&msg, RRC_NULL, sizeof(msg));
        memset_wrapper(sig_msg_req_buf, RRC_NULL,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */
        msg.bitmask = RRC_NULL;

        msg.mme_ue_s1ap_id = mme_ue_s1ap_id;
        msg.cause = *p_cause;

        /*SPR 15896 Fix Start*/
        if (PNULL != p_ue_context && p_ue_context->m.traceActivated)
        {
            /* SPR:5840 start */
            uecc_s1ap_p_rrc_trace_for_cause(p_ue_context,msg.cause);
            /* SPR:5840 stop */
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n </msg>");
        }
        /*SPR 15896 Fix Stop*/

        if (PNULL != p_err_ind_content) 
        {
            msg.criticality_diagnostics = p_err_ind_content->criticality_diagnostics;
            msg.bitmask |= 
                RRC_S1AP_HANDOVER_FAILURE_CRITICALITY_DIAGNOSTICS_PRESENT;
        }

        /* Encode message */
        result = rrc_s1ap_handover_failure_intrl_enc(
                p_uecc_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],
                &p_sig_msg_req->message_buff_size,
                &msg);

        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "[s1ap_HandoverFailure] "
                    "Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                                 encoded_msg_len);
            if (PNULL != p_event_header)
            {
               /* SES-508 Fix Start */
               /* Code Removed */
               /* SES-508 Fix End */
               rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_HANDOVER_FAILURE,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        if (PNULL != p_ue_context) 
        {
            /* ASN.1 encoded message to logged */
            /*SPR 15896 Fix Start*/
            rrc_trace_max_file_write(p_ue_context,HANDOVER_FAILURE,p_sig_msg_req->message_buff_size,
                &p_sig_msg_req->message_buff_p[0], S1) ;
            /*SPR 15896 Fix Stop*/
            p_sig_msg_req->cell_index = p_ue_context->cell_index;
            /*BUG 604 changes start*/
            /*Fill ue_index*/
            p_sig_msg_req->ue_index = p_ue_context->ue_index;
        }
        else
        {
            p_sig_msg_req->ue_index = RRC_INVALID_UE_INDEX;
        }
        /*BUG 604 changes stop*/ 

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_HandoverResourceAllocation;
        p_sig_msg_req->message_type = UNSUCCESSFUL_OUTCOME;
        /* SPR 16149  Fix Start*/
        p_sig_msg_req->enb_ue_s1ap_id = enb_ue_s1ap_id;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        /* SPR 16149 Fix Stop*/

        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_MME_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->mme_ue_s1ap_id = mme_ue_s1ap_id;

        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_MME_ID_PRESENT;
        p_sig_msg_req->mme_id = mme_id;

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);
        /* SPR 19929 Fix Start*/
        /*Code Removed*/
        /* SPR 19929 Fix Stop*/
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_INFO, "S1AP_MSG: HandoverFailure %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_handover_request_ack
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  s1ap_CriticalityDiagnostics *p_criticality_diagnostics
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends HO Request Ack message
 *       to S1AP module.
 *
 *   RETURNS:
 *       rrc_return_et
 *
 ******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_handover_request_ack
(
 uecc_ue_context_t*      p_ue_context,
 s1ap_CriticalityDiagnostics *p_criticality_diagnostics
 )
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_handover_request_ack_t  msg;
    s1ap_TargeteNB_ToSourceeNB_TransparentContainer 
        target_enb_to_source_enb_transparent_container;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    /* CSR 101813 Fix Start */
    ranap_TargetRNC_ToSourceRNC_TransparentContainer 
    ranap_target_rnc_to_src_rnc_transparent_cont;

    ranap_TargetBSS_ToSourceBSS_TransparentContainer
    ranap_target_bss_to_src_bss_transparent_cont;
    /* CSR 101813 Fix Stop */
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);


    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                p_ue_context->cell_index))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    if((p_ue_context->m.traceActivated) && (p_ue_context->p_ue_trace_activation_info != PNULL))
    {
        /*SPR 15875 Fix Start*/
        /*SPR 15896 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_MME,"\n <msg function=\"S1AP\" name=\"HANDOVER REQUEST ACKNOWLEDGE\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_CELL,"\n <msg function=\"S1AP\" name=\"HANDOVER REQUEST ACKNOWLEDGE\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        /*SPR 15875 Fix Stop*/
        P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
                p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
        /*SPR 15896 Fix Stop*/
    }

    if (RRC_FALSE == p_ue_context->p_gb_context->mme_connection_status)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[ s1ap_ENBStatusTransfer] MME connection isn't present");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[ s1ap_ENBStatusTransfer] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));
        asn1Init_s1ap_TargeteNB_ToSourceeNB_TransparentContainer(
                &target_enb_to_source_enb_transparent_container);

        /* CSR 101813 Fix Start */
        memset_wrapper(&ranap_target_rnc_to_src_rnc_transparent_cont, RRC_NULL,
        sizeof(ranap_TargetRNC_ToSourceRNC_TransparentContainer));
    asn1Init_ranap_TargetRNC_ToSourceRNC_TransparentContainer(
        &ranap_target_rnc_to_src_rnc_transparent_cont);

    memset_wrapper(&ranap_target_bss_to_src_bss_transparent_cont, RRC_NULL,
         sizeof(ranap_TargetBSS_ToSourceBSS_TransparentContainer));
    asn1Init_ranap_TargetBSS_ToSourceBSS_TransparentContainer(
        &ranap_target_bss_to_src_bss_transparent_cont); 
    /* CSR 101813 Fix Stop */

        /* Fill message */
        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

        if (RRC_SUCCESS != uecc_s1ap_build_s1ap_e_rab_admitted_list( 
                    p_ue_context, &asn1_ctx, &msg.e_rab_admitted_list))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ENBStatusTransfer]"
                    "uecc_s1ap_build_s1ap_e_rab_admitted_list failure");

            break;
        }

        if (p_ue_context->ho_info.p_ho_info->
                p_trg_ho_info->s1_trg_ho_info.erab_failed_list.count)
        {
            if (RRC_SUCCESS != uecc_s1ap_build_s1ap_e_rab_failed_to_setup_list( 
                        p_ue_context, 
                        &asn1_ctx, &msg.e_rab_failed_to_setup_list))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[s1ap_ENBStatusTransfer]"
                        "uecc_s1ap_build_s1ap_e_rab_failed_to_setup_list failure");

                break;
            }
            else
            {
                msg.bitmask |= 
                    RRC_S1AP_HANDOVER_REQUEST_ACK_FAILED_TO_SETUP_LIST_PRESENT;
            }
        }

        /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated)
        {
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n</msg>");
        }
        /*SPR 15896 Fix Stop*/

        /* CSR 101813 Fix Start */
    if ( HANDOVER_TYPE_UTRAN_TO_LTE == p_ue_context->ho_info.p_ho_info->ho_type )
    {
        /* SPR 21610 Fix Start */
            if (RRC_SUCCESS != uecc_s1ap_build_rrc_connection_reconfig(
                    p_ue_context,
                &ranap_target_rnc_to_src_rnc_transparent_cont,
                    &asn1_ctx))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ENBStatusTransfer]"
                    "uecc_s1ap_build_rrc_connection_reconfig failure");

                break;
            }

        /* SPR 21610 Fix End */
            if (RRC_SUCCESS != uecc_s1ap_build_rrc_ho_command(
                    p_ue_context,
                (void *)(&ranap_target_rnc_to_src_rnc_transparent_cont),
                    &asn1_ctx))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ENBStatusTransfer]"
                    "uecc_s1ap_build_rrc_ho_command_utran failure");

                break;
            }

    }
    else if ( HANDOVER_TYPE_GERAN_TO_LTE == p_ue_context->ho_info.p_ho_info->ho_type )
    {
        if (RRC_SUCCESS != uecc_s1ap_build_rrc_ho_command(
                    p_ue_context,
                    (void *)(&ranap_target_bss_to_src_bss_transparent_cont),
                    &asn1_ctx))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ENBStatusTransfer]"
                    "uecc_s1ap_build_rrc_ho_command_geran failure");

                break;
            }
    }
        else /* CSR 101813 Fix Stop */
    {
        if (RRC_SUCCESS != uecc_s1ap_build_rrc_ho_command(
                    p_ue_context,
                    (void *)(&target_enb_to_source_enb_transparent_container),
                    &asn1_ctx))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ENBStatusTransfer]"
                    "uecc_s1ap_build_rrc_ho_command failure");

            break;
        }
    }  

    /* CSR 101813 Fix Start */
    if ( HANDOVER_TYPE_UTRAN_TO_LTE == p_ue_context->ho_info.p_ho_info->ho_type )
    {
            if (RRC_SUCCESS != rrc_ranap_target_RNC_to_source_RNC_container_intrl_enc(
                    p_ue_context->p_gb_context,
                    &msg.target_to_source_transparent_container,
                    &ranap_target_rnc_to_src_rnc_transparent_cont,
                    &asn1_ctx))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ENBStatusTransfer]"
                    "rrc_ranap_target_RNC_to_source_RNC_container_intrl_enc returned failure");

                break;
            }

    }
    else if ( HANDOVER_TYPE_GERAN_TO_LTE == p_ue_context->ho_info.p_ho_info->ho_type )
    {
            if (RRC_SUCCESS != rrc_ranap_target_BSS_to_source_BSS_container_intrl_enc(
                    p_ue_context->p_gb_context,
                    &msg.target_to_source_transparent_container,
                    &ranap_target_bss_to_src_bss_transparent_cont,
                    &asn1_ctx))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ENBStatusTransfer]"
                    "rrc_ranap_target_BSS_to_source_BSS_container_intrl_enc returned failure");

            break;
        }

    }
    else
    {/* CSR 101813 Fix Stop */
        if (RRC_SUCCESS != rrc_s1ap_target_enb_to_source_enb_container_intrl_enc(
                    p_ue_context->p_gb_context,
                    &msg.target_to_source_transparent_container,
                    &target_enb_to_source_enb_transparent_container,
                    &asn1_ctx))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ENBStatusTransfer]"
                    "rrc_s1ap_target_enb_to_source_enb_"
                    "container_intrl_enc returned failure");

            break;
        }
    }
/*cr_592 changes*/
        if (RRC_TRUE == p_ue_context->trg_ho_csg_id_fail_flag)
        {
            /* fill csg_id from UE Context*/
            msg.bitmask |= RRC_S1AP_HANDOVER_REQUEST_ACK_CSG_ID_PRESENT;
            msg.csg_id.numbits = CSG_ID_BITSTRING_SIZE;
            if (PNULL != p_ue_context->p_gb_context->p_p_csc_context)
            {
                if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                        [p_ue_context->cell_index])
                {
                    if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                            [p_ue_context->cell_index]->p_csc_init_setup_ind)
                    {
                        l3_memcpy_wrapper(msg.csg_id.data,
                                p_ue_context->p_gb_context->p_p_csc_context[
                                p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                                cell_access_related_info.csg_identity,
                                CSG_ID_OCTET_SIZE);
                        msg.csg_id.data[CSG_ID_OCTET_SIZE-1] &= CSG_RESET_VAL;
                    }
                }
            }
        }

        if (PNULL != p_criticality_diagnostics)
        {
            msg.criticality_diagnostics = *p_criticality_diagnostics;
            msg.bitmask |= RRC_S1AP_HANDOVER_REQUEST_ACK_DIAGNOSTICS_PRESENT;
        }

        /* Encode message */
        result = rrc_s1ap_handover_request_ack_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],
                &p_sig_msg_req->message_buff_size,
                &msg);
        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ENBStatusTransfer] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

           rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_HANDOVER_REQUEST_ACKNOWLEDGE,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        /*SPR 15896 Fix Start*/
        rrc_trace_max_file_write(p_ue_context,HANDOVER_REQUEST_ACK,p_sig_msg_req->message_buff_size,
                      &p_sig_msg_req->message_buff_p[0], S1);
        /*SPR 15896 Fix Stop*/

        p_sig_msg_req->procedure_code = 
            ASN1V_s1ap_id_HandoverResourceAllocation;
        p_sig_msg_req->message_type = SUCCESSFUL_OUTCOME;

        p_sig_msg_req->enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;

        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_MME_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->mme_ue_s1ap_id = p_ue_context->mme_ue_id;

        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_MME_ID_PRESENT;
        p_sig_msg_req->mme_id = p_ue_context->mme_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,"S1AP_MSG: HandoverRequestAcknowledge %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));
        
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_s1ap_e_rab_admitted_list
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT *p_asn1_ctx
 *                  s1ap_E_RABAdmittedList *p_e_rab_admitted_list
 *   OUTPUTS      :
 *   DESCRIPTION:
 *       This function builds s1ap_E_RABAdmittedList
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_s1ap_e_rab_admitted_list
(
 uecc_ue_context_t* p_ue_context,
 OSCTXT *p_asn1_ctx,
 s1ap_E_RABAdmittedList *p_e_rab_admitted_list
 )
{
    uecc_ho_drb_forward_info_list_t          
        **pp_erab_trg_ho_forward_list = PNULL;
    OSRTDListNode* p_node = PNULL;
    s1ap_E_RABAdmittedList_element  *p_elem = PNULL;
    U8 e_rab_index = 0;
    U8 *p_transport_addr = PNULL;



    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_e_rab_admitted_list);
    RRC_ASSERT(PNULL != p_ue_context->ho_info.p_ho_info);
    RRC_ASSERT(PNULL != p_ue_context->ho_info.p_ho_info->p_trg_ho_info);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    asn1Init_s1ap_E_RABAdmittedList(p_e_rab_admitted_list);

        /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated)
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n<ieGroup name=\"E-RABs Admitted List \">");
    }
        /*SPR 15896 Fix Stop*/
    for (e_rab_index=0; 
            e_rab_index < MAX_ERAB_COUNT; 
            e_rab_index++)
    {
        if (PNULL == p_ue_context->p_e_rab_list[e_rab_index]) 
        {
            continue;
        }

        rtxDListAllocNodeAndData(p_asn1_ctx,
                s1ap_E_RABAdmittedList_element,
                &p_node,
                &p_elem);

        if (PNULL == p_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,"Can't allocate p_node");

            rtxDListFreeAll (p_asn1_ctx, p_e_rab_admitted_list);

            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        asn1Init_s1ap_E_RABAdmittedList_element(p_elem);
        p_elem->value.u._E_RABAdmittedItemIEs_1 =
            (s1ap_E_RABAdmittedItem*)rtxMemAlloc(p_asn1_ctx,
                    sizeof(s1ap_E_RABAdmittedItem));

        if (PNULL==p_elem->value.u._E_RABAdmittedItemIEs_1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "ASN malloc failed.");
            return RRC_FAILURE;
        }
        asn1Init_s1ap_E_RABAdmittedItem(p_elem->value.u._E_RABAdmittedItemIEs_1);
        p_elem->value.t = T13__E_RABAdmittedItemIEs_1;

        p_elem->id = ASN1V_s1ap_id_E_RABAdmittedItem;
        p_elem->criticality = s1ap_ignore;

        p_elem->value.u._E_RABAdmittedItemIEs_1->e_RAB_ID = p_ue_context->
            p_e_rab_list[e_rab_index]->e_RAB_ID;

        /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated) 
        { 

            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"E-RABID\">%d</ie>",p_elem->value.u._E_RABAdmittedItemIEs_1->e_RAB_ID);
        }
        /*SPR 15896 Fix Stop*/



        p_elem->value.u._E_RABAdmittedItemIEs_1->transportLayerAddress.numbits =
            p_ue_context->p_e_rab_list[e_rab_index]->transportLayerAddress_self.numbits;

        if(0 ==
                p_elem->value.u._E_RABAdmittedItemIEs_1->transportLayerAddress.numbits%RRC_OCTET_SIZE)
        {
            /* p_elem->value.transportLayerAddress.data */
            p_transport_addr
                =
                (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                                      (p_elem->value.u._E_RABAdmittedItemIEs_1->transportLayerAddress.numbits)/RRC_OCTET_SIZE);
            if (PNULL ==
                    p_transport_addr)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "[uecc_s1ap_build_s1ap_e_rab_admitted_list] Memory"
                        " allocation failed.");
                break;
            }

            l3_memcpy_wrapper(p_transport_addr,
                    p_ue_context->p_e_rab_list[e_rab_index]->transportLayerAddress_self.data,
                    (p_elem->value.u._E_RABAdmittedItemIEs_1->transportLayerAddress.numbits)/RRC_OCTET_SIZE);


        }
        else
        {
            /* p_elem->value.transportLayerAddress.data */
            p_transport_addr
                =
                (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                                      ((p_elem->value.u._E_RABAdmittedItemIEs_1->transportLayerAddress.numbits)/RRC_OCTET_SIZE)+1);

            if (PNULL ==
                    p_transport_addr)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "[uecc_s1ap_build_s1ap_e_rab_admitted_list] Memory"
                        " allocation failed.");
                break;
            }

            l3_memcpy_wrapper(p_transport_addr,
                    p_ue_context->p_e_rab_list[e_rab_index]->transportLayerAddress_self.data,
                    ((p_elem->value.u._E_RABAdmittedItemIEs_1->transportLayerAddress.numbits)/RRC_OCTET_SIZE)+1);
        }

        p_elem->value.u._E_RABAdmittedItemIEs_1->transportLayerAddress.data = p_transport_addr;


        p_elem->value.u._E_RABAdmittedItemIEs_1->gTP_TEID.numocts = sizeof(rrc_gtp_teid_t);

        rrc_pack_U32(p_elem->value.u._E_RABAdmittedItemIEs_1->gTP_TEID.data,
                &p_ue_context->p_e_rab_list[e_rab_index]->teid_self);

        pp_erab_trg_ho_forward_list = &p_ue_context->ho_info.
            p_ho_info->p_trg_ho_info->s1_trg_ho_info.
            p_erab_trg_ho_forward_list[0];


        if (pp_erab_trg_ho_forward_list[e_rab_index])
        {
            if ((UECC_FORWARDING_DIRECTION_UL == 
                        pp_erab_trg_ho_forward_list[e_rab_index]->
                        forward_direction) ||
                    (UECC_FORWARDING_DIRECTION_BOTH == 
                     pp_erab_trg_ho_forward_list[e_rab_index]->forward_direction))
            {
                p_elem->value.u._E_RABAdmittedItemIEs_1->uL_GTP_TEID = 
                    pp_erab_trg_ho_forward_list[e_rab_index]->
                    drb_forward_info[UL_FWD_INFO_INDEX].teid_self;

                p_elem->value.u._E_RABAdmittedItemIEs_1->uL_TransportLayerAddress = 
                    pp_erab_trg_ho_forward_list[e_rab_index]->
                    drb_forward_info[UL_FWD_INFO_INDEX].
                    transportLayerAddress;

                p_elem->value.u._E_RABAdmittedItemIEs_1->m.uL_TransportLayerAddressPresent = 1;
                p_elem->value.u._E_RABAdmittedItemIEs_1->m.uL_GTP_TEIDPresent = 1;
            }
            if ((UECC_FORWARDING_DIRECTION_DL == 
                        pp_erab_trg_ho_forward_list[e_rab_index]->
                        forward_direction) ||
                    (UECC_FORWARDING_DIRECTION_BOTH == 
                     pp_erab_trg_ho_forward_list[e_rab_index]->forward_direction))
            {
                p_elem->value.u._E_RABAdmittedItemIEs_1->dL_gTP_TEID = 
                    pp_erab_trg_ho_forward_list[e_rab_index]->
                    drb_forward_info[DL_FWD_INFO_INDEX].teid_self;

                p_elem->value.u._E_RABAdmittedItemIEs_1->dL_transportLayerAddress =
                    pp_erab_trg_ho_forward_list[e_rab_index]->
                    drb_forward_info[DL_FWD_INFO_INDEX].
                    transportLayerAddress;

                p_elem->value.u._E_RABAdmittedItemIEs_1->m.dL_transportLayerAddressPresent = 1;
                p_elem->value.u._E_RABAdmittedItemIEs_1->m.dL_gTP_TEIDPresent = 1;
            }
        }

        rtxDListAppendNode(
                p_e_rab_admitted_list,
                p_node);
    }
    /*COVERITY_FIX_20435_START*/
        /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated &&
            (PNULL != p_ue_context->p_ue_trace_activation_info || PNULL != p_ue_context->p_ue_cell_trace_activation_info)) 
    /*COVERITY_FIX_20435_END*/
    {
        P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"</ieGroup>");
    }
        /*SPR 15896 Fix Stop*/
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return RRC_SUCCESS;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_s1ap_e_rab_failed_to_setup_list
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT *p_asn1_ctx
 *                  s1ap_E_RABFailedtoSetupListHOReqAck *p_e_rab_failed_to_setup_list
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds s1ap_E_RABFailedtoSetupListHOReqAck
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_s1ap_e_rab_failed_to_setup_list
(
 uecc_ue_context_t* p_ue_context,
 OSCTXT *p_asn1_ctx,
 s1ap_E_RABFailedtoSetupListHOReqAck *p_e_rab_failed_to_setup_list
 )
{
    U16 max_erab_count = 0;
    OSRTDListNode* p_node = PNULL;
    s1ap_E_RABFailedtoSetupListHOReqAck_element  *p_elem = PNULL;
    U8 count = 0;
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
        /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated) 
    {
        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ieGroup name=\"E-RABs Failed to Setup List\">");
    }
        /*SPR 15896 Fix Stop*/

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_e_rab_failed_to_setup_list);
    RRC_ASSERT(PNULL != p_ue_context->ho_info.p_ho_info);
    RRC_ASSERT(PNULL != p_ue_context->ho_info.p_ho_info->p_trg_ho_info);

    asn1Init_s1ap_E_RABFailedtoSetupListHOReqAck(p_e_rab_failed_to_setup_list);

    max_erab_count = p_ue_context->ho_info.p_ho_info->p_trg_ho_info->
        s1_trg_ho_info.erab_failed_list.count;

    for (count = 0; 
            count < max_erab_count; 
            count++)
    {
        rtxDListAllocNodeAndData(p_asn1_ctx,
                s1ap_E_RABFailedtoSetupListHOReqAck_element,
                &p_node,
                &p_elem);

        if (PNULL == p_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,"Can't allocate p_node");

            rtxDListFreeAll (p_asn1_ctx, p_e_rab_failed_to_setup_list);

            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        asn1Init_s1ap_E_RABFailedtoSetupListHOReqAck_element(p_elem);
        p_elem->value.u._E_RABFailedtoSetupItemHOReqAckIEs_1 =
            (s1ap_E_RABFailedToSetupItemHOReqAck*)rtxMemAlloc(p_asn1_ctx,
                    sizeof(s1ap_E_RABFailedToSetupItemHOReqAck)); /* SPR_8041_fix */

        if (PNULL==p_elem->value.u._E_RABFailedtoSetupItemHOReqAckIEs_1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "ASN malloc failed.");
            return RRC_FAILURE;
        }
        asn1Init_s1ap_E_RABFailedToSetupItemHOReqAck(p_elem->value.u._E_RABFailedtoSetupItemHOReqAckIEs_1);
        p_elem->value.t = T15__E_RABFailedtoSetupItemHOReqAckIEs_1;

        p_elem->id = ASN1V_s1ap_id_E_RABFailedtoSetupItemHOReqAck;
        p_elem->criticality = s1ap_ignore;

        p_elem->value.u._E_RABFailedtoSetupItemHOReqAckIEs_1->e_RAB_ID = 
            p_ue_context->ho_info.p_ho_info->p_trg_ho_info->
            s1_trg_ho_info.erab_failed_list.
            e_rab_failed_to_add_list[count].e_rab_id;

        /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated) 
        {
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"E-RABID\">%d</ie>",p_elem->value.u._E_RABFailedtoSetupItemHOReqAckIEs_1->e_RAB_ID);
        }
        /*SPR 15896 Fix Stop*/



        p_elem->value.u._E_RABFailedtoSetupItemHOReqAckIEs_1->cause = 
            p_ue_context->ho_info.p_ho_info->p_trg_ho_info->
            s1_trg_ho_info.erab_failed_list.
            e_rab_failed_to_add_list[count].cause;

        /* SPR_8041_fix */
        rtxDListInit(&p_elem->value.u._E_RABFailedtoSetupItemHOReqAckIEs_1->iE_Extensions);
        rtxDListInit(&p_elem->value.u._E_RABFailedtoSetupItemHOReqAckIEs_1->extElem1);
        /* SPR_8041_fix */

        rtxDListAppendNode(
                p_e_rab_failed_to_setup_list,
                p_node);
    }
        /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated) 
    {
        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n</ieGroup>");
    }
        /*SPR 15896 Fix Stop*/
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return RRC_SUCCESS;
}
/* SPR 21610 Fix Start */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_rrc_connection_reconfig
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSDynOctStr         *p_handoverCommandMessage
 *                  OSCTXT              *pctxt
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and DL_DCCH_Message  message
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_s1ap_build_rrc_connection_reconfig(
        uecc_ue_context_t   *p_uecc_ue_context,
      ranap_TargetRNC_ToSourceRNC_TransparentContainer     *p_ranap_target_rnc_to_src_rnc_transparent_cont,
       OSCTXT              *pctxt        /* for memory allocation */
        )
{
    DL_DCCH_Message         dl_dcch_msg;
    rrc_return_et                  result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    U8 msg[S1AP_MAX_ASN1_BUF_LEN];


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_ranap_target_rnc_to_src_rnc_transparent_cont);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);


    do
    {
        /* Init ASN1 context */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[HandoverCommand] "
                    "ASN1 context initialization failed.");
            return RRC_FAILURE;
        }


        if (RRC_SUCCESS !=
                uecc_llim_build_ho_rrc_connection_reconfiguration(p_uecc_ue_context,
                    &dl_dcch_msg,&asn1_ctx))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[HandoverCommand] "
                    "Building rrc_connection_reconfiguration failed!!");
            break;
        }

        pu_setBuffer(&asn1_ctx, msg,  S1AP_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);

        if ( RT_OK != asn1PE_DL_DCCH_Message(&asn1_ctx, &dl_dcch_msg) )
        {
            /* Drop message */
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "[uecc_s1ap_build_rrc_con_reconfig] ASN encode failed.");
            break;
        }

        p_ranap_target_rnc_to_src_rnc_transparent_cont->rRC_Container.numocts = pe_GetMsgLen(&asn1_ctx);

        rrc_asn1PrtToStr_DL_DCCH_Message(RRC_ASN, "DL_DCCH_Message",
                &dl_dcch_msg, "RRCConnectionReconfiguration",  msg,
                p_ranap_target_rnc_to_src_rnc_transparent_cont->rRC_Container.numocts);

        p_ranap_target_rnc_to_src_rnc_transparent_cont->rRC_Container.data = (OSOCTET *)rtxMemAlloc(
                pctxt, p_ranap_target_rnc_to_src_rnc_transparent_cont->rRC_Container.numocts);

        if (PNULL == p_ranap_target_rnc_to_src_rnc_transparent_cont->rRC_Container.data)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name, RRC_FATAL,
                    "[uecc_s1ap_build_rrc_con_reconfig] "
                    "Memory allocation failed.");
            break;        
        }

        l3_memcpy_wrapper((U8 *)(p_ranap_target_rnc_to_src_rnc_transparent_cont->rRC_Container.data), 
                msg, p_ranap_target_rnc_to_src_rnc_transparent_cont->rRC_Container.numocts);

        if (PNULL != p_uecc_ue_context->p_rrm_scell_config)
        {
            rrc_mem_free(p_uecc_ue_context->p_rrm_scell_config);
            p_uecc_ue_context->p_rrm_scell_config = PNULL;
        }

        result = RRC_SUCCESS;    
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}
/* SPR 21610 Fix End */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_rrc_con_reconfig
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSDynOctStr         *p_handoverCommandMessage
 *                  OSCTXT              *pctxt
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and DL_DCCH_Message  message
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
rrc_return_et uecc_s1ap_build_rrc_con_reconfig(
        uecc_ue_context_t   *p_uecc_ue_context,
        OSDynOctStr         *p_handoverCommandMessage,
        OSCTXT              *pctxt        /* for memory allocation */
        )
{
    DL_DCCH_Message         dl_dcch_msg;
    rrc_return_et                  result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    U8 msg[S1AP_MAX_ASN1_BUF_LEN];


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_handoverCommandMessage);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);


    do
    {
        /* Init ASN1 context */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[HandoverCommand] "
                    "ASN1 context initialization failed.");
            return RRC_FAILURE;
        }


        if (RRC_SUCCESS !=
                uecc_llim_build_ho_rrc_connection_reconfiguration(p_uecc_ue_context,
                    &dl_dcch_msg,&asn1_ctx))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[HandoverCommand] "
                    "Building rrc_connection_reconfiguration failed!!");
            break;
        }

        pu_setBuffer(&asn1_ctx, msg,  S1AP_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);

        if ( RT_OK != asn1PE_DL_DCCH_Message(&asn1_ctx, &dl_dcch_msg) )
        {
            /* Drop message */
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "[uecc_s1ap_build_rrc_con_reconfig] ASN encode failed.");
            break;
        }

        p_handoverCommandMessage->numocts = pe_GetMsgLen(&asn1_ctx);

        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name, RRC_INFO,
                "RRC_MSG: RRCConnectionReconfiguration %s",
                change_data_to_str(p_handoverCommandMessage->numocts, msg));

        rrc_asn1PrtToStr_DL_DCCH_Message(RRC_ASN, "DL_DCCH_Message",
                &dl_dcch_msg, "RRCConnectionReconfiguration",  msg,
                p_handoverCommandMessage->numocts);


        p_handoverCommandMessage->data = (OSOCTET *)rtxMemAlloc(
                pctxt, p_handoverCommandMessage->numocts);

        if (PNULL == p_handoverCommandMessage->data)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name, RRC_FATAL,
                    "[uecc_s1ap_build_rrc_con_reconfig] "
                    "Memory allocation failed.");
            break;        
        }

        l3_memcpy_wrapper((U8 *)(p_handoverCommandMessage->data), 
                msg, p_handoverCommandMessage->numocts);

        if (PNULL != p_uecc_ue_context->p_rrm_scell_config)
        {
            rrc_mem_free(p_uecc_ue_context->p_rrm_scell_config);
            p_uecc_ue_context->p_rrm_scell_config = PNULL;
        }

        result = RRC_SUCCESS;    
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_rrc_ho_command
 *
 *   INPUTS       : uecc_ue_context_t   *p_uecc_ue_context
 *                  s1ap_TargeteNB_ToSourceeNB_TransparentContainer 
 *                                                         *p_transparent_container
 *                  OSCTXT         *pctxt
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and HandoverCommand  message
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
static rrc_return_et uecc_s1ap_build_rrc_ho_command(
        uecc_ue_context_t   *p_uecc_ue_context,/* CSR 101813 Fix Start */
        void            *p_container,/* CSR 101813 Fix Stop */
        OSCTXT         *pctxt
        )
{
    HandoverCommand                         ho_cmd_msg;
    rrc_return_et                           result = RRC_FAILURE;
    OSCTXT         asn1_ctx;
    U8 msg[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET  *p_data = PNULL;
    /* CSR 101813 Fix Start */
    ranap_TargetRNC_ToSourceRNC_TransparentContainer *p_utran_container = PNULL;
    ranap_TargetBSS_ToSourceBSS_TransparentContainer *p_geran_container = PNULL;
    s1ap_TargeteNB_ToSourceeNB_TransparentContainer  *p_enb_container = PNULL; 
    /* CSR 101813 Fix Stop */

    RRC_ASSERT(PNULL != p_uecc_ue_context);/* CSR 101813 Fix Start */
    RRC_ASSERT(PNULL != p_container);/* CSR 101813 Fix Stop */
    RRC_ASSERT(PNULL != pctxt);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&ho_cmd_msg, 0, sizeof(ho_cmd_msg));

    /* Init ASN1 context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[HandoverCommand] "
                "ASN1 context initialization failed.");
        return RRC_FAILURE;
    }

    do
    {
        /*Fill HandoverCommand*/
        ho_cmd_msg.criticalExtensions.t = 
            T_HandoverCommand_criticalExtensions_c1;
        ho_cmd_msg.criticalExtensions.u.c1 = 
            (HandoverCommand_criticalExtensions_c1*)
            rtxMemAllocType(&asn1_ctx, HandoverCommand);

        if (PNULL == ho_cmd_msg.criticalExtensions.u.c1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[HandoverCommand] ASN malloc failed.");
            break;
        }

        ho_cmd_msg.criticalExtensions.u.c1->t =
            T_HandoverCommand_criticalExtensions_c1_handoverCommand_r8;

        ho_cmd_msg.criticalExtensions.u.c1->u.handoverCommand_r8 = 
            rtxMemAllocType(&asn1_ctx, HandoverCommand_r8_IEs);

        if (PNULL == ho_cmd_msg.criticalExtensions.u.c1->u.handoverCommand_r8)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[HandoverCommand] ASN malloc failed.");
            break;
        }

        asn1Init_HandoverCommand_r8_IEs(ho_cmd_msg.
                criticalExtensions.u.c1->u.handoverCommand_r8);

        if (RRC_SUCCESS != uecc_s1ap_build_rrc_con_reconfig(
                    p_uecc_ue_context,
                    &ho_cmd_msg.criticalExtensions.u.c1->
                    u.handoverCommand_r8->handoverCommandMessage,
                    &asn1_ctx))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[HandoverCommand]"
                    "uecc_s1ap_build_rrc_con_reconfig failure");

            break;
        }

        /* Do ASN1 encode */
        pu_setBuffer(&asn1_ctx, msg, S1AP_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);

        if (RT_OK != asn1PE_HandoverCommand(&asn1_ctx, &ho_cmd_msg))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[HandoverCommand] ASN1 encoding failed.");
            break;
        }

    /* CSR 101813 Fix Start */
    if ( HANDOVER_TYPE_GERAN_TO_LTE == p_uecc_ue_context->ho_info.p_ho_info->ho_type )
    {
        p_geran_container = (ranap_TargetBSS_ToSourceBSS_TransparentContainer *)p_container;

        p_geran_container->numocts = (rrc_counter_t)pe_GetMsgLen(&asn1_ctx);
        p_data = (OSOCTET *)rtxMemAlloc(pctxt, 
        p_geran_container->numocts);

        if (PNULL == p_data)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name, RRC_FATAL,
                    "[HandoverCommand]Memory allocation failed.");
                break;        
            }
            
        l3_memcpy_wrapper(p_data, msg, 
                p_geran_container->numocts);

            p_geran_container->data = p_data;
    }
    else if (HANDOVER_TYPE_UTRAN_TO_LTE == p_uecc_ue_context->ho_info.p_ho_info->ho_type)
    {
        p_utran_container = (ranap_TargetRNC_ToSourceRNC_TransparentContainer *)p_container;

        p_utran_container->rRC_Container.numocts = 
            (rrc_counter_t)pe_GetMsgLen(&asn1_ctx);

        p_data = (OSOCTET *)rtxMemAlloc(pctxt, 
        p_utran_container->rRC_Container.numocts);
        if (PNULL == p_data)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name, RRC_FATAL,
                    "[HandoverCommand]Memory allocation failed.");
            break;        
        }

        l3_memcpy_wrapper(p_data, msg, 
                p_utran_container->rRC_Container.numocts);

            p_utran_container->rRC_Container.data = p_data;
    }
    else
    {   
        p_enb_container = (s1ap_TargeteNB_ToSourceeNB_TransparentContainer *)p_container;
            p_enb_container->rRC_Container.numocts = 
            (rrc_counter_t)pe_GetMsgLen(&asn1_ctx);

        p_data = (OSOCTET *)rtxMemAlloc(pctxt, 
                p_enb_container->rRC_Container.numocts);

        if (PNULL == p_data)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name, RRC_FATAL,
                    "[HandoverCommand]Memory allocation failed.");
            break;        
        }

        l3_memcpy_wrapper(p_data, msg, 
                p_enb_container->rRC_Container.numocts);

            p_enb_container->rRC_Container.data = p_data;
    }
    /* CSR 101813 Fix Stop */
        result = RRC_SUCCESS;
    }while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_handover_notify
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends  s1ap_HandoverNotify message
 *       to S1AP module.
 *
 *   RETURNS:
 *       rrc_return_et
 *
 ******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_handover_notify
(
 uecc_ue_context_t*      p_ue_context
 )
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_handover_notify_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                p_ue_context->cell_index))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    if (RRC_FALSE == p_ue_context->p_gb_context->mme_connection_status)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[ s1ap_HandoverNotify] MME connection isn't present");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[ s1ap_HandoverNotify] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Is trace activated */
        if (p_ue_context->m.traceActivated)
        {
            /*SPR 15875 Fix Start*/
            /*SPR 15896 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(),GEN_MME,"\n <msg function=\"S1AP\" name=\"Handover Notify\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(),GEN_CELL,"\n <msg function=\"S1AP\" name=\"Handover Notify\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
            /*SPR 15875 Fix Stop*/
            //Trace Change Start
            P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
              p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
            /*SPR 15896 Fix Stop*/
            //Trace Change End
        }

        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* tai.pLMNidentity  */
        msg.tai.pLMNidentity.numocts = sizeof(msg.tai.pLMNidentity.data);
        uecc_s1ap_generate_plmn_identity_int(
                msg.tai.pLMNidentity.data,
                &p_ue_context->plmn_identity.plmn_identity);  

        /* e_utran_cgi.pLMNidentity */
        msg.e_utran_cgi.pLMNidentity.numocts =
            sizeof(msg.e_utran_cgi.pLMNidentity.data); /*3*/
        if (PNULL != p_ue_context->p_gb_context->p_p_csc_context)
        {
            if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                    [p_ue_context->cell_index])
            {
                if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                        [p_ue_context->cell_index]->p_csc_init_setup_ind)
                {
                    uecc_s1ap_generate_plmn_identity_int(
                            msg.e_utran_cgi.pLMNidentity.data,
                            &p_ue_context->p_gb_context->p_p_csc_context[
                            p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.plmn_Id_info_list.
                            plmn_identity_info[0].plmn_identity);

                    l3_memcpy_wrapper(msg.tai.tAC.data,
                            p_ue_context->p_gb_context->p_p_csc_context[
                            p_ue_context->cell_index]->p_csc_init_setup_ind->
                            sib_type_1_Info.cell_access_related_info.tac,
                            sizeof(msg.tai.tAC.data));
                    msg.tai.tAC.numocts = sizeof(msg.tai.tAC.data);
                }
            }
        }

        /* Fill message */
        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
        msg.e_utran_cgi = p_ue_context->ho_info.
            p_ho_info->targetCell_ID;

            /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated) 
        {
            /* TRACE_fix */
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n<ie name=\"TAI-pLMNidentity\">%02x%02x%02x</ie>",
                    msg.tai.pLMNidentity.data[0],msg.tai.pLMNidentity.data[1],msg.tai.pLMNidentity.data[2]);
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"TAI-tac\">%02x%02x</ie>",
                    msg.tai.tAC.data[0],msg.tai.tAC.data[1]);
            if (RRC_TRACE_ACTIVATION_CELL_INITIATE & p_ue_context->m.traceActivated)
            {
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"E-UTRAN CGI-pLMNidentity\">%02x%02x%02x</ie> ",
                         msg.e_utran_cgi.pLMNidentity.data[0],msg.e_utran_cgi.pLMNidentity.data[1],
                         msg.e_utran_cgi.pLMNidentity.data[2]);
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"E-UTRAN CGI-CELL_ID\">%02x%02x%02x%x</ie>",
                                             msg.e_utran_cgi.cell_ID.data[0],
                                             msg.e_utran_cgi.cell_ID.data[1],
                                             msg.e_utran_cgi.cell_ID.data[2],
                                             msg.e_utran_cgi.cell_ID.data[3]>>4);
            }
            /* TRACE_fix */
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n </msg>");
             /*SPR 15896 Fix Stop*/
        }
        /* Encode message */
        result = rrc_s1ap_handover_notify_intrl_enc(p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],
                &p_sig_msg_req->message_buff_size,
                &msg); 
        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_HandoverNotify] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            
            rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                                 encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_HANDOVER_NOTIFY,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }
        /* ASN.1 encoded message to logged */
        /*SPR 15896 Fix Start*/
        rrc_trace_max_file_write(p_ue_context,HANDOVER_NOTIFY,p_sig_msg_req->message_buff_size,
                      &p_sig_msg_req->message_buff_p[0], S1) ;
        /*SPR 15896 Fix Stop*/


        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_HandoverNotification;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "S1AP_MSG: HandoverNotify %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));

    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}


/******************************************************************************
 *   FUNCTION NAME: get_erab_id_from_lc_id
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  rrc_lc_id_t lc_id
 *   OUTPUTS      : None
 *   DESCRIPTION:  The function returns the erab_id corresponding to an lc_id

 *
 *   RETURNS:
 *     U32   erab_id
 *
 ******************************************************************************/
U32 get_erab_id_from_lc_id
(
 uecc_ue_context_t* p_ue_context,
 rrc_lc_id_t lc_id
 )
{
    U32 erab_id = INVALID_ERAB_ID;
    U32 i = 0;

    for (i = 0; i < MAX_ERAB_COUNT; i++)
    {
        if (PNULL == p_ue_context->p_e_rab_list[i])
        {
            continue;
        }

        if (lc_id == p_ue_context->p_e_rab_list[i]->
                drb_config.logical_channel_identity)
        {
            if ( (X2_HO == p_ue_context->ho_info.s1_or_x2_handover) ||
/*BUG 604 changes start*/
                    (INTER_CELL_HO == p_ue_context->ho_info.s1_or_x2_handover) ||
                    (INTRA_CELL_HO == p_ue_context->ho_info.s1_or_x2_handover) )
/*BUG 604 changes stop*/
            {
                return (p_ue_context->p_e_rab_list[i]->uecc_x2ap_drb_ctx.e_RAB_ID);
            }
            else
            {
                return (p_ue_context->p_e_rab_list[i]->e_RAB_ID);
            }
        }
    }

    return erab_id;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_handover_command
 *
 *   INPUTS       : S1AP_PDU              *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  U8                  mme_id
 *                  U8          *p_buff
 *                  U16         buff_size
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes S1AP Handover Command message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_handover_command
(
 S1AP_PDU              *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
 U8                  mme_id,
 U8          *p_buff,        /* ASN.1 encoded message */
/*BUG 604 changes start*/ 
 U16         buff_size,      /* encoded buf size - just for check*/
 U16         ue_index
 /*BUG 604 changes stop*/ 

 )
{
    uecc_ue_context_t             *p_ue_context = PNULL;
    s1ap_ENB_UE_S1AP_ID      enb_ue_s1ap_id = 0;
    rrc_s1ap_handover_command_t msg;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    LOCAL_S1_HANDOVER_COMMAND_STRUCT    *p_s1_handover_command = PNULL;
    OSRTDListNode* p_node = PNULL;
    s1ap_E_RABList_element *p_elem = PNULL;

    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_ASSERT(PNULL!=p_s1ap_pdu->u.successfulOutcome);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    memset_wrapper(&msg, 0, sizeof(rrc_s1ap_handover_command_t));

    do
    {
        if (PNULL==p_s1ap_pdu->u.successfulOutcome->value.u.handoverPreparation)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Handover Command] handoverPreparation field is PNULL");
            break;
        }
        if( RRC_FAILURE == rrc_s1ap_get_enb_ue_s1ap_id_from_handover_command(
                    p_uecc_gb_context,
                    mme_id,
                    p_s1ap_pdu->u.successfulOutcome->value.u.handoverPreparation,
                    &enb_ue_s1ap_id
                    ))
        {

            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, " enb_ue_s1ap_id from HO Command"
                    "Decoding Failure");
            break;
        }

/*BUG 604 changes start*/ 
        p_ue_context = uecc_ue_ctx_get(
                p_uecc_gb_context,ue_index);
/*BUG 604 changes stop*/ 

        if ((PNULL==p_ue_context) || (PNULL==p_ue_context->p_gb_context))
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Handover Command] UE context not found");

            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"[S1AP_RESET_MSG_IND]"
                    "messsage dropped - "
                    "UECC isn't initialized by CSC ");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }

        /* Is trace activated */
            /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated)
        {
            /*SPR 15875 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_MME,"\n<msg function=\"S1AP\" name=\"Handover Command\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),GEN_CELL,"\n<msg function=\"S1AP\" name=\"Handover Command\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
            /*SPR 15875 Fix Stop*/
            P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), S1,"\n <initiator type=\"MME\">%s</initiator>",
                        p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);

                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"Handover-Type\">%d</ie>",msg.handover_type);
            /*SPR 15896 Fix Stop*/
        }

      if ( PNULL != p_ue_context->ho_info.p_ho_info )
      {
        /* Decode message */
        if( RRC_FAILURE == rrc_s1ap_handover_command_intrl_dec(
                    mme_id,
                    &p_ue_context->ho_info.p_ho_info->ho_s1ap_asn1_ctx,
                    p_s1ap_pdu->u.successfulOutcome->value.u.handoverPreparation,
                    &msg,
                    p_ue_context
                    ))
        {

            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, " Handover Command "
                    "Decoding Failure");
            break;
        }
            /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated)
        {
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n </msg>");
            /*SPR 15896 Fix Stop*/
        }
        if (0!=p_ue_context->m.mme_ue_id_present)
        {
            if (msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[S1AP Handover Command] "
                        "mme_ue_s1ap_id (%i) != p_ue_context->mme_ue_id (%i)",
                        msg.mme_ue_s1ap_id,
                        p_ue_context->mme_ue_id);

                break;
            }
            
            /*Generating Protocol Events LOCAL_S1_HANDOVER_COMMAND */
            p_s1_handover_command = rrc_mem_get(sizeof(LOCAL_S1_HANDOVER_COMMAND_STRUCT) + 
                    (U32)buff_size);
            if (PNULL != p_s1_handover_command)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */

                p_s1_handover_command->header.length = sizeof(LOCAL_S1_HANDOVER_COMMAND_STRUCT) + 
                    (U32)buff_size;
                p_s1_handover_command->header.event_id = LOCAL_S1_HANDOVER_COMMAND;

                if ((PNULL != p_ue_context->p_gb_context) && (PNULL != 
                            p_ue_context->p_gb_context->p_p_csc_context) && (PNULL !=
                                p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index])
                        && (PNULL != p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                            p_csc_init_setup_ind))
                {
                    l3_memcpy_wrapper(&p_s1_handover_command->header.EVENT_PARAM_CELL_ID, p_ue_context->p_gb_context->
                            p_p_csc_context[p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.cell_Id, sizeof(U32));
                }
                p_s1_handover_command->header.EVENT_PARAM_EUTRANCELL_FROID = p_s1_handover_command->
                    header.EVENT_PARAM_CELL_ID;
                if (p_ue_context->m.mme_ue_id_present)
                {
                    p_s1_handover_command->header.EVENT_PARAM_MMES1APID = p_ue_context->mme_ue_id;
                }
                p_s1_handover_command->header.EVENT_PARAM_RAC_UE_REF = p_ue_context->s1ap_ue_id;

                p_s1_handover_command->EVENT_PARAM_MESSAGE_DIRECTION = MESSAGE_DIRECTION_RECEIVED;
                p_s1_handover_command->EVENT_PARAM_L3MESSAGE_LENGTH = (U32)buff_size;

                for (p_node = msg.erab_failed_list.head; PNULL != p_node; p_node=p_node->next)
                {
                    p_elem = (s1ap_E_RABList_element*)p_node->data;
                    RRC_ASSERT(PNULL!=p_elem);

                    if (ASN1V_s1ap_id_E_RABItem != p_elem->id)
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,/*coverity_fix_ssn*/
                                p_uecc_gb_context->facility_name, RRC_WARNING,
                                "ASN1V_s1ap_id_E_RABItem ! =p_elem"
                                "->id (%i)",
                                p_elem->id);
                        break;
                    }

                    /* Filling Bitmap for Protocol Event LOCAL_S1_HANDOVER_COMMAND*/
                    p_s1_handover_command->EVENT_PARAM_HO_OUT_PREP_ERAB_FAIL_BITMAP |=
                        (1 << p_elem->value.u._E_RABItemIEs_1->e_RAB_ID);
                }

                l3_memcpy_wrapper((void*)(((U8*)p_s1_handover_command) + 
                            sizeof(LOCAL_S1_HANDOVER_COMMAND_STRUCT)),
                        (const void*)p_buff,
                        (U32)buff_size);
                
                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_s1_handover_command);
            }       
        }
        /* Added for i-Rat */
        /* ASN.1 encoded message to logged */
        /*SPR 15896 Fix Start*/
        rrc_trace_max_file_write(p_ue_context, HANDOVER_COMMAND, buff_size, p_buff, S1);

        if (msg.handover_type !=
                p_ue_context->ho_info.p_ho_info->\
                p_src_ho_info->s1_src_ho_info.\
                p_rrc_rrm_ho_required->ho_type)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Handover Command] "
                    "msg.handover_type (%d) != p_ue_context->ho_info.p_ho_info->\
                    p_src_ho_info->s1_src_ho_info.\
                    p_rrc_rrm_ho_required->ho_type (%d)",
                    msg.handover_type,
                    p_ue_context->ho_info.p_ho_info->p_src_ho_info->s1_src_ho_info.\
                    p_rrc_rrm_ho_required->ho_type);

            break;
        }

        if (PNULL != p_ue_context->p_gb_context)
        {
            /* Call UECC_EV_S1AP_HO_CMD event handler *
             * and pass API data to FSM. */
            /* WARNING. The uecc_event_queue_push_event can't be used here because
             * the stack variable is used for storing the API data
             * */
            uecc_fsm_process_event(
                    p_ue_context,
                    UECC_EV_S1AP_HO_CMD,
                    &msg);
        }
      }
      else
      {  
          RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                  p_uecc_gb_context->facility_name,
                  RRC_INFO, "Handover info stored in Ue Context is NULL");
          break;
      }
    } while (0);


    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}


/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_handover_preparation_failure
 *
 *   INPUTS       : S1AP_PDU              *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  U8                  mme_id
 *                  U8          *p_buff
 *                  U16         buff_size
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes S1AP Handover Preparation Failure message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_handover_preparation_failure
(
 S1AP_PDU              *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context,  /* UECC global context */
 U8                  mme_id,
 U8          *p_buff,        /* ASN.1 encoded message */
/*BUG 604 changes start*/ 
 U16         buff_size,      /* encoded buf size - just for check*/
 U16         ue_index
/*BUG 604 changes stop*/ 
 )
{
    uecc_ue_context_t             *p_ue_context = PNULL;
    rrc_s1ap_handover_preparation_failure_t msg;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;


    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_ASSERT(PNULL!=p_s1ap_pdu->u.unsuccessfulOutcome);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    /* initializing the msg with all bits set to zero */
    memset_wrapper(&msg, 0, sizeof(rrc_s1ap_handover_preparation_failure_t));

    do
    {
        if (PNULL == p_s1ap_pdu->u.unsuccessfulOutcome->value.u.
                handoverPreparation)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Handover Preparation Failure] "
                    "handoverPreparation field is PNULL");
            break;
        }


        /* Decode message */
        if(RRC_FAILURE == rrc_s1ap_handover_preparation_failure_intrl_dec(
                    p_uecc_gb_context,
                    mme_id, 
                    p_s1ap_pdu->u.unsuccessfulOutcome->value.u.handoverPreparation,
                    &msg
                    ))
        {

            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, " Handover Prepration Failure"
                    "Decoding Failure");
            break;
        }

        /* Process message */
/*BUG 604 changes start*/ 
        /* Get context using ue_index */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,ue_index);
/*BUG 604 changes stop*/ 

        if (PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Handover Preparation Failure] UE context not found");

            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"[S1AP Handover Preparation Failure]"
                    "message dropped -"
                    "UECC isn't initialized by CSC ");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }


        if (0!=p_ue_context->m.mme_ue_id_present)
        {
            if (msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[S1AP Handover Preparation Failure] "
                        "mme_ue_s1ap_id (%i) != p_ue_context->mme_ue_id (%i)",
                        msg.mme_ue_s1ap_id,
                        p_ue_context->mme_ue_id);

                break;
            }

            /*Generating Protocol Events LOCAL_S1_HANDOVER_PREPARATION_FAILURE */
            /* SPR 22634 Fix - Starts */
            encoded_msg_len = (U32)(buff_size);
            /* SPR 22634 Fix - Ends */
            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_HANDOVER_PREPARATION_FAILURE,
                        MESSAGE_DIRECTION_RECEIVED);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_buff,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }
        /* Is trace activated */
        if (p_ue_context->m.traceActivated )
        {
            /*SPR 15875 Fix Start*/
            /*SPR 15896 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(), GEN_MME,"\n<msg function=\"S1AP\" name=\"Handover Preparation Failure\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        /* Coverity fix 87744 start */
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
        /* Coverity fix 87744 end */
            /* SPR 12187 Fix Start */
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),S1,"\n<msg function=\"S1AP\" name=\"Handover Preparation Failure\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
            /* SPR 12187 Fix Stop */
            /*coverity_87966_fix_start*/
            P_RRC_TRACE(p_ue_context,set_all_trace_bitmask(),S1,"\n <initiator type=\"MME\">%s</initiator>",
                        p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
            /*coverity_87966_fix_end*/
                
            /* SPR:5840 start */ 
            uecc_s1ap_p_rrc_trace_for_cause(p_ue_context,msg.cause);            
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n</msg>");    
            /* SPR:5840 stop */ 
            /* ASN.1 encoded message to logged */
            rrc_trace_max_file_write(p_ue_context, HANDOVER_PREPARATION_FAILURE , buff_size, p_buff, S1);
        /*SPR 15896 Fix Stop*/
        }
        }
        /* Call UECC_EV_S1AP_HO_PREP_FAIL event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_S1AP_HO_PREPARATION_FAIL,
                &msg);

    } while (0);


    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_handover_cancel
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends s1ap_HandoverCancel message
 *       to S1AP module.
 *
 *   RETURNS:
 *       rrc_return_et
 *
 ******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_handover_cancel
(
 uecc_ue_context_t*      p_ue_context
 )
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_handover_cancel_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if (RRC_FALSE == p_ue_context->p_gb_context->mme_connection_status)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_HandoverCancel] MME connection isn't present");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_HandoverCancel] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Is trace activated */
        if (p_ue_context->m.traceActivated)
        {
            /*SPR 15875 Fix Start*/
            /*SPR 15896 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(),GEN_MME,"\n <msg function=\"S1AP\" name=\"Handover Cancel\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(),GEN_CELL,"\n <msg function=\"S1AP\" name=\"Handover Cancel\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
            /*SPR 15875 Fix Stop*/
            //Trace Change Start
            P_RRC_TRACE(p_ue_context, set_all_trace_bitmask (),S1,"\n <target type=\"MME\">%s</target>",
                p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
            /*SPR 15896 Fix Stop*/
            //Trace Change End
        }

        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */
        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
        msg.cause = p_ue_context->ho_info.cause;

            /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated) 
        {
            
            /* SPR:5840 start */ 
            uecc_s1ap_p_rrc_trace_for_cause(p_ue_context,msg.cause);            
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n</msg>");      
            /* SPR:5840 stop */ 
        }
            /*SPR 15896 Fix Stop*/

        /* Encode message */
        result = rrc_s1ap_handover_cancel_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],
                &p_sig_msg_req->message_buff_size,
                &msg); 
        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_HandoverCancel] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                                 encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_HANDOVER_CANCEL,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

    /*SPR 15896 Fix Start*/
        rrc_trace_max_file_write(p_ue_context,HANDOVER_CANCEL,p_sig_msg_req->message_buff_size,
                      &p_sig_msg_req->message_buff_p[0],S1);
    /*SPR 15896 Fix Stop*/

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_HandoverCancel;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "S1AP_MSG: HandoverCancel %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));

    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_src_to_trg_container_secondary
 *
 *   DESCRIPTION:
 *       This function builds Src to Trg Container Secondary
 *       for HandoverRequired message
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
static rrc_return_et uecc_s1ap_build_src_to_trg_container_secondary(
        uecc_ue_context_t*      p_ue_context,
        rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required,
        rrc_s1ap_handover_required_t    *p_msg,
        OSCTXT                  *p_asn1_ctx)
{
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    if(p_rrc_rrm_ho_required->bitmask
            & RRC_RRM_UE_HO_ADM_RE_SRC_TO_TARGET_CONTAINER_SECONDARY_PRESENT)
    {   
        /* SRVCC start */
        p_msg->bitmask |= 
            RRC_S1AP_HANDOVER_REQUIRED_SOURCE_TO_TARGET_TRANSPARENT_CONTAINER_SECONDARY_PRESENT;
        /* SRVCC stop */
        /***** HO for CS and PS domain *****/
        if( CS_PS_TYPE == p_msg->srvcc_ho_indication) 
        {
            /* Secondary Container:  Fill old BSS to New Bss information */
            if( RRC_SUCCESS != uecc_s1ap_fill_old_bss_to_new_bss_info_container(
                        p_asn1_ctx,
                        p_msg,
                        p_ue_context,
                        &p_rrc_rrm_ho_required->source_to_target_container_secondary,
                        CS_PS_TYPE))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[uecc_s1ap_fill_old_bss_to_new_bss_info_container]"
                        " Fail to fill old_bss_to_new_bss_info_container]");
                return RRC_FAILURE;
            }
        }
        /***** HO for CS domain*****/
        else if(CS_ONLY_TYPE == p_msg->srvcc_ho_indication)
        {
            /* filling target ID start */
            p_msg->target_id.t = T_s1ap_TargetID_cGI;
            p_msg->target_id.u.cGI = rtxMemAllocType(p_asn1_ctx,
                    s1ap_CGI );
            if ( PNULL ==  p_msg->target_id.u.cGI)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "[s1ap_HandoverRequired] Fail to allocate memory]");
                return RRC_FAILURE;
            }
            uecc_s1ap_build_s1ap_Target_CGI(
                    p_ue_context->p_gb_context, 
                    p_rrc_rrm_ho_required,
                    /*SPR 17777 +-*/
                    p_msg->target_id.u.cGI);


            /* Primary Container:  Fill old BSS to New Bss information */
            if( RRC_SUCCESS != uecc_s1ap_fill_old_bss_to_new_bss_info_container(
                        p_asn1_ctx,
                        p_msg,
                        p_ue_context,
                        &p_rrc_rrm_ho_required->source_to_target_container_secondary,
                        CS_ONLY_TYPE))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[uecc_s1ap_fill_old_bss_to_new_bss_info_container]"
                        " Fail to fill old_bss_to_new_bss_info_container]");
                return RRC_FAILURE;
            } 
        }
        else
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_HandoverRequired] Invalid SRVCC \
                    information exists");
            return RRC_FAILURE;
        }
    }
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_src_to_trg_container
 *
 *   DESCRIPTION:
 *       This function builds Src to Trg Container for HandoverRequired message
 *
 *   RETURNS:
 *       RRC_FAILURE/RRC_SUCCESS
 *
 ******************************************************************************/
static rrc_return_et uecc_s1ap_build_src_to_trg_container(
        uecc_ue_context_t*      p_ue_context,
        rrc_rrm_ho_required_t *p_rrc_rrm_ho_required,
        rrc_s1ap_handover_required_t    *p_msg,
        OSCTXT                  *p_asn1_ctx)
{
    U16       bitmask = 0;

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    if(p_rrc_rrm_ho_required->bitmask
            &RRC_RRM_UE_HO_ADM_RE_SRC_TO_TARGET_CONTAINER_PRESENT )
    {
        bitmask = p_rrc_rrm_ho_required->source_to_target_container.bitmask;
        /* check if enb */
        if (bitmask & SOURCE_TO_TARGET_TRANSPARENT_ENB_CONTAINER_PRESENT)
        {
            if(RRC_SUCCESS != 
                    uecc_s1ap_build_sourceENB_to_targetENB_transparent_container(
                        p_msg, p_ue_context, p_asn1_ctx, p_rrc_rrm_ho_required))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR, "[s1ap_HandoverRequired]"
                        "Failed to build sourceENB_to_targetENB_container");
                return RRC_FAILURE;
            }
        }    
        else if( bitmask & SOURCE_TO_TARGET_TRANSPARENT_RNC_CONTAINER_PRESENT)
        {
            /* Fill RNC Container */
            if(RRC_SUCCESS != 
                    uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container(
                        p_msg, p_ue_context, p_asn1_ctx, p_rrc_rrm_ho_required))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR, "[s1ap_HandoverRequired]"
                        "Failed to build sourceRNC_to_targetRNC_container");
                return RRC_FAILURE;
            }
        }
        else if (bitmask & SOURCE_TO_TARGET_TRANSPARENT_BSS_CONTAINER_PRESENT)
        {
            /* filling target ID */
            p_msg->target_id.t = T_s1ap_TargetID_cGI;
            p_msg->target_id.u.cGI = rtxMemAllocType(p_asn1_ctx,
                    s1ap_CGI );

            if ( PNULL ==  p_msg->target_id.u.cGI)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "[s1ap_HandoverRequired] Fail to allocate memory]");
                return RRC_FAILURE;
            }
            /*SPR 15896 Fix Start*/
            if (p_ue_context->m.traceActivated )
            {
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"Target ID-Type\">%d</ie>",p_msg->target_id.t);
            /*SPR 15896 Fix Stop*/
            }

            uecc_s1ap_build_s1ap_Target_CGI(
                    p_ue_context->p_gb_context,
                    p_rrc_rrm_ho_required,
                    /*SPR 17777 +-*/
                    p_msg->target_id.u.cGI);

            /* Fill Primary Container : Source BSS To Target BSS Container */
            if( RRC_SUCCESS != uecc_s1ap_fill_source_bss_to_target_bss_container 
                    (
                     p_asn1_ctx,
                     p_ue_context,
                     p_msg))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[uecc_s1ap_fill_source_bss_to_target_bss_container]"
                        " Fail to fill source_bss_to_target_bss_container]");
                return RRC_FAILURE;
            }
        }
        else if( bitmask & OLD_TO_NEW_TRANSPARENT_BSS_CONTAINER_PRESENT)
        {
            if( CS_ONLY_TYPE == p_msg->srvcc_ho_indication) 
            {
                /* SRVCC start */
                /* filling target ID start */
                p_msg->target_id.t = T_s1ap_TargetID_cGI;
                p_msg->target_id.u.cGI = rtxMemAllocType(p_asn1_ctx,s1ap_CGI );
                if ( PNULL ==  p_msg->target_id.u.cGI)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_FATAL,"[s1ap_HandoverRequired] Fail to allocate memory]");
                    return RRC_FAILURE;
                }
                uecc_s1ap_build_s1ap_Target_CGI(
                        p_ue_context->p_gb_context,
                        p_rrc_rrm_ho_required,
                        /*SPR 17777 +-*/
                        p_msg->target_id.u.cGI);
                /* SRVCC stop */

                /* Fill old to new bss container */
                if( RRC_SUCCESS != uecc_s1ap_fill_old_bss_to_new_bss_info_container(
                            p_asn1_ctx,
                            p_msg,
                            p_ue_context,
                            &p_rrc_rrm_ho_required->source_to_target_container.old_to_new_bssContainer,
                            CS_ONLY_TYPE))
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR, "[s1ap_HandoverRequired]"
                            "Failed to build oldBSS_to_newBSS_container");
                    return RRC_FAILURE;
                }
            }
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_handover_required_trace_handler
 *
 *   DESCRIPTION:
 *       This function handles TraceActivation for HandoverRequired message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
static void uecc_s1ap_build_and_send_handover_required_trace_handler(
        uecc_ue_context_t*      p_ue_context,
        rrc_rrm_ho_required_t *p_rrc_rrm_ho_required)
{
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    U8 plmn_id[3];
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&plmn_id, 0, 3);
    if (p_ue_context->m.traceActivated)
    {
        /*SPR 15875 Fix Start*/
            /*SPR 15896 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), GEN_MME, "\n<msg function=\"S1AP\" name=\"Handover Required\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                    P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), GEN_CELL, "\n<msg function=\"S1AP\" name=\"Handover Required\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        /*SPR 15875 Fix Stop*/

        //Trace Change Start
        P_RRC_TRACE(p_ue_context, set_all_trace_bitmask (),S1,"\n <target type=\"MME\">%s</target>",
                p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
        //Trace Change End

        /* SPR 15783 Start */
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"cause type\">%d</ie> ",p_rrc_rrm_ho_required->cause.type - 1);
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"cause value\">%d</ie> ",p_rrc_rrm_ho_required->cause.value);
        /* SPR 15783 Stop */
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"Handover Type\">%d</ie> ",p_rrc_rrm_ho_required->ho_type);
            /* SPR:5904 start */
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(),S1,"\n <ieGroup name=\"Target ID\">");
            if(RRM_TARGET_ID_ENB_ID_PRESENT & p_rrc_rrm_ho_required->target_id.bitmask)
            {
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ieGroup name=\"Enb ID\">");
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ieGroup name=\"Global Enb ID\">");

                uecc_s1ap_generate_plmn_identity_int(plmn_id, &p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.plmn_identity);
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"PLMN\">%02x%02x%02x</ie>",
                        plmn_id[0], plmn_id[1], plmn_id[2]);

                if( MACRO_ENB_ID == p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_type)
                {
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"Cell Identity\">%02x%02x%x</ie> ",
                            p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_identity[0],
                            p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_identity[1],
                            p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_identity[2]>>4);
                }
                else 
                {
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"Cell Identity\">%02x%02x%02x%x</ie> ",
                            p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_identity[0],
                            p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_identity[1],
                            p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_identity[2],
                            p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_identity[3]>>4);
                }
                if (EUTRAN_CELL_GLOBAL_IDENTITY_PRESENT & p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.bitmask)
                {
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"ECGI\">%02x%02x%02x%02x</ie> ",
                            p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.ecgi[0],
                            p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.ecgi[1],
                            p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.ecgi[2],
                            p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.ecgi[3]);
                }
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"Cell Type\">%02x</ie> ",
                        p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_type);
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n </ieGroup>"); //Global Enb ID... IE group Close.

                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ieGroup name=\"Tracking Area ID\">");
                uecc_s1ap_generate_plmn_identity_int(plmn_id, &p_rrc_rrm_ho_required->target_id.enb_id.tracking_area_id.plmn_identity);
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"PLMN\">%02x%02x%02x</ie>",
                        plmn_id[0], plmn_id[1], plmn_id[2]);
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(),S1,"\n <ie name=\"Tracking Area Code\">%02x%02x</ie> ",
                        p_rrc_rrm_ho_required->target_id.enb_id.tracking_area_id.tracking_area_code[0],
                        p_rrc_rrm_ho_required->target_id.enb_id.tracking_area_id.tracking_area_code[1]);
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n </ieGroup>"); //Tracking Area ID... IE group Close.
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n </ieGroup>"); //Enb ID... IE group Close.
            }

            else if(RRM_TARGET_ID_RNC_ID_PRESENT & p_rrc_rrm_ho_required->target_id.bitmask)
            {
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ieGroup name=\"RNC ID\">");
                uecc_s1ap_generate_plmn_identity_int(plmn_id, &p_rrc_rrm_ho_required->target_id.rnc_id.lai.plmn_identity);
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"PLMN\">%02x%02x%02x</ie>",
                        plmn_id[0], plmn_id[1], plmn_id[2]);
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"Location Area Code\">%02x%02x</ie> ",
                        p_rrc_rrm_ho_required->target_id.rnc_id.lai.location_area_code[0],
                        p_rrc_rrm_ho_required->target_id.rnc_id.lai.location_area_code[1]);
                if(RRM_RNC_ROUTING_AREA_CODE_PRESENT & p_rrc_rrm_ho_required->target_id.rnc_id.bitmask)
                {
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"Routing Area Code\">%02x</ie> ",
                            p_rrc_rrm_ho_required->target_id.rnc_id.routing_area_code);
                }
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"RNC ID\">%02x</ie> ",
                        p_rrc_rrm_ho_required->target_id.rnc_id.rnc_id);
                if(RRM_RNC_EXTENDED_RNC_ID_PRESENT & p_rrc_rrm_ho_required->target_id.rnc_id.bitmask)
                {
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"Extended RNC ID\">%02x</ie> ",
                            p_rrc_rrm_ho_required->target_id.rnc_id.extended_rnc_id);
                }
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n </ieGroup>"); //RNC ID... IE group Close.
            }

            else if(RRM_TARGET_ID_CGI_PRESENT & p_rrc_rrm_ho_required->target_id.bitmask)
            {
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ieGroup name=\"CGI\">");
                uecc_s1ap_generate_plmn_identity_int(plmn_id, &p_rrc_rrm_ho_required->target_id.cgi.plmn_identity);
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"PLMN\">%02x%02x%02x</ie>",
                        plmn_id[0], plmn_id[1], plmn_id[2]);

                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"Location Area Code\">%02x%02x</ie> ",
                        p_rrc_rrm_ho_required->target_id.cgi.location_area_code[0],
                        p_rrc_rrm_ho_required->target_id.cgi.location_area_code[1]);

                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"CI Info\">%02x%02x</ie> ",
                        p_rrc_rrm_ho_required->target_id.cgi.ci_info[0],
                        p_rrc_rrm_ho_required->target_id.cgi.ci_info[1]);

                if (RRM_CGI_INFO_ROUTING_AREA_CODE & p_rrc_rrm_ho_required->target_id.cgi.bitmask)
                {
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"Routing Area Code\">%02x</ie> ",
                            p_rrc_rrm_ho_required->target_id.cgi.routing_area_code);
                }

                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n </ieGroup>"); // CGI ...IE Group close
            }
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(),S1,"\n </ieGroup>"); // Target ID ... IE Group close
            /* SPR:5904 start */
            /*SPR 15896 Fix Stop*/
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_handover_required
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends s1ap_HandoverRequired message
 *       to S1AP module.
 *
 *   RETURNS:
 *       rrc_return_et
 *
 ******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_handover_required
(
 uecc_ue_context_t*      p_ue_context
 )
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    /* getting ho required messge */
    rrc_rrm_ho_required_t *p_rrc_rrm_ho_required = PNULL; 
    rrc_s1ap_handover_required_t    msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;
    /*SPR 14320 Fix Start*/
    U8   temp_container[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET                         *p_data = PNULL;
    UE_Radio_Capability_RAT_Container_t *p_ue_radio_capability = PNULL;
    RAT_Type rat_type;
    /*SPR 14320 Fix Stop*/

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                p_ue_context->cell_index))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    if (PNULL ==  p_ue_context->ho_info.p_ho_info->p_src_ho_info->
            s1_src_ho_info.p_rrc_rrm_ho_required)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_HandoverRequired] p_rrc_rrm_ho_required is NULL");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    /* assigning the p_rrc_rrm_ho_required */
    p_rrc_rrm_ho_required =  p_ue_context->ho_info.p_ho_info->
        p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required;

    if (RRC_FALSE == p_ue_context->p_gb_context->mme_connection_status)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_HandoverCancel] MME connection isn't present");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_HandoverCancel] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Is trace activated */
        uecc_s1ap_build_and_send_handover_required_trace_handler(
                p_ue_context, p_rrc_rrm_ho_required);

        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,(sizeof(s1ap_ue_associated_sig_msg_req_t) 
              + S1AP_MAX_ASN1_BUF_LEN));

        /* Fill message */
        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
        /*SPR_16778_START*/
        if( RRC_SUCCESS != fill_s1ap_cause(&msg.cause,&p_rrc_rrm_ho_required->cause,p_ue_context))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                 (p_ue_context->p_gb_context)->facility_name,
                 RRC_ERROR,
             "[s1ap_HandoverRequired] p_rrc_rrm_ho_required->cause is invalid");
            /*SPR_18125_START*/
            rtFreeContext(&asn1_ctx);
            /*SPR_18125_END*/
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
        }
        /*SPR_16778_END*/

        msg.handover_type = p_rrc_rrm_ho_required->ho_type;

        /*cr_407 filling srvcc ho indication */
        if ( p_rrc_rrm_ho_required->bitmask 
                & RRC_RRM_UE_HO_ADM_REQ_SRVCC_HO_INDICATION_PRESENT )
        {
            msg.bitmask |= 
                RRC_S1AP_HANDOVER_REQUIRED_SRVCC_HO_INDICATION_PRESENT;

            /* This check is redundant as the value received from RRM for
             * p_rrc_rrm_ho_required->srvcc_ho_indication in this case
             * must be CS_ONLY.*/
            if ((RRC_RRM_UE_HO_ADM_REQ_PS_SERVICE_NOT_AVAILABLE_PRESENT &
                        p_rrc_rrm_ho_required->bitmask) && 
                    (CS_PS_TYPE == p_rrc_rrm_ho_required->srvcc_ho_indication))
            {
                /* This must not happen!!!*/
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR, "[s1ap_HandoverRequired]"
                        "Target Cell supports DTM HO but does not support DTM");
                break;    
            }
           /* SRVCC start */
            if((HANDOVER_TYPE_LTE_TO_GERAN == p_rrc_rrm_ho_required->ho_type) &&
                        ((RRC_RRM_UE_HO_ADM_REQ_PS_SERVICE_NOT_AVAILABLE_PRESENT &
                          p_rrc_rrm_ho_required->bitmask) ||
                    (!(p_ue_context->m.dtm_r9_present))))
           /* SRVCC stop */
            {
                msg.bitmask |=
                    RRC_S1AP_HANDOVER_REQUIRED_PS_SERVICE_NOT_AVAILABLE_PRESENT;

                msg.ps_service_not_available =  p_rrc_rrm_ho_required->\
                                                ps_service_not_available;
            }
            msg.srvcc_ho_indication =  p_rrc_rrm_ho_required->\
                                       srvcc_ho_indication;
        }

        /*Fill src to target container*/
        if (RRC_SUCCESS != uecc_s1ap_build_src_to_trg_container(
                            p_ue_context, p_rrc_rrm_ho_required, &msg, &asn1_ctx))
        {
            break;
        }

        /*Fill src to target container Secondary*/
        if (RRC_SUCCESS != uecc_s1ap_build_src_to_trg_container_secondary(
                            p_ue_context, p_rrc_rrm_ho_required, &msg, &asn1_ctx))
        {
            break;
        }
        /*SPR 14320 Fix Start*/
        if((HANDOVER_TYPE_LTE_TO_GERAN == p_rrc_rrm_ho_required->ho_type) &&
             (RRC_S1AP_HANDOVER_REQUIRED_SRVCC_HO_INDICATION_PRESENT &
                msg.bitmask))
        {
            memset_wrapper(temp_container,0, S1AP_MAX_ASN1_BUF_LEN);

            /* 2. fill MS Classmark 2*/
            rat_type = geran_cs;
            p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t *) 
                ylFind(&p_ue_context->ue_radio_capability,
                        &rat_type, 
                        uecc_rat_type_keyof, 
                        uecc_rat_type_compare);
            if (p_ue_radio_capability != PNULL)
            {
                if(RRC_TRUE == p_ue_radio_capability->valid_rat_string)
                {

                    msg.ms_classmark2.numocts =  MS_CLASSMARK_2_OCTETS;
                    /* fill IE : as per 48008 spec */
                    temp_container[0] = MS_CLASSMARK_2_IE;

                    /* fill length */
                    temp_container[1] = MS_CLASSMARK_2_LENGTH;

                    /* fill contents */
                    l3_memcpy_wrapper(&(temp_container[2]),\
                           &(p_ue_radio_capability->p_rat_string[2]),\
                            MS_CLASSMARK_2_LENGTH);

                    /* Copy data from temp_container to ms_classmark2.data */ 
                    p_data = (U8*)rtxMemAlloc(&asn1_ctx, msg.ms_classmark2.numocts);

                    l3_memcpy_wrapper(p_data,temp_container, msg.ms_classmark2.numocts);

                    msg.ms_classmark2.data = p_data;

                    memset_wrapper(temp_container,0, S1AP_MAX_ASN1_BUF_LEN);

                    msg.bitmask |= RRC_S1AP_HANDOVER_REQUIRED_MS_CLASSMARK2_PRESENT;

                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,
                            "[rrc_s1ap_old_bss_to_new_bss_information_intrl_enc]"
                            "Encoding successful for ms_classmark2");

                    /* 3. fill MS Classmark 3*/
                    msg.ms_classmark3.numocts =  HEADER_IE_PLUS_LENGTH +\
                                                    (p_ue_radio_capability->numocts -\
                                                     MS_CLASSMARK_2_OCTETS);

                    /* fill IE : as per 48008 spec */
                    temp_container[0] = MS_CLASSMARK_3_IE; 

                    /* fill Length */
                    temp_container[1] = (U8)((p_ue_radio_capability->numocts) -\
                            MS_CLASSMARK_2_OCTETS);

                    /* fill contents */
                    l3_memcpy_wrapper(&(temp_container[2]),\
                            &(p_ue_radio_capability->p_rat_string[5]),\
                            ((p_ue_radio_capability->numocts)- MS_CLASSMARK_2_OCTETS));

                    /* Copy data from temp_container to ms_classmark3.data */ 
                    p_data = (U8*)rtxMemAlloc(&asn1_ctx, msg.ms_classmark3.numocts);

                    l3_memcpy_wrapper(p_data,temp_container, msg.ms_classmark3.numocts);

                    msg.ms_classmark3.data = p_data;

                    msg.bitmask |= RRC_S1AP_HANDOVER_REQUIRED_MS_CLASSMARK3_PRESENT;

                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,
                            "[rrc_s1ap_old_bss_to_new_bss_information_intrl_enc]"
                            "Encoding successful for ms_classmark3");
                }
                else
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "[uecc_s1ap_fill_old_bss_to_new_bss_info_container]"
                            "Wrong Rat Type GERAN_CS should present");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
            }
            else
            { 
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "[uecc_s1ap_fill_old_bss_to_new_bss_info_container]"
                        "UE radio capability not found");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
        }
        /*SPR 14320 Fix Stop*/

        /* filling direct_forward_path_available */
        if ( p_rrc_rrm_ho_required->bitmask 
                & RRC_RRM_UE_HO_ADM_REQ_DIRECT_FORWARD_PATH_AVAILABLE_PRESENT )
        {
            msg.bitmask |= RRC_S1AP_HANDOVER_REQUIRED_DIRECT_FORWARDING_PATH_AVAILABILITY_PRESENT;
            msg.direct_forwarding_path_availability = p_rrc_rrm_ho_required->direct_fwd_path_available;
        }

        if (PNULL != p_ue_context->p_gb_context->p_p_csc_context)
        {
            if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                    [p_ue_context->cell_index])
            {
                if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                        [p_ue_context->cell_index]->p_csc_init_setup_ind)
                {
                    /* cr_592 filling CSG ID */
                    if( p_ue_context->p_gb_context->p_p_csc_context[
                            p_ue_context->cell_index]->
                            p_csc_init_setup_ind->sib_type_1_Info.cell_access_related_info.
                            presence_bitmask & CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG )
                    {
                        if ( (1 == p_ue_context->m.rel_of_mme_present) &&
                             (RRC_MME_REL9 <= p_ue_context->rel_of_mme) &&
                              (p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_CSG_ID_PRESENT))
                        {
                            msg.bitmask |= RRC_S1AP_HANDOVER_REQUIRED_CSG_ID_PRESENT;
                            msg.csg_id.numbits = CSG_ID_BITSTRING_SIZE;
                            l3_memcpy_wrapper(msg.csg_id.data,
                                   p_rrc_rrm_ho_required->csg_identity,
                                   CSG_ID_OCTET_SIZE);

                            msg.csg_id.data[CSG_ID_OCTET_SIZE-1] &= CSG_RESET_VAL;
                        }
                    }
                }
            }
        }
        //filling Cell access mode 
        if(( p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_HO_ADM_REQ_CELL_ACCESS_MODE_PRESENT )
            && ( RRC_HYBRID == p_rrc_rrm_ho_required->cell_access_mode ) && 
            (1 == p_ue_context->m.rel_of_mme_present) && (RRC_MME_REL9 <= p_ue_context->rel_of_mme))
        {
           msg.bitmask |= RRC_S1AP_HANDOVER_REQUIRED_CELL_ACCESS_MODE_PRESENT;
           msg.cell_access_mode = s1ap_hybrid; 
        }

        /* encoding the handover required messgae */

        result = rrc_s1ap_handover_required_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],
                &p_sig_msg_req->message_buff_size,
                &msg);
        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_HandoverRequired] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

            rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_HANDOVER_REQUIRED,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }
        /* ASN.1 encoded message to logged */
    /*SPR 15896 Fix Start*/
        rrc_trace_max_file_write(p_ue_context, HANDOVER_REQUIRED,
                p_sig_msg_req->message_buff_size,
                &p_sig_msg_req->message_buff_p[0], S1);
    /*SPR 15896 Fix Stop*/

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_HandoverPreparation;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* Send message HO Required to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "S1AP_MSG: HandoverRequired %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));

    } while (0);

            /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated)
        P_RRC_TRACE(p_ue_context, set_all_trace_bitmask (),S1,"\n </msg>");
            /*SPR 15896 Fix Stop*/

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);


    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}



/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_s1ap_TargeteNB_ID
 *
 *   INPUTS       : rrc_rrm_ho_required_t   *p_rrc_rrm_ho_require
 *                  OSCTXT            *p_asn1_ctx 
 *                  s1ap_TargeteNB_ID *p_target_enb_id
 *                  uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds s1ap_TargeteNB_ID 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_s1ap_TargeteNB_ID(
        rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required, 
        OSCTXT            *p_asn1_ctx,
        s1ap_TargeteNB_ID *p_target_enb_id, 
        uecc_ue_context_t *p_ue_context
        )
{

    RRC_ASSERT(PNULL!=p_rrc_rrm_ho_required);
    RRC_ASSERT(PNULL!=p_asn1_ctx);
    RRC_ASSERT(PNULL!=p_target_enb_id);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    asn1Init_s1ap_TargeteNB_ID(p_target_enb_id);

    /* filling the plmn id */

    /* copy the count field */
    p_target_enb_id->global_ENB_ID.pLMNidentity.numocts
        = MCC_OCTET_SIZE;
    uecc_s1ap_generate_plmn_identity_int(
            p_target_enb_id->global_ENB_ID.pLMNidentity.data,
            &(p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.
                plmn_identity));

    /* copy cell_identity */
    /* set the value as macro eNB type */
    /* SPR 2330 Start */
    if (MACRO_ENB_ID ==
            p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.cell_type)
    {
        p_target_enb_id->global_ENB_ID.eNB_ID.t = T_s1ap_ENB_ID_macroENB_ID;

        if (PNULL == (p_target_enb_id->global_ENB_ID.eNB_ID.u.macroENB_ID = 
                    rtxMemAllocType(p_asn1_ctx,ASN1BitStr32)))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[s1ap_HandoverRequired] Fail to allocate memory]");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    
        memset_wrapper(p_target_enb_id->global_ENB_ID.
                eNB_ID.u.macroENB_ID, RRC_NULL, sizeof(ASN1BitStr32));
        /* pick a pointer to tergeteNB_ID */
        p_target_enb_id->global_ENB_ID.eNB_ID.u.macroENB_ID->numbits 
            = 8*sizeof(p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.
                    cell_identity);  
        p_target_enb_id->global_ENB_ID.eNB_ID.u.macroENB_ID->numbits =
            (p_target_enb_id->global_ENB_ID.eNB_ID.u.macroENB_ID->numbits 
             < MAX_MACRO_CELL_ID_BITS ?
             p_target_enb_id->global_ENB_ID.eNB_ID.u.macroENB_ID->numbits 
             : MAX_MACRO_CELL_ID_BITS);
        l3_memcpy_wrapper(p_target_enb_id->global_ENB_ID.eNB_ID.
                u.macroENB_ID->data,
                p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.
                cell_identity,
                (p_target_enb_id->global_ENB_ID.eNB_ID.u.macroENB_ID->numbits/8 +1)); 

    }
    else
    {
        p_target_enb_id->global_ENB_ID.eNB_ID.t = T_s1ap_ENB_ID_homeENB_ID;

        if (PNULL == (p_target_enb_id->global_ENB_ID.eNB_ID.u.homeENB_ID = 
                    rtxMemAllocType(p_asn1_ctx,ASN1BitStr32)))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[s1ap_HandoverRequired] Fail to allocate memory]");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    
        memset_wrapper(p_target_enb_id->global_ENB_ID.
                eNB_ID.u.homeENB_ID, RRC_NULL, sizeof(ASN1BitStr32));
        /* pick a pointer to tergeteNB_ID */
        p_target_enb_id->global_ENB_ID.eNB_ID.u.homeENB_ID->numbits 
            = 8*sizeof(p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.
                    cell_identity);  
        p_target_enb_id->global_ENB_ID.eNB_ID.u.homeENB_ID->numbits =
            (p_target_enb_id->global_ENB_ID.eNB_ID.u.homeENB_ID->numbits 
             < MAX_HOME_CELL_ID_BITS ?
             p_target_enb_id->global_ENB_ID.eNB_ID.u.homeENB_ID->numbits 
             : MAX_HOME_CELL_ID_BITS);
        l3_memcpy_wrapper(p_target_enb_id->global_ENB_ID.eNB_ID.
                u.homeENB_ID->data,
                p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.
                cell_identity,
                (p_target_enb_id->global_ENB_ID.eNB_ID.u.homeENB_ID->numbits/8 +1)); 
    }
    /* SPR 2330 Stop */
    /* copy the plmn of TAC */
    p_target_enb_id->selected_TAI.pLMNidentity.numocts = MCC_OCTET_SIZE;
    uecc_s1ap_generate_plmn_identity_int(
            p_target_enb_id->selected_TAI.pLMNidentity.data,
            &(p_rrc_rrm_ho_required->target_id.enb_id.tracking_area_id.
                plmn_identity));
    /* copy the s1ap_TAC */ 
    p_target_enb_id->selected_TAI.tAC.numocts = sizeof(
            p_rrc_rrm_ho_required->target_id.enb_id.tracking_area_id.
            tracking_area_code);
    l3_memcpy_wrapper(p_target_enb_id->selected_TAI.tAC.data,
            p_rrc_rrm_ho_required->target_id.enb_id.tracking_area_id.
            tracking_area_code,
            p_target_enb_id->selected_TAI.tAC.numocts);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_HandoverPreparationInformation 
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT            *p_asn1_ctx
 *                  HandoverPreparationInformation_r8_IEs  *p_handover_prep_info
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds HandoverPreparationInformation_r8_IEs 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_HandoverPreparationInformation(
        uecc_ue_context_t *p_ue_context,
        OSCTXT            *p_asn1_ctx,
        HandoverPreparationInformation_r8_IEs  *p_handover_prep_info
        )
{
    rrm_srb_info_t      srb_info;
    mib_info_t          mib_info;
    rrm_rrc_container_t *p_rrc_container = PNULL;
    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL!= p_ue_context);
    RRC_ASSERT(PNULL!=p_asn1_ctx);
    RRC_ASSERT(PNULL!=p_handover_prep_info);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                p_ue_context->cell_index))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    /* initialization with zero */
    memset_wrapper(&srb_info, 0, sizeof(srb_info));
    memset_wrapper(&mib_info, 0, sizeof(mib_info));
    asn1Init_UE_CapabilityRAT_ContainerList(&p_handover_prep_info->ue_RadioAccessCapabilityInfo);

    if ( RRC_SUCCESS != uecc_s1ap_build_UE_CapabilityRAT_ContainerList(
                p_ue_context,
                p_asn1_ctx,
                &p_handover_prep_info->ue_RadioAccessCapabilityInfo))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_HandoverRequired] Fail to fill "
                "CapabilityRAT_ContainerList");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }


    /* filling AS Config */

    asn1Init_AS_Config(&p_handover_prep_info->as_Config);
    p_handover_prep_info->m.as_ConfigPresent = 1;
    /* filling meas config */

    /* meas reconfig change */
    if (p_ue_context->curr_meas_config.is_meas_config_valid ==
            RRM_RRC_MC_VALIDATE_SUCCESS )  
    {
        if (RRC_SUCCESS != uecc_llim_build_CurrMeasConfig(
                    p_ue_context,
                    &p_ue_context->curr_meas_config,
                    p_asn1_ctx,
                    &p_handover_prep_info->as_Config.sourceMeasConfig))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_HandoverRequired] Fail to fill MeasConfig Parameter");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }


    /* fill Proximity Configuration */
    if ( p_ue_context->m.proximity_config_present )
    {
        asn1Init_OtherConfig_r9 (&p_handover_prep_info->as_Config.
            sourceOtherConfig_r9);

        p_handover_prep_info->as_Config.m._v2ExtPresent = 1;

        p_handover_prep_info->as_Config.sourceOtherConfig_r9.m.
            reportProximityConfig_r9Present = 1;

        if ( p_ue_context->proximity_config.bitmask & RRM_PROXIMITY_IND_EUTRA_PRESENT )
        {
            p_handover_prep_info->as_Config.sourceOtherConfig_r9.
                reportProximityConfig_r9.proximityIndicationEUTRA_r9 = 
                p_ue_context->proximity_config.proximity_ind_eutra;

            p_handover_prep_info->as_Config.sourceOtherConfig_r9.
                reportProximityConfig_r9.m.proximityIndicationEUTRA_r9Present = 1;
        }

        if ( p_ue_context->proximity_config.bitmask & RRM_PROXIMITY_IND_UTRA_PRESENT )
        {
            p_handover_prep_info->as_Config.sourceOtherConfig_r9.
                reportProximityConfig_r9.proximityIndicationUTRA_r9 = 
                p_ue_context->proximity_config.proximity_ind_utra;

            p_handover_prep_info->as_Config.sourceOtherConfig_r9.
                reportProximityConfig_r9.m.proximityIndicationUTRA_r9Present = 1;
        }

    }

    /* need to fill srb1 */
    /* filling sourceRadioResourceConfig */


    if ( p_ue_context->m.srb1_config_present)
    {
        srb_info.bitmask |= RRM_SRB_INFO_SRB1_CONFIG_PRESENT;
        srb_info.srb1_config = p_ue_context->srb1_config;
    }   
    if(p_ue_context->m.srb2_config_present)
    {
        srb_info.bitmask |= RRM_SRB_INFO_SRB2_CONFIG_PRESENT;
        srb_info.srb2_config = p_ue_context->srb2_config;
    }    

    /* Fill RadioResourceConfigDedicated*/
    if (RRC_SUCCESS != uecc_llim_build_asn1_radio_resource_cfg_dedicated_during_src_ho(
                p_ue_context,
                &p_handover_prep_info->as_Config.sourceRadioResourceConfig,
                &srb_info,
                p_asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_HandoverRequired] Fail to fill "
                "sourceRadioResourceConfig Parameter");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }       

    /* filling sourceSecurityAlgorithmConfig */
    p_handover_prep_info->as_Config.sourceSecurityAlgorithmConfig.
        cipheringAlgorithm =  
        p_ue_context->configure_ciphering.algorithm_id;
    p_handover_prep_info->as_Config.sourceSecurityAlgorithmConfig.
        integrityProtAlgorithm = 
        p_ue_context->configure_integrity_protection.algorithm_id;


    /* Filling CRNTI */
    /* 8 - size of OCTET */
    p_handover_prep_info->as_Config.sourceUE_Identity.numbits 
        =  8 *sizeof(p_ue_context->crnti);

    rrc_pack_U16(
            p_handover_prep_info->as_Config.sourceUE_Identity.data,
            &p_ue_context->crnti);


    if (PNULL != p_ue_context->p_gb_context->p_p_csc_context)
    {
        if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                [p_ue_context->cell_index])
        {
            if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                    [p_ue_context->cell_index]->p_csc_init_setup_ind)
            {
                /* filling mibs information */
                mib_info = p_ue_context->p_gb_context->p_p_csc_context[
                    p_ue_context->cell_index]->p_csc_init_setup_ind->
                    mib_info;

                asn1Init_MasterInformationBlock (&p_handover_prep_info->as_Config.
                        sourceMasterInformationBlock);
                p_handover_prep_info->as_Config.sourceMasterInformationBlock.
                    dl_Bandwidth = mib_info.dl_band_width;
                p_handover_prep_info->as_Config.sourceMasterInformationBlock.
                    phich_Config.phich_Duration = mib_info.phich_config.phich_duration;
                p_handover_prep_info->as_Config.sourceMasterInformationBlock.
                    phich_Config.phich_Resource = mib_info.phich_config.phich_resource;

                /* fix length in form of numofbits for parameter systemFrameNumber */
                p_handover_prep_info->as_Config.sourceMasterInformationBlock.
                    systemFrameNumber.numbits = 8;

                p_handover_prep_info->as_Config.sourceMasterInformationBlock.
                    systemFrameNumber.data[0] =0x10;

                p_handover_prep_info->as_Config.sourceMasterInformationBlock.
                    schedulingInfoSIB1_BR_r13  = 0;

                /* fix length in form of numofbits for parameter spare */
                p_handover_prep_info->as_Config.sourceMasterInformationBlock.
                    spare.numbits = 4;
                p_handover_prep_info->as_Config.sourceMasterInformationBlock.
                    spare.data[0] = 0x00;

                /* filling sib1 information */
                if( RRC_SUCCESS != uecc_m_check_and_convert_sib1
                        (p_asn1_ctx,
                         &(p_handover_prep_info->as_Config.
                             sourceSystemInformationBlockType1),
                         &(p_ue_context->p_gb_context->p_p_csc_context[
                             p_ue_context->cell_index]->p_csc_init_setup_ind->
                             sib_type_1_Info),
                             p_ue_context))
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,"Fail to fill sib1");
                    return RRC_FAILURE;
                }
                /* filling sib2 */
                if( RRC_SUCCESS != uecc_m_check_and_convert_sib2(
                            p_asn1_ctx,
                            &(p_handover_prep_info->as_Config.sourceSystemInformationBlockType2),
                            &(p_ue_context->p_gb_context->p_p_csc_context[
                                p_ue_context->cell_index]->p_csc_init_setup_ind->
                                sib_type_2_Info),p_ue_context))
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,"Fail to fill sib2");
                    return RRC_FAILURE;
                }

                /* filling sourceDl_CarrierFreq */
                p_handover_prep_info->as_Config.sourceDl_CarrierFreq = 
                    p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                    p_csc_init_setup_ind-> eutra_dl_carrier_freq;

               /* SPR 3052 Start */
               switch(p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                                   p_csc_init_setup_ind->num_of_antennas)
              {
                 case 1:
                     p_handover_prep_info->
                       as_Config.antennaInfoCommon.antennaPortsCount = an1;
                     break;
                 case 2:
                     p_handover_prep_info->
                      as_Config.antennaInfoCommon.antennaPortsCount = an2;
                     break;
                 case 4:
                     p_handover_prep_info->
                      as_Config.antennaInfoCommon.antennaPortsCount = an4;
                     break;
                 default:
                     RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                             RRC_ERROR, "Invalid Num of Antenna in global context = %u",
                             p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->
                               cell_index]->p_csc_init_setup_ind->num_of_antennas);
                     return RRC_FAILURE;        
              }
              /* SPR 3052 Stop */

                
                /*Filling SCellToAddModList_r10 in AS_Config*/
                if ( (PNULL != p_ue_context->p_scell_config) && 
                        (p_ue_context->p_scell_config->bitmask & RRM_SCELL_ADD_MOD_LIST_PRESENT))
                {
                    p_handover_prep_info->as_Config.m._v3ExtPresent = 1;
                    p_handover_prep_info->as_Config.m.sourceSCellConfigList_r10Present = RRC_TRUE;

                    result =  uecc_llim_build_asn1_add_modify_scell_config(p_ue_context,
                             &p_ue_context->p_scell_config->scell_add_mod_list,
                             &p_handover_prep_info->as_Config.sourceSCellConfigList_r10,
                             p_asn1_ctx);
                    if (result != RRC_SUCCESS)
                    {
                        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                (p_ue_context->p_gb_context)->facility_name,
                                RRC_ERROR,"Failed to fill scell config info");
                        return result;

                    }
                }
                        

                p_rrc_container = &(p_ue_context->ho_info.p_ho_info->p_src_ho_info->
                        s1_src_ho_info.p_rrc_rrm_ho_required->source_to_target_container.
                        eNBContainer.rrc_container);
                /* filling RRM Config */
                if ((p_ue_context->ho_info.p_ho_info->p_src_ho_info->bitmask
                            & MAC_UE_INACTIVE_TIME_PRESENT) ||
                        ((p_rrc_container->bitmask & RRM_RRC_CONTAINER_RRM_CONFIG_PRESENT) &&
                         (p_rrc_container->rrm_config.bitmask & 
                          RRM_CONFIG_EXT_CANDIDATE_CELL_INFO_LIST_PRESENT)))
                {
                    asn1Init_RRM_Config(&p_handover_prep_info->rrm_Config);
                    p_handover_prep_info->m.rrm_ConfigPresent = 1;
                    p_handover_prep_info->rrm_Config.m.ue_InactiveTimePresent = 1;
                    p_handover_prep_info->rrm_Config.ue_InactiveTime = 
                        p_ue_context->ho_info.p_ho_info->p_src_ho_info-> 
                        ue_inactive_time;

                    result = uecc_s1ap_fill_candidiate_cell_info_list(p_ue_context ,
                            p_asn1_ctx, &p_handover_prep_info->rrm_Config, 
                            p_rrc_container);
                    if (result != RRC_SUCCESS)
                    {
                        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                (p_ue_context->p_gb_context)->facility_name,
                                RRC_ERROR,"Failed to fill candidate cell info list");
                        return result;
                    }

                    rtxDListInit(&p_handover_prep_info->rrm_Config.extElem1);
                }

                /* filling as context */
                p_rrc_container = &(p_ue_context->ho_info.p_ho_info->p_src_ho_info->
                        s1_src_ho_info.p_rrc_rrm_ho_required->source_to_target_container.
                        eNBContainer.rrc_container);
                asn1Init_AS_Context(&p_handover_prep_info->as_Context);
                p_handover_prep_info->m.as_ContextPresent = 1;
                p_handover_prep_info->as_Context.m.reestablishmentInfoPresent = 1;
                p_handover_prep_info->as_Context.reestablishmentInfo.sourcePhysCellId
                    = p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->
                    cell_index]->p_csc_init_setup_ind->phys_cell_id;

                p_handover_prep_info->as_Context.reestablishmentInfo.
                    targetCellShortMAC_I.numbits
                    = 8*sizeof(p_ue_context->ho_info.p_ho_info->p_src_ho_info->
                            target_cell_short_mac_i.short_mac_i);

                rrc_pack_U16(
                        p_handover_prep_info->as_Context.reestablishmentInfo
                        .targetCellShortMAC_I.data,
                        &p_ue_context->ho_info.p_ho_info->p_src_ho_info->
                        target_cell_short_mac_i.short_mac_i);

            }
        }
    }
    /* fill additionalReestabInfoList */

        /* check if additionalReestablishment information present */
    if ((PNULL != p_rrc_container) && (p_rrc_container->bitmask & 
            RRM_RRC_CONTAINER_TARGET_CELL_IDENTITY_LIST_PRESENT) &&
              (p_ue_context->ho_info.p_ho_info->p_src_ho_info->
                count_short_mac_i > 0))
        {
            p_handover_prep_info->as_Context.reestablishmentInfo.
                m.additionalReestabInfoListPresent= 1;
            if ( RRC_SUCCESS != uecc_s1ap_build_AdditionalReestabInfoList(
                        p_ue_context,
                        p_asn1_ctx,
                        &p_handover_prep_info->as_Context.reestablishmentInfo.
                        additionalReestabInfoList))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[s1ap_HandoverRequired] Fail to fill "
                        "additionalReestabInfoList");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
        }
    p_handover_prep_info->m.nonCriticalExtensionPresent = 0;

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
} 

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_UE_CapabilityRAT_ContainerList
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT *p_asn1_ctx
 *                  This function builds UE_CapabilityRAT_ContainerList
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds UE_CapabilityRAT_ContainerList
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_UE_CapabilityRAT_ContainerList(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        UE_CapabilityRAT_ContainerList *p_ue_capability_list 
        )
{
    OSRTDListNode* p_node = PNULL;
    UE_CapabilityRAT_Container *p_elem = PNULL;
    UE_Radio_Capability_RAT_Container_t *p_ue_radio_capability = PNULL;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/

    RRC_ASSERT(PNULL!=p_ue_context);
    RRC_ASSERT(PNULL!=p_asn1_ctx);
    RRC_ASSERT(PNULL!=p_ue_capability_list);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    asn1Init_UE_CapabilityRAT_ContainerList(p_ue_capability_list);

    for (p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t*) 
         ylFirst (&p_ue_context->ue_radio_capability);
         p_ue_radio_capability; 
         p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t*) 
            ylNext((YLNODE*)p_ue_radio_capability))
    {
        rtxDListAllocNodeAndData(p_asn1_ctx,
                UE_CapabilityRAT_Container,
                &p_node,
                &p_elem);

        if (PNULL==p_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,"Can't allocate p_node");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        asn1Init_UE_CapabilityRAT_Container(p_elem);


        if ( RRC_TRUE == p_ue_radio_capability->valid_rat_string )
        {
            p_elem->rat_Type = p_ue_radio_capability->rat_type;

            /* SPR 1237 fix start */
            p_elem->ueCapabilityRAT_Container.numocts = 
                p_ue_radio_capability->numocts;
            /* SPR 1237 fix stop */

            p_elem->ueCapabilityRAT_Container.data =
                (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                                      p_elem->ueCapabilityRAT_Container.numocts);
            if (PNULL== p_elem->ueCapabilityRAT_Container.data)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL, "ASN malloc failed.");
                return RRC_FAILURE;
            }
            l3_memcpy_wrapper((void*)(p_elem->ueCapabilityRAT_Container.data),
                        /* SPR 13502 Fix Start */
                   (U8 *)(p_ue_radio_capability->p_rat_string),
                        /* SPR 13502 Fix Stop */
                    p_elem->ueCapabilityRAT_Container.numocts);

            rtxDListAppendNode(p_ue_capability_list, p_node);
        }

    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_AdditionalReestabInfoList
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT *p_asn1_ctx
 *                  AdditionalReestabInfoList *p_additional_re_estab_list
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds AdditionalReestabInfoList 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_AdditionalReestabInfoList(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        AdditionalReestabInfoList *p_additional_re_estab_list 
        )
{
    OSRTDListNode* p_node = PNULL;
    AdditionalReestabInfo *p_elem = PNULL;
    short_mac_i_info_list_t *p_short_mac_i = PNULL;
    rrc_counter_t count = 0;


    RRC_ASSERT(PNULL!=p_ue_context);
    RRC_ASSERT(PNULL!=p_asn1_ctx);
    RRC_ASSERT(PNULL!=p_additional_re_estab_list);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    asn1Init_AdditionalReestabInfoList(p_additional_re_estab_list);

    rtxDListAllocNodeAndData(p_asn1_ctx,
            AdditionalReestabInfo,
            &p_node,
            &p_elem);

    if (PNULL==p_node)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,"Can't allocate p_node");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }


    for (count =0;count < p_ue_context->ho_info.p_ho_info->p_src_ho_info->
            count_short_mac_i; count++)
    {
        asn1Init_AdditionalReestabInfo(p_elem);

        p_short_mac_i = &(p_ue_context->ho_info.p_ho_info->
                p_src_ho_info->short_mac_I[count]);

        /* storing cell_identity */
        p_elem->cellIdentity.numbits = 28;

        l3_memcpy_wrapper(((void*)p_elem->cellIdentity.data),
                ((const void *)p_short_mac_i->cell_identity),
                p_elem->cellIdentity.numbits/8+1);

        /* storing macI information */
        p_elem->shortMAC_I.numbits = 8*sizeof(p_short_mac_i->short_mac_i);


        rrc_pack_U16(
                p_elem->shortMAC_I.data,
                &p_short_mac_i->short_mac_i);


        p_elem->key_eNodeB_Star.numbits =256;
        memset_wrapper(p_elem->key_eNodeB_Star.data,0,32);

        rtxDListAppendNode(p_additional_re_estab_list, p_node);
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_s1ap_E_RABInformationList
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT *p_asn1_ctx
 *                  s1ap_E_RABInformationList *p_erab_info_list
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds s1ap_E_RABInformationList
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_s1ap_E_RABInformationList(
        uecc_ue_context_t* p_ue_context,
        OSCTXT *p_asn1_ctx,
        s1ap_E_RABInformationList *p_erab_info_list
        )
{
    OSRTDListNode* p_node = PNULL;
    s1ap_E_RABInformationList_element *p_elem = PNULL;
    rrc_erab_list_t     *p_erab_list = PNULL;
    rrc_counter_t   count = 0, inner_count = 0;


    RRC_ASSERT(PNULL!=p_ue_context);
    RRC_ASSERT(PNULL!=p_asn1_ctx);
    RRC_ASSERT(PNULL!=p_erab_info_list);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    asn1Init_s1ap_E_RABInformationList(p_erab_info_list);

    p_erab_list = &(p_ue_context->ho_info.p_ho_info->p_src_ho_info->
            s1_src_ho_info.p_rrc_rrm_ho_required->source_to_target_container
            .eNBContainer.erab_dl_fwding_list); 
    for (count = 0; count < MAX_ERAB_COUNT; count++) 
    {
        if(PNULL == p_ue_context->p_e_rab_list[count])
            continue;
        rtxDListAllocNodeAndData(p_asn1_ctx,
                s1ap_E_RABInformationList_element,
                &p_node,
                &p_elem);

        if (PNULL==p_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,"Can't allocate p_node");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        asn1Init_s1ap_E_RABInformationList_element(p_elem);
        p_elem->value.u._E_RABInformationListIEs_1 =
            (s1ap_E_RABInformationListItem*)rtxMemAlloc(p_asn1_ctx,
                    sizeof(s1ap_E_RABInformationListItem));

        if (PNULL==p_elem->value.u._E_RABInformationListIEs_1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "ASN malloc failed.");
            return RRC_FAILURE;
        }
        asn1Init_s1ap_E_RABInformationListItem(p_elem->value.u._E_RABInformationListIEs_1);
        /* SPR 21660 changes start */
        p_elem->value.t = T178__E_RABInformationListIEs_1;//T171__E_RABInformationListIEs_1
        /* SPR 21660 changes end */
        p_elem->id = ASN1V_s1ap_id_E_RABInformationListItem;
        p_elem->criticality = s1ap_ignore;
        p_elem->value.u._E_RABInformationListIEs_1->m.dL_ForwardingPresent = 0;
        for(inner_count = 0; inner_count < p_erab_list->erab_count;
                inner_count++)
        {
            if (p_ue_context->p_e_rab_list[count]->e_RAB_ID ==  
                    p_erab_list->erab_id[inner_count])
            {
                p_elem->value.u._E_RABInformationListIEs_1->m.dL_ForwardingPresent = 1;
                /* SPR_6545 start */
                p_elem->value.u._E_RABInformationListIEs_1->dL_Forwarding = 0;
                /* SPR_6545 stop */
            }
        }
        p_elem->value.u._E_RABInformationListIEs_1->e_RAB_ID = p_ue_context->p_e_rab_list[count]->e_RAB_ID;
        p_elem->value.u._E_RABInformationListIEs_1->m.iE_ExtensionsPresent = 0;

        rtxDListAppendNode(p_erab_info_list, p_node);
    }


    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return RRC_SUCCESS;
}

/*srvcc-u start*/
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_s1ap_Irat_meas_config_info 
 *
 *   INPUTS       : irat_meas_config_t   irat_meas_config
 *                  OSCTXT                      *p_asn1_ctx
 *                  ranap_IRAT_Measurement_Configuration  *p_asn_irat_meas_config
 *                  uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds IRAT meas confog info and fill the various values
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_s1ap_Irat_meas_config_info(
        rrm_source_rnc_to_target_rnc_transparent_container_t *p_rnc_container,
        OSCTXT                      *p_asn1_ctx,
        ranap_IRAT_Measurement_Configuration  *p_asn_irat_meas_config,
        uecc_ue_context_t           *p_ue_context
        )
{
    OSRTDListNode  *p_node = PNULL;
    U8             loop_count = 0;
    ranap_EUTRANFrequencies_element  *p_eutra_freq_elem = PNULL;

    p_asn_irat_meas_config->m.iE_ExtensionsPresent = 0;
    
    /* Filling RSRP  */
    if(IRAT_MEAS_CONFIG_PARAM_RSRP_PRESENT & p_rnc_container->irat_meas_config.bitmask)
    {
        p_asn_irat_meas_config->m.rSRPPresent = 1;
        p_asn_irat_meas_config->rSRP = p_rnc_container->irat_meas_config.rsrp;
    }

    /* Filling RSRQ */
    if(IRAT_MEAS_CONFIG_PARAM_RSRQ_PRESENT &  p_rnc_container->irat_meas_config.bitmask)
    {
        p_asn_irat_meas_config->m.rSRQPresent = 1;
        p_asn_irat_meas_config->rSRQ = p_rnc_container->irat_meas_config.rsrq;
    }
 
    /* Filling MeasurementDuration */
    p_asn_irat_meas_config->iRATmeasurementParameters.measurementDuration = 
         p_rnc_container->irat_meas_config.irat_meas_param.meas_duration;
    
    p_asn_irat_meas_config->iRATmeasurementParameters.m.iE_ExtensionsPresent =0;

    /* Filling EUTRA_FREQ_LIST */
    if(IRAT_MEAS_PARAM_EUTRA_FREQ_LIST_PRESENT &  
            p_rnc_container->irat_meas_config.irat_meas_param.bitmask)
    {
        rtxDListInit(&p_asn_irat_meas_config->iRATmeasurementParameters.eUTRANFrequencies);

        p_asn_irat_meas_config->iRATmeasurementParameters.m.eUTRANFrequenciesPresent =1;
        
        for(loop_count = 0; 
                loop_count < p_rnc_container->irat_meas_config.irat_meas_param.eutra_freq_list.count;
                loop_count++)
        {
            rtxDListAllocNodeAndData(p_asn1_ctx, ranap_EUTRANFrequencies_element, 
                    &p_node, &p_eutra_freq_elem);
            if (PNULL == p_node)
            {
                /* Node Allocation failure, Free Node and return Failure */
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "[uecc_s1ap_build_s1ap_Irat_meas_config_info]"
                        "Can't allocate p_node");
                rtxDListFreeAll(p_asn1_ctx, 
                        &p_asn_irat_meas_config->iRATmeasurementParameters.eUTRANFrequencies);
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            asn1Init_ranap_EUTRANFrequencies_element(p_eutra_freq_elem);
        
            p_eutra_freq_elem->m.iE_ExtensionsPresent = 0;

            /* Filling EARFCN */
            p_eutra_freq_elem->earfcn =  
                p_rnc_container->irat_meas_config.irat_meas_param.eutra_freq_list.
                eutra_freq[loop_count].e_arfcn;

            /* Filling Measurement Bandwidth */
            if(E_UTRA_FREQ_MEASUREMENT_BAND_WIDTH_PRESENT & 
                    p_rnc_container->irat_meas_config.irat_meas_param.eutra_freq_list.
                    eutra_freq[loop_count].bitmask)
            {
                p_eutra_freq_elem->m.measBandPresent = 1;
                p_eutra_freq_elem->measBand = 
                    (U8)p_rnc_container->irat_meas_config.irat_meas_param.eutra_freq_list.
                    eutra_freq[loop_count].measurement_bandwidth;
            }
            rtxDListAppendNode(&p_asn_irat_meas_config->iRATmeasurementParameters.
                    eUTRANFrequencies, p_node);
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}
/*srvcc-u stop*/
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_s1ap_UE_HistoryInformation
 *
 *   INPUTS       : ue_history_t                *p_ue_history_at_rrc_rrm_intf
 *                  OSCTXT                      *p_asn1_ctx
 *                  s1ap_UE_HistoryInformation  *p_ue_history_info
 *                  uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds s1ap_UE_HistoryInformation and fill the various
 *          details regarding UE History either from UE context or values 
 *          received from RRM.
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_s1ap_UE_HistoryInformation(
        ue_history_t                *p_ue_history_at_rrc_rrm_intf,
        OSCTXT                      *p_asn1_ctx,
        s1ap_UE_HistoryInformation  *p_ue_history_info,
        uecc_ue_context_t           *p_ue_context
        )
{
    OSRTDListNode               *p_node = PNULL;
    s1ap_LastVisitedCell_Item   *p_elem = PNULL;
    last_visited_cell_list_t    *p_last_visited_cell_list= PNULL;
    rrc_counter_t               count = 0;
    last_visited_e_utran_cell_information_t
        *p_last_visited_e_utran_cell_information = PNULL;
    last_visited_utran_cell_information_t
        *p_last_visited_utran_cell_information= PNULL;

    RRC_ASSERT(PNULL!=p_asn1_ctx);
    RRC_ASSERT(PNULL!=p_ue_history_info);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    asn1Init_s1ap_UE_HistoryInformation(p_ue_history_info);
    p_last_visited_cell_list = 
        &(p_ue_history_at_rrc_rrm_intf->last_visited_cell_list);

    for (count = 0; count<p_last_visited_cell_list->count; count++) 
    {
        rtxDListAllocNodeAndData(p_asn1_ctx,
                s1ap_LastVisitedCell_Item,
                &p_node,
                &p_elem);

        if (PNULL==p_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,"Can't allocate p_node");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        asn1Init_s1ap_LastVisitedCell_Item(p_elem);

        if(p_last_visited_cell_list->last_visited_cell_info[count].bitmask
                & LAST_VISITED_CELL_INFO_E_UTRAN_CELL_INFORMATION_PRESENT )
        {
            p_last_visited_e_utran_cell_information = 
                &(p_last_visited_cell_list->last_visited_cell_info[count].
                        last_visited_e_utran_cell_information);
            p_elem->t = T_s1ap_LastVisitedCell_Item_e_UTRAN_Cell;

            /* memory allocation */
            p_elem->u.e_UTRAN_Cell =
                (s1ap_LastVisitedEUTRANCellInformation*)
                rtxMemAlloc(p_asn1_ctx,
                        sizeof(s1ap_LastVisitedEUTRANCellInformation));
            if (PNULL==  p_elem->u.e_UTRAN_Cell)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL, "ASN malloc failed.");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }

            asn1Init_s1ap_LastVisitedEUTRANCellInformation(p_elem->u.e_UTRAN_Cell);
            p_elem->u.e_UTRAN_Cell->m.iE_ExtensionsPresent = 0;

            /* copy plmn identity */
            p_elem->u.e_UTRAN_Cell->global_Cell_ID.pLMNidentity.numocts = MCC_OCTET_SIZE;
            uecc_s1ap_generate_plmn_identity_int(
                    p_elem->u.e_UTRAN_Cell->global_Cell_ID.pLMNidentity.data,
                    &(p_last_visited_e_utran_cell_information->
                        global_cell_id.plmn_identity));

            /* copy cell Id */
            p_elem->u.e_UTRAN_Cell->global_Cell_ID.cell_ID.numbits = 8*sizeof(
                    p_last_visited_e_utran_cell_information->\
                    global_cell_id.cell_identity);
            p_elem->u.e_UTRAN_Cell->global_Cell_ID.cell_ID.numbits 
                =(p_elem->u.e_UTRAN_Cell->global_Cell_ID.cell_ID.numbits < MAX_CELL_ID_BITS?
                        p_elem->u.e_UTRAN_Cell->global_Cell_ID.cell_ID.numbits : MAX_CELL_ID_BITS);

            l3_memcpy_wrapper(p_elem->u.e_UTRAN_Cell->global_Cell_ID.cell_ID.data,
                    p_last_visited_e_utran_cell_information->\
                    global_cell_id.cell_identity,
                    sizeof(p_last_visited_e_utran_cell_information->
                        global_cell_id.cell_identity));

            /* copy cell type */
            p_elem->u.e_UTRAN_Cell->cellType.m.iE_ExtensionsPresent = 0;
            p_elem->u.e_UTRAN_Cell->cellType.cell_Size = 
                p_last_visited_e_utran_cell_information->cell_type.cell_size;

            /* copy time_UE_StayedInCell */
            p_elem->u.e_UTRAN_Cell->time_UE_StayedInCell =  
                p_last_visited_e_utran_cell_information->time_ue_stayed_in_cell;
        }
        else if(p_last_visited_cell_list->last_visited_cell_info[count].bitmask
                & LAST_VISITED_CELL_INFO_UTRAN_CELL_INFORMATION_PRESENT)
        {
            p_last_visited_utran_cell_information = 
                &(p_last_visited_cell_list->last_visited_cell_info[count].
                        last_visited_utran_cell_information);
            p_elem->t = T_s1ap_LastVisitedCell_Item_uTRAN_Cell;

            /* memory allocation */
            p_elem->u.uTRAN_Cell =
                (s1ap_LastVisitedUTRANCellInformation*)
                rtxMemAlloc(p_asn1_ctx,
                        sizeof(s1ap_LastVisitedUTRANCellInformation));
            if (PNULL==  p_elem->u.uTRAN_Cell)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL, "ASN malloc failed.");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            asn1Init_s1ap_LastVisitedUTRANCellInformation(p_elem->u.uTRAN_Cell);
            if (RRC_SUCCESS != 
                    uecc_s1ap_build_s1ap_LastVisitedUTRANCellInformation(
                        p_last_visited_utran_cell_information,
                        p_asn1_ctx,
                        p_elem->u.uTRAN_Cell,
                        p_ue_context))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR, "Failure in filling "
                        "p_last_visited_utran_cell_information");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);        
                return RRC_FAILURE;
            }
        }
        rtxDListAppendNode(p_ue_history_info, p_node);
    }


    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_s1ap_LastVisitedUTRANCellInformation
 *
 *   INPUTS       :  last_visited_utran_cell_information_t
 *                                *p_last_visited_utran_cell_information
 *                   OSCTXT *p_asn1_ctx
 *                   s1ap_LastVisitedUTRANCellInformation *p_utran_cell_info
 *                   uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds s1ap_LastVisitedUTRANCellInformation 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_s1ap_LastVisitedUTRANCellInformation(
        last_visited_utran_cell_information_t 
        *p_last_visited_utran_cell_information,
        OSCTXT *p_asn1_ctx,
        s1ap_LastVisitedUTRANCellInformation *p_utran_cell_info,
        uecc_ue_context_t           *p_ue_context
        )
{
    ranap_LastVisitedUTRANCell_Item* 
        p_last_visited_utran_cell_item = PNULL;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;



    RRC_ASSERT(PNULL!=p_last_visited_utran_cell_information);
    RRC_ASSERT(PNULL!=p_asn1_ctx);
    RRC_ASSERT(PNULL!=p_utran_cell_info);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    p_last_visited_utran_cell_item =
        (ranap_LastVisitedUTRANCell_Item*)rtxMemAlloc(p_asn1_ctx,
                                                      sizeof(ranap_LastVisitedUTRANCell_Item));
    if (PNULL == p_last_visited_utran_cell_item)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_FATAL, "ASN malloc failed.");
        return RRC_FAILURE;
    }

    asn1Init_ranap_LastVisitedUTRANCell_Item(p_last_visited_utran_cell_item);

    /* copy plmn identity */
    p_last_visited_utran_cell_item->uTRAN_CellID.pLMNidentity.numocts = 3;
    uecc_s1ap_generate_plmn_identity_int(
            (U8 *)p_last_visited_utran_cell_item->uTRAN_CellID.pLMNidentity.data,
            &(p_last_visited_utran_cell_information->
                utran_cell_id.plmn_identity));

    /* copy cell Id */
    l3_memcpy_wrapper((U8*)&p_last_visited_utran_cell_item->uTRAN_CellID.cellID,
            (U8*)p_last_visited_utran_cell_information->utran_cell_id.cell_identity,
            sizeof(p_last_visited_utran_cell_information->utran_cell_id.
                cell_identity));

    /* copy cell type */
    p_last_visited_utran_cell_item->cellType = (ranap_CellType) 
        p_last_visited_utran_cell_information->cell_type.cell_size;

    /* copy time_UE_StayedInCell */
    p_last_visited_utran_cell_item->time_UE_StayedInCell =  
        p_last_visited_utran_cell_information->time_ue_stayed_in_cell;

    memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

    if( RRC_SUCCESS != 
            rrc_s1ap_last_visited_utran_cell_information_intrl_enc(
                p_ue_context->p_gb_context,
                p_asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],
                &p_sig_msg_req->message_buff_size,
                p_last_visited_utran_cell_item))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR, "Fail to decode s1ap_last_visited_"
                "utran_cell_information");
        return RRC_FAILURE;
    }
    p_utran_cell_info->numocts
        = p_sig_msg_req->message_buff_size;
    p_utran_cell_info->data =
        (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                              p_sig_msg_req->message_buff_size);
    if (PNULL ==  p_utran_cell_info->data)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_FATAL, "ASN malloc failed.");
        return RRC_FAILURE;
    }

    memset_wrapper((void *)p_utran_cell_info->data, 0,
            p_sig_msg_req->message_buff_size);
    l3_memcpy_wrapper((U8*)p_utran_cell_info->data,
            p_sig_msg_req->message_buff_p,
            p_sig_msg_req->message_buff_size);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_enb_status_transfer
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  rrc_uecc_llim_sn_hfn_status_resp_t  *p_sn_hfn_status_res
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends  s1ap_ENBStatusTransfer message
 *       to S1AP module.
 *
 *   RETURNS:
 *       rrc_return_et
 *
 ******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_enb_status_transfer
(
 uecc_ue_context_t*      p_ue_context,
 rrc_uecc_llim_sn_hfn_status_resp_t  *p_sn_hfn_status_resp
 )
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_enb_status_transfer_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_sn_hfn_status_resp);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if (0 == p_sn_hfn_status_resp->sn_hfn_status_list.count)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[ s1ap_ENBStatusTransfer] sn_hfn_status_list.count = 0");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }


    if (RRC_FALSE == p_ue_context->p_gb_context->mme_connection_status)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[ s1ap_ENBStatusTransfer] MME connection isn't present");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[ s1ap_ENBStatusTransfer] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */
        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

        if (RRC_SUCCESS!=
                uecc_s1ap_build_enb_status_transfer_transparent_container(
                    p_ue_context,
                    p_sn_hfn_status_resp,
                    &asn1_ctx,
                    &msg.enb_status_transfer_transparent_container))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ENBStatusTransfer]"
                    "s1ap_ENB_StatusTransfer_TransparentContainer failure");
            break;
        }

        /* Encode message */
        result = rrc_s1ap_enb_status_transfer_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],
                &p_sig_msg_req->message_buff_size,
                &msg); 
        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ENBStatusTransfer] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

      rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_ENB_STATUS_TRANSFER,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_eNBStatusTransfer;
        p_sig_msg_req->enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, &p_sig_msg_req->message_buff_p[0], 
                        p_sig_msg_req->message_buff_size, "ENB Status Transfer", 1);
        /* TRACE_changes_start */
        
        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);
    
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "S1AP_MSG: ENBStatusTransfer %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));
        
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_enb_status_transfer_transparent_container
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  rrc_uecc_llim_sn_hfn_status_resp_t  *p_sn_hfn_status_resp
 *                  OSCTXT *p_asn1_ctx
 *                  s1ap_ENB_StatusTransfer_TransparentContainer
 *                  p_enb_status_transfer_transparent_container
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds s1ap_ENB_StatusTransfer_TransparentContainer
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_enb_status_transfer_transparent_container
(
 uecc_ue_context_t* p_ue_context,
 rrc_uecc_llim_sn_hfn_status_resp_t  *p_sn_hfn_status_resp,
 OSCTXT *p_asn1_ctx,
 s1ap_ENB_StatusTransfer_TransparentContainer 
 *p_enb_status_transfer_transparent_container
 )    
{
    U32 erab_id =INVALID_ERAB_ID;
    OSRTDListNode* p_node = PNULL;
    s1ap_Bearers_SubjectToStatusTransferList_element *p_elem = PNULL;
    U8 e_rab_index = 0;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
/*SPR_18249_Fix_Start*/
    rrc_counter_t count = RRC_NULL;
    rrc_bool_et  erab_id_match_flag  = RRC_FALSE;
    uecc_e_rab_failed_to_add_list_t * p_uecc_e_rab_failed_to_add_list = PNULL;
/*SPR_18249_Fix_End*/

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_sn_hfn_status_resp);
    RRC_ASSERT(PNULL != p_enb_status_transfer_transparent_container);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
/*SPR_18249_Fix_Start*/
    p_uecc_e_rab_failed_to_add_list = &(p_ue_context->ho_info.p_ho_info->
            p_src_ho_info->s1_src_ho_info.erab_failed_list);
/*SPR_18249_Fix_End*/
    asn1Init_s1ap_ENB_StatusTransfer_TransparentContainer(
            p_enb_status_transfer_transparent_container);
    asn1Init_s1ap_Bearers_SubjectToStatusTransferList(
            &p_enb_status_transfer_transparent_container->
            bearers_SubjectToStatusTransferList);

    /* TRACE_fix */
    /*SPR 15875 Fix Start*/
            /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated) 
    {
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), GEN_MME,"<msg function=\"S1AP\" name=\"ENB STATUS TRANSFER\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), GEN_CELL,"<msg function=\"S1AP\" name=\"ENB STATUS TRANSFER\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
                p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
            /*SPR 15896 Fix Stop*/
    }
    /* SPR 12187 Fix Stop */
    /* TRACE_fix */
   
    /* Klockwork Fix */
    for (e_rab_index=0; 
            (( e_rab_index < p_sn_hfn_status_resp->sn_hfn_status_list.count ) &&
            ( e_rab_index < MAX_ERAB_COUNT )) ; 
    /* Klockwork Fix */
            e_rab_index++)
    {
        erab_id = get_erab_id_from_lc_id(p_ue_context, 
                p_sn_hfn_status_resp->sn_hfn_status_list.
                sn_hfn_status[e_rab_index].lc_id); 

        if (INVALID_ERAB_ID <= erab_id)
        {
            continue;
        }
/* SPR_18249_Fix_Start */
        erab_id_match_flag = RRC_FALSE;
        if((p_ue_context->ho_info.p_ho_info->
                p_src_ho_info->s1_src_ho_info.bitmask) & E_RAB_FAILED_LIST_PRESENT)
        {    
            for(count = 0; count < (p_uecc_e_rab_failed_to_add_list->count) 
                ; count++)
            {
                if (erab_id == p_uecc_e_rab_failed_to_add_list->
                    e_rab_failed_to_add_list[count].e_rab_id)
                {
                    RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                        p_ue_context->p_gb_context->facility_name, RRC_INFO,
                        "[%s] The e_RAB_ID[%d] is not admitted at target side " 
                        "so not sending sn-hfn status for this e_RAB_ID "
                        ,__FUNCTION__,erab_id);
                    erab_id_match_flag = RRC_TRUE;
                    break;
                }
            }
            if(RRC_TRUE == erab_id_match_flag)
            {
               continue;
            }
        }   
/* SPR_18249_Fix_End */

        rtxDListAllocNodeAndData(p_asn1_ctx,
                s1ap_Bearers_SubjectToStatusTransferList_element,
                &p_node,
                &p_elem);

        if (PNULL == p_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,"Can't allocate p_node");

            rtxDListFreeAll(p_asn1_ctx, 
                    &p_enb_status_transfer_transparent_container->
                    bearers_SubjectToStatusTransferList);

            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        asn1Init_s1ap_Bearers_SubjectToStatusTransferList_element(p_elem);
        p_elem->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1 =
            (s1ap_Bearers_SubjectToStatusTransfer_Item*)rtxMemAlloc(p_asn1_ctx,
                    sizeof(s1ap_Bearers_SubjectToStatusTransfer_Item));

        if (PNULL==p_elem->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "ASN malloc failed.");
            return RRC_FAILURE;
        }
        asn1Init_s1ap_Bearers_SubjectToStatusTransfer_Item(p_elem->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1);
        /* SPR 21660 changes start */
        p_elem->value.t = T143__Bearers_SubjectToStatusTransfer_ItemIEs_1;
        /* SPR 21660 changes end */

        p_elem->id = ASN1V_s1ap_id_Bearers_SubjectToStatusTransfer_Item;
        p_elem->criticality = s1ap_ignore;

        p_elem->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->e_RAB_ID = erab_id;
            /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated) 
        {
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n<ie name=\"E-RABID\">%d</ie>",
                    p_elem->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->e_RAB_ID);
        }
            /*SPR 15896 Fix Stop*/

        p_elem->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->dL_COUNTvalue.pDCP_SN = 
            p_sn_hfn_status_resp->sn_hfn_status_list.sn_hfn_status[e_rab_index].
            dl_count_value.sn_count;
        p_elem->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->dL_COUNTvalue.hFN = 
            p_sn_hfn_status_resp->sn_hfn_status_list.sn_hfn_status[e_rab_index].
            dl_count_value.hfn_count;

        p_elem->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->uL_COUNTvalue.pDCP_SN = 
            p_sn_hfn_status_resp->sn_hfn_status_list.sn_hfn_status[e_rab_index].
            ul_count_value.sn_count;
        p_elem->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->uL_COUNTvalue.hFN = 
            p_sn_hfn_status_resp->sn_hfn_status_list.sn_hfn_status[e_rab_index].
            ul_count_value.hfn_count;

        if (UECC_LLIM_RECEIVE_STATUS_OF_UL_PDCP_SDU_PRESENT &
                p_sn_hfn_status_resp->
                sn_hfn_status_list.sn_hfn_status[e_rab_index].bitmask)
        {
            p_elem->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->receiveStatusofULPDCPSDUs.numbits 
                = MAX_UL_PDCP_SDU * 8;

            l3_memcpy_wrapper(((void*)p_elem->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->receiveStatusofULPDCPSDUs.data),
                    ((const void *)p_sn_hfn_status_resp->sn_hfn_status_list.
                     sn_hfn_status[e_rab_index].
                     status_of_ul_pdcp_sdu.receive_status_of_ul_pdcp_sdu),
                    MAX_UL_PDCP_SDU);

            p_elem->value.u._Bearers_SubjectToStatusTransfer_ItemIEs_1->m.receiveStatusofULPDCPSDUsPresent = RRC_TRUE;
        }

        rtxDListAppendNode(
                &p_enb_status_transfer_transparent_container->
                bearers_SubjectToStatusTransferList, 
                p_node);
    }
    /* TRACE_fix */
            /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated) 
    {
        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n </msg>");
            /*SPR 15896 Fix Stop*/
    }
    /* TRACE_fix */

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_m_check_and_convert_sib1
 *
 *   INPUTS       : OSCTXT                      *pctxt
 *                  SystemInformationBlockType1 *p_asn1_sib
 *                  sib_type_1_Info_t           *p_sib1
 *                  uecc_ue_context_t           *p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function converts sib_type_1_Info_t to
 *       SystemInformationBlockType1
 *       and checks if input data are valid.
 *       Full check of SchedulingInformation_element and si_WindowLength is
 *       out of scope of this function.
 *       This function check si_WindowLength range.
 *
 *   RETURNS:
 *       RRC_SUCCESS - if all data are valid
 *       RRC_FAILURE - if data are invalid or if there are not enough memory
 *
 ******************************************************************************/
static rrc_return_et uecc_m_check_and_convert_sib1
(
 OSCTXT                      *pctxt,             /* for memory allocation */
 SystemInformationBlockType1 *p_asn1_sib1,       /* destination */
 sib_type_1_Info_t           *p_sib1,            /* source */
 uecc_ue_context_t           *p_ue_context
 )
{
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    /*Init*/
    asn1Init_SystemInformationBlockType1(p_asn1_sib1);
    /* Init optional element to absent */
    p_asn1_sib1->m.p_MaxPresent                 = 0;
    p_asn1_sib1->m.tdd_ConfigPresent            = 0;
    p_asn1_sib1->m.nonCriticalExtensionPresent  = 0;

    if (RRC_SUCCESS != check_and_convert_sib1_cell_ari( pctxt,
                &p_asn1_sib1->
                cellAccessRelatedInfo,
                &p_sib1->
                cell_access_related_info,p_ue_context))
    {
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* Fill p_asn1_sib1->cellSelectionInfo */
    /* Init optional element to absent */
    p_asn1_sib1->cellSelectionInfo.m.q_RxLevMinOffsetPresent = 0;

    p_asn1_sib1->cellSelectionInfo.q_RxLevMin = p_sib1->cell_selection_Info.
        q_rx_lev_min;
    if (p_sib1->cell_selection_Info.presence_bitmask &
            CELL_SELECT_INFO_Q_RX_LEV_MIN_OFFSET_PRESENCE_FLAG)
    {
        p_asn1_sib1->cellSelectionInfo.m.q_RxLevMinOffsetPresent = 1;

        p_asn1_sib1->cellSelectionInfo.q_RxLevMinOffset = p_sib1->
            cell_selection_Info.q_rx_lev_min_offset;
    }

    if (p_sib1->presence_bitmask & SIB_TYPE_1_P_MAX_PRESENCE_FLAG)
    {
        p_asn1_sib1->m.p_MaxPresent = 1;

        p_asn1_sib1->p_Max = p_sib1->p_max;
    }

    if (p_sib1->presence_bitmask & SIB_TYPE_1_TDD_CONFIG_PRESENT_FLAG)
    {
        p_asn1_sib1->m.tdd_ConfigPresent = 1;

        p_asn1_sib1->tdd_Config.subframeAssignment = p_sib1->tdd_config.
            sub_frame_assignment;
        p_asn1_sib1->tdd_Config.specialSubframePatterns = p_sib1->tdd_config.
            special_sub_frame_pattern;
    }
    p_asn1_sib1->freqBandIndicator = p_sib1->freq_band_indicator;

    if (RRC_SUCCESS != check_and_convert_sib1_sched_inf(pctxt,
                &p_asn1_sib1->
                schedulingInfoList,
                &p_sib1->
                scheduling_info_list,
                p_ue_context))
    {
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* tdd-Configuration is absent in release 0.5 */

    /* Make sure that SIs scheduling information is OK */
    /* p_sib1->si_window_length should be defined in term of
     *  SystemInformationBlockType1_si_WindowLength_Root */
    if ( p_sib1->si_window_length > ms40)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "Wrong SI window length=%u. Should be up to "
                "RRM_RRC_SI_WINDOW_LEN_MS_40==ms40",
                p_sib1->si_window_length);
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    p_asn1_sib1->si_WindowLength = p_sib1->si_window_length;
    p_asn1_sib1->systemInfoValueTag = p_sib1->si_value_tag;

    /*36331 10.3 Inter-node RRC information element definitions
    
    sourceSystemInformationBlockType1   SystemInformationBlockType1(WITH COMPONENTS
                                                {..., nonCriticalExtension ABSENT}),
    */
    p_asn1_sib1->m.nonCriticalExtensionPresent = 0;

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: check_and_convert_sib1_cell_ari
 *
 *   INPUTS       : OSCTXT                               *pctxt 
 *                  SystemInformationBlockType1_cellAccessRelatedInfo 
 *                                                           *p_asn1_cell_ari
 *                  cell_access_related_info_t                *p_cell_ari
 *                  uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function converts cell_access_related_info_t to
 *       SystemInformationBlockType1_cellAccessRelatedInformation
 *       and checks if input data are valid.
 *
 *   RETURNS:
 *       RRC_SUCCESS - if all data are valid
 *       RRC_FAILURE - if data are invalid or if there are not enough memory
 *
 ******************************************************************************/
static rrc_return_et check_and_convert_sib1_cell_ari
(
 /* for memory allocation */
 OSCTXT                                                      *pctxt,
 /* destination */
 SystemInformationBlockType1_cellAccessRelatedInfo           *p_asn1_cell_ari
 ,
 /* source */
 cell_access_related_info_t                                  *p_cell_ari,
 uecc_ue_context_t                                           *p_ue_context
 )
{
    U8                          i               = RRC_NULL;
    U8                          digit           = RRC_NULL;
    OSRTDListNode               *p_node         = PNULL;
    PLMN_IdentityInfo           *p_asn1_l_elem  = PNULL;
    plmn_identity_info_t        *p_l_elem       = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* Init optional element to absent */
    p_asn1_cell_ari->m.csg_IdentityPresent = 0;

    /* PLMN-IdentityList */
    if (p_cell_ari->plmn_Id_info_list.count > ARRSIZE(p_cell_ari->
                plmn_Id_info_list.plmn_identity_info))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "Wrong size of PLMN-IdentityList: current=%u, RRM max=%u",
                p_cell_ari->plmn_Id_info_list.count,
                ARRSIZE(p_cell_ari->plmn_Id_info_list.plmn_identity_info));
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    rtxDListInit(&p_asn1_cell_ari->plmn_IdentityList);
    for (i = 0; i < p_cell_ari->plmn_Id_info_list.count; i++)
    {
        rtxDListAllocNodeAndData(pctxt, PLMN_IdentityInfo, &p_node,
                &p_asn1_l_elem);
        if (PNULL == p_node)
        {
            /* Not enough memory */
            return RRC_FAILURE;
        }
        p_l_elem = p_cell_ari->plmn_Id_info_list.plmn_identity_info + i;

        /* Check MCC condition: mcc must be present in the first
         *  PLMN-IdentityList item */
        if (    (0 == i) &&
                (0 == (p_l_elem->plmn_identity.presence_bitmask &
                       PLMN_IDENTITY_MCC_PRESENCE_FLAG)))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING, "Mcc must be present in the first PLMN"
                    "-IdentityList item");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /* Init optional element to absent */
        p_asn1_l_elem->plmn_Identity.m.mccPresent = 0;

        if (p_l_elem->plmn_identity.presence_bitmask &
                PLMN_IDENTITY_MCC_PRESENCE_FLAG)
        {
            p_asn1_l_elem->plmn_Identity.m.mccPresent = 1;

            p_asn1_l_elem->plmn_Identity.mcc.n = ARRSIZE(p_l_elem->plmn_identity
                    .mcc);
            for (digit = 0; digit < ARRSIZE(p_l_elem->plmn_identity.mcc);
                    digit++)
            {
                p_asn1_l_elem->plmn_Identity.mcc.elem[digit] = p_l_elem->
                    plmn_identity.mcc[digit];
            }
        }

        if (    (p_l_elem->plmn_identity.mnc.count > ARRSIZE(p_asn1_l_elem->
                        plmn_Identity.mnc.elem)) ||
                (p_l_elem->plmn_identity.mnc.count > 
                 ARRSIZE(p_l_elem->
                     plmn_identity.mnc.mnc)))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "Too many MNC digits: current=%u, RRM max=%u, ASN.1 max=%u",
                    p_l_elem->plmn_identity.mnc.count,
                    ARRSIZE(p_l_elem->plmn_identity.mnc.mnc),
                    ARRSIZE(p_asn1_l_elem->plmn_Identity.mnc.elem));
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        p_asn1_l_elem->plmn_Identity.mnc.n = p_l_elem->plmn_identity.mnc.count;
        for (digit = 0; digit < p_l_elem->plmn_identity.mnc.count; digit++)
        {
            p_asn1_l_elem->plmn_Identity.mnc.elem[digit] = p_l_elem->
                plmn_identity.mnc.mnc[digit];
        }

        p_asn1_l_elem->cellReservedForOperatorUse = p_l_elem->
            cell_res_for_operator_use;

        rtxDListAppendNode(&p_asn1_cell_ari->plmn_IdentityList, p_node);
    }

    p_asn1_cell_ari->trackingAreaCode.numbits = TAC_NBITS;
    l3_memcpy_wrapper( p_asn1_cell_ari->trackingAreaCode.data,
            p_cell_ari->tac,
            sizeof(p_cell_ari->tac));

    p_asn1_cell_ari->cellIdentity.numbits = CELL_ID_NBITS;
    l3_memcpy_wrapper( p_asn1_cell_ari->cellIdentity.data,
            p_cell_ari->cell_Id,
            sizeof(p_asn1_cell_ari->cellIdentity.data));

    p_asn1_cell_ari->cellBarred             = p_cell_ari->cell_barred;
    p_asn1_cell_ari->intraFreqReselection   = p_cell_ari->
        intra_freq_reselection;

    if (RRC_FALSE == p_cell_ari->csg_indication)
    {
        p_asn1_cell_ari->csg_Indication = FALSE;
    }
    else
    {
        p_asn1_cell_ari->csg_Indication = TRUE;
    }

    if (    (RRC_TRUE == p_cell_ari->csg_indication) &&
            (0 == (p_cell_ari->presence_bitmask &
                   CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG)))
    {
        /* Logical check: we should have p_cell_ari->csg_identity
         *  if p_cell_ari->csg_indication is TRUE */
        /* Otherwise I don't understand how UE should behaviour in this case */
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING, "We should have p_cell_ari->csg_identity if"
                " p_cell_ari->csg_indication is TRUE");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    if (p_cell_ari->presence_bitmask & CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG)
    {
        p_asn1_cell_ari->m.csg_IdentityPresent = 1;

        p_asn1_cell_ari->csg_Identity.numbits = CSG_ID_NBITS;
        l3_memcpy_wrapper( p_asn1_cell_ari->csg_Identity.data,
                p_cell_ari->csg_identity,
                sizeof(p_asn1_cell_ari->csg_Identity.data));

        p_asn1_cell_ari->csg_Identity.data[CSG_ID_OCTET_SIZE-1] &= CSG_RESET_VAL;
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: check_and_convert_sib1_sched_inf
 *
 *   INPUTS       : OSCTXT                     *pctxt
 *                  SchedulingInfoList         *p_asn1_sched_inf
 *                  scheduling_info_list_t      *p_sched_inf
 *                  uecc_ue_context_t           *p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function converts scheduling_info_list_t to
 *       SchedulingInformation_element
 *       and checks if input data are valid.
 *       This function checks number of SIs, si_Periodicity range,
 *       number of SIBs in SI and make sure that only known and present in
 *       message from RRM SIBs are mapped only once to SIs.
 *
 *   RETURNS:
 *       RRC_SUCCESS - if all data are valid
 *       RRC_FAILURE - if data are invalid or if there are not enough memory
 *
 ******************************************************************************/
static rrc_return_et check_and_convert_sib1_sched_inf
(
 OSCTXT                     *pctxt,             /* for memory allocation */
 SchedulingInfoList         *p_asn1_sched_inf,  /* destination */
 scheduling_info_list_t      *p_sched_inf,       /* source */
 uecc_ue_context_t           *p_ue_context
 )
{
    U8                              i               = RRC_NULL;
    U8                              SIB             = RRC_NULL;
    OSRTDListNode                   *p_node         = PNULL;
    SchedulingInfo                  *p_asn1_l_elem  = PNULL;
    scheduling_info_t                *p_l_elem       = PNULL;
    /* We don't have mapped SIBs at the beginning */
    U16                             mapped_sibs_mask= 0;
    U16                 per_si_sibs_bitmask = 0;

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if (    (p_sched_inf->count < 1) ||
            (p_sched_inf->count > MAX_SI_MESSAGE) ||
            (p_sched_inf->count > ARRSIZE(p_sched_inf->scheduling_info)))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "Wrong number of SIs=%u. Should be 1..min(RRM=%u, ASN.1=%u)",
                p_sched_inf->count,
                ARRSIZE(p_sched_inf->scheduling_info),
                MAX_SI_MESSAGE);
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }



    rtxDListInit(p_asn1_sched_inf);
    for (i = 0; i < p_sched_inf->count; i++)
    {
        rtxDListAllocNodeAndData(pctxt, SchedulingInfo, &p_node,
                &p_asn1_l_elem);
        if (PNULL == p_node)
        {
            /* Not enough memory */
            return RRC_FAILURE;
        }
        p_l_elem = p_sched_inf->scheduling_info + i;

        /* Make sure that SIs scheduling information is OK */
        /* p_l_elem->si_periodicity should be defined in term of
         *  SchedulingInformation_element_si_Periodicity_Root */
        if (p_l_elem->si_periodicity > rf512)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING, "Wrong periodicity of SI=%u. Should be "
                    "up to rf512", p_l_elem->si_periodicity);
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        p_asn1_l_elem->si_Periodicity = p_l_elem->si_periodicity;

        /* Check number of SIBs in this SI */
        if (    (p_l_elem->sib_mapping_info.count > MAX_SIB_MESSAGE_1) ||
                (p_l_elem->sib_mapping_info.count > 
                 ARRSIZE(p_l_elem->
                     sib_mapping_info.sib_type)))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "Wrong number of SIBs in SI=%u. Should be 0..min "
                    "(RRM=%u, ASN.1 =%u)",
                    p_l_elem->sib_mapping_info.count,
                    ARRSIZE(p_l_elem->sib_mapping_info.sib_type),
                    MAX_SIB_MESSAGE_1);
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        RRC_ASSERT(MAX_SIB_MESSAGE_1 == ARRSIZE(p_asn1_l_elem->sib_MappingInfo.
                    elem));

        /* mapped_sibs_mask should be big enough to hold all possible SIBs.*/
        /* SPR 18922 changes Start */
        RRC_ASSERT(sibType13_v920 < 16);
        /* SPR 18922 changes End */
        /* Here we relay on strict connection between rrm_sib_type_et and
         *  _PRESENCE_FLAG for SIBs in message from RRM! */
        RRC_ASSERT(CELL_SETUP_REQ_API_SIB_3_INFO_PRESENCE_FLAG == (1<<
                    RRM_RRC_SIB_TYPE_3));
        RRC_ASSERT(CELL_SETUP_REQ_API_SIB_9_INFO_PRESENCE_FLAG == (1<<
                    RRM_RRC_SIB_TYPE_9));
        p_asn1_l_elem->sib_MappingInfo.n = p_l_elem->sib_mapping_info.count;

        /* Initialise the SI_SIBS_BITMASK */
        per_si_sibs_bitmask = 0;
        for (SIB = 0; SIB < p_l_elem->sib_mapping_info.count; SIB++)
        {
            /* Make sure that SIs scheduling information is OK */
            /* p_l_elem->sib_mapping_info.sib_type[SIB] should be defined in
             *  term of SIB_Type_Root */
        /* SPR 18922 changes Start */
            if (p_l_elem->sib_mapping_info.sib_type[SIB] > sibType13_v920)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "Wrong SIB=%u in SI. Should be up to sibType13_v920",
                        p_l_elem->sib_mapping_info.sib_type[SIB]);
        /* SPR 18922 changes End */
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            if (mapped_sibs_mask & (1 << p_l_elem->sib_mapping_info.
                        sib_type[SIB]))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "Duplicate SIB=%u mapping to SI(s)",
                        p_l_elem->sib_mapping_info.sib_type[SIB]);
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }

            per_si_sibs_bitmask |= (U16)
                (8 << p_l_elem->sib_mapping_info.sib_type[SIB]);    
            mapped_sibs_mask |= (U16)
                (1 << p_l_elem->sib_mapping_info.sib_type[SIB]);
            p_asn1_l_elem->sib_MappingInfo.elem[SIB] = p_l_elem->
                sib_mapping_info.sib_type[SIB];
        }

        rtxDListAppendNode(p_asn1_sched_inf, p_node);
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_m_check_and_convert_sib2
 *
 *   INPUTS       : OSCTXT                      *p_asn1_ctx
 *                  SystemInformationBlockType2 *p_asn1_sib
 *                  sib_type_2_Info_t           *p_sib2
 *                  uecc_ue_context_t           *p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function converts sib_type_2_Info_t to
 *       SystemInformationBlockType2
 *       and checks whether input data are valid.
 *
 *   RETURNS:
 *       RRC_SUCCESS - all data are valid
 *       RRC_FAILURE - data are invalid or if there are not enough memory
 *
 ******************************************************************************/
static rrc_return_et uecc_m_check_and_convert_sib2
(
 OSCTXT                      *p_asn1_ctx,    /* for memory allocation */
 SystemInformationBlockType2 *p_asn1_sib2,   /* destination */
 sib_type_2_Info_t           *p_sib2,         /* source */
 uecc_ue_context_t           *p_ue_context
 )
{
    rrc_return_et ret_value = RRC_SUCCESS;


    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_sib2);
    RRC_ASSERT(PNULL != p_asn1_sib2);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    asn1Init_SystemInformationBlockType2(p_asn1_sib2);
    
    p_asn1_sib2->m.ac_BarringInfoPresent      = 0;
    p_asn1_sib2->m.mbsfn_SubframeConfigListPresent  = 0;
    /*cr_345 new Asn IEs added*/
    p_asn1_sib2->m._v3ExtPresent = 0;
    p_asn1_sib2->m.ssac_BarringForMMTEL_Voice_r9Present = 0;
    p_asn1_sib2->m.ssac_BarringForMMTEL_Video_r9Present = 0;
    /* - accessBarringInformation */

    if (SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG & p_sib2->presence_bitmask)
    {
        p_asn1_sib2->m.ac_BarringInfoPresent = 1;

        p_asn1_sib2->ac_BarringInfo.m.ac_BarringForMO_SignallingPresent       =
            0;
        p_asn1_sib2->ac_BarringInfo.m.ac_BarringForMO_DataPresent             =
            0;

        if (p_sib2->access_barring_info.acBarringForEmergency > RRC_TRUE)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "Incorrect p_sib2->access_barring_info."
                    "acBarringForEmergency "
                    "value=%u received",
                    p_sib2->access_barring_info.acBarringForEmergency);
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        p_asn1_sib2->ac_BarringInfo.ac_BarringForEmergency =
            p_sib2->access_barring_info.acBarringForEmergency;

        if (AC_BARR_INFO_MO_SIG_PRESENCE_FLAG & p_sib2->access_barring_info.
                presence_bitmask)
        {
            p_asn1_sib2->ac_BarringInfo.m.ac_BarringForMO_SignallingPresent = 1;

            ret_value = fill_access_class_barring_info(
                    &p_asn1_sib2->ac_BarringInfo.ac_BarringForMO_Signalling,
                    &p_sib2->access_barring_info.ac_barring_for_mo_signalling,p_ue_context);
            if (RRC_FAILURE == ret_value)
            {
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
        }

        if (AC_BARR_INFO_MO_DATA_PRESENCE_FLAG & p_sib2->access_barring_info.
                presence_bitmask)
        {
            p_asn1_sib2->ac_BarringInfo.m.ac_BarringForMO_DataPresent = 1;

            ret_value = fill_access_class_barring_info(
                    &p_asn1_sib2->ac_BarringInfo.ac_BarringForMO_Data,
                    &p_sib2->access_barring_info.ac_barring_for_mo_data,p_ue_context);

            if (RRC_FAILURE == ret_value)
            {
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
        }
    }

    /* - radioResourceConfigCommon */
    ret_value = fill_radio_resource_config_common(
            p_ue_context->p_gb_context, p_asn1_ctx,
            &p_asn1_sib2->radioResourceConfigCommon, &p_sib2->
            radio_resource_config_common_sib);

    if (RRC_FAILURE == ret_value)
    {
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* - ue_TimersAndConstants */

    p_asn1_sib2->ue_TimersAndConstants.t300 = p_sib2->ue_timers_and_constants.
        timer_300;
    p_asn1_sib2->ue_TimersAndConstants.t301 = p_sib2->ue_timers_and_constants.
        timer_301;
    p_asn1_sib2->ue_TimersAndConstants.t310 = p_sib2->ue_timers_and_constants.
        timer_310;
    p_asn1_sib2->ue_TimersAndConstants.n310 = p_sib2->ue_timers_and_constants.
        timer_n310;
    p_asn1_sib2->ue_TimersAndConstants.t311 = p_sib2->ue_timers_and_constants.
        timer_311;
    p_asn1_sib2->ue_TimersAndConstants.n311 = p_sib2->ue_timers_and_constants.
        timer_n311;

    rtxDListInit(&p_asn1_sib2->ue_TimersAndConstants.extElem1);

    /* - frequencyInformation */

    p_asn1_sib2->freqInfo.m.ul_CarrierFreqPresent    = 0;
    p_asn1_sib2->freqInfo.m.ul_BandwidthPresent = 0;

    if (FREQ_INFO_UL_CARRER_FREQ_PRESENCE_FLAG & p_sib2->freq_info.
            presence_bitmask)
    {
        p_asn1_sib2->freqInfo.m.ul_CarrierFreqPresent = 1;
        p_asn1_sib2->freqInfo.ul_CarrierFreq = p_sib2->freq_info.
            ul_carrier_freq;
    }

    if (FREQ_INFO_UL_BW_PRESENCE_FLAG & p_sib2->freq_info.presence_bitmask)
    {
        p_asn1_sib2->freqInfo.m.ul_BandwidthPresent = 1;
        p_asn1_sib2->freqInfo.ul_Bandwidth = p_sib2->freq_info.ul_bandwidth;
    }

    p_asn1_sib2->freqInfo.additionalSpectrumEmission =
        p_sib2->freq_info.add_spectrum_emission;

    /* - mbsfn_SubframeConfiguration */
    if (SIB2_MBSFN_SUBFRAME_CONF_LIST_PRESENCE_FLAG & p_sib2->presence_bitmask)
    {
        p_asn1_sib2->m.mbsfn_SubframeConfigListPresent = 1;

        ret_value = fill_subframe_config(
                p_ue_context->p_gb_context, p_asn1_ctx,
                &p_asn1_sib2->mbsfn_SubframeConfigList, &p_sib2->
                mbsfn_subframe_config_list,p_ue_context);

        if (RRC_FAILURE == ret_value)
        {
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }

    p_asn1_sib2->timeAlignmentTimerCommon = p_sib2->time_align_timer;
    
    /*CR 345: New IEs are added in SIB2*/
    if (SIB2_SSAC_BARRING_FOR_MMTEL_VOICE_PRESENCE_FLAG & 
            p_sib2->presence_bitmask)
    {
        p_asn1_sib2->m._v3ExtPresent = 1;
        p_asn1_sib2->m.ssac_BarringForMMTEL_Voice_r9Present = 1;

        ret_value = fill_access_class_barring_info(
                &p_asn1_sib2->ssac_BarringForMMTEL_Voice_r9,
                &p_sib2->ssac_barring_for_mmtel_voice_r9,p_ue_context);

        if (RRC_FAILURE == ret_value)
        {
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }

    if (SIB2_SSAC_BARRING_FOR_MMTEL_VIDEO_PRESENCE_FLAG & 
            p_sib2->presence_bitmask)
    {
        p_asn1_sib2->m._v3ExtPresent = 1;
        p_asn1_sib2->m.ssac_BarringForMMTEL_Video_r9Present = 1;

        ret_value = fill_access_class_barring_info(
                &p_asn1_sib2->ssac_BarringForMMTEL_Video_r9,
                &p_sib2->ssac_barring_for_mmtel_video_r9,p_ue_context);

        if (RRC_FAILURE == ret_value)
        {
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }
/*This will be use in Release 10*/
    if (SIB2_AC_BARRING_FOR_CSFB_PRESENCE_FLAG & 
            p_sib2->presence_bitmask)
    {
       p_asn1_sib2->m._v4ExtPresent = 1;
       p_asn1_sib2->m.ac_BarringForCSFB_r10Present = 1;

        ret_value = fill_access_class_barring_info(
                &p_asn1_sib2->ac_BarringForCSFB_r10,
                &p_sib2->ac_barring_for_csfb_r10,p_ue_context);

        if (RRC_FAILURE == ret_value)
        {
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }
    rtxDListInit(&p_asn1_sib2->extElem1);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return ret_value;
}

/******************************************************************************
 *   FUNCTION NAME: fill_access_class_barring_info
 *
 *   INPUTS       : OSCTXT                          *p_asn1_ctx
 *                  AC_BarringConfig                *p_asn1_access_class
 *                  access_class_barring_Info_t     *p_access_class
 *                  uecc_ue_context_t               *p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function converts access_class_barring_Info_t to
 *       AC_BarringConfig (previously named AccessClassBarringInformation)
 *       and checks whether input data are valid.
 *
 *   RETURNS:
 *       RRC_SUCCESS - all data are valid
 *       RRC_FAILURE - data are invalid or if there are not enough memory
 *
 ******************************************************************************/
static rrc_return_et fill_access_class_barring_info
(
 /* for memory allocation */
 AC_BarringConfig                *p_asn1_access_class,   /* destination */
 access_class_barring_Info_t     *p_access_class,         /* source */
 uecc_ue_context_t               *p_ue_context
 )
{

    RRC_ASSERT(PNULL != p_asn1_access_class);
    RRC_ASSERT(PNULL != p_access_class);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);


    p_asn1_access_class->ac_BarringFactor = p_access_class->ac_barring_factor;
    p_asn1_access_class->ac_BarringTime   = p_access_class->ac_barring_time;

    p_asn1_access_class->ac_BarringForSpecialAC.numbits = MAX_AC_VALUE;
    p_asn1_access_class->ac_BarringForSpecialAC.data[0] = p_access_class->
        ac_barring_for_special_ac;
    /* cr_524 ac_BarringFactor check introduced*/
    if ((p_asn1_access_class->ac_BarringFactor != p00 ) && 
        (p_access_class->ac_barring_for_special_ac != RRC_NULL ))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
            (p_ue_context->p_gb_context)->facility_name,
            RRC_ERROR,
            "ac-BarringFactor: Values other than p00 can only be set if all bits of "
            "the corresponding ac-BarringForSpecialAC are set to 0.");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}


/******************************************************************************
 *   FUNCTION NAME: fill_radio_resource_config_common
 *
 *   INPUTS       : uecc_gb_context_t*                  p_uecc_gb_context
 *                  OSCTXT                              *p_asn1_ctx
 *                  RadioResourceConfigCommonSIB        *p_asn1_cc
 *                  radio_resource_config_common_sib_t  *p_cc
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function converts radio_resource_config_common_sib_t to
 *       RadioResourceConfigCommonSIB
 *       and checks whether input data are valid.
 *
 *   RETURNS:
 *       RRC_SUCCESS - all data are valid
 *       RRC_FAILURE - data are invalid or if there are not enough memory
 *
 ******************************************************************************/
static rrc_return_et fill_radio_resource_config_common
(
 uecc_gb_context_t*                  p_uecc_gb_context,
 /* for memory allocation */
 OSCTXT                              *p_asn1_ctx,
 RadioResourceConfigCommonSIB        *p_asn1_cc,     /* destination */
 radio_resource_config_common_sib_t  *p_cc           /* source */
 )
{

    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_asn1_cc);
    RRC_ASSERT(PNULL != p_cc);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
    /* - rach_Configuration */
    /* -- rach_Configuration/preambleInformation */
    p_asn1_cc->rach_ConfigCommon.preambleInfo.numberOfRA_Preambles =
        p_cc->rach_config_common.preamble_info.ra_preamble_count;

    p_asn1_cc->rach_ConfigCommon.preambleInfo.m.preamblesGroupAConfigPresent = 0;

    if (p_cc->rach_config_common.preamble_info.presence_bitmask &
            PREAMBLE_INFO_GROUP_A_CONFIG_PRESENCE_FLAG)
    {
        p_asn1_cc->rach_ConfigCommon.preambleInfo.m.
            preamblesGroupAConfigPresent = 1;

        p_asn1_cc->rach_ConfigCommon.preambleInfo.preamblesGroupAConfig.
            sizeOfRA_PreamblesGroupA =
            p_cc->rach_config_common.preamble_info.preambles_group_a_config.
            ra_preambles_group_a_size;

        p_asn1_cc->rach_ConfigCommon.preambleInfo.preamblesGroupAConfig.
            messageSizeGroupA =
            p_cc->rach_config_common.preamble_info.preambles_group_a_config.
            group_a_msg_size;

        p_asn1_cc->rach_ConfigCommon.preambleInfo.preamblesGroupAConfig.
            messagePowerOffsetGroupB =
            p_cc->rach_config_common.preamble_info.preambles_group_a_config.
            group_b_msg_power_offset;

        rtxDListInit(&p_asn1_cc->rach_ConfigCommon.preambleInfo.
                preamblesGroupAConfig. extElem1);
    }

    /* -- rach_Configuration/powerRampingParameters */
    p_asn1_cc->rach_ConfigCommon.powerRampingParameters.powerRampingStep =
        p_cc->rach_config_common.power_ramping_params.power_ramping_step;

    p_asn1_cc->rach_ConfigCommon.powerRampingParameters.
        preambleInitialReceivedTargetPower =
        p_cc->rach_config_common.power_ramping_params.
        preamble_init_rec_target_pow;

    /* -- rach_Configuration/ra_SupervisionInformation */
    p_asn1_cc->rach_ConfigCommon.ra_SupervisionInfo.preambleTransMax =
        p_cc->rach_config_common.ra_supervision_info.preamble_trans_max;

    p_asn1_cc->rach_ConfigCommon.ra_SupervisionInfo.ra_ResponseWindowSize =
        p_cc->rach_config_common.ra_supervision_info.ra_resp_win_size;

    p_asn1_cc->rach_ConfigCommon.ra_SupervisionInfo.
        mac_ContentionResolutionTimer =
        p_cc->rach_config_common.ra_supervision_info.mac_cont_resol_timer;

    p_asn1_cc->rach_ConfigCommon.maxHARQ_Msg3Tx =
        p_cc->rach_config_common.max_harq_msg_3_tx;

    rtxDListInit(&p_asn1_cc->rach_ConfigCommon.extElem1);

    /* - bcch_Configuration */
    p_asn1_cc->bcch_Config.modificationPeriodCoeff =
        p_cc->bcch_config.mod_period_coeff;

    /* - pcch_Configuration */
    p_asn1_cc->pcch_Config.defaultPagingCycle =
        p_cc->pcch_config.default_paging_cycle;

    p_asn1_cc->pcch_Config.nB =
        p_cc->pcch_config.nb;

    /* - prach_Configuration */
    p_asn1_cc->prach_Config.rootSequenceIndex =
        p_cc->prach_config_sib.root_seq_index;

    /* -- prach_Configuration/prach_ConfigInfo */
    p_asn1_cc->prach_Config.prach_ConfigInfo.prach_ConfigIndex =
        p_cc->prach_config_sib.prach_config_info.prach_config_index;

    p_asn1_cc->prach_Config.prach_ConfigInfo.highSpeedFlag =
        p_cc->prach_config_sib.prach_config_info.high_speed_flag;

    p_asn1_cc->prach_Config.prach_ConfigInfo.zeroCorrelationZoneConfig =
        p_cc->prach_config_sib.prach_config_info.zero_cor_zone_config;

    p_asn1_cc->prach_Config.prach_ConfigInfo.prach_FreqOffset =
        p_cc->prach_config_sib.prach_config_info.prach_freq_offset;

    /* - pdsch_Configuration */
    p_asn1_cc->pdsch_ConfigCommon.referenceSignalPower =
        p_cc->pdsch_config_common.ref_signal_power;

    p_asn1_cc->pdsch_ConfigCommon.p_b =
        p_cc->pdsch_config_common.pb;

    /* - pusch_Configuration */

    /* -- pusch_Configuration/pusch_ConfigBasic */
    p_asn1_cc->pusch_ConfigCommon.pusch_ConfigBasic.n_SB =
        p_cc->pusch_config_common.pusch_config_basic.nsb;

    p_asn1_cc->pusch_ConfigCommon.pusch_ConfigBasic.hoppingMode =
        p_cc->pusch_config_common.pusch_config_basic.hopping_mode;

    p_asn1_cc->pusch_ConfigCommon.pusch_ConfigBasic.pusch_HoppingOffset =
        p_cc->pusch_config_common.pusch_config_basic.pusch_hopping_offset;

    p_asn1_cc->pusch_ConfigCommon.pusch_ConfigBasic.enable64QAM =
        p_cc->pusch_config_common.pusch_config_basic.enable_64_qam;

    /* -- pusch_Configuration/ul_ReferenceSignalsPUSCH */
    p_asn1_cc->pusch_ConfigCommon.ul_ReferenceSignalsPUSCH.groupHoppingEnabled =
        p_cc->pusch_config_common.ul_ref_signals_pusch.group_hopping_enabled;

    p_asn1_cc->pusch_ConfigCommon.ul_ReferenceSignalsPUSCH.groupAssignmentPUSCH =
        p_cc->pusch_config_common.ul_ref_signals_pusch.group_assign_pusch;

    p_asn1_cc->pusch_ConfigCommon.ul_ReferenceSignalsPUSCH.
        sequenceHoppingEnabled =
        p_cc->pusch_config_common.ul_ref_signals_pusch.seq_hopping_enabled;

    p_asn1_cc->pusch_ConfigCommon.ul_ReferenceSignalsPUSCH.cyclicShift =
        p_cc->pusch_config_common.ul_ref_signals_pusch.cyclic_shift;

    /* - pucch_Configuration */
    p_asn1_cc->pucch_ConfigCommon.deltaPUCCH_Shift =
        p_cc->pucch_config_common.delta_pucch_shift;

    p_asn1_cc->pucch_ConfigCommon.nRB_CQI =
        p_cc->pucch_config_common.n_rb_cqi;

    p_asn1_cc->pucch_ConfigCommon.nCS_AN =
        p_cc->pucch_config_common.n_cs_an;

    p_asn1_cc->pucch_ConfigCommon.n1PUCCH_AN =
        p_cc->pucch_config_common.n_one_pucch_an;

    /* - soundingRS_UL_ConfigCommon */
    if (p_cc->sounding_rs_ul_config_common.presence_bitmask &
            SOUNDING_RS_UL_CONFIG_COMMON_SETUP_PRESENCE_FLAG)
    {
        p_asn1_cc->soundingRS_UL_ConfigCommon.t = 
            T_SoundingRS_UL_ConfigCommon_setup;
        p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup =
            rtxMemAllocType(p_asn1_ctx, SoundingRS_UL_ConfigCommon_setup);

        if (PNULL == p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup)
        {
            /* Not enough memory */
            return RRC_FAILURE;
        }

        p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup->m.srs_MaxUpPtsPresent = 0;

        p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup->srs_BandwidthConfig =
            p_cc->sounding_rs_ul_config_common.setup.srs_bw_config;

        p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup->srs_SubframeConfig =
            p_cc->sounding_rs_ul_config_common.setup.srs_subframe_config;

        p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup->
            ackNackSRS_SimultaneousTransmission =
            p_cc->sounding_rs_ul_config_common.setup.ack_nack_srs_simul_trans;

        if(p_cc->sounding_rs_ul_config_common.setup.presence_bitmask &
                SOUNDING_RS_UL_CONFIG_COMMON_SETUP_SRS_MAX_UP_PTS_PRESENCE_FLAG)
        {
            p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup->m.srs_MaxUpPtsPresent 
                = 1;
            p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup->srs_MaxUpPts =
                p_cc->sounding_rs_ul_config_common.setup.srs_max_up_pts;
        }
    }
    else
    {
        p_asn1_cc->soundingRS_UL_ConfigCommon.t =
            T_SoundingRS_UL_ConfigCommon_release;
    }

    /* - uplinkPowerControl */
    p_asn1_cc->uplinkPowerControlCommon.p0_NominalPUSCH =
        p_cc->uplink_power_control_common.p_zero_nominal_Pusch;

    p_asn1_cc->uplinkPowerControlCommon.alpha =
        p_cc->uplink_power_control_common.alpha;

    p_asn1_cc->uplinkPowerControlCommon.p0_NominalPUCCH =
        p_cc->uplink_power_control_common.p_zero_nominal_pucch;

    p_asn1_cc->uplinkPowerControlCommon.deltaPreambleMsg3 =
        p_cc->uplink_power_control_common.delta_preamble_msg_three;

    /* -- uplinkPowerControl/deltaFList_PUCCH */
    p_asn1_cc->uplinkPowerControlCommon.deltaFList_PUCCH.deltaF_PUCCH_Format1 =
        p_cc->uplink_power_control_common.delta_f_list_pucch.
        delta_f_pucch_format_one;

    p_asn1_cc->uplinkPowerControlCommon.deltaFList_PUCCH.deltaF_PUCCH_Format1b =
        p_cc->uplink_power_control_common.delta_f_list_pucch.
        delta_f_pucch_format_one_b;

    p_asn1_cc->uplinkPowerControlCommon.deltaFList_PUCCH.deltaF_PUCCH_Format2 =
        p_cc->uplink_power_control_common.delta_f_pucch_format_two.
        delta_f_pucch_format_two;

    p_asn1_cc->uplinkPowerControlCommon.deltaFList_PUCCH.deltaF_PUCCH_Format2a =
        p_cc->uplink_power_control_common.delta_f_pucch_format_two.
        delta_f_pucch_format_two_a;

    p_asn1_cc->uplinkPowerControlCommon.deltaFList_PUCCH.deltaF_PUCCH_Format2b =
        p_cc->uplink_power_control_common.delta_f_pucch_format_two.
        delta_f_pucch_format_two_b;

    p_asn1_cc->ul_CyclicPrefixLength =
        p_cc->ul_cyc_prefix_len;
    
    if (p_cc->presence_bitmask & RRC_CONFIG_COMMON_SIB_POWER_CONTROL_CMN_V1020)
    {
       p_asn1_cc->m._v2ExtPresent = 1;
       p_asn1_cc->m.uplinkPowerControlCommon_v1020Present = 1;

       p_asn1_cc->uplinkPowerControlCommon_v1020.deltaF_PUCCH_Format3_r10 =
           p_cc->uplink_power_control_common_v1020.pucch_format3_r10;

       p_asn1_cc->uplinkPowerControlCommon_v1020.deltaF_PUCCH_Format1bCS_r10 = 
           p_cc->uplink_power_control_common_v1020.pucch_format1_bcs_r10;

    }
    rtxDListInit(&p_asn1_cc->extElem1);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return RRC_SUCCESS;
}


/******************************************************************************
 *   FUNCTION NAME: fill_subframe_config
 *
 *   INPUTS       : uecc_gb_context_t*               p_uecc_gb_context
 *                  OSCTXT                          *p_asn1_ctx
 *                  MBSFN_SubframeConfigList        *p_asn1_sc
 *                  mbsfn_subframe_config_list_t    *p_sc
 *                   uecc_ue_context_t               *p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function converts mbsfn_subframe_config_list_t to
 *       MBSFN_SubframeConfiguration
 *       and checks whether input data are valid.
 *
 *   RETURNS:
 *       RRC_SUCCESS - all data are valid
 *       RRC_FAILURE - data are invalid or if there are not enough memory
 *
 ******************************************************************************/
static rrc_return_et fill_subframe_config
(
 uecc_gb_context_t*               p_uecc_gb_context,
 OSCTXT                          *p_asn1_ctx,    /* for memory allocation */
 MBSFN_SubframeConfigList        *p_asn1_sc,     /* destination */
 mbsfn_subframe_config_list_t    *p_sc,           /* source */
 uecc_ue_context_t               *p_ue_context
 )
{
    rrc_counter_t subframe_index                        = RRC_NULL;
    MBSFN_SubframeConfig                *p_asn1_sc_elem = PNULL;
    OSRTDListNode *p_asn1_list_node                     = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_asn1_sc);
    RRC_ASSERT(PNULL != p_sc);

    if ((p_sc->count < 1) || (p_sc->count > ARRSIZE(p_sc->
                    mbsfn_subframe_config)) || (p_sc->count > 
                    ASN1V_maxMBSFN_Allocations))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "Incorrect subframe config list count=%u."
                "Should be 1..min(RRM=%u, "
                "ASN.1=%u)",
                p_sc->count,
                ARRSIZE(p_sc->mbsfn_subframe_config),
                ASN1V_maxMBSFN_Allocations);
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return RRC_FAILURE;
    }

    /* Fill MBSFN_SubframeConfiguration */
    rtxDListInit(p_asn1_sc);

    for (subframe_index = 0; subframe_index < p_sc->count; subframe_index++)
    {
        rtxDListAllocNodeAndData(p_asn1_ctx, MBSFN_SubframeConfig,
                &p_asn1_list_node, &p_asn1_sc_elem);

        if (PNULL == p_asn1_list_node)
        {
            /* Not enough memory */
            return RRC_FAILURE;
        }

        /* Fill MBSFN_SubframeConfiguration_element */
        p_asn1_sc_elem->radioframeAllocationPeriod =
            p_sc->mbsfn_subframe_config[subframe_index].
            radio_frame_alloc_period;

        p_asn1_sc_elem->radioframeAllocationOffset =
            p_sc->mbsfn_subframe_config[subframe_index].
            radio_frame_alloc_offset;

        /* - subframeAllocation */

        if (SUBFRAME_ALLOCATION_ONE_FRAME == p_sc->
                mbsfn_subframe_config[subframe_index].subframe_allocation.
                presence_bitmask)
        {
            p_asn1_sc_elem->subframeAllocation.t =
                T_MBSFN_SubframeConfig_subframeAllocation_oneFrame;
            p_asn1_sc_elem->subframeAllocation.u.oneFrame =
                rtxMemAllocType(p_asn1_ctx,
                        ASN1BitStr32);
        if(p_asn1_sc_elem->subframeAllocation.u.oneFrame == PNULL)
        {
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return RRC_FAILURE;
        }

            p_asn1_sc_elem->subframeAllocation.u.oneFrame->numbits =
                ONE_FRAME_NBITS;
            l3_memcpy_wrapper(p_asn1_sc_elem->subframeAllocation.u.oneFrame->data,
                    p_sc->mbsfn_subframe_config[subframe_index].
                    subframe_allocation.one_frame,
                    sizeof(p_sc->mbsfn_subframe_config[subframe_index].
                        subframe_allocation.one_frame));
        }
        else if (SUBFRAME_ALLOCATION_FOUR_FRAMES == p_sc->
                mbsfn_subframe_config[subframe_index].subframe_allocation.
                presence_bitmask)
        {
            p_asn1_sc_elem->subframeAllocation.t =
                T_MBSFN_SubframeConfig_subframeAllocation_fourFrames;
            p_asn1_sc_elem->subframeAllocation.u.fourFrames =
                rtxMemAllocType(p_asn1_ctx,
                        ASN1BitStr32);
        if(p_asn1_sc_elem->subframeAllocation.u.fourFrames == PNULL)
        {
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return RRC_FAILURE;
        }

            p_asn1_sc_elem->subframeAllocation.u.fourFrames->numbits =
                FOUR_FRAME_NBITS;
            l3_memcpy_wrapper(p_asn1_sc_elem->subframeAllocation.u.fourFrames->data,
                    p_sc->mbsfn_subframe_config[subframe_index].
                    subframe_allocation.
                    four_frames,
                    sizeof(p_sc->mbsfn_subframe_config[subframe_index].
                        subframe_allocation.four_frames));
        }
        else
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,RRC_WARNING,
                    "Incorrect subframe_allocation.presence_bitmask=%u",
                    p_sc->mbsfn_subframe_config[subframe_index].
                    subframe_allocation.
                    presence_bitmask);
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return RRC_FAILURE;
        }

        rtxDListAppendNode(p_asn1_sc, p_asn1_list_node);
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return RRC_SUCCESS;
}

/*SPR_16778_START*/
/******************************************************************************
 *   FUNCTION NAME: fill_s1ap_cause 
 *
 *   INPUTS       : s1ap_Cause             *p_s1ap_cause
 *                  rrm_cause_t            *p_rrm_cause
 *                  uecc_ue_context_t      *p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function fill the s1ap_casue paramter using rrm_cause.
 *
 *   RETURNS: 
 *      RRC_SUCCESS/RRC_FAILURE
 ******************************************************************************/
rrc_return_et  fill_s1ap_cause(
        s1ap_Cause             *p_s1ap_cause,
        rrm_cause_t            *p_rrm_cause,
        uecc_ue_context_t      *p_ue_context
        )
{
    rrc_return_et result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    p_s1ap_cause->t = p_rrm_cause->type;
    switch(p_s1ap_cause->t)
    {
        case T_s1ap_Cause_radioNetwork:
            if (S1AP_CAUSE_RADIO_NETWORK_MAX_VALUE >= p_rrm_cause->value)
            {
              RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                  (p_ue_context->p_gb_context)->facility_name,
                  RRC_INFO, "Radio NW cause %u", p_s1ap_cause->t);
              p_s1ap_cause->u.radioNetwork = p_rrm_cause->value;
            }
            else
            {
                result = RRC_FAILURE;
            }
            break;
        case T_s1ap_Cause_transport:
            if (S1AP_CAUSE_TRANSPORT_MAX_VALUE >= p_rrm_cause->value)
            {
              RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                  (p_ue_context->p_gb_context)->facility_name,
                  RRC_INFO, "Transport cause %u", p_s1ap_cause->t);
              p_s1ap_cause->u.transport = p_rrm_cause->value;
            }
            else
            {
                result = RRC_FAILURE;
            }
            break;
        case  T_s1ap_Cause_nas:
            if (S1AP_CAUSE_NAS_MAX_VALUE >= p_rrm_cause->value)
            {
              RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                  (p_ue_context->p_gb_context)->facility_name,
                  RRC_INFO, "NAS cause %u", p_s1ap_cause->t);
              p_s1ap_cause->u.nas = p_rrm_cause->value;
            }
            else
            {
                result = RRC_FAILURE;
            }
            break;
        case T_s1ap_Cause_protocol:     
            if (S1AP_CAUSE_PROTOCOL_MAX_VALUE >= p_rrm_cause->value)
            {
              RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                  (p_ue_context->p_gb_context)->facility_name,
                  RRC_INFO, "Protocol cause %u", p_s1ap_cause->t);
              p_s1ap_cause->u.protocol = p_rrm_cause->value;
            }
            else
            {
                result = RRC_FAILURE;
            }
            break;
        case  T_s1ap_Cause_misc:
            if (S1AP_CAUSE_MISC_MAX_VALUE >= p_rrm_cause->value)
            {
              RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                  (p_ue_context->p_gb_context)->facility_name,
                  RRC_INFO, "Misc cause %u", p_s1ap_cause->t);
              p_s1ap_cause->u.misc = p_rrm_cause->value;
            }
            else
            {
                result = RRC_FAILURE;
            }
            break;
        default:
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "Wrong cause type appeared %d",p_s1ap_cause->t);
            result = RRC_FAILURE;
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}
/*SPR_16778_END*/

/******************************************************************************
 *   FUNCTION NAME: fill_rrm_cause_from_s1ap_cause
 *
 *   INPUTS       : rrm_cause_t        *p_rrm_cause
 *                  s1ap_Cause         *p_s1ap_caus
 *                  uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function fill the s1ap_casue paramter using rrm_cause.
 *
 *   RETURNS: N/A
 ******************************************************************************/
void fill_rrm_cause_from_s1ap_cause(
        rrm_cause_t        *p_rrm_cause,
        s1ap_Cause         *p_s1ap_cause,
        uecc_ue_context_t*  p_ue_context
        )
{
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    p_rrm_cause->type =(U8)p_s1ap_cause->t;
    switch(p_s1ap_cause->t)
    {
        case T_s1ap_Cause_radioNetwork:
            p_rrm_cause->value = (U16)p_s1ap_cause->u.radioNetwork;
            break;
        case T_s1ap_Cause_transport:
            p_rrm_cause->value = (U16)p_s1ap_cause->u.transport;
            break;
        case  T_s1ap_Cause_nas:
            p_rrm_cause->value = (U16)p_s1ap_cause->u.nas;
            break;
        case T_s1ap_Cause_protocol:
            p_rrm_cause->value = (U16)p_s1ap_cause->u.protocol;
            break;
        case  T_s1ap_Cause_misc:
            p_rrm_cause->value = (U16)p_s1ap_cause->u.misc;
            break;
        default:
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "Wrong cause type appeared %d",p_s1ap_cause->t);
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_s1ap_TargetRNC_ID
 *
 *   INPUTS       : uecc_gb_context_t*       p_uecc_gb_context
 *                  rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required
 *                  OSCTXT                  *p_asn1_ctx
 *                  s1ap_TargetRNC_ID       *p_target_rnc_id
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds s1ap_build_s1ap_TargetRNC_ID 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static  void uecc_s1ap_build_s1ap_TargetRNC_ID
(
 uecc_gb_context_t*       p_uecc_gb_context,
 rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required, 
 /*SPR 17777 +-*/
 s1ap_TargetRNC_ID       *p_target_rnc_id 
 )
{
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_ASSERT(PNULL!=p_rrc_rrm_ho_required);
    RRC_ASSERT(PNULL!=p_target_rnc_id);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
    asn1Init_s1ap_TargetRNC_ID(p_target_rnc_id);

    p_target_rnc_id->lAI.pLMNidentity.numocts = MCC_OCTET_SIZE;
    uecc_s1ap_generate_plmn_identity_int(
            p_target_rnc_id->lAI.pLMNidentity.data,
            &(p_rrc_rrm_ho_required->target_id.rnc_id.lai.plmn_identity));
    /* Filling lAI.lAC */
    p_target_rnc_id->lAI.lAC.numocts = 
        sizeof(p_rrc_rrm_ho_required->target_id.rnc_id.lai.location_area_code);
    l3_memcpy_wrapper(p_target_rnc_id->lAI.lAC.data,
            p_rrc_rrm_ho_required->target_id.rnc_id.lai.location_area_code,
            p_target_rnc_id->lAI.lAC.numocts);
    /* Filling lAI.extElem1 */
    rtxDListInit(&p_target_rnc_id->lAI.extElem1);
    p_target_rnc_id->lAI.m.iE_ExtensionsPresent = 0;
    /* Filling rAC */
   
    /*  CR0885 start */ 
    if( CS_PS_TYPE == p_rrc_rrm_ho_required->srvcc_ho_indication ) 
    {
        if(RRM_RNC_ROUTING_AREA_CODE_PRESENT & 
            p_rrc_rrm_ho_required->target_id.rnc_id.bitmask)
        {
            p_target_rnc_id->m.rACPresent = 1;
            p_target_rnc_id->rAC.numocts = 
                sizeof(p_rrc_rrm_ho_required->target_id.rnc_id.routing_area_code);
            l3_memcpy_wrapper(p_target_rnc_id->rAC.data,
                &p_rrc_rrm_ho_required->target_id.rnc_id.routing_area_code,
                p_target_rnc_id->rAC.numocts);
        }
    }
    /*  CR0885 end */

    /* Filling rNC_ID */
    p_target_rnc_id->rNC_ID =
        p_rrc_rrm_ho_required->target_id.rnc_id.rnc_id;
    /* Filling extended rNC_ID */
    if(RRM_RNC_EXTENDED_RNC_ID_PRESENT & 
            p_rrc_rrm_ho_required->target_id.rnc_id.bitmask)
    {
        p_target_rnc_id->m.extendedRNC_IDPresent = 1;
        p_target_rnc_id->extendedRNC_ID =
            p_rrc_rrm_ho_required->target_id.rnc_id.extended_rnc_id;
    }
    /* Filling extElem1 */
    rtxDListInit(&p_target_rnc_id->extElem1);
    p_target_rnc_id->m.iE_ExtensionsPresent = 0;
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_cn_domain_indicator_intrnl_enc
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT                          *pctxt
 *                  ranap_ProtocolExtensionField    *p_ele_cn_domain
 *                  U8                              cn_domain_ind
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function encodes cn_domain_indicator
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_cn_domain_indicator_intrnl_enc 
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_ele_cn_domain,
 U8                              cn_domain_ind
 )
{
    OSCTXT          asn1_ctx;
    rrc_return_et   result = RRC_FAILURE;
    U8              msg_buf[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET         *p_data = PNULL;

    RRC_ASSERT(PNULL != p_ele_cn_domain);
    RRC_ASSERT(PNULL != pctxt);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    do 
    {
        /* ASN Encode message */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_cn_domain_indicator_intrl_enc] "
                    "ASN1 context initialization failed.");
            break;
        }
        pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_S1AP_BUF_TYPE);
        if (RT_OK !=  asn1PE_ranap_CN_DomainIndicator(&asn1_ctx, cn_domain_ind))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "ASN1 encoding failed.");
            break;
        }
        p_ele_cn_domain->extensionValue.numocts = pe_GetMsgLen(&asn1_ctx);
        p_data = (U8 *)rtxMemAlloc(pctxt, p_ele_cn_domain->extensionValue.numocts);
        if (PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "[cn_domain_indicator]Memory allocation failed.");
            break;        
        }
        l3_memcpy_wrapper(p_data, msg_buf, p_ele_cn_domain->extensionValue.numocts);
        p_ele_cn_domain->extensionValue.data = p_data;
        result = RRC_SUCCESS;
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_hS_DSCH_MAC_d_Flow_ID_intrnl_enc
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT                          *pctxt
 *                  ranap_ProtocolExtensionField    *p_ele_mac_flow
 *                  U8                              hs_dsch_mac_flow_id
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function encodes hS_DSCH_MAC_d_Flow_ID 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_hS_DSCH_MAC_d_Flow_ID_intrnl_enc 
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_ele_mac_flow,
 U8                              hs_dsch_mac_flow_id
 )
{
    OSCTXT          asn1_ctx;
    rrc_return_et   result = RRC_FAILURE;
    U8              msg_buf[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET         *p_data = PNULL;

    RRC_ASSERT(PNULL != p_ele_mac_flow);
    RRC_ASSERT(PNULL != pctxt);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    do 
    {
        /* ASN Encode message */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_hS_DSCH_MAC_d_Flow_ID_intrnl_enc]"
                    "ASN1 context initialization failed.");
            break;
        }
        pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_S1AP_BUF_TYPE);
        if (RT_OK !=  
                asn1PE_ranap_HS_DSCH_MAC_d_Flow_ID(&asn1_ctx, hs_dsch_mac_flow_id))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_hS_DSCH_MAC_d_Flow_ID_intrnl_enc]"
                    "ASN1 encoding failed.");
            break;
        }
        p_ele_mac_flow->extensionValue.numocts = pe_GetMsgLen(&asn1_ctx);
        p_data = (U8 *)rtxMemAlloc(pctxt, p_ele_mac_flow->extensionValue.numocts);
        if (PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "[uecc_s1ap_hS_DSCH_MAC_d_Flow_ID_intrnl_enc]"
                    "Memory allocation failed.");
            break;        
        }
        l3_memcpy_wrapper(p_data, msg_buf, p_ele_mac_flow->extensionValue.numocts);
        p_ele_mac_flow->extensionValue.data = p_data;
        result = RRC_SUCCESS;
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_E_DCH_MAC_d_Flow_ID_intrnl_enc
 *
 *   INPUTS       : uecc_ue_context_t               *p_ue_contex
 *                  OSCTXT                          *pctxt
 *                  ranap_ProtocolExtensionField    *p_ele_mac_flow
 *                  U8                              e_dch_mac_flow_id
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function encodes E_DCH_MAC_d_Flow_ID_intrnl_enc
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_E_DCH_MAC_d_Flow_ID_intrnl_enc 
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_ele_mac_flow,
 U8                              e_dch_mac_flow_id
 )
{
    OSCTXT          asn1_ctx;
    rrc_return_et   result = RRC_FAILURE;
    U8              msg_buf[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET         *p_data = PNULL;

    RRC_ASSERT(PNULL != p_ele_mac_flow);
    RRC_ASSERT(PNULL != pctxt);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    do 
    {
        /* ASN Encode message */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_E_DCH_MAC_d_Flow_ID_intrnl_enc]"
                    "ASN1 context initialization failed.");
            break;
        }
        pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_S1AP_BUF_TYPE);
        if (RT_OK !=  
                asn1PE_ranap_E_DCH_MAC_d_Flow_ID(&asn1_ctx, e_dch_mac_flow_id))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_E_DCH_MAC_d_Flow_ID_intrnl_enc]"
                    "ASN1 encoding failed.");
            break;
        }
        p_ele_mac_flow->extensionValue.numocts = pe_GetMsgLen(&asn1_ctx);
        p_data = (U8 *)rtxMemAlloc(pctxt, p_ele_mac_flow->extensionValue.numocts);
        if (PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "[uecc_s1ap_E_DCH_MAC_d_Flow_ID_intrnl_enc]"
                    "Memory allocation failed.");
            break;        
        }
        l3_memcpy_wrapper(p_data, msg_buf, p_ele_mac_flow->extensionValue.numocts);
        p_ele_mac_flow->extensionValue.data = p_data;
        result = RRC_SUCCESS;
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_Trace_Rec_Session_info_intrnl_enc
 *
 *   INPUTS       : uecc_ue_context_t*                       p_ue_context
 *                  OSCTXT                                  *pctxt
 *                  ranap_ProtocolExtensionField            *p_elem
 *                  ranap_TraceRecordingSessionInformation  *p_trace_rec_sess_info
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function encodes Trace Recording Session Information
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_Trace_Rec_Session_info_intrnl_enc
(
 uecc_ue_context_t                       *p_ue_context,
 OSCTXT                                  *pctxt,
 ranap_ProtocolExtensionField            *p_elem,
 ranap_TraceRecordingSessionInformation  *p_trace_rec_sess_info                              
 )
{
    OSCTXT          asn1_ctx;
    rrc_return_et   result = RRC_FAILURE;
    U8              msg_buf[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET         *p_data = PNULL;

    RRC_ASSERT(PNULL != p_elem);
    RRC_ASSERT(PNULL != p_trace_rec_sess_info);
    RRC_ASSERT(PNULL != pctxt);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    do
    {
        /* ASN Encode message */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_Trace_Rec_Session_info_intrnl_enc]"
                    "ASN1 context initialization failed.");
            break;
        }
        pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_S1AP_BUF_TYPE);
        if (RT_OK != asn1PE_ranap_TraceRecordingSessionInformation(
                    &asn1_ctx, p_trace_rec_sess_info))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_Trace_Rec_Session_info_intrnl_enc]"
                    "ASN1 encoding failed.");
            break;
        }
        p_elem->extensionValue.numocts = pe_GetMsgLen(&asn1_ctx);
        p_data = (U8 *)rtxMemAlloc(pctxt, p_elem->extensionValue.numocts);
        if (PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "[uecc_s1ap_Trace_Rec_Session_info_intrnl_enc]"
                    "Memory allocation failed.");
            break;
        }
        l3_memcpy_wrapper(p_data, msg_buf, p_elem->extensionValue.numocts);
        p_elem->extensionValue.data = p_data;
        result = RRC_SUCCESS;
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_MBMS_Linking_info_intrnl_enc
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT                          *pctxt
 *                  ranap_ProtocolExtensionField    *p_elem
 *                  U8                              mbms_link_info
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function encodes MBMS Linking Information
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_MBMS_Linking_info_intrnl_enc
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 U8                              mbms_link_info
 )
{
    OSCTXT          asn1_ctx;
    rrc_return_et   result = RRC_FAILURE;
    U8              msg_buf[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET         *p_data = PNULL;

    RRC_ASSERT(PNULL != p_elem);
    RRC_ASSERT(PNULL != pctxt);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    do
    {
        /* ASN Encode message */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_MBMS_Linking_info_intrnl_enc]"
                    "ASN1 context initialization failed.");
            break;
        }
        pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_S1AP_BUF_TYPE);
        if (RT_OK !=  asn1PE_ranap_MBMSLinkingInformation(&asn1_ctx, mbms_link_info))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_MBMS_Linking_info_intrnl_enc]"
                    "ASN1 encoding failed.");
            break;
        }
        p_elem->extensionValue.numocts = pe_GetMsgLen(&asn1_ctx);
        p_data = (U8 *)rtxMemAlloc(pctxt, p_elem->extensionValue.numocts);
        if (PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "[uecc_s1ap_MBMS_Linking_info_intrnl_enc]"
                    "Memory allocation failed.");
            break;
        }
        l3_memcpy_wrapper(p_data, msg_buf, p_elem->extensionValue.numocts);
        p_elem->extensionValue.data = p_data;
        result = RRC_SUCCESS;
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_d_rnti_intrnl_enc
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT                          *pctxt
 *                  ranap_ProtocolExtensionField    *p_elem
 *                  U32                              d_rnti
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function encodes D-RNTI
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_d_rnti_intrnl_enc 
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 U32                              d_rnti
 )
{
    OSCTXT          asn1_ctx;
    rrc_return_et   result = RRC_FAILURE;
    U8              msg_buf[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET         *p_data = PNULL;

    RRC_ASSERT(PNULL != p_elem);
    RRC_ASSERT(PNULL != pctxt);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    do
    {
        /* ASN Encode message */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_d_rnti_intrnl_enc]"
                    "ASN1 context initialization failed.");
            break;
        }
        pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_S1AP_BUF_TYPE);
        if (RT_OK != asn1PE_ranap_D_RNTI(&asn1_ctx, d_rnti))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_d_rnti_intrnl_enc]"
                    "ASN1 encoding failed.");
            break;
        }
        p_elem->extensionValue.numocts = pe_GetMsgLen(&asn1_ctx);
        p_data = (U8 *)rtxMemAlloc(pctxt, p_elem->extensionValue.numocts);
        if (PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "[uecc_s1ap_d_rnti_intrnl_enc]"
                    "Memory allocation failed.");
            break;
        }
        l3_memcpy_wrapper(p_data, msg_buf, p_elem->extensionValue.numocts);
        p_elem->extensionValue.data = p_data;
        result = RRC_SUCCESS;
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_ue_history_intrnl_enc
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT                          *pctxt
 *                  ranap_ProtocolExtensionField    *p_elem
 *                  s1ap_UE_HistoryInformation      *p_ue_history_info
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function encodes Ue History Information
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_ue_history_intrnl_enc 
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 s1ap_UE_HistoryInformation      *p_ue_history_info
 )
{
    OSCTXT          asn1_ctx;
    rrc_return_et   result = RRC_FAILURE;
    U8              msg_buf[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET         *p_data = PNULL;
    /* SPR 16939 Fix Start */
    ranap_UE_History_Information      ranap_ue_history_info;
    /* SPR 16939 Fix Stop */

    RRC_ASSERT(PNULL != p_elem);
    RRC_ASSERT(PNULL != pctxt);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    do
    {
        /* ASN Encode message */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_ue_history_intrnl_enc]"
                    "ASN1 context initialization failed.");
            break;
        }
        pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_S1AP_BUF_TYPE);
        if (RT_OK != asn1PE_s1ap_UE_HistoryInformation(&asn1_ctx, p_ue_history_info))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_ue_history_intrnl_enc]"
                    "ASN1 encoding failed.");
            break;
        }

        /* SPR 16939 Fix Start */
    asn1Init_ranap_UE_History_Information(&ranap_ue_history_info);

        ranap_ue_history_info.numocts = pe_GetMsgLen(&asn1_ctx);
        ranap_ue_history_info.data = (U8 *)rtxMemAlloc(pctxt, ranap_ue_history_info.numocts);
        if (PNULL == ranap_ue_history_info.data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "[uecc_s1ap_ue_history_intrnl_enc]"
                    "RANAP UE History Info Memory allocation failed.");
            break;
        }
        p_data = (OSOCTET *)ranap_ue_history_info.data;

        l3_memcpy_wrapper(p_data, msg_buf, ranap_ue_history_info.numocts);

        pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_S1AP_BUF_TYPE);

        if (RT_OK != asn1PE_ranap_UE_History_Information(&asn1_ctx, ranap_ue_history_info))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_ue_history_intrnl_enc]"
                    "RANAP UE History Info ASN1 encoding failed.");
            break;
        }
        /* SPR 16939 Fix Stop */

        p_elem->extensionValue.numocts = pe_GetMsgLen(&asn1_ctx);
        p_data = (U8 *)rtxMemAlloc(pctxt, p_elem->extensionValue.numocts);
        if (PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "[uecc_s1ap_ue_history_intrnl_enc]"
                    "Memory allocation failed.");
            break;
        }
        l3_memcpy_wrapper(p_data, msg_buf, p_elem->extensionValue.numocts);
        p_elem->extensionValue.data = p_data;
        result = RRC_SUCCESS;
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_subs_profile_id_rfp_intrnl_enc
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT                          *pctxt
 *                  ranap_ProtocolExtensionField    *p_elem
 *                  U16                              subs_profile_id
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function encodes Subscriber Profile ID for RFP
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_subs_profile_id_rfp_intrnl_enc 
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 U16                              subs_profile_id
 )
{
    OSCTXT          asn1_ctx;
    rrc_return_et   result = RRC_FAILURE;
    U8              msg_buf[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET         *p_data = PNULL;

    RRC_ASSERT(PNULL != p_elem);
    RRC_ASSERT(PNULL != pctxt);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    do
    {
        /* ASN Encode message */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_subs_profile_id_rfp_intrnl_enc]"
                    "ASN1 context initialization failed.");
            break;
        }
        pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_S1AP_BUF_TYPE);
        if (RT_OK !=  asn1PE_ranap_SubscriberProfileIDforRFP(&asn1_ctx, subs_profile_id))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR, 
                    "[uecc_s1ap_subs_profile_id_rfp_intrnl_enc]"
                    "ASN1 encoding failed.");
            break;
        }
        p_elem->extensionValue.numocts = pe_GetMsgLen(&asn1_ctx);
        p_data = (U8 *)rtxMemAlloc(pctxt, p_elem->extensionValue.numocts);
        if (PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "[uecc_s1ap_subs_profile_id_rfp_intrnl_enc]"
                    "Memory allocation failed.");
            break;
        }
        l3_memcpy_wrapper(p_data, msg_buf, p_elem->extensionValue.numocts);
        p_elem->extensionValue.data = p_data;
        result = RRC_SUCCESS;
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_srvcc_info_intrnl_enc
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT                          *pctxt
 *                  ranap_ProtocolExtensionField    *p_elem
 *                  ranap_SRVCC_Information         *p_srvcc_info
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function encodes SRVCC information
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_srvcc_info_intrnl_enc
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 ranap_SRVCC_Information         *p_srvcc_info
 )
{
    OSCTXT          asn1_ctx;
    rrc_return_et   result = RRC_FAILURE;
    U8              msg_buf[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET         *p_data = PNULL;

    RRC_ASSERT(PNULL != p_elem);
    RRC_ASSERT(PNULL != pctxt);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    do
    {
        /* ASN Encode message */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_srvcc_info_intrnl_enc]"
                    "ASN1 context initialization failed.");
            break;
        }
        pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_S1AP_BUF_TYPE);
        if (RT_OK != asn1PE_ranap_SRVCC_Information(&asn1_ctx, p_srvcc_info))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR, 
                    "[uecc_s1ap_srvcc_info_intrnl_enc]"
                    "ASN1 encoding failed.");
            break;
        }
        p_elem->extensionValue.numocts = pe_GetMsgLen(&asn1_ctx);
        p_data = (U8 *)rtxMemAlloc(pctxt, p_elem->extensionValue.numocts);
        if (PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "[uecc_s1ap_srvcc_info_intrnl_enc]"
                    "Memory allocation failed.");
            break;
        }
        l3_memcpy_wrapper(p_data, msg_buf, p_elem->extensionValue.numocts);
        p_elem->extensionValue.data = p_data;
        result = RRC_SUCCESS;
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_ps_rab_replace_intrnl_enc 
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT                          *pctxt
 *                  ranap_ProtocolExtensionField    *p_elem
 *                  ranap_RAB_ID                    *p_rab_id
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function encodes PS RAB ID to be Replace
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_ps_rab_replace_intrnl_enc 
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 ranap_RAB_ID                    *p_rab_id
 )
{
    OSCTXT          asn1_ctx;
    rrc_return_et   result = RRC_FAILURE;
    U8              msg_buf[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET         *p_data = PNULL;
    ranap_RAB_ID                    rab_id;

    RRC_ASSERT(PNULL != p_elem);
    RRC_ASSERT(PNULL != pctxt);
    RRC_ASSERT(PNULL != p_rab_id);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&rab_id, RRC_NULL, sizeof(ranap_RAB_ID));
    l3_memcpy_wrapper(&rab_id, p_rab_id, sizeof(ranap_RAB_ID));

    do
    {
        /* ASN Encode message */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_ps_rab_replace_intrnl_enc]"
                    "ASN1 context initialization failed.");
            break;
        }
        pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_S1AP_BUF_TYPE);
        if (RT_OK !=  asn1PE_ranap_RAB_ID(&asn1_ctx, rab_id))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_ps_rab_replace_intrnl_enc]"
                    "ASN1 encoding failed.");
            break;
        }
        p_elem->extensionValue.numocts = pe_GetMsgLen(&asn1_ctx);
        p_data = (U8 *)rtxMemAlloc(pctxt, p_elem->extensionValue.numocts);
        if (PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "[uecc_s1ap_ps_rab_replace_intrnl_enc]"
                    "Memory allocation failed.");
            break;
        }
        l3_memcpy_wrapper(p_data, msg_buf, p_elem->extensionValue.numocts);
        p_elem->extensionValue.data = p_data;
        result = RRC_SUCCESS;
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}
/*srvcc-u start*/
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_IRAT_meas_config_info_intrnl_enc 
 *
 *   INPUTS       : uecc_ue_context_t*    p_ue_context
 *                  OSCTXT                         *pctxt
 *                  ranap_ProtocolExtensionField   *p_elem
 *                  irat_meas_config_t    irat_meas_config
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function encodes IRAT MEAS CONFIG Information
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et  uecc_s1ap_IRAT_meas_config_info_intrnl_enc 
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 ranap_IRAT_Measurement_Configuration  *p_irat_meas_config
 )
{
    OSCTXT          asn1_ctx;
    rrc_return_et   result = RRC_FAILURE;
    U8              msg_buf[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET         *p_data = PNULL;

    RRC_ASSERT(PNULL != p_elem);
    RRC_ASSERT(PNULL != pctxt);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    do
    {
        /* ASN Encode message */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_IRAT_meas_config_info_intrnl_enc]"
                    "ASN1 context initialization failed.");
            break;
        }
        pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_S1AP_BUF_TYPE);
        if (RT_OK !=  asn1PE_ranap_IRAT_Measurement_Configuration(&asn1_ctx, p_irat_meas_config))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR, 
                    "[uecc_s1ap_IRAT_meas_config_info_intrnl_enc]"
                    "ASN1 encoding failed.");
            break;
        }
        p_elem->extensionValue.numocts = pe_GetMsgLen(&asn1_ctx);
        p_data = (U8 *)rtxMemAlloc(pctxt, p_elem->extensionValue.numocts);
        if (PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "[uecc_s1ap_IRAT_meas_config_info_intrnl_enc]"
                    "Memory allocation failed.");
            break;
        }
        l3_memcpy_wrapper(p_data, msg_buf, p_elem->extensionValue.numocts);
        p_elem->extensionValue.data = p_data;
        result = RRC_SUCCESS;
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}
/*srvcc-u stop*/
/******************************************************************************
 *   FUNCTION NAME:uecc_s1ap_CSFB_info_intrnl_enc 
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT                          *pctxt
 *                  ranap_ProtocolExtensionField    *p_elem
 *                  U8                              csfb_info
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function encodes CSFB info
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_CSFB_info_intrnl_enc 
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 U8                              csfb_info
 )
{
    OSCTXT          asn1_ctx;
    rrc_return_et   result = RRC_FAILURE;
    U8              msg_buf[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET         *p_data = PNULL;

    RRC_ASSERT(PNULL != p_elem);
    RRC_ASSERT(PNULL != pctxt);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    do
    {
        /* ASN Encode message */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_CSFB_info_intrnl_enc]"
                    "ASN1 context initialization failed.");
            break;
        }
        pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_S1AP_BUF_TYPE);
        if (RT_OK !=  asn1PE_ranap_CSFB_Information(&asn1_ctx, csfb_info))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR, 
                    "[uecc_s1ap_CSFB_info_intrnl_enc]"
                    "ASN1 encoding failed.");
            break;
        }
        p_elem->extensionValue.numocts = pe_GetMsgLen(&asn1_ctx);
        p_data = (U8 *)rtxMemAlloc(pctxt, p_elem->extensionValue.numocts);
        if (PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "[uecc_s1ap_CSFB_info_intrnl_enc]"
                    "Memory allocation failed.");
            break;
        }
        l3_memcpy_wrapper(p_data, msg_buf, p_elem->extensionValue.numocts);
        p_elem->extensionValue.data = p_data;
        result = RRC_SUCCESS;
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_n_encode_rrc_container 
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT                         *pctxt
 *                  ranap_RRC_Container            *p_rrc_container
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function fills Inter RAT Handover Info with Inter RAT Capability 
 *          information (utra and eutra rat_strings) in ToTargetRNC_Container 
 *          structure (defined in 25331). Finally. Encoded ToTargetRNC_Container 
 *          string copied to rrc_container of sourceRNC to targetRNC container.    
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_n_encode_rrc_container 
(
 uecc_ue_context_t              *p_ue_context,
 OSCTXT                         *pctxt,
 ranap_RRC_Container            *p_rrc_container
 )
{
    OSCTXT                  asn1_ctx;
    rrc_return_et           result = RRC_FAILURE;
    U8                      msg_buf[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET                 *p_data = PNULL;
    OSOCTET                 *p_inter_rat_cap_data = PNULL;
    utran_ToTargetRNC_Container   rnc_container;
    utran_InterRATHandoverInfoWithInterRATCapabilities_r3_r3 *p_r3 = PNULL;
    UE_Radio_Capability_RAT_Container_t* p_ue_radio_capability_utra;
    UE_Radio_Capability_RAT_Container_t* p_ue_radio_capability_eutra;
    RAT_Type rat_type;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                "[s1ap_HandoverCancel] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    rat_type = utra_1;
    p_ue_radio_capability_utra = (UE_Radio_Capability_RAT_Container_t *) 
        ylFind(&p_ue_context->ue_radio_capability,
                &rat_type, 
                uecc_rat_type_keyof, 
                uecc_rat_type_compare);

    rat_type = eutra;
    p_ue_radio_capability_eutra = (UE_Radio_Capability_RAT_Container_t *) 
        ylFind(&p_ue_context->ue_radio_capability,
                &rat_type, 
                uecc_rat_type_keyof, 
                uecc_rat_type_compare);
    
    if ((p_ue_radio_capability_utra != PNULL) &&
        (p_ue_radio_capability_eutra != PNULL))
    {
    /* Validating RAT strings */
        if((RRC_TRUE == p_ue_radio_capability_utra->valid_rat_string)
                &&
                (RRC_TRUE  == p_ue_radio_capability_eutra->valid_rat_string))
    {    
        asn1Init_utran_ToTargetRNC_Container(&rnc_container); 
        /* Filling INTER RAT HANDOVER INFO WITH INTER RAT CAPABILITIES */
        /*
         *  INTER RAT CAPABILITIES will be filled in v860NonCriticalExtensions in ToTargetRNC_Container.
         *  To reach to v860NonCriticalExtensions following bitmask (recursively) to be set:
         *  1.  m.v390NonCriticalExtensionsPresent = 1
         *  2.  v390NonCriticalExtensions.m.v690NonCriticalExtensionsPresent = 1;
         *  3.  v390NonCriticalExtensions.v690NonCriticalExtensions.m.v860NonCriticalExtensionsPresent = 1;
         *  4.  v390NonCriticalExtensions.v690NonCriticalExtensions.v860NonCriticalExtensions.
         interRATHandoverInfoWithInterRATCapabilities_v860ext.m.ue_RATSpecificCapabilityPresent = 1;
         *  5.  v390NonCriticalExtensions.v690NonCriticalExtensions.v860NonCriticalExtensions.
         interRATHandoverInfoWithInterRATCapabilities_v860ext.ue_RATSpecificCapability.m.
         eutra_RadioAccessCapabilityPresent = 1;
         Set remaining bitmasks(recursive) and variables to 0/NULL as they not required in this.        
         */

        rnc_container.t = T_utran_ToTargetRNC_Container_interRATHandoverInfo;
        rnc_container.u.interRATHandoverInfo = 
            rtxMemAllocType(&asn1_ctx, utran_InterRATHandoverInfoWithInterRATCapabilities_r3);
        /* SPR 12964 Fix Start */
        if (PNULL == rnc_container.u.interRATHandoverInfo)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "Mem Alloc failed");
            /*SPR_18125_START*/
            rtFreeContext(&asn1_ctx);
            /*SPR_18125_END*/
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /* SPR 12964 Fix Stop */
        rnc_container.u.interRATHandoverInfo->t = 
            T_utran_InterRATHandoverInfoWithInterRATCapabilities_r3_r3;    
        rnc_container.u.interRATHandoverInfo->u.r3 = 
            rtxMemAllocType(&asn1_ctx, utran_InterRATHandoverInfoWithInterRATCapabilities_r3_r3);
        /* SPR 12964 Fix Start */
        if (PNULL == rnc_container.u.interRATHandoverInfo->u.r3)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "Mem Alloc failed");
            /*SPR_18125_START*/
            rtFreeContext(&asn1_ctx);
            /*SPR_18125_END*/
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /* SPR 12964 Fix Stop */
        p_r3 = rnc_container.u.interRATHandoverInfo->u.r3;    
        /* 1 */
        p_r3->m.v390NonCriticalExtensionsPresent = 1;
        p_r3->interRATHandoverInfo_r3.m.ue_RATSpecificCapabilityPresent = 0;
        /* Fill INTER RAT HANDOVER INFO */
        p_r3->interRATHandoverInfo_r3.interRATHandoverInfo.numocts = 
                p_ue_radio_capability_utra->numocts;
        l3_memcpy_wrapper(p_r3->interRATHandoverInfo_r3.interRATHandoverInfo.data,
                    /* SPR 13502 Fix Start */
                    p_ue_radio_capability_utra->p_rat_string,
                    /* SPR 13502 Fix Stop */
                    p_ue_radio_capability_utra->numocts);
        /* 2 */ 
        p_r3->v390NonCriticalExtensions.m.v690NonCriticalExtensionsPresent = 1;
        p_r3->v390NonCriticalExtensions.                                        \
            interRATHandoverInfoWithInterRATCapabilities_v390ext.m.             \
            failureCauseWithProtErrPresent = 0;
        /* 3 */    
        p_r3->v390NonCriticalExtensions.v690NonCriticalExtensions.m.            \
            v860NonCriticalExtensionsPresent = 1;
        p_r3->v390NonCriticalExtensions.v690NonCriticalExtensions.              \
            interRATHandoverInfoWithInterRATCapabilities_v690ext.m.             \
            ue_RATSpecificCapability_v690extPresent = 0;
        p_r3->v390NonCriticalExtensions.v690NonCriticalExtensions.              \
            v860NonCriticalExtensions.m.v920NonCriticalExtensionsPresent = 0;  
        /* 4 */
        p_r3->v390NonCriticalExtensions.v690NonCriticalExtensions.              \
            v860NonCriticalExtensions.                                         \
            interRATHandoverInfoWithInterRATCapabilities_v860ext.m.            \
            ue_RATSpecificCapabilityPresent = 1;
        /* 5 */
        p_r3->v390NonCriticalExtensions.v690NonCriticalExtensions.              \
            v860NonCriticalExtensions.                                         \
            interRATHandoverInfoWithInterRATCapabilities_v860ext.              \
            ue_RATSpecificCapability.m.eutra_RadioAccessCapabilityPresent = 1;
        /* Filling INTER RAT CAPABILITIES */    
        p_r3->v390NonCriticalExtensions.v690NonCriticalExtensions.              \
            v860NonCriticalExtensions.                                         \
            interRATHandoverInfoWithInterRATCapabilities_v860ext.              \
            ue_RATSpecificCapability.eutra_RadioAccessCapability.
            ue_EUTRA_Capability.numocts = 
                p_ue_radio_capability_eutra->numocts;
        p_inter_rat_cap_data = rtxMemAlloc(&asn1_ctx,
                    p_ue_radio_capability_eutra->numocts);
        /* SPR 12964 Fix Start */
        if(PNULL == p_inter_rat_cap_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "Mem Alloc failed");
            /*SPR_18125_START*/
            rtFreeContext(&asn1_ctx);
            /*SPR_18125_END*/
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /* SPR 12964 Fix Stop */
        l3_memcpy_wrapper(p_inter_rat_cap_data,
                    /* SPR 13502 Fix Start */
                    p_ue_radio_capability_eutra->p_rat_string,
                    /* SPR 13502 Fix Stop */
                    p_ue_radio_capability_eutra->numocts);

        p_r3->v390NonCriticalExtensions.v690NonCriticalExtensions.          \
            v860NonCriticalExtensions.                                      \
            interRATHandoverInfoWithInterRATCapabilities_v860ext.           \
            ue_RATSpecificCapability.eutra_RadioAccessCapability.           \
            ue_EUTRA_Capability.data = p_inter_rat_cap_data;

        do
        {
        /* CSR 101813 Fix Start */
            pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_RRC_BUF_TYPE);/* CSR 101813 Fix Stop */
            if (RT_OK != asn1PE_utran_ToTargetRNC_Container(&asn1_ctx, &rnc_container))
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                        p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                        "[uecc_s1ap_build_n_encode_rrc_container]"
                        "ASN1 encoding failed.");
                break;
            }
            p_rrc_container->numocts = pe_GetMsgLen(&asn1_ctx);
            p_data = (U8 *)rtxMemAlloc(pctxt,  p_rrc_container->numocts);
            if (PNULL == p_data)
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                        p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                        "[uecc_s1ap_build_n_encode_rrc_container]"
                        "Memory allocation failed.");
                break;
            }
            l3_memcpy_wrapper(p_data, msg_buf,  p_rrc_container->numocts);
            p_rrc_container->data = p_data;
            result = RRC_SUCCESS;
        } while(0);

        /* Free ASN Context */
        rtFreeContext(&asn1_ctx);
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return result;
    }
        /*SPR_18125_START*/
        rtFreeContext(&asn1_ctx);
        /*SPR_18125_END*/
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return result;
    }
    else
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                "[uecc_s1ap_build_n_encode_rrc_container]"
                "Either or Both Rat_strings not available in UE Context");
        rtFreeContext(&asn1_ctx);
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }    
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_fill_rnc_container_security_info
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  ranap_SourceRNC_ToTargetRNC_TransparentContainer
 *                                                *p_s1ap_rnc_container
 *                  security_info_t     *p_security_info
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function fills security information in RNC Transparent Container
 *
 *   RETURNS: None
 *
 *******************************************************************************/
static void uecc_s1ap_fill_rnc_container_security_info
(
 uecc_gb_context_t*               p_uecc_gb_context,
 ranap_SourceRNC_ToTargetRNC_TransparentContainer 
 *p_s1ap_rnc_container, /*dst*/
 security_info_t     *p_security_info /*src*/
 )
{
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
    /* Filling Chosen Integrity Protection Algorithm */
    if(SECURITY_INFO_CHOSEN_INTEGRITY_PROTECTION_ALGO_PRESENT &
            p_security_info->bitmask)
    {
        p_s1ap_rnc_container->m.chosenIntegrityProtectionAlgorithmPresent = 1;
        p_s1ap_rnc_container->chosenIntegrityProtectionAlgorithm =
            p_security_info->chosen_integrity_protection_algo;
    }
    /* Filling Integrity Protection Key */
    if(SECURITY_INFO_INTEGRITY_PROTECTION_KEY_PRESENT &                     \
            p_security_info->bitmask)
    {
        p_s1ap_rnc_container->m.integrityProtectionKeyPresent = 1;
        p_s1ap_rnc_container->integrityProtectionKey.numbits = 8 * (        \
                sizeof(p_security_info->integration_protection_key));
        l3_memcpy_wrapper( p_s1ap_rnc_container->integrityProtectionKey.data,  
                p_security_info->integration_protection_key,
                sizeof(p_security_info->integration_protection_key));
    }
    /* Filling Chosen Encryption Algorithm */
    if(SECURITY_INFO_CHOSEN_ENCRYPTION_ALGO_PRESENT & p_security_info->bitmask)
    {
        p_s1ap_rnc_container->m.chosenEncryptionAlgorithForSignallingPresent = 1;
        p_s1ap_rnc_container->chosenEncryptionAlgorithForSignalling =          \
                                                                            p_security_info->chosen_encryption_algo;
    }
    /* Filling Ciphering Key */
    if (SECURITY_INFO_CIPHERING_KEY_PRESENT & p_security_info->bitmask)
    {
        p_s1ap_rnc_container->m.cipheringKeyPresent = 1;
        p_s1ap_rnc_container->cipheringKey.numbits = 8 * (                  \
                sizeof(p_security_info->ciphering_key));
        l3_memcpy_wrapper(p_s1ap_rnc_container->cipheringKey.data,
                p_security_info->ciphering_key,
                sizeof(p_security_info->ciphering_key));
    }
    /* Filling Chosen Encryption Algorithm for CS user data */
    if(SECURITY_INFO_CHOSEN_CS_ENCRYPTION_ALGO_PRESENT &        \
            p_security_info->bitmask)
    {
        p_s1ap_rnc_container->m.chosenEncryptionAlgorithForCSPresent = 1;
        p_s1ap_rnc_container->chosenEncryptionAlgorithForCS = 
            p_security_info->chosen_cs_encryption_algorithm;
    }
    /* Filling Chosen Encryption Algorithm for PS user data */
    if(SECURITY_INFO_CHOSEN_PS_ENCRYPTION_ALGO_PRESENT &        \
            p_security_info->bitmask)
    {
        p_s1ap_rnc_container->m.chosenEncryptionAlgorithForPSPresent = 1;
        p_s1ap_rnc_container->chosenEncryptionAlgorithForPS = 
            p_security_info->chosen_ps_encryption_algorithm;
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_SRB_TrCH_Mapping_intrnl_enc
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT                          *pctxt
 *                  ranap_ProtocolExtensionField    *p_elem
 *                  ranap_SRB_TrCH_MappingItem      *p_srb_trch_map
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function encodes SRB_TrCH_Mapping
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_SRB_TrCH_Mapping_intrnl_enc
(
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *pctxt,
 ranap_ProtocolExtensionField    *p_elem,
 ranap_SRB_TrCH_MappingItem      *p_srb_trch_map
 )
{
    OSCTXT          asn1_ctx;
    rrc_return_et   result = RRC_FAILURE;
    U8              msg_buf[S1AP_MAX_ASN1_BUF_LEN];
    OSOCTET         *p_data = PNULL;

    RRC_ASSERT(PNULL != p_elem);
    RRC_ASSERT(PNULL != pctxt);
    RRC_ASSERT(PNULL != p_srb_trch_map);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    do
    {
        /* ASN Encode message */
        if (RT_OK != rtInitContext(&asn1_ctx))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "[uecc_s1ap_cn_domain_indicator_intrl_enc] "
                    "ASN1 context initialization failed.");
            break;
        }
        pu_setBuffer(&asn1_ctx, msg_buf, S1AP_MAX_ASN1_BUF_LEN, ASN_S1AP_BUF_TYPE);
        if (RT_OK !=  asn1PE_ranap_SRB_TrCH_MappingItem(&asn1_ctx, p_srb_trch_map))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR, "ASN1 encoding failed.");
            break;
        }
        p_elem->extensionValue.numocts = pe_GetMsgLen(&asn1_ctx);
        p_data = (U8 *)rtxMemAlloc(pctxt, p_elem->extensionValue.numocts);
        if (PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name, RRC_FATAL,
                    "[cn_domain_indicator]Memory allocation failed.");
            break;
        }
        l3_memcpy_wrapper(p_data, msg_buf, p_elem->extensionValue.numocts);
        p_elem->extensionValue.data = p_data;
        result = RRC_SUCCESS;
    } while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_ranap_RAB_TrCH_Mapping
 *
 *   INPUTS       : rrm_source_rnc_to_target_rnc_transparent_container_t
 *                                                           *p_rnc_container
 *                  OSCTXT                                   *p_asn1_ctx
 *                  ranap_RAB_TrCH_Mapping                   *p_ranap_RAB_TrCH_Mapping
 *                  U8                            no_of_rab_trch_mappings
 *                  uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds RAB Transport Channel Mapping List. 
 *      The following steps taken while appending the items in the list.
 *          1.  Fill contents of ranap_RAB_TrCH_MappingItem structure
 *              a.  RAB_ID.
 *              b.  TrCH_ID_List (step 2).
 *              c.  ProtocolExtensionContainer :
 *                  This list contains value of CN_Domain Indicator.
 *              d.  extElem1 (Empty List).
 *          2.  Build TrCH_ID_List by filling ranap_TrCH_ID structure
 *              a.  DCH_ID
 *              b.  DSCH_ID
 *              c.  USCH_ID
 *              d.  ProtocolExtensionContainer : 
 *                  This List contains nodes with values of 
 *                   HS_DSCH_MAC_D_FLOW_ID and E_DCH_MAC_D_FLOW_ID
 *              e.  extElem1 (Empty List).
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_ranap_RAB_TrCH_Mapping
(
 rrm_source_rnc_to_target_rnc_transparent_container_t    *p_rnc_container,
 OSCTXT                                                  *p_asn1_ctx,
 ranap_RAB_TrCH_Mapping                          *p_ranap_RAB_TrCH_Mapping,
 U8                                              no_of_rab_trch_mappings,
 uecc_ue_context_t                               *p_ue_context
 )
{
    OSRTDListNode                   *p_node_trch_map = PNULL;
    OSRTDListNode                   *p_node_trch_id = PNULL;
    OSRTDListNode                   *p_node_trch_id_ie_ext = PNULL;
    OSRTDListNode                   *p_node_trch_map_ie_ext = PNULL;
    ranap_RAB_TrCH_MappingItem      *p_ele_trch_map_item = PNULL;
    ranap_TrCH_ID                   *p_ele_trch_id = PNULL;
    ranap_ProtocolExtensionField    *p_ele_cn_domain = PNULL;
    ranap_ProtocolExtensionField    *p_ele_mac_flow = PNULL;
    rrc_counter_t                   count = 0;
    rrc_counter_t                   inner_count = 0;

    RRC_ASSERT(PNULL!=p_rnc_container);
    RRC_ASSERT(PNULL!=p_asn1_ctx);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* Step 1 Starts*/
    /* Init List for RAB Transport Channel Mappiing Items */
    rtxDListInit(p_ranap_RAB_TrCH_Mapping);
    for (count = 0; count < no_of_rab_trch_mappings; count++) 
    {
        /* Allocating Node to fill RAB Transport Channel Mapping Item*/
        rtxDListAllocNodeAndData(p_asn1_ctx, ranap_RAB_TrCH_MappingItem,
                &p_node_trch_map, &p_ele_trch_map_item);
        if (PNULL == p_node_trch_map){
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_ranap_RAB_TrCH_Mapping]"
                    "Can't allocate p_node_trch_map");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        asn1Init_ranap_RAB_TrCH_MappingItem(p_ele_trch_map_item);
        /* Filling ranap_RAB_ID (step 1a) */
        p_ele_trch_map_item->rAB_ID.numbits = (8 * 
                sizeof(p_rnc_container->rab_transport_channel_mapping[count].rab_id));
        l3_memcpy_wrapper(p_ele_trch_map_item->rAB_ID.data,
                &p_rnc_container->rab_transport_channel_mapping[count].rab_id,
                (p_ele_trch_map_item->rAB_ID.numbits / 8));

        /* Step 2 Starts*/
        /* Init List for Transport Channel IDs */
        rtxDListInit(&p_ele_trch_map_item->trCH_ID_List);
        /* Filling ranap_TrCH_ID_List (step 1b) */
        for(inner_count = 0; 
                inner_count < p_rnc_container->                                 \
                rab_transport_channel_mapping[count].no_of_rab_subflow;
                inner_count++)
        {
            /* Allocating Node to fill Transport Channel IDs */
            rtxDListAllocNodeAndData(p_asn1_ctx, ranap_TrCH_ID,
                    &p_node_trch_id, &p_ele_trch_id);
            if (PNULL == p_node_trch_id){
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "[uecc_s1ap_build_ranap_RAB_TrCH_Mapping]"
                        "Can't allocate p_node_trch_id");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            asn1Init_ranap_TrCH_ID(p_ele_trch_id);
            /* Filling ranap_DCH_ID (step 2a) */
            if(TRANSPORT_CHANNEL_ID_DCH_ID_PRESENT &
                    p_rnc_container->rab_transport_channel_mapping[count].      \
                    transport_channel_id[inner_count].bitmask)
            {
                p_ele_trch_id->m.dCH_IDPresent = 1;
                p_ele_trch_id->dCH_ID = 
                    p_rnc_container->rab_transport_channel_mapping[count].  \
                    transport_channel_id[inner_count].dch_id;
            }
            /* Filling ranap_DSCH_ID (step 2b) */
            if(TRANSPORT_CHANNEL_ID_DSCH_ID_PRESENT &
                    p_rnc_container->rab_transport_channel_mapping[count].      \
                    transport_channel_id[inner_count].bitmask)
            {
                p_ele_trch_id->m.dSCH_IDPresent = 1;
                p_ele_trch_id->dSCH_ID = 
                    p_rnc_container->rab_transport_channel_mapping[count].  \
                    transport_channel_id[inner_count].dsch_id;
            }
            /* Filling ranap_USCH_ID (step 2c)*/
            if(TRANSPORT_CHANNEL_ID_USCH_ID_PRESENT &
                    p_rnc_container->rab_transport_channel_mapping[count].      \
                    transport_channel_id[inner_count].bitmask)
            {
                p_ele_trch_id->m.uSCH_IDPresent = 1;
                p_ele_trch_id->uSCH_ID = 
                    p_rnc_container->rab_transport_channel_mapping[count].  \
                    transport_channel_id[inner_count].usch_id;
            } 
            /* Filling ranap_ProtocolExtensionContainer (step 2d) */
            p_ele_trch_id->m.iE_ExtensionsPresent = 0;
            /* Init List for Transport Channel ID ProtocolExtension List */
            rtxDListInit(&p_ele_trch_id->iE_Extensions);
            if(TRANSPORT_CHANNEL_ID_HS_DSCH_MAC_D_FLOW_ID_PRESENT &
                    p_rnc_container->rab_transport_channel_mapping[count].  \
                    transport_channel_id[inner_count].bitmask)
            {
                p_ele_trch_id->m.iE_ExtensionsPresent = 1;
                /* Allocating Node to fill hS_DSCH_MAC_d_Flow_ID (step 2d:1) */
                rtxDListAllocNodeAndData(p_asn1_ctx, 
                        ranap_ProtocolExtensionField,
                        &p_node_trch_id_ie_ext, &p_ele_mac_flow);
                if (PNULL==p_node_trch_id_ie_ext)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,"Can't allocate p_node_trch_id_ie_ext");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
                asn1Init_ranap_ProtocolExtensionField(p_ele_mac_flow);

                p_ele_mac_flow->id = ASN1V_ranap_id_hS_DSCH_MAC_d_Flow_ID;
                p_ele_mac_flow->criticality = ranap_ignore;

                /* Encoding hS_DSCH_MAC_d_Flow_ID */
                if(RRC_FAILURE == uecc_s1ap_hS_DSCH_MAC_d_Flow_ID_intrnl_enc(
                            p_ue_context, 
                            p_asn1_ctx, p_ele_mac_flow,
                            p_rnc_container->rab_transport_channel_mapping[count].  \
                            transport_channel_id[inner_count].hs_dsch_mac_d_flow_id))
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_FATAL,
                            "[uecc_s1ap_build_ranap_RAB_TrCH_Mapping]"
                            "hS DSCH MAC d Flow ID internal enc Failed");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
                /* 
                 * Appending Node with hS_DSCH_MAC_d_Flow_ID 
                 *  to Transport Channel ID ProtocolExtension List
                 */
                rtxDListAppendNode(&p_ele_trch_id->iE_Extensions, 
                        p_node_trch_id_ie_ext);
            }
            if(TRANSPORT_CHANNEL_ID_E_DCH_MAC_D_FLOW_ID_PRESENT &
                    p_rnc_container->rab_transport_channel_mapping[count].  \
                    transport_channel_id[inner_count].bitmask)
            {                
                p_ele_trch_id->m.iE_ExtensionsPresent = 1;
                /* Allocating Node to fill E_DCH_MAC_d_Flow_ID (step 2d:2) */
                rtxDListAllocNodeAndData(p_asn1_ctx, 
                        ranap_ProtocolExtensionField,
                        &p_node_trch_id_ie_ext, &p_ele_mac_flow);

                if (PNULL==p_node_trch_id_ie_ext)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,"Can't allocate p_node_trch_id_ie_ext");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
                asn1Init_ranap_ProtocolExtensionField(p_ele_mac_flow);

                p_ele_mac_flow->id = ASN1V_ranap_id_E_DCH_MAC_d_Flow_ID;
                p_ele_mac_flow->criticality = ranap_ignore;

                /* Encoding E_DCH_MAC_d_Flow_ID */
                if(RRC_FAILURE == uecc_s1ap_E_DCH_MAC_d_Flow_ID_intrnl_enc(
                            p_ue_context, p_asn1_ctx, p_ele_mac_flow,
                            p_rnc_container->rab_transport_channel_mapping[count].      \
                            transport_channel_id[inner_count].e_dch_mac_d_flow_id))
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_FATAL,
                            "[uecc_s1ap_build_ranap_RAB_TrCH_Mapping]"
                            "E DCH MAC d Flow ID internal enc Failed");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
                /*
                 * Appending Node with E_DCH_MAC_d_Flow_ID
                 *  to Transport Channel ID ProtocolExtension List
                 */
                rtxDListAppendNode(&p_ele_trch_id->iE_Extensions, 
                        p_node_trch_id_ie_ext);
            }
            /* Filling extElem1 (step 2e) */
            rtxDListInit(&p_ele_trch_id->extElem1);
            /*
             * Appending Node to Transport Channel IDs List 
             */
            rtxDListAppendNode(&p_ele_trch_map_item->trCH_ID_List, p_node_trch_id);
        }/* Step 2 Ends */
        /* Filling ranap_ProtocolExtensionContainer (step 1c) */
        p_ele_trch_map_item->m.iE_ExtensionsPresent = 1;
        {
            /* Init List for RAB Transport Channel Mapping Item ProtocolExtensions */
            rtxDListInit(&p_ele_trch_map_item->iE_Extensions);
            /* Allocating Node to fill CN Domain Indicator */
            rtxDListAllocNodeAndData(p_asn1_ctx, ranap_ProtocolExtensionField,
                    &p_node_trch_map_ie_ext, &p_ele_cn_domain);
            if (PNULL==p_node_trch_map_ie_ext)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"Can't allocate p_node_trch_map_ie_ext");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            asn1Init_ranap_ProtocolExtensionField(p_ele_cn_domain);

            p_ele_cn_domain->id = ASN1V_ranap_id_CN_DomainIndicator;
            p_ele_cn_domain->criticality = ranap_ignore;

            /* Encoding CN Domain Indicator */
            if(RRC_FAILURE == uecc_s1ap_cn_domain_indicator_intrnl_enc(
                        p_ue_context,
                        p_asn1_ctx, p_ele_cn_domain, 
                        p_rnc_container->rab_transport_channel_mapping[count].    \
                        cn_domain_indicator))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "[uecc_s1ap_build_ranap_RAB_TrCH_Mapping]"
                        "CN domain indicator internal enc Failed");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            /* 
             * Appending Node with CN Domain Indicator to 
             *  RAB Transport Channel Mapping Item ProtocolExtensions List
             */
            rtxDListAppendNode(&p_ele_trch_map_item->iE_Extensions, 
                    p_node_trch_map_ie_ext);
        }    
        /* Filling extElem1 (step 1d) */
        rtxDListInit(&p_ele_trch_map_item->extElem1);
        /*
         * Appending Node to RAB Transport Channel Mapping Item List 
         */
        rtxDListAppendNode(p_ranap_RAB_TrCH_Mapping, p_node_trch_map);
    }/* Step 1 Ends */

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_Protocol_extn_container
 *
 *   INPUTS       : rrm_source_rnc_to_target_rnc_transparent_container_t
 *                                                             p_rnc_container
 *                  OSCTXT                  *p_asn1_ctx
 *                  ranap_SourceRNC_ToTargetRNC_TransparentContainer
 *                                                 *p_srcRNC_to_trgtRNC_con
 *                  uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *      This function builds Protocol Extension Container List of sourceRNC to 
 *          targetRNC Transparent Container. 
 *      The following steps taken while appending the items in the list.
 *          Build nodes of List with ProtocolExtensionField structure values.
 *             -ProtocolExtensionID.
 *             -Criticality {ranap_reject = 0,ranap_ignore, ranap_notify}.
 *             -extensionValue.numocts and extensionValue.data
 *          1.  First Node contains UE_HistoryInformation
 *          2.  Next Node contains SRB Transport Channel Mapping List (Optional)
 *          3.  Next Node contains Trace Recording Session Information (Optional)
 *          4.  Next Node contains MBMS Linking Information (Optional)
 *          5.  Next Node contains D-RNTI for No IuCS UP (Optional)
 *          6.  Next Node contains Subscriber Profile ID for RAT/Frequency Priority (Optional)
 *          7.  Next Node contains SRVCC Information (Optional)
 *          8.  Next Node contains PS RAB to be Replaced (Optional)
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_Protocol_extn_container
(
 rrm_source_rnc_to_target_rnc_transparent_container_t *p_rnc_container, 
 OSCTXT *p_asn1_ctx,
 ranap_SourceRNC_ToTargetRNC_TransparentContainer  *p_srcRNC_to_trgtRNC_con,
 uecc_ue_context_t               *p_ue_context
 )
{
    OSRTDListNode                   *p_main_node = PNULL;
    ranap_ProtocolExtensionField    *p_main_elem = PNULL;
    OSRTDListNode                   *p_node_trch_id_ie_ext = PNULL;
    ranap_ProtocolExtensionField    *p_ele_mac_flow = PNULL;

    U16                                     srb_map_count = 0;
    ranap_SRB_TrCH_MappingItem              srb_trch_mapping[MAX_NUM_SRB_PER_UE];
    ranap_TraceRecordingSessionInformation  trace_rec_sess_info;
    s1ap_UE_HistoryInformation              ue_history_info;
    ranap_SRVCC_Information                 srvcc_info;
    ranap_RAB_ID                            rab_id;
    ranap_IRAT_Measurement_Configuration    asn_irat_meas_config;

    RRC_ASSERT(PNULL!=p_rnc_container);
    RRC_ASSERT(PNULL!=p_asn1_ctx);
    RRC_ASSERT(PNULL!=p_srcRNC_to_trgtRNC_con);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* Init ProtocolExtensions (SourceRNC Container) List*/
    rtxDListInit(&p_srcRNC_to_trgtRNC_con->iE_Extensions);

    /* Step 1 Starts */
    /* Allocating Node to fill UE History Information */
    rtxDListAllocNodeAndData(p_asn1_ctx, ranap_ProtocolExtensionField,
            &p_main_node, &p_main_elem);

    if (PNULL == p_main_node)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,"Can't allocate ranap_ProtocolExtensionField");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    asn1Init_ranap_ProtocolExtensionField(p_main_elem);

    p_main_elem->id = ASN1V_ranap_id_UE_History_Information;
    p_main_elem->criticality = ranap_ignore;
    /* Filling s1ap_UE_HistoryInformation structure */
    if (RRC_SUCCESS != uecc_s1ap_build_s1ap_UE_HistoryInformation(
                &p_rnc_container->ue_histroy_info, p_asn1_ctx, &ue_history_info,
                p_ue_context))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[uecc_s1ap_build_Protocol_extn_container]"
                "Ue History Information build Failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    /* Encoding s1ap_UE_HistoryInformation structure to append in List Node*/
    if(RRC_FAILURE == uecc_s1ap_ue_history_intrnl_enc(
                p_ue_context, p_asn1_ctx, p_main_elem, &ue_history_info))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,
                "[uecc_s1ap_build_Protocol_extn_container]"
                "Ue History intrnl enc Failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    /* Appending Node with UE History Information to Protocol Extn List (Source RNC)*/
    rtxDListAppendNode(&p_srcRNC_to_trgtRNC_con->iE_Extensions,p_main_node);
    /* Step 1 Ends */

    /* Step 2 Starts */
    if(RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_SRB_TRANSPORT_CH_MAP_PRESENT
            & p_rnc_container->bitmask)
    {
        /* Number of Node will be equal to Number if SRB Transport Channel Mappings */
        for(srb_map_count = 0;
                srb_map_count < p_rnc_container->no_of_srb_transport_channel_mappings;
                srb_map_count++)
        {    
            /* Allocating Node to fill SRB Transport Channel Mapping Item */
            rtxDListAllocNodeAndData(p_asn1_ctx, ranap_ProtocolExtensionField,
                    &p_main_node, &p_main_elem);
            if (PNULL == p_main_node)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"Can't allocate node");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            asn1Init_ranap_ProtocolExtensionField(p_main_elem);
            p_main_elem->id = ASN1V_ranap_id_SRB_TrCH_Mapping;
            p_main_elem->criticality = ranap_reject;

            /* Filling SRB Transport Channel Mapping Items */
            /* sRB_ID */
            srb_trch_mapping[srb_map_count].sRB_ID = p_rnc_container->      \
                                                     srb_transport_channel_mapping[srb_map_count].srb_id;
            /* trCH_ID Items */
            if(TRANSPORT_CHANNEL_ID_DCH_ID_PRESENT &
                    p_rnc_container->srb_transport_channel_mapping[srb_map_count].\
                    srb_transport_channel_id.bitmask)
            {   
                srb_trch_mapping[srb_map_count].trCH_ID.m.dCH_IDPresent = 1;
                srb_trch_mapping[srb_map_count].trCH_ID.dCH_ID = 
                    p_rnc_container->srb_transport_channel_mapping[srb_map_count] \
                    .srb_transport_channel_id.dch_id;
            }       
            if(TRANSPORT_CHANNEL_ID_DSCH_ID_PRESENT &
                    p_rnc_container->srb_transport_channel_mapping[srb_map_count].\
                    srb_transport_channel_id.bitmask)
            {   
                srb_trch_mapping[srb_map_count].trCH_ID.m.dCH_IDPresent = 1;
                srb_trch_mapping[srb_map_count].trCH_ID.dSCH_ID = 
                    p_rnc_container->srb_transport_channel_mapping[srb_map_count] \
                    .srb_transport_channel_id.dsch_id;
            }       
            if(TRANSPORT_CHANNEL_ID_USCH_ID_PRESENT &
                    p_rnc_container->srb_transport_channel_mapping[srb_map_count].\
                    srb_transport_channel_id.bitmask)
            {   
                srb_trch_mapping[srb_map_count].trCH_ID.m.dCH_IDPresent = 1;
                srb_trch_mapping[srb_map_count].trCH_ID.uSCH_ID = 
                    p_rnc_container->srb_transport_channel_mapping[srb_map_count] \
                    .srb_transport_channel_id.usch_id;
            }      
            /* Empty List in (SRB)trCH_ID */
            rtxDListInit(&srb_trch_mapping[srb_map_count].trCH_ID.extElem1);
            /* Filling ranap_ProtocolExtensionContainer for (SRB)TrCH iE Extension */
            srb_trch_mapping[srb_map_count].trCH_ID.m.iE_ExtensionsPresent = 0;
            /* Init List for SRB TrCh Item's ProtocolExtensions */
            rtxDListInit(&srb_trch_mapping[srb_map_count].trCH_ID.iE_Extensions);
            if(TRANSPORT_CHANNEL_ID_HS_DSCH_MAC_D_FLOW_ID_PRESENT &
                    p_rnc_container->srb_transport_channel_mapping[srb_map_count].\
                    srb_transport_channel_id.bitmask)
            {
                srb_trch_mapping[srb_map_count].trCH_ID.m.                  \
                    iE_ExtensionsPresent = 1;
                /* Allocating Node for SRB TrCh Item's ProtocolExtensions(hS_DSCH_MAC_d_Flow_ID) */
                rtxDListAllocNodeAndData(p_asn1_ctx,
                        ranap_ProtocolExtensionField,
                        &p_node_trch_id_ie_ext, &p_ele_mac_flow);
                if (PNULL == p_node_trch_id_ie_ext)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,"Can't allocate ranap_ProtocolExtensionField");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
                asn1Init_ranap_ProtocolExtensionField(p_ele_mac_flow);
                p_ele_mac_flow->id = ASN1V_ranap_id_hS_DSCH_MAC_d_Flow_ID;
                p_ele_mac_flow->criticality = ranap_ignore;
                /* Encoding value of hS_DSCH_MAC_d_Flow_ID */
                if(RRC_FAILURE == uecc_s1ap_hS_DSCH_MAC_d_Flow_ID_intrnl_enc(
                            p_ue_context, 
                            p_asn1_ctx, p_ele_mac_flow,
                            p_rnc_container->srb_transport_channel_mapping[srb_map_count].\
                            srb_transport_channel_id.hs_dsch_mac_d_flow_id))
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_FATAL,
                            "[uecc_s1ap_build_Protocol_extn_container]"
                            "hS DSCH MAC d Flow ID(SRB TrCH Mapping) internal enc Failed");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
                /* 
                 *  Appending Node to SRB TrCh Item's ProtocolExtensions List
                 *  with hS_DSCH_MAC_d_Flow_ID
                 */
                rtxDListAppendNode(
                        &srb_trch_mapping[srb_map_count].trCH_ID.iE_Extensions,
                        p_node_trch_id_ie_ext);
            }
            if(TRANSPORT_CHANNEL_ID_E_DCH_MAC_D_FLOW_ID_PRESENT &
                    p_rnc_container->srb_transport_channel_mapping[srb_map_count].\
                    srb_transport_channel_id.bitmask)
            {
                srb_trch_mapping[srb_map_count].trCH_ID.m.iE_ExtensionsPresent = 1;
                /* Allocating Node for SRB TrCh Item's ProtocolExtensions(E_DCH_MAC_d_Flow_ID) */
                rtxDListAllocNodeAndData(p_asn1_ctx,
                        ranap_ProtocolExtensionField,
                        &p_node_trch_id_ie_ext, &p_ele_mac_flow);
                if (PNULL == p_node_trch_id_ie_ext)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,"Can't allocate ranap_ProtocolExtensionField");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
                asn1Init_ranap_ProtocolExtensionField(p_ele_mac_flow);
                p_ele_mac_flow->id = ASN1V_ranap_id_E_DCH_MAC_d_Flow_ID;
                p_ele_mac_flow->criticality = ranap_ignore;
                /* Encoding value of E_DCH_MAC_d_Flow_ID */
                if(RRC_FAILURE == uecc_s1ap_E_DCH_MAC_d_Flow_ID_intrnl_enc(
                            p_ue_context, p_asn1_ctx, p_ele_mac_flow,
                            p_rnc_container->srb_transport_channel_mapping[srb_map_count].\
                            srb_transport_channel_id.e_dch_mac_d_flow_id))
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_FATAL,
                            "[uecc_s1ap_build_Protocol_extn_container]"
                            "E DCH MAC d Flow ID(SRB TrCH Mapping) internal enc Failed");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
                /* 
                 *  Appending Node to SRB TrCh Item's ProtocolExtensions List
                 *  with E_DCH_MAC_d_Flow_ID
                 */
                rtxDListAppendNode(
                        &srb_trch_mapping[srb_map_count].trCH_ID.iE_Extensions,
                        p_node_trch_id_ie_ext);
            }
            /* No member for SRB TrCh Mapping Extension */
            srb_trch_mapping[srb_map_count].m.iE_ExtensionsPresent = 0;
            /* Empty List SRB Transport Channel Mapping Item */
            rtxDListInit(&srb_trch_mapping[srb_map_count].extElem1);
            /* Encoding SRB Transport Channel Mapping Item */
            if(RRC_FAILURE == uecc_s1ap_SRB_TrCH_Mapping_intrnl_enc(
                        p_ue_context, p_asn1_ctx, p_main_elem, &srb_trch_mapping[srb_map_count]))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "[uecc_s1ap_build_Protocol_extn_container]"
                        "SRB TrCH Mapping intrnl enc Failed");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            /*
             *  Appending Node with SRB TrCH Mapping to Protocol Extn List (Source RNC)
             */
            rtxDListAppendNode(&p_srcRNC_to_trgtRNC_con->iE_Extensions,p_main_node);
        }    
    }/* Step 2 Ends */

    /* Step 3 Starts */
    if(RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_TRACE_REC_SESSION_INFO_PRESENT
            & p_rnc_container->bitmask)
    {
        asn1Init_ranap_TraceRecordingSessionInformation(&trace_rec_sess_info);
        /* Allocating Node to fill Trace Recording Session Information */
        rtxDListAllocNodeAndData(p_asn1_ctx, ranap_ProtocolExtensionField,
                &p_main_node, &p_main_elem);
        if (PNULL == p_main_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate ranap_ProtocolExtensionField");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        asn1Init_ranap_ProtocolExtensionField(p_main_elem);
        p_main_elem->id = ASN1V_ranap_id_TraceRecordingSessionInformation;
        p_main_elem->criticality = ranap_ignore;
        /* Filling Trace Recording Session Information */ 
        /* No member for Trace Recording Session Information Extn */ 
        trace_rec_sess_info.m.iE_ExtensionsPresent = 0;
        trace_rec_sess_info.traceReference.numocts = 
            sizeof(p_rnc_container->trace_recording_session_info.trace_reference);
        l3_memcpy_wrapper(trace_rec_sess_info.traceReference.data,
                p_rnc_container->trace_recording_session_info.trace_reference,
                trace_rec_sess_info.traceReference.numocts);
        trace_rec_sess_info.traceRecordingSessionReference = 
            p_rnc_container->trace_recording_session_info.                 \
            trace_recording_session_reference;
        /* Empty List */
        rtxDListInit(&trace_rec_sess_info.extElem1);
        /* Encoding Trace Recording Session Information */
        if(RRC_FAILURE == uecc_s1ap_Trace_Rec_Session_info_intrnl_enc(
                    p_ue_context, p_asn1_ctx, p_main_elem, &trace_rec_sess_info))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_Protocol_extn_container]"
                    "Trace Rec Session info intrnl enc Failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /*
         *  Appending Node with Trace Recording Session Information 
         *  to Protocol Extn List (Source RNC)
         */
        rtxDListAppendNode(&p_srcRNC_to_trgtRNC_con->iE_Extensions,p_main_node);
    }/* Step 3 Ends */
    /*SPR_19302_START*/
    else if((p_ue_context->m.traceActivated) && 
            (PNULL != p_ue_context->p_ue_trace_activation_info))
    {
        /*Fill TraceRecordingSession Info from ue conteaxt 
         * if not recieved from RRM */
        asn1Init_ranap_TraceRecordingSessionInformation(&trace_rec_sess_info);
        /* Allocating Node to fill Trace Recording Session Information */
        rtxDListAllocNodeAndData(p_asn1_ctx, ranap_ProtocolExtensionField,
                &p_main_node, &p_main_elem);
        if (PNULL == p_main_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate ranap_ProtocolExtensionField");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        asn1Init_ranap_ProtocolExtensionField(p_main_elem);
        p_main_elem->id = ASN1V_ranap_id_TraceRecordingSessionInformation;
        p_main_elem->criticality = ranap_ignore;
        /* Filling Trace Recording Session Information */ 
        /* No member for Trace Recording Session Information Extn */ 
        trace_rec_sess_info.m.iE_ExtensionsPresent = 0;

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_DETAILED,
                        "[uecc_s1ap_build_Protocol_extn_container]"
                        "Trace Rec Session info filled");

       trace_rec_sess_info.traceReference.numocts =  
                      sizeof(trace_rec_sess_info.traceReference.data);

       l3_memcpy_wrapper(trace_rec_sess_info.traceReference.data,
                    p_ue_context->p_ue_trace_activation_info->
                    trace_id_info.eutran_trace_id.data + 3,
                    trace_rec_sess_info.traceReference.numocts);

       trace_rec_sess_info.traceRecordingSessionReference = ((p_ue_context->
               p_ue_trace_activation_info->trace_id_info.eutran_trace_id.data[6] << 8) & 0xFF00) | (p_ue_context->
                    p_ue_trace_activation_info->trace_id_info.eutran_trace_id.data[7]);
       

        /* Empty List */
        rtxDListInit(&trace_rec_sess_info.extElem1);

        /* Encoding Trace Recording Session Information */
        if(RRC_FAILURE == uecc_s1ap_Trace_Rec_Session_info_intrnl_enc(
                    p_ue_context, p_asn1_ctx, p_main_elem, &trace_rec_sess_info))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_Protocol_extn_container]"
                    "Trace Rec Session info intrnl enc Failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /*
         *  Appending Node with Trace Recording Session Information 
         *  to Protocol Extn List (Source RNC)
         */
        rtxDListAppendNode(&p_srcRNC_to_trgtRNC_con->iE_Extensions,p_main_node);

    }
    /*SPR_19302_END*/

    /* Step 4 Starts */
    if(RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_MBMS_LINKING_INFO_PRESENT
            & p_rnc_container->bitmask)
    {
        /* Allocating Node to fill MBMS Linking Information */
        rtxDListAllocNodeAndData(p_asn1_ctx, ranap_ProtocolExtensionField,
                &p_main_node, &p_main_elem);
        if (PNULL == p_main_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate ranap_ProtocolExtensionField");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        asn1Init_ranap_ProtocolExtensionField(p_main_elem);
        p_main_elem->id = ASN1V_ranap_id_MBMSLinkingInformation;
        p_main_elem->criticality = ranap_ignore;

        /* Encoding MBMSLinkingInformation */
        if(RRC_FAILURE == uecc_s1ap_MBMS_Linking_info_intrnl_enc(
                    p_ue_context, p_asn1_ctx, p_main_elem, p_rnc_container->mbms_linking_info))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_Protocol_extn_container]"
                    "MBMS Linking info intrnl enc Failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /*
         * Appending Node with MBMS Linking Information to Protocol Extn List (Source RNC) 
         */
        rtxDListAppendNode(&p_srcRNC_to_trgtRNC_con->iE_Extensions,p_main_node);
    }/* Step 4 Ends */

    /* Step 5 Starts */
    if(RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_DRNTI_FOR_NO_UI_CS_UP_PRESENT
            & p_rnc_container->bitmask)
    {
        /* Allocating Node to fill D-RNTI for No IuCS UP */
        rtxDListAllocNodeAndData(p_asn1_ctx, ranap_ProtocolExtensionField,
                &p_main_node, &p_main_elem);
        if (PNULL == p_main_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate ranap_ProtocolExtensionField");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        asn1Init_ranap_ProtocolExtensionField(p_main_elem);
        p_main_elem->id = ASN1V_ranap_id_d_RNTI_for_NoIuCSUP;
        p_main_elem->criticality = ranap_reject;

        /* Encoding D-RNTI */
        if(RRC_FAILURE == uecc_s1ap_d_rnti_intrnl_enc(
                    p_ue_context, p_asn1_ctx, p_main_elem, p_rnc_container->d_rnti_for_no_ui_cs_up))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_Protocol_extn_container]"
                    "D RNTI for No UI CS UP Presnt intrnl enc Failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /*
         * Appending Node with D-RNTI for No IuCS UP to Protocol Extn List (Source RNC)
         */
        rtxDListAppendNode(&p_srcRNC_to_trgtRNC_con->iE_Extensions,p_main_node);
    }/* Step 5 Ends */

    /* Step 6 Starts */
    /* Filling Subscriber Profile ID for RAT/Frequency Priority */
    if(RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_SUB_PROF_ID_FOR_RAT_OR_FREQ_PRI_PRESENT
            & p_rnc_container->bitmask)
    {
        /* Allocating Node to fill Profile ID for RAT/Frequency Priority */
        rtxDListAllocNodeAndData(p_asn1_ctx, ranap_ProtocolExtensionField,
                &p_main_node, &p_main_elem);
        if (PNULL == p_main_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate ranap_ProtocolExtensionField");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        asn1Init_ranap_ProtocolExtensionField(p_main_elem);
        p_main_elem->id = ASN1V_ranap_id_SubscriberProfileIDforRFP;
        p_main_elem->criticality = ranap_ignore;

        /* Encoding Subscriber Profile ID for RFP */
        if(RRC_FAILURE == uecc_s1ap_subs_profile_id_rfp_intrnl_enc(
                    p_ue_context, p_asn1_ctx, p_main_elem, 
                    p_rnc_container->subscriber_profile_id_for_rat_or_frequency_priority))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_Protocol_extn_container]"
                    "Subs profile ID for RFP intrnl enc Failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /*
         * Appending Node with Profile ID for RAT/Frequency Priority
         *  to Protocol Extn List (Source RNC)
         */
        rtxDListAppendNode(&p_srcRNC_to_trgtRNC_con->iE_Extensions,p_main_node);
    }/* Step 6 Ends */

    /* Step 7 Starts */
    if(RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_SRVCC_INFO_PRESENT
            & p_rnc_container->bitmask)
    {
        asn1Init_ranap_SRVCC_Information(&srvcc_info);
        /* Allocating Node to fill SRVCC Information */
        rtxDListAllocNodeAndData(p_asn1_ctx, ranap_ProtocolExtensionField,
                &p_main_node, &p_main_elem);
        if (PNULL == p_main_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate ranap_ProtocolExtensionField");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        asn1Init_ranap_ProtocolExtensionField(p_main_elem);
        p_main_elem->id = ASN1V_ranap_id_SRVCC_Information;
        p_main_elem->criticality = ranap_reject;

        /* Filling SRVCC Information */
        srvcc_info.m.iE_ExtensionsPresent = 0;
        srvcc_info.nonce.numbits = 
            (8 * sizeof(p_rnc_container->srvcc_info.nonce));
        l3_memcpy_wrapper(srvcc_info.nonce.data, p_rnc_container->srvcc_info.nonce,
                (srvcc_info.nonce.numbits / 8));
        /* Empty List */        
        rtxDListInit(&srvcc_info.extElem1);        
        /* Encoding SRVCC Inforamtion */
        if(RRC_FAILURE == uecc_s1ap_srvcc_info_intrnl_enc(
                    p_ue_context, p_asn1_ctx, p_main_elem, &srvcc_info))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_Protocol_extn_container]"
                    "SRVCC info intrnl enc Failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /*
         * Appending Node with SRVCC Information to Protocol Extn List (Source RNC) 
         */
        rtxDListAppendNode(&p_srcRNC_to_trgtRNC_con->iE_Extensions,p_main_node);
    }/* Step 7 Ends */

    /* Step 8 Starts */
    if(RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_PS_RAB_TO_BE_REPLACED_PRESENT
            & p_rnc_container->bitmask)
    {
        asn1Init_ranap_RAB_ID(&rab_id);
        /* Allocating Node to fill PS RAB to be Replaced */
        rtxDListAllocNodeAndData(p_asn1_ctx, ranap_ProtocolExtensionField,
                &p_main_node, &p_main_elem);
        if (PNULL == p_main_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate ranap_ProtocolExtensionField");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        asn1Init_ranap_ProtocolExtensionField(p_main_elem);
        p_main_elem->id = ASN1V_ranap_id_PSRABtobeReplaced;
        p_main_elem->criticality = ranap_reject;

        rab_id.numbits = (8 * sizeof(p_rnc_container->ps_rab_to_be_replaced));
        l3_memcpy_wrapper(rab_id.data, &p_rnc_container->ps_rab_to_be_replaced,
                (rab_id.numbits / 8));
        /* Encoding PS RAB to be Replace Inforamtion */
        if(RRC_FAILURE == uecc_s1ap_ps_rab_replace_intrnl_enc(
                    p_ue_context, p_asn1_ctx, p_main_elem, &rab_id)) 
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_Protocol_extn_container]"
                    "ps rab replace intrnl enc Failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /*
         * Appending Node with PS RAB to be Replaced to Protocol Extn List (Source RNC)
         */
        rtxDListAppendNode(&p_srcRNC_to_trgtRNC_con->iE_Extensions,p_main_node);
    }/* Step 8 Ends */
    
    if(RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_CSFB_INFO_PRESENT
            & p_rnc_container->bitmask)
    {
        /* Allocating Node to fill MBMS Linking Information */
        rtxDListAllocNodeAndData(p_asn1_ctx, ranap_ProtocolExtensionField,
                &p_main_node, &p_main_elem);
        if (PNULL == p_main_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate ranap_ProtocolExtensionField");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        asn1Init_ranap_ProtocolExtensionField(p_main_elem);
        p_main_elem->id = ASN1V_ranap_id_CSFB_Information;
        p_main_elem->criticality = ranap_ignore;

        /* Encoding CSFB Information */
        if(RRC_FAILURE == uecc_s1ap_CSFB_info_intrnl_enc(
                    p_ue_context, p_asn1_ctx, p_main_elem, p_rnc_container->csfb_info))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_Protocol_extn_container]"
                    "CSFB info intrnl enc Failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /*
         * Appending Node with CSFB Information to Protocol Extn List (Source RNC) 
         */
        rtxDListAppendNode(&p_srcRNC_to_trgtRNC_con->iE_Extensions,p_main_node);
    }
    /*srvcc-u start*/
    if(RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_IRAT_MEAS_CONFIG_INFO_PRESENT
            & p_rnc_container->bitmask)
    {
        /* Allocating Node to fill IRAT MEAS CONFIG Information */
        rtxDListAllocNodeAndData(p_asn1_ctx, ranap_ProtocolExtensionField,
                &p_main_node, &p_main_elem);
        if (PNULL == p_main_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate ranap_ProtocolExtensionField");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        asn1Init_ranap_ProtocolExtensionField(p_main_elem);
        p_main_elem->id = ASN1V_ranap_id_IRAT_Measurement_Configuration;
        p_main_elem->criticality = ranap_ignore;

        /* Filling IRAT MEAS CONFIG Information structure */
        if (RRC_SUCCESS != uecc_s1ap_build_s1ap_Irat_meas_config_info(
                    p_rnc_container, p_asn1_ctx, &asn_irat_meas_config,
                    p_ue_context))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_s1ap_build_Protocol_extn_container]"
                    "IRAT MEAS CONFIG Information build Failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        /* Encoding IRAT MEAS CONFIG Information */
        if(RRC_FAILURE == uecc_s1ap_IRAT_meas_config_info_intrnl_enc(
                    p_ue_context, p_asn1_ctx, p_main_elem, &asn_irat_meas_config))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_Protocol_extn_container]"
                    "IRAT MEAS CONFIG Information intrnl enc Failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /*
         * Appending Node with IRAT MEAS CONFIG Information to Protocol Extn List (Source RNC) 
         */
        rtxDListAppendNode(&p_srcRNC_to_trgtRNC_con->iE_Extensions,p_main_node);
    }
    /* MDT is Not Supported for now */
    /*srvcc-u stop*/


    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/****************************************************************************
 * Function Name  : uecc_s1ap_fillMobilityFromEUTRACommand 
 * Inputs         : uecc_ue_context_t*            p_ue_context
 *                  U8                            *p_data_buffer
 *                  U16                           *p_buffer_length
 *                  OSCTXT                        *p_asn1_ctx
 * Outputs        : None
 * Description    : This is the function to fill MobilityFromEUTRACommand
 which is used in the case of inter Rat HO
 * Returns        : None
 ****************************************************************************/
rrc_return_et uecc_s1ap_fillMobilityFromEUTRACommand 
(
 uecc_ue_context_t*            p_ue_context,
 U8                            *p_data_buffer,
 U16                           *p_buffer_length,
 OSCTXT                        *p_asn1_ctx
 )
{
    DL_DCCH_Message                  msg;
    rrc_rrm_ho_required_t            *p_rrc_rrm_ho_required = PNULL;
    uecc_s1_src_ho_info_t            *p_s1_src_ho_info = PNULL;
    rrc_return_et                    result = RRC_SUCCESS;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/

    RRC_ASSERT(PNULL!=p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    /*SPR 15896 Fix Start*/

    /* TRACE_changes_start */
    if (p_ue_context->m.traceActivated)
    {
        /*SPR 15875 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & UU) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(),GEN_MME,"\n <msg function=\"Uu\" name=\"MOBILITY FROM EUTRA COMMAND\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & UU) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(),GEN_CELL,"\n <msg function=\"Uu\" name=\"MOBILITY FROM EUTRA COMMAND\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
            /*SPR 15896 Fix Stop*/
        /*SPR 15875 Fix Stop*/
    }
    /* TRACE_changes */

    do
    {
        /* assigning the p_rrc_rrm_ho_required */
        p_rrc_rrm_ho_required =  p_ue_context->ho_info.p_ho_info->
            p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required;

        p_s1_src_ho_info = &(p_ue_context->ho_info.p_ho_info->
                p_src_ho_info->s1_src_ho_info);

        asn1Init_DL_DCCH_Message(&msg);

        msg.message.t = T_DL_DCCH_MessageType_c1;
        msg.message.u.c1 = rtxMemAllocType(p_asn1_ctx, DL_DCCH_MessageType_c1);

        if (PNULL ==  msg.message.u.c1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                    "Memory allocation failed for DL_DCCH_MessageType_c1");
            result = RRC_FAILURE;
            break; 
        }
        
        asn1Init_DL_DCCH_MessageType_c1(msg.message.u.c1);
 
        msg.message.u.c1->t = T_DL_DCCH_MessageType_c1_mobilityFromEUTRACommand;

        msg.message.u.c1->u.mobilityFromEUTRACommand =
            rtxMemAllocType(p_asn1_ctx,MobilityFromEUTRACommand);

        if (PNULL ==  msg.message.u.c1->u.mobilityFromEUTRACommand)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                    "Memory allocation failed for mobilityFromEUTRACommand");
            result = RRC_FAILURE;
            break;
        }

        asn1Init_MobilityFromEUTRACommand(msg.message.u.c1->u.mobilityFromEUTRACommand);

        msg.message.u.c1->u.mobilityFromEUTRACommand->rrc_TransactionIdentifier =
            (OSUINT8)uecc_ue_ctx_get_op_transction_id(p_ue_context);

        msg.message.u.c1->u.mobilityFromEUTRACommand->criticalExtensions.t = 
            T_MobilityFromEUTRACommand_criticalExtensions_c1;

        msg.message.u.c1->u.mobilityFromEUTRACommand->criticalExtensions.u.c1 =
            rtxMemAllocType(p_asn1_ctx,MobilityFromEUTRACommand_criticalExtensions_c1);
  
        if (PNULL ==  msg.message.u.c1->u.mobilityFromEUTRACommand->\
                criticalExtensions.u.c1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                    "Memory allocation failed for"
                    "MobilityFromEUTRACommand_criticalExtensions_c1");
            result = RRC_FAILURE;
            break; 
        }
        asn1Init_MobilityFromEUTRACommand_criticalExtensions_c1
            (msg.message.u.c1->u.mobilityFromEUTRACommand->criticalExtensions.u.c1);
            
        /* cr_586 ue_capability check */
        if (PNULL == p_ue_context->m.access_stratum_release)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "access_stratum_release is not Present");
            result = RRC_FAILURE;
            break;
        }    
        if (p_ue_context->access_stratum_release == RRC_UE_REL_8)   
        {   
            msg.message.u.c1->u.mobilityFromEUTRACommand->criticalExtensions.u.c1->t =
                T_MobilityFromEUTRACommand_criticalExtensions_c1_mobilityFromEUTRACommand_r8;

            msg.message.u.c1->u.mobilityFromEUTRACommand->criticalExtensions.u.c1->
                u.mobilityFromEUTRACommand_r8 =
                rtxMemAllocType(p_asn1_ctx, MobilityFromEUTRACommand_r8_IEs);

            if (PNULL == msg.message.u.c1->u.mobilityFromEUTRACommand->
                    criticalExtensions.u.c1->u.mobilityFromEUTRACommand_r8)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                        "Memory allocation failed for\
                        MobilityFromEUTRACommand_r8_IEs");
                result = RRC_FAILURE;
                break;
            }   

            asn1Init_MobilityFromEUTRACommand_r8_IEs(msg.message.u.c1->
                    u.mobilityFromEUTRACommand->criticalExtensions.
                    u.c1->u.mobilityFromEUTRACommand_r8);

            /* Fill MobilityFromEUTRACommand_r8_IEs */
            if(RRC_SUCCESS != uecc_s1ap_fillMobilityFromEUTRACommand_r8(
                        p_ue_context,
                        msg.message.u.c1->u.mobilityFromEUTRACommand->criticalExtensions.
                        u.c1->u.mobilityFromEUTRACommand_r8,
                        p_data_buffer,
                        p_asn1_ctx,
                        p_rrc_rrm_ho_required,
                        p_s1_src_ho_info,
                        &msg))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[uecc_s1ap_fillMobilityFromEUTRACommand]"
                        "uecc_s1ap_fillMobilityFromEUTRACommand Failed "
                        "for release 8");
                result = RRC_FAILURE;
                break;
            }        
        }    
        /* BUG_8995 Start */
        /*SPR_19154_START*/
        else if (p_ue_context->access_stratum_release >= RRC_UE_REL_9)
        /*SPR_19154_END*/
        /* BUG_8995 Stop */
            {   
                msg.message.u.c1->u.mobilityFromEUTRACommand->criticalExtensions.u.c1->t =
                    T_MobilityFromEUTRACommand_criticalExtensions_c1_mobilityFromEUTRACommand_r9;

                msg.message.u.c1->u.mobilityFromEUTRACommand->criticalExtensions.u.c1->
                    u.mobilityFromEUTRACommand_r9 =
                    rtxMemAllocType(p_asn1_ctx, MobilityFromEUTRACommand_r9_IEs);

                if (PNULL == msg.message.u.c1->u.mobilityFromEUTRACommand->
                        criticalExtensions.u.c1->u.mobilityFromEUTRACommand_r9)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_FATAL,
                            "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                            "Memory allocation failed for\
                            MobilityFromEUTRACommand_r9_IEs");
                    result = RRC_FAILURE;
                    break;
                }   

                asn1Init_MobilityFromEUTRACommand_r9_IEs(msg.message.u.c1->
                        u.mobilityFromEUTRACommand->criticalExtensions.
                        u.c1->u.mobilityFromEUTRACommand_r9);

            /* Fill MobilityFromEUTRACommand_r9_IEs */
                if(RRC_SUCCESS != uecc_s1ap_fillMobilityFromEUTRACommand_r9(
                            p_ue_context,
                            msg.message.u.c1->u.mobilityFromEUTRACommand->criticalExtensions.
                            u.c1->u.mobilityFromEUTRACommand_r9,
                            p_data_buffer,
                            p_asn1_ctx,
                            p_rrc_rrm_ho_required,
                            p_s1_src_ho_info,
                            &msg))
                {    
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,"[uecc_s1ap_fillMobilityFromEUTRACommand]"
                            "uecc_s1ap_fillMobilityFromEUTRACommand Failed "
                            "for release 9");
                    result = RRC_FAILURE;
                    break;
                }
            }     
            else
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[uecc_s1ap_fillMobilityFromEUTRACommand]:"
                        "UE Release Unsupported");
                result = RRC_FAILURE;
                break;

            }

        *(p_buffer_length) =(U16)pe_GetMsgLen(p_asn1_ctx);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,
                "[fillMobilityFromEUTRACommand]DL_DCCH_Message"
                " encoded len %d",
                *(p_buffer_length));

    }
    while(0);

    /* TRACE_changes_start */
    /* SPR 16113 Start */
    uecc_rrc_ue_assoc_msg_max_trace_handler(p_ue_context, p_data_buffer,
                              *(p_buffer_length), "MOBILITY FROM EUTRA COMMAND", RRC_DL_DCCH);
    /* SPR 16113 Stop */

       
            /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated)
    {
        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(),S1,"\n </msg>");
            /*SPR 15896 Fix Stop*/
    }
    /* TRACE_changes */

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context); 
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_s1ap_Target_CGI
 *
 *   INPUTS       : uecc_gb_context_t*       p_uecc_gb_contex
 *                  rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required
 *                  OSCTXT                  *p_asn1_ctx
 *                  s1ap_CGI                *p_cGI
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds fills Target_CGI
 if Ho Type is HANDOVER_TYPE_LTE_TO_GERAN
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static void uecc_s1ap_build_s1ap_Target_CGI
(
 uecc_gb_context_t*       p_uecc_gb_context,
 rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required, 
 /*SPR 17777 +-*/
 s1ap_CGI                *p_cGI
 )
{

    RRC_ASSERT(PNULL!=p_rrc_rrm_ho_required);
    /*SPR 17777 +-*/
    RRC_ASSERT(PNULL!=p_cGI);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
    asn1Init_s1ap_CGI(p_cGI);
    /* Filling pLMNidentity */
    /* copy the count field */

    p_cGI->pLMNidentity.numocts
        = MCC_OCTET_SIZE;
    uecc_s1ap_generate_plmn_identity_int(
            p_cGI->pLMNidentity.data,
            &(p_rrc_rrm_ho_required->target_id.cgi.plmn_identity));

    /* Filling lAC */
    p_cGI->lAC.numocts = sizeof(p_rrc_rrm_ho_required->target_id.cgi.location_area_code);
    l3_memcpy_wrapper(p_cGI->lAC.data,
            p_rrc_rrm_ho_required->target_id.cgi.location_area_code,
            p_cGI->lAC.numocts);

    /* Filling CI */
    p_cGI->cI.numocts = sizeof(p_rrc_rrm_ho_required->target_id.cgi.ci_info);
    l3_memcpy_wrapper(p_cGI->cI.data,
            &p_rrc_rrm_ho_required->target_id.cgi.ci_info,
            p_cGI->cI.numocts);

    /*  CR0935 start */ 
    if( CS_PS_TYPE == p_rrc_rrm_ho_required->srvcc_ho_indication ) 
    {
        /* Filling rAC */
        if(RRM_CGI_INFO_ROUTING_AREA_CODE &
            p_rrc_rrm_ho_required->target_id.cgi.bitmask)
        {
            p_cGI->m.rACPresent = 1;
            p_cGI->rAC.numocts = 
                sizeof(p_rrc_rrm_ho_required->target_id.cgi.routing_area_code);
            l3_memcpy_wrapper(p_cGI->rAC.data,
                &p_rrc_rrm_ho_required->target_id.cgi.routing_area_code,
                p_cGI->rAC.numocts);
        }
    }
    /*  CR0935 end */ 

    /* Filling extElem1 */
    rtxDListInit(&p_cGI->extElem1);
    p_cGI->m.iE_ExtensionsPresent = 0;
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

}
/******************************************************************************
 *   FUNCTION NAME:uecc_s1ap_fill_si_psi_container 
 *
 *   INPUTS       : U8*                 p_data
 *                  SI_OrPSI_GERAN*           p_system_info
 *                  U32                       si_psi_index
 *                  OSCTXT*                   p_asn1_ctx
 *                  uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function fills si psi values in Mobility From EUTRA Command
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_fill_si_psi_container
(
 U8*                 p_data,
 SI_OrPSI_GERAN*           p_system_info,
 U32                       si_psi_index,
 OSCTXT*                   p_asn1_ctx,
 uecc_ue_context_t*        p_ue_context
 )
{
    SystemInfoListGERAN  *p_si_psi_container = PNULL;
    /*SPR 19592 FIX START*/
    U8          lenOctet = 2; 
    /*SPR 19592 FIX END*/

    RRC_ASSERT(PNULL!=p_data);
    RRC_ASSERT(PNULL!=p_system_info);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /*SPR 19592 FIX START*/
    if( p_data[si_psi_index + 1] & 0x80 )
    {   
        lenOctet = 1;
    }
    /* SPR 22053 start */
    else
    {
        lenOctet = 2;
    }
    /* SPR 22053 end */


    if(PSI_TYPE & p_data[si_psi_index+lenOctet+ 1]) 
    {   
        /*SPR 19592 FIX END*/
        /* Fill PSI Container */
        p_system_info->t = T_SI_OrPSI_GERAN_psi;
        p_system_info->u.psi = rtxMemAllocType(p_asn1_ctx,\
                SystemInfoListGERAN);
        if (PNULL == p_system_info->u.psi)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_fill_si_psi_container]"
                    "Memory allocation failure for SystemInfoListGERAN");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        p_si_psi_container =  p_system_info->u.psi;

        if(RRC_SUCCESS !=  uecc_s1ap_fill_intrl_si_psi(p_si_psi_container, p_data, 
                    si_psi_index, PSI_MSG_LENGTH_IN_OCTETS,p_ue_context))
        {

            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_fill_si_psi_container]"
                    "Failed to filled internal structure of PSI");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }
    else 
    {   
        /* Fill SI Container */
        p_system_info->t = T_SI_OrPSI_GERAN_si;
        p_system_info->u.si =\
                             rtxMemAllocType(p_asn1_ctx, SystemInfoListGERAN);
        if (PNULL ==  p_system_info->u.si)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_fill_si_psi_container]"
                    "Memory allocation failure for SystemInfoListGERAN");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        p_si_psi_container =  p_system_info->u.si;

        if(RRC_SUCCESS !=  uecc_s1ap_fill_intrl_si_psi(p_si_psi_container, p_data, 
                    si_psi_index, SI_MSG_LENGTH_IN_OCTETS,p_ue_context))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_s1ap_fill_si_psi_container]"
                    "Failed to filled internal structure of SI");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }

    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
            (p_ue_context->p_gb_context)->facility_name,
            RRC_INFO,
            "[uecc_s1ap_fill_si_psi_container]"
            "Successfully filled SI_PSI");
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_fill_intrl_si_psi 
 *
 *   INPUTS       : SystemInfoListGERAN *p_si_psi_container
 *                  U8* p_data
 *                  U32 si_psi_index
 *                  U32 msg_len
 *                  uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function fills internal structures of si or psi values 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/

static rrc_return_et uecc_s1ap_fill_intrl_si_psi(
        SystemInfoListGERAN *p_si_psi_container,
        U8* p_data,
        U32 si_psi_index,
        U32 msg_len,
        uecc_ue_context_t*        p_ue_context)
{
    U32 i = 0;
    U32 temp_len = 0;
    /*SPR 19592 FIX START*/
    U8          lenOctet = 2; 

    /*SPR 19592 FIX END*/
    RRC_ASSERT(PNULL!=p_data);
    RRC_ASSERT(PNULL!=p_si_psi_container);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /*SPR 19592 FIX START*/
    if( p_data[si_psi_index + 1] & 0x80 )
    {
        lenOctet = 1;
    }
    /* SPR 22053 start */
    else
    {
        lenOctet = 2;
    }
    /* SPR 22053 end */
    p_si_psi_container->n = (U32)(p_data[si_psi_index+lenOctet +1] >> 1);
    /*SPR 19592 FIX END*/
    if( p_si_psi_container->n > 10)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,
                "[uecc_s1ap_fill_intrl_si_psi]"
                "maxGERAN-SI can be olny 10 as per spec 36331,\
                other value is not supported");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    /*SPR 19592 FIX START*/
    /* SPR 22053 start */
    if( p_data[si_psi_index + 1] & 0x80 )
    {
        temp_len = p_data[si_psi_index+1] & 0x7F;
    }
    else
    {
        temp_len = (p_data[si_psi_index+1] << 8) |  (p_data[si_psi_index+2]);
    }
    /* Reduce length by one byte for Num of SI/PSI field */
    temp_len -= 1;
    /* SPR 22053 end */

    si_psi_index = si_psi_index + lenOctet + 2;
    /*SPR 19592 FIX END*/

    for(i=0; i< p_si_psi_container->n ; i++)
    {
        if(msg_len > temp_len)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_fill_intrl_si_psi]"
                    "MSG_LENGTH_IN_OCTETS can not be greater than temp_len"); 
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        else
        {
            /*SPR 19260 :CID 95262 Fix Start*/
            if(msg_len > 23)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "[uecc_s1ap_fill_intrl_si_psi]"
                        "MSG_LENGTH_IN_OCTETS can not be greater than temp_len"); 
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            else
        {
            p_si_psi_container->elem[i].numocts = msg_len;
            l3_memcpy_wrapper(p_si_psi_container->elem[i].data,
                    &p_data[si_psi_index],
                    msg_len);


            si_psi_index += msg_len;
            temp_len -= msg_len;
        }
            /*SPR 19260 :CID 95262 Fix End*/
        }
    }
    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
            (p_ue_context->p_gb_context)->facility_name,
            RRC_INFO,
            "[uecc_s1ap_fill_si_psi_container]"
            "Successfully filled internal structure of PSI");
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;

}

/* SPR 20635 Fix - SRVCC to GERAN - Starts */
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_fill_irat_meas_config_and_source_cell_id
 *
 *   INPUTS       : uecc_ue_context_t                         *p_ue_context
 *                  rrm_old_bss_to_new_bss_irat_meas_config_t *p_irat_meas_config
 *                  U8                                        *p_temp_container
 *   OUTPUTS      : U8 *p_num_octet_filled
 *   DESCRIPTION  :
 *                  This function fills  IRAT Measurement configuration and 
 *                  Source Cell Id parameters in Source BSS to Target BSS container
 *                  And/Or Old BSS to New BSS Information container.
 *
 *   RETURNS      : RRC_SUCCESS or RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_fill_irat_meas_config_and_source_cell_id(
    uecc_ue_context_t                           *p_ue_context,
    rrm_old_bss_to_new_bss_irat_meas_config_t   *p_irat_meas_config,
    U8                                          *p_temp_container,
    U8                                          *p_num_octet_filled,
    U8                                          irat_meas_iei_value,
    U8                                          src_cell_id_iei_value)
{
    U8                  current_index = RRC_NULL;
    U8                  irat_meas_ie_length_index = RRC_NULL;
    U8                  loop_index = RRC_NULL;
    U8                  max_count = RRC_NULL;
    U8                  src_cell_id_ie_length_index = RRC_NULL;
    U8                  plmn_id[MAX_PLMN_ID_BYTES] = {RRC_NULL};
    U8                  tac[TAC_OCTET_SIZE] = {RRC_NULL};
    U8                  cell_Id[CELL_ID_OCTET_SIZE] = {RRC_NULL};
    uecc_gb_context_t   *p_uecc_gb_context = PNULL;

    RRC_ASSERT(PNULL != p_irat_meas_config);
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_temp_container);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* Fill IEI and Length Values */
    p_temp_container[current_index] = irat_meas_iei_value;
    /* Increament current_index */
    current_index++;
    /* Store IE Length Index to fill length later */
    irat_meas_ie_length_index = current_index;
    /* Increament current_index */
    current_index++;

    /* Fill REP_QUANT + Reporting Threshold Octet Contents */
    /* Octet ZERO by default */
    p_temp_container[current_index] = RRC_NULL;
    /* Fill Reporting Threshold in LSB 6 Bits */
    p_temp_container[current_index] =
        (p_irat_meas_config->reporting_threshold & 0x3F);
    /* If REP_QUANT is 1, then Set 7th Bit */
    if(RRC_TRUE == p_irat_meas_config->rep_quant)
    {
        p_temp_container[current_index] |= 0x40;
    }
    /* Increament current_index */
    current_index++;

    /* Fill Measurement Duration in next Octet */
    p_temp_container[current_index] = 
        p_irat_meas_config->irat_meas_param.meas_duration;
    /* Increament current_index */
    current_index++;

    if(IRAT_MEAS_PARAM_EUTRA_FREQ_LIST_PRESENT & 
            p_irat_meas_config->irat_meas_param.bitmask)
    {
        max_count = p_irat_meas_config->irat_meas_param.eutra_freq_list.count;
        for(loop_index = RRC_NULL; loop_index < max_count; loop_index++)
        {
            /* Fill E_ARFCN High Part (8 Bits) */
            p_temp_container[current_index] = 
                (U8)(p_irat_meas_config->irat_meas_param.
                        eutra_freq_list.eutra_freq[loop_index].e_arfcn >> 8);
            /* Increament current_index */
            current_index++;
            /* Fill E_ARFCN Lower Part (8 Bits) */
            p_temp_container[current_index] = 
                (U8)(p_irat_meas_config->irat_meas_param.
                        eutra_freq_list.eutra_freq[loop_index].e_arfcn);
            /* Increament current_index */
            current_index++;
            /* Fill Measurement Bandwidth - As per 48008, Bits 1-3 coded for Meas bandwidth */
            p_temp_container[current_index] = (p_irat_meas_config->irat_meas_param.
                    eutra_freq_list.eutra_freq[loop_index].measurement_bandwidth & 0x07);
            /* Increament current_index */
            current_index++;
        }
    }
    /* Fill Length of IRAT Measurement Configuration */
    p_temp_container[irat_meas_ie_length_index] = (current_index - 1) - irat_meas_ie_length_index;
    /* SPR 21307 Fix Start */
    /* Code Deleted */
    /* SPR 21307  Fix Stop */
    
    /* 14. Fill Source Cell ID */
    /* As per 48008, Source Cell ID field element shall only be present 
     * in the case the IRAT Measurement Configuration field element is present */ 
    {
        /* Fill IEI and Length Values */
        p_temp_container[current_index] = src_cell_id_iei_value;
        /* Increament current_index */
        current_index++;
        /* Store IE Length Index to fill length later */
        src_cell_id_ie_length_index = current_index;
        /* Increament current_index */
        current_index++;

        /* Calculate TAI, E-UTRAN CGI and Global eNB-ID */
        /* Get PLMN as Octet String */
        uecc_s1ap_generate_plmn_identity_int((OSOCTET *)&plmn_id, 
                &p_ue_context->plmn_identity.plmn_identity);
        /* Get Cell ID & TAC */
        p_uecc_gb_context = p_ue_context->p_gb_context;
        if ((PNULL != p_uecc_gb_context) &&
                (PNULL != p_uecc_gb_context->p_p_csc_context) &&
                (PNULL != p_uecc_gb_context->p_p_csc_context[p_ue_context->cell_index])&&
                (PNULL != p_uecc_gb_context->p_p_csc_context[p_ue_context->cell_index]->p_csc_init_setup_ind))
        {
            l3_memcpy_wrapper(&cell_Id,
                    p_uecc_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                    p_csc_init_setup_ind->sib_type_1_Info.cell_access_related_info.cell_Id,
                    CELL_ID_OCTET_SIZE);

            l3_memcpy_wrapper(&tac,
                    p_uecc_gb_context->p_p_csc_context[p_ue_context->cell_index]->
                    p_csc_init_setup_ind->sib_type_1_Info.cell_access_related_info.tac,
                    TAC_OCTET_SIZE);
        }

        /* Fill TAI = PLMN + TAC */
        l3_memcpy_wrapper(&p_temp_container[current_index],
                &plmn_id, MAX_PLMN_ID_BYTES);
        /* Increament current_index */
        current_index += MAX_PLMN_ID_BYTES;
        l3_memcpy_wrapper(&p_temp_container[current_index],
                &tac, TAC_OCTET_SIZE);
        /* Increament current_index */
        current_index += TAC_OCTET_SIZE;

        /* Fill E-UTRAN CGI = PLMN + Cell Identity */
        l3_memcpy_wrapper(&p_temp_container[current_index],
                &plmn_id, MAX_PLMN_ID_BYTES);
        /* Increament current_index */
        current_index += MAX_PLMN_ID_BYTES;
        l3_memcpy_wrapper(&p_temp_container[current_index],
                &cell_Id, CELL_ID_OCTET_SIZE);
        /* Increament current_index */
        current_index += CELL_ID_OCTET_SIZE;

        /* Fill Global eNB-ID = PLMN + Macro/Home eNB-ID */
        l3_memcpy_wrapper(&p_temp_container[current_index],
                &plmn_id, MAX_PLMN_ID_BYTES);
        /* Increament current_index */
        current_index += MAX_PLMN_ID_BYTES;
        if ((PNULL != p_uecc_gb_context) && 
                (MACRO_ENB == p_uecc_gb_context->enbType))
        {
            l3_memcpy_wrapper(&p_temp_container[current_index],
                    &p_uecc_gb_context->macro_enb_id, MACRO_ENB_ID_OCTET_SIZE);
            /* Increament current_index */
            current_index += MACRO_ENB_ID_OCTET_SIZE;
        }
        else if((PNULL != p_uecc_gb_context) &&
                (HOME_ENB == p_uecc_gb_context->enbType))
        {
            l3_memcpy_wrapper(&p_temp_container[current_index],
                    &p_uecc_gb_context->home_enb_id, HOME_ENB_ID_OCTET_SIZE);
            /* Increament current_index */
            current_index += HOME_ENB_ID_OCTET_SIZE;
        }

        /* Fill Length of Source Cell ID IE */
        p_temp_container[src_cell_id_ie_length_index] = (current_index - 1) - src_cell_id_ie_length_index;
        /* SPR 21307  Fix Start */
        /* Code Deleted */
        /* SPR 21307  Fix Stop */
    }
    /* Update Num of Octet Filled paramter */
    *(p_num_octet_filled) = current_index;

    /* Fill Number of Octates = Total Length */
    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
        (p_ue_context->p_gb_context)->facility_name, RRC_INFO,
        "Final Length of IRAT Measurement Config and Source Cell ID = %d", 
        *(p_num_octet_filled));
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context); 
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_fill_source_bss_to_target_bss_container
 *
 *   INPUTS       : OSCTXT                  *p_asn1_ctx
 *                  uecc_ue_context_t*      p_ue_context
 *                  rrc_s1ap_handover_required_t *p_msg
 *   OUTPUTS      : None
 *   DESCRIPTION  :
 *                  This function fills source BSS to Target BSS container 
 *                  parameters to the Source to Target Transparent Container
 *                  1. MS Radio Access Capability -M
 *                  2. Inter Rat handover Info :UE UTRAN Capability- O
 *                  3. Page Mode -O
 *                  4. Container ID - O
 *                  5. Global TFI - O
 *                  6. PS Handover Indication - O
 *                  7. CS Indication - O
 *
 *   RETURNS      : RRC_SUCCESS or RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_fill_source_bss_to_target_bss_container 
(
    OSCTXT                          *p_asn1_ctx,
    uecc_ue_context_t               *p_ue_context,
    rrc_s1ap_handover_required_t    *p_msg
)
{
    U8                                  temp_container[S1AP_MAX_ASN1_BUF_LEN];
    U32                                 current_index = RRC_NULL;
    UE_Radio_Capability_RAT_Container_t *p_ue_radio_capability;
    rrc_rrm_ho_required_t               *p_rrc_rrm_ho_required = PNULL;
    OSOCTET                             *p_data = PNULL;
    RAT_Type                            rat_type;
    U8                                  irat_meas_src_cell_id_length = RRC_NULL;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_msg);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* assigning the p_rrc_rrm_ho_required */
    p_rrc_rrm_ho_required = p_ue_context->ho_info.p_ho_info->
        p_src_ho_info->s1_src_ho_info.p_rrc_rrm_ho_required;
    memset_wrapper(temp_container, RRC_NULL, S1AP_MAX_ASN1_BUF_LEN);

    /* As per 36.413 and 48018, TL parts not required to be filled, 
     * Hence 0 index should contain the mandatory parameter IE 
     */

    /* fill source BSS to target BSS transparent Container Content */
    /* 1. fill MS Radio Access Capability */
    rat_type = geran_ps;
    p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t *) 
        ylFind(&p_ue_context->ue_radio_capability,
                &rat_type, 
                uecc_rat_type_keyof, 
                uecc_rat_type_compare);
    if (p_ue_radio_capability != PNULL)
    {
        if(RRC_TRUE ==  p_ue_radio_capability->valid_rat_string)
        {
            /* fill IE  : as per 48018 */
            /* SPR 20635 Fix - Macro Definition Corrected */
            temp_container[current_index] = SOURCE_BSS_TARGET_BSS_MS_RADIO_ACCESS_CAPABILITY_IE;  

            /* Increment current_index */
            current_index++;

            /* SPR 17309 Fix Start*/
            /*Fill Length: as per 48018 */
            temp_container[current_index] = (U8)(p_ue_radio_capability->numocts);
            /* Check length to set length indication bit */
            if(NUM_OCTET >= p_ue_radio_capability->numocts)
            {   
                /* Filling the length indicator in only one octet when the numoct is not greater than 7F */
                /* Setting the extension bit to 1 which represents that length indicator(TLV Format) to 1 Octet */ 
                temp_container[current_index] |=0x80;
                /* Increment current_index by 1 byte as length value stored */
                current_index++;
            }
            else
            {
                /* When the numoct is greater than 7F, filling the length indicator in two octets (with extension bit set in 1st octet) */
                rrc_cp_pack_U16(&temp_container[current_index],&(p_ue_radio_capability->numocts), "length_indicator");
                /* Increment current_index by 2 bytes as length value stored */
                current_index += sizeof(U16);
            }
            /* Fill Contents : as per 48018 */
            l3_memcpy_wrapper(&temp_container[current_index],
                p_ue_radio_capability->p_rat_string,
                p_ue_radio_capability->numocts);

            /* Increment current_index by exact length */
            current_index += p_ue_radio_capability->numocts;
            /* SPR 17309 Fix End */
        }                             
        else
        { 
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name, RRC_ERROR,
                "[uecc_s1ap_fill_source_bss_to_target_bss_container]"
                "Wrong Rat Type(MS RADIO ACCESS CAPABILITY :GERAN PS should present");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }
    /* SPR 19592 Fix SATRT */
    else 
    {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name, RRC_ERROR,
                "[uecc_s1ap_fill_source_bss_to_target_bss_container]"
                "p_ue_radio_capability is NULL for GERAN PS");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
    }
    /*SPR 19592 Fix END */
    /* Bug 3672 Changes Start */
    /* SPR 17309 Fix Start */       

    /*SPR 13721 Fix Start*/
    /* 2. fill Inter Rat handover Info :UE UTRAN Capability */
    rat_type = utra_1;
    p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t*) 
        ylFind(&p_ue_context->ue_radio_capability,
                &rat_type, 
                uecc_rat_type_keyof, 
                uecc_rat_type_compare);

    if (p_ue_radio_capability != PNULL)
    {
        if(RRC_TRUE == p_ue_radio_capability->valid_rat_string)
        {
            /* fill IE : as per 48018  */
            /* SPR 20635 Fix - Macro Definition Corrected */
            temp_container[current_index] = SOURCE_BSS_TARGET_BSS_INTER_RAT_HANDOVER_INFO_IE;
            /* Increment current_index */
            current_index++;
            
            /* Fill Length : as per 48018 */
            temp_container[current_index] = (U8)(p_ue_radio_capability->numocts);
            /* Check length to set length indication bit */
            if((NUM_OCTET >= p_ue_radio_capability->numocts))
            {
                /* Filling the length indicator in 1 octet when the numoct is not greater than 7F */
                /* Setting the extension bit to 1 , which signifies that second octet of the length indicator is absent */ 
                temp_container[current_index] |=0x80;
                /* Increment current_index by 1 byte as length value stored */
                current_index++;
            }
            else
            {
                /* When the numoct is greater than 7F, filling the length indicator in two octets (with extension bit set in 1st octet) */
                rrc_cp_pack_U16(&temp_container[current_index],&(p_ue_radio_capability->numocts), "length_indicator");
                /* Increment current_index by 2 bytes as length value stored */
                current_index += sizeof(U16);
            }

            /* Fill Contents : as per 48018 */
            l3_memcpy_wrapper(&temp_container[current_index],
                p_ue_radio_capability->p_rat_string,
                p_ue_radio_capability->numocts);
            /* Increment current_index by exact length */
            current_index += p_ue_radio_capability->numocts;
        }
        else
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name, RRC_WARNING,
                "Wrong Rat Type : UE EUTRA CAPABILITY should be present");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }
    /*SPR 13721 Fix Stop*/
    /* Bug 3846 deleted else part */
    /* SPR 17309 Fix End */
    /* Bug 3672 Changes End */

    /* 3. Fill Page Mode */
    if( RRM_SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_PAGE_MODE_PRESENT &
        p_rrc_rrm_ho_required->source_to_target_container.bssContainer.bitmask )
    {
        /* fill IE : as per 48018  */
        /* SPR 20635 Fix - Macro Definition Corrected */
        temp_container[current_index] = SOURCE_BSS_TARGET_BSS_PAGE_MODE_IE;
        /* Increment current_index */
        current_index++;

        /* Bug 3672 Changes Start */
        /* SPR 17309 Fix Start */
        /* Fill Length: as per 48018 */
        temp_container[current_index] = 0x01;
        /* Setting the extension bit to 1 , which signifies that second octet of the length indicator is absent */ 
        temp_container[current_index] |=0x80;
        /* SPR 17309 Fix End */
        /* Bug 3672 Changes End */
        /* Increment current_index */
        current_index++;
        
        temp_container[current_index] = p_rrc_rrm_ho_required->
            source_to_target_container.bssContainer.page_mode;
        /* Increment current_index */
        current_index++;
    }

    /* 4. Fill container_id */
    if( RRM_SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_CONTAINER_ID_PRESENT &
        p_rrc_rrm_ho_required->source_to_target_container.bssContainer.bitmask )
    {
        /* fill IE : as per 48018  */
        /* SPR 20635 Fix - Macro Definition Corrected */
        temp_container[current_index] = SOURCE_BSS_TARGET_BSS_CONTAINER_ID_IE;
        /* Increment current_index */
        current_index++;

        /* Bug 3672 Changes Start */        
        /* SPR 17309 Fix Start */
        /* Fill Length: as per 48018 */
        temp_container[current_index] = 0x01;
        /* Setting the extension bit to 1 , which signifies that second octet of the length indicator is absent */ 
        temp_container[current_index] |=0x80;
        /* SPR 17309 Fix End */
        /* Bug 3672 Changes End */
        /* Increment current_index */
        current_index++;

        temp_container[current_index] = p_rrc_rrm_ho_required->
            source_to_target_container.bssContainer.container_id;
        /* Increment current_index */
        current_index++;
    }

    /* 5. Fill global_tfi */
    if( RRM_SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_GLOBAL_TFI_PRESENT &
        p_rrc_rrm_ho_required->source_to_target_container.bssContainer.bitmask )
    {
        /* fill IE : as per 48018  */
        /* SPR 20635 Fix - Macro Definition Corrected */
        temp_container[current_index] = SOURCE_BSS_TARGET_BSS_GLOBAL_TFI_IE;
        /* Increment current_index */
        current_index++;

        /* Bug 3672 Changes Start */
        /* SPR 17309 Fix Start */
        /* Fill Length: as per 48018 */
        temp_container[current_index] = 0x01;
        /* Setting the extension bit to 1 , which signifies that second octet of the length indicator is absent */ 
        temp_container[current_index] |=0x80;
        /* SPR 17309 Fix End */
        /* Bug 3672 Changes End */
        /* Increment current_index */
        current_index++;

        temp_container[current_index] = p_rrc_rrm_ho_required->
            source_to_target_container.bssContainer.global_tfi;
        /* Increment current_index */
        current_index++;
    }

    /* 6. Fill ps_handover_indication */
    if( RRM_SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_PS_INDICATION_PRESENT &
        p_rrc_rrm_ho_required->source_to_target_container.bssContainer.bitmask )
    {
        /* fill IE : as per 48018  */
        /* SPR 20635 Fix - Macro Definition Corrected */
        temp_container[current_index] = SOURCE_BSS_TARGET_BSS_PS_HANDOVER_INDICATION_IE;
        /* Increment current_index */
        current_index++;

        /* Bug 3672 Changes Start */
        /* SPR 17309 Fix Start */
        /* Fill Length: as per 48018 */
        temp_container[current_index] = 0x01;
        /* Setting the extension bit to 1 , which signifies that second octet of the length indicator is absent */ 
        temp_container[current_index] |=0x80;
        /* SPR 17309 Fix End */          
        /* Bug 3672 Changes End */
        /* Increment current_index */
        current_index++;
        
        temp_container[current_index] =  p_rrc_rrm_ho_required->
            source_to_target_container.bssContainer.ps_handover_indication;
        /* Increment current_index */
        current_index++;
    }

    /* 7. Fill cs_indication */
    if( RRM_SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_CS_INDICATION_PRESENT &
        p_rrc_rrm_ho_required->source_to_target_container.bssContainer.bitmask )
    {
        /* fill IE : as per 48018  */
        /* SPR 20635 Fix - Macro Definition Corrected */
        temp_container[current_index] = SOURCE_BSS_TARGET_BSS_CS_INDICATION_IE;
        /* Increment current_index */
        current_index++;

        /* Bug 3672 Changes Start */
        /* SPR 17309 Fix Start */
        /* Fill Length: as per 48018 */
        temp_container[current_index] = 0x01;
        /* Setting the extension bit to 1 , which signifies that second octet of the length indicator is absent */
        temp_container[current_index] |=0x80;
        /* SPR 17309 Fix End */
        /* Bug 3672 Changes End */
        /* Increment current_index */
        current_index++;

        temp_container[current_index] = p_rrc_rrm_ho_required->
            source_to_target_container.bssContainer.cs_indication;
        /* Increment current_index */
        current_index++;
    }
 
    /*SPR 14320 Fix Start*/
    /* 8. fill E-UTRAN Inter RAT Handover Info :UE EUTRA Capability */
    rat_type = eutra;
    p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t*) 
        ylFind(&p_ue_context->ue_radio_capability,
                &rat_type, 
                uecc_rat_type_keyof, 
                uecc_rat_type_compare);

    if (p_ue_radio_capability != PNULL)
    {
        if(RRC_TRUE == p_ue_radio_capability->valid_rat_string)
        {
            /* fill IE : as per 48018  */
            /* SPR 20635 Fix - Macro Definition Corrected */
            temp_container[current_index] = SOURCE_BSS_TARGET_BSS_E_UTRAN_INTER_RAT_HANDOVER_INFO_IE;
            /* Increment current_index */
            current_index++;

            /* Bug 3672 Changes Start */
            /* SPR 17309 Fix Start */
            /* Fill Length: as per 48018 */
            temp_container[current_index] = (U8)(p_ue_radio_capability->numocts);
            if((NUM_OCTET>= p_ue_radio_capability->numocts))
            {
                /* Filling the length indicator in 1 octet when the numoct is not greater than 7F */
                /* Setting the extension bit to 1 , to set the length indicator(TLV Format) to 1 Octet */
                temp_container[current_index] |=0x80;
                /* Increment current_index by 1 byte as Length stored */
                current_index++;
            }
            else
            {
                /* Filling the length indicator in both the octets when the numoct is greater than 7F */
                rrc_cp_pack_U16(&temp_container[current_index],&(p_ue_radio_capability->numocts), "length_indicator");
                /* Increment current_index by 2 bytes as Length stored */
                current_index += sizeof(U16);
            }
            /* fill contents */
            l3_memcpy_wrapper(&temp_container[current_index],
                p_ue_radio_capability->p_rat_string,
                p_ue_radio_capability->numocts);
            /* Incremeant current_index as per exact length */
            current_index += p_ue_radio_capability->numocts;
            /* SPR 17309 Fix End*/ 
            /* Bug 3672 Changes End */
        }
        else
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name, RRC_WARNING,
                "Wrong Rat Type : UE EUTRA CAPABILITY should be present");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }
    /*SPR 14320 Fix Stop*/

    /* 9. Fill IRAT Measurement Configuration */
    /* 10. Fill Source Cell ID */
    if( RRM_SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_IRAT_MEAS_CONFIG_PRESENT &
        p_rrc_rrm_ho_required->source_to_target_container.bssContainer.bitmask )
    {
        /* Call Function to Fill IRAT Meas Config and Source Cell ID */
        uecc_s1ap_fill_irat_meas_config_and_source_cell_id(
            p_ue_context,
            &p_rrc_rrm_ho_required->source_to_target_container.bssContainer.irat_meas_config,
            &temp_container[current_index],
            &irat_meas_src_cell_id_length,
            SOURCE_BSS_TARGET_BSS_IRAT_MEASUREMENT_CONFIGURATION_IE,
            SOURCE_BSS_TARGET_BSS_SOURCE_CELL_ID_IE);

        /* Update Total Length parameter */
        current_index += irat_meas_src_cell_id_length;
    }

    /* Fill temp_container directly to source to target transparent container */
    /* ASN encoding and Higher level T and L values not required */
    /* Fill NumOcts = current_index as it points to exact length */
    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
        (p_ue_context->p_gb_context)->facility_name, RRC_INFO,
        "Final length of the container = %d",current_index);

    p_msg->source_to_target_transparent_container.numocts = current_index;
    /* Copy data from temp_container to source_to_target_transparent_container */
    p_data = (U8*)rtxMemAlloc(p_asn1_ctx, p_msg->source_to_target_transparent_container.numocts);
    if( PNULL != p_data)
    {
        l3_memcpy_wrapper(p_data,temp_container, p_msg->source_to_target_transparent_container.numocts);
        p_msg->source_to_target_transparent_container.data = p_data;
    }
    else
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
            (p_ue_context->p_gb_context)->facility_name, RRC_ERROR,
            "[rtxMemAlloc Failed for p_data ]"
            "Encoding failed for s1ap_source_to_targe_transparent container");
    }
    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
        (p_ue_context->p_gb_context)->facility_name, RRC_INFO,
        "[uecc_s1ap_fill_source_bss_to_target_bss_container]"
        "Encoding successful for s1ap_source_bss_to_targetbss_transparent container");
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_fill_old_bss_to_new_bss_info_container
 *
 *   INPUTS       : OSCTXT                               *p_asn1_ctx
 *                  rrc_s1ap_handover_required_t         *p_msg
 *                  uecc_ue_context_t                    *p_ue_context
 *                  rrm_old_bss_to_new_bss_information_t *p_old_bss_to_new_bss_info
 *                  U8                                    ho_domain_flag
 *   OUTPUTS      : None
 *   DESCRIPTION  :
 *                  This function fills  following things:
 *                  1. old BSS To new BSS information 
 *                  2. MS CLASSMARK 2
 *                  3. MS CLASSMARK 3
 *
 *   RETURNS      : RRC_SUCCESS or RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_fill_old_bss_to_new_bss_info_container(
    OSCTXT                                  *p_asn1_ctx,
    rrc_s1ap_handover_required_t            *p_msg,
    uecc_ue_context_t                       *p_ue_context,
    rrm_old_bss_to_new_bss_information_t    *p_old_bss_to_new_bss_info,
    U8                                      ho_domain_flag)
{
    U8      temp_container[S1AP_MAX_ASN1_BUF_LEN];
    U8      current_index = RRC_NULL;
    U8      total_length = RRC_NULL;
    U8      extra_info_element = RRC_NULL;
    U8      irat_meas_src_cell_id_length = RRC_NULL;
    OSOCTET *p_data = PNULL;
    s1ap_Source_ToTarget_TransparentContainer   *p_container = PNULL;
    UE_Radio_Capability_RAT_Container_t         *p_ue_radio_capability_utra = PNULL;
    UE_Radio_Capability_RAT_Container_t         *p_ue_radio_capability_cdma = PNULL;
    RAT_Type                                    rat_type = RRC_NULL;
    
    RRC_ASSERT(PNULL!=p_old_bss_to_new_bss_info);
    RRC_ASSERT(PNULL!=p_ue_context);
    RRC_ASSERT(PNULL!=p_msg);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if(CS_PS_TYPE == ho_domain_flag)
    {
        p_container =  &p_msg->source_to_target_transparent_container_secondary;
    }
    else
    {
        p_container =  &p_msg->source_to_target_transparent_container;
    }

    memset_wrapper(temp_container,0, S1AP_MAX_ASN1_BUF_LEN);

    /* Fill old BSS to New Bss information Elements, direct V to be filled,
     * Ignore IEI and Length Bytes of Old BSS to New BSS Information */
    /* 1. Fill Extra Information, if present */
    if(RRM_OLD_BSS_TO_NEW_BSS_INFO_EXTRA_INFO_PRESENT & 
        p_old_bss_to_new_bss_info->bitmask)
    {
        /* Fill Extra Information IEI Value */
        temp_container[current_index] = OLD_BSS_NEW_BSS_EXTRA_INFORMATION_IE;
        /* Increament current_index */
        current_index++;
        /* Fill Extra Information IEI Length Value - 0x01 (Fixed) */
        temp_container[current_index] = OLD_BSS_NEW_BSS_EXTRA_INFORMATION_LENGTH;
        /* Update Total Length parameter */
        total_length += temp_container[current_index] + HEADER_IE_PLUS_LENGTH;
        /* SPR 21307  Fix Start */ 
        /* Code Deleted */
        /* SPR 21307  Fix Stop */ 
        /* Increament current_index */
        current_index++;
        
        /* Calculate and Fill Extra Info Element Value */
        if(RRM_BSS_EXTRA_INFORMATION_PRE_EMPTION_RECOMMEDATION_PRESENT &
            p_old_bss_to_new_bss_info->extra_information.bitmask)
        {
            extra_info_element |= 
                RRM_BSS_EXTRA_INFORMATION_PRE_EMPTION_RECOMMEDATION_PRESENT;
        }
        if(RRM_BSS_EXTRA_INFORMATION_LCS_INFO_PRESENT &
            p_old_bss_to_new_bss_info->extra_information.bitmask)
        {
            extra_info_element |= RRM_BSS_EXTRA_INFORMATION_LCS_INFO_PRESENT;
        }
        if(RRM_BSS_EXTRA_INFORMATION_UMTS_HO_SUPPORT_PRESENT &
            p_old_bss_to_new_bss_info->extra_information.bitmask)
        {
            extra_info_element |= RRM_BSS_EXTRA_INFORMATION_UMTS_HO_SUPPORT_PRESENT;
        }
        temp_container[current_index] = extra_info_element;
        /* Increament current_index */
        current_index++;
    }

    /* 2. Current Channel Type 2, Not Required in case of SRVCC from LTE to GERAN */
    /* 3. Fill Target Cell Radio Information, if present */
    if(RRM_OLD_BSS_TO_NEW_BSS_INFO_TARGET_CELL_RADIO_INFO_PRESENT & 
        p_old_bss_to_new_bss_info->bitmask)
    {
        /* Fill IEI and Length Values */
        temp_container[current_index] = 
            OLD_BSS_NEW_BSS_TARGET_CELL_RADIO_INFORMAION_IE;
        /* Increament current_index */
        current_index++;
        temp_container[current_index] = OLD_BSS_NEW_BSS_TARGET_CELL_RADIO_INFORMAION_LENGTH;
        /* Update Total Length parameter */
        total_length += temp_container[current_index] + HEADER_IE_PLUS_LENGTH;
        /* SPR 21307 Fix Start */ 
        /* Code Deleted */
        /* SPR 21307  Fix Stop */ 
        /* Increament current_index */
        current_index++;

        /* Fill RXLEV_NCELL - As per spec 48008, Only Bit 1-6 to be filled */
        temp_container[current_index] = 
            (p_old_bss_to_new_bss_info->target_cell_rxlev & 0x3F);
        /* Increament current_index */
        current_index++;
    }

    /* 4. GPRS Suspend Information, Not Required in case of SRVCC from LTE to GERAN */
    /* 5. Multi Rate Configuration Information, Not Required in case of SRVCC from LTE to GERAN */
    /* 6. Dual Transfer Mode Information, Not Required in case of SRVCC from LTE to GERAN */
    /* 7. Fill INTER RAT Handover Information, UE-CapabilityRAT-Container : For UTRA*/
    {
        rat_type = utra_1;
        p_ue_radio_capability_utra = (UE_Radio_Capability_RAT_Container_t *) 
            ylFind(&p_ue_context->ue_radio_capability, &rat_type, 
            uecc_rat_type_keyof, uecc_rat_type_compare);

        /* Validating RAT strings and Fill IEI Information */
        if((PNULL != p_ue_radio_capability_utra) &&
            (RRC_TRUE == p_ue_radio_capability_utra->valid_rat_string))
        {
            /* Fill IEI  */
            temp_container[current_index] = 
                OLD_BSS_NEW_BSS_INTER_RAT_HANDOVER_INFO_IE;
            /* Increament current_index */
            current_index++;
            /* Fill Length */
            temp_container[current_index] = p_ue_radio_capability_utra->numocts;
            /* SPR 21307 Fix Start */
            /* Code Deleted */
            current_index++;
            /* SPR 21307 Fix Stop */ 
            l3_memcpy_wrapper(&temp_container[current_index],
                p_ue_radio_capability_utra->p_rat_string,
                p_ue_radio_capability_utra->numocts);

            /* Increament current_index by numocts */
            current_index += p_ue_radio_capability_utra->numocts;
            /* Update Total Length parameter */
            total_length += HEADER_IE_PLUS_LENGTH + p_ue_radio_capability_utra->numocts;
        }
    }

    /* 8. Fill CDMA2000 Capability Information */
    {
        rat_type = cdma2000_1XRTT_1;
        p_ue_radio_capability_cdma = (UE_Radio_Capability_RAT_Container_t *) 
            ylFind(&p_ue_context->ue_radio_capability, &rat_type, 
            uecc_rat_type_keyof, uecc_rat_type_compare);

        /* Validating RAT strings and Fill IEI Information */
        if((PNULL != p_ue_radio_capability_cdma) &&
            (RRC_TRUE == p_ue_radio_capability_cdma->valid_rat_string))
        {
            /* Fill IEI  */
            temp_container[current_index] = 
                OLD_BSS_NEW_BSS_CDMA2000_CAPABILITY_INFO_IE;
            /* Increament current_index */
            current_index++;
            /* Fill Length */
            temp_container[current_index] = p_ue_radio_capability_cdma->numocts;
            /* SPR 21307 Fix Start */
            /* Code Deleted */
            current_index++;
            /* SPR 21307 Fix Stop */

            l3_memcpy_wrapper(&temp_container[current_index],
                p_ue_radio_capability_cdma->p_rat_string,
                p_ue_radio_capability_cdma->numocts);

            /* Increament current_index by numocts */
            current_index += p_ue_radio_capability_cdma->numocts;
            /* Update Total Length parameter */
            total_length += HEADER_IE_PLUS_LENGTH + p_ue_radio_capability_cdma->numocts;
        }
    }

    /* 9. Fill Cell Load Information Group, Not Required in case of SRVCC from LTE to GERAN */
    /* 10. Fill VGCS Talker Mode, Not Required in case of SRVCC from LTE to GERAN */
    /* 11. Fill PS Indication, if present */
    if(RRM_OLD_BSS_TO_NEW_BSS_INFO_PS_INDICATION_PRESENT & 
        p_old_bss_to_new_bss_info->bitmask)
    {
        /* Fill IEI and Length Values */
        temp_container[current_index] = 
            OLD_BSS_NEW_BSS_PS_INDICATION_IE;
        /* Increament current_index */
        current_index++;
        temp_container[current_index] = OLD_BSS_NEW_BSS_PS_INDICATION_LENGTH;
        /* Update Total Length parameter */
        total_length += temp_container[current_index] + HEADER_IE_PLUS_LENGTH;
        /* SPR 21307 Fix Start */
        /* Code Deleted */
        /* SPR 21307 Fix Stop */
        /* Increament current_index */
        current_index++;

        /* Fill PS Indication Contents */
        temp_container[current_index] = 
            p_old_bss_to_new_bss_info->old_bss_to_new_bss_ps_indication;
        /* Increament current_index */
        current_index++;
    }

    /* 12. Fill D-RNTI, Not Required in case of SRVCC from LTE to GERAN */
    /* 13. Fill IRAT Measurement Configuration, if present */
    /* 14. Fill Source Cell ID with IRAT Measurement Configuration */
    if(RRM_OLD_BSS_TO_NEW_BSS_INFO_IRAT_MEAS_CONFIG_INFO_PRESENT & 
        p_old_bss_to_new_bss_info->bitmask)
    {
        /* Call Function to Fill IRAT Meas Config and Source Cell ID */
        uecc_s1ap_fill_irat_meas_config_and_source_cell_id(
            p_ue_context,
            &p_old_bss_to_new_bss_info->irat_meas_config,
            &temp_container[current_index],
            &irat_meas_src_cell_id_length,
            OLD_BSS_NEW_BSS_IRAT_MEASUREMENT_CONFIGURATION_IE,
            OLD_BSS_NEW_BSS_SOURCE_CELL_ID_IE);
        /* Update Total Length parameter */
        total_length += irat_meas_src_cell_id_length;
    }

    /* As per speicification only "V" part to be filled in container */
    /* Fill Old BSS to New BSS Information IEI: as per 48008 spec */
    /* temp_container[0]= OLD_BSS_TO_NEW_BSS_INFORMATION_IE; */
    /* Fill Old BSS to New BSS Information Length as per filled parameters */
    /* temp_container[1] = total_length; */

    /* Fill Number of Octates = Total Length */
    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
        (p_ue_context->p_gb_context)->facility_name, RRC_INFO,
        "Final Length of Old BSS to New BSS Information Container = %d", total_length);
    p_container->numocts = total_length;
    
    p_data = (U8*)rtxMemAlloc(p_asn1_ctx, p_container->numocts);
    /* SPR 12964 Fix Start */
    if(PNULL == p_data)
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
            p_ue_context->p_gb_context->facility_name, RRC_ERROR,
            "Mem Alloc failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    /* SPR 12964 Fix Stop */

    l3_memcpy_wrapper(p_data, temp_container, p_container->numocts);
    p_container->data = p_data;
    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
        (p_ue_context->p_gb_context)->facility_name, RRC_INFO,
        "[uecc_s1ap_fill_old_bss_to_new_bss_info_container]"
        "Encoding successful for s1ap_old_bss_to_new_bss_information");

    memset_wrapper(temp_container,0, S1AP_MAX_ASN1_BUF_LEN);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context); 
    return RRC_SUCCESS;
}
/* SPR 20635 Fix - SRVCC to GERAN - Ends */

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_sourceENB_to_targetENB_transparent_container
 *
 *   INPUTS       : rrc_s1ap_handover_required_t    *p_s1ap_msg
 *                  uecc_ue_context_t*      p_ue_context
 *                  OSCTXT                          *p_asn1_ctxt
 *                  rrc_rrm_ho_required_t           *p_rrc_rrm_ho_required
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function build and encode the sourceENB to targetENB transparent
 *       container which will further added to HO_REQUIRED message going to MME
 *
 *   RETURNS: RRC_SUCCESS or RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_sourceENB_to_targetENB_transparent_container
(
 rrc_s1ap_handover_required_t    *p_s1ap_msg,
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *p_asn1_ctxt,
 rrc_rrm_ho_required_t           *p_rrc_rrm_ho_required
 )
{
    rrc_return_et                       result = RRC_FAILURE;
    HandoverPreparationInformation      handover_prep_info;
    s1ap_RRC_Container                  rRC_Container;
    s1ap_EUTRAN_CGI                     *p_s1ap_eutran_cgi = PNULL;
    s1ap_SourceeNB_ToTargeteNB_TransparentContainer 
        source_enb_to_target_enb_trasprent_container;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_asn1_ctxt);
    RRC_ASSERT(PNULL != p_rrc_rrm_ho_required);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&handover_prep_info, 0, sizeof(handover_prep_info));
    memset_wrapper(&rRC_Container, 0, sizeof(rRC_Container));
    memset_wrapper(&source_enb_to_target_enb_trasprent_container, 0, 
            sizeof(source_enb_to_target_enb_trasprent_container));

    do
    {
        /* filling target ID start */
        p_s1ap_msg->target_id.t = T_s1ap_TargetID_targeteNB_ID;
        p_s1ap_msg->target_id.u.targeteNB_ID = rtxMemAllocType(p_asn1_ctxt,
                s1ap_TargeteNB_ID);
        if ( PNULL ==  p_s1ap_msg->target_id.u.targeteNB_ID )
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_sourceENB_to_targetENB_transparent_container]"
                    "Fail to allocate memory]");
            break;
        }
        asn1Init_s1ap_TargeteNB_ID(p_s1ap_msg->target_id.u.targeteNB_ID);

        if (RRC_SUCCESS != uecc_s1ap_build_s1ap_TargeteNB_ID(
                    p_rrc_rrm_ho_required,
                    p_asn1_ctxt,
                    p_s1ap_msg->target_id.u.targeteNB_ID,
                    p_ue_context))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_s1ap_build_sourceENB_to_targetENB_transparent_container]"
                    "Target eNB_ID Build Failed");
            break;
        }

        /* filling target ID end */

        /* start Handover Preparation Information */
        handover_prep_info.criticalExtensions.t 
            = T_HandoverPreparationInformation_criticalExtensions_c1;
        handover_prep_info.criticalExtensions.u.c1 = rtxMemAllocType(p_asn1_ctxt,
                HandoverPreparationInformation_criticalExtensions_c1);
        if( PNULL == handover_prep_info.criticalExtensions.u.c1 )
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_sourceENB_to_targetENB_transparent_container]"
                    "Fail to allocate memory]");
            break;
        }
        asn1Init_HandoverPreparationInformation_criticalExtensions_c1 (
                handover_prep_info.criticalExtensions.u.c1);
        handover_prep_info.criticalExtensions.u.c1->t =
            T_HandoverPreparationInformation_criticalExtensions_c1_handoverPreparationInformation_r8;
        handover_prep_info.criticalExtensions.u.c1->u.
            handoverPreparationInformation_r8= 
            rtxMemAllocType(p_asn1_ctxt,
                    HandoverPreparationInformation_r8_IEs);
        if( PNULL == handover_prep_info.criticalExtensions.u.c1->u.
                handoverPreparationInformation_r8 )
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_sourceENB_to_targetENB_transparent_container]"
                    "Fail to allocate memory]");
            break;
        }

        memset_wrapper(handover_prep_info.criticalExtensions.u.c1->u.
                handoverPreparationInformation_r8,0,sizeof(
                    HandoverPreparationInformation_r8_IEs));

        asn1Init_HandoverPreparationInformation_r8_IEs (
                handover_prep_info.criticalExtensions.u.c1->u.
                handoverPreparationInformation_r8);
        if (RRC_SUCCESS != 
                uecc_s1ap_build_HandoverPreparationInformation(
                    p_ue_context,
                    p_asn1_ctxt,
                    handover_prep_info.criticalExtensions.u.c1->u.
                    handoverPreparationInformation_r8))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_s1ap_build_sourceENB_to_targetENB_transparent_container]"
                    "Fail to fill Handover Information");
            break;
        }
        /* end Handover Preparation Information */

        /* Encode rrc container */
        if(RRC_SUCCESS != rrc_s1ap_rrc_container_intrl_enc(
                    p_ue_context->p_gb_context,
                    p_asn1_ctxt,
                    &rRC_Container, 
                    &handover_prep_info))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_s1ap_build_sourceENB_to_targetENB_transparent_container]"
                    "RRC Container Build failure");
            break;
        }
        /* filling encoded rrc container */
        source_enb_to_target_enb_trasprent_container.rRC_Container =
            rRC_Container;

        /* filling e_RABInformationList from the ue context */
        if (p_rrc_rrm_ho_required->source_to_target_container.eNBContainer.\
                bitmask &
                SOURCE_ENB_TO_TARGET_ENB_TRANSPARENT_CONTAINER_ERAB_DL_FWDING_LIST_PRESENT )
        {
            source_enb_to_target_enb_trasprent_container.m.\
                e_RABInformationListPresent = 1;
            if (RRC_SUCCESS != uecc_s1ap_build_s1ap_E_RABInformationList(
                        p_ue_context,
                        p_asn1_ctxt,
                        &source_enb_to_target_enb_trasprent_container.\
                        e_RABInformationList))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[uecc_s1ap_build_sourceENB_to_targetENB_transparent_container]"
                        "Fail to fill e_RABInformationList");
                break;
            }
        }

        /* filling the targetCell_ID */
        p_s1ap_eutran_cgi = &(source_enb_to_target_enb_trasprent_container.
                targetCell_ID);
        /* filling the plmn id */
        p_s1ap_eutran_cgi->pLMNidentity.numocts = MCC_OCTET_SIZE;
        uecc_s1ap_generate_plmn_identity_int(
                p_s1ap_eutran_cgi->pLMNidentity.data,
                &(p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.
                    plmn_identity));

        /* copy cell_identity */
        p_s1ap_eutran_cgi->cell_ID.numbits = 8*sizeof(
                p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.
                cell_identity); 
        p_s1ap_eutran_cgi->cell_ID.numbits = 
            (p_s1ap_eutran_cgi->cell_ID.numbits < MAX_CELL_ID_BITS ? 
             p_s1ap_eutran_cgi->cell_ID.numbits : MAX_CELL_ID_BITS);

        l3_memcpy_wrapper( p_s1ap_eutran_cgi->cell_ID.data,
                p_rrc_rrm_ho_required->target_id.enb_id.global_enb_id.\
                cell_identity,
                p_s1ap_eutran_cgi->cell_ID.numbits/8+1);
        p_s1ap_eutran_cgi->m.iE_ExtensionsPresent = 0;

        /* filling subscriberProfileIDforRFP */
        if (p_rrc_rrm_ho_required->source_to_target_container.eNBContainer.\
                bitmask & 
                SOURCE_ENB_TO_TARGET_ENB_TRANSPARENT_CONTAINER_SUB_PROFILE_ID_PRESENT )
        {
            source_enb_to_target_enb_trasprent_container.m.\
                subscriberProfileIDforRFPPresent = 1;
            source_enb_to_target_enb_trasprent_container.\
                subscriberProfileIDforRFP = p_rrc_rrm_ho_required->\
                source_to_target_container.eNBContainer.sub_profile_id;
        }

        /* filling ue_history */
        if (RRC_SUCCESS != uecc_s1ap_build_s1ap_UE_HistoryInformation(
                    &p_rrc_rrm_ho_required->source_to_target_container.  \
                    eNBContainer.ue_histroy,
                    p_asn1_ctxt,
                    &source_enb_to_target_enb_trasprent_container.\
                    uE_HistoryInformation,
                    p_ue_context))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_s1ap_build_sourceENB_to_targetENB_transparent_container]"
                    "Fail to fill UE_HistoryInformation");
            break;
        }
        /* Encoding source_enb_to_targer_enb_container */
        if(RRC_SUCCESS != rrc_s1ap_source_enb_to_targer_enb_container_intrl_enc(
                    p_ue_context->p_gb_context,
                    p_asn1_ctxt,
                    &p_s1ap_msg->source_to_target_transparent_container,
                    &source_enb_to_target_enb_trasprent_container))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_s1ap_build_sourceENB_to_targetENB_transparent_container]"
                    "Encoding failed for source_enb_to_targer_enb_container");
            break;
        }
        /* Information Build Successful */
        result = RRC_SUCCESS;
    }while(0);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container
 *
 *   INPUTS       : rrc_s1ap_handover_required_t    *p_s1ap_msg
 *                  uecc_ue_context_t*      p_ue_context
 *                  OSCTXT                          *p_asn1_ctx
 *                  rrc_rrm_ho_required_t           *p_rrc_rrm_ho_required
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function build and encode the sourceRNC to targetRNC transparent
 *       container which will further added to HO_REQUIRED message going to MME
 *
 *   RETURNS: RRC_SUCCESS or RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container
(
 rrc_s1ap_handover_required_t    *p_s1ap_msg,
 uecc_ue_context_t               *p_ue_context,
 OSCTXT                          *p_asn1_ctxt,
 rrc_rrm_ho_required_t           *p_rrc_rrm_ho_required
 )
{
    rrc_return_et           result = RRC_FAILURE;
    ranap_SourceRNC_ToTargetRNC_TransparentContainer
        source_rnc_to_target_rnc_transparent_container;
    rrm_source_rnc_to_target_rnc_transparent_container_t 
        *p_rnc_container = PNULL;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_asn1_ctxt);
    RRC_ASSERT(PNULL != p_rrc_rrm_ho_required);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&source_rnc_to_target_rnc_transparent_container, 0, 
            sizeof(source_rnc_to_target_rnc_transparent_container));

    p_rnc_container = &p_rrc_rrm_ho_required->source_to_target_container.   \
                      rncContainer;
    do
    {
        /* Checking rrm_sourceRNC container */
        if(PNULL == p_rnc_container)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container]"
                    "rrm sourceRNC container is NULL");
            break;    
        }
        /* Filling target ID */
        p_s1ap_msg->target_id.t = T_s1ap_TargetID_targetRNC_ID;
        p_s1ap_msg->target_id.u.targetRNC_ID = 
            rtxMemAllocType(p_asn1_ctxt,s1ap_TargetRNC_ID);
        if (PNULL ==  p_s1ap_msg->target_id.u.targetRNC_ID )
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container]"
                    "Fail to allocate memory]");
            break;
        }
        uecc_s1ap_build_s1ap_TargetRNC_ID(p_ue_context->p_gb_context,
                p_rrc_rrm_ho_required,/*SPR 17777 +-*/ 
                p_s1ap_msg->target_id.u.targetRNC_ID);

        /* Filling RRC Container */
        if (RRC_SUCCESS != uecc_s1ap_build_n_encode_rrc_container(
                    p_ue_context, p_asn1_ctxt,
                    &source_rnc_to_target_rnc_transparent_container.rRC_Container))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container]"
                    "Fail to fill RNC RRC Container");
            break;
        }

        /* Filling Number of lu instances */
        if(RRC_RRM_UE_HO_ADM_REQ_SRVCC_HO_INDICATION_PRESENT & p_s1ap_msg->bitmask)
        {
            if(((CS_ONLY_TYPE == p_s1ap_msg->srvcc_ho_indication) && 
                        (1 == p_rnc_container->number_of_Iu_instances))
                    || ((CS_PS_TYPE == p_s1ap_msg->srvcc_ho_indication) && 
                        (2 == p_rnc_container->number_of_Iu_instances)))
            {
                source_rnc_to_target_rnc_transparent_container.numberOfIuInstances
                    = p_rnc_container->number_of_Iu_instances;
            }
            else
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container]"
                        "Invalid value received for Number of lu instances from RRM");
                break;        
            }
        }    
        else if(1 == p_rnc_container->number_of_Iu_instances)
        {
            source_rnc_to_target_rnc_transparent_container.numberOfIuInstances
                = p_rnc_container->number_of_Iu_instances;
        }
        else
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container]"
                    "Fail to fill Number of lu instances as SRVCC Info not present");
            break;        
        }

        /* Filling relocation type */
        source_rnc_to_target_rnc_transparent_container.relocationType =
            p_rnc_container->relocation_type;

        /* Filling Chosen Integrity Protection Algorithm */
        if(RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_SECURITY_INFO_PRESENT
                & p_rnc_container->bitmask)
        {
            uecc_s1ap_fill_rnc_container_security_info(
                    p_ue_context->p_gb_context, 
                    &source_rnc_to_target_rnc_transparent_container,
                    &p_rnc_container->security_info);
        }    

        /* Checking presence of d-RNTI & Target Cell ID*/
        if((RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_D_RNTI_PRESENT
                    & p_rnc_container->bitmask)
                && (RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_TARGET_CELL_ID_PRESENT
                    & p_rnc_container->bitmask))        
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container]"
                    "Both d-RNTI & Target Cell ID cannot be present");
            break;        
        }
        else if(RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_D_RNTI_PRESENT
                & p_rnc_container->bitmask)
        {
            /* Filling d-RNTI */
            if(UE_NOT_INVOLVED == p_rnc_container->relocation_type)
            {
                source_rnc_to_target_rnc_transparent_container.m.       \
                    d_RNTIPresent = 1;
                source_rnc_to_target_rnc_transparent_container.d_RNTI =
                    p_rnc_container->d_rnti;
            }
            else
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container]"
                        "Invalid d_RNTI value");
                break;        
            }
        }
        else if(RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_TARGET_CELL_ID_PRESENT
                & p_rnc_container->bitmask)
        {    
            /* Filling Target Cell ID */
            if(UE_INVOLVED == p_rnc_container->relocation_type)
            {
                source_rnc_to_target_rnc_transparent_container.m.       \
                    targetCellIdPresent = 1;
                source_rnc_to_target_rnc_transparent_container.targetCellId =
                    p_rnc_container->target_cell_id;
            }
            else
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container]"
                        "Invalid Target Cell ID");
                break;
            }    
        }

        /* Filling RAB TrCH Mapping */
        if(RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_RAB_TRANSPORT_CH_MAP_PRESENT
                & p_rnc_container->bitmask)
        {
            source_rnc_to_target_rnc_transparent_container.m.           \
                rAB_TrCH_MappingPresent = 1;
            if (RRC_SUCCESS != uecc_s1ap_build_ranap_RAB_TrCH_Mapping(
                        p_rnc_container,
                        p_asn1_ctxt,
                        &source_rnc_to_target_rnc_transparent_container.rAB_TrCH_Mapping,
                        p_rrc_rrm_ho_required->source_to_target_container.  \
                        rncContainer.no_of_rab_transport_channel_mappings,p_ue_context))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container]"
                        "Fail to fill the TrCH Mapping");
                break;
            }
        }

        /* Filling Protocol Extention Container */
        source_rnc_to_target_rnc_transparent_container.m.           \
            iE_ExtensionsPresent = 1;
        if (RRC_SUCCESS != uecc_s1ap_build_Protocol_extn_container(
                    p_rnc_container,
                    p_asn1_ctxt,
                    &source_rnc_to_target_rnc_transparent_container,
                    p_ue_context))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,                               
                    "[uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container]"
                    "Fail to fill Protocol Extension Container");
            break;
        }

        /* Filling extElem1 */
        rtxDListInit(&source_rnc_to_target_rnc_transparent_container.extElem1);

        /* Encode sourceRNC to TargetRNC and fill in Source to Target Transparent Container */
        if(RRC_SUCCESS != rrc_s1ap_source_rnc_to_targer_rnc_container_intrl_enc(
                    p_ue_context->p_gb_context,
                    p_asn1_ctxt,
                    &p_s1ap_msg->source_to_target_transparent_container,
                    &source_rnc_to_target_rnc_transparent_container))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_s1ap_build_sourceRNC_to_targetRNC_transparent_container]"
                    "s1ap_HandoverSourceToTargetTransparentContainer Build failure");
            break;
        }
        /* Information Build Successful */
        result = RRC_SUCCESS;
    }while(0);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_handover_cancel_ack
 *
 *   INPUTS       : S1AP_PDU            *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  U8                  mme_id
 *                  U8                  *p_buff
 *                  U16                 buffer_length
 *                  U16                 ue_index
 *
 *   OUTPUTS      : None
 *   DESCRIPTION  : This function processes S1AP Handover Cancel Ack message
 *
 *   RETURNS      : None
 ******************************************************************************/
void uecc_s1ap_process_handover_cancel_ack
(
 S1AP_PDU              *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context,  /* UECC global context */
 U8                  mme_id,
 U8                  *p_buff,        /* ASN.1 encoded message */
/*BUG 604 changes start*/ 
 U16                 buffer_length,      /* encoded buf size - just for check*/
 U16                 ue_index
/*BUG 604 changes stop*/ 
 )
{
    uecc_ue_context_t           *p_ue_context = PNULL;
    rrc_s1ap_handover_cancel_ack_t  msg;
    EVENT_EXTERNAL_HEADER       *p_event_header = PNULL;
    U32                         encoded_msglen = 0;


    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_ASSERT(PNULL!=p_s1ap_pdu->u.successfulOutcome);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    memset_wrapper(&msg, 0, sizeof(rrc_s1ap_handover_cancel_ack_t));

    do
    {
        if (PNULL==p_s1ap_pdu->u.successfulOutcome->value.u.handoverCancel)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Handover Cancel] handoverCancel field is PNULL");
            break;
        }

        /* Decode message */
        if( RRC_FAILURE == rrc_s1ap_handover_cancel_ack_intrl_dec(
                    p_uecc_gb_context,
                    mme_id,
                    p_s1ap_pdu->u.successfulOutcome->value.u.handoverCancel,
                    &msg
                    ))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, " Handover Cancel Ack"
                    "Decoding Failure");
            break;
        }


        /* Process message */
/*BUG 604 changes start*/ 
        /* Get context using ue_index */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,ue_index);
/*BUG 604 changes stop*/ 

        if (PNULL==p_ue_context )
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Handover Command] UE context not found");

            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"[S1AP Handover Command]"
                    "message dropped -"
                    "UECC isn't initialized by CSC ");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }

        if (PNULL != p_ue_context)
        {
            /*Generating Protocol Events */
            /* SPR 22634 Fix - Starts */
            encoded_msglen = (U32)(buffer_length);
            /* SPR 22634 Fix - Ends */
            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msglen);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msglen),
                        LOCAL_S1_HANDOVER_CANCEL_ACKNOWLEDGE,
                        MESSAGE_DIRECTION_RECEIVED);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_buff,
                        encoded_msglen);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }
        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, p_buff, encoded_msglen, 
                                                 "Handover Cancel Acknowledge", 0);
        /* TRACE_changes_start */

        /* Call UECC_EV_S1AP_HO_CANCEL_ACK event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_S1AP_HO_CANCEL_ACK,
                &msg);

    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_del_ctx_msg_ind
 *
 *   INPUTS       : void                *p_api
 *                 uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes S1AP_DEL_CONTEXT_MSG_IND
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/

void uecc_s1ap_process_del_ctx_msg_ind(
        void                *p_api,             /* Input API buffer */
        uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
        )
{
    uecc_ue_context_t                 *p_ue_context = PNULL;

    s1ap_del_ctx_msg_ind_t *p_s1ap_del_ctx_msg_ind = PNULL;


    RRC_ASSERT(PNULL!=p_api);
    RRC_ASSERT(PNULL!=p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) !=
            (RRC_API_HEADER_SIZE + sizeof(s1ap_del_ctx_msg_ind_t)))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[S1AP_DEL_CONTEXT_MSG_IND] Wrong message size - ignore");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }

    p_s1ap_del_ctx_msg_ind =
        (s1ap_del_ctx_msg_ind_t *)((U8*)p_api + RRC_API_HEADER_SIZE);

    /* Process message */
/*BUG 604 changes start*/ 
    /* Get context using ue_index */
    p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            p_s1ap_del_ctx_msg_ind->ue_index);
/*BUG 604 changes stop*/ 

    if (PNULL==p_ue_context )
    {
        /* Error. Can't find UE context */
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[S1AP_DEL_CONTEXT_MSG_IND] UE context not found");

        return;
    }

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                p_ue_context->cell_index))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,"[S1AP_DEL_CONTEXT_MSG_IND]"
                "message dropped -"
                "UECC isn't initialized by CSC ");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
    }


    uecc_fsm_process_event(
            p_ue_context,
            UECC_EV_S1AP_DEL_UE_CONTEXT_IND,
            p_s1ap_del_ctx_msg_ind);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return;
}

/******************************************************************************
*   FUNCTION NAME: rrc_asn1PrtToStr_S1AP_PDU
*
 *   INPUTS       : U32              log_level
 *                  const char*      name
 *                  S1AP_PDU*        pvalue
 *   OUTPUTS      : None
*   DESCRIPTION:
*       This function prints ASN S1AP_PDUs using RRC logging mechanism.
*
*   RETURNS:
*       void
*
*****************************************************************************/
void rrc_asn1PrtToStr_S1AP_PDU(
        U32              log_level, 
        const char*      name, 
        S1AP_PDU*        pvalue)
{
    int rrc_result =0;
    /*valgrind_fix start*/
    S8* pBuff = PNULL;
    /*valgrind_fix stop*/

    /* SPR 16017 Fix Start */
    if(RRC_SUCCESS == rrc_check_logger_type(log_level))
    /* SPR 16017 Fix Stop */
    {
        if( name != NULL && pvalue !=NULL)
        {
            /*valgrind_fix start*/
            pBuff = rrc_mem_get(MAX_ASN_PRINT_BUFF_SIZE);
            /*valgrind_fix stop*/

            if(pBuff != NULL)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_result = asn1PrtToStr_S1AP_PDU(name, pvalue, (char*)pBuff, MAX_ASN_PRINT_BUFF_SIZE);  /* Converted to char* as required by ASN function */
                if(rrc_result == 0)
                {/* SPR 13700 Fix start */
                    RRC_TRACE_ASN((S32)log_level, "%s\n", pBuff);/* SPR 13700 Fix stop */
                }
                else
                {
                    RRC_TRACE(RRC_WARNING,"Buffer size for ASN needs to be increased\n");
                }
                rrc_mem_free(pBuff);
            }
        }
        else
        {
            RRC_TRACE(RRC_WARNING, "S1AP_PDU Info to be printed is missing\n");
        }
    }
    //RRC_LOG_ASN_HEX_DUMP(name, msgName, p_buff, msgLen);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_s1ap_overload_msg_ind
 *
 *   INPUTS       : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes OVERLOAD IND
 *
 *   RETURNS:        
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_s1ap_overload_msg_ind
(
 void                *p_api,             /* Input API buffer */         
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
        s1ap_overload_msg_ind_t *p_s1ap_overload_ind = PNULL;
        uecc_ue_context_t *p_uecc_ue_context = PNULL;


        /* Check for NULL */
        RRC_ASSERT(PNULL!=p_api);
        RRC_ASSERT(PNULL!=p_uecc_gb_context);
        RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_INFO, "Processing OVERLOAD INDICATION for UE");

        /* SSIT Fix */
        do
        {
                /* Precondition - p_api should point to right message */
                if (rrc_get_api_buf_size(p_api) <
                                (RRC_API_HEADER_SIZE + sizeof(s1ap_overload_msg_ind_t)))
                {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                        p_uecc_gb_context->facility_name,
                                        RRC_WARNING,
                                        "[S1AP_OVERLOAD_MSG_IND] Wrong message size - ignore");
                        break;
                }

                p_s1ap_overload_ind =
                        (s1ap_overload_msg_ind_t *)((U8*)p_api + RRC_API_HEADER_SIZE);

                /* Find the UECC Context for UE ID received from S1AP */
/*BUG 604 changes start*/ 
                p_uecc_ue_context = uecc_ue_ctx_get(
                                p_uecc_gb_context,
                                p_s1ap_overload_ind->ue_index);
/*BUG 604 changes stop*/ 

                if(PNULL != p_uecc_ue_context)
                {
                        /* Send event to specified UE */
                        uecc_fsm_process_event(
                                        p_uecc_ue_context,
                                        UECC_EV_S1AP_OVERLOAD_MSG_IND,
                                        (void *)&p_s1ap_overload_ind);
                }
                else
                {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                        p_uecc_gb_context->facility_name,
                                        RRC_WARNING,
                                        "[S1AP_OVERLOAD_MSG_IND] Wrong S1AP UE index");
                        break;
                }


                if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_uecc_ue_context->p_gb_context,
                                        p_uecc_ue_context->cell_index))
                {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                        p_uecc_gb_context->facility_name,
                                        RRC_WARNING,"[S1AP_OVERLOAD_MSG_IND]"
                                        "message dropped -"
                                        "UECC isn't initialized by CSC ");
                        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
                        return;
                }


        }while(0);

        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_location_reporting_message
 *
 *   INPUTS       : S1AP_PDU            *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  U8                  mme_id
 *                  U8                  *p_buff
 *                  U16                 buffer_length
 *                  U16                 ue_index
 *                  
 *   OUTPUTS      : None
 *   DESCRIPTION  : This function identifies which message to send based on request type 
 *
 *   RETURNS      : None
 *******************************************************************************/
void uecc_s1ap_process_location_reporting_message
(
    S1AP_PDU*           p_s1ap_pdu,
    uecc_gb_context_t*  p_uecc_gb_context,
    U8                  mme_id,
    U8                  *p_buff,    /* ASN.1 encoded message */
    /*BUG 604 changes start*/
    U16                 buffer_length,  /* encoded buf size - just for check*/
    U16                 ue_index
    /*BUG 604 changes stop*/
)
{
    uecc_ue_context_t   *p_ue_context = PNULL;
    rrc_return_et       result= RRC_FAILURE;

    rrc_s1ap_reporting_control_indication_msg_t   reporting_control_ind_msg;
    rrc_s1ap_location_report_t  report_msg;
    rrc_s1ap_failure_report_t   failure_msg;
    rrc_bool_et                 send_failure = RRC_FALSE;
    /* SPR_22097 Fix - Start */
    rrc_bool_et                 send_err_ind = RRC_FALSE;
    rrc_bool_et                 cntxts_identical = RRC_FALSE;
    uecc_ue_context_t           *p_mme_id_ue_ctxt = PNULL;
    uecc_ue_context_t           *p_enb_id_ue_ctxt = PNULL;
    s1ap_Cause                  cause;
    rrc_s1ap_error_indication_t s1ap_err_ind;
    /* SPR_22097 Fix - Stop */

    U8 p_message[sizeof(s1ap_ue_associated_sig_msg_ind_t)+
        S1AP_MAX_ASN1_BUF_LEN] = {0};

    s1ap_ue_associated_sig_msg_req_t* p_sig_msg_req = 
        (s1ap_ue_associated_sig_msg_req_t *)p_message;

    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_s1ap_pdu);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    memset_wrapper(p_sig_msg_req, RRC_NULL, sizeof(s1ap_ue_associated_sig_msg_req_t));
    memset_wrapper(&reporting_control_ind_msg, RRC_NULL,
            sizeof(rrc_s1ap_reporting_control_indication_msg_t));
    memset_wrapper(&failure_msg, RRC_NULL, sizeof(rrc_s1ap_failure_report_t));
    memset_wrapper(&report_msg, RRC_NULL, sizeof(rrc_s1ap_location_report_t));

    do
    {
        /* SPR_22097 Fix - Start */
        /* Fill Default Cause for Error Indication */
        cause.t = T_s1ap_Cause_misc;
        cause.u.protocol = s1ap_unspecified;
        /* SPR_22097 Fix - Stop */

        /* Decode message */
        if (RRC_FAILURE == uecc_s1ap_location_repoting_control_intrl_dec(
                    p_uecc_gb_context,
                    mme_id,
                    p_s1ap_pdu->u.initiatingMessage->value.u.locationReportingControl,
                    &reporting_control_ind_msg))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, "Location Reporting Control "
                    "Decoding Failure, Sending Error Indication");
            break;
        }

        //default values for cause of failure msg
        failure_msg.cause.t = T_s1ap_Cause_misc ;
        failure_msg.cause.u.misc = s1ap_unspecified;
        if (PNULL ==  reporting_control_ind_msg.p_request_type)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name, RRC_INFO,
                    "Request Type not present in Location Report Control -  "
                    "Sent Error Indication.");
            /* SPR_22097 Fix - Start */
            cause.t = T_s1ap_Cause_protocol;
            cause.u.protocol = s1ap_abstract_syntax_error_ignore_and_notify;
            send_err_ind = RRC_TRUE;
            /* SPR_22097 Fix - Stop */
            break;
        }

        /*BUG 604 changes start*/ 
        /* Get context using ue_index */
        /*p_ue_context = uecc_ue_ctx_get_by_s1ap_id(p_uecc_gb_context,
          reporting_control_ind_msg.enb_ue_s1ap_id);*/
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,ue_index);
        /*BUG 604 changes stop*/ 
        if (PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name, RRC_INFO,
                    "ue context not found, Sent Error Indication.");
            /* SPR_22097 Fix - Start */
            /* Set Error Cause */
            cause.t = T_s1ap_Cause_radioNetwork;
            cause.u.radioNetwork = s1ap_unknown_pair_ue_s1ap_id;
            send_err_ind = RRC_TRUE;
            /* SPR_22097 Fix - Stop */ 
            break;
        }
        else
        {
            if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                        p_ue_context->cell_index))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name, RRC_WARNING,
                        "Location Reporting Control UECC isn't initialized by CSC");
                /* SPR_22097 Fix - Start */
                /* Set Error Cause */
                cause.t = T_s1ap_Cause_radioNetwork;
                cause.u.radioNetwork = s1ap_cell_not_available;
                send_err_ind = RRC_TRUE;
                /* SPR_22097 Fix - Stop */
                break;
            }

            if (reporting_control_ind_msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name, RRC_WARNING,
                        "Location Reporting Control Unknown MME UE S1AP Id");
                /* SPR_22097 Fix - Start */
                /* Set Error Cause */
                cause.t = T_s1ap_Cause_radioNetwork;
                cause.u.radioNetwork = s1ap_unknown_pair_ue_s1ap_id;
                send_err_ind = RRC_TRUE;
                /* SPR_22097 Fix - Stop */
                break;
            }

            /* SPR 23404 Fix - Starts */
            /* TRACE_changes_start */
            uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, p_buff, buffer_length, "Location Reporting Control", 0);
            /* TRACE_changes_stop */
            /* SPR 23404 Fix - Ends */
            /* cr_742 UE_SRC_HO check */ 
            if ((RRC_TRUE == !(strncmp_wrapper((const S8*)p_ue_context->uecc_fsm.p_current_state->s_name,
                                (const S8*)"UECC_UE_SRC_HO_ONGOING",
                                strlen_wrapper((const Char8*)p_ue_context->uecc_fsm.p_current_state->s_name))))
                ||(RRC_TRUE == !(strncmp_wrapper((const S8*)p_ue_context->uecc_fsm.p_current_state->s_id,
                                (const S8*)"M_SRC_HO_O",
                                strlen_wrapper((const Char8*)p_ue_context->uecc_fsm.p_current_state->s_id))))
                ||(RRC_TRUE == !(strncmp_wrapper((const S8*)p_ue_context->uecc_fsm.p_current_state->s_name,
                                (const S8*)"UECC_UE_TRG_HO_ONGOING",
                                strlen_wrapper((const Char8*)p_ue_context->uecc_fsm.p_current_state->s_name))))
                ||(RRC_TRUE == !(strncmp_wrapper((const S8*)p_ue_context->uecc_fsm.p_current_state->s_id,
                                (const S8*)"M_TRG_HO_O",
                                strlen_wrapper((const Char8*)p_ue_context->uecc_fsm.p_current_state->s_id)))))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name,
                        RRC_ERROR,"Location Reporting Control Procedure Failed due to an interaction with Handover Procedure");            
                send_failure = RRC_TRUE;
                //filling failure message cause
                /* SPR 16240 START */
                if( X2_HO == p_ue_context->ho_info.s1_or_x2_handover )
                {
                    failure_msg.cause.t = T_s1ap_Cause_radioNetwork;
                    failure_msg.cause.u.radioNetwork = s1ap_x2_handover_triggered;
                }
                else if(S1_HO == p_ue_context->ho_info.s1_or_x2_handover)
                {
                    if(PNULL != p_ue_context->ho_info.p_ho_info)
                    {
                        if(HANDOVER_TYPE_INTRA_LTE_S1 == p_ue_context->ho_info.p_ho_info->ho_type)
                        {
                            failure_msg.cause.t = T_s1ap_Cause_radioNetwork;
                            failure_msg.cause.u.radioNetwork = s1ap_s1_intra_system_handover_triggered;
                        }
                        else
                        {
                            failure_msg.cause.t = T_s1ap_Cause_radioNetwork;
                            failure_msg.cause.u.radioNetwork = s1ap_s1_inter_system_handover_triggered;
                        }
                    }
                }
                else
                {
                    failure_msg.cause.t = T_s1ap_Cause_radioNetwork;
                    failure_msg.cause.u.radioNetwork = s1ap_interaction_with_other_procedure;
                }
                /* SPR 16240 END */
            }
            else
            {
                /* Store in ue context */
                p_ue_context->m.location_reporting_info_present = RRC_TRUE;
                p_ue_context->location_reporting_event_type
                    = reporting_control_ind_msg.p_request_type->eventType;
                p_ue_context->location_reporting_report_area
                    = reporting_control_ind_msg.p_request_type->reportArea;

                if((s1ap_direct == reporting_control_ind_msg.p_request_type->eventType) && 
                        (RRC_FALSE == send_failure))
                {
                    report_msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
                    report_msg.mme_ue_s1ap_id = p_ue_context->mme_ue_id;

                    asn1Init_s1ap_TAI(&report_msg.tai);
                    asn1Init_s1ap_EUTRAN_CGI(&report_msg.eutran_cgi);

                    report_msg.tai.pLMNidentity.numocts = MAX_MNC_OCTET_SIZE;
                    uecc_s1ap_generate_plmn_identity_int(
                            report_msg.tai.pLMNidentity.data,
                            &p_ue_context->plmn_identity.plmn_identity);

                    if (PNULL != p_ue_context->p_gb_context->p_p_csc_context)
                    {
                        if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                                [p_ue_context->cell_index])
                        {
                            if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                                    [p_ue_context->cell_index]->p_csc_init_setup_ind)
                            {
                                /* This needs to be changeded when multi cells are supported */
                                l3_memcpy_wrapper(report_msg.tai.tAC.data,
                                        p_ue_context->p_gb_context->p_p_csc_context[
                                        p_ue_context->cell_index]->p_csc_init_setup_ind->
                                        sib_type_1_Info.
                                        cell_access_related_info.tac,
                                        TAC_OCTET_SIZE);
                                report_msg.tai.tAC.numocts = TAC_OCTET_SIZE;

                                /* EUTRAN_CGI */
                                /* eutran_cgi.pLMNidentity */
                                report_msg.eutran_cgi.pLMNidentity.numocts =
                                    MAX_MNC_OCTET_SIZE; 
                                /* tai.pLMNidentity should be the same as eutran_cgi.pLMNidentity*/
                                l3_memcpy_wrapper(report_msg.eutran_cgi.pLMNidentity.data,
                                        report_msg.tai.pLMNidentity.data, MAX_MNC_OCTET_SIZE);

                                /* eutran_cgi.cell_ID */
                                l3_memcpy_wrapper(report_msg.eutran_cgi.cell_ID.data,
                                        p_ue_context->p_gb_context->p_p_csc_context[
                                        p_ue_context->cell_index]->p_csc_init_setup_ind->
                                        sib_type_1_Info.
                                        cell_access_related_info.cell_Id,
                                        /* SPR 11322 Fix Start */
                                        sizeof(report_msg.eutran_cgi.cell_ID.data));
                                /* SPR 11322 Fix Stop */
                            }
                        }
                    }
                    report_msg.eutran_cgi.cell_ID.numbits = RRC_CELL_IDENTITY_BITS;

                    /* request type is filled as has been sent in control message */
                    l3_memcpy_wrapper(&report_msg.request_type, reporting_control_ind_msg.p_request_type,
                            sizeof(s1ap_RequestType));

                    result = uecc_s1ap_location_report_intrl_enc(
                            p_uecc_gb_context,
                            &report_msg,
                            &p_sig_msg_req->message_buff_p[0],
                            &p_sig_msg_req->message_buff_size);

                    if( RRC_SUCCESS != result)
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index, 
                                p_uecc_gb_context->facility_name, RRC_ERROR,
                                "location report encoding failure.");
                        break;
                    }
                    p_sig_msg_req->procedure_code = ASN1V_s1ap_id_LocationReport;
                    /* SPR 23404 Fix - Starts */
                    /* TRACE_changes_start */
                    uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context,
                            &p_sig_msg_req->message_buff_p[0],
                            p_sig_msg_req->message_buff_size,
                            "Location Report", 1);
                    /* TRACE_changes_stop */
                    /* SPR 23404 Fix - Ends */
                }
                else if (s1ap_direct != reporting_control_ind_msg.p_request_type->eventType) 
                {
                    /*SPR_6393_FIX Start*/
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name,
                            RRC_INFO, "[LOCATION REPORTING CONTROL]: " 
                            "Event Type is [%d]", 
                            reporting_control_ind_msg.p_request_type->eventType); 
                    /*SPR_6393_FIX Stop*/
                }
            }
        }
    }while(0);

    /* SPR_22097 Fix - Start */
    /* If Sent Error Indication Flag set, then Send Error Indication */
    if(RRC_TRUE == send_err_ind)
    {
        /* Get UE Contexts as per received eNB and MME S1AP IDs */
        p_enb_id_ue_ctxt = uecc_ue_ctx_get_by_s1ap_id(p_uecc_gb_context,
                reporting_control_ind_msg.enb_ue_s1ap_id);
        p_mme_id_ue_ctxt = uecc_ue_ctx_get_by_mme_s1ap_id(p_uecc_gb_context,
                reporting_control_ind_msg.mme_ue_s1ap_id);

        /* Check if UE Contexts are identical */
        if((PNULL != p_enb_id_ue_ctxt) &&
                (PNULL != p_mme_id_ue_ctxt) && 
                (p_mme_id_ue_ctxt->ue_index == p_enb_id_ue_ctxt->ue_index))
        {
            cntxts_identical = RRC_TRUE;
        }

        /* If Ue Context Null, then get UE Context from received MME S1AP ID */
        if (PNULL == p_ue_context)
        {
            p_ue_context = p_mme_id_ue_ctxt;
        }

        /* Send Error Indication to MME */
        if (PNULL != p_ue_context)
        {
            /*Coverity 115990 Fix*/
            if (RRC_SUCCESS != uecc_s1ap_build_and_send_error_indication(mme_id,
                        reporting_control_ind_msg.mme_ue_s1ap_id, RRC_TRUE,
                        reporting_control_ind_msg.enb_ue_s1ap_id, RRC_TRUE,
                        PNULL, RRC_FALSE, &cause, p_ue_context))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name, RRC_WARNING,
                        "Failure - Build & Send Error Indication Message");
            }

            /* Push ERROR Indication Events to Release UEs Context */
            if(s1ap_unknown_pair_ue_s1ap_id == cause.u.radioNetwork)
            {
                /* Fill rrc_s1ap_error_ind message */
                memset_wrapper(&s1ap_err_ind, RRC_NULL, sizeof(rrc_s1ap_error_indication_t));

                s1ap_err_ind.mme_ue_s1ap_id =
                    reporting_control_ind_msg.mme_ue_s1ap_id;
                s1ap_err_ind.enb_ue_s1ap_id =
                    reporting_control_ind_msg.enb_ue_s1ap_id;
                s1ap_err_ind.cause = cause;
                s1ap_err_ind.bitmask =
                    (RRC_S1AP_ERROR_INDICATION_MME_UE_S1AP_ID_PRESENT |
                     RRC_S1AP_ERROR_INDICATION_ENB_UE_S1AP_ID_PRESENT |
                     RRC_S1AP_ERROR_INDICATION_CAUSE_PRESENT);

                if (PNULL != p_enb_id_ue_ctxt)
                {
                    /* Set Flag to block UE Context Release Complete */
                    p_enb_id_ue_ctxt->share_data.uecc_rcr_data.
                        ue_context_rel_comp_not_req_flag = RRC_TRUE;

                    /* Push ERROR INDICATION Event */
                    uecc_fsm_process_event(p_enb_id_ue_ctxt,
                            UECC_EV_UE_ERROR_INDICATION,
                            &s1ap_err_ind);
                    /*Coverity 115522 Fix*/
                    /* Call Event to Clear S1AP Context */
                    if (RRC_SUCCESS != uecc_s1ap_build_and_send_ue_release_msg_req(
                                p_enb_id_ue_ctxt->s1ap_ue_id,
                                RRC_FALSE,
                                p_enb_id_ue_ctxt))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name, RRC_WARNING,
                                "Failure - Build & Send S1AP UE Release Request Message for UE=%u",
                                p_enb_id_ue_ctxt->ue_index);
                    }

                }
                if ((PNULL != p_mme_id_ue_ctxt) && (RRC_FALSE == cntxts_identical))
                {
                    /* Set Flag to block UE Context Release Complete */
                    p_mme_id_ue_ctxt->share_data.uecc_rcr_data.
                        ue_context_rel_comp_not_req_flag = RRC_TRUE;

                    /* Push ERROR INDICATION Event */
                    uecc_fsm_process_event(p_mme_id_ue_ctxt,
                            UECC_EV_UE_ERROR_INDICATION,
                            &s1ap_err_ind);

                    /*Coverity 115522 Fix*/
                    /* Call Event to Clear S1AP Context */
                    if(RRC_SUCCESS != uecc_s1ap_build_and_send_ue_release_msg_req(
                                p_mme_id_ue_ctxt->s1ap_ue_id,
                                RRC_FALSE,
                                p_mme_id_ue_ctxt))
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name, RRC_WARNING,
                                "Failure - Build & Send S1AP UE Release Request Message for UE=%u",
                                p_mme_id_ue_ctxt->ue_index);
                    }
                }
            }
        }
        else
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name, RRC_FATAL,
                    "Location Reporting Control Procedure Failed "
                    "Unable to Find UE Context - Drop Message ");
        }
        RRC_UT_TRACE_EXIT();
        return;
    }
    /* SPR_22097 Fix - Stop */

   if (RRC_TRUE == send_failure)
   {
       failure_msg.enb_ue_s1ap_id = reporting_control_ind_msg.enb_ue_s1ap_id;
       failure_msg.mme_ue_s1ap_id = reporting_control_ind_msg.mme_ue_s1ap_id;
       result = uecc_s1ap_ue_associated_location_report_failure_intrl_enc(
               p_uecc_gb_context,
               &failure_msg,
               &p_sig_msg_req->message_buff_p[0],
               &p_sig_msg_req->message_buff_size);

       if(RRC_SUCCESS != result)
       {
           RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->
                   facility_name, RRC_ERROR,
                   "location report failure indication encoding failure.");
           if (PNULL != reporting_control_ind_msg.p_request_type)
           {
               rrc_mem_free(reporting_control_ind_msg.p_request_type);
           }
           RRC_UT_TRACE_EXIT();
           return;
       }

       p_sig_msg_req->procedure_code = ASN1V_s1ap_id_LocationReportingFailureIndication;
       /* SPR 23404 Fix - Starts */
       /* TRACE_changes_start */
       if(PNULL != p_ue_context)
       {
           uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context,
                   &p_sig_msg_req->message_buff_p[0], p_sig_msg_req->message_buff_size,
                   "Location Report Failure Indication", 1);
       }
       /* TRACE_changes_stop */
       /* SPR 23404 Fix - Ends */
   }

   p_sig_msg_req->enb_ue_s1ap_id = reporting_control_ind_msg.enb_ue_s1ap_id ;
   p_sig_msg_req->mme_id = mme_id;
   if (PNULL != p_ue_context)
   {
       p_sig_msg_req->cell_index = p_ue_context->cell_index;
       /*BUG 604 changes start*/
       /*Fill ue_index*/
       p_sig_msg_req->ue_index = p_ue_context->ue_index;
   }
   else
   {
       /*Fill ue_index*/
       p_sig_msg_req->ue_index = RRC_INVALID_UE_INDEX;
   }
   /*BUG 604 changes stop*/

   if(RRC_SUCCESS == result)
   {
       result = uecc_rrc_send_internal_msg(
               RRC_S1AP_MODULE_ID,
               S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
               (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                   p_sig_msg_req->message_buff_size),
               p_message);

       if(RRC_FAILURE == result)
       {
           RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                   p_uecc_gb_context->facility_name, RRC_ERROR,
                   "failure sending message.");
           if (PNULL != reporting_control_ind_msg.p_request_type)
           {
               rrc_mem_free(reporting_control_ind_msg.p_request_type);
           }
           RRC_UT_TRACE_EXIT();
           return;
       }
   }

   if (PNULL != reporting_control_ind_msg.p_request_type)
   {
       rrc_mem_free(reporting_control_ind_msg.p_request_type);
   }

   RRC_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_error_indication
 *
 *   INPUTS       : S1AP_PDU            *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  U8                  *buffer
 *                  U16                 buffer_length
 *                  U16                 ue_index
 *
 *   OUTPUTS      : None
 *
 *   DESCRIPTION  : This function processes s1ap_UEContextReleaseCommand
 *
 *   RETURNS      : None
 ******************************************************************************/
void uecc_s1ap_process_error_indication
(
 S1AP_PDU            *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context,  /* UECC global context */
 U8                  *buffer,
/*BUG 604 changes start*/ 
 U32                 buffer_length,
 U16                 ue_index
/*BUG 604 changes stop*/ 
 )
{
        uecc_ue_context_t               *p_ue_context = PNULL;
        rrc_return_et result = RRC_SUCCESS;
        rrc_s1ap_error_indication_t     msg;
        /* SPR 16750 Fix Start */
        rrc_bool_et                     is_processing_reqd = RRC_FALSE;
        uecc_ue_context_t               *p_second_ue_context = PNULL;
        rrc_bool_et                     unknown_apid_cause_prsnt = RRC_FALSE;
        /* SPR 16750 Fix Stop */

        RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_INFO, "Recived Error Indication");

        RRC_ASSERT(PNULL!=p_s1ap_pdu);
        RRC_ASSERT(PNULL!=p_s1ap_pdu->u.initiatingMessage);


        do
        {
                memset_wrapper(&msg,0,sizeof(rrc_s1ap_error_indication_t));
                if (PNULL==p_s1ap_pdu->u.initiatingMessage->value.u.errorIndication)
                {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                        p_uecc_gb_context->facility_name,
                                        RRC_WARNING,
                                        "[s1ap_ErrorIndication] errorIndication field is PNULL");
                        /* Drop message */
                        break;
                }

                /* Decode message */
                result = rrc_uecc_error_indication_intrl_dec(
                                p_uecc_gb_context,
                                p_s1ap_pdu->u.initiatingMessage->value.u.errorIndication,
                                &msg);

                if (RRC_SUCCESS != result)
                {
                        /* Message parsing error */
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                        p_uecc_gb_context->facility_name,
                                        RRC_WARNING,
                                        "[s1ap_ErrorIndication] Parsing error");
                        /* Drop message */
                        break;
                }

                switch(msg.criticality_diagnostics.procedureCode)
                {
                        case ASN1V_s1ap_id_Reset:
                        case ASN1V_s1ap_id_Paging:
                        case ASN1V_s1ap_id_uplinkNASTransport:
                        case ASN1V_s1ap_id_MMEConfigurationUpdate:
                        case ASN1V_s1ap_id_MMEDirectInformationTransfer:
                        case ASN1V_s1ap_id_MMEConfigurationTransfer:
                        case ASN1V_s1ap_id_ErrorIndication:
                        case ASN1V_s1ap_id_S1Setup:
                        case ASN1V_s1ap_id_ENBConfigurationUpdate:
                                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                                p_uecc_gb_context->facility_name,
                                                RRC_INFO, "Error Indication Received",
                                                "Procedure Code:%d", 
                                                msg.criticality_diagnostics.procedureCode);
                                break;
                        default:
                                is_processing_reqd = RRC_TRUE;
                                break;
                }
                /* SPR 16750 Fix Start */
                if (( (msg.bitmask & RRC_S1AP_ERROR_INDICATION_ENB_UE_S1AP_ID_PRESENT) ||
                       (msg.bitmask & RRC_S1AP_ERROR_INDICATION_MME_UE_S1AP_ID_PRESENT) ) &&
                         (msg.bitmask & RRC_S1AP_ERROR_INDICATION_CAUSE_PRESENT) &&
                           (msg.cause.t == T_s1ap_Cause_radioNetwork) &&
                            ((msg.cause.u.radioNetwork == s1ap_unknown_mme_ue_s1ap_id) ||
                             (msg.cause.u.radioNetwork == s1ap_unknown_enb_ue_s1ap_id) ||
                             (msg.cause.u.radioNetwork == s1ap_unknown_pair_ue_s1ap_id)))    
                {
                    is_processing_reqd = RRC_TRUE;
                    unknown_apid_cause_prsnt = RRC_TRUE;
                }

                if (is_processing_reqd == RRC_TRUE)
                {
                        /* Log the message */
                        log_uecc_error_indication_message(p_uecc_gb_context,&msg);

                        /* Process message */
                        if (msg.bitmask & RRC_S1AP_ERROR_INDICATION_ENB_UE_S1AP_ID_PRESENT)
                        {
                                /* Get context using S1AP id */
                            /*BUG 604 changes start*/ 
                            /* SPR 19338 Fix Start */
                            /* p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,ue_index); */
                            p_ue_context = uecc_ue_ctx_get_by_s1ap_id(p_uecc_gb_context,
                                                msg.enb_ue_s1ap_id);
                            /* SPR 19338 Fix Stop */
                            /*BUG 604 changes stop*/ 
                            if ( ( (PNULL != p_ue_context) && (p_ue_context->m.mme_ue_id_present) &&
                                   (msg.bitmask & RRC_S1AP_ERROR_INDICATION_MME_UE_S1AP_ID_PRESENT) &&
                                     (msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id) ) ||
                                ( (PNULL == p_ue_context) && 
                                  (msg.bitmask & RRC_S1AP_ERROR_INDICATION_MME_UE_S1AP_ID_PRESENT) ) )
                            {
                                p_second_ue_context = uecc_ue_ctx_get_by_mme_s1ap_id(
                                                p_uecc_gb_context,
                                                msg.mme_ue_s1ap_id);
                                if (PNULL != p_ue_context)
                                {
                                    unknown_apid_cause_prsnt = RRC_TRUE;
                                }
                                else
                                {
                                    p_ue_context = p_second_ue_context;
                                }
                            }
                            else if ( (PNULL != p_ue_context) &&
                                       (RRC_NULL == p_ue_context->m.mme_ue_id_present) )
                            {
                               /* store mme_ue_s1ap_id in UE context */
                               p_ue_context->m.mme_ue_id_present = 1;
                               p_ue_context->mme_ue_id = msg.mme_ue_s1ap_id;
                            }
                            if (RRC_TRUE == unknown_apid_cause_prsnt)
                            {
                                if (PNULL != p_ue_context)
                                {
                                    p_ue_context->share_data.uecc_rcr_data.s1_error_ind_recv =
                                                                   RRC_TRUE;
                                    uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, 
                                          buffer, buffer_length, "Error Indication", 0);
                                    uecc_fsm_process_event(
                                        p_ue_context,
                                        UECC_EV_UE_ERROR_INDICATION,
                                        &msg);
                                }
                                if (PNULL != p_second_ue_context)
                                {
                                    p_second_ue_context->share_data.uecc_rcr_data.s1_error_ind_recv =
                                                                   RRC_TRUE;
                                    uecc_s1ap_ue_assoc_msg_max_trace_handler(p_second_ue_context, 
                                          buffer, buffer_length, "Error Indication", 0);
                                    uecc_fsm_process_event(
                                        p_second_ue_context,
                                        UECC_EV_UE_ERROR_INDICATION,
                                        &msg);
                                }
                                break;
                            }
                        }
                        else if (msg.bitmask & RRC_S1AP_ERROR_INDICATION_MME_UE_S1AP_ID_PRESENT)
                        {
                                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                                p_uecc_gb_context->facility_name,
                                                RRC_INFO,
                                                "[s1ap_ErrorIndication] Only MME UE S1AP ID present\n");

                                p_ue_context = uecc_ue_ctx_get_by_mme_s1ap_id(
                                                p_uecc_gb_context,
                                                msg.mme_ue_s1ap_id);
                                if (RRC_TRUE == unknown_apid_cause_prsnt)
                                {
                                    if (PNULL != p_ue_context)
                                    {
                                        p_ue_context->share_data.uecc_rcr_data.s1_error_ind_recv =
                                                                   RRC_TRUE;
                                        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, 
                                                buffer, buffer_length, "Error Indication", 0);
                                        uecc_fsm_process_event(
                                                p_ue_context,
                                                UECC_EV_UE_ERROR_INDICATION,
                                                &msg);
                                    }
                                    break;
                                }

                        }
                        else
                        {
                                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                                p_uecc_gb_context->facility_name,
                                                RRC_DETAILED,
                                                "[s1ap_ErrorIndication]",
                                                " Neither ENB_UE_S1AP_ID nor MME_UE_S1AP_ID present\n");
                                break;
                        }

                        if (PNULL==p_ue_context )
                        {
                                /* Error. Can't find UE context */
                                /* Drop message */
                                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                                p_uecc_gb_context->facility_name,
                                                RRC_DETAILED,
                                                "[s1ap_ErrorIndication] UE context not found");
                                break;
                        }
                /* SPR 16750 Fix Stop */
                        /* TRACE_changes_start */
                        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, buffer, buffer_length, "Error Indication", 0);
                        /* TRACE_changes_start */

                        if (msg.bitmask & 
                                        RRC_S1AP_ERROR_INDICATION_CRITICALITY_DIAGNOSTICS_PRESENT)
                        {
                                /* If Procedure Code is ASN1V_s1ap_id_HandoverPreparation,
                                 * Error Indication is received for Handover Required 
                                 * If Procedure Code is ASN1V_s1ap_id_HandoverResourceAllocation,
                                 * Error Indication is received for HANDOVER REQUEST ACKNOWLEDGE 
                                 * */
                                if ((msg.criticality_diagnostics.procedureCode == 
                                                        ASN1V_s1ap_id_HandoverPreparation) ||
                                                (msg.criticality_diagnostics.procedureCode == 
                                                 ASN1V_s1ap_id_E_RABReleaseIndication) ||
                                                (msg.criticality_diagnostics.procedureCode == 
                                                 ASN1V_s1ap_id_HandoverResourceAllocation) ||
                                                (msg.criticality_diagnostics.procedureCode == 
                                                 ASN1V_s1ap_id_UEContextReleaseRequest))
                                {

                                        uecc_fsm_process_event(
                                                        p_ue_context,
                                                        UECC_EV_UE_ERROR_INDICATION,
                                                        &msg);
                                }
                                else
                                {
                                        /* Do Nothing*/
                                }
                        }
                        /*SPR 13560 Fix Start*/
                        else
                        {
                                
                                        uecc_fsm_process_event(
                                                        p_ue_context,
                                                        UECC_EV_SIAP_ERROR_INDICATION,
                                                        &msg);
                        }
                        /* SPR 13560 Fix Stop*/
                }
        } while (0);

        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_generate_eutran_traceid
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function generate eutran_traceid
 *       
 *
 *   RETURNS:
 *          NONE
 *
 *******************************************************************************/
void  uecc_generate_eutran_traceid(
                uecc_ue_context_t              *p_ue_context
                )
{
    //Trace Change Start
    /* Assign trace id at lower three bytes */
    /*SPR 15896 Fix Start*/
    l3_memcpy_wrapper(&p_ue_context->p_ue_cell_trace_activation_info->trace_id_info.
            cell_eutran_trace_id.trace_reference,
            &p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->traceRef,
            (sizeof(p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->cell_index]->traceRef)));
    /*SPR 15896 Fix Stop*/

    /* Assign trace recording session reference at right most 2 bytes */
    p_ue_context->p_gb_context->traceRecordSessionRef++;
    /*SPR 15875 Fix Start*/
    /*SPR 15896 Fix Start*/
    p_ue_context->p_ue_cell_trace_activation_info->trace_id_info.
        cell_eutran_trace_id.trace_recording_session_reference[0] =(U8)(p_ue_context->p_gb_context->traceRecordSessionRef >> 8);
    p_ue_context->p_ue_cell_trace_activation_info->trace_id_info.
        cell_eutran_trace_id.trace_recording_session_reference[1] = (U8)(p_ue_context->p_gb_context->traceRecordSessionRef);
    /*SPR 15896 Fix Stop*/
    /*SPR 15875 Fix Stop*/
    //Trace Change End


}

/******************************************************************************
 *   FUNCTION NAME: uecc_generate_trace_file_name
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  rrc_trace_initiator_et trace_Initiator
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function generate trace file name
 *       
 *
 *   RETURNS:
 *          NONE
 *
 *******************************************************************************/
void uecc_generate_trace_file_name(uecc_ue_context_t  *p_ue_context, rrc_trace_initiator_et trace_Initiator )
{
    /*Buffer name */
    U8 xml_header[400]="<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n \
                           <traceCollecFile xmlns=\"http://www.3gpp.org/ftp/specs/archive/32_series/32.423#traceData\" \n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n  xsi:schemaLocation=\"http://www.3gpp.org/ftp/specs/archive/32_series/32.423#traceData\n  http://www.3gpp.org/ftp/specs/archive/32_series/32.423#traceData\"> " ;
    /*SPR 15875 Fix Start*/
    U8 file_header[70] = "\n <fileHeader fileFormatVersion=\"32.423 V10.5\" vendorName=";
    /*SPR 15875 Fix Stop*/
    U8 vendor[32]; /*  "\"Aricent\"\>" ; */
    U8 vendor1[32];  /*  =  "\"Aricent\"\," ; */
    U8 fsend [100] = " \" elementType=\"ENODEB\"/> " ;
    U8 filesender[500] = "\n  <fileSender elementDn=\"";
    U8 traceCollec[30] = "\n <traceCollec beginTime= ";
    U8 filehdrend[25] = "/></fileHeader>" ;
    /*SPR 15875 Fix Start*/
    U8 tracesession[300]="\n<traceRecSession " ;
    U8 traceResessionref[50] = "traceRecSessionRef=\"";
    /*SPR 15875 Fix Stop*/
    U8 stime[30] = "\" stime=" ;
    /*SPR 15896 Fix Start*/
    U8 depth_type = RRC_NULL;
    /*SPR 15896 Fix Stop*/

    U8 Startdate[MAX_DATE_LEN] = {RRC_NULL};
    /*SPR 15875 Fix Start*/
    U8 bytes_written = RRC_NULL;
    U8 i = RRC_NULL;
    int var1 = RRC_NULL;
    /*SPR 15875 Fix Stop*/
            /*klockwork Fix*/
    U8 SenderName[8] = {RRC_NULL};
    U8 FileName[MAX_FILE_LEN]={RRC_NULL} ;
            /*klockwork Fix*/
    time_t rawtime ;
    struct tm * timeinfo = PNULL;
    U8 timebuffer[MAX_NAME_LEN] = {RRC_NULL};
    memset_wrapper(&timebuffer,0,sizeof(MAX_NAME_LEN));
    memset_wrapper(&Startdate,0,sizeof(MAX_DATE_LEN));
    if ( HOME_ENB == p_ue_context->p_gb_context->enbType ) 
    {
        /*SPR 15875 Fix Start*/
        snprintf_wrapper((Char8 *)SenderName,8,(const Char8*)"%02X%02X%02X%X",p_ue_context->p_gb_context->home_enb_id[0] ,
        p_ue_context->p_gb_context->home_enb_id[1] , p_ue_context->p_gb_context->home_enb_id[2] ,
        (p_ue_context->p_gb_context->home_enb_id[3] >> 4));
        /*SPR 15875 Fix Stop*/
    }
    else if ( MACRO_ENB == p_ue_context->p_gb_context->enbType )
    {
        /*SPR 15875 Fix Start*/
        snprintf_wrapper((Char8 *)SenderName,6,(const Char8*)"%02X%02X%X",p_ue_context->p_gb_context->macro_enb_id[0] , 
                p_ue_context->p_gb_context->macro_enb_id[1] , (p_ue_context->p_gb_context->macro_enb_id[2] >> 4));
        /*SPR 15875 Fix Stop*/
    }

    
    time_wrapper(&rawtime);
    timeinfo = localtime_wrapper(&rawtime);
    /*SPR 15896 Fix Start*/
    if (trace_Initiator == TRACE_OAM_INITIATED)
    {
/* SPR 19288 change start */

        clock_gettime_wrapper(CLOCK_MONOTONIC_RAW,&(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
/* SPR 19288 change end */
    }
    if (trace_Initiator != TRACE_OAM_INITIATED)
    {
/* SPR 19288 change start */

        clock_gettime_wrapper(CLOCK_MONOTONIC_RAW,&(p_ue_context->p_ue_trace_activation_info->rawtime));
/* SPR 19288 change end */
    }
    /*SPR 15896 Fix Stop*/

    if (PNULL != timeinfo)
    {
    strftime_wrapper ((S8 *)Startdate,80,(const S8 *)"%Y%m%d.%H%M%z",timeinfo);
    }
    /*Coverity Fix 20190 Start*/

    snprintf_wrapper((Char8 *)vendor, 32,(const Char8*) "\"%s\">  ",p_ue_context->p_gb_context->vendor_name);
    snprintf_wrapper((Char8 *)vendor1, 32,(const Char8*) "%s,",p_ue_context->p_gb_context->vendor_name);

    l3_strncat_wrapper((S8*)FileName,(const S8*)"A",1);
    l3_strncat_wrapper((S8*)FileName,(const S8*)Startdate, strlen_wrapper((const Char8*)Startdate));
    l3_strncat_wrapper((S8*)FileName,(const S8*) "-", 1);
    l3_strncat_wrapper((S8*)FileName,(const S8*)"ENodeB",6);
    l3_strncat_wrapper((S8*)FileName,(const S8*) ".",1);
    l3_strncat_wrapper((S8*)FileName,(const S8*) SenderName, strlen_wrapper((const Char8*)SenderName));
    l3_strncat_wrapper((S8*)FileName,(const S8*) ".", 1);
    
    /*klockwork Fix*/
    U8 TraceReference[13] = {RRC_NULL};
    U8 TraceRecordingSessionRef[5] = {RRC_NULL};
    /*klockwork Fix*/
    U8 Temp[4] ;
    if (trace_Initiator == TRACE_OAM_INITIATED)
    {
        /*SPR 15875 Fix Start*/
        /*Code removed*/
        /*SPR 15875 Fix Stop*/
        for(i=0 ; i<6 ; i++){
        /*SPR 15896 Fix Start*/
            snprintf_wrapper((Char8 *)Temp,4,(const Char8*)"%02X",p_ue_context->p_ue_cell_trace_activation_info->trace_id_info.cell_eutran_trace_id.trace_reference[i]);
        /*SPR 15896 Fix Stop*/
        /*coverity_Parse warning_fix_start*/    
        l3_strncat_wrapper((S8*)TraceReference,(const S8*) Temp, strlen_wrapper((const Char8*)Temp));
        }
        /*SPR 15875 Fix Start*/
        /*Checking for Filler digit*/   
        /*SPR 15896 Fix Start*/
        if(RRC_NULL != p_ue_context->p_ue_cell_trace_activation_info->trace_id_info.cell_eutran_trace_id.trace_recording_session_reference[0])
        {
            snprintf_wrapper((Char8 *)Temp, 4,(const Char8*)"%X",p_ue_context->p_ue_cell_trace_activation_info->trace_id_info.
                            cell_eutran_trace_id.trace_recording_session_reference[0]);
            /*SPR 15896 Fix Stop*/
            l3_strncat_wrapper((S8*)TraceRecordingSessionRef,(const S8*) Temp, strlen_wrapper((const Char8*)Temp));
            /*SPR 15896 Fix Start*/
            snprintf_wrapper((Char8 *)Temp, 4,(const Char8*)"%02X",p_ue_context->p_ue_cell_trace_activation_info->trace_id_info.
                            cell_eutran_trace_id.trace_recording_session_reference[1]);
            /*SPR 15896 Fix Stop*/
            l3_strncat_wrapper((S8*)TraceRecordingSessionRef,(const S8*) Temp, strlen_wrapper((const Char8*)Temp));
        }
        else
        {
            /*SPR 15896 Fix Start*/
            snprintf_wrapper((Char8 *)Temp, 4,(const Char8*)"%X",p_ue_context->p_ue_cell_trace_activation_info->trace_id_info.
                            cell_eutran_trace_id.trace_recording_session_reference[1]);
            /*SPR 15896 Fix Stop*/
            l3_strncat_wrapper((S8*)TraceRecordingSessionRef,(const S8*) Temp, strlen_wrapper((const Char8*)Temp));
        }
        /*SPR 15875 Fix Stop*/
    }
    else
    {
         RRC_TRACE(RRC_INFO, "eutran trace_reference: %d\n",p_ue_context->p_ue_trace_activation_info->trace_id_info.eutran_trace_id.data[7]);
        /*SPR 15875 Fix Start*/
        /*Code removed*/
        /*SPR 15875 Fix Stop*/
        for(i=0 ; i<6 ; i++){
            snprintf_wrapper((Char8 *)Temp,4,(const Char8*)"%02X",p_ue_context->p_ue_trace_activation_info->trace_id_info.eutran_trace_id.data[i]);
            if(i<6)
                l3_strncat_wrapper((S8*)TraceReference,(const S8*) Temp, strlen_wrapper((const Char8*)Temp));
        }
        /*SPR 15875 Fix Start*/    
        if(RRC_NULL != p_ue_context->p_ue_trace_activation_info->trace_id_info.eutran_trace_id.data[6])
        {
            snprintf_wrapper((Char8 *)Temp, 4,(const Char8*)"%X",p_ue_context->
                p_ue_trace_activation_info->trace_id_info.eutran_trace_id.data[6]);
            l3_strncat_wrapper((S8*)TraceRecordingSessionRef,
                (const S8*) Temp, strlen_wrapper((const Char8*)Temp));
            snprintf_wrapper((Char8 *)Temp, 4,(const Char8*)"%02X",p_ue_context->
                p_ue_trace_activation_info->trace_id_info.eutran_trace_id.data[7]);
            l3_strncat_wrapper((S8*)TraceRecordingSessionRef,
                (const S8*) Temp, strlen_wrapper((const Char8*)Temp));
        }
        else
        {
            snprintf_wrapper((Char8 *)Temp, 4,(const Char8*)"%X",p_ue_context->
                p_ue_trace_activation_info->trace_id_info.eutran_trace_id.data[7]);
            l3_strncat_wrapper((S8*)TraceRecordingSessionRef,
                (const S8*) Temp, strlen_wrapper((const Char8*)Temp));
        }
        /*SPR 15875 Fix Stop*/
    }
    l3_strncat_wrapper((S8*)FileName,(const S8*)TraceReference,strlen_wrapper((const Char8*)TraceReference));
    l3_strncat_wrapper((S8*)FileName,(const S8*) ".", 1);
    l3_strncat_wrapper((S8*)FileName,(const S8*)TraceRecordingSessionRef, strlen_wrapper((const Char8*)TraceRecordingSessionRef));
    l3_strncat_wrapper((S8*)FileName,(const S8*) ".xml", 4);

    /*SPR 15896 Fix Start*/
    if( TRACE_OAM_INITIATED == trace_Initiator)
    {
       depth_type = GEN_CELL;
       l3_strncpy_wrapper((S8 *)p_ue_context->p_ue_cell_trace_activation_info->trace_file, (const S8 *)FileName,
               MAX_FILE_NAME_SIZE);
       if (p_ue_context->p_ue_cell_trace_activation_info->fp == PNULL)
       {
           p_ue_context->p_ue_cell_trace_activation_info->fp=fopen_wrapper((const S8*)FileName,(const S8*)"w");

           if (p_ue_context->p_ue_cell_trace_activation_info->fp == NULL)
           {
              p_ue_context->m.traceActivated &= (0xFF^RRC_TRACE_ACTIVATION_CELL_INITIATE);
              RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                      (p_ue_context->p_gb_context)->facility_name,
                       RRC_ERROR,"Tracing File could'nt be opened ");
           }
       }
    }
    else
    {
       depth_type = GEN_MME;
    l3_strncpy_wrapper((S8 *)p_ue_context->p_ue_trace_activation_info->trace_file, (const S8 *)FileName,
            MAX_FILE_NAME_SIZE);
       if (p_ue_context->p_ue_trace_activation_info->fp == PNULL)
    {
           p_ue_context->p_ue_trace_activation_info->fp=fopen_wrapper((const S8*)FileName,(const S8*)"w");

           if (p_ue_context->p_ue_trace_activation_info->fp == NULL)
        {
              p_ue_context->m.traceActivated &= (0xFF^RRC_TRACE_ACTIVATION_MME_INITIATE);
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Tracing File could'nt be opened ");
        }
    }
   }


    P_RRC_TRACE(p_ue_context, set_all_trace_bitmask (),depth_type,xml_header);
    /*SPR 15896 Fix Stop*/
    /*Coverity Fix 20190 Start*/
    l3_strncat_wrapper((S8*)file_header, (const S8 *)vendor, (sizeof(vendor)/sizeof(vendor[0])));
    l3_strncat_wrapper((S8*)filesender, (const S8 *)(p_ue_context->p_gb_context->enbName), strlen_wrapper((const Char8 *)(p_ue_context->p_gb_context->enbName)));
    l3_strncat_wrapper((S8*)filesender, (const S8 *)fsend, (sizeof(fsend)/sizeof(fsend[0])));

    time_wrapper( &rawtime );
    timeinfo = localtime_wrapper( &rawtime );
    if (PNULL != timeinfo)
    {
        /*SPR 15875 Fix Start*/
        /*Splitting timebuffer into 2 temporary buffers*/
        bytes_written = strftime_wrapper ((S8 *)timebuffer,80,(const S8 *)"\"%Y-%m-%dT%H:%M:%S%z\"",timeinfo);
        for (var1 = bytes_written-1 ; var1 >= (bytes_written-3) ; var1--)
        {
            timebuffer[var1+1]= timebuffer[var1];   
        }
        timebuffer[bytes_written-3]=':';
        /*SPR 15875 Fix Stop*/
    }
    puts_wrapper ((const S8 *)timebuffer);
    l3_strncat_wrapper((S8*)filesender, (const S8 *)traceCollec, (sizeof(traceCollec)/sizeof(traceCollec[0])));
    /*SPR 15875 Fix Start*/
    l3_strncat_wrapper((S8*)filesender, (const S8 *)timebuffer, (sizeof(timebuffer)/sizeof(timebuffer[0])));
    /*SPR 15875 Fix Stop*/
    l3_strncat_wrapper((S8*)filesender, (const S8 *)filehdrend, (sizeof(filehdrend)/sizeof(filehdrend[0])));
    /*SPR 15896 Fix Start*/
    P_RRC_TRACE(p_ue_context, set_all_trace_bitmask (),depth_type,file_header);
    P_RRC_TRACE(p_ue_context, set_all_trace_bitmask (),depth_type,filesender);
    /*SPR 15896 Fix Stop*/
    /*SPR 15875 Fix Start*/
    /*Code Removed*/
    /*SPR 15875 Fix Stop*/
    l3_strncat_wrapper((S8*)tracesession, (const S8 *)traceResessionref,(sizeof(traceResessionref)/sizeof(traceResessionref[0])));
    l3_strncat_wrapper((S8*)tracesession, (const S8 *)TraceRecordingSessionRef,(sizeof(TraceRecordingSessionRef)/sizeof(TraceRecordingSessionRef[0])));
    l3_strncat_wrapper((S8*)tracesession, (const S8 *)stime, (sizeof(stime)/sizeof(stime[0])));
    /*SPR 15875 Fix Start*/
    l3_strncat_wrapper((S8*)tracesession, (const S8 *)timebuffer, (sizeof(timebuffer)/sizeof(timebuffer[0])));
    /*SPR 15875 Fix Stop*/
    l3_strncat_wrapper((S8*)tracesession, (const S8 *)">", 1);
    /*Coverity Fix 20190 End*/
    /*coverity_Parse warning_fix_end*/
    /*SPR 15896 Fix Start*/
    P_RRC_TRACE(p_ue_context, set_all_trace_bitmask (),depth_type,tracesession);
    /*SPR 15896 Fix Stop*/
}

/*SPR 15896 Fix Start*/
/****************************************************************************
 * Function Name  : rrc_trace_max_fprintf
 * Inputs         : p_ue_context - Pointer to uecc_ue_context_t
 *              interface
 *                  buffer_len
 *                  buffer
 * Outputs        : None
 * Returns        : None
 * Description    : Function does fprintf in p_ue_context->fp from buffer
 ****************************************************************************/
static void rrc_trace_max_fprintf( uecc_ue_context_t *p_ue_context, 
                                  U8 interface, U32 buffer_len,  U8 *buffer)
{
    U32 index = 0;
    if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
            (PNULL != p_ue_context->p_ue_trace_activation_info) &&
            (PNULL != p_ue_context->p_ue_trace_activation_info->fp) &&
                        (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & interface) &&
            ((p_ue_context->p_ue_trace_activation_info->trace_depth == MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION) ||
             (p_ue_context->p_ue_trace_activation_info->trace_depth == MAXIMUM)))
    {
        for (index = 0; index < buffer_len; index++)
        {
            fprintf_wrapper(p_ue_context->p_ue_trace_activation_info->fp, (const S8 *)"%02x", buffer[index]);
        }
    }
    if ((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) && 
            (PNULL != p_ue_context->p_ue_cell_trace_activation_info) &&
            (PNULL != p_ue_context->p_ue_cell_trace_activation_info->fp) &&
                        (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & interface) &&
            ((p_ue_context->p_ue_cell_trace_activation_info->trace_depth == MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION) ||
             (p_ue_context->p_ue_cell_trace_activation_info->trace_depth == MAXIMUM)))
    {
    for (index = 0; index < buffer_len; index++)
    {
            fprintf_wrapper(p_ue_context->p_ue_cell_trace_activation_info->fp, (const S8 *)"%02x", buffer[index]);
        }
    }
}

/******************************************************************************
 *   FUNCTION NAME: rrc_trace_max_file_write
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  int message
 *                  U32 buffer_len
 *                  U8 *buffe
 *                  U8 interface
 *                  FILE *fp    
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function traces the RRC logs
 *       
 *
 *   RETURNS:
 *          NONE
 *
 *******************************************************************************/
void rrc_trace_max_file_write(uecc_ue_context_t *p_ue_context,
                 int message ,
                 U32 buffer_len,
                 U8 *buffer,
                         U8 interface)
{
    U8 header_buffer[100];
    U8  end[20] ;

    /* klockwork Fix */ 
    memset_wrapper(header_buffer,RRC_NULL,sizeof(header_buffer));
    memset_wrapper(end,RRC_NULL,sizeof(end));
    /* klockwork Fix */ 

    switch(message)
    {

        /* Coverity Fix 20189 Start */
        case UE_CONTEXT_RELEASE_REQ : 
        case UE_CONTEXT_RELEASE_COMMAND: 
        case UE_CONTEXT_MOD_FAIL:
        case ERAB_RELEASE_COMMAND:
        case ERAB_SETUP_REQ:
        case ERAB_SETUP_RESP:
        case ERAB_MODIFY_REQ:
        case ERAB_MODIFY_RESP:
        case INITIAL_CONTEXT_SETUP_REQ:
        case INITIAL_CONTEXT_SETUP_RESP:
        case INITIAL_CONTEXT_SETUP_FAILURE:
        case NAS_NON_DELIVERY_INDICATION:
        case HANDOVER_COMMAND:
        case HANDOVER_PREPARATION_FAILURE:
        case HANDOVER_REQUIRED:
        case HANDOVER_REQUEST:
        case HANDOVER_REQUEST_ACK:
        case HANDOVER_NOTIFY:
        case PATH_SWITCH_REQUEST:
        case INITIAL_UE_MESSAGE : 
        case HANDOVER_FAILURE : 
        case UPLINK_NAS_TRANSPORT:
        case HANDOVER_CANCEL:
        case DOWNLINK_S1_CDMA2000_TUNNELING:
            P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), interface,"<rawMsg protocol=\"S1AP\" version=\"001\">");
                        rrc_trace_max_fprintf(p_ue_context, S1, buffer_len, buffer);
                        P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), interface," </rawMsg>\n </msg>");
                        break;
        /* SPR 16113 Start */
        case HO_FROM_EUTRA_PREP_REQ:
        case RRC_CONNECTION_RELEASE:
            P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), interface,"<rawMsg protocol=\"%s\" version=\"001\">", RRC_DL_DCCH);
                        rrc_trace_max_fprintf(p_ue_context, UU, buffer_len, buffer);
                        P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), interface," </rawMsg>\n </msg>");
                        break;
        case RRC_CONNECTION_SETUP_COMPLETE:
        case MEASUREMENT_REPORT:
            P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), interface,"<rawMsg protocol=\"%s\" version=\"001\">", RRC_UL_DCCH);
                        rrc_trace_max_fprintf(p_ue_context, UU, buffer_len, buffer);
                        P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), interface," </rawMsg>\n </msg>");
                        break;
        case RRC_CONNECTION_REESTABLISHMENT_REQ:
        case RRC_CONNECTION_REQUEST:
            P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), interface,"<rawMsg protocol=\"%s\" version=\"001\">", RRC_UL_CCCH);
                        rrc_trace_max_fprintf(p_ue_context, UU, buffer_len, buffer);
                        P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), interface," </rawMsg>\n </msg>");
                        break;
        /* SPR 16113 Stop */

        case X2AP_HANDOVER_REQUEST:
        case X2AP_HANDOVER_CANCEL:
        case X2AP_HANDOVER_REQUEST_ACK:
        case X2AP_HANDOVER_PREP_FAILURE:
        case X2AP_SN_STATUS_TRANSFER:
            P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), interface,"<rawMsg protocol=\"X2AP\" version=\"001\">");
                        rrc_trace_max_fprintf(p_ue_context, X2, buffer_len, buffer);
                        P_RRC_TRACE(p_ue_context, set_maximum_bitmask(), interface," </rawMsg>\n </msg>");
                        break;
        default : break ;
    }

}
/*SPR 15896 Fix Stop*/

/* cr_586 new function introduced */
/****************************************************************************
* Function Name  : uecc_s1ap_fillMobilityFromEUTRACommand_r8
* Inputs         : uecc_ue_context_t*  p_ue_context
*                  MobilityFromEUTRACommand_r8_IEs *p_mobilityFromEUTRACommand_r8
*                  U8                               *p_data_buffer
*                  OSCTXT                           *p_asn1_ctx
*                  rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required
*                  uecc_s1_src_ho_info_t   *p_s1_src_ho_info
*                  DL_DCCH_Message                  *msg
* Outputs        : None
* Returns        : None
* Description    : This is the function to fill MobilityFromEUTRACommand 
*                  criticalExtensions IEs either RELEASE 8 
*                  which is used in the case of inter Rat HO
****************************************************************************/
rrc_return_et uecc_s1ap_fillMobilityFromEUTRACommand_r8 
(
    uecc_ue_context_t*                p_ue_context,
    MobilityFromEUTRACommand_r8_IEs  *p_mobilityFromEUTRACommand_r8,
    U8                               *p_data_buffer,
    OSCTXT                           *p_asn1_ctx,
    rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required,
    uecc_s1_src_ho_info_t   *p_s1_src_ho_info,
    DL_DCCH_Message                  *msg
)
{
    OSOCTET                          *p_data = PNULL;
    U32                              si_psi_index;
    U32                              ho_cmd_index;
    /*SPR 19592 FIX START*/
    U8                   iei_plus_len = RRC_ZERO;
    U32                  ho_cmd_len = RRC_ZERO;
    /*SPR 19592 FIX END*/

    p_mobilityFromEUTRACommand_r8->m.nonCriticalExtensionPresent = 0;
    p_mobilityFromEUTRACommand_r8->cs_FallbackIndicator = 
        (OSBOOL)p_ue_context->cs_fallback_indicator; 

    /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated)
    { 
        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), UU,"\n <ie name=\"Cs fallback indicator\">%d</ie> \n ",
                (OSBOOL)p_ue_context->cs_fallback_indicator);
        /*SPR 15896 Fix Stop*/
    }

    /* Cell Change Order is not supported for this release : Code
       needs to be added for that */
    if(HANDOVER_TYPE_CCO != p_rrc_rrm_ho_required->ho_type)
    {
        p_mobilityFromEUTRACommand_r8->purpose.t =
            T_MobilityFromEUTRACommand_r8_IEs_purpose_handover;

        p_mobilityFromEUTRACommand_r8->purpose.u.handover =
            rtxMemAllocType(p_asn1_ctx,Handover);
        if (PNULL == p_mobilityFromEUTRACommand_r8->purpose.u.handover)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                    "Memory allocation failed for IEs_purpose_handover");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        asn1Init_Handover(p_mobilityFromEUTRACommand_r8->purpose.u.handover);
        p_mobilityFromEUTRACommand_r8->purpose.u.handover->
            m.nas_SecurityParamFromEUTRAPresent = 1;

        /* Fill nas_security_param_from_E_UTRAN */
        p_mobilityFromEUTRACommand_r8->purpose.u.handover->
            nas_SecurityParamFromEUTRA.numocts =
            p_s1_src_ho_info->inter_rat_ho_info.nas_security_param_from_E_UTRAN_numocts;

        l3_memcpy_wrapper(&p_mobilityFromEUTRACommand_r8->purpose.u.handover->
                nas_SecurityParamFromEUTRA.data,
                p_s1_src_ho_info->inter_rat_ho_info.
                p_nas_security_param_from_E_UTRAN_data,
                p_s1_src_ho_info->inter_rat_ho_info.
                nas_security_param_from_E_UTRAN_numocts); 
    }
    else
    {
        p_mobilityFromEUTRACommand_r8->purpose.t =
            T_MobilityFromEUTRACommand_r8_IEs_purpose_cellChangeOrder;
        p_mobilityFromEUTRACommand_r8->purpose.u.cellChangeOrder =
            rtxMemAllocType(p_asn1_ctx,CellChangeOrder);
        if (PNULL == p_mobilityFromEUTRACommand_r8->purpose.u.cellChangeOrder)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL, "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                    "Memory allocation failed for IEs_purpose_cellChangeOrder");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        asn1Init_CellChangeOrder(p_mobilityFromEUTRACommand_r8->purpose.u.cellChangeOrder);

        p_mobilityFromEUTRACommand_r8->purpose.u.cellChangeOrder->t304 = 
            p_rrc_rrm_ho_required->mobility_control_info.t304_timer;

        if (RRC_SUCCESS != uecc_s1ap_fill_cellChangeOrder_targetRAT_Type(p_asn1_ctx,
                    p_ue_context,
                    &p_rrc_rrm_ho_required->cco_params.target_rat_params,
                    &p_mobilityFromEUTRACommand_r8->purpose.u.cellChangeOrder->targetRAT_Type))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL, "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                    "uecc_s1ap_fill_cellChangeOrder_targetRAT_Type failed.");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }

    /* for HO LTE_TO_UTRAN */
    if(HANDOVER_TYPE_LTE_TO_UTRAN == p_rrc_rrm_ho_required->ho_type)
    {
        p_mobilityFromEUTRACommand_r8->purpose.u.handover->
            targetRAT_Type = TARGET_RAT_TYPE_UTRA;
        p_mobilityFromEUTRACommand_r8->purpose.u.handover->m.systemInformationPresent = 0;
        p_mobilityFromEUTRACommand_r8->purpose.u.handover->
            targetRAT_MessageContainer.numocts =
            p_s1_src_ho_info->inter_rat_ho_info.target_to_source_transparent_container_numocts;

        p_data = rtxMemAlloc(p_asn1_ctx,p_mobilityFromEUTRACommand_r8->
                purpose.u.handover->targetRAT_MessageContainer.numocts);
        /* SPR 12964 Fix Start */
        if(PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "Mem Alloc failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /* SPR 12964 Fix Stop */
        l3_memcpy_wrapper(p_data, 
                p_s1_src_ho_info->inter_rat_ho_info.
                p_target_to_source_transparent_container_data,
                p_mobilityFromEUTRACommand_r8->purpose.u.handover->
                targetRAT_MessageContainer.numocts);
        p_mobilityFromEUTRACommand_r8->purpose.u.handover->
            targetRAT_MessageContainer.data = p_data;
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,
                "[uecc_s1ap_fillMobilityFromEUTRACommand] "
                "Copied %d bytes to targetRAT Message Container",
                p_s1_src_ho_info->inter_rat_ho_info.target_to_source_transparent_container_numocts);
    }
    /* for HO LTE_TO_GERAN */
    else if(HANDOVER_TYPE_LTE_TO_GERAN == p_rrc_rrm_ho_required->ho_type)    
    {
        p_mobilityFromEUTRACommand_r8->purpose.u.handover->targetRAT_Type =
            TARGET_RAT_TYPE_GERAN;
        if ( p_rrc_rrm_ho_required->bitmask
                & RRC_RRM_UE_HO_ADM_REQ_SRVCC_HO_INDICATION_PRESENT )
        {
            /* Fill targetRAT_MessageContainer for CS domain HO */
            if( CS_ONLY_TYPE ==  p_rrc_rrm_ho_required->srvcc_ho_indication)            {
                p_mobilityFromEUTRACommand_r8->purpose.u.handover->\
                    m.systemInformationPresent =0;
                /* SPR 20635 Fix - Macro Definition Corrected */
                if( NEW_BSS_OLD_BSS_LAYER_3_INFORMATION_IE &\
                        p_s1_src_ho_info->inter_rat_ho_info.\
                        p_target_to_source_transparent_container_data[0])
                { 
                    /* Fill layer 3 information */
                    p_mobilityFromEUTRACommand_r8->purpose.u.handover->\
                        targetRAT_MessageContainer.numocts =\
                        (OSUINT32)(HEADER_IE_PLUS_LENGTH+\
                                p_s1_src_ho_info->inter_rat_ho_info.\
                                p_target_to_source_transparent_container_data[1]);
                    p_mobilityFromEUTRACommand_r8->purpose.u.
                        handover->targetRAT_MessageContainer.data = (OSOCTET *)
                        (p_s1_src_ho_info->inter_rat_ho_info.
                         p_target_to_source_transparent_container_data);
                    /* SPR 20635 Fix - Print Trace Corrected */
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,
                            "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                            "NEW_BSS_OLD_BSS_LAYER_3_INFORMATION_IE"
                            "is successfully filled targetRAT_MessageContainer ");
                }
                else
                {
                    /* SPR 20635 Fix - Print Trace Corrected */
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                            "NEW_BSS_OLD_BSS_LAYER_3_INFORMATION_IE"
                            "is not present");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
            }

            /* Fill targetRAT_MessageContainer for CS and PS domain HO */
            else if(CS_PS_TYPE ==  p_rrc_rrm_ho_required->srvcc_ho_indication)
            {
                if( p_s1_src_ho_info->inter_rat_ho_info.bitmask &\
                        TARGET_TO_SOURCE_TRANSPARNET_CONTAINER_SECONDARY_PRESENT)
                {
                    /* SRVCC start */
                    /*  p_mobilityFromEUTRACommand_r8->purpose.u.handover->\
                        m.systemInformationPresent = 1;  */
                    /* SRVCC stop */

                    /* SPR 20635 Fix - Macro Definition Corrected */
                    if(TARGET_BSS_TO_SOURCE_BSS_TRANSPARENT_CONTAINER_IE & \
                            p_s1_src_ho_info->inter_rat_ho_info.\
                            p_target_to_source_transparent_container_secondary_data[0])
                    {
                        /* SPR 22053 start */
                        if (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_secondary_data[1] & 0x80)
                        {
                            iei_plus_len = HEADER_IE_PLUS_LENGTH; /* IEI (1-Octet) + length (1-Octet) */
                        }
                        else
                        {
                            iei_plus_len = HEADER_IE_PLUS_LENGTH + 1;/* IEI (1-Octet) + length (2-Octet) */
                        }

                        /* as per 48018:  DTM handover Command IEI - x79 
                           SI/PSI Container IE     - x76 */
                        /* SPR 20635 Fix - Macro Definition Corrected */
                        if(TARGET_BSS_SOURCE_BSS_SI_PSI_CONTAINER_IE ==\
                                p_s1_src_ho_info->inter_rat_ho_info.\
                                p_target_to_source_transparent_container_secondary_data[iei_plus_len])
                        {
                            if (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_secondary_data[iei_plus_len + 1] & 0x80)
                            {
                                ho_cmd_index = iei_plus_len + /* Transparent IEI + length skip */
                                    HEADER_IE_PLUS_LENGTH + /* PSI IEI + length skip */
                                    (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_secondary_data[iei_plus_len + 1] & 0x7F);
                            }
                            else
                            {
                                ho_cmd_index = iei_plus_len +
                                    HEADER_IE_PLUS_LENGTH +
                                    1 + /* Length is of 2 octet */
                                    ((p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_secondary_data[iei_plus_len + 1] << 8) |
                                    (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_secondary_data[iei_plus_len + 2]));
                            }
                            /* Target Bss to Source Bss Transparent Container :
                               1. SI/PSI Container
                               2. DTM Handover Command */
                        }
                        /* SPR 20635 Fix - Macro Definition Corrected */
                        else if(TARGET_BSS_SOURCE_BSS_DTM_HANDOVER_COMMAND_IE ==\
                                p_s1_src_ho_info->inter_rat_ho_info.\
                                p_target_to_source_transparent_container_secondary_data[iei_plus_len])
                        {
                            ho_cmd_index = iei_plus_len;
                        }
                        else
                        {   
                            /* SPR 20635 Fix - Print Trace Corrected */
                            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                    (p_ue_context->p_gb_context)->facility_name,
                                    RRC_WARNING,
                                    "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                                    "TARGET_BSS_SOURCE_BSS_SI_PSI_CONTAINER_IE or "
                                    "TARGET_BSS_SOURCE_BSS_DTM_HANDOVER_COMMAND_IE"
                                    "is not present");
                            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                            return RRC_FAILURE;
                        }
                        if (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_secondary_data[ho_cmd_index + 1] & 0x80)
                        {
                            ho_cmd_len = HEADER_IE_PLUS_LENGTH +
                                (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_secondary_data[ho_cmd_index+1] & 0x7F);
                        }
                        else
                        {
                            ho_cmd_len = HEADER_IE_PLUS_LENGTH + 1 +
                                ((p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_secondary_data[ho_cmd_index + 1] << 8) |
                                (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_secondary_data[ho_cmd_index + 2]));
                        }
                        /* Fill targetRAT_MessageContainer  */
                        p_mobilityFromEUTRACommand_r8->purpose.u.handover->\
                            targetRAT_MessageContainer.numocts = ho_cmd_len;
                        /* SPR 22053 end */

                        p_data = (U8*)rtxMemAlloc(p_asn1_ctx,p_mobilityFromEUTRACommand_r8->purpose.u.handover->\
                                targetRAT_MessageContainer.numocts);
                        /* SPR 12964 Fix Start */
                        if(PNULL == p_data)
                        {
                            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                                    "Mem Alloc failed");
                            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                            return RRC_FAILURE;
                        }
                        /* SPR 12964 Fix Stop */

                        /* Fill DTM  Handover Command */
                        l3_memcpy_wrapper(p_data,
                                &(p_s1_src_ho_info->inter_rat_ho_info.\
                                    p_target_to_source_transparent_container_secondary_data[ho_cmd_index]),
                                p_mobilityFromEUTRACommand_r8->purpose.u.handover->\
                                targetRAT_MessageContainer.numocts);

                        p_mobilityFromEUTRACommand_r8->purpose.u.\
                            handover->targetRAT_MessageContainer.data= p_data;

                        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                (p_ue_context->p_gb_context)->facility_name,
                                RRC_INFO,
                                "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                                "DTM  Handover Command"
                                "is successfully filled in targetRAT_MessageContainer");
                        /* SPR 1029 */
                    }
                    else
                    {
                        /* SPR 20635 Fix - Print Trace Corrected */
                        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                (p_ue_context->p_gb_context)->facility_name,
                                RRC_WARNING,
                                "[uecc_sgap_fillMobilityFromEUTRACommand]"
                                "TARGET_BSS_TO_SOURCE_BSS_TRANSPARENT_CONTAINER_IE"
                                "is not present");
                        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                        return RRC_FAILURE;
                    }
                }
                else
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                            "target_to_source_transparent_container_secondary"
                            "is not present");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE; 
                }
            }
        }
        else
        {
            /* For PS Domain HO */
            p_mobilityFromEUTRACommand_r8->purpose.u.handover->\
                m.systemInformationPresent  = 1;
            /* SPR 20635 Fix - Macro Definition Corrected */
            if( TARGET_BSS_TO_SOURCE_BSS_TRANSPARENT_CONTAINER_IE &\
                    p_s1_src_ho_info->inter_rat_ho_info.\
                    p_target_to_source_transparent_container_data[0])
            {
                /* SPR 22053 start */
                if (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[1] & 0x80)
                {
                    iei_plus_len = HEADER_IE_PLUS_LENGTH; /* IEI (1-Octet) + length (1-Octet) */
                }
                else
                {
                    iei_plus_len = HEADER_IE_PLUS_LENGTH + 1;/* IEI (1-Octet) + length (2-Octet) */
                }
                /* as per 48018:  PS handover Command IEI - x74 
                   SI/PSI Container IE     - x76 */
                /* SPR 20635 Fix - Macro Definition Corrected */
                if(TARGET_BSS_SOURCE_BSS_SI_PSI_CONTAINER_IE ==\
                        p_s1_src_ho_info->inter_rat_ho_info.\
                        p_target_to_source_transparent_container_data[iei_plus_len])
                {
                    /* Target Bss to Source Bss Transparent Container :
                       1. SI/PSI Container
                       2. PS Handover Command */

                    si_psi_index = iei_plus_len;
                    /*SPR 19592 FIX START*/
                    if (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[si_psi_index + 1] & 0x80)
                    {
                        ho_cmd_index = iei_plus_len +
                            HEADER_IE_PLUS_LENGTH + /* PSI IEI + length skip */
                            (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[si_psi_index + 1] & 0x7F);

                    }
                    else
                    {
                        ho_cmd_index = iei_plus_len +
                            HEADER_IE_PLUS_LENGTH +
                            1 + /* Length is of 2 octet */
                            ((p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[si_psi_index + 1] << 8) |
                            (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[si_psi_index + 2]));
                    }
                    if (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[ho_cmd_index + 1] & 0x80)
                    {
                        ho_cmd_len = HEADER_IE_PLUS_LENGTH +
                            (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[ho_cmd_index + 1] & 0x7F);

                        si_psi_index = (U32)(ho_cmd_index + ho_cmd_len);
                    }
                    else
                    {
                        ho_cmd_len = HEADER_IE_PLUS_LENGTH + 1 +
                            ((p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[ho_cmd_index + 1] << 8) |
                            (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[ho_cmd_index + 2]));
                        si_psi_index = (U32)(ho_cmd_index + ho_cmd_len);
                    }
                    /*SPR 19592 FIX END*/
                }
                /* SPR 20635 Fix - Macro Definition Corrected */
                else if(TARGET_BSS_SOURCE_BSS_PS_HANDOVER_COMMAND_IE ==\
                        p_s1_src_ho_info->inter_rat_ho_info.\
                        p_target_to_source_transparent_container_data[iei_plus_len])
                {
                    /* Target Bss to Source Bss Transparent Container :
                       1. PS Handover Command
                       2. SI/PSI Container */
                    ho_cmd_index = iei_plus_len;
                    /*SPR 19592 FIX START*/
                    if (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[ho_cmd_index + 1] & 0x80)
                    {
                        ho_cmd_len = HEADER_IE_PLUS_LENGTH +
                            (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[ho_cmd_index + 1] & 0x7F);

                        si_psi_index = (U32)(ho_cmd_index + ho_cmd_len);
                    }
                    else
                    {
                        ho_cmd_len = HEADER_IE_PLUS_LENGTH + 1 +
                            ((p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[ho_cmd_index + 1] << 8) |
                            (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[ho_cmd_index + 2]));
                        si_psi_index = (U32)(ho_cmd_index + ho_cmd_len);
                    }
                    /*SPR 19592 FIX END*/
                }
                else
                {
                    /* SPR 20635 Fix - Print Trace Corrected */
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                            "TARGET_BSS_SOURCE_BSS_SI_PSI_CONTAINER_IE or "
                            "TARGET_BSS_SOURCE_BSS_PS_HANDOVER_COMMAND_IE"
                            "is not present");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }

                /* Fill targetRAT_MessageContainer for PS domain HO */
                p_mobilityFromEUTRACommand_r8->purpose.u.handover->
                    targetRAT_MessageContainer.numocts = ho_cmd_len;
                /* SPR 22053 end */

                /* Fill PS Handover Command */
                p_data = (U8*)rtxMemAlloc(p_asn1_ctx,p_mobilityFromEUTRACommand_r8->purpose.u.handover->\
                        targetRAT_MessageContainer.numocts);
                /* SPR 12964 Fix Start */
                if(PNULL == p_data)
                {
                    RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                            p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                            "Mem Alloc failed");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
                /* SPR 12964 Fix Stop */

                l3_memcpy_wrapper(p_data,
                        &(p_s1_src_ho_info->inter_rat_ho_info.\
                            p_target_to_source_transparent_container_data[ho_cmd_index]),
                        p_mobilityFromEUTRACommand_r8->purpose.u.handover->\
                        targetRAT_MessageContainer.numocts);

                p_mobilityFromEUTRACommand_r8->purpose.u.\
                    handover->targetRAT_MessageContainer.data= p_data;

                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_INFO,
                        "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                        "PS  Handover Command"
                        "is successfully filled in targetRAT_MessageContainer");

                if(RRC_SUCCESS != uecc_s1ap_fill_si_psi_container(
                            p_s1_src_ho_info->inter_rat_ho_info.
                            p_target_to_source_transparent_container_data,
                            &p_mobilityFromEUTRACommand_r8->purpose.u.handover->\
                            systemInformation,si_psi_index,p_asn1_ctx,p_ue_context))
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                            "failed to fill si_psi_container");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
            }
            else
            {
                /* SPR 20635 Fix - Print Trace Corrected */
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                        "TARGET_BSS_TO_SOURCE_BSS_TRANSPARENT_CONTAINER_IE"
                        "is not present");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
        }

        /* cr 586 ::  Filling Band Indicator */
        if (p_s1_src_ho_info->p_rrc_rrm_ho_required->bitmask &
                RRC_RRM_UE_HO_ADM_RE_BAND_INDICATOR_PRESENT)
        {    
            p_mobilityFromEUTRACommand_r8->m.nonCriticalExtensionPresent = 1;
            p_mobilityFromEUTRACommand_r8->nonCriticalExtension.
                m.lateNonCriticalExtensionPresent = 0;
            p_mobilityFromEUTRACommand_r8->nonCriticalExtension.
                m.nonCriticalExtensionPresent= 1;
            p_mobilityFromEUTRACommand_r8->nonCriticalExtension.
                nonCriticalExtension.m.nonCriticalExtensionPresent = 0;

            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_INFO,"Release 8 Band Indicator IE received form RRM");
            p_mobilityFromEUTRACommand_r8->nonCriticalExtension.
                nonCriticalExtension.m.bandIndicatorPresent = 1;

            p_mobilityFromEUTRACommand_r8->nonCriticalExtension.nonCriticalExtension.
                bandIndicator =  p_s1_src_ho_info->p_rrc_rrm_ho_required->band_indicator; 
        }    
    }

    /* TRACE_fix */
    /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated)
    {
        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), UU,"<ie name=\"Target RAT Type\">%d</ie>",
                p_mobilityFromEUTRACommand_r8->purpose.u.handover->targetRAT_Type); 
        /*SPR 15896 Fix Stop*/
    }  
    /* TRACE_fix */
    /*SPR 20886 Fix Start*/
    pu_setBuffer(p_asn1_ctx,p_data_buffer,UECC_MAX_ASN1_BUF_LEN,ASN_RRC_BUF_TYPE);
    /*SPR 20886 Fix Stop*/
    /* Encode the message and then store into UE Context buffer */
    if(RT_OK != asn1PE_DL_DCCH_Message(p_asn1_ctx,msg))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,
                "[fillMobilityFromEUTRACommand]DL_DCCH_Message Encoding failed");
        /*SPR 20886 Fix Start*/
        char buff[500];
        rtxErrGetTextBuf(p_asn1_ctx,buff ,500); 
        /*SPR 20886 Fix Stop*/
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    else
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "RRC_MSG: HandoverFromEUTRAPreparationRequest %s",
                change_data_to_str((U16)pe_GetMsgLen(p_asn1_ctx), p_data_buffer));

        rrc_asn1PrtToStr_DL_DCCH_Message(RRC_ASN, "DL_DCCH_Message", msg,
                "Handover", p_data_buffer,
                (U16)pe_GetMsgLen(p_asn1_ctx));
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}   

/****************************************************************************
* Function Name  : uecc_s1ap_fillMobilityFromEUTRACommand_r9_lte_to_geran
* Inputs         : uecc_ue_context_t* - pointer to UE context
*                  p_rrc_rrm_ho_required,
*                  p_s1_src_ho_info
*                  p_asn1_ctx
* Outputs        : p_mobilityFromEUTRACommand_r9
* Returns        : RRC_FAILURE/RRC_SUCCESS
* Description    : This is the function to fill MobilityFromEUTRACommand 
*                  for ho_type HANDOVER_TYPE_LTE_TO_GERAN
****************************************************************************/
static rrc_return_et uecc_s1ap_fillMobilityFromEUTRACommand_r9_lte_to_geran(
        uecc_ue_context_t                *p_ue_context,
        MobilityFromEUTRACommand_r9_IEs  *p_mobilityFromEUTRACommand_r9,
        rrc_rrm_ho_required_t            *p_rrc_rrm_ho_required,
        uecc_s1_src_ho_info_t            *p_s1_src_ho_info,
        OSCTXT                           *p_asn1_ctx)
{
    OSOCTET                          *p_data = PNULL;
    U32                              si_psi_index;
    U32                              ho_cmd_index;

    /* BugId - 20068 Start */
    U8                   contatiner_index;
    U32                  si_psi_len;
    U32                  ho_cmd_len;
    /* BugId - 20068 End */

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    if ( p_rrc_rrm_ho_required->bitmask
            & RRC_RRM_UE_HO_ADM_REQ_SRVCC_HO_INDICATION_PRESENT )
    {
        /* Fill targetRAT_MessageContainer for CS domain HO */
        if( CS_ONLY_TYPE ==  p_rrc_rrm_ho_required->srvcc_ho_indication)
        {
            p_mobilityFromEUTRACommand_r9->purpose.u.handover->\
                m.systemInformationPresent =0;

            /* SPR 20635 Fix - Macro Definition Corrected */
            if( NEW_BSS_OLD_BSS_LAYER_3_INFORMATION_IE &\
                    p_s1_src_ho_info->inter_rat_ho_info.\
                    p_target_to_source_transparent_container_data[0])
            { 
                /* Fill layer 3 information */
                /* SPR 17626 Fix Start */
                p_mobilityFromEUTRACommand_r9->purpose.u.handover->\
                    targetRAT_MessageContainer.numocts =\
                    (OSUINT32)(p_s1_src_ho_info->inter_rat_ho_info.\
                            target_to_source_transparent_container_numocts);
                /* SPR 17626 Fix Stop */

                p_mobilityFromEUTRACommand_r9->purpose.u.
                    handover->targetRAT_MessageContainer.data = (OSOCTET *)
                    (p_s1_src_ho_info->inter_rat_ho_info.
                     p_target_to_source_transparent_container_data);

                /* SPR 20635 Fix - Print Trace Corrected */
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_INFO,
                        "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                        "NEW_BSS_OLD_BSS_LAYER_3_INFORMATION_IE"
                        "is successfully filled targetRAT_MessageContainer ");
            }
            else
            {
                /* SPR 20635 Fix - Print Trace Corrected */
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                        "NEW_BSS_OLD_BSS_LAYER_3_INFORMATION_IE"
                        "is not present");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
        }

        /* Fill targetRAT_MessageContainer for CS and PS domain HO */
        else if(CS_PS_TYPE ==  p_rrc_rrm_ho_required->srvcc_ho_indication)
        {
            if( p_s1_src_ho_info->inter_rat_ho_info.bitmask &\
                    TARGET_TO_SOURCE_TRANSPARNET_CONTAINER_SECONDARY_PRESENT)
            {
                p_mobilityFromEUTRACommand_r9->purpose.u.handover->\
                    m.systemInformationPresent = 1;

                /* SPR 20635 Fix - Macro Definition Corrected */
                if(TARGET_BSS_TO_SOURCE_BSS_TRANSPARENT_CONTAINER_IE & \
                        p_s1_src_ho_info->inter_rat_ho_info.\
                        p_target_to_source_transparent_container_secondary_data[0])
                {

                    /* as per 48018:  DTM handover Command IEI - x79 
                       SI/PSI Container IE     - x76 */
                    /* SPR 20635 Fix - Macro Definition Corrected */
                    if(TARGET_BSS_SOURCE_BSS_SI_PSI_CONTAINER_IE ==\
                            p_s1_src_ho_info->inter_rat_ho_info.\
                            p_target_to_source_transparent_container_secondary_data[2])
                    {
                        /* Target Bss to Source Bss Transparent Container :
                           1. SI/PSI Container
                           2. DTM Handover Command */
                        /*coverity 81453 fix start*/
                        //si_psi_index = HEADER_IE_PLUS_LENGTH ;
                        /*coverity 81453 fix end*/
                        ho_cmd_index =\
                                      (U32)(HEADER_IE_PLUS_LENGTH+\
                                              HEADER_IE_PLUS_LENGTH+\
                                              (p_s1_src_ho_info->inter_rat_ho_info.\
                                               p_target_to_source_transparent_container_secondary_data[3]));
                    }
                    /* SPR 20635 Fix - Macro Definition Corrected */
                    else if(TARGET_BSS_SOURCE_BSS_DTM_HANDOVER_COMMAND_IE ==\
                            p_s1_src_ho_info->inter_rat_ho_info.\
                            p_target_to_source_transparent_container_secondary_data[2])
                    {
                        /* Target Bss to Source Bss Transparent Container :
                           1. DTM Handover Command
                           2. SI/PSI Container */
                        ho_cmd_index = HEADER_IE_PLUS_LENGTH ;
            /* + Coverity 81309 */
                    /*    si_psi_index =
                            (U32)(HEADER_IE_PLUS_LENGTH+\
                                    HEADER_IE_PLUS_LENGTH+\
                                    (p_s1_src_ho_info->inter_rat_ho_info.\
                                     p_target_to_source_transparent_container_secondary_data[3]));*/
            /* - Coverity 81309 */
                    }
                    else
                    {   
                        /* SPR 20635 Fix - Print Trace Corrected */
                        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                (p_ue_context->p_gb_context)->facility_name,
                                RRC_WARNING,
                                "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                                "TARGET_BSS_SOURCE_BSS_SI_PSI_CONTAINER_IE or "
                                "TARGET_BSS_SOURCE_BSS_DTM_HANDOVER_COMMAND_IE"
                                "is not present");
                        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                        return RRC_FAILURE;
                    }
                    /* Fill targetRAT_MessageContainer  */
                    p_mobilityFromEUTRACommand_r9->purpose.u.handover->\
                        targetRAT_MessageContainer.numocts =  
                        (U32)(HEADER_IE_PLUS_LENGTH +\
                                (p_s1_src_ho_info->inter_rat_ho_info.\
                                 p_target_to_source_transparent_container_secondary_data[ho_cmd_index+1]));


                    p_data = (U8*)rtxMemAlloc(p_asn1_ctx,p_mobilityFromEUTRACommand_r9->purpose.u.handover->\
                            targetRAT_MessageContainer.numocts);
                    /* SPR 12964 Fix Start */
                    if(PNULL == p_data)
                    {
                        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                                p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                                "Mem Alloc failed");
                        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                        return RRC_FAILURE;
                    }
                    /* SPR 12964 Fix Stop */

                    /* Fill DTM  Handover Command */
                    l3_memcpy_wrapper(p_data,
                            &(p_s1_src_ho_info->inter_rat_ho_info.\
                                p_target_to_source_transparent_container_secondary_data[ho_cmd_index]),
                            p_mobilityFromEUTRACommand_r9->purpose.u.handover->\
                            targetRAT_MessageContainer.numocts);

                    p_mobilityFromEUTRACommand_r9->purpose.u.\
                        handover->targetRAT_MessageContainer.data= p_data;

                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,
                            "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                            "DTM  Handover Command"
                            "is successfully filled in targetRAT_MessageContainer");
                }
                else
                {
                    /* SPR 20635 Fix - Print Trace Corrected */
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "[uecc_sgap_fillMobilityFromEUTRACommand]"
                            "TARGET_BSS_TO_SOURCE_BSS_TRANSPARENT_CONTAINER_IE"
                            "is not present");
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
            }
            else
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                        "target_to_source_transparent_container_secondary"
                        "is not present");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE; 
            }
        }
    }
    else
    {
        /* For PS Domain HO */
        p_mobilityFromEUTRACommand_r9->purpose.u.handover->\
            m.systemInformationPresent  = 1;
        /* SPR 20635 Fix - Macro Definition Corrected */
        if( TARGET_BSS_TO_SOURCE_BSS_TRANSPARENT_CONTAINER_IE &\
                p_s1_src_ho_info->inter_rat_ho_info.\
                p_target_to_source_transparent_container_data[0])
        {
                /* BugId - 20068 Start */
                if (1 && (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[1] >> 7))
                {
                    contatiner_index = 2;
                }
                else 
                {
                    contatiner_index = 3;
                }
                /* BugId - 20068 End */
            /* as per 48018:  PS handover Command IEI - x74 
               SI/PSI Container IE     - x76 */
            /* SPR 20635 Fix - Macro Definition Corrected */
            if(TARGET_BSS_SOURCE_BSS_SI_PSI_CONTAINER_IE ==\
                    p_s1_src_ho_info->inter_rat_ho_info.\
                        /* BugId - 20068 Start */
                        p_target_to_source_transparent_container_data[contatiner_index])
                    /* BugId - 20068 End */
            {
                /* Target Bss to Source Bss Transparent Container :
                   1. SI/PSI Container
                   2. PS Handover Command */
                    /* BugId - 20068 Start */

                    si_psi_index = contatiner_index ;
                    if (1 && (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[si_psi_index+1] >> 7))
                    {
                        si_psi_len = p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[++contatiner_index] & 0x7F;

                        ho_cmd_index = (U32)(contatiner_index + si_psi_len + 1);
                    }
                    else
                    {
                        si_psi_len = p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[++contatiner_index] << 8 || p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[++contatiner_index];
                ho_cmd_index =\
                                      (U32)(contatiner_index + si_psi_len + 1);
                    }
                    /* BugId - 20068 End */
            }
            /* SPR 20635 Fix - Macro Definition Corrected */
            else if(TARGET_BSS_SOURCE_BSS_PS_HANDOVER_COMMAND_IE ==\
                    p_s1_src_ho_info->inter_rat_ho_info.\
                        /* BugId - 20068 Start */
                        p_target_to_source_transparent_container_data[contatiner_index])
                    /* BugId - 20068 End */
            {
                /* Target Bss to Source Bss Transparent Container :
                   1. PS Handover Command
                   2. SI/PSI Container */
                    /* BugId - 20068 Start */
                    ho_cmd_index = contatiner_index ;
                    if (1 && (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[ho_cmd_index+1] >> 7))
                    {
                        ho_cmd_len = (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[++contatiner_index] & 0x7F);

                        si_psi_index = (U32)(contatiner_index + ho_cmd_len + 1);
                    }
                    else
                    {
                        ho_cmd_len = p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[++contatiner_index] << 8 || p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[++contatiner_index];
                        si_psi_index = (U32)(contatiner_index + ho_cmd_len + 1);
                    }
                    /* BugId - 20068 End */
            }   
            else
            {   
                /* SPR 20635 Fix - Print Trace Corrected */
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                        "TARGET_BSS_SOURCE_BSS_SI_PSI_CONTAINER_IE or "
                        "TARGET_BSS_SOURCE_BSS_PS_HANDOVER_COMMAND_IE"
                        "is not present");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }

            /* Fill targetRAT_MessageContainer for PS domain HO */
                /* BugId - 20068 Start */
                if (1 && (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[ho_cmd_index+1] >> 7))
                {
                    ho_cmd_len = (p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[ho_cmd_index+1] & 0x7F);             
                    ho_cmd_index +=2;

                }
                else
                {
                    ho_cmd_len = p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[ho_cmd_index+1] << 8 || p_s1_src_ho_info->inter_rat_ho_info.p_target_to_source_transparent_container_data[ho_cmd_index+2];
                    ho_cmd_index +=3;
                }

            p_mobilityFromEUTRACommand_r9->purpose.u.handover->            \
                    targetRAT_MessageContainer.numocts =  (U32) ho_cmd_len;
                /* BugId - 20068 End */

            /* Fill PS Handover Command */
            p_data = (U8*)rtxMemAlloc(p_asn1_ctx,p_mobilityFromEUTRACommand_r9->purpose.u.handover->\
                    targetRAT_MessageContainer.numocts);
            /* SPR 12964 Fix Start */
            if(PNULL == p_data)
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                        p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                        "Mem Alloc failed");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            /* SPR 12964 Fix Stop */

            l3_memcpy_wrapper(p_data,
                    &(p_s1_src_ho_info->inter_rat_ho_info.\
                        p_target_to_source_transparent_container_data[ho_cmd_index]),
                    p_mobilityFromEUTRACommand_r9->purpose.u.handover->\
                    targetRAT_MessageContainer.numocts);

            p_mobilityFromEUTRACommand_r9->purpose.u.\
                handover->targetRAT_MessageContainer.data= p_data;

            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_INFO,
                    "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                    "PS  Handover Command"
                    "is successfully filled in targetRAT_MessageContainer");

            if(RRC_SUCCESS != uecc_s1ap_fill_si_psi_container(
                        p_s1_src_ho_info->inter_rat_ho_info.
                        p_target_to_source_transparent_container_data,
                        &p_mobilityFromEUTRACommand_r9->purpose.u.handover->\
                        systemInformation,si_psi_index,p_asn1_ctx,
                        p_ue_context))
            {

                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                        "failed to fill si_psi_container");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
        }
        else
        {
            /* SPR 20635 Fix - Print Trace Corrected */
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                    "TARGET_BSS_TO_SOURCE_BSS_TRANSPARENT_CONTAINER_IE"
                    "is not present");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }

    /* cr 586 ::  Filling Band Indicator */

    if (p_s1_src_ho_info->p_rrc_rrm_ho_required->bitmask &
            RRC_RRM_UE_HO_ADM_RE_BAND_INDICATOR_PRESENT)
    {    
        p_mobilityFromEUTRACommand_r9->m.nonCriticalExtensionPresent = 1;
        p_mobilityFromEUTRACommand_r9->nonCriticalExtension.
            m.lateNonCriticalExtensionPresent = 0;
        p_mobilityFromEUTRACommand_r9->nonCriticalExtension.
            m.nonCriticalExtensionPresent= 1;
        p_mobilityFromEUTRACommand_r9->nonCriticalExtension.
            nonCriticalExtension.m.nonCriticalExtensionPresent = 0;
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,"Release 9 Band Indicator IE received form RRM");
        p_mobilityFromEUTRACommand_r9->nonCriticalExtension.
            nonCriticalExtension.m.bandIndicatorPresent = 1;

        p_mobilityFromEUTRACommand_r9->nonCriticalExtension.nonCriticalExtension.
            bandIndicator =  p_s1_src_ho_info->p_rrc_rrm_ho_required->band_indicator; 
    }    
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/****************************************************************************
* Function Name  : uecc_s1ap_fillMobilityFromEUTRACommand_r9
* Inputs         : uecc_ue_context_t*  p_ue_context
*                  MobilityFromEUTRACommand_r9_IEs  
*                                             *p_mobilityFromEUTRACommand_r9
*                  OSCTXT                           *p_asn1_ctx
*                  rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required
*                  uecc_s1_src_ho_info_t   *p_s1_src_ho_info
*                  DL_DCCH_Message                  *msg
* Outputs        : None
* Returns        : None
* Description    : This is the function to fill MobilityFromEUTRACommand 
*                  criticalExtensions IEs either RELEASE 9 
*                  which is used in the case of inter Rat HO
****************************************************************************/
rrc_return_et uecc_s1ap_fillMobilityFromEUTRACommand_r9 
(
    uecc_ue_context_t*                p_ue_context,
    MobilityFromEUTRACommand_r9_IEs  *p_mobilityFromEUTRACommand_r9,
    U8                               *p_data_buffer,
    OSCTXT                           *p_asn1_ctx,
    rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required,
    uecc_s1_src_ho_info_t   *p_s1_src_ho_info,
    DL_DCCH_Message                  *msg
)
{
    OSOCTET                          *p_data = PNULL;

    p_mobilityFromEUTRACommand_r9->m.nonCriticalExtensionPresent = 0;
    p_mobilityFromEUTRACommand_r9->cs_FallbackIndicator = 
        (OSBOOL)p_ue_context->cs_fallback_indicator; 

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated)
    { 
        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), UU,"\n <ie name=\"Cs fallback indicator\">%d</ie> \n ",
                (OSBOOL)p_ue_context->cs_fallback_indicator);
        /*SPR 15896 Fix Stop*/
    }

    /* Cell Change Order is not supported for this release : Code
       needs to be added for that */
    /*SPR 8522 Fix start*/ 
    p_mobilityFromEUTRACommand_r9->purpose.u.handover =
        rtxMemAllocType(p_asn1_ctx,Handover);
    if (PNULL == p_mobilityFromEUTRACommand_r9->purpose.u.handover)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,
                "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                "Memory allocation failed for IEs_purpose_handover");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    asn1Init_Handover(p_mobilityFromEUTRACommand_r9->purpose.u.handover);
    /*SPR 8522 Fix stop*/ 
    /* for HO LTE_TO_UTRAN */
    if((HANDOVER_TYPE_LTE_TO_UTRAN == p_rrc_rrm_ho_required->ho_type) ||
            (HANDOVER_TYPE_LTE_TO_GERAN == p_rrc_rrm_ho_required->ho_type) ||
            (HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD == p_rrc_rrm_ho_required->ho_type))
    {
        p_mobilityFromEUTRACommand_r9->purpose.t =
            T_MobilityFromEUTRACommand_r9_IEs_purpose_handover;


        if (HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD != p_rrc_rrm_ho_required->ho_type)
        {
            /* Fill nas_security_param_from_E_UTRAN */
            p_mobilityFromEUTRACommand_r9->purpose.u.handover->
                m.nas_SecurityParamFromEUTRAPresent = 1;

            p_mobilityFromEUTRACommand_r9->purpose.u.handover->
                nas_SecurityParamFromEUTRA.numocts =
                p_s1_src_ho_info->inter_rat_ho_info.nas_security_param_from_E_UTRAN_numocts;

            l3_memcpy_wrapper(&p_mobilityFromEUTRACommand_r9->purpose.u.handover->
                    nas_SecurityParamFromEUTRA.data,
                    p_s1_src_ho_info->inter_rat_ho_info.
                    p_nas_security_param_from_E_UTRAN_data,
                    p_s1_src_ho_info->inter_rat_ho_info.
                    nas_security_param_from_E_UTRAN_numocts); 
        }
    }

    if(HANDOVER_TYPE_CCO == p_rrc_rrm_ho_required->ho_type)
    {
        p_mobilityFromEUTRACommand_r9->purpose.t =
            T_MobilityFromEUTRACommand_r9_IEs_purpose_cellChangeOrder;
        p_mobilityFromEUTRACommand_r9->purpose.u.cellChangeOrder =
            rtxMemAllocType(p_asn1_ctx,CellChangeOrder);
        if (PNULL == p_mobilityFromEUTRACommand_r9->purpose.u.cellChangeOrder)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL, "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                    "Memory allocation failed for IEs_purpose_cellChangeOrder");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        asn1Init_CellChangeOrder(p_mobilityFromEUTRACommand_r9->purpose.u.cellChangeOrder);

        p_mobilityFromEUTRACommand_r9->purpose.u.cellChangeOrder->t304 = 
            p_rrc_rrm_ho_required->mobility_control_info.t304_timer;

        if (RRC_SUCCESS != uecc_s1ap_fill_cellChangeOrder_targetRAT_Type(p_asn1_ctx,
                    p_ue_context,
                    &p_rrc_rrm_ho_required->cco_params.target_rat_params,
                    &p_mobilityFromEUTRACommand_r9->purpose.u.cellChangeOrder->targetRAT_Type))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL, "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                    "uecc_s1ap_fill_cellChangeOrder_targetRAT_Type failed.");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }

    /* for HO LTE_TO_UTRAN */
    if(HANDOVER_TYPE_LTE_TO_UTRAN == p_rrc_rrm_ho_required->ho_type)
    {
        p_mobilityFromEUTRACommand_r9->purpose.u.handover->
            targetRAT_Type = TARGET_RAT_TYPE_UTRA;
        p_mobilityFromEUTRACommand_r9->purpose.u.handover->m.systemInformationPresent = 0;
        p_mobilityFromEUTRACommand_r9->purpose.u.handover->
            targetRAT_MessageContainer.numocts =
            p_s1_src_ho_info->inter_rat_ho_info.target_to_source_transparent_container_numocts;

        p_data = rtxMemAlloc(p_asn1_ctx,p_mobilityFromEUTRACommand_r9->
                purpose.u.handover->targetRAT_MessageContainer.numocts);
        /* SPR 12964 Fix Start */
        if(PNULL == p_data)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "Mem Alloc failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        /* SPR 12964 Fix Stop */
        l3_memcpy_wrapper(p_data, 
                p_s1_src_ho_info->inter_rat_ho_info.
                p_target_to_source_transparent_container_data,
                p_mobilityFromEUTRACommand_r9->purpose.u.handover->
                targetRAT_MessageContainer.numocts);
        p_mobilityFromEUTRACommand_r9->purpose.u.handover->
            targetRAT_MessageContainer.data = p_data;
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,
                "[uecc_s1ap_fillMobilityFromEUTRACommand] "
                "Copied %d bytes to targetRAT Message Container",
                p_s1_src_ho_info->inter_rat_ho_info.target_to_source_transparent_container_numocts);
    }

    /* for HO LTE_TO_GERAN */
    else if(HANDOVER_TYPE_LTE_TO_GERAN == p_rrc_rrm_ho_required->ho_type)
    {
        p_mobilityFromEUTRACommand_r9->purpose.u.handover->targetRAT_Type =
            TARGET_RAT_TYPE_GERAN;
        if(RRC_SUCCESS != uecc_s1ap_fillMobilityFromEUTRACommand_r9_lte_to_geran(p_ue_context, 
                    p_mobilityFromEUTRACommand_r9, p_rrc_rrm_ho_required, p_s1_src_ho_info, p_asn1_ctx))
        {
            return RRC_FAILURE;
        }
    }
    /* for HO LTE_TO_UTRAN */
    else if(HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD == p_rrc_rrm_ho_required->ho_type)
    {
        p_mobilityFromEUTRACommand_r9->purpose.u.handover->
            targetRAT_Type = TARGET_RAT_TYPE_CDMA2000_HRPD;

        p_mobilityFromEUTRACommand_r9->purpose.u.handover->m.systemInformationPresent = 0;

        p_mobilityFromEUTRACommand_r9->purpose.u.handover->targetRAT_MessageContainer = 
            p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_hrpd.cdma2000_pdu; 
        /*free context*/
        if (PNULL != p_ue_context->cdma2000_info.
                dl_s1_cdma2000_tunneling_hrpd.cdma2000_pdu.data)
        {
            rrc_mem_free((void *)p_ue_context->cdma2000_info.
                    dl_s1_cdma2000_tunneling_hrpd.cdma2000_pdu.data);

            p_ue_context->cdma2000_info.
                dl_s1_cdma2000_tunneling_hrpd.cdma2000_pdu.data = PNULL ;       
        }

    }
    else if((HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT == p_rrc_rrm_ho_required->ho_type)||
            (HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD == p_rrc_rrm_ho_required->ho_type))
    {
        if(HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT == p_rrc_rrm_ho_required->ho_type)
        {
            p_mobilityFromEUTRACommand_r9->purpose.u.handover->
                targetRAT_Type = TARGET_RAT_TYPE_CDMA2000_1XRTT;
        }
        p_mobilityFromEUTRACommand_r9->purpose.t =
            T_MobilityFromEUTRACommand_r9_IEs_purpose_e_CSFB_r9;

        p_mobilityFromEUTRACommand_r9->purpose.u.e_CSFB_r9 =
            rtxMemAllocType(p_asn1_ctx,E_CSFB_r9);
        if (PNULL == p_mobilityFromEUTRACommand_r9->purpose.u.e_CSFB_r9)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,
                    "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                    "Memory allocation failed for IEs_purpose_e_CSFB_r9");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        asn1Init_E_CSFB_r9(p_mobilityFromEUTRACommand_r9->purpose.u.e_CSFB_r9);

        /*Filling MobilityFromEUTRACommand_r9_IEs_purpose*/ 
        if(RRC_SUCCESS != uecc_s1ap_fillMobilityFromEUTRACommand_r9_purpose_e_csfb(
                    p_ue_context,
                    p_mobilityFromEUTRACommand_r9->purpose.u.e_CSFB_r9,
                    /*SPR 17777 +-*/
                    p_asn1_ctx,
                    p_rrc_rrm_ho_required))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"[uecc_s1ap_fillMobilityFromEUTRACommand_r9]"
                    "uecc_s1ap_fillMobilityFromEUTRACommand_r9 Failed "
                    "for release 9");
            return RRC_FAILURE;

        }
    }
    /* TRACE_fix */
    /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated)
    {
        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), UU,"<ie name=\"Target RAT Type\">%d</ie>",
                p_mobilityFromEUTRACommand_r9->purpose.u.handover->targetRAT_Type);  
        /*SPR 15896 Fix Stop*/
    }  
    /* TRACE_fix */

    /* Encode the message and then store into UE Context buffer */
    /*SPR 20886 Fix Start*/
    pu_setBuffer(p_asn1_ctx,p_data_buffer,UECC_MAX_ASN1_BUF_LEN,ASN_RRC_BUF_TYPE);
    /*SPR 20886 Fix Stop*/
    if(RT_OK != asn1PE_DL_DCCH_Message(p_asn1_ctx,msg))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,
                "[fillMobilityFromEUTRACommand]DL_DCCH_Message Encoding failed");

        /*SPR 20886 Fix Start*/
        char buff[500];
        rtxErrGetTextBuf(p_asn1_ctx,buff ,500);
        /*SPR 20886 Fix Stop*/
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    else
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO,
                "RRC_MSG: HandoverFromEUTRAPreparationRequest %s",
                change_data_to_str((U16)pe_GetMsgLen(p_asn1_ctx), p_data_buffer));
        rrc_asn1PrtToStr_DL_DCCH_Message(RRC_ASN, "DL_DCCH_Message", msg,
                "Handover", p_data_buffer,
                (U16)pe_GetMsgLen(p_asn1_ctx));
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
} 
/****************************************************************************
* Function Name  : uecc_s1ap_fillMobilityFromEUTRACommand_r9_purpose_e_csfb 
* Inputs         : uecc_ue_context_t*  p_ue_context
*                  E_CSFB_r9                         *p_e_csfb_r9
*                  U8                               *p_data_buffer
*                  OSCTXT                           *p_asn1_ctx
*                  rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required
* Outputs        : None
* Returns        : None
* Description    : This is the function to fill MobilityFromEUTRACommand 
*                  r9_IEs_purpose 
*                  which is used in the case of inter Rat HO
****************************************************************************/
rrc_return_et uecc_s1ap_fillMobilityFromEUTRACommand_r9_purpose_e_csfb
(
    uecc_ue_context_t*                p_ue_context,
    E_CSFB_r9                         *p_e_csfb_r9,
    /*SPR 17777 +-*/
    OSCTXT                           *p_asn1_ctx,
    rrc_rrm_ho_required_t   *p_rrc_rrm_ho_required
)
{
    /* coverity_fix_54698_start */
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_rrc_rrm_ho_required);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    p_e_csfb_r9->m.messageContCDMA2000_1XRTT_r9Present = 0;
    p_e_csfb_r9->m.mobilityCDMA2000_HRPD_r9Present = 0;
    p_e_csfb_r9->m.messageContCDMA2000_HRPD_r9Present = 0;
    p_e_csfb_r9->m.redirectCarrierCDMA2000_HRPD_r9Present = 0;

    if(HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT == p_rrc_rrm_ho_required->ho_type)
    {
        p_e_csfb_r9->m.messageContCDMA2000_1XRTT_r9Present = 1;


        p_e_csfb_r9->m.messageContCDMA2000_1XRTT_r9Present = 1;
        /*Copy  the number of octets and data recieved in cdma2000 pdu 
         * from MME in Downlink S1 CDMA2000 tunneling message */

        p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.numocts =
            p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_1xrtt.
            cdma2000_pdu.numocts; 

        p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.data = 
            (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                    p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.numocts);

        if (PNULL== p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.data)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL, 
                    "ASN malloc failed.");
            return RRC_FAILURE; 
        }

        memset_wrapper((void*)p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.data, 0, 
                p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.numocts);

        if((p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_1xrtt.
                    cdma2000_pdu.numocts != 0) 
                &&
                ((p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_1xrtt.
                  cdma2000_pdu.data)!=NULL))
        {
            l3_memcpy_wrapper((void*)p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.data,
                    (p_ue_context->cdma2000_info.
                     dl_s1_cdma2000_tunneling_1xrtt.
                     cdma2000_pdu.data),
                    p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.numocts);
        }
        /*free context*/
        if (PNULL != p_ue_context->cdma2000_info.
                dl_s1_cdma2000_tunneling_1xrtt.cdma2000_pdu.data)
        {
            rrc_mem_free((void *)p_ue_context->cdma2000_info.
                    dl_s1_cdma2000_tunneling_1xrtt.cdma2000_pdu.data);

            p_ue_context->cdma2000_info.
                dl_s1_cdma2000_tunneling_1xrtt.cdma2000_pdu.data = PNULL ;       
        }
    }
    else if(HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD == p_rrc_rrm_ho_required->ho_type)
    {
        /*(1) Downlink s1 cdma message comes for 1xrtt or timer is expired for hrpd*/ 
        if((HO_SUCCESS == 
                    p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_1xrtt.cdma2000_ho_status)  
                &&
                (RRC_FALSE == p_ue_context->cdma2000_info.timer_expired_f_1xrtt)) 
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,RRC_INFO,
                    "CDMA: ho_status is success for 1xrtt");

            /*Filling the 1xrtt container with dl_s1_cdma200_1xrtt container*/
            p_e_csfb_r9->m.messageContCDMA2000_1XRTT_r9Present = 1;

            /*Copy  the number of octets and data recieved in cdma2000 pdu 
             * from MME in Downlink S1 CDMA2000 tunneling message */

            p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.numocts =
                p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_1xrtt.
                cdma2000_pdu.numocts; 

            p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.data = 
                (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                        p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.numocts);

            if (PNULL== p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.data)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL, 
                        "ASN malloc failed.");

                return RRC_FAILURE;
            } 

            memset_wrapper((void*)p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.data, 0, 
                    p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.numocts);

            if((p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_1xrtt.
                        cdma2000_pdu.numocts != 0) 
                    &&
                    (&(p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_1xrtt.
                       cdma2000_pdu.data)!=NULL))
            {
                l3_memcpy_wrapper((void*)p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.data,
                        (void *)(p_ue_context->cdma2000_info.
                            dl_s1_cdma2000_tunneling_1xrtt.
                            cdma2000_pdu.data),
                        p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.numocts);
            }

            if((RRC_TRUE == p_ue_context->cdma2000_info.timer_expired_f_hrpd)
                    ||
                    (HO_FAILURE == 
                     p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_hrpd.cdma2000_ho_status))
            {

                if(RRC_TRUE == p_ue_context->cdma2000_info.redirection_present_f_hrpd)
                {
                    p_e_csfb_r9->m.mobilityCDMA2000_HRPD_r9Present = 1;
                    p_e_csfb_r9->mobilityCDMA2000_HRPD_r9 = redirection;

                    p_e_csfb_r9->m.redirectCarrierCDMA2000_HRPD_r9Present = 1;
                    p_e_csfb_r9->redirectCarrierCDMA2000_HRPD_r9.bandClass = 
                        p_ue_context->cdma2000_info.carrier_freq_cdma2000.band_class; 
                    p_e_csfb_r9->redirectCarrierCDMA2000_HRPD_r9.arfcn = 
                        p_ue_context->cdma2000_info.carrier_freq_cdma2000.arfcn; 
                }

                if((HO_FAILURE == 
                            p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_hrpd.cdma2000_ho_status)
                        &&
                        (RRC_FALSE == p_ue_context->cdma2000_info.redirection_present_f_hrpd))
                {
                    p_e_csfb_r9->m.mobilityCDMA2000_HRPD_r9Present = 1;
                    p_e_csfb_r9->mobilityCDMA2000_HRPD_r9 = handover;

                    /*Filling the hrpd container with dl_s1_cdma200_hrpd container*/
                    p_e_csfb_r9->m.messageContCDMA2000_HRPD_r9Present = 1;
                    p_e_csfb_r9->messageContCDMA2000_HRPD_r9.numocts =
                        p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_hrpd.
                        cdma2000_pdu.numocts; 

                    p_e_csfb_r9->messageContCDMA2000_HRPD_r9.data = 
                        (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                                p_e_csfb_r9->messageContCDMA2000_HRPD_r9.numocts);

                    if (PNULL== p_e_csfb_r9->messageContCDMA2000_HRPD_r9.data)
                    {
                        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                (p_ue_context->p_gb_context)->facility_name,
                                RRC_FATAL, 
                                "ASN malloc failed.");

                        return RRC_FAILURE;
                    } 

                    memset_wrapper((void*)p_e_csfb_r9->messageContCDMA2000_HRPD_r9.data, 0, 
                            p_e_csfb_r9->messageContCDMA2000_HRPD_r9.numocts);

                    if((p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_hrpd.
                                cdma2000_pdu.numocts != 0) 
                            &&
                            (&(p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_hrpd.
                               cdma2000_pdu.data)!=NULL))
                    {
                        l3_memcpy_wrapper((void*)p_e_csfb_r9->messageContCDMA2000_HRPD_r9.data,
                                (void *)(p_ue_context->cdma2000_info.
                                    dl_s1_cdma2000_tunneling_hrpd.
                                    cdma2000_pdu.data),
                                p_e_csfb_r9->messageContCDMA2000_HRPD_r9.numocts);
                    }

                }
            }

        }
        if ((HO_SUCCESS == 
                    p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_hrpd.cdma2000_ho_status)
                &&
                (RRC_FALSE == p_ue_context->cdma2000_info.timer_expired_f_hrpd))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,RRC_INFO,
                    "CDMA: ho_status is success for hrpd");

            /*Filling mobility: mobility is handover in the case*/
            p_e_csfb_r9->m.mobilityCDMA2000_HRPD_r9Present = 1;
            p_e_csfb_r9->mobilityCDMA2000_HRPD_r9 = handover;

            /*Filling the hrpd container with dl_s1_cdma200_hrpd container*/
            p_e_csfb_r9->m.messageContCDMA2000_HRPD_r9Present = 1;

            p_e_csfb_r9->messageContCDMA2000_HRPD_r9.numocts =
                p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_hrpd.
                cdma2000_pdu.numocts; 

            p_e_csfb_r9->messageContCDMA2000_HRPD_r9.data = 
                (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                        p_e_csfb_r9->messageContCDMA2000_HRPD_r9.numocts);

            if (PNULL== p_e_csfb_r9->messageContCDMA2000_HRPD_r9.data)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL, 
                        "ASN malloc failed.");

                return RRC_FAILURE;
            } 

            memset_wrapper((void*)p_e_csfb_r9->messageContCDMA2000_HRPD_r9.data, 0, 
                    p_e_csfb_r9->messageContCDMA2000_HRPD_r9.numocts);

            if((p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_hrpd.
                        cdma2000_pdu.numocts != 0) 
                    &&
                    (&(p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_hrpd.
                       cdma2000_pdu.data)!=NULL))
            {
                l3_memcpy_wrapper((void*)p_e_csfb_r9->messageContCDMA2000_HRPD_r9.data,
                        (void *)(p_ue_context->cdma2000_info.
                            dl_s1_cdma2000_tunneling_hrpd.
                            cdma2000_pdu.data),
                        p_e_csfb_r9->messageContCDMA2000_HRPD_r9.numocts);
            }

            if(HO_FAILURE == 
                    p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_1xrtt.cdma2000_ho_status)
            {
                /*Filling the 1xrtt container with dl_s1_cdma200_1xrtt container*/
                p_e_csfb_r9->m.messageContCDMA2000_1XRTT_r9Present = 1;

                /*Copy  the number of octets and data recieved in cdma2000 pdu 
                 * from MME in Downlink S1 CDMA2000 tunneling message */

                p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.numocts =
                    p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_1xrtt.
                    cdma2000_pdu.numocts; 

                p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.data = 
                    (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                            p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.numocts);

                if (PNULL== p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.data)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_FATAL, 
                            "ASN malloc failed.");

                    return RRC_FAILURE;
                } 

                memset_wrapper((void*)p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.data, 0, 
                        p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.numocts);

                if((p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_1xrtt.
                            cdma2000_pdu.numocts != 0) 
                        &&
                        (&(p_ue_context->cdma2000_info.dl_s1_cdma2000_tunneling_1xrtt.
                           cdma2000_pdu.data)!=NULL))
                {
                    l3_memcpy_wrapper((void*)p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.data,
                            (void *)(p_ue_context->cdma2000_info.
                                dl_s1_cdma2000_tunneling_1xrtt.
                                cdma2000_pdu.data),
                            p_e_csfb_r9->messageContCDMA2000_1XRTT_r9.numocts);
                }


            }
            else if (RRC_TRUE == p_ue_context->cdma2000_info.timer_expired_f_1xrtt) 
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_INFO, 
                        "cdma2000_info.timer_expired_f_1xrtt is present");
            }

        }

        /*free context*/
        if (PNULL != p_ue_context->cdma2000_info.
                dl_s1_cdma2000_tunneling_1xrtt.cdma2000_pdu.data)
        {
            rrc_mem_free((void *)p_ue_context->cdma2000_info.
                    dl_s1_cdma2000_tunneling_1xrtt.cdma2000_pdu.data);

            p_ue_context->cdma2000_info.
                dl_s1_cdma2000_tunneling_1xrtt.cdma2000_pdu.data = PNULL ;       
        }

        /*free context*/
        if (PNULL != p_ue_context->cdma2000_info.
                dl_s1_cdma2000_tunneling_hrpd.cdma2000_pdu.data)
        {
            rrc_mem_free((void *)p_ue_context->cdma2000_info.
                    dl_s1_cdma2000_tunneling_hrpd.cdma2000_pdu.data);

            p_ue_context->cdma2000_info.
                dl_s1_cdma2000_tunneling_hrpd.cdma2000_pdu.data = PNULL ;       
        }


    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}
/* coverity_fix_54698_stop */

/* cr_726 new function introduced */
/****************************************************************************
 *** Function Name  : check_trace_id_validity
 *** Inputs         : U8   index
 ***                  U8   octateValue
 *** Outputs        : None
 *** Returns        : rrc_return_et
 *** Description    : Check the validity of PLMN
 ******************************************************************************/
rrc_return_et check_trace_id_validity(U8 index, U8 octateValue)
{
    rrc_return_et result = RRC_FAILURE;

    switch (index)
    {
        case 0:
        case 2:
            /* Check the first Octate */
            if (((octateValue & 0x0F) <= MAX_TRACE_ID_VAL) &&
                    ((octateValue >> 0x04) <= MAX_TRACE_ID_VAL))
            {
                result = RRC_SUCCESS;
            }
            break;
        case 1:
            /* Check the second Octate*/
            /* check for the filler bit at second nibble */            
            if (((octateValue & 0x0F) <= MAX_TRACE_ID_VAL) &&
                    (((octateValue >> 0x04) == 0xF) ||
                     ((octateValue >> 0x04) <= MAX_TRACE_ID_VAL)))
            {
                result = RRC_SUCCESS;
            }
            break;
        default:
            {
                result = RRC_FAILURE;
            }
    }
    return result;
}

/* SPR 1643 Start */
/****************************************************************************
 * Function Name  : validate_ho_restriction_list_plmn_identity 
 * Inputs         : p_s1ap_HandoverRestrictionList  - pointer points to
 *                  Handover retriction list recived in ICS/Downlink
 *                  NAS.
 *                  uecc_gb_context_t            *p_uecc_gb_context
 * Outputs        : None 
 * Returns        : RRC_SUCCESS/RRC_FAILURE
 * Description    : This function validates PLMN identiy range
 *                  received in Initial Context Setup Request.
 ****************************************************************************/
static rrc_return_et validate_ho_restriction_list_plmn_identity
(
    s1ap_HandoverRestrictionList * p_s1ap_HandoverRestrictionList,
    uecc_gb_context_t            *p_uecc_gb_context  /* UECC global context */
)
{
    OSRTDListNode*      p_node = PNULL;
    U16 count = 0;

    /* Serving PLMN */
    if ( p_s1ap_HandoverRestrictionList->
            servingPLMN.numocts == MAX_NUM_OCTETS )
    {
        if (RRC_FAILURE == 
                is_valid_plmn_identity(p_s1ap_HandoverRestrictionList->
                    servingPLMN.data ))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "PLMN ID Range Check Fail - Serving PLMN");
            return RRC_FAILURE;
        }
    }
    else
    {
       RRC_UECC_TRACE(p_uecc_gb_context->context_index,
               p_uecc_gb_context->facility_name,
               RRC_WARNING,
               "PLMN ID : Number of octets not equal to 3 - Serving PLMN.");
       return RRC_FAILURE;
    }

    /* Equivalent PLMNs */
    if (p_s1ap_HandoverRestrictionList->m.equivalentPLMNsPresent) 
    {
        for (count =0; 
             count < p_s1ap_HandoverRestrictionList->equivalentPLMNs.n; 
             count++)
        {    
            if (p_s1ap_HandoverRestrictionList->equivalentPLMNs.
                    elem[count].numocts == MAX_NUM_OCTETS )    
            {
                if (RRC_FAILURE == 
                        is_valid_plmn_identity(p_s1ap_HandoverRestrictionList->
                            equivalentPLMNs.elem[count].data))
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "PLMN ID Range Check Fail for Index [%d] - Equivalent PLMNs",count);
                    return RRC_FAILURE;
                }
            }
            else
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "PLMN ID : Number of octets not equal to 3, for Index [%d] -" 
                        "Equivalent PLMNs",count);
                return RRC_FAILURE;
            }
        }
    }

    /* ForbiddenTAs */
    if (p_s1ap_HandoverRestrictionList->m.forbiddenTAsPresent) 
    {
        p_node = p_s1ap_HandoverRestrictionList->forbiddenTAs.head;
        for (count =0; count < 
                p_s1ap_HandoverRestrictionList->forbiddenTAs.count;
                count++)
        {
            RRC_ASSERT(PNULL != p_node);
            RRC_ASSERT(PNULL != p_node->data);
            if (((s1ap_ForbiddenTAs_Item*)p_node->data)->pLMN_Identity.numocts
                     == MAX_NUM_OCTETS )    
            {
                if (RRC_FAILURE == 
                        is_valid_plmn_identity(((s1ap_ForbiddenTAs_Item*)p_node->data)->
                            pLMN_Identity.data))
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "PLMN ID Range Check Fail for Index [%d] - ForbiddenTAs",count);
                    return RRC_FAILURE;
                }
            }
            else
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "PLMN ID : Number of octets not equal to 3, for Index [%d] - "
                        "ForbiddenTAs",count);
                return RRC_FAILURE;
            }
            p_node = p_node->next;
        }
    }

    /* ForbiddenLAs */
    if (p_s1ap_HandoverRestrictionList->m.forbiddenLAsPresent)
    {
        p_node = p_s1ap_HandoverRestrictionList->forbiddenLAs.head;
        for (count =0; count < 
                p_s1ap_HandoverRestrictionList->forbiddenLAs.count;
                count++)
        {
            RRC_ASSERT(PNULL != p_node);
            RRC_ASSERT(PNULL != p_node->data);
            if (((s1ap_ForbiddenLAs_Item*)p_node->data)->pLMN_Identity.numocts
                     == MAX_NUM_OCTETS )    
            {
                if (RRC_FAILURE == 
                        is_valid_plmn_identity(((s1ap_ForbiddenLAs_Item*)p_node->data)->
                            pLMN_Identity.data))
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "PLMN ID Range Check Fail for Index [%d] - ForbiddenLAs",count);
                    return RRC_FAILURE;
                }
            }
            else
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "PLMN ID : Number of octets not equal to 3, for Index [%d] - "
                        "ForbiddenLAs",count);
                return RRC_FAILURE;
            }
            p_node = p_node->next;
        }
    }

    return RRC_SUCCESS;
}


/* added*/

/****************************************************************************
 * Function Name  : validate_source_to_target_transparent_container_plmn_identity
 * Inputs         : p_source_enb_to_target_enb_transparent_container pointer
 * points to
 *                  source_enb_to_target_enb_transparent_container recived in
 *                  Handover Request.
 *                  uecc_gb_context_t   *p_uecc_gb_context
 * Outputs        : None
 * Returns        : RRC_SUCCESS/RRC_FAILURE
 * Description    : This function validates PLMN identiy range
 *                  received in source_enb_to_target_enb_transparent_container
 *                  in
 *                  Handover Request.
 ****************************************************************************/
static rrc_return_et
validate_source_to_target_transparent_container_plmn_identity
(
 rrc_source_enb_to_target_enb_transparent_container_t*
 p_source_enb_to_target_enb_transparent_container,
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
  U8 ue_history_info_count = 0;

  /* targetCell_ID PLMN */
  if ( p_source_enb_to_target_enb_transparent_container->
      targetCell_ID.pLMNidentity.numocts == MAX_NUM_OCTETS )
  {
    if (RRC_FAILURE ==
        is_valid_plmn_identity(p_source_enb_to_target_enb_transparent_container->
          targetCell_ID.pLMNidentity.data))
    {
      RRC_UECC_TRACE(p_uecc_gb_context->context_index,
          p_uecc_gb_context->facility_name,
          RRC_WARNING,
          "PLMN ID Range Check Fail - targetCell_ID");
      return RRC_FAILURE;
    }
  }
  else
  {
    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
        p_uecc_gb_context->facility_name,
        RRC_WARNING,
        "PLMN ID : Number of octets not equal to 3 - targetCell_ID.");
    return RRC_FAILURE;
  }

  /* ue_HistoryInformation.lastVisited_cell_item[].e_UTRAN_Cell->global_Cell_ID PLMN */
  for(ue_history_info_count = 0; ue_history_info_count <
      (p_source_enb_to_target_enb_transparent_container->ue_HistoryInformation.count);
      ue_history_info_count++)
  {
    if(1 ==
        p_source_enb_to_target_enb_transparent_container->ue_HistoryInformation.lastVisited_cell_item[ue_history_info_count].t)
    {

      if ( p_source_enb_to_target_enb_transparent_container->
          ue_HistoryInformation.lastVisited_cell_item[ue_history_info_count].u.
          e_UTRAN_Cell->global_Cell_ID.pLMNidentity.numocts ==
          MAX_NUM_OCTETS )
      {
        if (RRC_FAILURE ==
            is_valid_plmn_identity(p_source_enb_to_target_enb_transparent_container->
              ue_HistoryInformation.lastVisited_cell_item[ue_history_info_count].u.
              e_UTRAN_Cell->global_Cell_ID.pLMNidentity.data))
        {
          RRC_UECC_TRACE(p_uecc_gb_context->context_index,
              p_uecc_gb_context->facility_name,
              RRC_WARNING,
              "PLMN ID Range Check Fail - ue_HistoryInformation.lastVisited_cell_item[].e_UTRAN_Cell->global_Cell_ID");
          return RRC_FAILURE;
        }
      }
      else
      {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_WARNING,
            "PLMN ID : Number of octets not equal to 3 - ue_HistoryInformation.lastVisited_cell_item[].e_UTRAN_Cell->global_Cell_ID.");
        return RRC_FAILURE;
      }
    }
  }
  return RRC_SUCCESS;
}

/* SPR 1643 Stop*/


/******************************************************************************
 *   FUNCTION NAME: validate_gummei_and_fill_mme_id
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  s1ap_gummei_t*          p_gummei
 *                  U32                     *mme_id
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function validate gummei and fill mme_id
 *
 *   RETURNS:
 *       rrc_return_et
 *
 ******************************************************************************/
rrc_return_et validate_gummei_and_fill_mme_id
(
 uecc_ue_context_t*      p_ue_context,
 s1ap_gummei_t*          p_gummei,      
 U32                     *mme_id   
 )
{
    U8 mme_count = 0;
    rrc_return_et retVal = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    for(; mme_count<MAX_NUM_MME; mme_count++)
    {
        if (!memcmp_wrapper(p_gummei,
                    &(p_ue_context->p_gb_context->mme_ctx[mme_count].gummei),
                    sizeof(s1ap_gummei_t)))
        {
            *mme_id = p_ue_context->p_gb_context->mme_ctx[mme_count].mme_id;
            retVal = RRC_SUCCESS;
            break;
        }
    }
    if(RRC_FAILURE == retVal)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "gummei info doesn't match.");
        return retVal;
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return retVal;
}
/*x2ap-start*/

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_path_switch_request
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context,
 *                  U8                      mme_id
 *
 *   OUTPUTS      : None
 *   DESCRIPTION  : This function builds and sends s1ap_PathSwitchRequest 
 *                  message to S1AP module.
 *
 *   RETURNS      : rrc_return_et
 ******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_path_switch_request
(
 uecc_ue_context_t*      p_ue_context,
/* Bug 8198 Fix Start */
  U8   mme_id
/* Bug 8198 Fix End */
 )
{
    rrc_return_et result = RRC_FAILURE;
    OSCTXT asn1_ctx;
    rrc_s1ap_path_switch_request_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;
    U8 rel_of_mme = 0;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    if (RRC_FALSE == p_ue_context->p_gb_context->mme_connection_status)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "[s1ap_PathSwitchRequest] MME connection isn't present");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

/*Bug_12255_start*/
/*    if ( !p_ue_context->m.mme_ue_id_present )
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "[s1ap_PathSwitchRequest] MME isn't ready");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }*/
/*Bug_12255_stop*/
    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_PathSwitchRequest] ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Is trace activated */
        if (p_ue_context->m.traceActivated)
        {
            /*SPR 15875 Fix Start*/
        /*SPR 15896 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1))
        {
                P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(),GEN_MME,
                        "\n<msg function=\"S1AP\" name=\"Path Switch Request\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1))
        {
                P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(),GEN_CELL,
                        "\n<msg function=\"S1AP\" name=\"Path Switch Request\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
            /*SPR 15875 Fix Stop*/
            //Trace Change Start
            P_RRC_TRACE(p_ue_context, set_all_trace_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
                p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
        /*SPR 15896 Fix Stop*/
            //Trace Change End
        }
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */
        /*eNB UE S1AP ID*/
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
        
        /* Bug 897 Fix Stop */
        /*Source MME UE S1AP ID*/
        //msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.mme_ue_s1ap_id =  p_ue_context->mme_ue_id;
        /* Bug 897 Fix Stop */

/* Bug 8198 Fix Start */
        rel_of_mme  = p_ue_context->p_gb_context->mme_ctx[mme_id].connection_info.rel_of_mme;
/* Bug 8198 Fix End */

        /*36413_CR0798_start*/
        if (RRC_MME_REL10 <= rel_of_mme) 
        {
            msg.bitmask |=
            RRC_S1AP_PATH_SWITCH_REQUEST_SOURCE_GUMMEI_PRESENT;
            msg.gummei.pLMN_Identity = p_ue_context->gummei.plmn_identity;
            msg.gummei.mME_Group_ID = p_ue_context->gummei.grp_id;
            msg.gummei.mME_Code = p_ue_context->gummei.mme_code;
        }
        /*36413_CR0798_stop*/


        /*E_RAB To Be Switched DL List*/
        if (RRC_SUCCESS != uecc_s1ap_build_s1ap_erab_to_be_switched_dl_list ( 
                    p_ue_context, &asn1_ctx, &msg.erab_to_be_switched_dl_list))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_PathSwitchRequest]"
                    "uecc_s1ap_build_s1ap_erab_to_be_switched_dl_list failure");

            break;
        }

        /* TAI */
        /* tai.pLMNidentity should be the same as eutran_cgi.pLMNidentity*/
        uecc_s1ap_generate_plmn_identity_int(
                msg.tai.pLMNidentity.data,
                &p_ue_context->plmn_identity.plmn_identity);   /*Mukesh*/
        msg.tai.pLMNidentity.numocts = sizeof(msg.tai.pLMNidentity.data);


        /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated) 
        {
            /* SPR:5903 start */
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"TAI-pLMNidentity\">%02x%02x%02x</ie>",
                                            msg.tai.pLMNidentity.data[0],msg.tai.pLMNidentity.data[1],msg.tai.pLMNidentity.data[2]);
        /*SPR 15896 Fix Stop*/
            /* SPR:5903 stop */
        }

        if (PNULL != p_ue_context->p_gb_context->p_p_csc_context)
        {
            if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                    [p_ue_context->cell_index])
            {
                if (PNULL != p_ue_context->p_gb_context->p_p_csc_context
                        [p_ue_context->cell_index]->p_csc_init_setup_ind)
                {
                    /* tai.tAC */
                    RRC_ASSERT(sizeof(msg.tai.tAC.data) ==
                            sizeof(p_ue_context->p_gb_context->p_p_csc_context[
                                p_ue_context->cell_index]->p_csc_init_setup_ind->
                                sib_type_1_Info.
                                cell_access_related_info.tac));
                    l3_memcpy_wrapper(msg.tai.tAC.data,
                            p_ue_context->p_gb_context->p_p_csc_context[
                            p_ue_context->cell_index]->p_csc_init_setup_ind->
                            sib_type_1_Info.
                            cell_access_related_info.tac,
                            sizeof(msg.tai.tAC.data));
                    msg.tai.tAC.numocts = sizeof(msg.tai.tAC.data);

        /*SPR 15896 Fix Start*/
                    if (p_ue_context->m.traceActivated) 
                    {
            /* SPR:5903 start */
                        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"TAI-tac\">%02x%02x</ie>",
                                msg.tai.tAC.data[0],msg.tai.tAC.data[1]);
        /*SPR 15896 Fix Stop*/
            /* SPR:5903 stop */

                    }

                    /* EUTRAN_CGI */
                    /* eutran_cgi.pLMNidentity */
                    msg.eutran_cgi.pLMNidentity.numocts =
                        sizeof(msg.eutran_cgi.pLMNidentity.data); /*3*/
                    /* eutran_cgi.pLMNidentity */
                    uecc_s1ap_generate_plmn_identity_int(
                            msg.eutran_cgi.pLMNidentity.data,
                            &p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->
                            cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.plmn_Id_info_list.
                            plmn_identity_info[0].plmn_identity);  

        /*SPR 15896 Fix Start*/
                    if (p_ue_context->m.traceActivated ) 
                    {
            /* SPR:5903 start */
                        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n<ie name=\"E-UTRAN CGI-pLMNidentity\">%02x%02x%02x</ie>",
                                msg.eutran_cgi.pLMNidentity.data[0],msg.eutran_cgi.pLMNidentity.data[1],msg.eutran_cgi.pLMNidentity.data[2]);
        /*SPR 15896 Fix Stop*/
            /* SPR:5903 stop */
                    }


                    /* eutran_cgi.cell_ID */
                    /* 28 bits */
                    RRC_ASSERT(sizeof(msg.eutran_cgi.cell_ID.data) ==
                            sizeof(p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->
                                cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                                cell_access_related_info.cell_Id));
                    l3_memcpy_wrapper(msg.eutran_cgi.cell_ID.data,
                            p_ue_context->p_gb_context->p_p_csc_context[p_ue_context->
                            cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.cell_Id,
                            sizeof(msg.eutran_cgi.cell_ID.data));
                    msg.eutran_cgi.cell_ID.numbits = RRC_CELL_IDENTITY_BITS;
            /*36413_CR0798_start*/
                    /* csg_id */

                    if (RRC_MME_REL10 <= rel_of_mme) 
                    {
                        if (CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG &
                            p_ue_context->p_gb_context->p_p_csc_context[
                            p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.presence_bitmask)
                        {
                            msg.bitmask |= RRC_S1AP_PATH_SWITCH_REQUEST_CSG_ID_PRESENT;

                            RRC_ASSERT(sizeof(msg.csg_id.data) ==
                                   sizeof(p_ue_context->p_gb_context->p_p_csc_context[
                                        p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                                        cell_access_related_info.csg_identity));
                            l3_memcpy_wrapper(msg.csg_id.data,
                                    p_ue_context->p_gb_context->p_p_csc_context[
                                    p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                                    cell_access_related_info.csg_identity,
                                    sizeof(msg.csg_id.data));
                            msg.csg_id.data[CSG_ID_OCTET_SIZE-1] &= CSG_RESET_VAL;
                            msg.csg_id.numbits = RRC_CSG_ID_BITS;
                        }

                        /* cell Access Mode */
                        /* If Cell_indication false but cell broadcast CSG identity then 
                        * Cell is an hybrid cell */
                        if ((CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG &
                            p_ue_context->p_gb_context->p_p_csc_context[
                            p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                            cell_access_related_info.presence_bitmask) && 
                            (p_ue_context->p_gb_context->p_p_csc_context[
                             p_ue_context->cell_index]->p_csc_init_setup_ind->sib_type_1_Info.
                                 cell_access_related_info.csg_indication == RRC_FALSE)
                           )
                        {
                            msg.bitmask |= RRC_S1AP_PATH_SWITCH_REQUEST_CELL_ACCESS_MODE_PRESENT;
                            /* This param indicates cell as an Hybrid cell */
                            msg.cell_access_mode = 0;
                        }
                   /*36413_CR0798_stop*/
                    }
                }
            }
        }
        /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated) 
        {
            /* SPR:5903 start */
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"E-UTRAN CELL_ID\">%02x%02x%02x%x</ie> \n </msg>",
                                            msg.eutran_cgi.cell_ID.data[0],
                                            msg.eutran_cgi.cell_ID.data[1],
                                            msg.eutran_cgi.cell_ID.data[2],
                                            msg.eutran_cgi.cell_ID.data[3]>>4);
        /*SPR 15896 Fix Stop*/
            /* SPR:5903 stop */
        }

        /*UE Security Capabilities*/       
        msg.ue_security_capabilities.encryptionAlgorithms = 
                p_ue_context->ue_security_capabilities.encryptionAlgorithms;

        msg.ue_security_capabilities.integrityProtectionAlgorithms = 
                p_ue_context->ue_security_capabilities.integrityProtectionAlgorithms;
      
        /* Encoe message */
        result=rrc_s1ap_path_switch_request_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],&p_sig_msg_req->message_buff_size,
                &msg);
        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_PathSwitchRequest] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

           rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_PATH_SWITCH_REQUEST,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }


        /* ASN.1 encoded message to logged */
    /*SPR 15896 Fix Start*/
        rrc_trace_max_file_write(p_ue_context, PATH_SWITCH_REQUEST,
                p_sig_msg_req->message_buff_size , &p_sig_msg_req->message_buff_p[0], S1);
    /*SPR 15896 Fix Stop*/

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_PathSwitchRequest;
        p_sig_msg_req->message_type = INITIATING_MESSAGE;
        
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

/* Bug 8198 Fix Start */
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_MME_ID_PRESENT;
        p_sig_msg_req->mme_id = mme_id;
/* Bug 8198 Fix End */
        
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/
        
        /* Send message to S1AP */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
            (p_ue_context->p_gb_context)->facility_name,
            RRC_INFO, "S1AP_MSG: PathSwitchRequest %s",
            change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));
        
    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_s1ap_erab_to_be_switched_dl_list
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT *p_asn1_ctx
 *                  s1ap_E_RABToBeSwitchedDLList *p_erab_to_be_switched_dl_list
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds s1ap_E_RABToBeSwitchedDLList
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_s1ap_erab_to_be_switched_dl_list
(
 uecc_ue_context_t* p_ue_context,
 OSCTXT *p_asn1_ctx,
 s1ap_E_RABToBeSwitchedDLList *p_erab_to_be_switched_dl_list
 )
{
 /*   uecc_ho_drb_forward_info_list_t          
        **pp_erab_trg_ho_forward_list = PNULL;*/
    OSRTDListNode* p_node = PNULL;
    s1ap_E_RABToBeSwitchedDLList_element  *p_elem = PNULL;
    U8 e_rab_index = 0;
    U8 *p_transport_addr = PNULL;



    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_erab_to_be_switched_dl_list);
    RRC_ASSERT(PNULL != p_ue_context->ho_info.p_ho_info);
    RRC_ASSERT(PNULL != p_ue_context->ho_info.p_ho_info->p_trg_ho_info);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    asn1Init_s1ap_E_RABToBeSwitchedDLList(p_erab_to_be_switched_dl_list);


    for (e_rab_index=0; 
            e_rab_index < MAX_ERAB_COUNT; 
            e_rab_index++)
    {
        if (PNULL == p_ue_context->p_e_rab_list[e_rab_index]) 
        {
            continue;
        }

        rtxDListAllocNodeAndData(p_asn1_ctx,
                s1ap_E_RABToBeSwitchedDLList_element,
                &p_node,
                &p_elem);

        if (PNULL == p_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_FATAL,"Can't allocate p_node");

            rtxDListFreeAll (p_asn1_ctx, p_erab_to_be_switched_dl_list);

            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        asn1Init_s1ap_E_RABToBeSwitchedDLList_element(p_elem);
        p_elem->value.u._E_RABToBeSwitchedDLItemIEs_1 =
            (s1ap_E_RABToBeSwitchedDLItem*)rtxMemAlloc(p_asn1_ctx,
                    sizeof(s1ap_E_RABToBeSwitchedDLItem));

        if (PNULL==p_elem->value.u._E_RABToBeSwitchedDLItemIEs_1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "ASN malloc failed.");
            return RRC_FAILURE;
        }
        asn1Init_s1ap_E_RABToBeSwitchedDLItem(p_elem->value.u._E_RABToBeSwitchedDLItemIEs_1);
        p_elem->value.t= T20__E_RABToBeSwitchedDLItemIEs_1;

        p_elem->id = ASN1V_s1ap_id_E_RABToBeSwitchedDLItem;
        p_elem->criticality = s1ap_reject;

        /*e_RAB_ID*/
        p_elem->value.u._E_RABToBeSwitchedDLItemIEs_1->e_RAB_ID = p_ue_context->
            p_e_rab_list[e_rab_index]->uecc_x2ap_drb_ctx.e_RAB_ID;

        /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated) 
        { 

            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"E-RABID\">%d</ie>",p_elem->value.u._E_RABToBeSwitchedDLItemIEs_1->e_RAB_ID);
        /*SPR 15896 Fix Stop*/
        }

        /*transportLayerAddress*/
        p_elem->value.u._E_RABToBeSwitchedDLItemIEs_1->transportLayerAddress.numbits =
                p_ue_context->p_e_rab_list[e_rab_index]->
                transportLayerAddress_self.numbits;

        if(0 ==
                p_elem->value.u._E_RABToBeSwitchedDLItemIEs_1->transportLayerAddress.numbits%RRC_OCTET_SIZE)
        {
            /* p_elem->value.transportLayerAddress.data */
            p_transport_addr
                =
                (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                                      (p_elem->value.u._E_RABToBeSwitchedDLItemIEs_1->transportLayerAddress.numbits)/RRC_OCTET_SIZE);
            if (PNULL ==
                    p_transport_addr)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "[uecc_s1ap_build_s1ap_e_rab_admitted_list] Memory"
                        " allocation failed.");
                break;
            }

            l3_memcpy_wrapper(p_transport_addr,
                       ((void*)p_ue_context->p_e_rab_list[e_rab_index]->
                       transportLayerAddress_self.data),
                       (p_elem->value.u._E_RABToBeSwitchedDLItemIEs_1->transportLayerAddress.numbits)/RRC_OCTET_SIZE);


        }
        else
        {
            /* p_elem->value.transportLayerAddress.data */
            p_transport_addr
                =
                (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                                      ((p_elem->value.u._E_RABToBeSwitchedDLItemIEs_1->transportLayerAddress.numbits)/RRC_OCTET_SIZE)+1);

            if (PNULL ==
                    p_transport_addr)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "[uecc_s1ap_build_s1ap_e_rab_admitted_list] Memory"
                        " allocation failed.");
                break;
            }

            l3_memcpy_wrapper(p_transport_addr,
                       ((void*)p_ue_context->p_e_rab_list[e_rab_index]->
                       transportLayerAddress_self.data),
                       ((p_elem->value.u._E_RABToBeSwitchedDLItemIEs_1->transportLayerAddress.numbits)/RRC_OCTET_SIZE)+1);
        }

        p_elem->value.u._E_RABToBeSwitchedDLItemIEs_1->transportLayerAddress.data = p_transport_addr;

        /*gTP_TEID*/
        p_elem->value.u._E_RABToBeSwitchedDLItemIEs_1->gTP_TEID.numocts = sizeof(rrc_gtp_teid_t);


        rrc_pack_U32(p_elem->value.u._E_RABToBeSwitchedDLItemIEs_1->gTP_TEID.data,
                &p_ue_context->p_e_rab_list[e_rab_index]->teid_self);

        


        /*    p_erab_trg_ho_forward_list[0]; */

        rtxDListAppendNode(
                p_erab_to_be_switched_dl_list,
                p_node);
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return RRC_SUCCESS;
}

/*x2ap-start*/
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_path_switch_request_ack
 *
 *   INPUTS       : S1AP_PDU            *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  U8                  mme_id
 *                  U8                  *p_buff
 *                  U16                 buffer_length 
 *                  U16                 ue_index
 *
 *   OUTPUTS      : None
 *
 *   DESCRIPTION  : This function processes S1AP Path Switch Request Ack message
 *
 *   RETURNS      : None
 ******************************************************************************/
void uecc_s1ap_process_path_switch_request_ack
(
 S1AP_PDU              *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context,  /* UECC global context */
 U8                  mme_id,
 U8                  *p_buff,        /* ASN.1 encoded message */
/*BUG 604 changes start*/ 
 U16                 buffer_length,      /* encoded buf size - just for check*/
 U16                 ue_index
/*BUG 604 changes stop*/ 
 )
{
    uecc_ue_context_t           *p_ue_context = PNULL;
    rrc_s1ap_path_switch_request_ack_t  msg;
    EVENT_EXTERNAL_HEADER       *p_event_header = PNULL;
    U32                         encoded_msglen = 0;
    /*SPR_17718_START*/
    OSRTDListNode*                          p_node = PNULL;
    s1ap_E_RABToBeSwitchedULList_element    *p_erab_to_be_switched_elem = PNULL;
    s1ap_E_RABList_element                  *p_erab_to_be_released_elem = PNULL;
    /*SPR_17718_END*/

    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_ASSERT(PNULL!=p_s1ap_pdu->u.successfulOutcome);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    memset_wrapper(&msg, 0, sizeof(rrc_s1ap_path_switch_request_ack_t));

    do
    {
        if (PNULL==p_s1ap_pdu->u.successfulOutcome->value.u.pathSwitchRequest)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Path Switch Request Ack] "
                    "pathSwitchRequest field is PNULL");
            break;
        }

        /* Decode message */
        if( RRC_FAILURE == rrc_s1ap_path_switch_req_ack_intrl_dec(
                    p_uecc_gb_context,
                    mme_id,
                    p_s1ap_pdu->u.successfulOutcome->value.u.pathSwitchRequest,
                    &msg
                    ))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, " Path Switch Request Ack"
                    "Decoding Failure");
            break;
        }

        /* Process message */
        /* Get context using S1AP id */
/*BUG 604 changes start*/ 
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,ue_index);
/*BUG 604 changes stop*/ 

        if (PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Path Switch Request Ack] UE context not found");

            break;
        }



        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"[S1AP Path Switch Request Ack]"
                    "message dropped - "
                    "UECC isn't initialized by CSC ");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }
        if (msg.enb_ue_s1ap_id != p_ue_context->s1ap_ue_id)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Path Switch Request Ack] "
                    "msg.enb_ue_s1ap_id (%i) != p_ue_context->s1ap_ue_id (%i)",
                    msg.enb_ue_s1ap_id,
                    p_ue_context->s1ap_ue_id);

            break;
        }
        
        /* Store MME ID in UE context as received in msg */
        p_ue_context->m.mme_ue_id_present = 1;
        p_ue_context->mme_ue_id = msg.mme_ue_s1ap_id;
    /*SPR 14254 Fix Start*/
        if(msg.bitmask & RRC_S1AP_PATH_SWITCH_REQUEST_ACK_MME_UE_S1AP_ID2_PRESENT)
    /*SPR 14254 Fix Stop*/
        {
            p_ue_context->m.mme_ue_id2_present = 1;
            p_ue_context->mme_ue_id2 = msg.mme_ue_s1ap_id2;
        }
 
        if (PNULL != p_ue_context)
        {
            /*Generating Protocol Events */
            /* SPR 22634 Fix - Starts */
            encoded_msglen = (U32)(buffer_length);
            /* SPR 22634 Fix - Ends */
            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msglen);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msglen),
                        LOCAL_S1_PATH_SWITCH_REQUEST_ACKNOWLEDGE,
                        MESSAGE_DIRECTION_RECEIVED);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_buff,
                        encoded_msglen);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }
        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, p_buff, encoded_msglen, 
                                             "Path Switch Request Acknowledge", 0);
        /* TRACE_changes_start */
        
        /*SPR_17718_START*/
        /* MINIMUM/MEDIUM tracing shall be done for Path Switch Req Ack
         * if ERAB Id is present which means if either ERAB to be switched
         * UL list is present or ERAB to be released list is present.
         */
        if (p_ue_context->m.traceActivated && 
                ((RRC_S1AP_PATH_SWITCH_REQUEST_ACK_E_RAB_TO_BE_SWITCHED_UL_LIST_PRESENT &
                  msg.bitmask) ||
                 (RRC_S1AP_PATH_SWITCH_REQUEST_ACK_E_RAB_TO_BE_RELEASED_LIST_PRESENT &
                  msg.bitmask))) 
        {
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                    (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                    (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1) &&
                    ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                     (MEDIUM == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                     (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                     (MINIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
            {
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), GEN_MME,"\n<msg function=\"S1AP\" name=\"Path Switch Request Acknowledge\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                        difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
            }
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                    (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                    (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1) &&
                    ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                     (MEDIUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                     (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                     (MINIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
            {
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), GEN_CELL,"\n<msg function=\"S1AP\" name=\"Path Switch Request Acknowledge\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                        difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
            }
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <initiator type=\"MME\">%s</initiator>",
                    p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);

            if(RRC_S1AP_PATH_SWITCH_REQUEST_ACK_E_RAB_TO_BE_SWITCHED_UL_LIST_PRESENT &
                    msg.bitmask)
            {
                P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n <ieGroup name=\"E-RAB To Be Switched in Uplink List\">");
                for( p_node = msg.e_rab_to_be_switched_ul_list.head;
                        PNULL!=p_node;
                        p_node=p_node->next)
                {
                    p_erab_to_be_switched_elem = (s1ap_E_RABToBeSwitchedULList_element *)p_node->data;
                    if (PNULL == p_erab_to_be_switched_elem || p_erab_to_be_switched_elem->value.u._E_RABToBeSwitchedULItemIEs_1 == PNULL)
                    {
                        continue;
                    }
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n<ie name=\"E-RABID\">%d</ie>",(U8)p_erab_to_be_switched_elem->value.u._E_RABToBeSwitchedULItemIEs_1->e_RAB_ID);
                }
                P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n </ieGroup> ");
            }
            if(RRC_S1AP_PATH_SWITCH_REQUEST_ACK_E_RAB_TO_BE_RELEASED_LIST_PRESENT &
                    msg.bitmask)
            {
                P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n <ieGroup name=\"E-RAB To Be Released List\">");
                for (p_node = msg.e_rab_to_be_released_list.head; 
                        PNULL!=p_node; 
                        p_node=p_node->next)
                {
                    p_erab_to_be_released_elem = (s1ap_E_RABList_element*)p_node->data;
                    if (PNULL == p_erab_to_be_released_elem || p_erab_to_be_released_elem->value.u._E_RABItemIEs_1 == PNULL)
                    {
                        continue;
                    }
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n<ie name=\"E-RABID\">%d</ie>",p_erab_to_be_released_elem->value.u._E_RABItemIEs_1->e_RAB_ID);
                }
                P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(), S1,"\n </ieGroup> ");
            }

            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n </msg>");
        }
        /*SPR_17718_END*/

        /* Call UECC_EV_S1AP_PATH_SWITCH_REQ_ACK event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_S1AP_PATH_SWITCH_REQ_ACK,
                &msg);

    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/*************************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_path_switch_request_failure
 *
 *   INPUTS       : S1AP_PDU            *p_s1ap_pdu
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  U32                 *mme_id
 *                  U8                  *p_buff
 *                  U16                 buffer_length
 *                  U16                 ue_index
 *
 *   OUTPUTS      : None
 *   DESCRIPTION  : This function processes S1AP Path Switch Request Failure message
 *
 *   RETURNS      : None
 *************************************************************************************/
void uecc_s1ap_process_path_switch_request_failure
(
 S1AP_PDU            *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context,  /* UECC global context */
 U8                  mme_id,
 U8                  *p_buff,        /* ASN.1 encoded message */
/*BUG 604 changes start*/ 
 U16             buffer_length,   /* encoded buf size - just for check*/
 U16             ue_index
 )
{
    /* coverity_fix_54688_start */
    uecc_ue_context_t       *p_ue_context = PNULL;
    rrc_s1ap_path_switch_request_failure_t msg;
    /*time_t time1;*/
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msglen = 0;

    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/

    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_ASSERT(PNULL!=p_s1ap_pdu->u.unsuccessfulOutcome);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    /* initializing the msg with all bits set to zero */
    memset_wrapper(&msg, 0, sizeof(rrc_s1ap_path_switch_request_failure_t));

    do
    {
        if (PNULL == p_s1ap_pdu->u.unsuccessfulOutcome->value.u.
                pathSwitchRequest)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Path Switch Request Failure] "
                    "pathSwitchRequest field is PNULL");
            break;
        }

        /* Decode message */
        if(RRC_FAILURE == rrc_s1ap_path_switch_req_fail_intrl_dec(
                    p_uecc_gb_context,
                    mme_id, 
                    p_s1ap_pdu->u.unsuccessfulOutcome->value.u.pathSwitchRequest,
                    &msg
                    ))
        {

            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, " Path Switch Request Failure "
                    "Decoding Failure");
            break;
        }

        /* Process message */
        /*BUG 604 changes start*/ 
        /* Get context using ue_index */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,ue_index);
        /*BUG 604 changes stop*/ 

        if (PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Path Switch Request Failure] UE context not found");

            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"[S1AP Path Switch Request Failure]"
                    "message dropped - "
                    "UECC isn't initialized by CSC ");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }



        if (msg.enb_ue_s1ap_id != p_ue_context->s1ap_ue_id)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[S1AP Path Switch Request Ack Failure] "
                    "msg.enb_ue_s1ap_id (%i) != p_ue_context->s1ap_ue_id (%i)",
                    msg.enb_ue_s1ap_id,
                    p_ue_context->s1ap_ue_id);

            break;
        }

        /* Store MME ID in UE context as received in msg */
        p_ue_context->m.mme_ue_id_present = 1;
        p_ue_context->mme_ue_id = msg.mme_ue_s1ap_id;

        /*Store the cause in UE context as received in msg */
        l3_memcpy_wrapper(&p_ue_context->ho_info.cause,&msg.cause,sizeof(s1ap_Cause));

        if (PNULL != p_ue_context)
        {
            /*Generating Protocol Events */
            /* SPR 22634 Fix - Starts */
            encoded_msglen = (U32)(buffer_length);
            /* SPR 22634 Fix - Ends */
            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msglen);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msglen),
                        LOCAL_S1_PATH_SWITCH_REQUEST_FAILURE,
                        MESSAGE_DIRECTION_RECEIVED);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_buff,
                        encoded_msglen);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, p_buff, encoded_msglen, 
                "Path Switch Request Failure", 0);
        /* TRACE_changes_start */
        /* SPR 12187 Fix Start */
            /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated) 
        {
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                    (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                    (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1) &&
                    ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                     (MEDIUM == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                     (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                     (MINIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
            {
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), GEN_MME,"\n<msg function=\"S1AP\" name=\"Path Switch Request Failure\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                        difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
            }
            if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                    (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                    (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1) &&
                    ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                     (MEDIUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                     (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                     (MINIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
            {
                P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), GEN_CELL,"\n<msg function=\"S1AP\" name=\"Path Switch Request Failure\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                        difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
            }
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <initiator type=\"MME\">%s</initiator>",
                    p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);

            /*SPR 15875 Fix Stop*/
            /* SPR:5840 start*/ 
            uecc_s1ap_p_rrc_trace_for_cause(p_ue_context,msg.cause);            
            /* SPR:5840 stop */ 
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n </msg>");
            /*SPR 15896 Fix Stop*/

        }

        /* Call UECC_EV_S1AP_PATH_SWITCH_REQ_FAILURE event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_S1AP_PATH_SWITCH_REQ_FAIL,
                &msg);

    } while (0);
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/* coverity_fix_54688_stop */
/*x2ap-end*/

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_ue_release_ind
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends s1ap_ue_release_ind message
 *       to S1AP module.
 *
 *   RETURNS:
 *       rrc_return_et
 *
 ******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_ue_release_ind
(
    uecc_ue_context_t                *p_ue_context
)
{
    rrc_return_et result = RRC_FAILURE;
    s1ap_ue_release_ind_t s1ap_ue_release_ind;


    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* Reset message */
    memset_wrapper(&s1ap_ue_release_ind, 0, sizeof(s1ap_ue_release_ind_t));

    /* Fill message */
    /*Fill UE ID*/
    if(p_ue_context->m.mme_ue_id_present)
    {
        s1ap_ue_release_ind.mme_ue_s1ap_id = p_ue_context->mme_ue_id;
    }
    /* SPR 18168 Fix Start */
    else
    {
        s1ap_ue_release_ind.mme_ue_s1ap_id = RRC_INVALID_MME_UE_S1AP_ID;
    }
    /* SPR 18168 Fix Stop */
    s1ap_ue_release_ind.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

    if(INTER_CELL_HO == p_ue_context->ho_info.s1_or_x2_handover)
    {
        s1ap_ue_release_ind.mme_id = 0xFF;
    }
    else
    {
        s1ap_ue_release_ind.mme_id = p_ue_context->mme_id;
    }

    /* Send message to S1AP  */
    result = uecc_rrc_send_internal_msg(
            RRC_S1AP_MODULE_ID,
            S1AP_UE_RELEASE_IND,
            (U16)(sizeof(s1ap_ue_release_ind_t)),
            &s1ap_ue_release_ind);

    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
            (p_ue_context->p_gb_context)->facility_name,
            RRC_INFO, "S1AP_MSG: UE RELEASE IND");

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_ho_ongoing_ue_release_ind
 *
 *   INPUTS       : mme_ue_s1ap_id_list_t        *p_mme_ue_s1ap_id_list
 *                  uecc_gb_context_t            *p_uecc_gb_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends s1ap_ho_ongoing_ue_release_ind message
 *       to S1AP module.
 *
 *   RETURNS:
 *       rrc_return_et
 *
 ******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_ho_ongoing_ue_release_ind
(
    mme_ue_s1ap_id_list_t        *p_mme_ue_s1ap_id_list,
    uecc_gb_context_t            *p_uecc_gb_context  /* UECC global context */
)
{
    U16                               mme_s1ap_index = RRC_NULL;
    rrc_return_et                     result = RRC_FAILURE;
    s1ap_ho_ongoing_ue_release_ind_t  s1ap_ho_ongoing_ue_release_ind; 


    RRC_ASSERT (PNULL != p_mme_ue_s1ap_id_list);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    
    /* Reset message */
    memset_wrapper(&s1ap_ho_ongoing_ue_release_ind, 0, 
                sizeof(s1ap_ho_ongoing_ue_release_ind_t));

    if (MAX_RESET_UE_S1AP_ID_COUNT < p_mme_ue_s1ap_id_list->count)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING, "No. of MME UE S1AP Ids are greater than 256.");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
        return result;
    }

    /* Fill message */
    s1ap_ho_ongoing_ue_release_ind.mme_ue_s1ap_id_list.count = 
        p_mme_ue_s1ap_id_list->count;

    for (mme_s1ap_index = 0; mme_s1ap_index < p_mme_ue_s1ap_id_list->count;
            mme_s1ap_index++)
    {
        s1ap_ho_ongoing_ue_release_ind.mme_ue_s1ap_id_list.mme_ue_s1ap_id[mme_s1ap_index] 
            = p_mme_ue_s1ap_id_list->mme_ue_s1ap_id[mme_s1ap_index];
    }
    
    /* Send message to S1AP  */
    result = uecc_rrc_send_internal_msg(
            RRC_S1AP_MODULE_ID,
            S1AP_HO_ONGOING_UE_RELEASE_IND,
            (U16)(sizeof(s1ap_ho_ongoing_ue_release_ind_t)),
            &s1ap_ho_ongoing_ue_release_ind);

    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_INFO, "S1AP_MSG: S1AP HO ONGOING RELEASE IND");

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);

    return result;
}
/* ARP Start */

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_e_rab_release_indication
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *   
 *   OUTPUTS      : None
 *
 *   DESCRIPTION  : This function builds and sends e_rab_release_indication 
 *                  message to S1AP
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_e_rab_release_indication(
        uecc_ue_context_t* p_ue_context)
{

    OSCTXT asn1_ctx;
    rrc_s1ap_e_rab_release_indication_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t*  p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t*)sig_msg_req_buf;
    rrc_return_et result = RRC_FAILURE;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = 0;

    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if (p_ue_context->m.traceActivated )
    {
        /*SPR 15875 Fix Start*/
        /*SPR 15896 Fix Start*/
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), GEN_MME,"\n<msg function=\"S1AP\" name=\"E-RAB RELEASE Indication\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), GEN_CELL,"\n<msg function=\"S1AP\" name=\"E-RAB RELEASE Indication\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <target type=\"MME\">%s</target>",
                    p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
        /*SPR 15896 Fix Stop*/

        /*SPR 15875 Fix Stop*/
    }

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_ERABReleaseIndication]"
                "ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf, 0, 
                sizeof(s1ap_ue_associated_sig_msg_req_t));

        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

        if (RRC_SUCCESS != uecc_s1ap_build_e_rab_released_list(
                    p_ue_context, &asn1_ctx, &msg.e_rab_released_list))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ERABReleaseIndication]"
                    "uecc_s1ap_build_e_rab_released_list failure");
            break;
        }

        /* Encode message */
        result = rrc_s1ap_e_rab_release_indication_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0], 
                &p_sig_msg_req->message_buff_size,
                &msg);

        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ERABReleaseIndication] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

           
            rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if (PNULL != p_event_header)
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_ERAB_RELEASE_INDICATION,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_E_RABReleaseIndication;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
        /*Fill ue_index*/
        p_sig_msg_req->ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

        /* TRACE_changes_start */
        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, &p_sig_msg_req->message_buff_p[0], 
                        p_sig_msg_req->message_buff_size, "E-RAB Release Indication", 1);
        /* TRACE_changes_start */
        
        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "S1AP_MSG: E-RABReleaseIndication %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));

    } while (0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;

}


/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_e_rab_released_list
 *
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  OSCTXT*  p_asn1_ctx
 *                  s1ap_E_RABList* p_list
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds e_rab_released_list
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_e_rab_released_list(
        uecc_ue_context_t* p_ue_context,
        OSCTXT*  p_asn1_ctx,
        s1ap_E_RABList* p_list
        )
{
    OSRTDListNode* p_node = PNULL;
    s1ap_E_RABList_element* p_elem = PNULL;
    erab_list_t* p_erab_list = PNULL;
    U8 e_rab_index = RRC_NULL;
    U8 counter = RRC_NULL;
    U8 qci_value = RRC_NULL;


    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_list);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);


    asn1Init_s1ap_E_RABList(p_list);

    /* point to erab_release_list in erab_release_command_data */
    p_erab_list = &p_ue_context->p_curr_proc_data->u.
        erab_release_command_data.erab_release_list;

    for (e_rab_index = 0;
            e_rab_index < p_erab_list->counter;
            e_rab_index++)
    {
        rtxDListAllocNodeAndData(p_asn1_ctx,
                s1ap_E_RABList_element,
                &p_node,
                &p_elem);
        if (PNULL==p_node)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Can't allocate p_node");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        asn1Init_s1ap_E_RABList_element(p_elem);
        p_elem->value.u._E_RABItemIEs_1 =
        (s1ap_E_RABItem*)rtxMemAlloc(p_asn1_ctx,
                sizeof(s1ap_E_RABItem));

        if (PNULL==p_elem->value.u._E_RABItemIEs_1)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR, "ASN malloc failed.");
            return RRC_FAILURE;
        }
        asn1Init_s1ap_E_RABItem(p_elem->value.u._E_RABItemIEs_1);

        p_elem->id = ASN1V_s1ap_id_E_RABItem;
        p_elem->criticality = s1ap_ignore;
        
        /*SPR 6872 start*/
        /* SPR 21660 changes start */
        p_elem->value.t = T180__E_RABItemIEs_1; //T173__E_RABItemIEs_1 
        /* SPR 21660 changes end */
        /*SPR 6872 stop*/
        p_elem->value.u._E_RABItemIEs_1->e_RAB_ID =
            p_erab_list->erab_item[e_rab_index].e_RAB_ID;
        if ( PNULL != g_rrc_stats.p_rrc_stats)
        {
          /* Find the E-RAB ID in the UE Context to get the Qci */
          for (counter = 0; counter < MAX_ERAB_COUNT; counter++)
         {
            if ((PNULL != p_ue_context->p_e_rab_list[counter]) && 
                    (p_elem->value.u._E_RABItemIEs_1->e_RAB_ID == 
                     p_ue_context->p_e_rab_list[counter]->e_RAB_ID))
            {
                /* update the performance counter */
                qci_value = p_ue_context->p_e_rab_list[counter]->
                    e_RABlevelQoSParameters.qCI;

                /* SPR 13441 Fix Start */
                if ( (RRC_MIN_QCI_GBR_LIMIT <= qci_value) &&
                        (RRC_MAX_QCI_NON_GBR_LIMIT >= qci_value) )
                { 
                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                        p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].
                        rrc_erab_related_stats.erab_release_stats.
                        erab_relEnbNbr_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
                        RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                        p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].
                        rrc_erab_related_stats.erab_release_stats.
                        erab_relEnbNbr_sum, RRC_UPDATED_QCI_INDEX(qci_value), 
                        RRC_MAX_QCI_INDEX);

                RRC_UPDATE_PERFORMANCE_COUNTER_S1AP_CAUSE(p_ue_context,
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                        p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                        erab_release_stats.erab_rel_enb_cause_stats.
                        erab_relEnbNbr_cause, p_erab_list->erab_item[e_rab_index].cause);

                /* BUG 13094 Fix Start */
                /* BUG 13094 Fix Stop */

                /* CR 90 changes start */
                /* SPR Fix 8377 */    
                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                        p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].
                        rrc_erab_related_stats.erab_release_stats.
                        erab_relSuccNbr_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
                        RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

                RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                        g_rrc_stats.p_rrc_stats->
                        rrc_uecc_stats.rrc_uecc_instance_stats[p_ue_context->
                        p_gb_context->offset_uecc_mod_id].
                        rrc_uecc_cell_stats[p_ue_context->cell_index].rrc_erab_related_stats.
                        erab_release_stats.erab_relSuccNbr_sum, 
                        RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);
                /* SPR Fix 8377 */
                /* CR 90 changes stop*/
                /* CR 101 changes start*/
                if (MAC_DELETE_LC_ACTIVE == p_erab_list->erab_item[e_rab_index].lc_status) 
                {
                    RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                            g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                            rrc_uecc_instance_stats[p_ue_context->p_gb_context->offset_uecc_mod_id].
                            rrc_uecc_cell_stats[p_ue_context->cell_index].
                            rrc_erab_related_stats.erab_release_stats.
                            erab_relActNbr_qci[RRC_UPDATED_QCI_INDEX(qci_value)],
                            RRC_UPDATED_QCI_INDEX(qci_value), RRC_MAX_QCI_INDEX);

                    RRC_UPDATE_PERFORMANCE_COUNTER(p_ue_context->p_gb_context,
                            g_rrc_stats.p_rrc_stats->rrc_uecc_stats.
                            rrc_uecc_instance_stats[p_ue_context->p_gb_context->offset_uecc_mod_id].
                            rrc_uecc_cell_stats[p_ue_context->cell_index].
                            rrc_erab_related_stats.erab_release_stats.
                            erab_relActNbr_sum, RRC_UPDATED_QCI_INDEX(qci_value), 
                            RRC_MAX_QCI_INDEX);
                }
                /* CR 101 changes stop*/
                }
                /* SPR 13441 Fix End */
            }
          }
        }
        /*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated) 
        {
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n <ie name=\"E-RABID\">%d</ie>",p_elem->value.u._E_RABItemIEs_1->e_RAB_ID);
        /*SPR 15896 Fix Stop*/
        }

        p_elem->value.u._E_RABItemIEs_1->cause = p_erab_list->erab_item[e_rab_index].cause;

        rtxDListAppendNode(p_list,p_node);
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

        /*SPR 15896 Fix Start*/
    if (p_ue_context->m.traceActivated) 
    {
        P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), S1,"\n </msg>");
        /*SPR 15896 Fix Stop*/
    }
    return RRC_SUCCESS;
}
/* ARP Stop */
/************************************************************************************
 *   FUNCTION NAME: build_and_send_allocate_mme_req
 *
 *   INPUTS       : uecc_ue_context_t *p_ue_context,
 *                  U8 procedure_code
 *
 *   OUTPUTS      : None
 *
 *   DESCRIPTION  : This function builds and sends S1AP_ALLOCATE_MME_REQ to S1AP
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 ************************************************************************************/
rrc_return_et build_and_send_allocate_mme_req(
        uecc_ue_context_t* p_ue_context,
/* Bug 8198 Fix Start */
        U8   procedure_code
/* Bug 8198 Fix End */
 )
{
    s1ap_allocate_mme_req_t allocate_mme_req;
    rrc_return_et            result = RRC_FAILURE;

/*SPR 8708 Fix Start*/
    U32 invalid_plmn_id = RRC_INVALID_PLMN_ID;
/*SPR 8708 Fix Stop*/

    RRC_ASSERT(p_ue_context != PNULL);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&allocate_mme_req, RRC_NULL, sizeof(s1ap_allocate_mme_req_t));

/* Bug 8198 Fix Start */
    /*In case of path switch fill establishment cause with some invalid value*/
/*SPR 8708 Fix Start*/
     if((ASN1V_s1ap_id_initialUEMessage == procedure_code) || (RRC_RrcConnectionReq_proc_code == procedure_code))
/*SPR 8708 Fix Stop*/
     {
         allocate_mme_req.rrc_establishment_cause =  p_ue_context->rcs_establishmentCause;
     }
     else if(ASN1V_s1ap_id_PathSwitchRequest == procedure_code)
     {
         allocate_mme_req.rrc_establishment_cause = RRC_INVALID_ESTABLISHMENT_CAUSE;
     }
    
    /* SPR 5396 Fix */
    allocate_mme_req.plmn_identity.numocts = sizeof(allocate_mme_req.plmn_identity.data);
/*SPR 8708 Fix Start*/

    if((p_ue_context->rcs_stmsi.bitmask) && (RRC_RrcConnectionReq_proc_code == procedure_code))
    {
    /* Sending invalid plmn ID */
    l3_memcpy_wrapper(allocate_mme_req.plmn_identity.data , &invalid_plmn_id , allocate_mme_req.plmn_identity.numocts);

    /* Filling MMEC from UE context */
    allocate_mme_req.bitmask |= REGISTERED_MMEC_PRESENT;    
    allocate_mme_req.mmec.numocts = sizeof(p_ue_context->rcs_stmsi.s_tmsi.mmec);
    l3_memcpy_wrapper(&allocate_mme_req.mmec.data,
                &p_ue_context->rcs_stmsi.s_tmsi.mmec,
                allocate_mme_req.mmec.numocts);
    } 
    else if((p_ue_context->m.source_gummei_present == 1)&& 
            (ASN1V_s1ap_id_PathSwitchRequest == procedure_code))
/*SPR 8708 Fix Stop*/
    {
        l3_memcpy_wrapper(&allocate_mme_req.plmn_identity.data,
                &p_ue_context->gummei.plmn_identity.data,                      
                p_ue_context->gummei.plmn_identity.numocts);

        allocate_mme_req.bitmask |= REGISTERED_MMEGI_PRESENT;

        /*Bug 488 Fix Start*/
        allocate_mme_req.mme_group_id.numocts =
            ( p_ue_context->registered_mme.mmegi.numbits % 8) ?
            p_ue_context->registered_mme.mmegi.numbits/8 +1 :
            p_ue_context->registered_mme.mmegi.numbits/8;

        /* SPR 13529 Fix Start */
        allocate_mme_req.mme_group_id.data[0] = 
            p_ue_context->registered_mme.mmegi.data[0];
        allocate_mme_req.mme_group_id.data[1] = 
            p_ue_context->registered_mme.mmegi.data[1];
        /* SPR 13529 Fix Stop */
        /*Bug 488 Fix End*/
        allocate_mme_req.bitmask |= REGISTERED_MMEC_PRESENT;
        allocate_mme_req.mmec.numocts =
            p_ue_context->gummei.mme_code.numocts;
        l3_memcpy_wrapper(&allocate_mme_req.mmec.data,
                &p_ue_context->gummei.mme_code.data,                      
                p_ue_context->gummei.mme_code.numocts);
    }
    else
    {
        uecc_s1ap_generate_plmn_identity_int(
                allocate_mme_req.plmn_identity.data,
                &p_ue_context->plmn_identity.plmn_identity);

        if (p_ue_context->registered_mme_info_present)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_INFO,
                    "%s Registered MME info present",__FUNCTION__);
            /* Registered MME Infomation is present */

            allocate_mme_req.bitmask |= REGISTERED_MMEGI_PRESENT;
            allocate_mme_req.mme_group_id.numocts =
                ( p_ue_context->registered_mme.mmegi.numbits % 8) ?
                p_ue_context->registered_mme.mmegi.numbits/8 +1 :
                p_ue_context->registered_mme.mmegi.numbits/8;

            /* SPR 15668 Start */
            allocate_mme_req.mme_group_id.data[0] = 
                p_ue_context->registered_mme.mmegi.data[0];
            allocate_mme_req.mme_group_id.data[1] = 
                p_ue_context->registered_mme.mmegi.data[1];
            /* SPR 15668 End*/

            allocate_mme_req.bitmask |= REGISTERED_MMEC_PRESENT;

            /* Else assign MMEC from registered MME recvd in 
             * rrcConnSetupComp*/

            allocate_mme_req.mmec.numocts =
                ( p_ue_context->registered_mme.mmec.numbits % 8) ?
                p_ue_context->registered_mme.mmec.numbits/8 +1 :
                p_ue_context->registered_mme.mmec.numbits/8;

            l3_memcpy_wrapper(allocate_mme_req.mmec.data,
                    p_ue_context->registered_mme.mmec.data,
                    allocate_mme_req.mmec.numocts);

        }
    }
/* Bug 8198 Fix End */

/*BUG 604 changes start*/
//    allocate_mme_req.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
/*BUG 604 changes stop*/
    allocate_mme_req.cell_index = p_ue_context->cell_index;
/*BUG 604 changes start*/
    allocate_mme_req.ue_index = p_ue_context->ue_index;
/*BUG 604 changes stop*/

    /* Send message to S1AP  */
    result = uecc_rrc_send_internal_msg(
            RRC_S1AP_MODULE_ID,
            S1AP_ALLOCATE_MME_REQ,
            (U16)(sizeof(s1ap_allocate_mme_req_t)) ,
            &allocate_mme_req);

    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
            (p_ue_context->p_gb_context)->facility_name,
            RRC_INFO,"S1AP_MSG: ALLOCATE_MME_REQ");

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_alloc_mme_resp
 *
 *   INPUTS       : void                *p_api
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes S1AP_ALLOCATE_MME_RESP
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_alloc_mme_resp(
        void                *p_api,             /* Input API buffer */
        uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
        )
{
    s1ap_allocate_mme_resp_t*   p_s1ap_alloc_mme_resp = PNULL;
    uecc_ue_context_t*      p_uecc_context = PNULL;

    RRC_ASSERT(PNULL!=p_api);
    RRC_ASSERT(PNULL!=p_uecc_gb_context);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    /* Precondition - p_api should point to right message */
    if (rrc_get_api_buf_size(p_api) <
            (RRC_API_HEADER_SIZE + sizeof(s1ap_allocate_mme_resp_t)))
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                       p_uecc_gb_context->facility_name,
                       RRC_WARNING,
                       "[S1AP_ALLOCATE_MME_RESP] Wrong message size - ignore");
        return;
    }

    p_s1ap_alloc_mme_resp =
        (s1ap_allocate_mme_resp_t *)((U8*)p_api + RRC_API_HEADER_SIZE);

    /* find specified UE */
     /*BUG 604 changes start*/
    /*p_uecc_context = uecc_ue_ctx_get_by_s1ap_id(
            p_uecc_gb_context,
            p_s1ap_alloc_mme_resp->enb_ue_s1ap_id);*/
     p_uecc_context = uecc_ue_ctx_get(p_uecc_gb_context, p_s1ap_alloc_mme_resp->ue_index);
     /*BUG 604 changes stop*/

    if (PNULL != p_uecc_context)
    {
        /*SPR_17976_START*/
        if(RRC_TRUE == p_uecc_context->trg_ho_fail_rrc_cre_flag)
        {
            if(0 == 
                    TENB_CRE_Q_GET_COUNT(&p_uecc_context->p_tenb_cre_event_queue))
            {
                uecc_event_queue_push_tenb_cre_event(
                        UECC_EV_S1AP_ALLOCATE_MME_RESP, 
                        p_uecc_context, 
                        p_api, 
                        &p_uecc_context->p_tenb_cre_event_queue);
            }
            else
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->
                        facility_name, RRC_WARNING,
                        "MME Allocate Resp is ignored because reestablishment "
                        "procedure ongoing during handover for ue_index: %d"
                        " and one event is already queued",
                        p_uecc_context->ue_index );
            }
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }
        /*SPR_17976_END*/

        /*BUG 604 changes start*/
        /*store the enb_ue_s1ap_id received from s1ap in ue context */
        p_uecc_context->s1ap_ue_id = p_s1ap_alloc_mme_resp->enb_ue_s1ap_id;
        /*BUG 604 changes stop*/
        /* mme grp id feature changes start */
         p_uecc_context->gummei_to_be_sent =
             p_s1ap_alloc_mme_resp->matching_gummei_to_be_sent; 
        /* mme grp id feature changes stop */
        /* Send event to specified UE */
        uecc_fsm_process_event(
            p_uecc_context,
            UECC_EV_S1AP_ALLOCATE_MME_RESP,
            p_s1ap_alloc_mme_resp);
    }
    else
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                       p_uecc_gb_context->facility_name,
                       RRC_WARNING,
                "[S1AP_ALLOCATE_MME_RESP] Wrong S1AP UE index");
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
//Trace Change Start
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_set_enbId_from_s1ap_status_msg_ind
 *
 *   INPUTS       : uecc_gb_context_t   *p_uecc_gb_context
 *                  s1ap_status_msg_ind_t *p_s1ap_status_msg_ind
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function stores the eNodeB ID in the Global Context
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/

static void uecc_s1ap_set_enbId_from_s1ap_status_msg_ind(
    uecc_gb_context_t   *p_uecc_gb_context,  /* UECC global context */
    s1ap_status_msg_ind_t *p_s1ap_status_msg_ind /* Message Structure of S1AP Status Message Indication */
    )
{
    
    if ( p_s1ap_status_msg_ind->enb_id.presence_bitmask & S1AP_OAM_HOME_ENB_ID_PRESENT)
    {
        p_uecc_gb_context->enbType = HOME_ENB;
        l3_memcpy_wrapper( &p_uecc_gb_context->home_enb_id,
                    &p_s1ap_status_msg_ind->enb_id.home_enb_id.eNB_id,
                    sizeof(p_s1ap_status_msg_ind->enb_id.home_enb_id.eNB_id));
    }
    else if ( p_s1ap_status_msg_ind->enb_id.presence_bitmask & S1AP_OAM_MACRO_ENB_ID_PRESENT)
    {
        p_uecc_gb_context->enbType = MACRO_ENB;
        l3_memcpy_wrapper( &p_uecc_gb_context->macro_enb_id,
                    &p_s1ap_status_msg_ind->enb_id.macro_enb_id.eNB_id,
                    sizeof(p_s1ap_status_msg_ind->enb_id.macro_enb_id.eNB_id));
    }
 }
//Trace Change End

/******************************************************************************
*   FUNCTION NAME: rrc_fill_pilot_list_octet
*
*   INPUTS       : uecc_ue_context_t*      p_ue_context
*                  pilot_list_t *pilot_list
*
*   OUTPUTS      : None
*
*   DESCRIPTION  : This function forms an octet string from pilot_list
*       
*   RETURNS      : OSDynOctStr 
******************************************************************************/
OSDynOctStr* rrc_fill_pilot_list_octet(
    uecc_ue_context_t* p_ue_context,
    pilot_list_t *pilot_list
)
{
    /*klockwork fix */
    U8*           buffer = PNULL;
    /*klockwork fix */

    U8*          p_buf = PNULL;
/* Bug 12190 Fix Start */
    U8           bitPos = 0;
/* Bug 12190 Fix Stop */
    U32          count = 0;
    OSDynOctStr *p_octet_data = PNULL;
    U8* init_add_of_octet = buffer;
    U8* final_add_of_octet = PNULL;
    U32 num_of_octets = 0;
    
    /*klockwork fix */
    buffer = (U8*)rrc_mem_get(SIZE_OF_PILOT_LIST_PARAMS); 
    /*klockwork fix */

    /* coverity fix */
    if( PNULL == buffer )
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                p_ue_context->p_gb_context->facility_name,
                RRC_INFO,
                "Memory allocation to buffer failed");
    }
    else
    {
        /* SES-508 Fix Start */
        /* Code Removed */
        /* SES-508 Fix End */

        /* A21_ELMENT_IDENTIFIER */
        buffer[0] = CDMA2000_PILOT_LIST_A21_ELMENT_IDENTIFIER;

        /* PILOT_LIST_LENGTH */
        buffer[1] = 0; /*IE Length to be updated after filling all the other IEs*/

        /*pilot_list.num_of_pilots*/
        buffer[2] = pilot_list->num_of_pilots;

        p_buf = &buffer[3]; /*p_buf should point from index 3 onwards i.e. first pilot_entry*/

        /*pilot_list.pilot_entry*/
        for(count = 0; count < MAX_PILOT_ENTRY; count++)
        {
            rrc_fill_pilot_entry_octet(
                    p_ue_context, &p_buf,  
                    &bitPos, 
                    &pilot_list->pilot_entry[count]);
        }

        p_octet_data = (OSDynOctStr *)rrc_mem_get(SIZE_OF_PILOT_LIST_PARAMS);

        if(p_octet_data == NULL)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name,
                    RRC_INFO,
                    "Memory allocation to p_octet_data failed");
        }
        else
        {
            /* SES-508 Fix Start */
            /* Code Removed */
            /* SES-508 Fix End */

            p_octet_data->data = buffer; /*Initial address of buffer will */
            /*remain same as the size of */ 
            /*num_of_pilots is 4 bits*/

            final_add_of_octet = p_buf;
/*SPR 20636 Changes Start*/
            num_of_octets = ((U32_64_Bit)final_add_of_octet - (U32_64_Bit)init_add_of_octet);
/*SPR 20636 Changes End*/

            if(0 == bitPos)
            {
                num_of_octets = (num_of_octets - 1);
            }
            buffer[1] = (U8)num_of_octets; /* Length IE of Pilot list */

            p_octet_data->numocts = num_of_octets;
        }
    }
    /* coverity fix */

    /* Coverity Fix 63275 Start */
    if ( PNULL != buffer )
    {
        rrc_mem_free(buffer);
        buffer = PNULL;
    }
    /* Coverity Fix 63275 Stop */

    return p_octet_data;
}

/* Bug 12190 Fix Start */
/******************************************************************************
*   FUNCTION NAME: rrc_fill_pilot_entry_octet
*
 *   INPUTS       : uecc_ue_context_t*      p_ue_context
 *                  U8**  p_buf, U8* bitPos
 *                  pilot_entry_t  *pilot_entry
 *   OUTPUTS      : None
*   DESCRIPTION   : This function forms an octet string from pilot_entry
*
*   RETURNS       : None
*
******************************************************************************/

void rrc_fill_pilot_entry_octet(
    uecc_ue_context_t* p_uecc_ue_context,
    U8**  p_buf1, U8* bitPosition,
    pilot_entry_t  *pilot_entry
    )
{
   U8 ***p_buf;
   U8 **bitPos;
   U16 refPilot_pilotPnInfo = 0;
   U16 refPilot = 0;

   p_buf = &p_buf1;
   bitPos = &bitPosition;

   ***p_buf = CDMA_2000_PILOT_LIST_CHANNEL_RECORD_LENGTH;
   (**p_buf)++;

   /* CHANNEL_RECORD */
   SETNBIT(*p_buf, *bitPos, 
           CDMA_2000_PILOT_LIST_CHANNEL_RECORD_LENGTH, 
           CDMA_2000_PILOT_LIST_CHANNEL_RECORD_LENGTH_WIDTH,
           p_uecc_ue_context);
/* Bug 12190 Fix Stop */

   /*system_type*/
   SETNBIT(*p_buf, *bitPos, 
           pilot_entry->channel_record.system_type, 
           CDMA_2000_PILOT_LIST_SYSTEM_TYPE_WIDTH,
           p_uecc_ue_context);

   /*band_class*/
   SETNBIT(*p_buf, *bitPos, pilot_entry->channel_record.band_class,
           CDMA_2000_PILOT_LIST_BAND_CLASS_WIDTH,
           p_uecc_ue_context);

   /*channel_number*/
   SETNBIT(*p_buf, *bitPos, pilot_entry->channel_record.channel_number,
           CDMA_2000_PILOT_LIST_CHANNEL_NUMBER_INFO_WIDTH ,
           p_uecc_ue_context);

   /*cell_id_info*/
   SETNBIT(*p_buf, *bitPos, pilot_entry->cell_id_info, 
           CDMA_2000_PILOT_LIST_CELL_ID_INFO_WIDTH,
           p_uecc_ue_context);

   /*reserved bit */
   SETNBIT(*p_buf, *bitPos, RRC_FALSE, 
           CDMA_2000_PILOT_LIST_CHANNEL_RECORD_RESERVED_BIT,
           p_uecc_ue_context);

   if((pilot_entry->cell_id_info == CELL_ID_1XRTT_001)
       ||(pilot_entry->cell_id_info == CELL_ID_1XRTT_010)
       ||(pilot_entry->cell_id_info == CELL_ID_1XRTT_011)
       ||(pilot_entry->cell_id_info == CELL_ID_1XRTT_111))
   {
       /* 1x CELL IDENTIFIER */
       if(pilot_entry->bitmask & PILOT_ENTRY_1X_CELL_IDENTIFIER_PRESENT)
       {
/* Bug 12190 Fix Start */
           l3_memcpy_wrapper(**p_buf, 
                      pilot_entry->cdma2000_1xrtt_cell_id.cdma2000_1xrtt_cell_id,
                      CDMA2000_1XRTT_CELL_ID_LENGTH);
           (**p_buf) += CDMA2000_1XRTT_CELL_ID_LENGTH;
/* Bug 12190 Fix Stop */
       }    
   }
   else if((pilot_entry->cell_id_info == CELL_ID_HRPD_100)
           ||(pilot_entry->cell_id_info == CELL_ID_HRPD_101)
           ||(pilot_entry->cell_id_info == CELL_ID_HRPD_110))
 
   {
       /* CDMA2000 HRPD SECTOR ID */
       if(pilot_entry->bitmask & PILOT_ENTRY_HRPD_SECTOR_IDENTIFIER_PRESENT)
       {
           SETNBIT(*p_buf, *bitPos, pilot_entry->cdma2000_hrpd_sector_id.\
                  sector_id_length,
                  sizeof(U8),
                  p_uecc_ue_context);

/* Bug 12190 Fix Start */
           l3_memcpy_wrapper(**p_buf, 
                      pilot_entry->cdma2000_hrpd_sector_id.sector_id,
                      MAX_SECTOR_ID_LENGTH);
           (**p_buf) += MAX_SECTOR_ID_LENGTH;
/* Bug 12190 Fix Stop */
       }
   }

    refPilot_pilotPnInfo = pilot_entry->pilot_pn_info;
    refPilot = (U8)pilot_entry->reference_pilot; /*storing U8 value to U16 variable*/
    /*To reset the 15th bit position of Pilot PN Info as its size is 15 bits*/
    refPilot_pilotPnInfo = ((refPilot_pilotPnInfo <<1) >>1);

    /*Left shift refPilot 15 times*/
    refPilot = refPilot <<15;
    
    /*Perform ORing of Ref Pilot and Pilot PN info to make it a single IE*/
    refPilot_pilotPnInfo |= refPilot;


    /* REFERENCE PILOT & PILOT PN INFO*/
   if(pilot_entry->bitmask & PILOT_ENTRY_REFERENCE_PILOT_PRESENT)
   {
       SETNBIT(*p_buf, *bitPos, refPilot_pilotPnInfo, 
               CDMA_2000_PILOT_LIST_REFERENCE_PILOT_WIDTH + CDMA_2000_PILOT_LIST_PILOT_PN_INFO_WIDTH,
               p_uecc_ue_context);
   }

   /* PILOT STRENGTH */
   if(pilot_entry->bitmask & PILOT_ENTRY_PILOT_STRENGTH_PRESENT)
   {
       SETNBIT(*p_buf, *bitPos, pilot_entry->pilot_strength, 
               CDMA_2000_PILOT_LIST_PILOT_STRNGTH_WIDTH,
               p_uecc_ue_context);
   }

   /* PILOT ONE WAY DELAY INCLUDED */
   SETNBIT(*p_buf, *bitPos, pilot_entry->pilot_one_way_delay_included, 
           CDMA_2000_PILOT_LIST_PILOT_ONE_WAY_DELAY_INCLUDED_WIDTH,
           p_uecc_ue_context);

   /* PILOT STRENGTH RESERVED BIT */
   SETNBIT(*p_buf, *bitPos, RRC_FALSE, 
           CDMA_2000_PILOT_LIST_PILOT_STRENGTH_RESERVED_BIT_WIDTH,
           p_uecc_ue_context);

   /* PILOT ONE WAY DELAY */
   if(pilot_entry->bitmask & PILOT_ENTRY_PILOT_ONE_WAY_DELAY_PRESENT)
   {
       SETNBIT(*p_buf, *bitPos, pilot_entry->pilot_one_way_delay,
               CDMA_2000_PILOT_LIST_PILOT_ONE_WAY_DELAY_WIDTH, 
               p_uecc_ue_context);
   }
}


/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_cdma2000_1x_srvcc
 *
 *   INPUTS       : rrc_s1ap_uplink_s1_cdma2000_tunneling_t *p_s1ap_msg
 *                  uecc_ue_context_t*      p_ue_context
 *                  OSCTXT                                  *p_asn1_ctxt
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function build and encode the CDMA2000 1xRTT SRVCC Info
 *       which will further added to uplinks1cdma2000tunneling message going to MME
 *
 *   RETURNS: RRC_SUCCESS or RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_build_cdma2000_1x_srvcc
(
 rrc_s1ap_uplink_s1_cdma2000_tunneling_t *p_s1ap_msg,
 uecc_ue_context_t                       *p_ue_context,
 OSCTXT                                  *p_asn1_ctxt
)
{

    rrc_return_et                       result = RRC_FAILURE;
    OSDynOctStr*  p_octet_data = PNULL;
    
    RRC_ASSERT(PNULL != p_s1ap_msg);
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_asn1_ctxt);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    do
    {
       p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMEID.numocts =
            MEID_NBITS/8;
       
       p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMEID.data = 
                (OSOCTET*)rtxMemAlloc(p_asn1_ctxt,
                 p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMEID.numocts);
       
       if (PNULL== p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMEID.data)
       {
           RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                 (p_ue_context->p_gb_context)->facility_name,
                   RRC_FATAL, 
                   "[uecc_s1ap_build_cdma2000_1x_srvcc]"
                   "ASN malloc failed.");
       
            break;
        }

        memset_wrapper((void*)p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMEID.data, 0, 
                        p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMEID.numocts);
        
        if((p_ue_context->cdma2000_info.ulhandoverPrepTransfer_r8_IEs_meid_numbits != 0)
             && 
          (&(p_ue_context->cdma2000_info.ulhandoverPrepTransfer_r8_IEs_meid_data[0]) != '\0' ))
        {
           
              l3_memcpy_wrapper((void*)p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMEID.data,
                         (void *)&( p_ue_context->cdma2000_info.
                        ulhandoverPrepTransfer_r8_IEs_meid_data),
                       p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMEID.numocts);
        }
        else
        {
               RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[uecc_s1ap_build_cdma2000_1x_srvcc]" 
                "CDMA2000 1xRTT MEID is not present");
           break;
        }
        
        
        /* Fill Mobile Subscription Information */
 
         p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMSI.numocts = 
           p_ue_context->cdma2000_info.ulhandoverPrepTransfer_r8_IEs_msi_numocts;
                    
          p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMSI.data = 
                         (OSOCTET*)rtxMemAlloc(p_asn1_ctxt,
                          p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMSI.numocts);
                
          if (PNULL== p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMSI.data)
          {
              RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL, 
                        "[uecc_s1ap_build_cdma2000_1x_srvcc]"
                        "ASN malloc failed.");
                 
              break;
          }
                
          memset_wrapper((void*)p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMSI.data, 0,
                      p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMSI.numocts);
          
              l3_memcpy_wrapper((void*)p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMSI.data,
                         (void *)&( p_ue_context->cdma2000_info.
                        ulhandoverPrepTransfer_r8_IEs_msi_data),
                      p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXMSI.numocts);
  
          /* fill pilot info */
                p_octet_data = rrc_fill_pilot_list_octet(
                        p_ue_context,
                        &p_ue_context->ho_info.p_ho_info->p_src_ho_info->\
                        s1_src_ho_info.p_rrc_rrm_ho_required->\
                        cdma2000_information.pilot_list);
                if (PNULL == p_octet_data)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL, 
                        "[%s]Fail to fill Pilot List Octet",__FUNCTION__);
                    break;
                }

                p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXPilot.numocts = 
                    p_octet_data->numocts;

                l3_memcpy_wrapper(&p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXPilot.data,
                        p_octet_data->data,
                        p_octet_data->numocts);
                
                p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXPilot.numocts = 
                 10;

                p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXPilot.data = 
                         (OSOCTET*)rtxMemAlloc(p_asn1_ctxt,
                         p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXPilot.numocts);
                
                if (PNULL== p_s1ap_msg->cdma2000_1x_srvcc.cdma2000OneXPilot.data)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL, 
                        "[uecc_s1ap_build_cdma2000_1x_srvcc]"
                        "ASN malloc failed.");
                    break;
                }
                
               p_s1ap_msg->cdma2000_1x_srvcc.m.iE_ExtensionsPresent = 0;
                /* Information Build Successful */
                result = RRC_SUCCESS;
    }while(0);
        /* coverity_fix_63276_start */
    if (PNULL != p_octet_data)
    {
        if (PNULL != p_octet_data->data)
        {
            rrc_mem_free((void *)(p_octet_data->data));
            p_octet_data->data = PNULL;
        }
        rrc_mem_free(p_octet_data);
    }
        /* coverity_fix_63276_stop */
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_fill_cellChangeOrder_targetRAT_Type
 *
 *   INPUTS       : OSCTXT                           *p_asn1_ctx
 *                  uecc_ue_context_t*      p_ue_context
 *                  rrc_target_rat_type_t            *p_target_rat_params
 *                  CellChangeOrder_targetRAT_Type   *p_targetRAT_Type
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function encodes cellChangeOrder_targetRAT_Type
 *
 *   RETURNS: RRC_SUCCESS or RRC_FAILURE
 *
 *******************************************************************************/
static rrc_return_et uecc_s1ap_fill_cellChangeOrder_targetRAT_Type(
        OSCTXT                           *p_asn1_ctx,
        uecc_ue_context_t                *p_ue_context,
        rrc_target_rat_type_t            *p_target_rat_params,
        CellChangeOrder_targetRAT_Type   *p_targetRAT_Type)
{
    U32 count = 0;
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_targetRAT_Type);
    RRC_ASSERT(PNULL != p_target_rat_params);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    p_targetRAT_Type->t = T_CellChangeOrder_targetRAT_Type_geran;
    p_targetRAT_Type->u.geran = 
        rtxMemAllocType(p_asn1_ctx,CellChangeOrder_targetRAT_Type_geran);
    if (PNULL == p_targetRAT_Type->u.geran)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_FATAL, "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                "Memory allocation failed for CellChangeOrder_targetRAT_Type_geran");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    asn1Init_CellChangeOrder_targetRAT_Type_geran(
            p_targetRAT_Type->u.geran);
    p_targetRAT_Type->u.geran->physCellId.networkColourCode.numbits = 3;
    p_targetRAT_Type->u.geran->physCellId.networkColourCode.data[0] =
        p_target_rat_params->geran_params.pci_geran.network_colour_code << 5;

    p_targetRAT_Type->u.geran->physCellId.baseStationColourCode.numbits = 3;
    p_targetRAT_Type->u.geran->physCellId.baseStationColourCode.data[0] =
        p_target_rat_params->geran_params.pci_geran.base_station_colour_code << 5;

    p_targetRAT_Type->u.geran->carrierFreq.arfcn =
        p_target_rat_params->geran_params.carr_freq.arfcn;
    p_targetRAT_Type->u.geran->carrierFreq.bandIndicator = 
        (U32)p_target_rat_params->geran_params.carr_freq.band_indicator;

    if (RRC_RRM_UE_CCO_TARGET_RAT_GERAN_TYPE_NCO_PRESENT & 
            p_target_rat_params->geran_params.bitmask)
    {
       p_targetRAT_Type->u.geran->m.networkControlOrderPresent = 1;
       p_targetRAT_Type->u.geran->networkControlOrder.numbits = 2;
       p_targetRAT_Type->u.geran->networkControlOrder.data[0] =
            p_target_rat_params->geran_params.nco << 6;
    }
    if (RRC_RRM_UE_CCO_TARGET_RAT_GERAN_TYPE_SI_PSI_PRESENT &
            p_target_rat_params->geran_params.bitmask)
    {
       p_targetRAT_Type->u.geran->m.systemInformationPresent = 1;
        if (p_target_rat_params->geran_params.si_list.bitmask & 
                SYSTEM_INFO_LIST_GERAN_SI_PRESENT)
        {
           p_targetRAT_Type->u.geran->systemInformation.t = T_SI_OrPSI_GERAN_si;
           p_targetRAT_Type->u.geran->systemInformation.u.si =
                rtxMemAllocType(p_asn1_ctx,SystemInfoListGERAN);
            if (PNULL ==p_targetRAT_Type->u.geran->systemInformation.u.si)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL, "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                        "Memory allocation failed for SystemInfoListGERAN_si");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            asn1Init_SystemInfoListGERAN(p_targetRAT_Type->u.geran->systemInformation.u.si);
            p_targetRAT_Type->u.geran->systemInformation.u.si->n = 
                p_target_rat_params->geran_params.si_list.si.count;

            for (count = 0; count < p_target_rat_params->geran_params.si_list.si.count; count++)
            {
                if(RRC_RRM_SYS_INFO_CONTAINER_ENCODED_PRESENT &
                        p_target_rat_params->geran_params.si_list.si.
                        system_info_geran_elem[count].bitmask )
                {

                    p_targetRAT_Type->u.geran->systemInformation.u.si->
                        elem[count].numocts = p_target_rat_params->geran_params.si_list.si.
                        system_info_geran_elem[count].sys_info_container_encoded_si_info.length;
                    l3_memcpy_wrapper(p_targetRAT_Type->u.geran->systemInformation.u.si->
                            elem[count].data,
                            p_target_rat_params->geran_params.si_list.si.system_info_geran_elem[count].
                            sys_info_container_encoded_si_info.data,
                            p_targetRAT_Type->u.geran->systemInformation.u.si->
                            elem[count].numocts);
                }
            }
        }
        else if(p_target_rat_params->geran_params.si_list.bitmask & 
                SYSTEM_INFO_LIST_GERAN_PSI_PRESENT)
        {
            p_targetRAT_Type->u.geran->systemInformation.t = T_SI_OrPSI_GERAN_psi;
            p_targetRAT_Type->u.geran->systemInformation.u.psi =
                rtxMemAllocType(p_asn1_ctx,SystemInfoListGERAN);
            if (PNULL == p_targetRAT_Type->u.geran->systemInformation.u.psi)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL, "[uecc_s1ap_fillMobilityFromEUTRACommand]"
                        "Memory allocation failed for SystemInfoListGERAN_si");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            asn1Init_SystemInfoListGERAN(p_targetRAT_Type->u.geran->systemInformation.u.psi);
            p_targetRAT_Type->u.geran->systemInformation.u.psi->n = 
                p_target_rat_params->geran_params.si_list.psi.count;

            for (count = 0; count < p_target_rat_params->geran_params.si_list.psi.count; count++)
            {
                if(RRC_RRM_SYS_INFO_CONTAINER_ENCODED_PRESENT &
                        p_target_rat_params->geran_params.si_list.psi.
                        system_info_geran_elem[count].bitmask )
                {
                    p_targetRAT_Type->u.geran->systemInformation.u.psi->
                        elem[count].numocts = p_target_rat_params->geran_params.si_list.psi.
                        system_info_geran_elem[count].sys_info_container_encoded_si_info.length;
                    l3_memcpy_wrapper(p_targetRAT_Type->u.geran->systemInformation.u.psi->
                            elem[count].data,
                            p_target_rat_params->geran_params.si_list.psi.system_info_geran_elem[count].
                            sys_info_container_encoded_si_info.data,
                            p_targetRAT_Type->u.geran->systemInformation.u.psi->
                            elem[count].numocts);
                }
            }
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/*BUG 604 changes start*/ 
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_intra_cell_ho_success_ind
 *   INPUTS       : uecc_ue_context_t*  p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends S1AP_INTRA_CELL_HO_SUCCESS_IND message
 *       to S1AP module
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_intra_cell_ho_success_ind(
        uecc_ue_context_t*  p_ue_context
        )
{
    rrc_return_et result = RRC_FAILURE;
    s1ap_intra_cell_ho_success_ind_t intra_cell_ho_success_ind;

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    intra_cell_ho_success_ind.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;
    intra_cell_ho_success_ind.ue_index = p_ue_context->ue_index;

    /* Send message to S1AP  */
    result = uecc_rrc_send_internal_msg(
            RRC_S1AP_MODULE_ID,
            S1AP_INTRA_CELL_HO_SUCCESS_IND,
            sizeof(s1ap_intra_cell_ho_success_ind_t),
            &intra_cell_ho_success_ind);

    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
            (p_ue_context->p_gb_context)->facility_name,
            RRC_INFO, "S1AP_MSG: INTRACELL HO SUCCESS IND");

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}
/*BUG 604 changes stop*/ 
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_fill_candidiate_cell_info_list 
 *
 *   INPUTS       : uecc_ue_context_t           *p_ue_context
 *                  OSCTXT                      *p_asn1_ctx
 *                  RRM_Config                  *p_RRM_Config
 *                  rrm_rrc_container_t         *p_rrc_container
 *   OUTPUTS      : None
 *
 *   DESCRIPTION  : This function builds CandidateCellInfoList_r10.
 *
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_fill_candidiate_cell_info_list (
    uecc_ue_context_t         *p_ue_context,
    OSCTXT                    *p_asn1_ctx,
    RRM_Config                *p_RRM_Config,    /*dest*/
    rrm_rrc_container_t       *p_rrc_container  /*src*/
    )
{
    OSRTDListNode* p_node = PNULL;
    CandidateCellInfo_r10 *p_elem = PNULL;
    U8 index = RRC_NULL;

    RRC_ASSERT(PNULL != p_ue_context); 
    RRC_ASSERT(PNULL != p_RRM_Config);
    RRC_ASSERT(PNULL != p_rrc_container); 
    
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    asn1Init_CandidateCellInfoList_r10(&p_RRM_Config->candidateCellInfoList_r10);

    if ((p_rrc_container->bitmask & RRM_RRC_CONTAINER_RRM_CONFIG_PRESENT) &&
            (p_rrc_container->rrm_config.bitmask & 
             RRM_CONFIG_EXT_CANDIDATE_CELL_INFO_LIST_PRESENT))
    {
        p_RRM_Config->m._v2ExtPresent = 1;
        p_RRM_Config->m.candidateCellInfoList_r10Present = 1;

        for (index = RRC_NULL; index < p_rrc_container->rrm_config.
                candidate_cell_info_list.count; index++)
        {
            rtxDListAllocNodeAndData(p_asn1_ctx,
                    CandidateCellInfo_r10,
                    &p_node,
                    &p_elem);

            if (PNULL == p_node)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,"Can't allocate p_node");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            asn1Init_CandidateCellInfo_r10(p_elem);

            p_elem->physCellId_r10 = p_rrc_container->rrm_config.candidate_cell_info_list.
                candidate_cell_info[index].phy_cell_id;

            p_elem->dl_CarrierFreq_r10 = p_rrc_container->rrm_config.candidate_cell_info_list.
                candidate_cell_info[index].carrier_freq;

            if (p_rrc_container->rrm_config.candidate_cell_info_list.
                    candidate_cell_info[index].bitmask & CANDIDATE_CELL_INFO_RSRP_PRESENT )
            {
                p_elem->m.rsrpResult_r10Present = 1;
                p_elem->rsrpResult_r10 = p_rrc_container->rrm_config.candidate_cell_info_list.
                    candidate_cell_info[index].rsrp_result;
            }

            if (p_rrc_container->rrm_config.candidate_cell_info_list.
                    candidate_cell_info[index].bitmask & CANDIDATE_CELL_INFO_RSRQ_PRESENT)
            {
                p_elem->m.rsrqResult_r10Present = 1;
                p_elem->rsrqResult_r10 = p_rrc_container->rrm_config.candidate_cell_info_list.
                    candidate_cell_info[index].rsrq_result;
            }
            
            /* OSRTDList */
            rtxDListInit(&p_elem->extElem1);

            rtxDListAppendNode(&p_RRM_Config->candidateCellInfoList_r10 , p_node);
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/* OPTION3X Changes Start */
#ifdef ENDC_ENABLED
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_e_rab_not_to_be_modified_list
 *   INPUTS       : uecc_ue_context_t*             p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds s1ap_E_RABNotToBeModifiedListBearerModInd list
 *       in E-RABModificationIndication Msg. 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_e_rab_not_to_be_modified_list(
        uecc_ue_context_t   *p_ue_context,
        OSCTXT              *p_asn1_ctx,
        OSRTDList           *p_erabNotToBeModifiedList
)
{
    rrc_return_et           result  = RRC_FAILURE;
    OSRTDListNode           *p_node = RRC_NULL;
    s1ap_E_RABNotToBeModifiedListBearerModInd_element
        *p_erabNotToBeModifiedList_item = RRC_NULL;
    s1ap_E_RABNotToBeModifiedItemBearerModInd 
        *p_erabNotToBeModifiedItemBearerModInd = RRC_NULL;
    rrc_drb_to_modify_list_t  *p_drb_to_modify_list = RRC_NULL;
    U16                              erab_count = 0;
    U16                              erab_idx = 0;
    rrc_bool_t                       is_modified = RRC_FALSE;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_erabNotToBeModifiedList);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    
    if ( RRC_NULL != p_ue_context->p_curr_proc_data &&
            UECC_RRM_DC_BEARER_CHANGE_PROC != p_ue_context->p_curr_proc_data->t)
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                "[s1ap_E_RAB_MODIFICATION_IND]"
                " Current Procedure is not UECC_RRM_DC_BEARER_CHANGE_PROC");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return result;

    }

    asn1Init_s1ap_E_RABNotToBeModifiedListBearerModInd(p_erabNotToBeModifiedList);

    for(erab_idx = 0;
            erab_idx < p_ue_context->e_rab_list_count &&
            erab_idx < MAX_ERAB_COUNT;
            erab_idx++)
    {
        /*Skip If  E-RAB Context is NULL*/
        if (RRC_NULL == p_ue_context->p_e_rab_list[erab_idx])
        {
            continue;
        }

        /* coverity_277498_fix_start */
        if( (RRC_NULL != p_ue_context->p_curr_proc_data ) &&
              ( RRC_ONE == p_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data.m.
                drb_config_updated))
        /* coverity_277498_fix_end */
        {
            p_drb_to_modify_list = &(p_ue_context->p_curr_proc_data->u.
                    rrm_dc_bearer_change_request_data.drb_to_modify_list);

            is_modified = RRC_FALSE;

            for ( erab_count = RRC_ZERO;
                    erab_count < p_drb_to_modify_list->drb_count;
                    erab_count++)
            {
                /* Check the current ERABID is not same as ANY ERAB Present in
                 * DC_BEARER_CHANGE DRB-TO-MOFIFY Success DATA */
                 /*Logical_Error*/
                if(((RRC_TRUE == p_drb_to_modify_list->drb_config[erab_count].erab_success) || 
                	(RRC_FALSE == p_drb_to_modify_list->drb_config[erab_count].erab_failed))
                 /*Logical_Error*/
                        &&
                        p_drb_to_modify_list->drb_config[erab_count].erab_id ==
                        p_ue_context->p_e_rab_list[erab_idx]->e_RAB_ID)
                {
                    is_modified = RRC_TRUE;
                    break;
                }
            }

            if (RRC_TRUE == is_modified)
            {
                /*Skip the Rab if E-RAB is added in ERAB-To-Be-Modified list*/
                continue;
            }
        }

        rtxDListAllocNodeAndData(p_asn1_ctx, 
                s1ap_E_RABNotToBeModifiedListBearerModInd_element,
                &p_node, 
                &p_erabNotToBeModifiedList_item);

        if (PNULL == p_node)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "ASN malloc failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return result;
        }
        asn1Init_s1ap_E_RABNotToBeModifiedListBearerModInd_element(p_erabNotToBeModifiedList_item);

        p_erabNotToBeModifiedList_item->id = ASN1V_s1ap_id_E_RABNotToBeModifiedListBearerModInd;
        p_erabNotToBeModifiedList_item->criticality = s1ap_reject;

        p_erabNotToBeModifiedList_item->value.t = T115__E_RABNotToBeModifiedItemBearerModIndIEs_1; 


        p_erabNotToBeModifiedItemBearerModInd =  rtxMemAllocType(p_asn1_ctx,
                s1ap_E_RABNotToBeModifiedItemBearerModInd);
        if (PNULL == p_erabNotToBeModifiedItemBearerModInd)
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                    p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                    "ASN malloc failed");
            RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            return result;
        }

        asn1Init_s1ap_E_RABNotToBeModifiedItemBearerModInd(p_erabNotToBeModifiedItemBearerModInd);

        p_erabNotToBeModifiedList_item->value.u._E_RABNotToBeModifiedItemBearerModIndIEs_1 =
            p_erabNotToBeModifiedItemBearerModInd; 

        p_erabNotToBeModifiedItemBearerModInd->e_RAB_ID = erab_idx;

        /* TransportLayerAddress */
        if(RRC_ONE == p_ue_context->p_e_rab_list[erab_idx]->m.DC_BearerTypePresent &&
                SN_TERMINATED_SCG_BEARER ==
                p_ue_context->p_e_rab_list[erab_idx]->dc_bearer_type)
        {
            p_erabNotToBeModifiedItemBearerModInd->transportLayerAddress.data =
                (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                        p_ue_context->p_e_rab_list[erab_idx]->
                        sgnb_s1ap_transportLayerAddress.numbits/8);
            if (PNULL ==
                    p_erabNotToBeModifiedItemBearerModInd->transportLayerAddress.data)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR, "ASN malloc failed.");
                return RRC_FAILURE;
            }
            l3_memcpy_wrapper(
                    ((void*)p_erabNotToBeModifiedItemBearerModInd->transportLayerAddress.data),
                    p_ue_context->p_e_rab_list[erab_idx]->sgnb_s1ap_transportLayerAddress.data,
                    p_ue_context->p_e_rab_list[erab_idx]->sgnb_s1ap_transportLayerAddress.numbits/8
                    );

            p_erabNotToBeModifiedItemBearerModInd->transportLayerAddress.numbits =
                (OSUINT32)(p_ue_context->p_e_rab_list[erab_idx]->
                        sgnb_s1ap_transportLayerAddress.numbits);
        }
        else
        {
            p_erabNotToBeModifiedItemBearerModInd->transportLayerAddress.data =
                (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                        p_ue_context->p_e_rab_list[erab_idx]->self_transport_address_length);

            if (PNULL == p_erabNotToBeModifiedItemBearerModInd->transportLayerAddress.data)
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                        p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                        "ASN malloc failed");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return result;
            }
            p_erabNotToBeModifiedItemBearerModInd->transportLayerAddress.numbits =
                (OSUINT32)(p_ue_context->p_e_rab_list[erab_idx]->self_transport_address_length*8);

            l3_memcpy_wrapper((void*)p_erabNotToBeModifiedItemBearerModInd->transportLayerAddress.data,
                    (p_ue_context->p_e_rab_list[erab_idx]->self_transport_address),
                    p_ue_context->p_e_rab_list[erab_idx]->self_transport_address_length
                    );
        }

        /* gTP_TEID */
        if(RRC_ONE == p_ue_context->p_e_rab_list[erab_idx]->m.DC_BearerTypePresent &&
                SN_TERMINATED_SCG_BEARER ==
                p_ue_context->p_e_rab_list[erab_idx]->dc_bearer_type)
        {
            p_erabNotToBeModifiedItemBearerModInd->dL_GTP_TEID.numocts =
                p_ue_context->p_e_rab_list[erab_idx]->sgnb_s1ap_gtp_id.numocts;

            l3_memcpy_wrapper(p_erabNotToBeModifiedItemBearerModInd->dL_GTP_TEID.data,
                    p_ue_context->p_e_rab_list[erab_idx]->sgnb_s1ap_gtp_id.data,
                    p_erabNotToBeModifiedItemBearerModInd->dL_GTP_TEID.numocts
                    );
        }
        else
        {
            p_erabNotToBeModifiedItemBearerModInd->dL_GTP_TEID.numocts =
                sizeof(p_erabNotToBeModifiedItemBearerModInd->dL_GTP_TEID.data);

            rrc_pack_U32(
                    p_erabNotToBeModifiedItemBearerModInd->dL_GTP_TEID.data,
                    &p_ue_context->p_e_rab_list[erab_idx]->teid_self);
        }

        /* Append Node in the List*/
        rtxDListAppendNode(p_erabNotToBeModifiedList, p_node);
    }

    result = RRC_SUCCESS;

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_e_rab_to_be_modified_list
 *   INPUTS       : uecc_ue_context_t*             p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds s1ap_E_RABToBeModifiedListBearerModInd list
 *       in E-RABModificationIndication Msg. 
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_e_rab_to_be_modified_list(
        uecc_ue_context_t   *p_ue_context,
        OSCTXT              *p_asn1_ctx,
        OSRTDList           *p_erabToBeModifiedList
)
{
    rrc_return_et           result  = RRC_FAILURE;
    OSRTDListNode           *p_node = RRC_NULL;
    s1ap_E_RABToBeModifiedListBearerModInd_element
        *p_erabToBeModifiedList_item = RRC_NULL;
    s1ap_E_RABToBeModifiedItemBearerModInd 
        *p_erabToBeModifiedItemBearerModInd = RRC_NULL;
    rrc_drb_to_modify_list_t  *p_drb_to_modify_list = RRC_NULL;
    U16                              erab_count = 0;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_asn1_ctx);
    RRC_ASSERT(PNULL != p_erabToBeModifiedList);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    
    if ( RRC_NULL != p_ue_context->p_curr_proc_data &&
            UECC_RRM_DC_BEARER_CHANGE_PROC != p_ue_context->p_curr_proc_data->t)
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                "[s1ap_E_RAB_MODIFICATION_IND]"
                " Current Procedure is not UECC_RRM_DC_BEARER_CHANGE_PROC");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return result;

    }

    /* coverity_277495_fix_start */
    if( ( RRC_NULL != p_ue_context->p_curr_proc_data ) &&
         (RRC_ONE == p_ue_context->p_curr_proc_data->u.rrm_dc_bearer_change_request_data.m.
            drb_config_updated))
    /* coverity_277495_fix_end */
    {
        p_drb_to_modify_list = &(p_ue_context->p_curr_proc_data->u.
                rrm_dc_bearer_change_request_data.drb_to_modify_list);

        asn1Init_s1ap_E_RABToBeModifiedListBearerModInd(p_erabToBeModifiedList);

        for ( erab_count = RRC_ZERO;
                erab_count < p_drb_to_modify_list->drb_count;
                erab_count++)
        {
                 /*Logical_Error*/
            if ((RRC_TRUE == p_drb_to_modify_list->drb_config[erab_count].erab_failed) ||
            	(RRC_FALSE == p_drb_to_modify_list->drb_config[erab_count].erab_success))
                 /*Logical_Error*/
            {
                /* Skip the Failed Erabs in DC_Bearer_Change Req data*/
                continue;
            }
            rtxDListAllocNodeAndData(p_asn1_ctx, 
                    s1ap_E_RABToBeModifiedListBearerModInd_element,
                    &p_node, 
                    &p_erabToBeModifiedList_item);

            if (PNULL == p_node)
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                        p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                        "ASN malloc failed");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return result;
            }
            asn1Init_s1ap_E_RABToBeModifiedListBearerModInd_element(p_erabToBeModifiedList_item);

            p_erabToBeModifiedList_item->id = ASN1V_s1ap_id_E_RABToBeModifiedItemBearerModInd;
            p_erabToBeModifiedList_item->criticality = s1ap_reject;

            p_erabToBeModifiedList_item->value.t = T113__E_RABToBeModifiedItemBearerModIndIEs_1; 


            p_erabToBeModifiedItemBearerModInd =  rtxMemAllocType(p_asn1_ctx,
                    s1ap_E_RABToBeModifiedItemBearerModInd);
            if (PNULL == p_erabToBeModifiedItemBearerModInd)
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                        p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                        "ASN malloc failed");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return result;
            }

            asn1Init_s1ap_E_RABToBeModifiedItemBearerModInd(p_erabToBeModifiedItemBearerModInd);

            p_erabToBeModifiedList_item->value.u._E_RABToBeModifiedItemBearerModIndIEs_1 =
                p_erabToBeModifiedItemBearerModInd; 

            p_erabToBeModifiedItemBearerModInd->e_RAB_ID = 
                p_drb_to_modify_list->drb_config[erab_count].erab_id;

            /* Check if SgNB GTP TeID and Transport Layer address is present in Curr Proc*/
            if(RRC_ONE !=
                    p_drb_to_modify_list->drb_config[erab_count].m.rrc_x2u_sgnb_s1ap_gtp_id_updated
                || RRC_ONE !=
                    p_drb_to_modify_list->drb_config[erab_count].m.
                    rrc_x2u_sgnb_s1ap_transportLayerAddress_updated)
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                        p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                        "SgNB S1AP TeID or TransportLayerAddress not Present.");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return result;
            }
            /* TransportLayerAddress */
            p_erabToBeModifiedItemBearerModInd->transportLayerAddress.data =
                (OSOCTET*)rtxMemAlloc(p_asn1_ctx,
                        p_drb_to_modify_list->drb_config[erab_count].sgnb_s1ap_transportLayerAddress.numbits/8);

            if (PNULL == p_erabToBeModifiedItemBearerModInd->transportLayerAddress.data)
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                        p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                        "ASN malloc failed");
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return result;
            }
            p_erabToBeModifiedItemBearerModInd->transportLayerAddress.numbits =
                p_drb_to_modify_list->drb_config[erab_count].sgnb_s1ap_transportLayerAddress.numbits;

            l3_memcpy_wrapper((void*)p_erabToBeModifiedItemBearerModInd->transportLayerAddress.data,
                    p_drb_to_modify_list->drb_config[erab_count].sgnb_s1ap_transportLayerAddress.data,
                    p_drb_to_modify_list->drb_config[erab_count].sgnb_s1ap_transportLayerAddress.numbits/8);

            /* gTP_TEID */
            p_erabToBeModifiedItemBearerModInd->dL_GTP_TEID.numocts = 
                p_drb_to_modify_list->drb_config[erab_count].sgnb_s1ap_gtp_id.numocts;    

            l3_memcpy_wrapper((void*)p_erabToBeModifiedItemBearerModInd->dL_GTP_TEID.data,
                    p_drb_to_modify_list->drb_config[erab_count].sgnb_s1ap_gtp_id.data,
                    p_drb_to_modify_list->drb_config[erab_count].sgnb_s1ap_gtp_id.numocts);

            rtxDListAppendNode(p_erabToBeModifiedList, p_node);
        }

        result = RRC_SUCCESS;
    }
    


    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;

}
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_erab_modification_ind
 *   INPUTS       : uecc_ue_context_t*             p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function builds and sends erab_modification_ind message
 *       to S1AP
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 *******************************************************************************/
rrc_return_et uecc_s1ap_build_and_send_erab_modification_ind(
        uecc_ue_context_t*             p_ue_context)
{
    rrc_return_et                       result          = RRC_FAILURE;
    OSCTXT                              asn1_ctx;
    rrc_s1ap_erab_modification_ind_t    msg;

    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];

    s1ap_ue_associated_sig_msg_req_t *p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t *)sig_msg_req_buf;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_ue_context->p_gb_context);


    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* Init ASN context */
    if (RT_OK != rtInitContext(&asn1_ctx))
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                p_ue_context->p_gb_context->facility_name, RRC_ERROR,
                "[s1ap_E_RAB_MODIFICATION_IND]"
                "   ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /* Reset message */
        memset_wrapper(&msg, 0, sizeof(msg));
        memset_wrapper(sig_msg_req_buf,0,sizeof(s1ap_ue_associated_sig_msg_req_t));

        /* Fill message */
        msg.bitmask = 0;

        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;


        if (RRC_SUCCESS!=uecc_s1ap_build_e_rab_to_be_modified_list(
                    p_ue_context,
                    &asn1_ctx,
                    &msg.erab_to_be_modified_list_ind))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_E_RAB_MODIFICATION_IND]"
                    "uecc_s1ap_build_e_rab_to_be_modified_list failure");
            break;
        }

        /*Fill Erab not To be modified List in ERAB_ModificationIndication Message */
        if (RRC_SUCCESS!=uecc_s1ap_build_e_rab_not_to_be_modified_list(
                    p_ue_context,
                    &asn1_ctx,
                    &msg.erab_not_to_be_modified_list_ind))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_E_RAB_MODIFICATION_IND]"
                    "uecc_s1ap_build_e_rab_to_be_modified_list failure");
            break;
        }
        else
        {
            /* Set Bitmask if entry present in Not-To-Be-Modified-List */
            if(0 < msg.erab_not_to_be_modified_list_ind.count)
            {
                msg.bitmask |=
                    RRC_S1AP_ERAB_MODIFICATION_IND_ERAB_NOT_TO_BE_MODIFIED_LIST_IND_PRESENT;
            }
        }

        result=rrc_s1ap_erab_modification_ind_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0],
                &p_sig_msg_req->message_buff_size,
                &msg);

        if (RRC_SUCCESS!=result)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_E_RAB_MODIFICATION_IND] ASN Encoding Failure ");
            break;
        }
        else
        {
             rrc_asn1PrtToStr_S1AP_PDU(RRC_ASN,
                    "S1AP_PDU", &s1ap_pdu);
        }

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_E_RABModificationIndication;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;

        p_sig_msg_req->ue_index = p_ue_context->ue_index;

        /* Send message to S1AP  */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                    p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "S1AP_MSG:E-RABModificationIndication %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));

    }while(0);

    /* Free ASN Context */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_process_erab_modification_cnf
 *
 *   INPUTS       : S1AP_PDU            *p_s1ap_pd
 *                  uecc_gb_context_t   *p_uecc_gb_context
 *                  U8                  mme_id
 *                  U8          *p_buff
 *                  U16         buff_size
 *   OUTPUTS      : None
 *   DESCRIPTION:
 *       This function processes s1ap_E_RABModificationConfirm 
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
void uecc_s1ap_process_erab_modification_cnf
(
 S1AP_PDU            *p_s1ap_pdu,    /* Pointer to s1ap pdu */
 uecc_gb_context_t   *p_uecc_gb_context, /* UECC global context */
 U8                  mme_id,
 U8          *p_buff,        /* ASN.1 encoded message */
 U16         buff_size,      /* encoded buf size - just for check*/
 U16         ue_index
 )
{
    uecc_ue_context_t              *p_ue_context = PNULL;
    rrc_s1ap_erab_modification_cnf_t  msg;

    RRC_ASSERT(PNULL!=p_s1ap_pdu);
    RRC_ASSERT(PNULL!=p_s1ap_pdu->u.successfulOutcome);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        if (PNULL==p_s1ap_pdu->u.successfulOutcome->value.u.e_RABModificationIndication)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_E_RABModificationConfirm] e_RABModificationIndication field is PNULL");
            break;
        }

        memset_wrapper(&msg, 0, sizeof(rrc_s1ap_erab_modification_cnf_t));

        /* Decode message */
        if( RRC_FAILURE == rrc_s1ap_erab_modification_cnf_intrl_dec(
                    mme_id,
                    p_s1ap_pdu->u.successfulOutcome->value.u.e_RABModificationIndication,
                    &msg,
                    p_uecc_gb_context
                    ))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO, "[s1ap_E_RABModificationConfirm] "
                    "Decoding Failure, Sending Error Indication");
            break;
        }

        /* Process message */
        /* Get context using ue_index */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,ue_index);

        if (PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_E_RABModificationConfirm] UE context not found");

            break;
        }
        
        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_ue_context->p_gb_context,
                    p_ue_context->cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[s1ap_E_RABModificationConfirm]"
                    "message dropped - "
                    "UECC isn't initialized by CSC" );
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            return;
        }
        if (0!=p_ue_context->m.mme_ue_id_present)
        {
            if (msg.mme_ue_s1ap_id != p_ue_context->mme_ue_id)
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[s1ap_E_RABModificationConfirm] "
                        "mme_ue_s1ap_id (%i) != p_ue_context->mme_ue_id (%i)",
                        msg.mme_ue_s1ap_id,
                        p_ue_context->mme_ue_id);

                break;
            }
        }
        else
        {
            /* store mme_ue_s1ap_id in UE context */
            p_ue_context->m.mme_ue_id_present = 1;
            p_ue_context->mme_ue_id = msg.mme_ue_s1ap_id;
        }
        
        /* Call UECC_UE_EVENT_UE_CTX_SETUP_REQ event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_S1AP_ERAB_MODIFICATION_CNF,
                &msg);
    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_e_rab_release_indication_endc
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION  : This function builds and sends e_rab_release_indication message
 *                  to S1AP
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *******************************************************************************/
rrc_return_et
uecc_s1ap_build_and_send_e_rab_release_indication_endc
(
        uecc_ue_context_t* p_ue_context
)
{
    erab_list_t erab_list;
    OSCTXT asn1_ctx;
    rrc_s1ap_e_rab_release_indication_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t*  p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t*)sig_msg_req_buf;
    rrc_return_et result = RRC_FAILURE;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = RRC_NULL;
    U32                     free_erab_index = RRC_NULL;

    RRC_ASSERT(PNULL != p_ue_context);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&erab_list, RRC_NULL, sizeof(erab_list_t));

    if ( p_ue_context->m.traceActivated )
    {
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
                (p_ue_context->p_ue_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & S1) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),GEN_MME,"\n<msg function=\"S1AP\" name=\"E-RAB RELEASE Indication\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
        }
        if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
                (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
                (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & S1) &&
                ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MEDIUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
                (MINIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
        {
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),GEN_CELL,"\n<msg function=\"S1AP\" name=\"E-RAB RELEASE Indication\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
                    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
        }
            P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),S1,"\n <target type=\"MME\">%s</target>",
                    p_ue_context->p_gb_context->mme_ctx[p_ue_context->mme_id].connection_info.ip_addr[0].ip_addr);
    }

    /*
     * Init ASN context
     */
    if ( RT_OK != rtInitContext(&asn1_ctx) )
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_ERABReleaseIndication]"
                "ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /*
         * Reset message
         */
        memset_wrapper(&msg, RRC_NULL, sizeof(msg));
        memset_wrapper(sig_msg_req_buf, RRC_NULL, 
                sizeof(s1ap_ue_associated_sig_msg_req_t));

        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

        for (free_erab_index = RRC_NULL;
                free_erab_index < RRC_MAX_NUM_DRB;
                free_erab_index++)
        {
            if (PNULL != 
                    p_ue_context->p_e_rab_list
                    [free_erab_index])
            {
                if ( ( p_ue_context->p_e_rab_list[free_erab_index]->m.DC_BearerTypePresent ) &&
                        ( ( SN_TERMINATED_SPLIT_BEARER == p_ue_context->
                          p_e_rab_list[free_erab_index]->dc_bearer_type ) ||
                        ( SN_TERMINATED_SCG_BEARER == p_ue_context->
                          p_e_rab_list[free_erab_index]->dc_bearer_type ) )
                   ) 
                {
                    erab_list.erab_item[erab_list.counter].e_RAB_ID = p_ue_context->
                        p_e_rab_list[free_erab_index]->e_RAB_ID;
                    erab_list.erab_item[erab_list.counter].cause.t = RRC_ONE; 
                    erab_list.erab_item[erab_list.counter].cause.u.radioNetwork = RRC_THREE; 
                    erab_list.counter++;
                }
            }
        }
        if ( RRC_SUCCESS != uecc_s1ap_build_e_rab_released_list_arp(
                        p_ue_context, &asn1_ctx, &msg.e_rab_released_list,
                        &erab_list) )
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ERABReleaseIndication]"
                    "uecc_s1ap_build_e_rab_released_list_arp failure");
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "[s1ap_ERABReleaseIndication]"
                    "uecc_s1ap_build_e_rab_released_list_arp failure");
            break;
        }

        /*
         * Encode message
         */
        result = rrc_s1ap_e_rab_release_indication_intrl_enc(
                p_ue_context->p_gb_context,
                &asn1_ctx,
                &p_sig_msg_req->message_buff_p[0], 
                &p_sig_msg_req->message_buff_size,
                &msg);

        if ( RRC_SUCCESS != result )
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[s1ap_ERABReleaseIndication] Build failure");
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "[s1ap_ERABReleaseIndication] Build failure");
            break;
        }
        else
        {
            encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

          
            rrc_asn1PrtToStr_S1AP_PDU(
                    RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);

            p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
                    encoded_msg_len);
            if ( PNULL != p_event_header )
            {
                rrc_uecc_fill_protocol_event_params(p_ue_context,
                        p_event_header,
                        (sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
                        LOCAL_S1_ERAB_RELEASE_INDICATION,
                        MESSAGE_DIRECTION_SEND);

                l3_memcpy_wrapper((void*)((U8*)p_event_header + 
                            sizeof(EVENT_EXTERNAL_HEADER)),
                        (const void*)p_sig_msg_req->message_buff_p,
                        encoded_msg_len);

                rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
            }
        }

        p_sig_msg_req->procedure_code = ASN1V_s1ap_id_E_RABReleaseIndication;
        p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
        p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
        p_sig_msg_req->cell_index = p_ue_context->cell_index;
        p_sig_msg_req->ue_index = p_ue_context->ue_index;

        uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, &p_sig_msg_req->message_buff_p[0], 
                        p_sig_msg_req->message_buff_size, "E-RAB RELEASE Indication", 1);
        
        /*
         * Send message to S1AP
         */
        result = uecc_rrc_send_internal_msg(
                RRC_S1AP_MODULE_ID,
                S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
                (U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
                      p_sig_msg_req->message_buff_size),
                sig_msg_req_buf);

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_INFO, "S1AP_MSG: E-RABReleaseIndication %s",
                change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));

    } while (RRC_NULL);

    /*
     * Free ASN Context
     */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;

}

/******************************************************************************
 *   FUNCTION NAME: uecc_s1ap_build_and_send_secodary_rat_data_usage_report
 *   INPUTS       : uecc_ue_context_t* p_ue_context
 *   OUTPUTS      : None
 *   DESCRIPTION  : This function builds and sends secodary_rat_data_usage_report message
 *                  to S1AP
 *   RETURNS      : RRC_SUCCESS/RRC_FAILURE
 *******************************************************************************/

rrc_return_et
uecc_s1ap_build_and_send_secodary_rat_data_usage_report
(
        uecc_ue_context_t* p_ue_context
)
{
    OSCTXT asn1_ctx;
    rrc_s1ap_secondary_rat_data_usage_rep_t msg;
    U8 sig_msg_req_buf[sizeof(s1ap_ue_associated_sig_msg_req_t)+
        S1AP_MAX_ASN1_BUF_LEN];
    s1ap_ue_associated_sig_msg_req_t*  p_sig_msg_req =
        (s1ap_ue_associated_sig_msg_req_t*)sig_msg_req_buf;
    rrc_return_et result = RRC_FAILURE;
    EVENT_EXTERNAL_HEADER   *p_event_header = PNULL;
    U32                     encoded_msg_len = RRC_NULL;
    U32                     free_erab_index = RRC_NULL;

	RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);


    /*
     * Init ASN context
     */
    if ( RT_OK != rtInitContext(&asn1_ctx) )
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "[s1ap_ERABReleaseIndication]"
                "ASN context initialization failed");
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    do
    {
        /*
         * Reset message
         */
        memset_wrapper(&msg, RRC_NULL, sizeof(msg));
        memset_wrapper(sig_msg_req_buf, RRC_NULL, 
                sizeof(s1ap_ue_associated_sig_msg_req_t));

        msg.mme_ue_s1ap_id = uecc_ue_ctx_get_mme_ue_id(p_ue_context);
        msg.enb_ue_s1ap_id = p_ue_context->s1ap_ue_id;

        l3_memcpy_wrapper((void*)&msg.secondary_rat_data_usage_report_list,
        (const void *)&p_ue_context->secondary_rat_data_usage_report_list,
        sizeof(rrc_s1ap_SecRATDataReport_list_t));

		/*
		 * Encode message
		 */
		result = rrc_s1ap_secodary_rat_data_usage_report_intrl_enc(
				p_ue_context->p_gb_context,
				&asn1_ctx,
				&p_sig_msg_req->message_buff_p[0], 
				&p_sig_msg_req->message_buff_size,
				&msg);

		if ( RRC_SUCCESS != result )
		{
			RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
					(p_ue_context->p_gb_context)->facility_name,
					RRC_ERROR,
					"[secodary_rat_data_usage_report] Build failure");
			break;
		}
		else
		{
			encoded_msg_len = (U32)pe_GetMsgLen(&asn1_ctx);

		  
			rrc_asn1PrtToStr_S1AP_PDU(
					RRC_ASN,"S1AP_PDU : ", &s1ap_pdu);

			p_event_header = rrc_mem_get(sizeof(EVENT_EXTERNAL_HEADER) +
					encoded_msg_len);
			if ( PNULL != p_event_header )
			{
				rrc_uecc_fill_protocol_event_params(p_ue_context,
						p_event_header,
						(sizeof(EVENT_EXTERNAL_HEADER) + encoded_msg_len),
						LOCAL_S1_ERAB_RELEASE_INDICATION,
						MESSAGE_DIRECTION_SEND);

				l3_memcpy_wrapper((void*)((U8*)p_event_header + 
							sizeof(EVENT_EXTERNAL_HEADER)),
						(const void*)p_sig_msg_req->message_buff_p,
						encoded_msg_len);

				rrc_generate_protocol_events(RRC_PROTOCOL_EVENT, p_event_header);
			}
		}

		p_sig_msg_req->procedure_code = ASN1V_s1ap_id_SecondaryRATDataUsageReport;
		p_sig_msg_req->bitmask |= UE_ASSOC_SIG_MSG_REQ_ENB_UE_S1AP_ID_PRESENT;
		p_sig_msg_req->enb_ue_s1ap_id = msg.enb_ue_s1ap_id;
		p_sig_msg_req->cell_index = p_ue_context->cell_index;
		p_sig_msg_req->ue_index = p_ue_context->ue_index;

		uecc_s1ap_ue_assoc_msg_max_trace_handler(p_ue_context, &p_sig_msg_req->message_buff_p[0], 
						p_sig_msg_req->message_buff_size, "Secondary RAT Data Usage Report", 1);
		
		/*
		 * Send message to S1AP
		 */
		result = uecc_rrc_send_internal_msg(
				RRC_S1AP_MODULE_ID,
				S1AP_UE_ASSOCIATED_SIG_MSG_REQ,
				(U16)(sizeof(s1ap_ue_associated_sig_msg_req_t) +
					  p_sig_msg_req->message_buff_size),
				sig_msg_req_buf);

		RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
				(p_ue_context->p_gb_context)->facility_name,
				RRC_INFO, "S1AP_MSG: Secondary RAT Data Usage Report %s",
				change_data_to_str(p_sig_msg_req->message_buff_size, p_sig_msg_req->message_buff_p));

	
    }while (RRC_NULL);


    /*
     * Free ASN Context
     */
    rtFreeContext(&asn1_ctx);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;

}

#endif
/* OPTION3X Changes End */

