/******************************************************************************
*
*   FILE NAME:
*       uecc_rrm.c
*
*   DESCRIPTION:
*       This is the source file of the UECC RRM.
*       UECC RRM interacts with RRC RRM module.
*
*   DATE            AUTHOR      REFERENCE       REASON
*   23 Jul 2009     GrygoriyS   ---------       Initial
*
*   Copyright (c) 2009, Aricent Inc. All Rights Reserved
*
******************************************************************************/

/****************************************************************************
 * Includes
 ****************************************************************************/

#include "rrc_common_utils.h"
#include "rrc_rrm_intf.h"
#include "rrc_rrm_il_composer.h"
#include "rrc_rrm_il_parser.h"
#include "rrc_msg_mgmt.h"
#include "rrc_phy_intf.h"
#include "uecc_rmfsm.h"
#include "uecc_rrm.h"
#include "uecc_llim.h"
#include "uecc_logger.h"
#include "uecc_fsm_engine.h"
#include "uecc_fsm_common.h"
#include "uecc_llim_utils.h"
#include "uecc_ct_a.h"
#include "s1ap_asn_enc_dec_3gpp.h"
#include "rrc_asn_enc_dec.h"
#include "rrc_s1ap_asn_intrl_dec_3gpp.h"
#include "uecc_x2ap.h"
#include "uecc_s1ap.h"
#include "asn_dec_wrappers.h"
#include "uecc_utils.h"
#include "rrc_logging.h"

#ifdef ENDC_ENABLED
#include "rrc_cp_common.h"
#endif

#include <lteMisc.h>


/*CR 592*/
#define CSG_RESET_VAL 0xE0

/****************************************************************************
 * Local Functions Prototypes
 ****************************************************************************/

static rrc_return_et uecc_rrm_build_cell_access_related_info
(
    /* destination */
    cell_access_related_info_t                                  *p_cell_ari,
    /* source */
    SystemInformationBlockType1_cellAccessRelatedInfo           *p_asn1_cell_ari,
    uecc_ue_context_t                                           *p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_sib_type1_info(
            uecc_ue_context_t   *p_uecc_ue_context,
            sib_type_1_Info_t   *p_sib_type1_info,  
            SystemInformationBlockType1 *p_asn1_sib1 
);

static rrc_return_et uecc_rrm_build_sib_type2_info(
            uecc_ue_context_t   *p_uecc_ue_context,
            sib_type_2_Info_t   *p_sib_type1_info,  
            SystemInformationBlockType2 *p_asn1_sib1 
);

static void     uecc_rrm_build_mib_info(
    uecc_ue_context_t   *p_uecc_ue_context,
    mib_info_t                      *p_mib_info ,  
   MasterInformationBlock * p_asn_MasterInformationBlock 
);

static rrc_return_et fill_rrm_subframe_config
(
    mbsfn_subframe_config_list_t    *p_rrm_sc,           /* source */
    MBSFN_SubframeConfigList        *p_asn1_sc,     /* destination */
    uecc_ue_context_t               *p_uecc_ue_context
);

static rrc_return_et fill_rrm_access_class_barring_info (
 uecc_gb_context_t               *p_uecc_gb_context, 
 access_class_barring_Info_t     *p_access_class,         /* source */
 AC_BarringConfig                *p_asn1_access_class   /* destination */
);

static  rrc_return_et fill_rrm_radio_resource_config_common
(
    uecc_gb_context_t                    *p_uecc_gb_context,
    radio_resource_config_common_sib_t   *p_rrm_cc ,   
    RadioResourceConfigCommonSIB         *p_asn1_cc 
);

static rrc_return_et uecc_rrm_build_sib1_sched_inf
(
    scheduling_info_list_t       *p_sched_inf,       /* destination*/
    SchedulingInfoList          *p_asn1_sched_inf,  /* source */
    uecc_ue_context_t           *p_uecc_ue_context
);

static rrc_return_et process_and_fill_ue_history_from_s1ap_ho_request(
        uecc_ue_context_t* p_uecc_ue_context,
        ue_history_t                       *p_rrm_ue_history,
        rrc_ue_history_information_t  * p_rrc_ue_history_information
);

static rrc_return_et process_and_fill_ue_history_from_x2ap_ho_request(
        uecc_ue_context_t*              p_uecc_ue_context,
        ue_history_t*                    p_rrm_ue_history,
        x2ap_UE_HistoryInformation*     p_rrc_ue_history_information
);

static void uecc_rrm_build_rrc_rrm_erb_setup_req(
    uecc_ue_context_t* p_uecc_ue_context,
    rrc_rrm_erb_setup_req_t* p_rrc_rrm_erb_setup_req
);


/* ERB RELEASE COMMAND START */
static void uecc_rrm_build_rrc_rrm_erb_release_req(
    uecc_ue_context_t* p_uecc_ue_context,
    rrc_rrm_erb_release_req_t* p_rrc_rrm_erb_release_req
);
/* ERB RELEASE COMMAND END */
static rrc_return_et uecc_rrm_build_proximity_results_ind(
    uecc_ue_context_t*                  p_ue_context,
    rrc_rrm_proximity_ind_t*            p_rrc_rrm_proximity_ind,
    ProximityIndication_r9_IEs*         p_proximityIndication_r9
);
static rrc_return_et uecc_rrm_build_measurment_results_ind(
    uecc_ue_context_t*                  p_ue_context,
    rrc_rrm_measurment_results_ind_t*   p_rrc_rrm_measurment_results_ind,
    MeasResults*                        p_meas_results
);

rrc_return_et uecc_rrm_build_meas_results_cdma2000(
    meas_results_cdma2000_t*    p_meas_results_cdma2000,
    MeasResultsCDMA2000*        p_asn_meas_results_cdma2000,
    uecc_ue_context_t*          p_ue_context,
    uecc_gb_context_t*          p_uecc_gb_context
);

static rrc_return_et uecc_rrm_build_meas_result_cdma2000(
    meas_result_cdma2000_t* p_meas_result_cdma2000,
    MeasResultCDMA2000*     p_asn_meas_result_cdma2000,
    uecc_ue_context_t*      p_ue_context,
    uecc_gb_context_t*      p_uecc_gb_context
);

/* MeasResultServFreq-r10 changes start */
static rrc_return_et process_uecc_rrm_meas_result_servfreqlist(
    uecc_ue_context_t*                  p_ue_context,
    rrc_rrm_measurment_results_ind_t*   p_rrc_rrm_measurment_results_ind,
    MeasResults*                        p_meas_results
);

static void uecc_rrm_build_meas_result_serv_freq(
    uecc_gb_context_t*          p_uecc_gb_context,
    uecc_ue_context_t*          p_ue_context,
    rrc_meas_result_serv_freq_r10_t*    p_meas_result_serv_freq,
    MeasResultServFreq_r10*     p_asn_meas_results_servfreq
);
/* MeasResultServFreq-r10 changes stop */

rrc_return_et uecc_rrm_build_meas_result_eutra(
    uecc_gb_context_t*      p_uecc_gb_context,
    uecc_ue_context_t       *p_ue_context,
    meas_result_eutra_t*    p_meas_result_eutra,
    MeasResultEUTRA*        p_asn_meas_results_eutra
);

static rrc_return_et uecc_rrm_build_meas_result_eutra_plmn_info (
    uecc_gb_context_t*      p_uecc_gb_context,
    uecc_ue_context_t       *p_ue_context,
    meas_result_eutra_t*    p_meas_result_eutra,
    MeasResultEUTRA*        p_asn_meas_results_eutra
);

static rrc_return_et uecc_rrm_build_meas_result_eutra_plmn_list2_info(
    uecc_gb_context_t*      p_uecc_gb_context,
    uecc_ue_context_t       *p_ue_context,
    plmn_identity_t* p_rrc_rrm_meas_eutra_plmn,
    PLMN_Identity*   p_asn_Meas_result_eutra_plmn
);
         

rrc_return_et uecc_rrm_build_meas_result_utra(
     meas_result_utra_t*    p_meas_result_utra,
     MeasResultUTRA*        p_asn_meas_result_utra,
     uecc_ue_context_t*     p_ue_context,
     uecc_gb_context_t*     p_uecc_gb_context
);

static rrc_return_et uecc_rrm_build_meas_result_utra_plmn_info (
    uecc_gb_context_t*     p_uecc_gb_context,
    uecc_ue_context_t*     p_ue_context,
    meas_result_utra_t*    p_meas_result_utra,
    MeasResultUTRA*        p_asn_meas_results_utra
);

static rrc_return_et uecc_rrm_build_meas_result_utra_plmn_list2_info(
    uecc_gb_context_t*     p_uecc_gb_context,
    uecc_ue_context_t*     p_ue_context,
    plmn_identity_t* p_rrc_rrm_meas_utra_plmn,
    PLMN_Identity*   p_asn_Meas_result_utra_plmn
);

static rrc_return_et uecc_rrm_build_ue_eutra_capability(
    uecc_ue_context_t               *p_ue_context,      
    eutra_radio_capability_info_t   *p_eutra_radio_capability_info_t,
    UE_EUTRA_Capability             *p_UE_EUTRA_Capability
);

static rrc_return_et uecc_rrm_build_inter_rat_parameters(
    uecc_ue_context_t   *p_ue_context,  
    inter_rat_Parameters_t  *p_inter_rat_Parameters_t,
    UE_EUTRA_Capability_interRAT_Parameters     *p_asn_UE_EUTRA_Capability_interRAT_Parameters
);

static rrc_return_et uecc_rrm_build_pdcp_parameters(
    uecc_gb_context_t   *p_uecc_gb_context,
    pdcp_parameters_t   *p_pdcp_parameters,
    PDCP_Parameters     *p_asn_PDCP_Parameters
);

static rrc_return_et uecc_rrm_build_supported_band_eutra(
    uecc_gb_context_t       *p_uecc_gb_context,
    supported_band_eutra_t  *p_supported_band_eutra,
    SupportedBandEUTRA      *p_asn_supported_band_eutra
);

static rrc_return_et uecc_rrm_build_info_eutra(
    uecc_gb_context_t   *p_uecc_gb_context,
    band_info_eutra_t   *p_band_info_eutra,
    BandInfoEUTRA       *p_asn_BandInfoEUTRA
);

static rrc_return_et uecc_rrm_build_inter_rat_band_info(
    uecc_gb_context_t       *p_uecc_gb_context,
    inter_rat_band_info_t   *p_inter_rat_band_info,
    InterRAT_BandInfo       *p_asn_InterRAT_BandInfo
);

static rrc_return_et uecc_rrm_build_inter_freq_band_info(
    uecc_gb_context_t       *p_uecc_gb_context,
    inter_freq_band_info_t  *p_inter_freq_band_info,
    InterFreqBandInfo       *p_asn_InterFreqBandInfo
);

static rrc_return_et process_and_fill_as_config_from_s1ap_ho_request(
        uecc_ue_context_t* p_uecc_ue_context,
        as_config_t    *p_rrm_as_config,
        AS_Config * p_s1ap_as_config
);

static rrc_return_et uecc_rrm_build_cells_to_add_mod_list_cdma2000_list(
    uecc_ue_context_t* p_uecc_ue_context,
    cells_to_add_mod_list_cdma2000_list_t*
        p_rrm_cells_to_add_mod_list_cdma2000_list,
    CellsToAddModListCDMA2000*              p_cells_to_add_mod_list_cdma2000
);


static rrc_return_et uecc_rrm_build_black_cells_to_add_mod_list(
    black_cells_to_add_mod_list_t* p_rrm_black_cells_to_add_mod_list_eutra_list,
    BlackCellsToAddModList*        p_black_cells_to_add_mod_list_eutra,
    uecc_ue_context_t*             p_uecc_ue_context);

/*eICIC changes start */

static rrc_return_et uecc_rrm_build_meas_subframe_cell_list_r10(
    meas_subframe_cell_list_r10_t*   p_rrm_meas_subframe_cell_list_r10,
    MeasSubframeCellList_r10*        p_meas_subframe_cell_list_r10,
    uecc_ue_context_t*               p_uecc_ue_context);

/*eICIC changes stop */

static rrc_return_et uecc_rrm_build_meas_object_utra(
    meas_object_utra_t*         p_rrm_meas_object_utra,
    MeasObjectUTRA*             p_meas_object_utra,
    uecc_ue_context_t*          p_uecc_ue_context);

static void uecc_rrm_build_cells_to_add_mod_list_utra_fdd(
    uecc_gb_context_t                 *p_uecc_gb_context,
    cells_to_add_mod_list_utra_fdd_t* p_rrm_cells_to_add_mod_list_utra_fdd,
    MeasObjectUTRA*                   p_meas_object_utra);

static void uecc_rrm_build_cells_to_add_mod_list_utra_tdd(
    uecc_gb_context_t                 *p_uecc_gb_context,
    cells_to_add_mod_list_utra_tdd_t* p_rrm_cells_to_add_mod_list_utra_tdd,
    MeasObjectUTRA*                   p_meas_object_utra);

static rrc_return_et uecc_rrm_build_report_config_to_add_mod(
    report_config_to_add_mod_t* p_rrm_report_config_to_add_mod,
    ReportConfigToAddMod*       p_report_config_to_add_mod,
    uecc_ue_context_t*          p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_report_config_to_add_mod_list(
    report_config_to_add_mod_list_t*    p_rrm_report_config_to_add_mod_list,
    ReportConfigToAddModList*           p_report_config_to_add_mod_list,
    uecc_ue_context_t*                  p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_curr_report_config_to_add_mod_list(
    uecc_report_config_to_add_mod_list_t*    p_rrm_report_config_to_add_mod_list,
    ReportConfigToAddModList*           p_report_config_to_add_mod_list,
    uecc_ue_context_t*                  p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_report_config_eutra(
    report_config_eutra_t*      p_rrm_report_config_eutra,
    ReportConfigEUTRA*          p_report_config_eutra,
    uecc_ue_context_t*          p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_report_config_eutra_ext(
    report_config_to_add_mod_report_config_t*      p_rrm_report_config,
    ReportConfigEUTRA*          p_report_config_eutra,
    uecc_ue_context_t*          p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_report_config_eutra_trigger_type_event_eventid(
    report_config_eutra_trigger_type_event_eventid_t*   p_rrm_event_id,
    ReportConfigEUTRA_triggerType_event_eventId*        p_event_id,
    uecc_ue_context_t*                                  p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_threshold_eutra(
    threshold_eutra_t*  p_rrm_threshold_eutra,
    ThresholdEUTRA*     p_threshold_eutra,
    uecc_ue_context_t*  p_uecc_ue_context
);


static rrc_return_et uecc_rrm_build_threshold_utra(
    threshold_utra_t*   p_rrm_threshold_utra,
    ThresholdUTRA*      p_threshold_utra,
    uecc_ue_context_t*  p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_report_config_interrat_trigger_type_event_eventid(
    report_config_interrat_trigger_type_event_eventid_t*    p_rrm_event_id,
    ReportConfigInterRAT_triggerType_event_eventId*         p_event_id,
    uecc_ue_context_t*                                      p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_meas_id_to_add_mod_list(
    uecc_gb_context_t           *p_uecc_gb_context,
    meas_id_to_add_mod_list_t*  p_rrm_meas_id_to_add_mod_list,
    MeasIdToAddModList*         p_meas_id_to_add_mod_list
);

static rrc_return_et uecc_rrm_build_quantity_config(
    uecc_gb_context_t           *p_uecc_gb_context,
    quantity_config_t*  p_rrm_quantity_config,
    QuantityConfig*     p_quantity_config);

static rrc_return_et uecc_rrm_build_meas_gap_config(
    meas_gap_config_t*  p_rrm_meas_gap_config,
    MeasGapConfig*      p_meas_gap_config,
    uecc_ue_context_t*  p_uecc_ue_context);

static void uecc_rrm_build_pre_registration_info_hrpd(
    uecc_gb_context_t           *p_uecc_gb_context,
    pre_registration_info_hrpd_t*   p_rrm_pre_registration_info_hrpd,
    PreRegistrationInfoHRPD*        p_pre_registration_info_hrpd
);

static rrc_return_et uecc_rrm_build_meas_config_speed_state_pars(
    meas_config_speed_state_pars_t* p_rrm_meas_config_speed_state_pars,
    MeasConfig_speedStatePars*      p_meas_config_speed_state_pars,
    uecc_ue_context_t*              p_uecc_ue_context);

static rrc_return_et   uecc_rrm_build_radio_resource_config_dedicated(
        uecc_ue_context_t* p_uecc_ue_context,
      radio_resource_config_dedicated_t * p_rrm_radio_resource_config_dedicated,
        RadioResourceConfigDedicated * p_s1ap_sourceRadioResourceConfig);

static rrc_return_et   uecc_rrm_build_rrm_srb_to_add_info_list(
        uecc_ue_context_t* p_uecc_ue_context,
         rrm_srb_info_t            *  p_rrm_srb_to_add_info,
        SRB_ToAddModList * p_SRB_ToAddModList);

static rrc_return_et uecc_rrm_build_rrm_srb_to_add_mod(
    rrm_srb_config_t   *p_rrm_srb_config,
    SRB_ToAddMod       *p_asn1_srb_elem,
    uecc_ue_context_t*  p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_drb_to_add_mod_list(
        uecc_ue_context_t* p_uecc_ue_context,
        rrm_drb_to_add_info_list_t * p_rrm_drb_to_add_info_list,
        DRB_ToAddModList * p_DRB_ToAddModList
);

static rrc_return_et uecc_rrm_build_drb_to_add_mod(
    rrm_drb_config_t *p_rrm_drb_config,
    DRB_ToAddMod            *p_asn1_drb_elem,
    uecc_ue_context_t* p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_mac_main_config(
        uecc_ue_context_t                  *p_uecc_ue_context,
    rrc_mac_main_config_t *        p_mac_main_config,
        RadioResourceConfigDedicated_mac_MainConfig     *p_asn1_mac
);

static rrc_return_et uecc_rrm_build_cells_to_add_mod_list(
    cells_to_add_mod_list_t*   p_rrm_cells_to_add_mod_list_eutra_list,
    CellsToAddModList*         p_cells_to_add_mod_list_eutra,
    uecc_ue_context_t*         p_uecc_ue_context);

static rrc_return_et uecc_rrm_build_report_config_to_remove_list(
    report_config_to_remove_list_t* p_rrm_report_config_to_remove_list,
    ReportConfigToRemoveList*       p_report_config_to_remove_list,
    uecc_ue_context_t*              p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_report_config_interrat(
    report_config_interrat_t*   p_rrm_report_config_interrat,
    ReportConfigInterRAT*       p_report_config_interrat,
    uecc_ue_context_t*          p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_rrm_b1_threshold(
    report_config_interrat_trigger_type_event_eventid_event_b1_t*
        p_rrm_b1_threshold,
    ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold*
        p_b1_threshold,
    uecc_ue_context_t*                                      p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_meas_id_to_remove_list(
    meas_id_to_remove_list_t*   p_rrm_meas_id_to_remove_list,
    MeasIdToRemoveList*         p_meas_id_to_remove_list,
    uecc_ue_context_t*          p_uecc_ue_context
);

static rrc_return_et
 uecc_rrm_build_report_config_interrat_trigger_type_event_eventid_event_b2(
    report_config_interrat_trigger_type_event_eventid_event_b2_t*
        p_rrm_b2_threshold,
    ReportConfigInterRAT_triggerType_event_eventId_eventB2*         p_event_b2,
    uecc_ue_context_t*                                      p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_asn1_sps_config(
    uecc_ue_context_t   *p_uecc_ue_context,
    rrc_sps_config_t *p_rrm_sps_config,
    SPS_Config          *p_asn1_sps
);

static rrc_return_et uecc_rrm_build_rrm_physical_config_dedicated(
    uecc_ue_context_t                       *p_uecc_ue_context,
    rrc_phy_physical_config_dedicated_t *p_rrm_physical_config_dedicated,
    PhysicalConfigDedicated                 *p_asn1_phy
);

static void uecc_rrm_build_security_algorithm_config(
        uecc_ue_context_t* p_uecc_ue_context,
        security_algorithm_config_t        *p_rrm_security_algorithm_config
);

static rrc_return_et process_and_fill_as_context_from_s1ap_ho_request(
        uecc_ue_context_t* p_uecc_ue_context,
        as_context_t    *p_rrm_as_context,
        AS_Context * p_s1ap_as_context);

static rrc_return_et uecc_rrm_build_meas_object_eutra(
    meas_object_eutra_t*     p_rrm_meas_object_eutra,
    MeasObjectEUTRA*         p_meas_object_eutra,
    uecc_ue_context_t*       p_uecc_ue_context);

static rrc_return_et uecc_rrm_build_meas_object_cdma2000(
    uecc_ue_context_t*              p_uecc_ue_context,
    meas_object_cdma2000_t*     p_rrm_meas_object_cdma2000,
    MeasObjectCDMA2000*         p_meas_object_cdma2000
);

static rrc_return_et uecc_rrm_build_meas_object_to_add_mod(
    meas_object_to_add_mod_t*   p_rrm_meas_object_to_add_mod,
    MeasObjectToAddMod*         p_meas_object_to_add_mod,
    uecc_ue_context_t*              p_uecc_ue_context);

static rrc_return_et uecc_rrm_build_curr_meas_object_to_add_mod(
    uecc_meas_object_to_add_mod_t*   p_rrm_meas_object_to_add_mod,
    MeasObjectToAddMod*         p_meas_object_to_add_mod,
    uecc_ue_context_t*              p_uecc_ue_context);

static rrc_return_et uecc_rrm_build_meas_object_to_add_mod_list(
    meas_object_to_add_mod_list_t*  p_rrm_meas_object_to_add_mod_list,
    MeasObjectToAddModList*         p_meas_object_to_add_mod_list,
    uecc_ue_context_t*              p_uecc_ue_context
);
static rrc_return_et uecc_rrm_build_curr_meas_object_to_add_mod_list(
    uecc_meas_object_to_add_mod_list_t*  p_ue_meas_object_to_add_mod_list,
    MeasObjectToAddModList*         p_meas_object_to_add_mod_list,
    uecc_ue_context_t*              p_uecc_ue_context
);

static rrc_return_et uecc_rrm_build_meas_object_to_remove_list(
    meas_object_to_remove_list_t*   p_rrm_meas_object_to_remove_list,
    MeasObjectToRemoveList*         p_meas_object_to_remove_list,
    uecc_ue_context_t*              p_uecc_ue_context
);

static void uecc_rrm_build_rrc_rrm_erb_modify_req(
    uecc_ue_context_t* p_uecc_ue_context,
    rrc_rrm_erab_modify_req_t* p_rrc_rrm_erb_modify_req
);


rrc_return_et uecc_rrm_build_meas_result_geran(
     uecc_ue_context_t       *p_ue_context,
     meas_result_geran_t*    p_meas_result_geran,
     MeasResultGERAN*        p_asn_meas_result_geran
);

rrc_return_et uecc_rrm_build_meas_result_nr(
     uecc_ue_context_t       *p_ue_context,
     meas_result_ind_nr_t*    p_meas_result_nr,
     MeasResultCellNR_r15*    p_asn_meas_result_nr
);


static rrc_return_et uecc_rrm_build_curr_report_config_to_add_mod(
    uecc_report_config_to_add_mod_t* p_ue_report_config_to_add_mod,
    ReportConfigToAddMod*       p_report_config_to_add_mod,
    uecc_ue_context_t*          p_uecc_ue_context
);

void uecc_rrm_counter_check_stop_timer(
        uecc_ue_context_t   *p_ue_context
);
void copy_cell_id(
        rrm_cell_global_id_eutra_t *p_dest,
        CellGlobalIdEUTRA *p_src);
void uecc_rrm_build_band_combination_parameters_r10(
        uecc_ue_context_t                   *p_ue_context,      
        band_combination_parameters_r10_t   *p_band_combination_params,
        void                                *p_api);
static rrc_return_et uecc_rrm_check_band_in_rf_parameters(
    uecc_gb_context_t           *p_uecc_gb_context, 
    RF_Parameters               *p_rf_parameters,
    RF_Parameters_v1020         *p_rf_rel10_parameters);

rrc_return_et uecc_rrm_build_ue_eutra_capability_v9a0(
        uecc_ue_context_t               *p_ue_context,      /* Added UE context */        
        ue_eutra_capability_v9a0_ies_t *p_ue_eutra_capability,
        UE_EUTRA_Capability_v9a0_IEs   *p_UE_EUTRA_Capability_v9a0
);

static void uecc_rrm_update_mac_scell_config_extension(
        rrc_scell_mac_main_config_extensions_t *p_rrm_scell_mac_main_config_extension,
        rrc_scell_mac_main_config_extensions_t *p_ue_ctx_scell_mac_main_config_extension,
        uecc_ue_context_t                      *p_uecc_ue_context
);

static void uecc_rrm_update_common_scell_non_ul_config (
        rrc_radio_res_common_scell_non_ul_config_t *p_rrm_common_scell_non_ul_config,
        rrc_radio_res_common_scell_non_ul_config_t *p_ue_ctx_common_scell_non_ul_config,
        uecc_ue_context_t                          *p_uecc_ue_context
);

/* SPR 15905 Fix Start */
/* SPR 13261 Fix Start */
static rrc_return_et uecc_rrm_build_curr_meas_id_to_add_mod_list(
    uecc_gb_context_t           *p_uecc_gb_context,
    curr_meas_id_to_add_mod_list_t*  p_rrm_meas_id_to_add_mod_list,
    MeasIdToAddModList*         p_meas_id_to_add_mod_list
);
/* SPR 13261 Fix Stop */
/* SPR 15905 Fix Stop */

/* spr_13304_fix_2_start */
rrc_return_et uecc_rrm_build_meas_object_geran(
    meas_object_geran_t *        p_rrm_meas_object_geran,
    MeasObjectGERAN     *        p_meas_object_geran,
    uecc_ue_context_t   *        p_uecc_ue_context);

/* spr_13304_fix_2_stop */

#ifdef ENDC_ENABLED
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_ue_nr_capability
*   INPUT        : uecc_ue_context_t        *p_ue_context
*                  nr_radio_capability_info_t
*                                           *p_nr_radio_capability_info_t
*                  nr_rrc_UE_NR_Capability
*                                           *p_UE_NR_Capability
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds NR RAT capability.
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et
uecc_rrm_build_ue_nr_capability
(
    uecc_ue_context_t                *p_ue_context,
    nr_radio_capability_info_t       *p_nr_radio_capability_info,
    nr_rrc_UE_NR_Capability          *p_UE_NR_Capability
);
       
static void uecc_rrm_build_rrc_rrm_erb_release_req_endc
(
    uecc_ue_context_t* p_uecc_ue_context,
    rrc_rrm_erb_release_req_t* p_rrc_rrm_erb_release_req
);
/*NR_DC Code Change Start*/
static rrc_return_et uecc_rrm_build_ue_eutra_nr_capability(
    uecc_ue_context_t                  *p_ue_context,      
    eutra_nr_radio_capability_info_t   *p_eutra_nr_radio_capability_info_t,
    nr_rrc_UE_MRDC_Capability          *p_UE_MRDC_Capability
);

/*********************************************************************************
*   FUNCTION NAME: rrcUeEutraCapabilityV1510IesEndc
*   INPUT        : UE_EUTRA_Capability_v1510_IEs      *pUeEutraCapabilityV1510
*                  uecc_ue_context_t*                 *pUeContext
*                  ue_eutra_capability_v1510_ies_t    *pRrmUeEutraCapabilityV1510
*   OUTPUT       : ue_eutra_capability_v1510_ies_t    *pRrmUeEutraCapabilityV1510
*   DESCRIPTION  : This function builds Ue Eutra capability V1510 for RRM
*   RETURNS      : RRC_SUCCESS/RRC_FAILURE
**********************************************************************************/
static
rrc_return_et
rrcUeEutraCapabilityV1510IesEndc
(
    UE_EUTRA_Capability_v1510_IEs      *pUeEutraCapabilityV1510,
    uecc_ue_context_t                  *pUeContext,
    ue_eutra_capability_v1510_ies_t    *pRrmUeEutraCapabilityV1510
);
/*NR_DC Code Change Stop*/
#endif


/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_ue_reconfig_request
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
*   DESCRIPTION  : This function processes RRC_RRM_UE_RECONFIG_REQ
******************************************************************************/
void uecc_rrm_process_ue_reconfig_request
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_rrm_ue_reconfig_req_t       rrc_rrm_ue_reconfig_req;
    S32                             length_read = RRC_NULL;

    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_api);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    do
    {
        /* Decode message */
        result = rrc_il_parse_rrc_rrm_ue_reconfig_req(
                    &rrc_rrm_ue_reconfig_req,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", rrc_rrm_ue_reconfig_req.ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            rrc_rrm_ue_reconfig_req.ue_index);

        if ( PNULL != p_ue_context )
        {
            if ( RRC_SUCCESS != result )
            {
                /* Message parsing error */
                /* - Drop message */
                break;
            }
            /* SPR 21991 Fix Start */
            /* Storing received transaction id in UE Context*/
            p_ue_context->rrm_curr_trans_id = rrc_get_transaction_id(p_api);
            /* SPR 21991 Fix End */
            /* Removed the Transaction_id for RRM initiated Msg between RRM-RRC */

            /* Call UECC_EV_RRM_UE_RECONFIG_REQ event handler *
             * and pass API data to FSM. */
            /* WARNING. The uecc_event_queue_push_event can't be used here because
             * the stack variable is used for storing the API data
             * */
            uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_UE_RECONFIG_REQ,
                &rrc_rrm_ue_reconfig_req);
        }
    }
    while(0);

   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: fill_phyConfigDed_info_sched_cqi_antennaV920 
*
*   DESCRIPTION:
*       This function fill up scheduling info, CQI and antenna version 920
*       information in physical config dedicated info field
*   RETURNS:
        RRC_FAILURE/RRC_SUCCESS
*
******************************************************************************/
static rrc_return_et fill_phyConfigDed_info_sched_cqi_antennaV920(
        uecc_ue_context_t                   *p_uecc_ue_context,
	PhysicalConfigDedicated             *p_asn1_phy,
        rrc_phy_physical_config_dedicated_t *p_rrm_physical_config_dedicated
)
{
    RRC_ASSERT(PNULL != p_rrm_physical_config_dedicated);
    RRC_ASSERT(PNULL != p_asn1_phy);
    /* Scheduling Request Configuration */
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    if (p_asn1_phy->m.schedulingRequestConfigPresent)
    {
        p_rrm_physical_config_dedicated->bitmask |= 
            RRC_PHY_SCHEDULING_REQUEST_CONFIG_PRESENT;

        if (p_asn1_phy->schedulingRequestConfig.t ==
                T_SchedulingRequestConfig_setup)
        {
            p_rrm_physical_config_dedicated->scheduling_request_config.
                bitmask |=
                RRC_PHY_SCHEDULING_REQUEST_CONFIG_PARAM_PRESENT;

            if (PNULL == p_asn1_phy->schedulingRequestConfig.u.setup)
            {
                return RRC_FAILURE;
            }

            /* sr_PUCCH_ResourceIndex */
            p_rrm_physical_config_dedicated->scheduling_request_config.  
                scheduling_request_config_param.sr_pucch_resource_index=
                p_asn1_phy->schedulingRequestConfig.u.setup-> 
                sr_PUCCH_ResourceIndex ;

            /* cr_311 sr_ConfigIndex range check */
            if (p_uecc_ue_context->m.access_stratum_release)
            {    
                if (((p_asn1_phy->schedulingRequestConfig.u.setup->sr_ConfigIndex == 156) ||
                            (p_asn1_phy->schedulingRequestConfig.u.setup->sr_ConfigIndex == 157)) &&
                        (!(p_uecc_ue_context->access_stratum_release >= rrm_rel9)))
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->
                            context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,"Release 8 do not support"
                            " values 156 or 157 for sr_ConfigIndex");
                    return RRC_FAILURE;
                } 
                else
                {
                    p_rrm_physical_config_dedicated->scheduling_request_config.  
                        scheduling_request_config_param.sr_configuration_index=
                        p_asn1_phy->schedulingRequestConfig.u.setup->
                        sr_ConfigIndex ;
                }
            }    

            /* dsr_TransMax */
            p_rrm_physical_config_dedicated->scheduling_request_config.  
                scheduling_request_config_param.dsr_trans_max=
                (U8)p_asn1_phy->schedulingRequestConfig.u.setup->dsr_TransMax ;
        }
    }
    /* cr_316 And 247 CQI Reporting */
    if (p_asn1_phy->m.cqi_ReportConfig_v920Present)
    {
        p_rrm_physical_config_dedicated->bitmask 
            |= RRC_PHY_CQI_REPORT_CONFIG_V920_PRESENT;

        if (p_asn1_phy->cqi_ReportConfig_v920.m.cqi_Mask_r9Present)
        {
            p_rrm_physical_config_dedicated->cqi_report_config_v920.bitmask |= 
                RRC_PHY_CQI_MASK_R9_PRESENT;

            /* cqi_mask_r9 */
            p_rrm_physical_config_dedicated->cqi_report_config_v920.cqi_mask_r9 =
                (U8)p_asn1_phy->cqi_ReportConfig_v920.cqi_Mask_r9;
        }
        if (p_asn1_phy->cqi_ReportConfig_v920.m.pmi_RI_Report_r9Present)
        {
            p_rrm_physical_config_dedicated->cqi_report_config_v920.bitmask |= 
                RRC_PHY_PMI_RI_REPORT_R9_PRESENT;

            /* pmi_ri_report_r9 */
            p_rrm_physical_config_dedicated->cqi_report_config_v920.pmi_ri_report_r9 =
                (U8)p_asn1_phy->cqi_ReportConfig_v920.pmi_RI_Report_r9;
        }
    }

    /* antenna_info_v920 */
    if (p_asn1_phy->m.antennaInfo_v920Present)
    {
        p_rrm_physical_config_dedicated->bitmask |= 
            RRC_PHY_ANTENNA_INFO_V920_PRESENT;

        /* codebook_subset_restriction_v920 */
        if (p_asn1_phy->antennaInfo_v920.m.codebookSubsetRestriction_v920Present)
        {
            p_rrm_physical_config_dedicated->antenna_info_v920.bitmask |=
                RRC_PHY_CODEBOOK_SUBSET_RESTRICTION_V920_PRESENT;

            switch(p_asn1_phy->antennaInfo_v920.codebookSubsetRestriction_v920.t)
            {
                case T_AntennaInfoDedicated_v920_codebookSubsetRestriction_v920_n2TxAntenna_tm8_r9:
                    p_rrm_physical_config_dedicated->antenna_info_v920.
                        codebook_subset_restriction_v920.type = N2_TX_ANTENNA_TM8_R9;

                    if (PNULL == p_asn1_phy->antennaInfo_v920.
                            codebookSubsetRestriction_v920.u.n2TxAntenna_tm8_r9)
                    {
                        break;
                    }
                    p_asn1_phy->antennaInfo_v920.codebookSubsetRestriction_v920.
                        u.n2TxAntenna_tm8_r9->numbits = 6;    
                    l3_memcpy_wrapper(
                            p_rrm_physical_config_dedicated->antenna_info_v920.
                            codebook_subset_restriction_v920.value,
                            p_asn1_phy->antennaInfo_v920.codebookSubsetRestriction_v920.
                            u.n2TxAntenna_tm8_r9->data,
                            sizeof(p_asn1_phy->antennaInfo_v920.codebookSubsetRestriction_v920.
                                u.n2TxAntenna_tm8_r9->data));
                    break;

                case T_AntennaInfoDedicated_v920_codebookSubsetRestriction_v920_n4TxAntenna_tm8_r9:
                    p_rrm_physical_config_dedicated->antenna_info_v920.
                        codebook_subset_restriction_v920.type = N4_TX_ANTENNA_TM8_R9;

                    if (PNULL == p_asn1_phy->antennaInfo_v920.
                            codebookSubsetRestriction_v920.u.n4TxAntenna_tm8_r9)
                    {
                        break;
                    }
                    p_asn1_phy->antennaInfo_v920.codebookSubsetRestriction_v920.
                        u.n4TxAntenna_tm8_r9->numbits = 32;    
                    l3_memcpy_wrapper(
                            p_rrm_physical_config_dedicated->antenna_info_v920.
                            codebook_subset_restriction_v920.value,
                            p_asn1_phy->antennaInfo_v920.codebookSubsetRestriction_v920.
                            u.n4TxAntenna_tm8_r9->data,
                            sizeof(p_asn1_phy->antennaInfo_v920.codebookSubsetRestriction_v920.
                                u.n4TxAntenna_tm8_r9->data));
                    break;

                default:
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,
                            "Invalid codebook_subset_"
                            "restriction_v920.type=%i",
                            p_asn1_phy->antennaInfo_v920.
                            codebookSubsetRestriction_v920.t);
            }
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
*   FUNCTION NAME: fill_phyConfigDed_antenna_explicitValue 
*
*   DESCRIPTION:
*       This function fill up explicit values in physical channel dedicated antenna
*       info field to send to RRM for rab reconfig
*   RETURNS:
        RRC_FAILURE/RRC_SUCCESS
*
******************************************************************************/
static void fill_phyConfigDed_antenna_explicitValue(
    uecc_ue_context_t                       *p_uecc_ue_context,
    rrc_phy_antenna_information_dedicated_t *antenna_information_explicit_value,
    AntennaInfoDedicated                    *phyConfigDed_antennaInfo_explicitValue
)
{
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /* Code book subset restriction */
    if (phyConfigDed_antennaInfo_explicitValue->m.codebookSubsetRestrictionPresent)
    {
        /* explicitValue */
        antenna_information_explicit_value->bitmask |=
            RRC_PHY_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

        switch(phyConfigDed_antennaInfo_explicitValue->codebookSubsetRestriction.t)
        {
            case T_AntennaInfoDedicated_codebookSubsetRestriction_n2TxAntenna_tm3:
                antenna_information_explicit_value->codebook_subset_restriction.type = 
                    N2_TX_ANTENNA_TM3;

                if (PNULL == phyConfigDed_antennaInfo_explicitValue->
                        codebookSubsetRestriction.u.n2TxAntenna_tm3)
                {
                    break;
                }
                l3_memcpy_wrapper(
                        antenna_information_explicit_value->codebook_subset_restriction.value,
                        phyConfigDed_antennaInfo_explicitValue->codebookSubsetRestriction.
                            u.n2TxAntenna_tm3->data,
                        sizeof(phyConfigDed_antennaInfo_explicitValue->
                            codebookSubsetRestriction.u.n2TxAntenna_tm3->data));
                break;
            case T_AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm3:
                    antenna_information_explicit_value->codebook_subset_restriction.type = 
                        N4_TX_ANTENNA_TM3;

                if (PNULL == phyConfigDed_antennaInfo_explicitValue->
                        codebookSubsetRestriction.u.n4TxAntenna_tm3)
                {
                    break;
                }
                phyConfigDed_antennaInfo_explicitValue->codebookSubsetRestriction.
                    u.n4TxAntenna_tm3->numbits = 4;
                l3_memcpy_wrapper(phyConfigDed_antennaInfo_explicitValue->
                        codebookSubsetRestriction.u.n4TxAntenna_tm3->data,
                        antenna_information_explicit_value->codebook_subset_restriction.value,
                        sizeof(phyConfigDed_antennaInfo_explicitValue->
                            codebookSubsetRestriction.u.n4TxAntenna_tm3->data));
                break;
            case T_AntennaInfoDedicated_codebookSubsetRestriction_n2TxAntenna_tm4:
                    antenna_information_explicit_value->codebook_subset_restriction.type = 
                        N2_TX_ANTENNA_TM4;

                if (PNULL == phyConfigDed_antennaInfo_explicitValue->
                        codebookSubsetRestriction.u.n2TxAntenna_tm4)
                {
                    break;
                }

                l3_memcpy_wrapper(
                        antenna_information_explicit_value->codebook_subset_restriction.value,
                        phyConfigDed_antennaInfo_explicitValue->codebookSubsetRestriction.
                            u.n2TxAntenna_tm4->data,
                        sizeof(phyConfigDed_antennaInfo_explicitValue->
                            codebookSubsetRestriction.u.n2TxAntenna_tm4->data));
                break;
            case T_AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4:
                    antenna_information_explicit_value->codebook_subset_restriction.type = 
                        N4_TX_ANTENNA_TM4;

                if (PNULL == 
                        phyConfigDed_antennaInfo_explicitValue->
                        codebookSubsetRestriction.u.n4TxAntenna_tm4)
                {
                    break;
                }

                l3_memcpy_wrapper(
                        antenna_information_explicit_value->codebook_subset_restriction.value,
                        phyConfigDed_antennaInfo_explicitValue->codebookSubsetRestriction.
                        u.n4TxAntenna_tm4->data,
                        sizeof(phyConfigDed_antennaInfo_explicitValue->
                            codebookSubsetRestriction.u.n4TxAntenna_tm4->data));
                break;
            case T_AntennaInfoDedicated_codebookSubsetRestriction_n2TxAntenna_tm5:
                        antenna_information_explicit_value->codebook_subset_restriction.type = 
                            N2_TX_ANTENNA_TM5;
                if (PNULL == phyConfigDed_antennaInfo_explicitValue->
                        codebookSubsetRestriction.u.n2TxAntenna_tm5)
                {
                    break;
                }
                l3_memcpy_wrapper(
                        antenna_information_explicit_value->codebook_subset_restriction.value,
                        phyConfigDed_antennaInfo_explicitValue->codebookSubsetRestriction.
                        u.n2TxAntenna_tm5->data,
                        sizeof(phyConfigDed_antennaInfo_explicitValue->
                            codebookSubsetRestriction.u.n2TxAntenna_tm5->data));
                break;
            case T_AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm5:
                        antenna_information_explicit_value->codebook_subset_restriction.type = 
                            N4_TX_ANTENNA_TM5;

                if (PNULL == phyConfigDed_antennaInfo_explicitValue->
                        codebookSubsetRestriction.u.n4TxAntenna_tm5)
                {
                    break;
                }
                l3_memcpy_wrapper(
                        antenna_information_explicit_value->codebook_subset_restriction.value,
                        phyConfigDed_antennaInfo_explicitValue-> 
                        codebookSubsetRestriction.u.n4TxAntenna_tm5->data,
                        sizeof(phyConfigDed_antennaInfo_explicitValue->
                            codebookSubsetRestriction.u.n4TxAntenna_tm5->data));
                break;
            case T_AntennaInfoDedicated_codebookSubsetRestriction_n2TxAntenna_tm6:
                    antenna_information_explicit_value->codebook_subset_restriction.type =
                        N2_TX_ANTENNA_TM6;
                if (PNULL == phyConfigDed_antennaInfo_explicitValue->
                        codebookSubsetRestriction.u.n2TxAntenna_tm6)
                {
                    break;
                }
                l3_memcpy_wrapper(
                        antenna_information_explicit_value->codebook_subset_restriction.value,
                        phyConfigDed_antennaInfo_explicitValue-> 
                        codebookSubsetRestriction.u.n2TxAntenna_tm6->data,
                        sizeof(phyConfigDed_antennaInfo_explicitValue->
                            codebookSubsetRestriction.u.n2TxAntenna_tm6->data));
                break;
            case T_AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm6:
                    antenna_information_explicit_value->codebook_subset_restriction.type = 
                        N4_TX_ANTENNA_TM6;
                if (PNULL == phyConfigDed_antennaInfo_explicitValue->
                        codebookSubsetRestriction.u.n4TxAntenna_tm6)
                {
                    break;
                }
                phyConfigDed_antennaInfo_explicitValue->codebookSubsetRestriction.
                    u.n4TxAntenna_tm6->numbits = 16;
                l3_memcpy_wrapper(
                        antenna_information_explicit_value->codebook_subset_restriction.value,
                        phyConfigDed_antennaInfo_explicitValue-> 
                        codebookSubsetRestriction.u.n4TxAntenna_tm6->data,
                        sizeof(phyConfigDed_antennaInfo_explicitValue->
                            codebookSubsetRestriction.u.n4TxAntenna_tm6->data));
                break;
            default:
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "Invalid codebook_subset_restriction.type=%i",
                        phyConfigDed_antennaInfo_explicitValue->codebookSubsetRestriction.t);
                /* we can use ASN1OpenType *extElem1 */
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: fill_rrm_physical_config_parameter 
*
*   DESCRIPTION:
*       This function fill up physical channel config parameter to send them
*       to RRM
*   RETURNS:
        RRC_FAILURE/RRC_SUCCESS
*
******************************************************************************/
static rrc_return_et fill_rrm_physical_config_parameter(
    uecc_ue_context_t                   *p_uecc_ue_context,
    PhysicalConfigDedicated             *p_asn1_phy,
    rrc_phy_physical_config_dedicated_t *p_rrm_physical_config_dedicated
)

{
    RRC_ASSERT(PNULL != p_rrm_physical_config_dedicated);
    RRC_ASSERT(PNULL != p_asn1_phy);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /* PDSCH Configuration */
    if (p_asn1_phy->m.pdsch_ConfigDedicatedPresent)
    {
        p_rrm_physical_config_dedicated->bitmask |=
            RRC_PHY_PDSCH_CONFIGURATION_DEDICATED_PRESENT;

        /* P-a */
        p_rrm_physical_config_dedicated->pdsch_configuration_dedicated.p_a=
            (U8)p_asn1_phy->pdsch_ConfigDedicated.p_a ;
    }
    /* PUCCH Configuration */
    if (p_asn1_phy->m.pucch_ConfigDedicatedPresent)
    {
        p_rrm_physical_config_dedicated->bitmask |=
            RRC_PHY_PUCCH_CONFIGURATION_DEDICATED_PRESENT;

        /* ackNackRepetition */
        if (p_asn1_phy->pucch_ConfigDedicated.ackNackRepetition.t ==
                T_PUCCH_ConfigDedicated_ackNackRepetition_setup)
        {
            p_rrm_physical_config_dedicated->
                pucch_configuration_dedicated.bitmask |=
                RRC_PHY_ACK_NACK_REPETITION_PARAM_PRESENT;

            if (PNULL ==
                    p_asn1_phy->pucch_ConfigDedicated.
                    ackNackRepetition.u.setup)
            {
                return RRC_FAILURE;
            }

            /* repetitionFactor */
            p_rrm_physical_config_dedicated->
                pucch_configuration_dedicated.ack_nack_repetition_param.
                    factor =
                (U8)p_asn1_phy->pucch_ConfigDedicated.ackNackRepetition.
                    u.setup-> repetitionFactor ;

            /* n1PUCCH_AN_Rep */
            p_rrm_physical_config_dedicated->pucch_configuration_dedicated.  
                ack_nack_repetition_param.an_rep =  p_asn1_phy->pucch_ConfigDedicated.
                    ackNackRepetition.u.setup-> n1PUCCH_AN_Rep ;
        }

        /* tdd_AckNackFeedbackMode */
        if (p_asn1_phy->pucch_ConfigDedicated.m.tdd_AckNackFeedbackModePresent)
        {
            p_rrm_physical_config_dedicated->pucch_configuration_dedicated.bitmask |=
                RRC_PHY_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT;

            /* tddAckNackFeedbackMode */
            p_rrm_physical_config_dedicated->pucch_configuration_dedicated.
                tdd_ack_nack_feedback_mode =
                (U8)p_asn1_phy->pucch_ConfigDedicated.tdd_AckNackFeedbackMode ;
        }
    }

    /* PUSCH Configuration */
    if (p_asn1_phy->m.pusch_ConfigDedicatedPresent)
    {
        p_rrm_physical_config_dedicated->bitmask |= RRC_PHY_PUSCH_CONFIGURATION_DEDICATED_PRESENT;

        /* Delta Offset ACK index */
        p_rrm_physical_config_dedicated->pusch_configuration_dedicated.beta_offset_ack_index =
            p_asn1_phy->pusch_ConfigDedicated.betaOffset_ACK_Index ;

        /* Delta Offset RI index */
        p_rrm_physical_config_dedicated->pusch_configuration_dedicated.beta_offset_ri_index =
            p_asn1_phy->pusch_ConfigDedicated.betaOffset_RI_Index ;

        /* Delta Offset CQI index */
        p_rrm_physical_config_dedicated->pusch_configuration_dedicated.beta_offset_cqi_index=
            p_asn1_phy->pusch_ConfigDedicated.betaOffset_CQI_Index ;
    }

    /* Uplink Power Control */
    if (p_asn1_phy->m.uplinkPowerControlDedicatedPresent)
    {
        p_rrm_physical_config_dedicated->bitmask |= RRC_PHY_UPLINK_POWER_CONTROL_DEDICATED_PRESENT;

        /* p0_UePUSCH */
        p_rrm_physical_config_dedicated->uplink_power_control_dedicated.p0_ue_pusch=
            p_asn1_phy->uplinkPowerControlDedicated.p0_UE_PUSCH ;

        /* deltaMCS_Enabled */
        p_rrm_physical_config_dedicated->uplink_power_control_dedicated.delta_mcs_enabled=
            (U8)p_asn1_phy->uplinkPowerControlDedicated.deltaMCS_Enabled ;

        /* accumulationEnabled */
        p_rrm_physical_config_dedicated->uplink_power_control_dedicated.accumulation_enabled=
            p_asn1_phy->uplinkPowerControlDedicated.accumulationEnabled ;

        /* p0_uePUCCH */
        p_rrm_physical_config_dedicated->uplink_power_control_dedicated.p0_ue_pucch=
            p_asn1_phy->uplinkPowerControlDedicated.p0_UE_PUCCH ;

        /* pSRS_Offset */
        p_rrm_physical_config_dedicated->uplink_power_control_dedicated.p_srs_offset=
            p_asn1_phy->uplinkPowerControlDedicated.pSRS_Offset ;

        /* filterCoefficient */
        p_rrm_physical_config_dedicated->uplink_power_control_dedicated.filter_coefficient=
            (U8)p_asn1_phy->uplinkPowerControlDedicated.filterCoefficient ;
    }

    /* TPC PDCCH Configuration PUCCH*/
    if (p_asn1_phy->m.tpc_PDCCH_ConfigPUCCHPresent)
    {
        p_rrm_physical_config_dedicated->bitmask |= RRC_PHY_TPC_PDCCH_CONFIG_PUCCH_PRESENT;

        if (p_asn1_phy->tpc_PDCCH_ConfigPUCCH.t == T_TPC_PDCCH_Config_setup)
        {
            p_rrm_physical_config_dedicated->tpc_pdcch_config_pucch.bitmask |=
                RRC_PHY_TPC_PDCCH_CONFIG_PARAM_PRESENT;
            /* TPC PDCCH Configuration PUCCH setup */

            if (PNULL == p_asn1_phy->tpc_PDCCH_ConfigPUCCH.u.setup)
            {
                return RRC_FAILURE;
            }

            /* tpc_RNTI */
            RRC_ASSERT((p_asn1_phy->tpc_PDCCH_ConfigPUCCH.u.setup->
                        tpc_RNTI.numbits) <=
                    (8*sizeof(p_rrm_physical_config_dedicated->
                              tpc_pdcch_config_pucch.
                              tpc_pdcch_config_param.tpc_rnti)));
            l3_memcpy_wrapper(
                    p_rrm_physical_config_dedicated->
                    tpc_pdcch_config_pucch.tpc_pdcch_config_param.tpc_rnti,
                    p_asn1_phy->tpc_PDCCH_ConfigPUCCH.u.setup->
                    tpc_RNTI.data,
                    sizeof(p_rrm_physical_config_dedicated->
                        tpc_pdcch_config_pucch.
                        tpc_pdcch_config_param.tpc_rnti));

            /* TPC Index */
            if (p_asn1_phy->tpc_PDCCH_ConfigPUCCH.u.setup->
                    tpc_Index.t ==
                    T_TPC_Index_indexOfFormat3)
            {
                p_rrm_physical_config_dedicated->tpc_pdcch_config_pucch.
                    tpc_pdcch_config_param.tpc_index.bitmask |= TPC_INDEX_FORMAT_3_PRESENT;

                /* indexOfFormat3 */
                p_rrm_physical_config_dedicated->tpc_pdcch_config_pucch.
                    tpc_pdcch_config_param.tpc_index.index_of_format3 =
                    p_asn1_phy->tpc_PDCCH_ConfigPUCCH.u.setup->tpc_Index.u.indexOfFormat3 ;
            }
            else if (p_asn1_phy->tpc_PDCCH_ConfigPUCCH.u.setup->tpc_Index.t ==
                    T_TPC_Index_indexOfFormat3A)
            {
                p_rrm_physical_config_dedicated->tpc_pdcch_config_pucch.tpc_pdcch_config_param.
                    tpc_index.bitmask |= TPC_INDEX_FORMAT_3A_PRESENT;

                /* indexOfFormat3A */
                p_rrm_physical_config_dedicated->tpc_pdcch_config_pucch.tpc_pdcch_config_param.  
                    tpc_index.index_of_format3a = 
                    p_asn1_phy->tpc_PDCCH_ConfigPUCCH.u.setup->tpc_Index.u.indexOfFormat3A ;
            }
            else
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "Invalid tpc_pdcch_config_param."
                        "tpc_index.bitmask 0x%x",
                        p_asn1_phy->tpc_PDCCH_ConfigPUCCH.u.setup->tpc_Index.t );
            }
        }
    }

    /* TPC PDCCH Configuration PUSCH*/
    if (p_asn1_phy->m.tpc_PDCCH_ConfigPUSCHPresent)
    {
        p_rrm_physical_config_dedicated->bitmask |= RRC_PHY_TPC_PDCCH_CONFIG_PUSCH_PRESENT;

        if (p_asn1_phy->tpc_PDCCH_ConfigPUSCH.t == T_TPC_PDCCH_Config_setup)
        {
            p_rrm_physical_config_dedicated->tpc_pdcch_config_pusch.bitmask |=
                RRC_PHY_TPC_PDCCH_CONFIG_PARAM_PRESENT;
            /* TPC PDCCH Configuration PUSCH setup */

            if (PNULL == p_asn1_phy->tpc_PDCCH_ConfigPUSCH.u.setup)
            {
                return RRC_FAILURE;
            }

            /* tpc_RNTI */
            RRC_ASSERT(p_asn1_phy->tpc_PDCCH_ConfigPUSCH.u.
                    setup->tpc_RNTI.numbits <=
                    8*sizeof(p_rrm_physical_config_dedicated->
                        tpc_pdcch_config_pusch.
                        tpc_pdcch_config_param.tpc_rnti));

            l3_memcpy_wrapper(
                    p_rrm_physical_config_dedicated->tpc_pdcch_config_pusch.
                    tpc_pdcch_config_param.tpc_rnti,
                    p_asn1_phy->tpc_PDCCH_ConfigPUSCH.u.setup->
                    tpc_RNTI.data,
                    sizeof(p_rrm_physical_config_dedicated->
                        tpc_pdcch_config_pusch.
                        tpc_pdcch_config_param.tpc_rnti));

            /* TPC Index */
            if (p_asn1_phy->tpc_PDCCH_ConfigPUSCH.u.setup->tpc_Index.t ==
                    T_TPC_Index_indexOfFormat3)
            {
                p_rrm_physical_config_dedicated->tpc_pdcch_config_pusch.tpc_pdcch_config_param.
                    tpc_index.bitmask |= TPC_INDEX_FORMAT_3_PRESENT;

                /* indexOfFormat3 */
                p_rrm_physical_config_dedicated->tpc_pdcch_config_pusch.tpc_pdcch_config_param.  
                    tpc_index.index_of_format3 =
                    p_asn1_phy->tpc_PDCCH_ConfigPUSCH.u.setup->tpc_Index.u.indexOfFormat3 ;
            }
            else if (p_asn1_phy->tpc_PDCCH_ConfigPUSCH.u.setup->tpc_Index.t ==
                    T_TPC_Index_indexOfFormat3A)
            {
                p_rrm_physical_config_dedicated->tpc_pdcch_config_pusch.tpc_pdcch_config_param.
                    tpc_index.bitmask |= TPC_INDEX_FORMAT_3A_PRESENT;

                /* indexOfFormat3A */
                p_rrm_physical_config_dedicated->tpc_pdcch_config_pusch.tpc_pdcch_config_param.
                    tpc_index.index_of_format3a =
                    p_asn1_phy->tpc_PDCCH_ConfigPUSCH.u.setup->tpc_Index.u.indexOfFormat3A ;
            }
            else
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "Invalid tpc_pdcch_config_param."
                        "tpc_index.bitmask=%i",
                        p_asn1_phy->tpc_PDCCH_ConfigPUSCH.u.
                        setup->tpc_Index.t);
            }
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
*   FUNCTION NAME: fill_macConfig_longDrxCycle_startOffset
*
*   DESCRIPTION:
*       This function fill up long drx cyle start offset in mac config field       
*   RETURNS:
        None
*
******************************************************************************/
void fill_macConfig_longDrxCycle_startOffset( 
    uecc_ue_context_t                  *p_uecc_ue_context,
    rrc_long_drx_cycle_start_offset_t           *macMain_longDRX_CycleStartOffset,
    DRX_Config_setup_longDRX_CycleStartOffset   *asnMac_longDRX_CycleStartOffset
)
{
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /* LongDRX_CycleStartOffset */
    switch(asnMac_longDRX_CycleStartOffset->t)
    {
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf10:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_10_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_10=
                asnMac_longDRX_CycleStartOffset->u.sf10 ;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf20:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_20_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_20=
                asnMac_longDRX_CycleStartOffset->u.sf20 ;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf32:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_32_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_32=
                asnMac_longDRX_CycleStartOffset->u.sf32 ;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf40:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_40_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_40=
                asnMac_longDRX_CycleStartOffset->u.sf40 ;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf64:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_64_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_64=
                asnMac_longDRX_CycleStartOffset->u.sf64 ;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf80:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_80_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_80=
                asnMac_longDRX_CycleStartOffset->u.sf80;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf128:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_128_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_128=
                asnMac_longDRX_CycleStartOffset->u.sf128;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf160:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_160_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_160=
                asnMac_longDRX_CycleStartOffset->u.sf160;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf256:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_256_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_256=
                asnMac_longDRX_CycleStartOffset->u.sf256;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf320:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_320_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_320=
                asnMac_longDRX_CycleStartOffset->u.sf320;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf512:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_512_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_512=
                asnMac_longDRX_CycleStartOffset->u.sf512;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf640:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_640_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_640=
                asnMac_longDRX_CycleStartOffset->u.sf640;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf1024:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_1024_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_1024=
                asnMac_longDRX_CycleStartOffset->u.sf1024;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf1280:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_1280_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_1280=
                asnMac_longDRX_CycleStartOffset->u.sf1280 ;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf2048:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_2048_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_2048=
               asnMac_longDRX_CycleStartOffset->u.sf2048 ;
            break;
        case T_DRX_Config_setup_longDRX_CycleStartOffset_sf2560:
            macMain_longDRX_CycleStartOffset->bitmask |=
                RRC_LONG_DRX_CYCLE_START_OFFSET_SF_2560_PRESENT;
            macMain_longDRX_CycleStartOffset->sf_2560=
                asnMac_longDRX_CycleStartOffset->u.sf2560 ;
            break;
        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,   
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "Wrong long_drx_cycle_start_offset.bitmask: %i",
                    macMain_longDRX_CycleStartOffset->bitmask);
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: rrc_rrm_build_s1ap_ho_adm_req 
*
*   DESCRIPTION:
*       This function fill up S1AP handover admission request structure
*       
*   RETURNS:
        returns RRC_FAILURE/RRC_SUCCESS
*
******************************************************************************/
static rrc_return_et  rrc_rrm_build_s1ap_ho_adm_req(
        uecc_ue_context_t                       *p_uecc_ue_context,
        rrc_s1ap_handover_request_t             *p_rrc_s1ap_ho_request,
        HandoverPreparationInformation_r8_IEs   *p_rrc_container,
        src_to_trg_container_t                  *p_eutra_src_to_trg_container,
        rrm_erab_to_be_setup_item_list_t        *erab_to_be_setup_item_list,
        rrc_source_enb_to_target_enb_transparent_container_t 
                                       *p_src_to_trg_trans_container
)
{
    AS_Config * p_s1ap_as_config = PNULL;
    OSRTDListNode* p_node = PNULL;
    U8 e_rab_list_count = 0;
    U32 drb_index = 0;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_s1ap_ho_request);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    if (s1ap_intralte == p_rrc_s1ap_ho_request->handover_type)
    {
        /* RRC_CONTAINER:AS Config and RRC_CONTAINER:AS Context, both IEs must be
         * present , if the HO
         *               type is of  "IntraLTE", TS 36.433, SECTION 10.2.2*/
        if ((0 != p_rrc_container->m.as_ConfigPresent) &&  
                (0 != p_rrc_container->m.as_ContextPresent))
        {

            p_eutra_src_to_trg_container->bitmask |=
                SRC_TO_TRG_CONTAINER_AS_CONFIG_PRESENT;

            p_eutra_src_to_trg_container->bitmask |=
                SRC_TO_TRG_CONTAINER_AS_CONTEXT_PRESENT;

            if ((p_rrc_container->as_Config.m._v3ExtPresent == 1) &&
                    (p_rrc_container->as_Config.m.sourceSCellConfigList_r10Present == 1))
            {
                p_eutra_src_to_trg_container->bitmask |=
                    SRC_TO_TRG_CONTAINER_AS_CONFIG_EXT_PRESENT;

                p_eutra_src_to_trg_container->as_config_ext.bitmask |=
                    SRC_TO_TRG_CONTAINER_AS_CONFIG_SCELL_ADD_MOD_LIST_PRESENT;

                if (RRC_FAILURE == uecc_rrm_build_scell_config_info (
                        p_uecc_ue_context,
                        &p_eutra_src_to_trg_container->as_config_ext,
                        &p_rrc_container->as_Config.sourceSCellConfigList_r10))
                {
                    RRC_UECC_TRACE ((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR, 
                            "Error occurred while building ScellConfigInfo ");
                    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
            }

            if (RRC_FAILURE == process_and_fill_as_config_from_s1ap_ho_request(
                        p_uecc_ue_context,
                        &p_eutra_src_to_trg_container->as_config,
                        &p_rrc_container->as_Config))
            {
                RRC_UECC_TRACE ((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "Error occurred during the processing of as_config IE !!");
                RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            /* Copy Proximity Configuration */
            p_s1ap_as_config = &p_rrc_container->as_Config;

            if ((p_s1ap_as_config->m._v2ExtPresent) &&
                    (p_s1ap_as_config->sourceOtherConfig_r9.m.reportProximityConfig_r9Present))
            {
                p_eutra_src_to_trg_container->bitmask |= 
                    SRC_TO_TRG_CONTAINER_AS_CONFIG_PROXIMITY_CONFIG_PRESENT;

                if (p_s1ap_as_config->sourceOtherConfig_r9.
                        reportProximityConfig_r9.m.proximityIndicationEUTRA_r9Present)
                {
                    p_eutra_src_to_trg_container->proximity_config.bitmask |= 
                        RRM_PROXIMITY_IND_EUTRA_PRESENT;

                    p_eutra_src_to_trg_container->proximity_config.proximity_ind_eutra =
                        (U8)p_s1ap_as_config->sourceOtherConfig_r9.
                        reportProximityConfig_r9.proximityIndicationEUTRA_r9;
                }

                if (p_s1ap_as_config->sourceOtherConfig_r9.
                        reportProximityConfig_r9.m.proximityIndicationUTRA_r9Present)
                {
                    p_eutra_src_to_trg_container->proximity_config.bitmask |= 
                        RRM_PROXIMITY_IND_UTRA_PRESENT;

                    p_eutra_src_to_trg_container->proximity_config.proximity_ind_utra =
                        (U8)p_s1ap_as_config->sourceOtherConfig_r9.
                        reportProximityConfig_r9.proximityIndicationUTRA_r9;
                }

            }

            if (RRC_FAILURE ==
                    process_and_fill_as_context_from_s1ap_ho_request(
                        p_uecc_ue_context,
                        &p_eutra_src_to_trg_container->as_context,
                        &p_rrc_container->as_Context))
            {
                RRC_UECC_TRACE ((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "Error occurred during the processing of as_context IE!!");

                RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                return RRC_FAILURE;
            }

        }
        else
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "Mandatory IE (AS-Config , AS-Context) absent in HandoverPreparationInformation-r8-IEs !!");
            RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }
    /*SPR_19066_START*/
    /* Code Removed */
    /*SPR_19066_END*/

    /* RRC_CONTAINER:Subscriber profile ID */
    if (RRC_SOURCE_ENB_TO_TARGET_ENB_SUBSCRIBER_PROFILER_ID_FOR_RFP_PRESENT &
            p_src_to_trg_trans_container->bitmask)
    {
        p_eutra_src_to_trg_container->bitmask |=
            SRC_TO_TRG_CONTAINER_SUB_PROFILE_ID_PRESENT;
        p_eutra_src_to_trg_container->sub_profile_id =
            p_src_to_trg_trans_container->
            subscriberProfileIDforRFP;
    }

    /* RRC_CONTAINER:UE History Information*/
    if (RRC_FAILURE == process_and_fill_ue_history_from_s1ap_ho_request(
                p_uecc_ue_context,
                &p_eutra_src_to_trg_container->ue_history,
                &p_src_to_trg_trans_container->ue_HistoryInformation))
    {
        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* ERAB INFO LIST */
    if (RRC_SOURCE_ENB_TO_TARGET_ENB_E_RAB_INFO_LIST_PRESENT &
            p_src_to_trg_trans_container->bitmask)
    {
        p_node = p_src_to_trg_trans_container->e_RABInformationList.head;

        for (e_rab_list_count =0; e_rab_list_count <
                p_src_to_trg_trans_container->e_RABInformationList.count;
                e_rab_list_count++)
        {
            RRC_ASSERT(PNULL != p_node);
            RRC_ASSERT(PNULL != p_node->data);
            RRC_ASSERT(PNULL != (((s1ap_E_RABInformationList_element*)p_node->data)->
                        value.u._E_RABInformationListIEs_1));

            if(((s1ap_E_RABInformationList_element*)p_node->data)->
                    value.u._E_RABInformationListIEs_1->m.dL_ForwardingPresent)
            {
                for(drb_index=0; drb_index < 
                        (erab_to_be_setup_item_list)->num_of_list; drb_index++)
                {
                    if(erab_to_be_setup_item_list->erab_to_be_setup_item[drb_index].
                            erab_id == ((s1ap_E_RABInformationList_element*)p_node->data)->
                            value.u._E_RABInformationListIEs_1->e_RAB_ID)
                    {
                        erab_to_be_setup_item_list->erab_to_be_setup_item [drb_index].
                            dl_fwding = 1;
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_INFO, "DL_FWD SET For E_RAB ID = %u",
                                erab_to_be_setup_item_list->
                                erab_to_be_setup_item [drb_index].erab_id);
                        break;
                    }
                }
            }

            p_node = p_node->next;
        }
    }
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_ue_admission_resp
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
*
*   DESCRIPTION:
*       This function processes RRM RRC_RRM_UE_ADMISSION_RESP
******************************************************************************/
void uecc_rrm_process_ue_admission_resp
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;
    static rrc_rrm_ue_admission_resp_t     rrc_rrm_ue_admission_resp;
    S32                             length_read = RRC_NULL;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    memset_wrapper(&rrc_rrm_ue_admission_resp, 0, 
               sizeof(rrc_rrm_ue_admission_resp_t));
 
    do
    {
        /* Decode message */
        result = rrc_il_parse_rrc_rrm_ue_admission_resp(
                    &rrc_rrm_ue_admission_resp,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_UE_ADMISSION_RESP] parsing error.");
            break;
        }
       
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", rrc_rrm_ue_admission_resp.ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            rrc_rrm_ue_admission_resp.ue_index);

        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_UE_ADMISSION_RESP] The UE context isn't found.");
            break;
        }

	/* SPR 19273 Fix Start */
        SET_UE_INDEX(rrc_rrm_ue_admission_resp.ue_index);
        /* SPR 19273 Fix End */

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_UE_ADMISSION_RESP] Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"cell not active");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }
        /* Check transaction id */
        if (uecc_ue_ctx_get_op_transction_id(p_ue_context) !=
            rrc_get_transaction_id(p_api))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_UE_ADMISSION_RESP] Invalid transaction id.");
            break;
        }

        /* Call UECC_RCS_EVENT_UE_ADMISSION_RESP event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_UE_ADMISSION_RESP,
                &rrc_rrm_ue_admission_resp);
    }
    while(0);

   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_erb_setup_resp
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
*   DESCRIPTION:
*       This function processes RRC_RRM_ERB_SETUP_RESP message from RRM
******************************************************************************/
void uecc_rrm_process_erb_setup_resp
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_rrm_erb_setup_resp_t        *p_rrc_rrm_erb_setup_resp = PNULL;
    S32                             length_read = RRC_NULL;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {

        p_rrc_rrm_erb_setup_resp = rrc_mem_get(sizeof(rrc_rrm_erb_setup_resp_t));
        if (PNULL == p_rrc_rrm_erb_setup_resp)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,       
                    RRC_ERROR,
                    "[RRC_RRM_ERB_SETUP_RESP] Mem Alloc failed");
            break;
        }

        /* Encode message */
        result = rrc_il_parse_rrc_rrm_erb_setup_resp(
                    p_rrc_rrm_erb_setup_resp,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_ERB_SETUP_RESP] "
                "The RRC_RRM_ERB_SETUP_RESP parsing error.");
            break;
        }
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", p_rrc_rrm_erb_setup_resp->ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            p_rrc_rrm_erb_setup_resp->ue_index);

        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_ERB_SETUP_RESP] The UE context isn't found.");
            break;
        }

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_ERB_SETUP_RESP] Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_ERB_SETUP_RESP] Cell not Active.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }
        /* Check transaction id */
        if (uecc_ue_ctx_get_op_transction_id(p_ue_context) !=
            rrc_get_transaction_id(p_api))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_ERB_SETUP_RESP] Invalid transaction id.");
            break;
        }

        /* Call UECC_RM_EVENT_ERAB_SETUP_RESP event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_ERB_SETUP_RESP,
                p_rrc_rrm_erb_setup_resp);

        rrc_mem_free(p_rrc_rrm_erb_setup_resp);
        p_rrc_rrm_erb_setup_resp = PNULL;
    }
    while(0);
    /* coverity_fix_63278_start */
    if (PNULL != p_rrc_rrm_erb_setup_resp)
    {
        rrc_mem_free(p_rrc_rrm_erb_setup_resp);
    }
    /* coverity_fix_63278_stop */

   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_ue_connection_release_ind
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
*   DESCRIPTION:
*       This function processes RRC_RRM_UE_CONNECTION_RELEASE_IND message
*       from RRM
******************************************************************************/
void uecc_rrm_process_ue_connection_release_ind
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    rrc_return_et                       result = RRC_FAILURE;
    uecc_ue_context_t*                  p_ue_context = PNULL;
    static rrc_rrm_ue_connection_release_ind_t rrc_rrm_ue_connection_release_ind;
    S32                                 length_read = RRC_NULL;
    rrc_cell_index_t                    cell_index = RRC_INVALID_CELL_INDEX;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    memset_wrapper(&rrc_rrm_ue_connection_release_ind, 0, 
            sizeof(rrc_rrm_ue_connection_release_ind_t));
    do
    {
        /* Encode message */
        result = rrc_il_parse_rrc_rrm_ue_connection_release_ind(
                    &rrc_rrm_ue_connection_release_ind,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_rrm_process_ue_connection_release_ind: "
                "The RRC_RRM_UE_CONNECTION_RELEASE_IND parsing error.");
            break;
        }
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", rrc_rrm_ue_connection_release_ind.ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
                rrc_rrm_ue_connection_release_ind.ue_index);

        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_rrm_process_ue_connection_release_ind: "
                "The UE context isn't found.");
            break;
        }

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_process_ue_connection_release_ind: "
                    "Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_process_ue_connection_release_ind: "
                    "Cell not Active.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }
        /* Call UECC_EV_RRM_UE_CONNECTION_RELEASE_IND event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_UE_CONNECTION_RELEASE_IND,
                &rrc_rrm_ue_connection_release_ind);
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_ue_capability_enquiry
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
*   DESCRIPTION:
*       This function processes RRC_RRM_UE_CAPABILITY_ENQUIRY_REQ message
*       from RRM
******************************************************************************/
void uecc_rrm_process_ue_capability_enquiry
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    rrc_return_et                       result = RRC_FAILURE;
    uecc_ue_context_t*                  p_ue_context = PNULL;
    rrc_rrm_ue_capability_enquiry_req_t rrc_rrm_ue_capability_enquiry_req;
    S32                                 length_read = RRC_NULL;
    rrc_counter_t rat_type_index = 0;
    rrc_cell_index_t cell_index = RRC_INVALID_CELL_INDEX;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        result = rrc_il_parse_rrc_rrm_ue_capability_enquiry_req(
                    &rrc_rrm_ue_capability_enquiry_req,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);
        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_rrm_process_ue_capability_enquiry : "
                "The RRC_RRM_UE_CAPABILITY_ENQUIRY_REQ parsing error.");
            break;
        }
        
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", rrc_rrm_ue_capability_enquiry_req.ue_Index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            rrc_rrm_ue_capability_enquiry_req.ue_Index);

        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_rrm_process_ue_capability_enquiry : " 
                "The UE context isn't found");
            break;
        }

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_process_ue_capability_enquiry: "
                    "Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_process_ue_capability_enquiry: "
                    "Cell not Active.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }
        /*SPR_17893_START*/
        /*Store transaction id in ue_context*/
        p_ue_context->ue_capability_transaction_id = rrc_get_transaction_id(p_api);
        /*SPR_17893_END*/
        /* setting global flag */
        p_ue_context->rrm_ue_capability_enq_ind = RRC_TRUE;

        if(RAT_TYPE_INFO_PRESENT == rrc_rrm_ue_capability_enquiry_req.bitmask)
        {
            p_ue_context->rrm_ue_capability_enq_count = 
                rrc_rrm_ue_capability_enquiry_req.rat_type_info.rat_type_count;

            for(rat_type_index = 0;
            rat_type_index < rrc_rrm_ue_capability_enquiry_req.rat_type_info.
            rat_type_count; rat_type_index++)
            {
                p_ue_context->rrm_ue_capability_enq_list[rat_type_index] = 
                            rrc_rrm_ue_capability_enquiry_req.
                            rat_type_info.rat_type[rat_type_index];
            }
        }

        /* Call UECC_EV_RRM_UE_CAPABILITY_ENQUIRY_REQ event handler *
             * and pass API data to FSM. */
            /* WARNING. The uecc_event_queue_push_event can't be used here because
             * the stack variable
             * is used for storing the API data
           * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_UE_CAPABILITY_ENQUIRY_REQ,
                &rrc_rrm_ue_capability_enquiry_req);
    }
    while(0);

   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}



/******************************************************************************
* FUNCTION NAME:  uecc_rrm_process_csfb_parameters_resp_cdma2000
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
* DESCRIPTION:    This is the function for receives
*                 RRC_RRM_CSFB_PARAMETERS_RESP_CDMA2000 message from RRM
*                 decodes it and posts event to the mainfsm.
******************************************************************************/

void uecc_rrm_process_csfb_parameters_resp_cdma2000
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);

    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_rrm_csfb_parameters_resp_cdma2000_t
                                    rrc_rrm_csfb_parameters_resp_cdma2000;
    S32                             length_read = RRC_NULL;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    //decoding message recvd from RRM
    do
    {
        /* Decode message */
        result = rrc_il_parse_rrc_rrm_csfb_parameters_resp_cdma2000(
                    &rrc_rrm_csfb_parameters_resp_cdma2000,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[CDMA2000:RRC_RRM_UE_HO_CMD_RESP] parsing error.");
            break;
        }

        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", rrc_rrm_csfb_parameters_resp_cdma2000.ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            rrc_rrm_csfb_parameters_resp_cdma2000.ue_index);

        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[CDMA2000:RRC_RRM_CSFB_PARAMETERS_RESP_CDMA2000]\
                  The UE context isn't found.");
            break;
        }

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[CDMA2000:RRC_RRM_CSFB_PARAMETERS_RESP_CDMA2000]\
                      Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[CDMA2000:RRC_RRM_CSFB_PARAMETERS_RESP_CDMA2000]\
                      Cell not Active.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }
        /* Check transaction id */
        if (uecc_ue_ctx_get_op_transction_id(p_ue_context) !=
            rrc_get_transaction_id(p_api))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[CDMA2000:RRC_RRM_CSFB_PARAMETERS_RESP_CDMA2000]\
                  Invalid transaction id.");
            break;
        }

        /* CDMA2000:RRC_RRM_CSFB_PARAMETERS_RESP_CDMA2000 event handler *
           and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
           the stack variable is used for storing the API data
        */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_CSFB_PARAMETERS_RESPONSE_CDMA2000,
                &rrc_rrm_csfb_parameters_resp_cdma2000);
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_ue_release_resp
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
*   DESCRIPTION  : 
*       This function processes RRC_RRM_UE_RELEASE_RESP message from RRM
******************************************************************************/
void uecc_rrm_process_ue_release_resp
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_rrm_ue_release_resp_t       rrc_rrm_ue_release_resp;
    S32                             length_read = RRC_NULL;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        /* Encode message */
        result = rrc_il_parse_rrc_rrm_ue_release_resp(
                    &rrc_rrm_ue_release_resp,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_rrm_process_ue_release_resp: "
                "The RRC_RRM_UE_RELEASE_RESP parsing error.");
            break;
        }
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", rrc_rrm_ue_release_resp.ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            rrc_rrm_ue_release_resp.ue_index);

        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_rrm_process_ue_release_resp: The UE context isn't found");
            break;
        }

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_process_ue_release_resp: "
                    "Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_process_ue_release_resp: "
                    "Cell not Active.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }
        /* Check transaction id */
        if (uecc_ue_ctx_get_op_transction_id(p_ue_context) !=
            rrc_get_transaction_id(p_api))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING, "Invalid transaction id.");
            break;
        }

        /* Call UECC_RCR_EVENT_RRM_UE_RELEASE_RESP event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable
         * is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_UE_RELEASE_RESP,
                &rrc_rrm_ue_release_resp);
    }
    while(0);

   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_ho_required
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
*   DESCRIPTION:
*       This function processes RRM RRC_RRM_HO_REQUIRED
******************************************************************************/
void uecc_rrm_process_ho_required
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_rrm_ho_required_t           *p_rrc_rrm_ho_required = PNULL;
    S32                             length_read = RRC_NULL;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;
    /* SPR 24021/SES-452 Fix Start */
    rrc_return_et                   ret_val = RRC_SUCCESS;
    /* SPR 24021/SES-452 Fix End */

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    
    do
    {
        p_rrc_rrm_ho_required = rrc_mem_get(sizeof(rrc_rrm_ho_required_t));
        if (PNULL == p_rrc_rrm_ho_required)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_FATAL,
                "[RRC_RRM_HO_REQUIRED] Memory alloc failed.");
            break;
        }
        /* Decode message */
        result = rrc_il_parse_rrc_rrm_ho_required(
                    p_rrc_rrm_ho_required,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_HO_REQUIRED] parsing error.");
            /* SPR 24021/SES-452 Fix Start */
            ret_val = RRC_FAILURE;
            /* SPR 24021/SES-452 Fix End */
            break;
        }
                
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", p_rrc_rrm_ho_required->ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            p_rrc_rrm_ho_required->ue_index);

        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_HO_REQUIRED] The UE context isn't found.");
            /* SPR 24021/SES-452 Fix Start */
            ret_val = RRC_FAILURE;
            /* SPR 24021/SES-452 Fix End */
            break;
        }
        
        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_HO_REQUIRED] Invalid Cell Index.");
            /* SPR 24021/SES-452 Fix Start */
            ret_val = RRC_FAILURE;
            /* SPR 24021/SES-452 Fix End */
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_HO_REQUIRED] Cell not Active.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            /* SPR 24021/SES-452 Fix Start */
            ret_val = RRC_FAILURE;
            /* SPR 24021/SES-452 Fix End */
            break;
        }
        /* Bug 817 Fix Start */
        if (p_ue_context->rrc_trg_ho_fwd_tnl_info.drb_tunnel_info_count > 0)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_HO_REQUIRED] Forwarding of previous HO is ongoing.");

            p_ue_context->ho_info.s1_or_x2_handover = INVALID_HO;

            if (RRC_SUCCESS != uecc_rrm_build_and_send_ho_failure (p_ue_context))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_HO_REQUIRED] Fail to send RRC_RRM_HO_FAILURE");
            }

            /* SPR 24021/SES-452 Fix Start */
            ret_val = RRC_FAILURE;
            /* SPR 24021/SES-452 Fix End */
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
            
        }
        /* Bug 817 Fix Stop */
        
        /* Call UECC_EV_RRM_HO_REQUIRED event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_HO_REQUIRED,
                p_rrc_rrm_ho_required);
    }
    while(0);
    /* SPR 24021/SES-452 Fix Start */
    if(RRC_FAILURE == ret_val)
    {
        if (PNULL != p_rrc_rrm_ho_required)
        {
            rrc_mem_free(p_rrc_rrm_ho_required);
            p_rrc_rrm_ho_required = PNULL;
        }
    }
    /* SPR 24021/SES-452 Fix End */
   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_ue_ho_adm_resp
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
*   DESCRIPTION:
*       This function processes RRM RRC_RRM_UE_HO_ADM_RESP
******************************************************************************/
void uecc_rrm_process_ue_ho_adm_resp
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;
    static rrc_rrm_ue_ho_adm_resp_t        rrc_rrm_ue_ho_adm_resp;
    S32                             length_read = RRC_NULL;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    memset_wrapper(&rrc_rrm_ue_ho_adm_resp, 0, sizeof(rrc_rrm_ue_ho_adm_resp_t));
    
    do
    {
        /* Decode message */
        result = rrc_il_parse_rrc_rrm_ue_ho_adm_resp(
                    &rrc_rrm_ue_ho_adm_resp,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_UE_HO_ADM_RESP] parsing error.");
            break;
        }
        
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,RRC_INFO,
           "API:RRM->RRC:RRC_RRM_UE_HO_ADM_RESP:[UE:%u] with response:%u",
           rrc_rrm_ue_ho_adm_resp.ue_index, rrc_rrm_ue_ho_adm_resp.response.response);

        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            rrc_rrm_ue_ho_adm_resp.ue_index);

        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_UE_HO_ADM_RESP] The UE context isn't found.");
            break;
        }

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_UE_HO_ADM_RESP] Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_UE_HO_ADM_RESP] Cell not Active.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }
        /* Check transaction id */
        if (uecc_ue_ctx_get_op_transction_id(p_ue_context) !=
            rrc_get_transaction_id(p_api))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_UE_HO_ADM_RESP] Invalid transaction id.");
            break;
        }

        /* Call UECC_EV_RRM_HO_ADM_RESP event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_HO_ADM_RESP,
                &rrc_rrm_ue_ho_adm_resp);
    }
    while(0);

   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_ho_cancel_req
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
*   DESCRIPTION:
*       This function processes RRM RRC_RRM_HO_CANCEL_REQ
******************************************************************************/
void uecc_rrm_process_ho_cancel_req
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_rrm_ho_cancel_req_t         rrc_rrm_ho_cancel_req;
    S32                             length_read = RRC_NULL;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    
    do
    {
        /* Decode message */
        result = rrc_il_parse_rrc_rrm_ho_cancel_req(
                    &rrc_rrm_ho_cancel_req,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_HO_CANCEL_REQ] parsing error.");
            break;
        }

        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", rrc_rrm_ho_cancel_req.ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            rrc_rrm_ho_cancel_req.ue_index);

        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_HO_CANCEL_REQ] The UE context isn't found.");
            break;
        }

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_HO_CANCEL_REQ] Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_HO_CANCEL_REQ] Cell not Active.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }
        /* Check transaction id */
        if (uecc_ue_ctx_get_op_transction_id(p_ue_context) !=
            rrc_get_transaction_id(p_api))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_HO_CANCEL_REQ] Invalid transaction id.");
            break;
        }

        /* Call UECC_EV_RRM_HO_CANCEL_REQ event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_HO_CANCEL_REQ,
                &rrc_rrm_ho_cancel_req);
    }
    while(0);

   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_ue_ho_cmd_resp
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
*   DESCRIPTION:
*       This function processes RRM RRC_RRM_UE_HO_CMD_RESP
******************************************************************************/
void uecc_rrm_process_ue_ho_cmd_resp
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_rrm_ue_ho_command_response_t  rrc_rrm_ue_ho_cmd_resp;
    S32                             length_read = RRC_NULL;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    
    do
    {
        /* Decode message */
        result = rrc_il_parse_rrc_rrm_ue_ho_command_response(
                    &rrc_rrm_ue_ho_cmd_resp,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_UE_HO_CMD_RESP] parsing error.");
            break;
        }
        
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", rrc_rrm_ue_ho_cmd_resp.ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            rrc_rrm_ue_ho_cmd_resp.ue_index);

        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_UE_HO_CMD_RESP] The UE context isn't found.");
            break;
        }

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_UE_HO_CMD_RESP] Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_UE_HO_CMD_RESP] Cell not Active.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }
        /* Check transaction id */
        if (uecc_ue_ctx_get_op_transction_id(p_ue_context) !=
            rrc_get_transaction_id(p_api))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_UE_HO_CMD_RESP] Invalid transaction id.");
            break;
        }

        /* Call UECC_EV_RRM_HO_CMD_RESP event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_HO_CMD_RESP,
                &rrc_rrm_ue_ho_cmd_resp);
    }
    while(0);

   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}



/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_erb_release_resp
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
*   DESCRIPTION:
*       This function processes RRC_RRM_ERB_RELEASE_RESP message from RRM
******************************************************************************/
void uecc_rrm_process_erb_release_resp
(
    void*                p_api,             /* Input API buffer */
    uecc_gb_context_t*   p_uecc_gb_context  /* UECC global context */
)
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_rrm_erb_release_resp_t      rrc_rrm_erb_release_resp;
    S32                             length_read = RRC_NULL;
    rrc_return_et                   result = RRC_FAILURE;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;

    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        /* Encode message */
        result = rrc_il_parse_rrc_rrm_erb_release_resp(
                    &rrc_rrm_erb_release_resp,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api) - 
                        RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        if (RRC_SUCCESS != result)
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_rrm_process_erb_release_resp: "
                "The RRC_RRM_ERB_RELEASE_RESP parsing error.");
            break;
        }
        
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", rrc_rrm_erb_release_resp.ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            rrc_rrm_erb_release_resp.ue_index);

        if (PNULL == p_ue_context)
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_rrm_process_erb_release_resp: The UE context isn't found");
            break;
        }

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_process_erb_release_resp: Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_process_erb_release_resp: Cell not Active.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }
        /* Check transaction id */
        if (uecc_ue_ctx_get_op_transction_id(p_ue_context) !=
            rrc_get_transaction_id(p_api))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING, "Invalid transaction id.");
            break;
        }

        /* Call UECC_EV_RRM_ERB_RELEASE_RESP event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable
         * is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_ERB_RELEASE_RESP,
                &rrc_rrm_erb_release_resp);
    } while(0);

   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_erb_release_ind
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
*   DESCRIPTION:
*       This function processes RRC_RRM_ERB_RELEASE_IND message from RRM
******************************************************************************/
void uecc_rrm_process_erb_release_ind
(
    void*                p_api,             /* Input API buffer */
    uecc_gb_context_t*   p_uecc_gb_context  /* UECC global context */
)
{
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_rrm_erb_release_ind_t       rrc_rrm_erb_release_ind;
    S32                             length_read = RRC_NULL;
    rrc_return_et                   result = RRC_FAILURE;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;

    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        /* Encode message */
        result = rrc_il_parse_rrc_rrm_erb_release_ind(
                    &rrc_rrm_erb_release_ind,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api) - 
                        RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        if (RRC_SUCCESS != result)
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_rrm_process_erb_release_ind: "
                "The RRC_RRM_ERB_RELEASE_IND parsing error.");
            break;
        }
        
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", rrc_rrm_erb_release_ind.ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            rrc_rrm_erb_release_ind.ue_index);

        if (PNULL == p_ue_context)
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_rrm_process_erb_release_ind: The UE context isn't found");
            break;
        }

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_process_erb_release_ind: Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_process_erb_release_ind: Cell not Active.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }
        /* Call UECC_EV_RRM_ERB_RELEASE_IND event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable
         * is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_ERAB_RELEASE_IND,
                &rrc_rrm_erb_release_ind);
    } while(0);

   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/* Measurment Re-config START */
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_meas_config_req
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
*   DESCRIPTION:
*       This function processes RRM RRC_RRM_MEAS_CONFIG_REQ
******************************************************************************/
void uecc_rrm_process_meas_config_req
(
    void*                p_api,             /* Input API buffer */
    uecc_gb_context_t*   p_uecc_gb_context  /* UECC global context */
)
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t*              p_ue_context = PNULL;
    /* SPR 22069 Fix Start */
    rrc_rrm_meas_config_req_t       *p_rrc_rrm_meas_config_req = RRC_PNULL;
    /* SPR 22069 Fix Start */
    S32                             length_read = RRC_NULL;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;
    ue_reconfig_queue_node_t        *p_ue_reconfig_queue_node = PNULL;
    list_t                          *p_ue_reconfig_queue = PNULL;

    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    /* SPR 22069 Fix Start */
    p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t *)rrc_mem_get(sizeof(rrc_rrm_meas_config_req_t));
    if(RRC_PNULL != p_rrc_rrm_meas_config_req)
    {
        do
        {
            /* Decode message */
            result = rrc_il_parse_rrc_rrm_meas_config_req(
                    p_rrc_rrm_meas_config_req,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

            if ( RRC_SUCCESS != result )
            {
                /* Message parsing error */
                /* - Drop message */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_MEAS_CONFIG_REQ] parsing error.");
                break;
            }
        
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                        RRC_BRIEF,"[UE_INDEX:%u]", p_rrc_rrm_meas_config_req->ue_index);
            /* Process message */
            p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
                        p_rrc_rrm_meas_config_req->ue_index);

            if ( PNULL == p_ue_context )
            {
                /* Error. Can't find UE context */
                /* - Drop message */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_MEAS_CONFIG_REQ] The UE context isn't found.");
                break;
            }

            rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                    p_api, &cell_index);

            if (RRC_INVALID_CELL_INDEX == cell_index)
            {
                /* Error. Can't find Cell Index */
                /* - Drop message */
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[RRC_RRM_MEAS_CONFIG_REQ] Invalid Cell Index.");
                break;
            }

            if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                        p_uecc_gb_context, cell_index))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_WARNING,
                        "[RRC_RRM_MEAS_CONFIG_REQ] Cell not Active.");
                RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
                break;
            }

            /* save the transaction_id of RRM procedure in UE context meas_proc_trans_id
            * */
            p_ue_context->meas_proc_trans_id = rrc_get_transaction_id(p_api);

            /* store meas config in ue context */
            if (p_ue_context->p_meas_config == PNULL)
            {
                p_ue_context->p_meas_config = (rrm_meas_config_t *)
                   rrc_mem_get(sizeof(rrm_meas_config_t));

                if (p_ue_context->p_meas_config == PNULL)
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_FATAL,
                        "[RRC_RRM_MEAS_CONFIG_REQ] Memory Allocation Failure.");
                    break;

                }
            }
        
            if (PNULL != p_ue_context->timers_data.timers_ids[UECC_UE_MEAS_CONFIG_GUARD_TIMER])
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_ERROR,
                        "[RRC_RRM_MEAS_CONFIG_REQ] Meas Config Procedure already ongoing ."
                        "Sending Failure to RRM ");

                /* Build and send the RRC_RRM_MEAS_CONFIG_RESP(failure) to RRM. */
                if (RRC_SUCCESS != uecc_rrm_build_and_send_meas_config_resp(
                            p_ue_context, RRC_FAILURE, RRC_RRM_MEAS_CONFIG_ALREADY_ONGOING))
                {
                    /* Process failure according to selected failure actions list */
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "Failure to build and send meas config resp to RRM.");
                }
                break;
            }

            /* check if main FSM state is not 
             * UECC_UE_IDLE, UECC_UE_CONNECTION_SETUP_ONGOING
             * UECC_WAIT_FOR_CONNECTION_RELEASE, UECC_UE_CONNECTION_RELEASE_ONGOING
	     * 
	     * also have to check with the UECC_UE_WAIT_FOR_S1_CONNECTION
	     * and UECC_S1_CONNECTION_ONGOING 
	     */ 
	    if (p_ue_context->uecc_fsm.p_current_state->s_name != PNULL)
	    {
                if ((!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                (const S8 *)"UECC_UE_IDLE")) ||
                    (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                 (const S8 *)"UECC_UE_CONNECTION_SETUP_ONGOING")) ||
                    (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                 (const S8 *)"UECC_UE_WAIT_FOR_CONNECTION_RELEASE")) ||
                    (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                 (const S8 *)"UECC_UE_CONNECTION_RELEASE_ONGOING")) ||
                    (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                 (const S8 *)"UECC_UE_WAIT_FOR_S1_CONNECTION"))) 
                {
                    /* Build and send the RRC_RRM_MEAS_CONFIG_RESP(failure) to RRM. */
                    if (RRC_SUCCESS != uecc_rrm_build_and_send_meas_config_resp(
                                p_ue_context, RRC_FAILURE, RRC_NO_ERROR))
                    {
                        /* Process failure according to selected failure actions list */
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,
                                "Failure to build and send meas config resp to RRM.");
                        break;
                    }
                    break;
                }
            }
        
            /* Klockwork fix */
            if ( ( PNULL != p_ue_context->uecc_fsm.p_current_state->s_name)
                                      &&
                 ( RRC_NULL != strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                        (const S8 *)"UECC_UE_CONNECTED")))
            /* Klockwork fix */
            {
                /* SPR 17900 Fix Start */
                if ((!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                (const S8 *)"UECC_UE_CONNECTION_RECONFIGURATION_ONGOING")) &&
                     (PNULL != p_ue_context->uecc_fsm.proc_descriptor.p_current_state->s_name) &&
                       ((!strcmp_wrapper(p_ue_context->uecc_fsm.proc_descriptor.p_current_state->s_name,
                                 (const S8 *)("UECC_RRM_ERB_SETUP_RESOURCE_ADMISSION_ONGOING"))) ||
                       (!strcmp_wrapper(p_ue_context->uecc_fsm.proc_descriptor.p_current_state->s_name,
                                 (const S8 *)("UECC_ERB_MODIFY_RRM_RESOURCE_MODIFICATION_ONGOING"))) ||
                       (!strcmp_wrapper(p_ue_context->uecc_fsm.proc_descriptor.p_current_state->s_name,
                                 (const S8 *)("UECC_RRM_ERB_RELEASE_RESOURCE_DELETION_ONGOING")))))
                {
                    /* Build and send the RRC_RRM_MEAS_CONFIG_RESP(failure) to RRM. */
                    if (RRC_SUCCESS != uecc_rrm_build_and_send_meas_config_resp(
                                p_ue_context, RRC_FAILURE, RRC_INTERACTION_WITH_OTHER_PROCEDURE))
                    {
                        /* Process failure according to selected failure actions list */
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,
                               "Failure to build and send meas config resp to RRM.");
                    }
                    break;
                }
                /* SPR 17900 Fix Stop */
                p_ue_reconfig_queue_node = (ue_reconfig_queue_node_t*)
                    rrc_mem_get(sizeof(ue_reconfig_queue_node_t) + rrc_get_api_buf_size(p_api));
            
                if (PNULL != p_ue_reconfig_queue_node)
                {
                    p_ue_reconfig_queue_node->message_type = MEAS_CONFIG_REQUEST;
                
                    l3_memcpy_wrapper((void *)p_ue_reconfig_queue_node->message,
                            (const void *)p_api, (rrc_get_api_buf_size(p_api)));
   
                    p_ue_reconfig_queue = &p_ue_context->ue_reconfig_queue;
  
                    if ((RECONFIGURATION_Q_GET_COUNT(p_ue_reconfig_queue)) < 
                            RECONFIGURATION_Q_MAX_LENGTH)
                    {
                        RECONFIGURATION_Q_ENQUEUE(p_ue_reconfig_queue, 
                                p_ue_reconfig_queue_node);
                    
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
				RRC_INFO,
				"[RRC_RRM_MEAS_CONFIG_REQ] Enqueued in "
				"reconfiguration queue . Queue length :%d",
				RECONFIGURATION_Q_GET_COUNT(p_ue_reconfig_queue));
		    }
		    else
		    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
				RRC_ERROR, 
				"[RRC_RRM_MEAS_CONFIG_REQ]Reconfiguration Queue Full : Message Discarded");

                        /* Build and send the RRC_RRM_MEAS_CONFIG_RESP(failure) to RRM. */
                        if (RRC_SUCCESS != uecc_rrm_build_and_send_meas_config_resp(
                                    p_ue_context, RRC_FAILURE, RRC_NO_ERROR))
                        {
                            /* Process failure according to selected failure actions list */
                            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                    p_uecc_gb_context->facility_name,
                                    RRC_WARNING,
                                    "Failure to build and send meas config resp to RRM.");
                        }
                        /* coverity_fix_63281_start */
                        rrc_mem_free(p_ue_reconfig_queue_node);
                        /* Coverity ID 85881 Fix Start*/
                        /*  p_ue_reconfig_queue_node = PNULL; */
                        /* Coverity ID 85881 Fix End*/
                       /* coverity_fix_63281_stop */
                     }
                }
		else
		{
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "Mem Alloc failed : Ignoring [RRC_RRM_MEAS_CONFIG_REQ]");                
		}
	    }
	    else
	    {
                l3_memcpy_wrapper(p_ue_context->p_meas_config,
                        &p_rrc_rrm_meas_config_req->meas_config,
                        sizeof(p_rrc_rrm_meas_config_req->meas_config));

                if (p_ue_context->curr_meas_config.is_meas_config_valid == 
                        RRM_RRC_MC_VALIDATE_FAILURE )
                {
                    if ((UE_ADM_MEAS_OBJECT_TO_REMOVE_LIST_PRESENT & 
                             p_ue_context->p_meas_config->bitmask) ||
                            (UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT &
                            p_ue_context->p_meas_config->bitmask)||
                           (UE_ADM_MEAS_ID_TO_REMOVE_LIST_PRESENT &
                            p_ue_context->p_meas_config->bitmask))
                    {
                        /* Build and send the RRC_RRM_MEAS_CONFIG_RESP(failure) to RRM. */
                        if (RRC_SUCCESS != uecc_rrm_build_and_send_meas_config_resp(
                                    p_ue_context, RRC_FAILURE, RRC_NO_ERROR))
                        {
                            /* Process failure according to selected failure actions list */
                            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                    p_uecc_gb_context->facility_name,
                                    RRC_WARNING,
                                    "Failure to build and send meas config resp to RRM.");
                            break;
                        }
                        break;
                    }
		}
                p_ue_context->curr_meas_config.is_meas_config_valid = 
                    RRM_RRC_MC_VALIDATE_SUCCESS;
        
		/* save the transaction_id in meas_transaction_id 
		 * variable in UE context */
		 uecc_ue_ctx_set_meas_transction_id(p_ue_context,
                       uecc_ue_ctx_get_next_transction_id(p_ue_context));

		 /* start timer */
		 if (RRC_SUCCESS != uecc_ue_timer_start(
                        p_uecc_gb_context, 
                        UECC_UE_MEAS_CONFIG_GUARD_TIMER,
                        &p_ue_context->p_gb_context->ue_timers_data,
                        &p_ue_context->timers_data,
                        p_ue_context->ue_index))
		 {
			 RRC_UECC_TRACE(p_uecc_gb_context->context_index,
					 p_uecc_gb_context->facility_name,
					 RRC_WARNING,
					 "Failure to start LL Guard Timer.");
			 break;
		 }

		 /* Vimal : if Meas-gap config present 
		  * send UECC_LLIM_MEAS_CONFIG_REQ to LLIM */
                if (p_ue_context->p_meas_config->bitmask &
                        UE_ADM_MEAS_GAP_CONFIG_PRESENT)
		{
			if (RRC_SUCCESS != uecc_llim_build_and_send_meas_config_req
					(p_ue_context))
			{
				RRC_UECC_TRACE(p_uecc_gb_context->context_index,
						p_uecc_gb_context->facility_name,
						RRC_ERROR,
						"[UECC_LLIM_MEAS_CONFIG_REQ] Message sending failed .");
				break;
			}
		}
		else
		{
			/* Build and send RRCConnectionReconfiguration to UE */
			if (RRC_SUCCESS !=
					uecc_llim_build_and_send_meas_reconfig_rrc_connection_reconfiguration(
						p_ue_context))
			{
				RRC_UECC_TRACE(p_uecc_gb_context->context_index,
						p_uecc_gb_context->facility_name,
						RRC_WARNING,
						"Failure to build and send "
						"meas_reconfig_rrc_connection_reconfiguration to LLIM.");
				break;
			}
		}
        }
    }
    while(0);
    }
    if(RRC_PNULL != p_rrc_rrm_meas_config_req)
    {
        rrc_mem_free(p_rrc_rrm_meas_config_req);
    }
    /* SPR 22069 Fix End */

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/* Measurment Re-config END */
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_rrm_cause
*   INPUT        : rrm_cause_t*    p_rrm_cause
*                  s1ap_Cause*     p_cause
*                  uecc_ue_context_t* p_uecc_ue_contex
*   OUTPUT       : none
*   RETURN       : RRC_SUCCESS
*   DESCRIPTION:
*       This function builds rrm_cause_t
*******************************************************************************/
rrc_return_et uecc_rrm_build_rrm_cause(
    rrm_cause_t*    p_rrm_cause,
    s1ap_Cause*     p_cause,
    uecc_ue_context_t* p_uecc_ue_context
)
{
    rrc_return_et result = RRC_SUCCESS;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    RRC_ASSERT(PNULL != p_rrm_cause);
    RRC_ASSERT(PNULL != p_cause);

    p_rrm_cause->type = (U8)p_cause->t;
    p_rrm_cause->value = 0;

    switch (p_rrm_cause->type)
    {
        case T_s1ap_Cause_radioNetwork:
            p_rrm_cause->value = (U16)p_cause->u.radioNetwork;
            break;
        case T_s1ap_Cause_transport:
            p_rrm_cause->value = (U16)p_cause->u.transport;
            break;
        case T_s1ap_Cause_nas:
            p_rrm_cause->value = (U16)p_cause->u.nas;
            break;
        case T_s1ap_Cause_protocol:
            p_rrm_cause->value = (U16)p_cause->u.protocol;
            break;
        case T_s1ap_Cause_misc:
            p_rrm_cause->value = (U16)p_cause->u.misc;
            break;
        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "[S1AP E-RAB RELEASE COMMAND] Invalid cause type:%d",
                p_rrm_cause->type);
            result = RRC_FAILURE;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_rrm_x2ap_cause
*   INPUT        : rrm_cause_t*    p_rrm_cause
*                  x2ap_Cause*     p_cause
*                  uecc_ue_context_t* p_uecc_ue_context
*   OUTPUT       : none
*
*   DESCRIPTION:
*       This function builds rrm_cause_t
*
*   RETURNS      : RRC_SUCCESS/RRC_FAILURE 
*
*******************************************************************************/
rrc_return_et uecc_rrm_build_rrm_x2ap_cause(
    rrm_cause_t*    p_rrm_cause,
    x2ap_Cause*     p_cause,
    uecc_ue_context_t* p_uecc_ue_context
)
{
    rrc_return_et result = RRC_SUCCESS;


    RRC_ASSERT(PNULL != p_rrm_cause);
    RRC_ASSERT(PNULL != p_cause);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_rrm_cause->type = (U8)p_cause->t;
    p_rrm_cause->value = 0;

    switch (p_rrm_cause->type)
    {
        case T_x2ap_Cause_radioNetwork:
            p_rrm_cause->value = (U16)p_cause->u.radioNetwork;
            break;
        case T_x2ap_Cause_transport:
            p_rrm_cause->value = (U16)p_cause->u.transport;
            break;
        case T_x2ap_Cause_protocol:
            p_rrm_cause->value = (U16)p_cause->u.protocol;
            break;
        case T_x2ap_Cause_misc:
            p_rrm_cause->value = (U16)p_cause->u.misc;
            break;
        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "[uecc_rrm_build_and_send_ho_failure] Invalid cause type:%d",
                p_rrm_cause->type);
            result = RRC_FAILURE;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/* ERB RELEASE COMMAND END */
/****************************************************************************
 ****************************************************************************
 * Build and Send Functions implementation
 ****************************************************************************
 ****************************************************************************/
/* ERB RELEASE COMMAND START */
/******************************************************************************
*   FUNCTION NAME : uecc_rrm_build_and_send_erb_release_req
*   INPUT         : uecc_ue_context_t*   p_uecc_ue_context
*   OUTPUT        : none
*   DESCRIPTION   :    
*       This is the function for building and sending
*       RRC_RRM_ERB_RELEASE_REQ message to the RRM.
*
*   RETURNS       : None
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_erb_release_req(
    uecc_ue_context_t*   p_uecc_ue_context      /* UECC UE context */
)
{
    rrc_rrm_erb_release_req_t       rrc_rrm_erb_release_req;
    rrc_return_et                   response = RRC_FAILURE;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Coverity Fix 83185 Start */
    memset_wrapper(&rrc_rrm_erb_release_req, RRC_NULL, 
        sizeof(rrc_rrm_erb_release_req_t));
    /* Coverity Fix 83185 Stop */

    #ifdef ENDC_ENABLED
    if ( ( p_uecc_ue_context->sgnbInitiatedSgnbReleaseFlag ) ||
         ( ERAB_REL == p_uecc_ue_context->release_type ) )
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "building uecc_rrm_build_rrc_rrm_erb_release_req_endc");
        /* Build message */
        uecc_rrm_build_rrc_rrm_erb_release_req_endc(
                p_uecc_ue_context,
                &rrc_rrm_erb_release_req);
    }
    else
    {
     /* Build message */
    uecc_rrm_build_rrc_rrm_erb_release_req(
            p_uecc_ue_context,
            &rrc_rrm_erb_release_req);
    }
    #else
     /* Build message */
    uecc_rrm_build_rrc_rrm_erb_release_req(
            p_uecc_ue_context,
            &rrc_rrm_erb_release_req);
    #endif

    /* Encode and send message */
    response = rrc_rrm_il_send_rrc_rrm_erb_release_req(
                   &rrc_rrm_erb_release_req,
                   RRC_UECC_MODULE_ID,
                   RRC_RRM_MODULE_ID,
                   uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context),
                   p_uecc_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return response;
}

/******************************************************************************
*   FUNCTION NAME : uecc_rrm_build_rrc_rrm_erb_release_req
*   INPUT         : uecc_ue_context_t*   p_uecc_ue_context
*                   rrc_rrm_erb_release_req_t* p_rrc_rrm_erb_release_req
*   OUTPUT        : none
*   DESCRIPTION   :
*       This function builds RRC_RRM_ERB_RELEASE_REQ message
*
*   RETURNS       : None
*
******************************************************************************/
void uecc_rrm_build_rrc_rrm_erb_release_req(
    uecc_ue_context_t* p_uecc_ue_context,
    rrc_rrm_erb_release_req_t* p_rrc_rrm_erb_release_req)
{
    erab_list_t*    p_erab_list = PNULL;
    U32 drb_index = RRC_NULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_rrm_erb_release_req);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(p_rrc_rrm_erb_release_req, 0, 
        sizeof(rrc_rrm_erb_release_req_t));

    /* Fill RRC_RRM_ERB_RELEASE_REQ API from RRC_S1AP_ERAB_RELEASE_COMMAND API
     * which is stored in Ue Context during procedure constructor */
    p_rrc_rrm_erb_release_req->ue_index = p_uecc_ue_context->ue_index;

    if (p_uecc_ue_context->m.ue_agg_max_bit_rate_updated == 1)
    {
        p_rrc_rrm_erb_release_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul =
            p_uecc_ue_context->ue_aggregate_maximum_bitrate.
            uEaggregateMaximumBitRateUL;

        p_rrc_rrm_erb_release_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl =
             p_uecc_ue_context->ue_aggregate_maximum_bitrate.
            uEaggregateMaximumBitRateDL;
        /* Set bit for ue_agg_max_bit_rate in api */
        p_rrc_rrm_erb_release_req->bitmask |= 
            RRC_RRM_ERB_RELEASE_REQ_UE_AGG_MAX_BIT_RATE_PRESENT;
    }

    /* point to erab_release_list in erab_release_command_data */
    p_erab_list = &p_uecc_ue_context->p_curr_proc_data->u.
        erab_release_command_data.erab_release_list;

    p_rrc_rrm_erb_release_req->erab_to_be_released_item_list.count =
        p_erab_list->counter;

    for(drb_index = 0; 
        drb_index < p_rrc_rrm_erb_release_req->erab_to_be_released_item_list
            .count; 
        drb_index++)
    {
        p_rrc_rrm_erb_release_req->erab_to_be_released_item_list.
        erab_to_be_release_item[drb_index].erab_id =
        (U8)(p_erab_list->erab_item[drb_index].e_RAB_ID);
        
        if (RRC_FAILURE == uecc_rrm_build_rrm_cause(&p_rrc_rrm_erb_release_req->
            erab_to_be_released_item_list.erab_to_be_release_item[drb_index].
            cause, &p_erab_list->erab_item[drb_index].cause,
            p_uecc_ue_context))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "Invalid s1ap_cause:[RRC_S1AP_ERAB_RELEASE_COMMAND]");
        }

    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_erb_release_conf
*   INPUT        : uecc_ue_context_t*  p_ue_context
*                  rrc_response_et    -   response
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds and sends 
        RRC_RRM_ERB_RELEASE_CNF/RRC_RRM_ERB_RELEASE_IND_CNF message
*       with failure to RRM module
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_erb_release_conf(
    uecc_ue_context_t*  p_ue_context,
    rrc_response_et       response)
{
    erab_list_t*    p_erab_list = PNULL;
    erab_list_t*    p_failed_erab_list = PNULL;
    rrc_return_et   rrc_response = RRC_FAILURE;
    rrc_rrm_erb_release_cnf_t rrc_rrm_erb_release_cnf;
    U8     erab_index = RRC_NULL;
    U16     resp_counter = RRC_NULL;
    U8     index = RRC_NULL;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&rrc_rrm_erb_release_cnf, 0, sizeof(rrc_rrm_erb_release_cnf_t));

    rrc_rrm_erb_release_cnf.ue_index = p_ue_context->ue_index;
    

    rrc_rrm_erb_release_cnf.response = response;

#ifdef ENDC_ENABLED
    if ( RRC_TRUE == p_ue_context->sgnbInitiatedSgnbReleaseFlag )
    {
        erab_list_t    erab_list;
        U8             counter = RRC_NULL;
        for ( erab_index = RRC_NULL; erab_index < MAX_ERAB_COUNT;
                erab_index++ )
        {
            if ( PNULL != p_ue_context->p_e_rab_list[erab_index] )
            {
                if ( p_ue_context->p_e_rab_list[erab_index]->m.DC_BearerTypePresent )
                {
                    erab_list.erab_item[counter].e_RAB_ID =
                        p_ue_context->p_e_rab_list[erab_index]->e_RAB_ID;

                    erab_list.erab_item[counter].cause.u.radioNetwork =
                        RRC_THREE;
                    erab_list.erab_item[counter].cause.t =
                        RRC_ONE;
                    p_ue_context->endc_erab_release_list.erab_item[erab_index].e_RAB_ID =
                        erab_list.erab_item[counter].e_RAB_ID;
                    counter++;
                }
            }
        }
        erab_list.counter = counter;
        rrc_rrm_erb_release_cnf.bitmask |=
            RRM_ERB_RELEASE_CNF_CONFIRM_LIST_PRESENT;
        rrc_rrm_erb_release_cnf.erab_cnf_list.erab_count =
            erab_list.counter;

        for ( erab_index = RRC_NULL;
                erab_index < erab_list.counter;
                erab_index++)
        {
            rrc_rrm_erb_release_cnf.erab_cnf_list.
                erab_cnf_info[erab_index].erab_id = (U8)
                erab_list.erab_item[erab_index].e_RAB_ID;
        }

    }
    else
    {
#endif

    /*point to erab_release_list in erab_release_command_data */
    p_erab_list = &(p_ue_context->p_curr_proc_data->u.
                      erab_release_command_data.erab_release_list);
    p_failed_erab_list = &(p_ue_context->p_curr_proc_data->u.
                      erab_release_command_data.erab_failed_to_release_list);


    /* erab_item_list */
    /* multi E-ERAB supporting */
    /* rrc_rrm_erb_release_cnf.erab_item_list.list_count = 
     * p_erab_list->counter;*/
    
    if (SUCCESS == response)
    {
        rrc_rrm_erb_release_cnf.bitmask |= 
            RRM_ERB_RELEASE_CNF_CONFIRM_LIST_PRESENT;
        rrc_rrm_erb_release_cnf.erab_cnf_list.erab_count = 
        p_erab_list->counter;

        for (erab_index = 0; 
             erab_index < p_erab_list->counter;
             erab_index++) 
        {
            rrc_rrm_erb_release_cnf.erab_cnf_list.
                erab_cnf_info[erab_index].erab_id = (U8) 
                p_erab_list->erab_item[erab_index].e_RAB_ID; 
        }

    }
    else if (FAILURE == response)
    {
        rrc_rrm_erb_release_cnf.bitmask |= 
            RRM_ERB_RELEASE_CNF_ERROR_LIST_PRESENT;
        rrc_rrm_erb_release_cnf.erab_error_list.erab_count = 
        p_erab_list->counter;
        for (erab_index = 0; 
             erab_index < p_erab_list->counter;
             erab_index++) 
        {
            rrc_rrm_erb_release_cnf.erab_error_list.
                erab_error_info[erab_index].erab_id = (U8) 
                p_erab_list->erab_item[erab_index].e_RAB_ID; 
            rrc_rrm_erb_release_cnf.erab_error_list.
                erab_error_info[erab_index].error_code = 
                p_erab_list->erab_item[erab_index].error_code; 
        }
        resp_counter = p_ue_context->p_curr_proc_data->u.
            erab_release_command_data.counter_after_rrm_resp;

        if (RRC_NULL < (U16)(p_failed_erab_list->counter - resp_counter))
        {
            /* fill from failed to release list */
            for (erab_index = (U8)resp_counter;
                    erab_index < p_failed_erab_list->counter;
                    erab_index++)
            {
                rrc_rrm_erb_release_cnf.erab_error_list.
                    erab_error_info
                    [rrc_rrm_erb_release_cnf.erab_error_list.erab_count]
                    .erab_id = (U8)p_failed_erab_list->erab_item[erab_index].
                    e_RAB_ID;

                rrc_rrm_erb_release_cnf.erab_error_list.
                    erab_error_info
                    [rrc_rrm_erb_release_cnf.erab_error_list.erab_count].
                    error_code = p_failed_erab_list->erab_item[erab_index].
                    error_code;
                rrc_rrm_erb_release_cnf.erab_error_list.erab_count++;
            }
        }

    }
    else if (PARTIAL_SUCCESS == response)
    {
        rrc_rrm_erb_release_cnf.bitmask |=
            RRM_ERB_RELEASE_CNF_CONFIRM_LIST_PRESENT;
        rrc_rrm_erb_release_cnf.bitmask |=
            RRM_ERB_RELEASE_CNF_ERROR_LIST_PRESENT;

        /* find erab id and error code from failed to release
         * list after rrm_erb_release_resp api is received */
        resp_counter = p_ue_context->p_curr_proc_data->u.
            erab_release_command_data.counter_after_rrm_resp;

        /* For ERAB CNF List */
        rrc_rrm_erb_release_cnf.erab_cnf_list.erab_count = 
            p_erab_list->counter;

        /* For ERAB ERROR List */
        rrc_rrm_erb_release_cnf.erab_error_list.erab_count = (U16) 
        (p_failed_erab_list->counter - resp_counter);

        /* fill from release list */
        for (erab_index = 0;
             erab_index < p_erab_list->counter;
             erab_index++)
        {
            rrc_rrm_erb_release_cnf.erab_cnf_list.
                erab_cnf_info[erab_index].erab_id = (U8)
                p_erab_list->erab_item[erab_index].e_RAB_ID;
        }
        /* fill from failed to release list */
        for (erab_index = (U8)resp_counter, index = 0;
             erab_index < p_failed_erab_list->counter;
             erab_index++, index++)
        {
            rrc_rrm_erb_release_cnf.erab_error_list.
                erab_error_info[index].erab_id = (U8)
                p_failed_erab_list->erab_item[erab_index].e_RAB_ID;

            rrc_rrm_erb_release_cnf.erab_error_list.
                erab_error_info[index].error_code =
                p_failed_erab_list->erab_item[erab_index].error_code;
        }
    }
    else
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
            (p_ue_context->p_gb_context)->facility_name,
            RRC_WARNING,
            "RRC_RRM_ERB_RELEASE_CNF:Invalid Response Code ");
    }
    /* SPS Start */
    if ((p_ue_context->m.is_sps_recv_frm_rrm) &&
            (rrc_rrm_erb_release_cnf.response != FAILURE) &&
            !p_ue_context->m.is_sps_setup_or_rel_recv)
    {
        if (p_ue_context->m.sps_config_updated)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_BRIEF, "SPS Configured Successfully");
        }
        else
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_BRIEF, "SPS Not Configured ");
            rrc_rrm_erb_release_cnf.response = RRC_PARTIAL_SUCCESS;
            rrc_rrm_erb_release_cnf.bitmask |= RRC_RRM_ERB_SETUP_CNF_SPS_ERROR_CODE_PRESENT;
            rrc_rrm_erb_release_cnf.error_code = RRM_RRC_SPS_SETUP_FAILED;
        }
    }

    /* SPS Stop */
#ifdef ENDC_ENABLED
    }
#endif



    /* PUP encoding */
    rrc_response = rrc_rrm_il_send_rrc_rrm_erb_release_cnf(
                       &rrc_rrm_erb_release_cnf,
                       RRC_UECC_MODULE_ID,
                       RRC_RRM_MODULE_ID,
                       uecc_ue_ctx_get_op_transction_id(p_ue_context),
                       p_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return rrc_response;
}
/* ERB RELEASE COMMAND END */

/****************************************************************************
 ****************************************************************************
 * Build and Send Functions implementation
 ****************************************************************************
 ****************************************************************************/

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_ue_admission_req
*   INPUT        : uecc_ue_context_t   *p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:    This is the function for building and sending
*                   RRC_RRM_UE_ADMISSION_REQ message to the RRM.
*
*   RETURNS:        None
*
******************************************************************************/
rrc_return_t uecc_rrm_build_and_send_ue_admission_req(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
)
{
    rrc_rrm_ue_admission_req_t      rrc_rrm_ue_admission_req;
    rrc_return_et                   response = RRC_FAILURE;
    /*Coverity_CID_71381_Fix_START*/
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    /*Coverity_CID_71381_Fix_END*/
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
     memset_wrapper(&rrc_rrm_ue_admission_req, RRC_NULL, sizeof(rrc_rrm_ue_admission_req_t));
    /* Fill message */

    /* ue_index */
    rrc_rrm_ue_admission_req.ue_index = p_uecc_ue_context->ue_index;
    

    /* ue_identity */
    rrc_rrm_ue_admission_req.ue_identity = p_uecc_ue_context->rcs_stmsi;

    /* establishment_cause */
    rrc_rrm_ue_admission_req.establishment_cause =
        (U8)(p_uecc_ue_context->rcs_establishmentCause);

    /* CLPC Start */
    rrc_rrm_ue_admission_req.timing_advance = 
        p_uecc_ue_context->timing_advance;

    rrc_rrm_ue_admission_req.sinr = 
        p_uecc_ue_context->sinr;


    /* CLPC Stop */

    /* SPR 19273 Fix Start */
    SET_UE_INDEX(rrc_rrm_ue_admission_req.ue_index);
    /* SPR 19273 Fix End */

    /* Encode and send message */
    response = rrc_rrm_il_send_rrc_rrm_ue_admission_req(
                    &rrc_rrm_ue_admission_req,
                    RRC_UECC_MODULE_ID,
                    RRC_RRM_MODULE_ID,
                    uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context),
                    p_uecc_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_ue_admission_cnf
*   INPUT        : uecc_ue_context_t*  p_uecc_ue_context,
*                  rrc_return_et       rrm_response
*   OUTPUT       : none
*   DESCRIPTION:    This function builds and sends
*                   RRC_RRM_UE_ADMISSION_CNF message to the RRM.
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_ue_admission_cnf
(
    uecc_ue_context_t*  p_uecc_ue_context,
    rrc_return_et       rrm_response
)
{
    rrc_rrm_ue_admission_cnf_t  rrc_rrm_ue_admission_cnf;
    rrc_return_et               response = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&rrc_rrm_ue_admission_cnf, RRC_NULL, sizeof(rrc_rrm_ue_admission_cnf_t));

    rrc_rrm_ue_admission_cnf.ue_index = p_uecc_ue_context->ue_index;
    rrc_rrm_ue_admission_cnf.response = rrm_response;
    /* SPS Start */
    if (p_uecc_ue_context->m.is_sps_recv_frm_rrm && (rrm_response != RRC_FAILURE))
    {
        if (p_uecc_ue_context->m.sps_config_updated)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
            (p_uecc_ue_context->p_gb_context)->facility_name,
            RRC_INFO,
            "SPS Configured Successfully");
        }
        else
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
            (p_uecc_ue_context->p_gb_context)->facility_name,
            RRC_INFO,
            "SPS Not Configured ");
              rrc_rrm_ue_admission_cnf.response = RRC_PARTIAL_SUCCESS;
              rrc_rrm_ue_admission_cnf.bitmask |= RRC_RRM_UE_ADM_CNF_SPS_ERROR_CODE_PRESENT;
              rrc_rrm_ue_admission_cnf.error_code = RRM_RRC_SPS_SETUP_FAILED;
        }
    }
    /* SPS Stop */

    /* SPR 19273 Fix Start */
    SET_UE_INDEX(rrc_rrm_ue_admission_cnf.ue_index);
    /* SPR 19273 Fix End */

    response = rrc_rrm_il_send_rrc_rrm_ue_admission_cnf(
                    &rrc_rrm_ue_admission_cnf,
                    RRC_UECC_MODULE_ID,
                    RRC_RRM_MODULE_ID,
                    uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context),
                    p_uecc_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_erb_setup_req
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds and sends RRC_RRM_ERB_SETUP_REQ message
*       to RRM module (PUP encoding)
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_erb_setup_req(
    uecc_ue_context_t* p_uecc_ue_context)
{
    static rrc_rrm_erb_setup_req_t rrc_rrm_erb_setup_req;

    rrc_return_et rrc_response = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&rrc_rrm_erb_setup_req, 0, sizeof(rrc_rrm_erb_setup_req));

    /* Build message */
    uecc_rrm_build_rrc_rrm_erb_setup_req(
            p_uecc_ue_context,
            &rrc_rrm_erb_setup_req);

        /* PUP encoding */
        rrc_response = rrc_rrm_il_send_rrc_rrm_erb_setup_req(
                &rrc_rrm_erb_setup_req,
                RRC_UECC_MODULE_ID,
                RRC_RRM_MODULE_ID,
                uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context),
                p_uecc_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return rrc_response;
}
/* SPR 16053 Fix Start */
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_ue_reestab_complete_ind
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context
*                  rrc_return_et        response
*   OUTPUT       : none
*   DESCRIPTION:    This is the function for building and sending
*                   RRC_RRM_UE_REESTAB_COMPLETE_IND message to the RRM.
*
*   RETURNS:        None
*
******************************************************************************/
rrc_return_t uecc_rrm_build_and_send_ue_reestab_complete_ind(
        uecc_ue_context_t   *p_uecc_ue_context,      /* UECC UE context */
        rrc_return_et        response
)
{
    rrc_rrm_ue_reestab_complete_ind_t reestab_complete_ind;
    rrc_return_et                     result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_uecc_ue_context);

    memset_wrapper(&reestab_complete_ind,RRC_NULL,sizeof(reestab_complete_ind));
/*SPR 21653 changes start*/
    reestab_complete_ind.cell_index = p_uecc_ue_context->cell_index;
/*SPR 21653 changes end*/
    reestab_complete_ind.ue_index = p_uecc_ue_context->ue_index;
    reestab_complete_ind.response = response;

    result = rrc_rrm_il_send_rrc_rrm_ue_reestab_complete_ind(
                    &reestab_complete_ind,
                    RRC_UECC_MODULE_ID,
                    RRC_RRM_MODULE_ID,
                    RRC_TRANSACTION_ID_ABSENT,
                    p_uecc_ue_context->cell_index
                    );
    
    if (RRC_SUCCESS == result)
    {                
        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,p_uecc_ue_context->
              p_gb_context->facility_name,RRC_INFO,
              "\n RRC Reestablishment Complete indication send to RRM");
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}
/* SPR 16053 Fix Stop */

/* Measurment Re-config START */
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_meas_config_resp
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context
*                  rrc_return_et        response
*                  U32                  error_code
*   OUTPUT       : none
*   DESCRIPTION:    This is the function for building and sending
*                   RRC_RRM_MEAS_CONFIG_RESP message to the RRM.
*
*   RETURNS:        None
*
******************************************************************************/
rrc_return_t uecc_rrm_build_and_send_meas_config_resp(
        uecc_ue_context_t   *p_uecc_ue_context,      /* UECC UE context */
        rrc_return_et        response,
        U32                  error_code
)
{
    rrc_rrm_meas_config_response_t      rrc_rrm_meas_config_response;
    rrc_return_et        result = RRC_FAILURE;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /*reset */
    memset_wrapper(&rrc_rrm_meas_config_response, RRC_NULL,
            sizeof(rrc_rrm_meas_config_response_t));

    /* Fill message */
    /* ue_index */
    rrc_rrm_meas_config_response.ue_index = 
        p_uecc_ue_context->ue_index;
    
    /* response */
    rrc_rrm_meas_config_response.response = response;

    /*fill rrm_cause*/
    if (response == RRC_FAILURE && error_code == RRC_NO_ERROR)
    {
        rrc_rrm_meas_config_response.cause.type = (U8)T_s1ap_Cause_radioNetwork;
        rrc_rrm_meas_config_response.cause.value = (U16)s1ap_unspecified_2;
        rrc_rrm_meas_config_response.bitmask |=
            RRC_RRM_MEAS_CONFIG_RESP_CAUSE_PRESENT;
        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
            p_uecc_ue_context->p_gb_context->facility_name, RRC_INFO,
           "[rrc_rrm_meas_config_response] - Failure with cause"
            "[s1ap_unspecified_2]");
    }
    else if (response == RRC_FAILURE && 
            ((error_code == RRC_RADIO_LINK_FAILURE_TRIGGERED) ||
             (error_code == RRC_REESTABLISHMENT_TRIGGERED)))
    {
        rrc_rrm_meas_config_response.cause.type = (U8)T_s1ap_Cause_radioNetwork;
        rrc_rrm_meas_config_response.cause.value = (U16)s1ap_radio_connection_with_ue_lost;
        rrc_rrm_meas_config_response.bitmask |=
            RRC_RRM_MEAS_CONFIG_RESP_CAUSE_PRESENT;
        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                p_uecc_ue_context->p_gb_context->facility_name, RRC_INFO,
           "[rrc_rrm_meas_config_response] - Failure"
           "with cause s1ap_radio_connection_with_ue_lost");
    }
    else if (response == RRC_FAILURE && error_code == RRC_TIMER_EXPIRY)
    {
        rrc_rrm_meas_config_response.cause.type = (U8)T_s1ap_Cause_radioNetwork;
        rrc_rrm_meas_config_response.cause.value = (U16)s1ap_release_due_to_eutran_generated_reason;
        rrc_rrm_meas_config_response.bitmask |=
            RRC_RRM_MEAS_CONFIG_RESP_CAUSE_PRESENT;
        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                p_uecc_ue_context->p_gb_context->facility_name, RRC_INFO,
           "[rrc_rrm_meas_config_response] - Failure"
           "with cause s1ap_release_due_to_eutran_generated_reason");
    }
    else if(response == RRC_FAILURE && error_code == RRC_RRM_MEAS_CONFIG_ALREADY_ONGOING)
    {
        rrc_rrm_meas_config_response.cause.type = (U8)T_s1ap_Cause_radioNetwork;
        rrc_rrm_meas_config_response.cause.value = (U16)s1ap_interaction_with_other_procedure;
        rrc_rrm_meas_config_response.bitmask |=
            RRC_RRM_MEAS_CONFIG_RESP_CAUSE_PRESENT;
        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                p_uecc_ue_context->p_gb_context->facility_name, RRC_INFO,
           "[rrc_rrm_meas_config_response] - Failure "
           "with cause s1ap_interaction_with_other_procedure");
    }
    else
    {
        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                p_uecc_ue_context->p_gb_context->facility_name, RRC_INFO,
           "[rrc_rrm_meas_config_response] - Success");
    }
    /* Encode and send message */
    result = rrc_rrm_il_send_rrc_rrm_meas_config_response(
                    &rrc_rrm_meas_config_response,
                    RRC_UECC_MODULE_ID,
                    RRC_RRM_MODULE_ID,
                    (p_uecc_ue_context->meas_proc_trans_id),
                    p_uecc_ue_context->cell_index);

#ifdef MEM_PROFILE_ON
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "\n ***************Sizeof UE CONTEXT After  MEASUREMENT CONFIG response is sent");
        qvPoolStats();

#endif

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;
}
/* Measurment Re-config END */

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_rrc_rrm_erb_setup_req
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context
*                  rrc_rrm_erb_setup_req_t* p_rrc_rrm_erb_setup_req
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds RRC_RRM_ERB_SETUP_REQ message
*
*   RETURNS:
*       None
*
******************************************************************************/
void uecc_rrm_build_rrc_rrm_erb_setup_req(
    uecc_ue_context_t* p_uecc_ue_context,
    rrc_rrm_erb_setup_req_t* p_rrc_rrm_erb_setup_req)
{
    rrc_counter_t drb_index = 0;
    rrm_erab_level_qos_params_t *p_rrm_erab_level_qos_params=PNULL;

    /* ICS START */

    rrc_counter_t drb_index_counter = 0;
    U8 e_rab_id          = 0;

    /* ICS STOP */
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_rrm_erb_setup_req);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Fill RRC_RRM_ERB_SETUP_REQ API from RRC_S1AP_INITIAL_CTX_SETUP_IND API */
    p_rrc_rrm_erb_setup_req->ue_index = p_uecc_ue_context->ue_index;
    
    if( p_uecc_ue_context->m.ue_agg_max_bit_rate_updated )
    {
        p_rrc_rrm_erb_setup_req->bitmask = 
            RRC_RRM_ERB_SETUP_REQ_UE_AGG_MAX_BIT_RATE_PRESENT;
    p_rrc_rrm_erb_setup_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul =
           p_uecc_ue_context->ue_aggregate_maximum_bitrate.
        uEaggregateMaximumBitRateUL;

    p_rrc_rrm_erb_setup_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl =
           p_uecc_ue_context->ue_aggregate_maximum_bitrate.
        uEaggregateMaximumBitRateDL;
        
    }

    #ifdef ENDC_ENABLED
    if( p_uecc_ue_context->m.ext_ue_agg_max_bit_rate_updated )
    {
        p_rrc_rrm_erb_setup_req->bitmask = 
            RRC_RRM_EXT_UE_AGG_MAX_BITRATE_PRESENT;

        p_rrc_rrm_erb_setup_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ext.
            ext_ue_agg_max_bit_rate_ul =
            p_uecc_ue_context->ue_aggregate_maximum_bitrate.
            uEaggregateMaximumBitRateULExt;

        p_rrc_rrm_erb_setup_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ext.
            ext_ue_agg_max_bit_rate_dl =
            p_uecc_ue_context->ue_aggregate_maximum_bitrate.
            uEaggregateMaximumBitRateDLExt;
    }
    #endif
    /* ICS START */

    drb_index_counter = p_uecc_ue_context->p_curr_proc_data->u.
        erab_setup_request_data.erab_info_data.count;

    /* Fill No. of ERAB item present */
    p_rrc_rrm_erb_setup_req->erab_to_be_setup_item_list.num_of_list = 
        drb_index_counter;

    /* SPR 17022 Fix Start */
    memset_wrapper(&p_uecc_ue_context->erab_info_temp, RRC_NULL, sizeof(rrc_temp_erb_info_t));

    p_uecc_ue_context->erab_info_temp.count = drb_index_counter; 
    /* SPR 17022 Fix Stop */

    /* ICS STOP */
    /* Fill E_RAB Info received from MME */ 
    for( drb_index = 0; drb_index < drb_index_counter; drb_index++ )
    {
        e_rab_id = p_uecc_ue_context->p_curr_proc_data->u.
            erab_setup_request_data.erab_info_data.erab_info[drb_index].
                erab_id;

	/* SPR 17022 Fix Start */
	p_uecc_ue_context->erab_info_temp.erab_info[drb_index].erab_id = 
	    p_uecc_ue_context->p_curr_proc_data->u.erab_setup_request_data.
	    erab_info_data.erab_info[drb_index].erab_id;
        /* SPR 17022 Fix Stop */

        p_rrc_rrm_erb_setup_req->erab_to_be_setup_item_list.
        erab_to_be_setup_item[drb_index].erab_id = e_rab_id;
                                                     
        p_rrm_erab_level_qos_params=
            &p_rrc_rrm_erb_setup_req->erab_to_be_setup_item_list.
            erab_to_be_setup_item[drb_index].erab_level_qos_params;

        /* qci */
        p_rrm_erab_level_qos_params->qci =
           p_uecc_ue_context->p_e_rab_list[e_rab_id]->e_RABlevelQoSParameters.qCI;

        /* alloc_and_reten_prior */
        p_rrm_erab_level_qos_params->alloc_and_reten_prior.priority_level =
            p_uecc_ue_context->p_e_rab_list[e_rab_id]->e_RABlevelQoSParameters.
            allocationRetentionPriority.priorityLevel;

        p_rrm_erab_level_qos_params->alloc_and_reten_prior.
            preemption_capability=
            (U8)(p_uecc_ue_context->p_e_rab_list[e_rab_id]->e_RABlevelQoSParameters.
            allocationRetentionPriority.pre_emptionCapability);

        p_rrm_erab_level_qos_params->alloc_and_reten_prior.
            preemption_vulnerability=
            (U8)(p_uecc_ue_context->p_e_rab_list[e_rab_id]->e_RABlevelQoSParameters.
            allocationRetentionPriority.pre_emptionVulnerability);

        /* gbr_qos_info */
        if(0!=p_uecc_ue_context->p_e_rab_list[e_rab_id]->
                e_RABlevelQoSParameters.m.gbrQosInformationPresent)
        {
            p_rrm_erab_level_qos_params->bitmask |=
                ERAB_LEVEL_QOS_PARAM_GBR_QOS_INFO_PRESENT;

            p_rrm_erab_level_qos_params->gbr_qos_info.erab_guar_bit_rate_dl =
              (U32) p_uecc_ue_context->p_e_rab_list[e_rab_id]->e_RABlevelQoSParameters.
               gbrQosInformation.e_RAB_GuaranteedBitrateDL;

            p_rrm_erab_level_qos_params->gbr_qos_info.erab_guar_bit_rate_ul =
               (U32)p_uecc_ue_context->p_e_rab_list[e_rab_id]->e_RABlevelQoSParameters.
               gbrQosInformation.e_RAB_GuaranteedBitrateUL;

            p_rrm_erab_level_qos_params->gbr_qos_info.erab_max_bit_rate_dl=
               (U32)p_uecc_ue_context->p_e_rab_list[e_rab_id]->e_RABlevelQoSParameters.
               gbrQosInformation.e_RAB_MaximumBitrateDL;

            p_rrm_erab_level_qos_params->gbr_qos_info.erab_max_bit_rate_ul=
               (U32)p_uecc_ue_context->p_e_rab_list[e_rab_id]->e_RABlevelQoSParameters.
               gbrQosInformation.e_RAB_MaximumBitrateUL;
        }
        /* lipa start */
        if(0 != p_uecc_ue_context->p_e_rab_list[e_rab_id]->m.Lipa_RabPresent
                      &&
           PNULL != p_uecc_ue_context->p_e_rab_list[e_rab_id]->correlation_id)
        {
            p_rrc_rrm_erb_setup_req->erab_to_be_setup_item_list.
              erab_to_be_setup_item[drb_index].bitmask |= 
                     ERAB_TO_BE_SETUP_LIPA_RAB_IND_PRESENT_FLAG;
            
            p_rrc_rrm_erb_setup_req->erab_to_be_setup_item_list.
               erab_to_be_setup_item[drb_index].lipa_rab_ind = RRC_TRUE;

        }
        /* lipa end */
    }

/* SPR #5597 Fix start */
    if(p_uecc_ue_context->m.ho_restriction_list_present)
    {
        p_rrc_rrm_erb_setup_req->bitmask |=
                RRC_RRM_ERB_SETUP_REQ_HO_RESTRICTION_LIST_PRESENT;
/* SPR #5597 Fix end */
        if (RRC_FAILURE == process_fill_ho_restriction_list(
                        p_uecc_ue_context,
                        &p_rrc_rrm_erb_setup_req->ho_restriction_list,
                        &p_uecc_ue_context->ics_handover_restriction_list))
        {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                               (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_WARNING,
                               "process_fill_ho_restriction_list failed");
                return;
        }
/* SPR #5597 Fix start */           
    }
/* SPR #5597 Fix end */   
    if(p_uecc_ue_context->m.registered_lai_present)
    {
        p_rrc_rrm_erb_setup_req->bitmask |=
                            RRC_RRM_ERB_SETUP_REQ_REGISTERED_LAI_PRESENT;
    
        p_rrc_rrm_erb_setup_req->registered_lai.plmn_identity.num =
                p_uecc_ue_context->p_registered_lai->plmn_identity.num;
    
        l3_memcpy_wrapper(&p_rrc_rrm_erb_setup_req->registered_lai.plmn_identity.data,
                    p_uecc_ue_context->p_registered_lai->plmn_identity.data,
                    p_uecc_ue_context->p_registered_lai->plmn_identity.num);
        
        p_rrc_rrm_erb_setup_req->registered_lai.lac.num = 
                p_uecc_ue_context->p_registered_lai->lac.num;

        l3_memcpy_wrapper(&p_rrc_rrm_erb_setup_req->registered_lai.lac.data,
                    p_uecc_ue_context->p_registered_lai->lac.data,
                    p_uecc_ue_context->p_registered_lai->lac.num);
     }

    if (p_uecc_ue_context->m.CsfallbackIndicator)
    {
        p_rrc_rrm_erb_setup_req->bitmask |=
            RRC_RRM_ERB_SETUP_REQ_CSF_INDICATOR_PRESENT;
        p_rrc_rrm_erb_setup_req->csf_indicator =
            (U8)p_uecc_ue_context->cs_fallback_indicator;

        /* Reset Variables */
     //   p_uecc_ue_context->m.CsfallbackIndicator = RRC_FALSE;
    }
    
    if (p_uecc_ue_context->m.SpId)
    {
        p_rrc_rrm_erb_setup_req->bitmask |=
            RRC_RRM_ERB_SETUP_REQ_SUB_PROFILE_ID_PRESENT;
        p_rrc_rrm_erb_setup_req->sub_profile_id =
            p_uecc_ue_context->spid;

        #ifndef ENDC_ENABLED
        /* Reset Variables */
        p_uecc_ue_context->m.SpId = RRC_FALSE;
        #endif
    }

    if (p_uecc_ue_context->m.SrvccOP)
    {
        p_rrc_rrm_erb_setup_req->bitmask |=
            RRC_RRM_ERB_SETUP_REQ_SRVCC_HO_OP_POSSIBLE_PRESENT;
        /* srvcc-u start */
        p_rrc_rrm_erb_setup_req->srvcc_ho_op_possible = RRC_TRUE;
        /* srvcc-u end */

        /* Reset Variables */
        p_uecc_ue_context->m.SrvccOP = RRC_NULL;
        p_uecc_ue_context->srvcc_operation_possible = RRC_NULL;
    }

    if (p_uecc_ue_context->m.CsgMembershipStatus)
    {
        p_rrc_rrm_erb_setup_req->bitmask |=
            RRC_RRM_ERB_SETUP_REQ_CSG_MEM_STATUS;
        p_rrc_rrm_erb_setup_req->csg_mem_status =
            (U8)p_uecc_ue_context->csg_membership_status;

        /* Reset Variables */
        //p_uecc_ue_context->m.CsgMembershipStatus = RRC_NULL;
        //p_uecc_ue_context->csg_membership_status = RRC_NULL;
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_erb_setup_conf
*   INPUT        : uecc_ue_context_t*  p_ue_context,
*                  rrc_response_et       response
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds and sends RRC_RRM_ERB_SETUP_CNF message
*       with failure to RRM module
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_erb_setup_conf(
    uecc_ue_context_t*  p_ue_context)
{
    U8 drb_index     = 0;
    U8 erab_id_count = 0;
    U8 error_list_count = 0;
    U8 succ_list_count  = 0;
    U8 fail_list_count = 0;
    rrc_return_et              rrc_response = RRC_FAILURE;
    rrc_rrm_erb_setup_cnf_t    rrc_rrm_erb_setup_cnf;
    uecc_rm_erab_setup_info_t* p_erab_setup_list = PNULL;
    uecc_erab_failed_to_setup_list_t  *p_erab_failed_list = PNULL;
    /* ARP changes begin */
    erab_list_t*            p_erab_list = PNULL;
    rrm_erab_release_cnf_list_t *p_rel_cnf_list = PNULL;
    erab_list_t*    p_erab_failed_to_rel_list = PNULL;

    /* ARP changes stop */
    /* mme grp id feature changes start */
    S8* s_id = PNULL;
    /* mme grp id feature changes stop */

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    p_erab_setup_list =&(p_ue_context->
        p_curr_proc_data->u.erab_setup_request_data.erab_info_data);   

    p_erab_failed_list =&(p_ue_context->
        p_curr_proc_data->u.erab_setup_request_data.failed_erab_data);   

    /* ARP changes begin */

    p_erab_list = &(p_ue_context->p_curr_proc_data->u.erab_setup_request_data.
        erab_release_command_data.erab_release_list);

    p_erab_failed_to_rel_list = &(p_ue_context->p_curr_proc_data->u.erab_setup_request_data.
        erab_release_command_data.erab_failed_to_release_list);

    /* ARP changes stop */


    /* Memset ERB SETUP CNF msg to 0 */
    memset_wrapper(&rrc_rrm_erb_setup_cnf, 0, sizeof(rrc_rrm_erb_setup_cnf));

    /* Set UE Index */
    rrc_rrm_erb_setup_cnf.ue_index = p_ue_context->ue_index;
    

    if ( PNULL != p_erab_setup_list )
    {
    /* Get Count of Temp ERAB SETUP List in UE Context */ 
    erab_id_count = p_erab_setup_list->count;
   
    /* Clear Bitmask to 0 */
    rrc_rrm_erb_setup_cnf.bitmask = 0;

    /* Set Response Code i.e. SUCCESS, PARTIAL_SUCCESS or FAILURE */ 
    rrc_rrm_erb_setup_cnf.response_code = p_erab_setup_list->outerResponse;

    /* Set Success and Error List */ 
    for (drb_index = 0; drb_index < erab_id_count; drb_index++)
    {
        /* Set E_RAB ID in Error List With Error Code */
        if (RRC_NO_ERROR != p_erab_setup_list->erab_info[drb_index].
            status) 
        {
            rrc_rrm_erb_setup_cnf.erab_error_list.erab_error_info
                [error_list_count].erab_id = p_erab_setup_list->erab_info
                [drb_index].erab_id;
            rrc_rrm_erb_setup_cnf.erab_error_list.erab_error_info
                [error_list_count].error_code = p_erab_setup_list->erab_info
                [drb_index].status; 
            error_list_count++;  
        }
        else
        {
            /* Set E_RAB ID in Success List */
            rrc_rrm_erb_setup_cnf.erab_cnf_list.erab_cnf_info
                [succ_list_count].erab_id = p_erab_setup_list->erab_info
                [drb_index].erab_id; 
            ++succ_list_count;
        }
    }

    /* Set Bitmask in ERB CNF msg */
    if (SUCCESS == p_erab_setup_list->outerResponse)
    {
        rrc_rrm_erb_setup_cnf.bitmask |= 
            RRC_RRM_ERB_SETUP_CNF_ERAB_CNF_LIST_PRESENT;
    }
    else if (PARTIAL_SUCCESS == p_erab_setup_list->outerResponse)
    {
        rrc_rrm_erb_setup_cnf.bitmask |= 
            RRC_RRM_ERB_SETUP_CNF_ERAB_CNF_LIST_PRESENT;
        rrc_rrm_erb_setup_cnf.bitmask |= 
            RRC_RRM_ERB_SETUP_CNF_ERAB_ERROR_LIST_PRESENT;
    }
    else
    { 
        rrc_rrm_erb_setup_cnf.bitmask |= 
            RRC_RRM_ERB_SETUP_CNF_ERAB_ERROR_LIST_PRESENT;          
    }

    /*BUG7931 FIX START*/
    if(0 == p_erab_failed_list->count)
    {
        for (drb_index = 0; drb_index < erab_id_count; drb_index++)
        {
            rrc_rrm_erb_setup_cnf.erab_error_list.erab_error_info
                [error_list_count].erab_id = p_erab_setup_list->erab_info
                [drb_index].erab_id;

            rrc_rrm_erb_setup_cnf.erab_error_list.erab_error_info
                [error_list_count].error_code = p_erab_setup_list->erab_info
                [drb_index].status;

            uecc_fill_response_code (
                    &rrc_rrm_erb_setup_cnf.erab_error_list.erab_error_info
                    [error_list_count].error_code, RRC_MODULE_ID,
                    RRC_LLIM_RECONFIG_FAILURE);

            error_list_count++;
        }
    }
    /*BUG7931 FIX STOP*/

    /*QOS changes start*/
    for (fail_list_count = 0; fail_list_count < 
         p_erab_failed_list->count && error_list_count < MAX_LC_COUNT;
         fail_list_count++)
    {
        if  ((BEARER_TYPE_QOS_FAILURE == p_erab_failed_list->
            erab_failed_to_setup_item[fail_list_count].qos_status) &&
                (MAX_LC_COUNT > error_list_count))
        {
            /* setting the bitmask for error list*/
            rrc_rrm_erb_setup_cnf.bitmask |= 
                RRC_RRM_ERB_SETUP_CNF_ERAB_ERROR_LIST_PRESENT;          
            /* Filling the failed erab list failed by L3*/
            rrc_rrm_erb_setup_cnf.erab_error_list.erab_error_info
                [error_list_count].erab_id = (U8)p_erab_failed_list->
                erab_failed_to_setup_item[fail_list_count].e_RAB_ID;

            /* Filling the error code,*/
            uecc_fill_response_code (
            &rrc_rrm_erb_setup_cnf.erab_error_list.erab_error_info
            [error_list_count].error_code, RRC_MODULE_ID, 
            RRC_UECC_INVALID_QOS_COMBINATION);
            error_list_count++;  
        }
        else
        {
            /* setting the bitmask for error list*/
            rrc_rrm_erb_setup_cnf.bitmask |= 
                RRC_RRM_ERB_SETUP_CNF_ERAB_ERROR_LIST_PRESENT;          

            /* Filling the error code,*/
            uecc_fill_response_code (
            &rrc_rrm_erb_setup_cnf.erab_error_list.erab_error_info
                [error_list_count].error_code,RRC_MODULE_ID,
                RRC_INTERNAL_ERROR);
        }
    }
    /*Updatinf the response code tobe sento to RRM*/
    if ((RRC_RRM_ERB_SETUP_CNF_ERAB_ERROR_LIST_PRESENT | 
         RRC_RRM_ERB_SETUP_CNF_ERAB_CNF_LIST_PRESENT) ==
        (rrc_rrm_erb_setup_cnf.bitmask))
    {
        rrc_rrm_erb_setup_cnf.response_code = PARTIAL_SUCCESS;
    }
    /*QOS changes end*/

    /* Set Count of ERAB ERROR List */
    rrc_rrm_erb_setup_cnf.erab_error_list.erab_count = error_list_count;

    /* Set Count of Success List */
    rrc_rrm_erb_setup_cnf.erab_cnf_list.erab_count = succ_list_count;
    
    /* ICS STOP */

    /* ARP changes begin */

    p_rel_cnf_list = &rrc_rrm_erb_setup_cnf.erab_rel_cnf_list;

    if (p_erab_list->counter > RRC_NULL)
    {
        rrc_rrm_erb_setup_cnf.bitmask |=
            RRC_RRM_ERB_SETUP_CNF_ERAB_REL_CNF_LIST_PRESENT;

        for(drb_index = 0;
            drb_index < p_erab_list->counter;
            drb_index++)
        {
                /* Fill in success cnf list */
                p_rel_cnf_list->erab_cnf_list.erab_cnf_info[drb_index].
                    erab_id =  
                    p_erab_list->erab_item[drb_index].e_RAB_ID;
        }
        p_rel_cnf_list->erab_cnf_list.erab_count = p_erab_list->counter;
    }

    if (p_erab_failed_to_rel_list->counter > RRC_NULL)
    {
        rrc_rrm_erb_setup_cnf.bitmask |=
            RRC_RRM_ERB_SETUP_CNF_ERAB_REL_CNF_LIST_PRESENT;

        for(drb_index = 0;
            drb_index < p_erab_failed_to_rel_list->counter;
            drb_index++)
        {

                /* Fill in error cnf list */
                p_rel_cnf_list->erab_error_list.erab_error_info[drb_index].erab_id = 
                    p_erab_failed_to_rel_list->erab_item[drb_index].e_RAB_ID;

                p_rel_cnf_list->erab_error_list.erab_error_info[drb_index].error_code= 
                    p_erab_failed_to_rel_list->erab_item[drb_index].error_code;
        }
        p_rel_cnf_list->erab_error_list.erab_count = p_erab_failed_to_rel_list->counter;
    }

    if (RRC_RRM_ERB_SETUP_CNF_ERAB_REL_CNF_LIST_PRESENT &
            rrc_rrm_erb_setup_cnf.bitmask)
    {
        if (p_rel_cnf_list->erab_cnf_list.erab_count > RRC_NULL)
        {
            p_rel_cnf_list->bitmask |=
                RRC_RRM_ERB_REL_CNF_ERAB_CNF_LIST_PRESENT;
        }
        if (p_rel_cnf_list->erab_error_list.erab_count > RRC_NULL)
        {
            p_rel_cnf_list->bitmask |=
                RRC_RRM_ERB_REL_CNF_ERAB_ERROR_LIST_PRESENT;
        }
    }

    /* ARP changes end */

    /* SPS Start */
    if ((p_ue_context->m.is_sps_recv_frm_rrm) && 
            (rrc_rrm_erb_setup_cnf.response_code != RRC_FAILURE) &&
             !p_ue_context->m.is_sps_setup_or_rel_recv)
    {
        if (p_ue_context->m.sps_config_updated)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_BRIEF, "SPS Configured Successfully");
        }
        else
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_BRIEF, "SPS Not Configured ");
            rrc_rrm_erb_setup_cnf.response_code = RRC_PARTIAL_SUCCESS;
            rrc_rrm_erb_setup_cnf.bitmask |= RRC_RRM_ERB_SETUP_CNF_SPS_ERROR_CODE_PRESENT;
            rrc_rrm_erb_setup_cnf.error_code = RRM_RRC_SPS_SETUP_FAILED;
        }
    }
    /* SPS Stop */
    /* mme grp id feature changes start */
    if (PNULL != p_ue_context->uecc_fsm.proc_descriptor.p_active_proc)
    {
        s_id = p_ue_context->uecc_fsm.proc_descriptor.p_active_proc->s_id;
    }
    if ((PNULL != s_id) && 
            !(strncmp_wrapper((const S8 *)s_id,(const S8 *)"UE_ICS_P",
                    strlen_wrapper((const Char8*)s_id))))
    {
        if (RRC_TRUE == p_ue_context->m.source_gummei_present)
        {
            rrc_rrm_erb_setup_cnf.bitmask |= 
                RRC_RRM_ERB_SETUP_CNF_GUMMEI_INFO_PRESENT;

            uecc_s1ap_generate_plmn_identity_to_int(
                    &(rrc_rrm_erb_setup_cnf.gummei_info.plmn_identity),
                    p_ue_context->gummei.plmn_identity.data);

            l3_memcpy_wrapper(((void*)rrc_rrm_erb_setup_cnf.gummei_info.
                        mme_group_id),((const void*)&p_ue_context->
                            gummei.grp_id.data),MAX_MME_GRP_BYTES);

            l3_memcpy_wrapper(((void*)&rrc_rrm_erb_setup_cnf.gummei_info.mmec),
                    ((const void*)&p_ue_context->gummei.mme_code.data),
                    sizeof(U8));
        }
        /* SPR 16477 Fix Start */
        /* Code Removed */
        /* SPR 16477 Fix Stop */

        /* SPR_21459 Fix - Start */
        /* Fill MME ID in case ICS procedure */
        rrc_rrm_erb_setup_cnf.bitmask |=
            RRC_RRM_ERB_SETUP_CNF_MME_ID_PRESENT;
        rrc_rrm_erb_setup_cnf.mme_id = p_ue_context->mme_id;
        /* SPR_21459 Fix - End */
    }
    /* mme grp id feature changes stop */

    /* PUP encoding */
    rrc_response = rrc_rrm_il_send_rrc_rrm_erb_setup_cnf(
        &rrc_rrm_erb_setup_cnf,
        RRC_UECC_MODULE_ID,
        RRC_RRM_MODULE_ID,
        uecc_ue_ctx_get_op_transction_id(p_ue_context),
        p_ue_context->cell_index);
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return rrc_response;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_ue_release_req
*   INPUT        : uecc_ue_context_t*  p_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds and sends RRC_RRM_UE_RELEASE_REQ message
*       with failure to RRM module
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_ue_release_req(
    uecc_ue_context_t*  p_ue_context)
{
    rrc_return_et               response = RRC_FAILURE;
    rrc_rrm_ue_release_req_t    rrc_rrm_ue_release_req;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&rrc_rrm_ue_release_req, 0, sizeof(rrc_rrm_ue_release_req_t));

    /* Fill message */
    rrc_rrm_ue_release_req.ue_index = p_ue_context->ue_index;
    
    /* SPR 11316 Fix Start */
    if (  (T_s1ap_Cause_radioNetwork == p_ue_context->
                share_data.uecc_rcr_data.u.cause.t) && 
          ( (s1ap_handover_cancelled == p_ue_context->
              share_data.uecc_rcr_data.u.cause.u.radioNetwork) ||
            (s1ap_ho_failure_in_target_EPC_eNB_or_target_system ==
              p_ue_context->share_data.uecc_rcr_data.u.cause.u.radioNetwork) ) )
    {
        rrc_rrm_ue_release_req.bitmask |= RRC_RRM_UE_RELEASE_CAUSE_PRESENCE_FLAG;
        rrc_rrm_ue_release_req.cause.type = p_ue_context->
                                share_data.uecc_rcr_data.u.cause.t;
        rrc_rrm_ue_release_req.cause.value = p_ue_context->
                                share_data.uecc_rcr_data.u.cause.u.radioNetwork;
    }
    /* SPR 11316 Fix Stop */ 

    /* PUP encode and send */
    response = rrc_rrm_il_send_rrc_rrm_ue_release_req(
        &rrc_rrm_ue_release_req,
        RRC_UECC_MODULE_ID,
        RRC_RRM_MODULE_ID,
        uecc_ue_ctx_get_op_transction_id(p_ue_context),
        p_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return response;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_ue_capability_info
*   INPUT        : uecc_ue_context_t               *p_ue_context
*                  UECapabilityInformation *p_UECapabilityInformation
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds and sends RRC_RRM_UE_CAPABILITY_ENQUIRY_RESP message
*       with success/failure to RRM module
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_ue_capability_info(
    uecc_ue_context_t               *p_ue_context,      /* UECC UE context */
    UECapabilityInformation *p_UECapabilityInformation
)
{
    OSRTDListNode*      p_node = PNULL;
    /* SPR 13502 Fix Start */
    rrc_rrm_ue_capability_enquiry_resp_t *p_rrc_rrm_ue_capability_enquiry_resp = PNULL;
    rrc_rrm_ue_capability_ind_t *p_rrc_rrm_ue_capability_ind = PNULL;
    rrc_return_et       result = RRC_FAILURE;
    U8 i = 0;
    UE_CapabilityRAT_Container *p_UE_CapabilityRAT_Container = PNULL;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_UECapabilityInformation);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    p_rrc_rrm_ue_capability_enquiry_resp = (rrc_rrm_ue_capability_enquiry_resp_t *)rrc_mem_get
                                  (sizeof(rrc_rrm_ue_capability_enquiry_resp_t));
    if (PNULL == p_rrc_rrm_ue_capability_enquiry_resp)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,
                "Memory Allocation Failure.");
        return RRC_FAILURE;
    }
    /* SES-508 Fix Start */
    /* Code Removed */
    /* SES-508 Fix End */

    p_rrc_rrm_ue_capability_ind = (rrc_rrm_ue_capability_ind_t *)rrc_mem_get
                                  (sizeof(rrc_rrm_ue_capability_ind_t));
    if (PNULL == p_rrc_rrm_ue_capability_ind)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,
                "Memory Allocation Failure.");
	    /* Coverity Fix 83399 Start */
        rrc_mem_free (p_rrc_rrm_ue_capability_enquiry_resp);
        p_rrc_rrm_ue_capability_enquiry_resp = PNULL;
        RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
	    /* Coverity Fix 83399 Stop */
        return RRC_FAILURE;
    }
    /* SES-508 Fix Start */
    /* Code Removed */
    /* SES-508 Fix End */
    
    do
    {
        if(p_ue_context->rrm_ue_capability_enq_ind)
        {
            p_rrc_rrm_ue_capability_enquiry_resp->bitmask = 0x0;
            
            p_rrc_rrm_ue_capability_enquiry_resp->ue_Index = p_ue_context->ue_index;
            p_rrc_rrm_ue_capability_enquiry_resp->result = RRC_SUCCESS;
            p_rrc_rrm_ue_capability_enquiry_resp->bitmask |= RADIO_CAPABILITY_INFO_PRESENT;
        }
        else
        {
            p_rrc_rrm_ue_capability_ind->ue_Index = p_ue_context->ue_index;
        }
        if( (p_UECapabilityInformation->criticalExtensions.u.c1->
                u.ueCapabilityInformation_r8->ue_CapabilityRAT_ContainerList.count < 1) ||
                (p_UECapabilityInformation->criticalExtensions.u.c1->
                u.ueCapabilityInformation_r8->ue_CapabilityRAT_ContainerList.count > MAX_RAT_CAPABILITY))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_and_send_ue_capability_info wrong list count [%u]",
                p_UECapabilityInformation->criticalExtensions.u.c1->
                u.ueCapabilityInformation_r8->ue_CapabilityRAT_ContainerList.count);
            result = RRC_FAILURE;
            break;
        }

        p_node = p_UECapabilityInformation->criticalExtensions.u.c1->
                u.ueCapabilityInformation_r8->ue_CapabilityRAT_ContainerList.head;

        /* TRACE_fix */
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);


	/*SPR 15896 Fix Start*/
        if (p_ue_context->m.traceActivated)
        {
	       /*SPR 15875 Fix Start*/
	    if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
			    (p_ue_context->p_ue_trace_activation_info != PNULL) &&
			    (p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & UU) &&
			    ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
			    (MEDIUM == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
			    (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
			    (MINIMUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
	    {
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), GEN_MME,"\n <msg function=\"Uu\" name=\"UE CAPABILITY INFO\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
				    difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
	    }
	    if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
			    (p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
			    (p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & UU) &&
			    ((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
			    (MEDIUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
			    (MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
			    (MINIMUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
	    {
                    P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(), GEN_CELL,"\n <msg function=\"Uu\" name=\"UE CAPABILITY INFO\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
				    difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
	    }
	 /*SPR 15896 Fix Stop*/
	       /*SPR 15875 Fix Stop*/
        }
        /* TRACE_fix */

        for(i=0 ; i < p_UECapabilityInformation->criticalExtensions.u.c1->
                u.ueCapabilityInformation_r8->ue_CapabilityRAT_ContainerList.count ; i++)
        {
            p_UE_CapabilityRAT_Container = (UE_CapabilityRAT_Container *)(p_node->data);

	    /*SPR 15896 Fix Start*/
            if (p_ue_context->m.traceActivated)
            {
                /* TRACE_fix */ 
                if (PNULL != p_UE_CapabilityRAT_Container)

                {    
                    /* SPR:7355 start */
                    P_RRC_TRACE(p_ue_context,set_minimum_medium_both_bitmask(),UU,"\n <ie name=\"RAT TYPE\">%d</ie>",
                            p_UE_CapabilityRAT_Container->rat_Type);
	    /*SPR 15896 Fix Stop*/
                    /* SPR:7355 stop */
                }
                /* TRACE_fix */
            }

            if(RRC_TRUE == p_ue_context->rrm_ue_capability_enq_ind)
            {
                /*Klockwork Fix*/
                if( PNULL != p_node->data )
                {
                    /* building rat capability -- rrc_rrm_ue_capability_enquiry_resp */
                    result = uecc_rrm_build_ue_rat_capability(
                            p_ue_context,
                            &p_rrc_rrm_ue_capability_enquiry_resp->radio_capability_info,
                            p_node->data);
                    p_ue_context->m.access_stratum_release = 1;

                    if(result)
                    {
                        result = (rrc_return_et)uecc_save_ue_rat_capability(p_ue_context,p_node->data);
                    }
                    else
                    {
                        break;
                    }
                }/*Klockwork Fix*/
            }
            if(RRC_FALSE == p_ue_context->rrm_ue_capability_enq_ind)
            {
                /*Klockwork Fix*/
                if( PNULL != p_node->data )
                {
                    /* building rat capability -- rrc_rrm_ue_capability_ind_t */
                    result = uecc_rrm_build_ue_rat_capability(p_ue_context,
                            &p_rrc_rrm_ue_capability_ind->radio_capability_info,p_node->data);             
                    p_ue_context->m.access_stratum_release = 1;

                    if(result)
                    {
                        result = (rrc_return_et)uecc_save_ue_rat_capability(p_ue_context,p_node->data);
                    }
                    else
                    {
                        break;
                    }
                }/*Klockwork Fix*/
            }
            if(RRC_FAILURE == result)
            {
                p_ue_context->m.access_stratum_release = 0;
                result = uecc_rrm_build_and_send_failure_ue_capability_info_to_rrm(p_ue_context);
                if(RRC_SUCCESS != result)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[uecc_rrm_build_ue_rat_capability] failure message not sent to RRM.");
                }
                result = RRC_FAILURE;

                uecc_fsm_rrm_ue_capability_enq_stop_timer(p_ue_context);    /* stopping the timer */
                
                break;
            }

            p_node = p_node->next;
        }
        /* TRACE_fix */
	/*SPR 15896 Fix Start*/
        if ( p_ue_context->m.traceActivated)
        {    
            P_RRC_TRACE(p_ue_context, set_minimum_medium_both_bitmask(),UU,"\n </msg>");
	/*SPR 15896 Fix Stop*/
        }
        /* TRACE_fix */

    }   while(0);

    if(result && (RRC_TRUE == p_ue_context->rrm_ue_capability_enq_ind))
    {
        result = rrc_rrm_il_send_rrc_rrm_ue_capability_enquiry_resp(
                    p_rrc_rrm_ue_capability_enquiry_resp,
                    RRC_UECC_MODULE_ID,
                    RRC_RRM_MODULE_ID,
                    /*SPR_17893_START*/
                    p_ue_context->ue_capability_transaction_id,
                    p_ue_context->cell_index);
                    /*SPR_17893_END*/

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
             (p_ue_context->p_gb_context)->facility_name,
             RRC_INFO,"API:RRC->RRM:RRC_RRM_UE_CAPABILITY_ENQUIRY_RESP:[UE:%u] with result:%u",
             p_rrc_rrm_ue_capability_enquiry_resp->ue_Index, p_rrc_rrm_ue_capability_enquiry_resp->result);

        uecc_fsm_rrm_ue_capability_enq_stop_timer(p_ue_context);    /* stopping the timer */
        if ( (p_rrc_rrm_ue_capability_enquiry_resp->radio_capability_info.eutra_radio_capability_info.
                eutra_radio_capability_info_def.ue_category >= 1) &&
           (p_rrc_rrm_ue_capability_enquiry_resp->radio_capability_info.eutra_radio_capability_info.
                eutra_radio_capability_info_def.ue_category <= 5) )
        {
          /* Set the UE Category in UE Context */
          p_ue_context->ue_category = p_rrc_rrm_ue_capability_enquiry_resp->
                                    radio_capability_info.eutra_radio_capability_info.
                                    eutra_radio_capability_info_def.ue_category;
        }
        if(  (p_rrc_rrm_ue_capability_enquiry_resp->radio_capability_info.eutra_radio_capability_info.
                bitmask & UE_EUTRA_CAPABILITY_V920_IES_PRESENT ) &&
            (p_rrc_rrm_ue_capability_enquiry_resp->radio_capability_info.eutra_radio_capability_info.
               ue_eutra_capability_v920_ies.bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT ) &&
            (p_rrc_rrm_ue_capability_enquiry_resp->radio_capability_info.eutra_radio_capability_info.
               ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.bitmask & 
               RRC_RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT ) &&
            (p_rrc_rrm_ue_capability_enquiry_resp->radio_capability_info.eutra_radio_capability_info.
               ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.bitmask & 
               RRC_RRM_UE_EUTRA_CAPABILITY_V1020_UE_CATEGORY_PRESENT ) &&
            ( (p_rrc_rrm_ue_capability_enquiry_resp->radio_capability_info.eutra_radio_capability_info.
                ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                ue_category_v1020 >= 6) &&
           (p_rrc_rrm_ue_capability_enquiry_resp->radio_capability_info.eutra_radio_capability_info.
                ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                ue_category_v1020 <= 8) ) )
        {
          /* Set the REL 10 UE Category in UE Context */
          p_ue_context->rel10_ue_category = p_rrc_rrm_ue_capability_enquiry_resp->
                                    radio_capability_info.eutra_radio_capability_info.
                                    ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                    ue_eutra_capability_v1020_ies.ue_category_v1020;
          p_ue_context->m.rel10_ue_category_present = RRC_TRUE;
        }
    }
    if(result && (RRC_FALSE == p_ue_context->rrm_ue_capability_enq_ind))
    {
        result = rrc_rrm_il_send_rrc_rrm_ue_capability_ind(
                    p_rrc_rrm_ue_capability_ind,
                    RRC_UECC_MODULE_ID,
                    RRC_RRM_MODULE_ID,
                    uecc_ue_ctx_get_op_transction_id(p_ue_context),
                    p_ue_context->cell_index);
        if ( (p_rrc_rrm_ue_capability_ind->radio_capability_info.eutra_radio_capability_info.
                eutra_radio_capability_info_def.ue_category >= 1) &&
           (p_rrc_rrm_ue_capability_ind->radio_capability_info.eutra_radio_capability_info.
                eutra_radio_capability_info_def.ue_category <= 5) )
        {
          /* Set the UE Category in UE Context */
          p_ue_context->ue_category = p_rrc_rrm_ue_capability_ind->radio_capability_info.
                                    eutra_radio_capability_info.eutra_radio_capability_info_def.
                                    ue_category;
        }
        if(  (p_rrc_rrm_ue_capability_ind->radio_capability_info.eutra_radio_capability_info.
                bitmask & UE_EUTRA_CAPABILITY_V920_IES_PRESENT ) &&
            (p_rrc_rrm_ue_capability_ind->radio_capability_info.eutra_radio_capability_info.
               ue_eutra_capability_v920_ies.bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT ) &&
            (p_rrc_rrm_ue_capability_ind->radio_capability_info.eutra_radio_capability_info.
               ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.bitmask & 
               RRC_RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT ) &&
            (p_rrc_rrm_ue_capability_ind->radio_capability_info.eutra_radio_capability_info.
               ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.bitmask & 
               RRC_RRM_UE_EUTRA_CAPABILITY_V1020_UE_CATEGORY_PRESENT ) &&
            ( (p_rrc_rrm_ue_capability_ind->radio_capability_info.eutra_radio_capability_info.
                ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                ue_category_v1020 >= 6) &&
           (p_rrc_rrm_ue_capability_ind->radio_capability_info.eutra_radio_capability_info.
                ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                ue_category_v1020 <= 8) ) )
            {
                /* Set the REL 10 UE Category in UE Context */
                p_ue_context->rel10_ue_category = p_rrc_rrm_ue_capability_ind->
                                    radio_capability_info.eutra_radio_capability_info.
                                    ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                    ue_eutra_capability_v1020_ies.ue_category_v1020;
            }
    }
    if (PNULL != p_rrc_rrm_ue_capability_ind)
    {
        rrc_mem_free (p_rrc_rrm_ue_capability_ind);
	/* Coverity Fix 83399 Start */
        p_rrc_rrm_ue_capability_ind = PNULL;
	/* Coverity Fix 83399 Stop */
    }

    if (PNULL != p_rrc_rrm_ue_capability_enquiry_resp)
    {
        rrc_mem_free (p_rrc_rrm_ue_capability_enquiry_resp);
	/* Coverity Fix 83399 Start */
        p_rrc_rrm_ue_capability_enquiry_resp = PNULL;
	/* Coverity Fix 83399 Stop */
    }
    /* SPR 13502 Fix Stop */
     
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_ue_rat_capability
*   INPUT        : uecc_ue_context_t               *p_ue_context
*                  rrc_radio_capability_info_t     *p_rrc_radio_capability_info,
*                  void                            *p_api
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds RAT capability message with success/failure.
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/

rrc_return_et uecc_rrm_build_ue_rat_capability(
    uecc_ue_context_t               *p_ue_context,      /* Added UE context */
    rrc_radio_capability_info_t     *p_rrc_radio_capability_info,
    void                            *p_api
)
{
    UE_CapabilityRAT_Container *p_UE_CapabilityRAT_Container;
    rrc_return_et   result = RRC_FAILURE;
    OSCTXT          asn1_ctx;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_rrc_radio_capability_info);
    RRC_ASSERT(PNULL != p_api);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    p_UE_CapabilityRAT_Container = (UE_CapabilityRAT_Container *)p_api;
    p_rrc_radio_capability_info->bitmask |= 0x0;

    switch(p_UE_CapabilityRAT_Container->rat_Type)
    {
        case RRC_RAT_TYPE_EUTRA:
        {
            UE_EUTRA_Capability ue_eutra_Capability;

            memset_wrapper(&ue_eutra_Capability, RRC_NULL, sizeof(UE_EUTRA_Capability));
            /*****************************/
            /* Init ASN1 context */
            if ( RT_OK != rtInitContext(&asn1_ctx) )
            {
                /* Drop message */
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_rrm_build_ue_rat_capability] ASN context initialization failed.");
                /* Free ASN context */
                rtFreeContext(&asn1_ctx);
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            do
            {
                /* CSR 00082289 Fix Start */
                /* CSR 00082289 Fix Stop */
                pu_setBuffer(&asn1_ctx, (OSOCTET *)p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts, ASN_RRC_BUF_TYPE);
        
                if ( RT_OK != asn1PD_UE_EUTRA_Capability(&asn1_ctx, &ue_eutra_Capability) )
                {
                    /* Drop message */
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[uecc_rrm_build_ue_rat_capability] ASN decode failed.");
                    break;
                }
                p_rrc_radio_capability_info->bitmask |=
                                                EUTRA_RADIO_CAPABILITY_PRESENT;
               
               

                result = uecc_rrm_build_ue_eutra_capability(p_ue_context,&p_rrc_radio_capability_info->eutra_radio_capability_info,
                                                &ue_eutra_Capability);

            }while(0);  
            /* Free ASN context */
            rtFreeContext(&asn1_ctx);
        }
        break;

        case RRC_RAT_TYPE_UTRA:
        {
            p_rrc_radio_capability_info->bitmask |=
                                            UTRA_RADIO_CAPABILITY_PRESENT;
            if ((p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts) > MAX_ASN_BUFFER)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_rrm_build_ue_rat_capability] Wrong num of Octets.");
            
                result = RRC_FAILURE;
                return result;
            }
            p_rrc_radio_capability_info->utra_radio_capability_info.len_utra_radio_capability_info = 
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
            l3_memcpy_wrapper(p_rrc_radio_capability_info->utra_radio_capability_info.utra_radio_capability_asn_buff,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
            
            result = RRC_SUCCESS;
        }
        break;
        
        case RRC_RAT_TYPE_GERAN_CS:
        {
            p_rrc_radio_capability_info->bitmask |=
                                            GERAN_CS_RADIO_CAPABILITY_PRESENT;
            if ((p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts) > MAX_ASN_BUFFER)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_rrm_build_ue_rat_capability] Wrong num of Octets.");
                
                result = RRC_FAILURE;
                return result;
            }
            p_rrc_radio_capability_info->geran_cs_radio_capability_info.len_geran_cs_radio_capability_info= 
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
            l3_memcpy_wrapper(p_rrc_radio_capability_info->geran_cs_radio_capability_info.geran_cs_radio_capability_asn_buff,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
            result = RRC_SUCCESS;
        }
        break;

        case RRC_RAT_TYPE_GERAN_PS:
        {
            p_rrc_radio_capability_info->bitmask |=
                                            GERAN_PS_RADIO_CAPABILITY_PRESENT;
            if ((p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts) > MAX_ASN_BUFFER)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_rrm_build_ue_rat_capability] Wrong num of Octets.");
    
                result = RRC_FAILURE;
                return result;
            }
            p_rrc_radio_capability_info->geran_ps_radio_capability_info.len_geran_ps_radio_capability_info = 
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
            l3_memcpy_wrapper(p_rrc_radio_capability_info->geran_ps_radio_capability_info.geran_ps_radio_capability_asn_buff,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
            result = RRC_SUCCESS;
        }
        break;

        case RRC_RAT_TYPE_CDMA2000_1XRTT:
        {
            p_rrc_radio_capability_info->bitmask |=
                                            CDMA2000_RADIO_CAPABILITY_PRESENT;
            if ((p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts) > MAX_ASN_BUFFER)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_rrm_build_ue_rat_capability] Wrong num of Octets.");
    
                result = RRC_FAILURE;
                return result;
            }
            p_rrc_radio_capability_info->cdma2000_radio_capability_info.len_cdma2000_radio_capability_info = 
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
            l3_memcpy_wrapper(p_rrc_radio_capability_info->cdma2000_radio_capability_info.cdma2000_radio_capability_asn_buff,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);

	    p_ue_context->cdma2000_info.ulhandoverPrepTransfer_r8_IEs_msi_numocts = 
		p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
	    l3_memcpy_wrapper(&p_ue_context->cdma2000_info.ulhandoverPrepTransfer_r8_IEs_msi_data,
		p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
		p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
       

            result = RRC_SUCCESS;
        }
        break;

#ifdef ENDC_ENABLED
/*NR_DC Code Change Start*/
        case RRC_RAT_TYPE_NR:
        {
            nr_rrc_UE_NR_Capability ue_NR_Capability;

            memset_wrapper(&ue_NR_Capability,
                    RRC_NULL,
                    sizeof(nr_rrc_UE_NR_Capability));

            /* Init ASN1 context */
            if ( RT_OK != rtInitContext(&asn1_ctx) )
            {
                /* Drop message */
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_DETAILED,
                        "[uecc_rrm_build_ue_nr_rat_capability] ASN context initialization failed.");
                /* Free ASN context */
                rtFreeContext(&asn1_ctx);
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            do
            {
                pu_setBuffer(&asn1_ctx, (OSOCTET *)p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts, ASN_RRC_BUF_TYPE);

                if ( RT_OK != asn1PD_nr_rrc_UE_NR_Capability(
                            &asn1_ctx,
                            &ue_NR_Capability))
                {
                    /* Drop message */
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_DETAILED,
                            "[uecc_rrm_build_ue_nr_rat_capability] ASN decode failed.");
                    break;
                }

                p_rrc_radio_capability_info->bitmask |=
                    NR_RADIO_CAPABILITY_PRESENT;

                result = uecc_rrm_build_ue_nr_capability(p_ue_context,
                        &p_rrc_radio_capability_info->nr_radio_capability_info,
                        &ue_NR_Capability);
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_DETAILED,
                            "[uecc_rrm_build_ue_nr_rat_capability] %d",result);

            }while(RRC_NULL); 
 
            /* Free ASN context */
            rtFreeContext(&asn1_ctx);
            break;
        }

        case RRC_RAT_TYPE_EUTRA_NR:
        {
            nr_rrc_UE_MRDC_Capability ue_MRDC_Capability;

            memset_wrapper(&ue_MRDC_Capability,
                    RRC_NULL,
                    sizeof(nr_rrc_UE_MRDC_Capability));

            /* Init ASN1 context */
            if ( RT_OK != rtInitContext(&asn1_ctx) )
            {
                /* Drop message */
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[uecc_rrm_build_ue_rat_capability] ASN context initialization failed.");
                /* Free ASN context */
                rtFreeContext(&asn1_ctx);
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            do
            {
                pu_setBuffer(&asn1_ctx, (OSOCTET *)p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts, ASN_RRC_BUF_TYPE);

                if ( RT_OK != asn1PD_nr_rrc_UE_MRDC_Capability(
                            &asn1_ctx,
                            &ue_MRDC_Capability))
                {
                    /* Drop message */
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,
                            "[uecc_rrm_build_ue_rat_capability] ASN decode failed.");
                    break;
                }

                p_rrc_radio_capability_info->bitmask |=
                    EURTA_NR_RADIO_CAPABILITY_PRESENT;

                result = uecc_rrm_build_ue_eutra_nr_capability(p_ue_context,
                        &p_rrc_radio_capability_info->eutra_nr_radio_capability_info,
                        &ue_MRDC_Capability);

            }while(0);  
            /* Free ASN context */
            rtFreeContext(&asn1_ctx);
        }
        break;
/*NR_DC Code Change Stop*/
#endif

        default:
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_ue_rat_capability -> wrong bitmask");
            break;
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_ue_eutra_capability
*   INPUT        : uecc_ue_context_t               *p_ue_context
*                  eutra_radio_capability_info_t   *p_eutra_radio_capability_info_t
*                  UE_EUTRA_Capability             *p_UE_EUTRA_Capability
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds EUTRA RAT capability.
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/

rrc_return_et uecc_rrm_build_ue_eutra_capability(
    uecc_ue_context_t               *p_ue_context,      /* Added UE context */
    eutra_radio_capability_info_t   *p_eutra_radio_capability_info_t,
    UE_EUTRA_Capability             *p_UE_EUTRA_Capability 
)       
{
    rrc_return_et       result = RRC_FAILURE;
    OSRTDListNode*      p_node = PNULL;
    NonContiguousUL_RA_WithinCC_r10 *p_ul_ra_withincc = PNULL;
    U8 i = 0;
    U8 ii = 0;

    /*CR 895 changes start*/
    UE_EUTRA_Capability_v9a0_IEs    ue_eutra_capability_v9a0_IEs;
    OSCTXT          asn1_ctx;
    /*CR 895 changes stop*/

    /*SPR_18803_START*/
    U32 feature_group_indicator    = 0;
    /*SPR_18803_END*/

    #if  defined (ENDC_ENABLED)
    /* eMTC changes start */
    UE_EUTRA_Capability_v1310_IEs     *pUeEutraCapabilityV1310    = PNULL;
    /* eMTC changes stop */
    #endif


    #ifdef ENDC_ENABLED
    /*NR_DC Code Change Start*/
    UE_EUTRA_Capability_v1510_IEs    *pUeEutraCapabilityV1510    = PNULL;    
    ue_eutra_capability_v1510_ies_t  *pRrmUeEutraCapabilityV1510 = PNULL;
    /*NR_DC Code Change Stop*/
    #endif

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_eutra_radio_capability_info_t);
    RRC_ASSERT(PNULL != p_UE_EUTRA_Capability);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    /* filling EUTRA capability */    
    p_eutra_radio_capability_info_t->bitmask = 0x0;
    if(1 == p_UE_EUTRA_Capability->m.nonCriticalExtensionPresent)
    {

        p_eutra_radio_capability_info_t->bitmask |= 
                                      UE_EUTRA_CAPABILITY_V920_IES_PRESENT;
        /*cr_407 filling dtm_r9*/
        if (1 == p_UE_EUTRA_Capability->nonCriticalExtension.
                interRAT_ParametersGERAN_v920.m.dtm_r9Present)
        {
          p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
            inter_rat_parameters_geran_v920.bitmask |=
                IRAT_PARAMS_GERAN_V920_DTM_R9_PRESENT;

          p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
              inter_rat_parameters_geran_v920.dtm_r9 =
            (U8)p_UE_EUTRA_Capability->nonCriticalExtension.
              interRAT_ParametersGERAN_v920.dtm_r9;

          /*store dtm_r9 in ue context*/
          /*p_ue_context->p_ue_capability_info->dtm_r9 =
              p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
              inter_rat_parameters_geran_v920.dtm_r9;*/
          p_ue_context->m.dtm_r9_present = RRC_TRUE;

        }
        /* cr_392 changes */ 
        if (1 == p_UE_EUTRA_Capability->nonCriticalExtension.
                interRAT_ParametersGERAN_v920.m.e_RedirectionGERAN_r9Present)
        {
            /* CR392: Added e_redirection_geran_r9 */
            p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
              inter_rat_parameters_geran_v920.bitmask |=
                IRAT_PARAMS_GERAN_V920_E_REDIRECTION_GERAN_R9_PRESENT;

            p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
              inter_rat_parameters_geran_v920.e_redirection_geran_r9 =
            (U8)p_UE_EUTRA_Capability->nonCriticalExtension.
              interRAT_ParametersGERAN_v920.e_RedirectionGERAN_r9;

            /*p_ue_context->m.e_redirection_geran_r9 = 1;
            p_ue_context->p_ue_capability_info->e_redirection_geran_r9 =
              p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                inter_rat_parameters_geran_v920.e_redirection_geran_r9;
            p_ue_context->m.e_redirection_geran_r9 = RRC_TRUE;*/
        }
        /* filling e_redirection_utra_r9 in ue_context*/

        if (1 == p_UE_EUTRA_Capability->nonCriticalExtension.m.
                interRAT_ParametersUTRA_v920Present)
        {
            /*SPR_18416_START*/
            p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
            bitmask |= RRC_RRM_INTER_RAT_PARAMS_UTRA_V920_PRESENT; 
            /*SPR_18416_STOP*/
          
            p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
              inter_rat_parameters_utra_v920.e_redirection_utra_r9 =
            (U8)p_UE_EUTRA_Capability->nonCriticalExtension.
              interRAT_ParametersUTRA_v920.e_RedirectionUTRA_r9;     

            if (supported_2 == p_eutra_radio_capability_info_t->
                  ue_eutra_capability_v920_ies.inter_rat_parameters_utra_v920.
                    e_redirection_utra_r9)
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_DETAILED,"e-Redirection-UTRA enabled");
                p_ue_context->m.e_redirection_utra_r9_present = RRC_TRUE;
            }
        }
       /*filling irat_parameters_cdma2000_v920_t */
	if (RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.m.
                 interRAT_ParametersCDMA2000_v920Present)
        {
           p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies. 
           bitmask = RRC_RRM_INTER_RAT_PARAMS_CDMA2000_V920_PRESENT;
          
           if ((RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.
                    interRAT_ParametersCDMA2000_v920.m.
                    e_CSFB_ConcPS_Mob1XRTT_r9Present )
                &&
              (supported_6 == p_eutra_radio_capability_info_t->
                ue_eutra_capability_v920_ies.inter_rat_parameters_cdma2000_v920.
                eCSFB_conc_ps_mobility_1xrtt_r9))
           {
              p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
               inter_rat_parameters_cdma2000_v920.bitmask =
               IRAT_PARAMS_CDMA_V920_E_CSFB_CONC_PS_MOB_1XRTT_R9_PRESENT;
            
              p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
               inter_rat_parameters_cdma2000_v920.
                eCSFB_conc_ps_mobility_1xrtt_r9 = 
			ECSFB_CONC_PS_MOB_1XRTT_R9_SUPPORTED; 
           
              RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_INFO,"e_CSFB_ConcPS_Mob1XRTT_r9 enabled");
           
           }
           
           
          if (supported_5 == p_eutra_radio_capability_info_t->
                ue_eutra_capability_v920_ies.inter_rat_parameters_cdma2000_v920.
                 eCSFB_1xrtt_r9 )
           {
             p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
              inter_rat_parameters_cdma2000_v920.eCSFB_1xrtt_r9 = 
                                      ECSFB_1XRTT_R9_SUPPORTED;
             
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_INFO,"e_CSFB_1XRTT_r9 enabled");
           }
           
        }
    /*SPR 17315 Fix Start 17 Nov*/
    /*Code Moved*/
    /*SPR 17315 Fix End 17 Nov*/

    /*cr_344 changes*/

    if ((RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.
              phyLayerParameters_v920.m.enhancedDualLayerFDD_r9Present)
        && (supported == p_UE_EUTRA_Capability->nonCriticalExtension.
              phyLayerParameters_v920.enhancedDualLayerFDD_r9))
    {
      p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
      phy_layer_parameters_v920.enhanced_dual_layer_fdd_supported_r9 = RRC_TRUE;
    }
    
    if ((RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.
              phyLayerParameters_v920.m.enhancedDualLayerTDD_r9Present)
        && (supported_1 == p_UE_EUTRA_Capability->nonCriticalExtension.
              phyLayerParameters_v920.enhancedDualLayerTDD_r9))
    {
      p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
      phy_layer_parameters_v920.enhanced_dual_layer_tdd_supported_r9 = RRC_TRUE;
    }


    //csg_ProximityIndicationParameters_r9
    
    if ((RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.
              csg_ProximityIndicationParameters_r9.m.intraFreqProximityIndication_r9Present)
        && (supported_7 == p_UE_EUTRA_Capability->nonCriticalExtension.
              csg_ProximityIndicationParameters_r9.intraFreqProximityIndication_r9))
    {
      p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
      csg_proximity_indication_parameters_r9.intra_freq_proximity_indication_supported_r9 = RRC_TRUE;
    }

    if ((RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.
              csg_ProximityIndicationParameters_r9.m.interFreqProximityIndication_r9Present)
        && (supported_8 == p_UE_EUTRA_Capability->nonCriticalExtension.
              csg_ProximityIndicationParameters_r9.interFreqProximityIndication_r9))
    {
      p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
      csg_proximity_indication_parameters_r9.inter_freq_proximity_indication_supported_r9 = RRC_TRUE;
    }

    if ((RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.
              csg_ProximityIndicationParameters_r9.m.utran_ProximityIndication_r9Present)
        && (supported_9 == p_UE_EUTRA_Capability->nonCriticalExtension.
              csg_ProximityIndicationParameters_r9.utran_ProximityIndication_r9))
    {
      p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
      csg_proximity_indication_parameters_r9.utran_proximity_indication_supported_r9 = RRC_TRUE;
    }

    //neighCellSI_AcquisitionParameters_r9

    if ((RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.
              neighCellSI_AcquisitionParameters_r9.m.intraFreqSI_AcquisitionForHO_r9Present)
        && (supported_10 == p_UE_EUTRA_Capability->nonCriticalExtension.
              neighCellSI_AcquisitionParameters_r9.intraFreqSI_AcquisitionForHO_r9))
    {
      p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
      neigh_cell_si_acquisition_parameters_r9.intra_freq_si_acquisition_for_ho_supported_r9 = RRC_TRUE;
    }

    if ((RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.
              neighCellSI_AcquisitionParameters_r9.m.interFreqSI_AcquisitionForHO_r9Present)
        && (supported_11 == p_UE_EUTRA_Capability->nonCriticalExtension.
              neighCellSI_AcquisitionParameters_r9.interFreqSI_AcquisitionForHO_r9))
    {
      p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
      neigh_cell_si_acquisition_parameters_r9.inter_freq_si_acquisition_for_ho_supported_r9 = RRC_TRUE;
    }

    if ((RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.
              neighCellSI_AcquisitionParameters_r9.m.utran_SI_AcquisitionForHO_r9Present)
        && (supported_12 == p_UE_EUTRA_Capability->nonCriticalExtension.
              neighCellSI_AcquisitionParameters_r9.utran_SI_AcquisitionForHO_r9))
    {
      p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
      neigh_cell_si_acquisition_parameters_r9.utran_si_acquisition_for_ho_supported_r9 = RRC_TRUE;
    }

    //son_Parameters_r9

    if ((RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.
              son_Parameters_r9.m.rach_Report_r9Present)
        && (supported_13 == p_UE_EUTRA_Capability->nonCriticalExtension.
              son_Parameters_r9.rach_Report_r9))
    {
      p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
      son_parameters_r9.rach_report_supported_r9 = RRC_TRUE;
    }

    /* cr_346 change */
    if ((RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.m.deviceType_r9Present) 
        && (noBenFromBatConsumpOpt == p_UE_EUTRA_Capability->nonCriticalExtension.deviceType_r9))
    {
        p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.bitmask |= RRC_RRM_DEVICE_TYPE_R9_PRESENT;

        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                p_ue_context->p_gb_context->facility_name, 
                RRC_DETAILED,"UE_EUTRA_CAP : NO BENEFIT FROM BATTERY CONSUMPTION OPTIMISATION Present.");
        p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.device_type_r9 =  NO_BEN_FROM_BAT_CONSUMP_OPT;
    }
    /* CR 503 changes */
    if (RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.m.nonCriticalExtensionPresent) 
    {
        p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.bitmask |= 
            RRC_RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT;

        /* CR 895 changes start*/
        if (RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.m.
                lateNonCriticalExtensionPresent)
        {
            if ( RT_OK != rtInitContext(&asn1_ctx) )
            {
                /* Drop message */
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[uecc_rrm_build_ue_eutra_capability] ASN context initialization failed.");
                /* Free ASN context */
                rtFreeContext(&asn1_ctx);
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            
            /* CSR 00082289 Fix Start */
            /* CSR 00082289 Fix Stop */

            pu_setBuffer(&asn1_ctx, (OSOCTET *)p_UE_EUTRA_Capability->nonCriticalExtension.
                    nonCriticalExtension.lateNonCriticalExtension.data, p_UE_EUTRA_Capability->
                    nonCriticalExtension.nonCriticalExtension.lateNonCriticalExtension.numocts, ASN_RRC_BUF_TYPE);

            if ( RT_OK != asn1PD_UE_EUTRA_Capability_v9a0_IEs(&asn1_ctx, &ue_eutra_capability_v9a0_IEs))
            {
                /* Drop message */
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[uecc_rrm_build_ue_eutra_capability] ASN decode failed.");
            }
            
           p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
               bitmask |= RRC_RRM_UE_EUTRA_CAPABILITY_V9a0_IES_PRESENT;

           result = uecc_rrm_build_ue_eutra_capability_v9a0(p_ue_context, &p_eutra_radio_capability_info_t->
                   ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v9a0_ies, 
                   &ue_eutra_capability_v9a0_IEs);
	   /* + Coverity 81333 */
           if(RRC_FAILURE == result)
           {
           	result = RRC_FAILURE;
           }
	   /* - Coverity 81333 */

        }
        /* CR 895 changes stop*/

        if (RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.m.nonCriticalExtensionPresent) 
        {
            p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.bitmask |= 
                       RRC_RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT;

            /* filling release 10 ue category */
            if (RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                    nonCriticalExtension.m.ue_Category_v1020Present) 
            {
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v1020_ies.bitmask |= 
                RRC_RRM_UE_EUTRA_CAPABILITY_V1020_UE_CATEGORY_PRESENT;
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v1020_ies.ue_category_v1020 = p_UE_EUTRA_Capability->nonCriticalExtension.
                    nonCriticalExtension.nonCriticalExtension.ue_Category_v1020;
                p_ue_context->rel10_ue_category = p_UE_EUTRA_Capability->nonCriticalExtension.
                    nonCriticalExtension.nonCriticalExtension.ue_Category_v1020;
                p_ue_context->m.rel10_ue_category_present = RRC_TRUE;
            }
            /* filling rf parameters release 10 */
            if (RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                    nonCriticalExtension.m.rf_Parameters_v1020Present) 
            {
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v1020_ies.bitmask |= 
                   RRC_RRM_UE_EUTRA_CAPABILITY_V1020_RF_PARAMETERS_PRESENT;
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v1020_ies.rf_parameters_v1020.supported_band_combination_r10.count =
                    p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                    rf_Parameters_v1020.supportedBandCombination_r10.count;
                p_node = p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                    rf_Parameters_v1020.supportedBandCombination_r10.head;
                for( ii = 0; ii<p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension.rf_Parameters_v1020.supportedBandCombination_r10.count ; ii++ )
                {
                            uecc_rrm_build_band_combination_parameters_r10(
                                    p_ue_context,
                                    &p_eutra_radio_capability_info_t->
                                    ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                    ue_eutra_capability_v1020_ies.rf_parameters_v1020.
                                    supported_band_combination_r10.band_combination_parameters_r10[ii],
                                    p_node->data);
                    p_node = p_node->next;
                }
            } 
            /* filling meas parameters release 10 */
            if (RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                    nonCriticalExtension.m.measParameters_v1020Present) 
            {
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v1020_ies.bitmask |= 
                    RRC_RRM_UE_EUTRA_CAPABILITY_V1020_MEAS_PARAMETERS_PRESENT;
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v1020_ies.meas_parameters_v1020.band_combination_list_eutra_r10.count = 
                    p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                    measParameters_v1020.bandCombinationListEUTRA_r10.count;
                p_node = p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                    nonCriticalExtension.measParameters_v1020.bandCombinationListEUTRA_r10.head;
                for( ii = 0; ii < p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension.measParameters_v1020.bandCombinationListEUTRA_r10.count ; ii++ )
                {
                    result =  uecc_rrm_build_info_eutra(
                            p_ue_context->p_gb_context, 
                            &p_eutra_radio_capability_info_t->
                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v1020_ies.meas_parameters_v1020.
                            band_combination_list_eutra_r10.band_info_eutra[ii],
                            p_node->data);
                    if(RRC_FAILURE == result)
                    {
                        result = RRC_FAILURE;
                        break;
                    }
                    p_node = p_node->next;
                }
            }
            /* CR 597 changes */
            /* filling inter rat parameters cdma 2000 */
            if (RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                    nonCriticalExtension.m.interRAT_ParametersCDMA2000_v1020Present) 
            {
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v1020_ies.bitmask |= RRC_RRM_UE_EUTRA_CAPABILITY_INTER_RAT_PARAMS_CDMA2000_V1020_PRESENT;
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v1020_ies.inter_rat_parameters_cdma2000_v1020.eCSFB_dual_1xrtt_r10 = 
                    p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                    interRAT_ParametersCDMA2000_v1020.e_CSFB_dual_1XRTT_r10;
            }

            /*CR 713 changes start*/
            /* filling interRAT Parameters UTRA_TDD v1020 */
            if (RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                    nonCriticalExtension.m.interRAT_ParametersUTRA_TDD_v1020Present)
            {
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v1020_ies.bitmask |= 
                    RRC_RRM_UE_EUTRA_CAPABILITY_INTER_RAT_PARAMS_UTRA_TDD_V1020_PRESENT;

                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v1020_ies.inter_rat_parameters_utra_tdd_v1020.
                    e_redirection_utra_tdd_r10 = p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                    nonCriticalExtension.interRAT_ParametersUTRA_TDD_v1020.e_RedirectionUTRA_TDD_r10;
            }
            /*CR 713 changes stop*/

            /* CR 597 changes */
            /* CR 710 changes */
            /* filling physical parameters v1020 */
            if (RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                    nonCriticalExtension.m.phyLayerParameters_v1020Present) 
            {
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v1020_ies.bitmask |= 
                    RRC_RRM_UE_EUTRA_CAPABILITY_V1020_PHYLAYERS_PARAMETERS_PRESENT;
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.bitmask = 0 ;
                
                /* filling two antenna ports for pucch rel 10 */
                if( RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension.phyLayerParameters_v1020.m.twoAntennaPortsForPUCCH_r10Present )
                {
                    p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                        ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                        phylayer_parameter_v1020.bitmask |= RRC_RRM_TWO_ANTENNA_PORTS_FOR_PUCCH_R10_PRESENT;

                    p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.two_antenna_ports_for_pucch_r10 = 
                        (two_antenna_ports_for_pucch_r10_et)p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension.phyLayerParameters_v1020.twoAntennaPortsForPUCCH_r10 ;

                }

                /* filling tm9_With_8Tx_FDD_r10 */
                if( RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension.phyLayerParameters_v1020.m.tm9_With_8Tx_FDD_r10Present )
                {
                    p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.bitmask |= 
                        RRC_RRM_TM9_WITH_8TX_FDD_R10_PRESENT ;

                    p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.tm9_with_8tx_fdd_r10 = 
                        (tm9_with_8tx_fdd_r10_et)p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension.phyLayerParameters_v1020.tm9_With_8Tx_FDD_r10;
                    
                }
                /* filling pmi_disabling_r10 */
                if( RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension.phyLayerParameters_v1020.m.pmi_Disabling_r10Present )
                {
                    p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.bitmask |= 
                        RRC_RRM_PMI_DISABLING_R10_PRESENT ;

                    p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                        ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                        phylayer_parameter_v1020.pmi_disabling_r10 =
                        (pmi_disabling_r10_et)p_UE_EUTRA_Capability->nonCriticalExtension.
                        nonCriticalExtension.nonCriticalExtension.phyLayerParameters_v1020.pmi_Disabling_r10;
                }
                /* filling cross_carrier_scheduling_r10 */
                if( RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension.phyLayerParameters_v1020.m.crossCarrierScheduling_r10Present )
                {
                    p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                        ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                        phylayer_parameter_v1020.bitmask |= RRC_RRM_CROSS_CARRIER_SCHEDULING_R10_PRESENT ;
                    
                    p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.
                        cross_carrier_scheduling_r10 =
                        (cross_carrier_scheduling_r10_et)p_UE_EUTRA_Capability->nonCriticalExtension.
                        nonCriticalExtension.nonCriticalExtension.phyLayerParameters_v1020.crossCarrierScheduling_r10;
                }
                /* filling simultaneous_pucch_pusch_r10 */
                if( RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension.phyLayerParameters_v1020.m.simultaneousPUCCH_PUSCH_r10Present )
                {
                    p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.
                        bitmask |= RRC_RRM_SIMULTANEOUS_PUCCH_PUSCH_R10_PRESENT ;
                    p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.simultaneous_pucch_pusch_r10 = 
                        (simultaneous_pucch_pusch_r10_et)p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                        phyLayerParameters_v1020.simultaneousPUCCH_PUSCH_r10;
                }
                /* filling multi_cluster_pusch_withincc_r10 */
                if( RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension.phyLayerParameters_v1020.m.multiClusterPUSCH_WithinCC_r10Present )
                {
                    p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.
                        bitmask |= RRC_RRM_MULTI_CLUSTER_PUSCH_WITHINCC_R10_PRESENT ;
                    
                    p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.
                        multi_cluster_pusch_withincc_r10 =
                        (multi_cluster_pusch_withincc_r10_et)p_UE_EUTRA_Capability->nonCriticalExtension.
                        nonCriticalExtension.nonCriticalExtension.phyLayerParameters_v1020.
                        multiClusterPUSCH_WithinCC_r10;
                }

                /* filling nonContiguousUL_RA_WithinCC_List_r10 */
                if( RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension.phyLayerParameters_v1020.m.nonContiguousUL_RA_WithinCC_List_r10Present )
                {
                    p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.
                        bitmask |= RRC_RRM_MULTI_NONCONTIGUOUSUL_RA_WITHINCC_LIST_R10_PRESENT ;
                    
                    p_node = p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension.phyLayerParameters_v1020.nonContiguousUL_RA_WithinCC_List_r10.head;

                    p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.phylayer_parameter_v1020.
                        noncontiguousul_ra_withincc_list_r10.count = p_UE_EUTRA_Capability->
                        nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                        phyLayerParameters_v1020.nonContiguousUL_RA_WithinCC_List_r10.count;

                    for( ii = 0; ii < p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                            nonCriticalExtension.phyLayerParameters_v1020.
                            nonContiguousUL_RA_WithinCC_List_r10.count ; ii++ )
                    {
                        p_ul_ra_withincc = (NonContiguousUL_RA_WithinCC_r10 *)p_node->data ;
                        if(RRC_TRUE == p_ul_ra_withincc->m.nonContiguousUL_RA_WithinCC_Info_r10Present )
                        {
                            p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                                ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                                phylayer_parameter_v1020.noncontiguousul_ra_withincc_list_r10.
                                noncontiguousul_ra_withincc_r10[ii].bitmask = 0 ;
                            p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                                ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                                phylayer_parameter_v1020.noncontiguousul_ra_withincc_list_r10.
                                noncontiguousul_ra_withincc_r10[ii].bitmask |= 
                                RRC_RRM_NONCONTIGUOUSUL_RA_WITHINCC_INFO_R10  ;
                            p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                                ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                                phylayer_parameter_v1020.noncontiguousul_ra_withincc_list_r10.
                                noncontiguousul_ra_withincc_r10[ii].noncontiguousul_ra_withincc_info_r10 = 
                                (noncontiguousul_ra_withincc_info_r10_et)p_ul_ra_withincc->nonContiguousUL_RA_WithinCC_Info_r10 ;
                        }
                        p_node = p_node->next;
                    }

                }
            }
            /* filling featuregroup_ind_r10 */
            if( RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                    nonCriticalExtension.m.featureGroupIndRel10_r10Present )
            {
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v1020_ies.bitmask |= 
                    RRC_RRM_UE_EUTRA_CAPABILITY_V1020_FEATUREGROUP_IND_R10_PRESENT;

                l3_memcpy_wrapper(&p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                        ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                        featuregroup_ind_r10,
                        &p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension.featureGroupIndRel10_r10.data,
                        p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension.featureGroupIndRel10_r10.numbits);
            }
            /* CR 710 changes */

            /* CR 919 changes start*/
            if (RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.
                    nonCriticalExtension.nonCriticalExtension.m.nonCriticalExtensionPresent)
            {
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                    ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.bitmask |= 
                        RRC_RRM_UE_EUTRA_CAPABILITY_v1060_IES_PRESENT;

                fill_ue_eutra_capability_v1060_ies(&p_UE_EUTRA_Capability->
                        nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                        nonCriticalExtension, &p_eutra_radio_capability_info_t->
                        ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies);
						

                                                #ifdef ENDC_ENABLED
                                                /*NR_DC Code Change Start*/
                                                pUeEutraCapabilityV1310 =  &(p_UE_EUTRA_Capability->nonCriticalExtension.
                                                    nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                                                    nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                                                    nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                                                    nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                                                    nonCriticalExtension);
                                                if ( pUeEutraCapabilityV1310->nonCriticalExtension.nonCriticalExtension.
                                                    nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                                                    nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                                                    nonCriticalExtension.m.nonCriticalExtensionPresent )
                                                {
                                                    pUeEutraCapabilityV1510 =  &(p_UE_EUTRA_Capability->nonCriticalExtension.
                                                            nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                                                            nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                                                            nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                                                            nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                                                            nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                                                            nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                                                            nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.
                                                            nonCriticalExtension.nonCriticalExtension);
                                                    pRrmUeEutraCapabilityV1510 = &(p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                                                            ue_eutra_capability_v1280_ies.ue_eutra_capability_v1310_ies.
                                                            ue_eutra_capability_v1320_ies.ue_eutra_capability_v1330_ies.
                                                            ue_eutra_capability_v1340_ies.ue_eutra_capability_v1350_ies.
                                                            ue_eutra_capability_v1360_ies.ue_eutra_capability_v1430_ies.
                                                            ue_eutra_capability_v1440_ies.ue_eutra_capability_v1450_ies.
                                                            ue_eutra_capability_v1460_ies.ue_eutra_capability_v1510_ies);
                                                     /*
                                                      * filling EN-DC parameters release 15
                                                      */
                                                     p_eutra_radio_capability_info_t->
                                                            bitmask
                                                     |= UE_EUTRA_CAPABILITY_V920_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_v1060_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_v1090_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_v1180_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_v11a0_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_v1250_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_v1260_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            ue_eutra_capability_v1260_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_v1270_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_v1280_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                                                            ue_eutra_capability_v1280_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_v1310_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                                                            ue_eutra_capability_v1280_ies.ue_eutra_capability_v1310_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_V1320_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                                                            ue_eutra_capability_v1280_ies.ue_eutra_capability_v1310_ies.
                                                            ue_eutra_capability_v1320_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_V1330_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                                                            ue_eutra_capability_v1280_ies.ue_eutra_capability_v1310_ies.
                                                            ue_eutra_capability_v1320_ies.ue_eutra_capability_v1330_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_V1340_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                                                            ue_eutra_capability_v1280_ies.ue_eutra_capability_v1310_ies.
                                                            ue_eutra_capability_v1320_ies.ue_eutra_capability_v1330_ies.
                                                            ue_eutra_capability_v1340_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_V1350_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                                                            ue_eutra_capability_v1280_ies.ue_eutra_capability_v1310_ies.
                                                            ue_eutra_capability_v1320_ies.ue_eutra_capability_v1330_ies.
                                                            ue_eutra_capability_v1340_ies.ue_eutra_capability_v1350_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_V1360_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                                                            ue_eutra_capability_v1280_ies.ue_eutra_capability_v1310_ies.
                                                            ue_eutra_capability_v1320_ies.ue_eutra_capability_v1330_ies.
                                                            ue_eutra_capability_v1340_ies.ue_eutra_capability_v1350_ies.
                                                            ue_eutra_capability_v1360_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_V1430_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                                                            ue_eutra_capability_v1280_ies.ue_eutra_capability_v1310_ies.
                                                            ue_eutra_capability_v1320_ies.ue_eutra_capability_v1330_ies.
                                                            ue_eutra_capability_v1340_ies.ue_eutra_capability_v1350_ies.
                                                            ue_eutra_capability_v1360_ies.ue_eutra_capability_v1430_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_V1440_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                                                            ue_eutra_capability_v1280_ies.ue_eutra_capability_v1310_ies.
                                                            ue_eutra_capability_v1320_ies.ue_eutra_capability_v1330_ies.
                                                            ue_eutra_capability_v1340_ies.ue_eutra_capability_v1350_ies.
                                                            ue_eutra_capability_v1360_ies.ue_eutra_capability_v1430_ies.
                                                            ue_eutra_capability_v1440_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_V1450_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                                                            ue_eutra_capability_v1280_ies.ue_eutra_capability_v1310_ies.
                                                            ue_eutra_capability_v1320_ies.ue_eutra_capability_v1330_ies.
                                                            ue_eutra_capability_v1340_ies.ue_eutra_capability_v1350_ies.
                                                            ue_eutra_capability_v1360_ies.ue_eutra_capability_v1430_ies.
                                                            ue_eutra_capability_v1440_ies.ue_eutra_capability_v1450_ies.
                                                            bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_V1460_IES_PRESENT;
                                                     p_eutra_radio_capability_info_t->
                                                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                                            ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060_ies.
                                                            ue_eutra_capability_v1090_ies.ue_eutra_capability_v1180_ies.
                                                            ue_eutra_capability_v11a0_ies.ue_eutra_capability_v1250_ies.
                                                            ue_eutra_capability_v1260_ies.ue_eutra_capability_v1270_ies.
                                                            ue_eutra_capability_v1280_ies.ue_eutra_capability_v1310_ies.
                                                            ue_eutra_capability_v1320_ies.ue_eutra_capability_v1330_ies.
                                                            ue_eutra_capability_v1340_ies.ue_eutra_capability_v1350_ies.
                                                            ue_eutra_capability_v1360_ies.ue_eutra_capability_v1430_ies.
                                                            ue_eutra_capability_v1440_ies.ue_eutra_capability_v1450_ies.
                                                            ue_eutra_capability_v1460_ies.bitmask
                                                     |= RRC_RRM_UE_EUTRA_CAPABILITY_V1510_IES_PRESENT;
                                                     result = rrcUeEutraCapabilityV1510IesEndc(pUeEutraCapabilityV1510, p_ue_context,
                                                         pRrmUeEutraCapabilityV1510);
                                                     if ( result == RRC_FAILURE )
                                                     {
                                                         RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                                                                 p_ue_context->p_gb_context->facility_name, 
                                                                 RRC_ERROR," Returned failure from UE eutra capability V1510 of EN-DC");
                                                         rtFreeContext(&asn1_ctx);
                                                         RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                                                         return result;
                                                     }
                                                     else
                                                     {
                                                         RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index, 
                                                              p_ue_context->p_gb_context->facility_name, 
                                                              RRC_DETAILED,"UE eutra capability V1510 of EN-DC is filled successfully");
                                                     }
                                                }
                                                /*NR_DC Code Change Stop*/
#endif
            }
            /* CR 919 changes stop*/
        }
        if (RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                nonCriticalExtension.m.ue_BasedNetwPerfMeasParameters_r10Present) 
        {
            p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.bitmask |= 
                RRC_RRM_UE_EUTRA_CAPABILITY_NW_PERF_MEAS_PARAMS_PRESENT;
            /* SPR_17315_Fix2_Start */
            p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                ue_based_nw_perf_meas_params.bitmask = RRC_NULL;
            /* SPR_17315_Fix2_End */

            if(RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                    nonCriticalExtension.ue_BasedNetwPerfMeasParameters_r10.m.loggedMeasurementsIdle_r10Present)
            {
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                    ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                    ue_based_nw_perf_meas_params.bitmask |=
                    RRC_RRM_LOGGED_MEAS_IDLE_UE_EUTRA_CAPABILITY_R10_PRESENT;

                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                    ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                    ue_based_nw_perf_meas_params.logged_measurements_idle_r10 =
                    p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                    nonCriticalExtension.ue_BasedNetwPerfMeasParameters_r10.loggedMeasurementsIdle_r10;
            }
            if(RRC_TRUE == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                    nonCriticalExtension.ue_BasedNetwPerfMeasParameters_r10.m.standaloneGNSS_Location_r10Present)
            {
                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                    ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                    ue_based_nw_perf_meas_params.bitmask |=
                    RRC_RRM_STANDALONE_GNSS_LOC_UE_EUTRA_CAPABILITY_R10_PRESENT;

                p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.
                    ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                    ue_based_nw_perf_meas_params.standalone_gnss_location_r10 =
                    p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.
                    nonCriticalExtension.ue_BasedNetwPerfMeasParameters_r10.standaloneGNSS_Location_r10;
            }

        }
        
    }
    /*SPR 17315 Fix Start 17 Nov*/
}
/*SPR 17315 Fix End*/

    /* CR 503 changes */
    /* filling access stratum release */
    //#ifdef ENDC_ENABLED
    /* Note: Temporary */
    /* MENB_CHANGES_START */
    //p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.access_stratum_release = 
        //RRM_REL_13;
    /* MENB_CHANGES_END */
    //#else
    p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.access_stratum_release = 
                                           (U8)p_UE_EUTRA_Capability->accessStratumRelease;
    //#endif

    /* filling ue category */           
    p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.ue_category = 
            p_UE_EUTRA_Capability->ue_Category;

    /*SPR 20951 Start*/
    if ((UE_EUTRA_CAPABILITY_V920_IES_PRESENT & p_eutra_radio_capability_info_t->bitmask) &&
          (RRC_RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT & p_eutra_radio_capability_info_t->
                   ue_eutra_capability_v920_ies.bitmask) &&
            (RRC_RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT & p_eutra_radio_capability_info_t->
                   ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.bitmask) &&
              (RRC_RRM_UE_EUTRA_CAPABILITY_V1020_UE_CATEGORY_PRESENT & p_eutra_radio_capability_info_t->
                   ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.bitmask))
    {
       
        if(!((((6 == p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                 ue_eutra_capability_v1020_ies.ue_category_v1020) || (7 == p_eutra_radio_capability_info_t->
                 ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.
                 ue_category_v1020)) && (4 == p_eutra_radio_capability_info_t->
                 eutra_radio_capability_info_def.ue_category)) ||
            ((8 == p_eutra_radio_capability_info_t->ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                  ue_eutra_capability_v1020_ies.ue_category_v1020) && 
                 (5 == p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.ue_category))))

        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "Invalid ue category combination");
            return RRC_FAILURE;
        }
    }
    /*SPR 20951 Stop*/
    /* filling pdcp parameters */
    result = uecc_rrm_build_pdcp_parameters(
                    p_ue_context->p_gb_context, 
                    &p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.pdcp_parameters,
                    &p_UE_EUTRA_Capability->pdcp_Parameters);

    /* filling physical parameters */           
    p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.physical_layer_params.ue_TxAntennaSelectionSupported =
                                            p_UE_EUTRA_Capability->phyLayerParameters.ue_TxAntennaSelectionSupported;
    p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.physical_layer_params.ue_SpecificRefSigsSupported =
                                            p_UE_EUTRA_Capability->phyLayerParameters.ue_SpecificRefSigsSupported;
    /* filling rf parameters */
    p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.rf_parameters.supported_band_list_eutra.count = 
                    (U8)(p_UE_EUTRA_Capability->rf_Parameters.supportedBandListEUTRA.count);
    p_node = p_UE_EUTRA_Capability->rf_Parameters.supportedBandListEUTRA.head;

    for (i = 0 ; i < p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.rf_parameters.supported_band_list_eutra.count ; i++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

         result = uecc_rrm_build_supported_band_eutra(
                        p_ue_context->p_gb_context, 
                        &p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.
                        rf_parameters.supported_band_list_eutra.supported_band_eutra[i],
                        p_node->data);
	/* + Coverity 81528 */
        if(RRC_FAILURE == result)
        {
            result = RRC_FAILURE;
            break;
        }
	/* - Coverity 81528 */


        p_node = p_node->next;
    }
    /* CR 678 changes */
    if( 1 == p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.m.rf_Parameters_v1020Present)
    {
        if( RRC_SUCCESS != uecc_rrm_check_band_in_rf_parameters(
                    p_ue_context->p_gb_context,
                    &p_UE_EUTRA_Capability->rf_Parameters,
                    &p_UE_EUTRA_Capability->nonCriticalExtension.nonCriticalExtension.nonCriticalExtension.rf_Parameters_v1020)
          )
        {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_INFO,"Extra Band information present in rel 10");
        }
    }
    /* CR 678 changes */

    /* filling meas parameters list */
    p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.meas_prameters.band_list_eutra.count
        = (U8)(p_UE_EUTRA_Capability->measParameters.bandListEUTRA.count);
    
    p_node = PNULL;
    p_node = p_UE_EUTRA_Capability->measParameters.bandListEUTRA.head;

    for (i = 0 ; i < p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.meas_prameters.band_list_eutra.count; i++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        result = uecc_rrm_build_info_eutra
                    (p_ue_context->p_gb_context, 
                    &p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.
                    meas_prameters.band_list_eutra.band_info_eutra[i],
                    p_node->data);
            
        if(RRC_FAILURE == result)
        {
            result = RRC_FAILURE;
            break;
        }
        p_node = p_node->next;
    }

    /* filling featureGroupIndicators */
    p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.bitmask = 0x0;
    if(1 == p_UE_EUTRA_Capability->m.featureGroupIndicatorsPresent)
    {
        p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.bitmask |=
                        EUTRA_FEATURE_GROUP_INDICATORS_PRESENT;
        
        l3_memcpy_wrapper(p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.feature_group_indicators,
                    p_UE_EUTRA_Capability->featureGroupIndicators.data,
                    ARRSIZE(p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.feature_group_indicators));

        /*SPR_18803_START*/
        l3_memcpy_wrapper(&feature_group_indicator,
                    p_UE_EUTRA_Capability->featureGroupIndicators.data,
                    ARRSIZE(p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.feature_group_indicators));

        p_ue_context->feature_group_indicators = ntohl_wrapper(feature_group_indicator);
        /*SPR_18803_END*/
    }
    /* filling interRAT-Parameters */
    
    result = uecc_rrm_build_inter_rat_parameters(
               /* CDMA2000_FIX*/
                p_ue_context, 
                &p_eutra_radio_capability_info_t->eutra_radio_capability_info_def.inter_rat_Parameters,
                &p_UE_EUTRA_Capability->interRAT_Parameters);
   RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
       (p_ue_context->p_gb_context)->facility_name,
        RRC_DETAILED,"e-Redirection-GERAN Stored");
    /*SPR_18125_START*/
    rtFreeContext(&asn1_ctx);
    /*SPR_18125_END*/
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}


/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_inter_rat_parameters
*   INPUT        : uecc_ue_context_t       *p_ue_context,
*                  inter_rat_Parameters_t  *p_inter_rat_Parameters_t,
*                  UE_EUTRA_Capability_interRAT_Parameters     *p_asn_UE_EUTRA_Capability_interRAT_Parameters
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds inter rat parameters for eutra
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_inter_rat_parameters(
    uecc_ue_context_t       *p_ue_context, 
    inter_rat_Parameters_t  *p_inter_rat_Parameters_t,
    UE_EUTRA_Capability_interRAT_Parameters     *p_asn_UE_EUTRA_Capability_interRAT_Parameters)
{
    rrc_return_et   result = RRC_FAILURE;
    U8 i = 0;
    RRC_ASSERT(PNULL != p_inter_rat_Parameters_t);
    RRC_ASSERT(PNULL != p_asn_UE_EUTRA_Capability_interRAT_Parameters);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    /* filling interRAT-utra fdd Parameters */
    if(1 == p_asn_UE_EUTRA_Capability_interRAT_Parameters->m.utraFDDPresent)
    {
        p_inter_rat_Parameters_t->bitmask |=
                            INTER_RAT_UTRA_FDD_PRESENT;

        p_inter_rat_Parameters_t->utra_fdd.count = 
            (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->utraFDD.supportedBandListUTRA_FDD.n);
    
        for (i = 0 ; i < p_inter_rat_Parameters_t->utra_fdd.count ; i++)
        {
            p_inter_rat_Parameters_t->utra_fdd.supported_band_utra_fdd[i] = 
            (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->utraFDD.supportedBandListUTRA_FDD.elem[i]);
        }
    }
    /* filling interRAT-utra tdd128 Parameters */
    if(1 == p_asn_UE_EUTRA_Capability_interRAT_Parameters->m.utraTDD128Present)
    {
        p_inter_rat_Parameters_t->bitmask |=
                            INTER_RAT_UTRA_TDD128_PRESENT;

        p_inter_rat_Parameters_t->utra_tdd128.count = 
            (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->utraTDD128.supportedBandListUTRA_TDD128.n);
    
        for (i = 0 ; i < p_inter_rat_Parameters_t->utra_tdd128.count ; i++)
        {
            p_inter_rat_Parameters_t->utra_tdd128.supported_band_utra_tdd128[i] = 
            (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->utraTDD128.supportedBandListUTRA_TDD128.elem[i]);
        }
    }
    /* filling interRAT-utra tdd384 Parameters */
    if(1 == p_asn_UE_EUTRA_Capability_interRAT_Parameters->m.utraTDD384Present)
    {
        p_inter_rat_Parameters_t->bitmask |=
                            INTER_RAT_UTRA_TDD384_PRESENT;

        p_inter_rat_Parameters_t->utra_tdd384.count = 
            (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->utraTDD384.supportedBandListUTRA_TDD384.n);
    
        for (i = 0 ; i < p_inter_rat_Parameters_t->utra_tdd384.count ; i++)
        {
            p_inter_rat_Parameters_t->utra_tdd384.supported_band_utra_tdd384[i] = 
                (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->utraTDD384.supportedBandListUTRA_TDD384.elem[i]);
        }
    }
    /* filling interRAT-utra tdd768 Parameters */
    if(1 == p_asn_UE_EUTRA_Capability_interRAT_Parameters->m.utraTDD768Present)
    {
        p_inter_rat_Parameters_t->bitmask |=
                            INTER_RAT_UTRA_TDD768_PRESENT;

        p_inter_rat_Parameters_t->utra_tdd768.count = 
                (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->utraTDD768.supportedBandListUTRA_TDD768.n);
    
        for (i = 0 ; i < p_inter_rat_Parameters_t->utra_tdd768.count ; i++)
        {
            p_inter_rat_Parameters_t->utra_tdd768.supported_band_utra_tdd768[i] = 
                (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->utraTDD768.supportedBandListUTRA_TDD768.elem[i]);
        }
    }
    /* filling interRAT-geran Parameters */
    if(1 == p_asn_UE_EUTRA_Capability_interRAT_Parameters->m.geranPresent)
    {
        p_inter_rat_Parameters_t->bitmask |=
                                INTER_RAT_UTRA_GERAN_PRESENT;
        p_inter_rat_Parameters_t->geran.inter_rat_ps_ho_to_geran = 
            p_asn_UE_EUTRA_Capability_interRAT_Parameters->geran.interRAT_PS_HO_ToGERAN;
        p_inter_rat_Parameters_t->geran.supported_band_list_geran.count = 
            (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->geran.supportedBandListGERAN.n);
        for (i = 0 ; i < p_inter_rat_Parameters_t->geran.supported_band_list_geran.count ; i++)
        {
            p_inter_rat_Parameters_t->geran.supported_band_list_geran.supported_band_geran[i] = 
                (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->geran.supportedBandListGERAN.elem[i]);
        }
    }
    /* filling interRAT-cdma2000_HRPD Parameters */
    if(1 == p_asn_UE_EUTRA_Capability_interRAT_Parameters->m.cdma2000_HRPDPresent)
    {
        p_inter_rat_Parameters_t->bitmask |=
                                INTER_RAT_UTRA_CDMA2000_HRPD_PRESENT;
        p_inter_rat_Parameters_t->cdma2000_hrpd.tx_confiig_hrpd =
            (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->cdma2000_HRPD.tx_ConfigHRPD);
        p_inter_rat_Parameters_t->cdma2000_hrpd.rx_confiig_hrpd =
            (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->cdma2000_HRPD.rx_ConfigHRPD);
        p_inter_rat_Parameters_t->cdma2000_hrpd.supported_band_list_hrpd.count =
            (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->cdma2000_HRPD.supportedBandListHRPD.n);
        for (i = 0 ; i < p_inter_rat_Parameters_t->cdma2000_hrpd.supported_band_list_hrpd.count ; i++)
        {
            p_inter_rat_Parameters_t->cdma2000_hrpd.supported_band_list_hrpd.band_class_cdma2000[i] = 
                (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->cdma2000_HRPD.supportedBandListHRPD.elem[i]);
        }
    }
    /* filling interRAT-cdma2000_1xrtt Parameters */
    if(1 == p_asn_UE_EUTRA_Capability_interRAT_Parameters->m.cdma2000_1xRTTPresent)
    {
        p_inter_rat_Parameters_t->bitmask |=
                                INTER_RAT_UTRA_CDMA2000_1XRTT_PRESENT;
        p_inter_rat_Parameters_t->cdma2000_1x_rtt.tx_confiig_1xrtt =
                (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->cdma2000_1xRTT.tx_Config1XRTT);
        p_inter_rat_Parameters_t->cdma2000_1x_rtt.rx_confiig_1xrtt=
                (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->cdma2000_1xRTT.rx_Config1XRTT);
#if 0       
        /* CDMA2000_FIX */
        if (tx_rx_dual == p_inter_rat_Parameters_t->cdma2000_1x_rtt.rx_confiig_1xrtt)
        {
            p_ue_context->p_ue_capability_info->dual_rx_config_1xrtt_present = RRC_TRUE;
        }
        else
            p_ue_context->p_ue_capability_info->dual_rx_config_1xrtt_present = RRC_FALSE;
#endif
        p_inter_rat_Parameters_t->cdma2000_1x_rtt.supported_band_list_1xrtt.count=
                (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->cdma2000_1xRTT.supportedBandList1XRTT.n);
        for (i = 0 ; i < p_inter_rat_Parameters_t->cdma2000_1x_rtt.supported_band_list_1xrtt.count ; i++)
        {
            p_inter_rat_Parameters_t->cdma2000_1x_rtt.supported_band_list_1xrtt.band_class_cdma2000[i] = 
                (U8)(p_asn_UE_EUTRA_Capability_interRAT_Parameters->cdma2000_1xRTT.supportedBandList1XRTT.elem[i]);
        }
    }
    
    result = RRC_SUCCESS;   
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;  
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_pdcp_parameters
*   INPUT        : uecc_gb_context_t   *p_uecc_gb_context,
*                  pdcp_parameters_t   *p_pdcp_parameters,
*                  PDCP_Parameters     *p_asn_PDCP_Parameters
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds pdcp parameters for eutra
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_pdcp_parameters(
    uecc_gb_context_t   *p_uecc_gb_context,
    pdcp_parameters_t   *p_pdcp_parameters,
    PDCP_Parameters     *p_asn_PDCP_Parameters)
{
    rrc_return_et   result = RRC_FAILURE;
    RRC_ASSERT(PNULL != p_pdcp_parameters);
    RRC_ASSERT(PNULL != p_asn_PDCP_Parameters);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
    p_pdcp_parameters->rohc_profile.profile0x0001 = p_asn_PDCP_Parameters->supportedROHC_Profiles.profile0x0001_r15;
    p_pdcp_parameters->rohc_profile.profile0x0002 = p_asn_PDCP_Parameters->supportedROHC_Profiles.profile0x0002_r15;
    p_pdcp_parameters->rohc_profile.profile0x0003 = p_asn_PDCP_Parameters->supportedROHC_Profiles.profile0x0003_r15;
    p_pdcp_parameters->rohc_profile.profile0x0004 = p_asn_PDCP_Parameters->supportedROHC_Profiles.profile0x0004_r15;
    p_pdcp_parameters->rohc_profile.profile0x0006 = p_asn_PDCP_Parameters->supportedROHC_Profiles.profile0x0006_r15;
    p_pdcp_parameters->rohc_profile.profile0x0101 = p_asn_PDCP_Parameters->supportedROHC_Profiles.profile0x0101_r15;
    p_pdcp_parameters->rohc_profile.profile0x0102 = p_asn_PDCP_Parameters->supportedROHC_Profiles.profile0x0102_r15;
    p_pdcp_parameters->rohc_profile.profile0x0103 = p_asn_PDCP_Parameters->supportedROHC_Profiles.profile0x0103_r15;
    p_pdcp_parameters->rohc_profile.profile0x0104 = p_asn_PDCP_Parameters->supportedROHC_Profiles.profile0x0104_r15;
    p_pdcp_parameters->max_num_rohc_context_session = (U8)p_asn_PDCP_Parameters->maxNumberROHC_ContextSessions;
                
    result = RRC_SUCCESS;   
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}


/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_inter_rat_band_info
*   INPUT        : uecc_gb_context_t       *p_uecc_gb_context,
*                  inter_rat_band_info_t   *p_inter_rat_band_info,
*                  InterRAT_BandInfo       *p_asn_InterRAT_BandInfo
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds inter rat band info for eutra
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_inter_rat_band_info(
    uecc_gb_context_t       *p_uecc_gb_context,
    inter_rat_band_info_t   *p_inter_rat_band_info,
    InterRAT_BandInfo       *p_asn_InterRAT_BandInfo)
{
    rrc_return_et   result = RRC_FAILURE;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                      "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
    RRC_ASSERT(PNULL != p_inter_rat_band_info);
    RRC_ASSERT(PNULL != p_asn_InterRAT_BandInfo);

    p_inter_rat_band_info->inter_rat_need_for_gaps = p_asn_InterRAT_BandInfo->interRAT_NeedForGaps;
    
    result = RRC_SUCCESS;   
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_inter_freq_band_info
*   INPUT        : uecc_gb_context_t       *p_uecc_gb_context,
*                  inter_freq_band_info_t  *p_inter_freq_band_info,
*                  InterFreqBandInfo       *p_asn_InterFreqBandInfo
*   OUTPUT       : none        
*   DESCRIPTION:
*       This function builds inter freq band info for eutra
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_inter_freq_band_info(
    uecc_gb_context_t       *p_uecc_gb_context,
    inter_freq_band_info_t  *p_inter_freq_band_info,
    InterFreqBandInfo       *p_asn_InterFreqBandInfo)
{
    rrc_return_et   result = RRC_FAILURE;
    RRC_ASSERT(PNULL != p_inter_freq_band_info);
    RRC_ASSERT(PNULL != p_asn_InterFreqBandInfo);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/

    p_inter_freq_band_info->inter_freq_need_for_gaps = p_asn_InterFreqBandInfo->interFreqNeedForGaps;
    
    result = RRC_SUCCESS;   
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_info_eutra
*   INPUT        : uecc_gb_context_t   *p_uecc_gb_context,
*                  band_info_eutra_t   *p_band_info_eutra,
*                  BandInfoEUTRA       *p_asn_BandInfoEUTRA
*   OUTPUT       : none               
*   DESCRIPTION:
*       This function builds info eutra
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_info_eutra(
    uecc_gb_context_t   *p_uecc_gb_context,
    band_info_eutra_t   *p_band_info_eutra,
    BandInfoEUTRA       *p_asn_BandInfoEUTRA)
{
    rrc_return_et   result = RRC_FAILURE;
    OSRTDListNode*      p_node = PNULL;
    U8 i = 0;

    RRC_ASSERT(PNULL != p_band_info_eutra);
    RRC_ASSERT(PNULL != p_asn_BandInfoEUTRA);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/

    /* filling inter rat band list */
    p_band_info_eutra->bitmask = 0x0;
    if(1 == p_asn_BandInfoEUTRA->m.interRAT_BandListPresent)
    {
        p_band_info_eutra->bitmask |= EUTRA_INTER_RAT_BAND_LIST_PRESENT;
        p_band_info_eutra->inter_rat_band_list.count = 
            (U8)(p_asn_BandInfoEUTRA->interRAT_BandList.count);

        p_node = p_asn_BandInfoEUTRA->interRAT_BandList.head;

        for (i = 0 ; i < p_band_info_eutra->inter_rat_band_list.count; i++)
        {
            RRC_ASSERT(PNULL != p_node);
            RRC_ASSERT(PNULL != p_node->data);

            /* Bug 8045 Fix Start */
            result = uecc_rrm_build_inter_rat_band_info
                        (p_uecc_gb_context, 
                        &p_band_info_eutra->inter_rat_band_list.inter_rat_band_info[i],
                        p_node->data);;
            /* Bug 8045 Fix Stop */
                
            p_node = p_node->next;
        }
    }

    /* filling inter freq band list */
    p_band_info_eutra->inter_freq_band_list.count = 
            (U8)(p_asn_BandInfoEUTRA->interFreqBandList.count);
    p_node = PNULL;

    p_node = p_asn_BandInfoEUTRA->interFreqBandList.head;

    for (i = 0 ; i < p_band_info_eutra->inter_freq_band_list.count; i++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        /* Bug 8045 Fix Start */
        result = uecc_rrm_build_inter_freq_band_info
                    (p_uecc_gb_context, 
                    &p_band_info_eutra->inter_freq_band_list.inter_freq_band_info[i],
                    p_node->data);;
        /* Bug 8045 Fix Stop */

        p_node = p_node->next;
    }
    
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}


/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_supported_band_eutra
*   INPUT        : uecc_gb_context_t       *p_uecc_gb_context,
*                  supported_band_eutra_t  *p_supported_band_eutra,
*                  SupportedBandEUTRA      *p_asn_supported_band_eutra
*   OUTPUT       : none               
*   DESCRIPTION:
*       This function builds supported band capability for eutra
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_supported_band_eutra(
    uecc_gb_context_t       *p_uecc_gb_context,
    supported_band_eutra_t  *p_supported_band_eutra,
    SupportedBandEUTRA      *p_asn_supported_band_eutra)
{
    rrc_return_et   result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_supported_band_eutra);
    RRC_ASSERT(PNULL != p_asn_supported_band_eutra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/

    p_supported_band_eutra->band_eutra = p_asn_supported_band_eutra->bandEUTRA;
    p_supported_band_eutra->half_duplex = p_asn_supported_band_eutra->halfDuplex;

    result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}


/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_failure_ue_capability_info_to_rrm
*   INPUT        : uecc_ue_context_t               *p_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds RAT capability message with negative response
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_failure_ue_capability_info_to_rrm(
    uecc_ue_context_t               *p_ue_context      /* UECC UE context */
)
{
    rrc_return_et       result = RRC_FAILURE;
    /* SPR 13502 Fix Start */
    rrc_rrm_ue_capability_enquiry_resp_t *p_rrc_rrm_ue_capability_enquiry_resp = PNULL;
    
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    p_rrc_rrm_ue_capability_enquiry_resp = (rrc_rrm_ue_capability_enquiry_resp_t *)rrc_mem_get
                                  (sizeof(rrc_rrm_ue_capability_enquiry_resp_t));
    if (PNULL == p_rrc_rrm_ue_capability_enquiry_resp)
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,
                "Memory Allocation Failure.");
        return RRC_FAILURE;
    }
    /* SES-508 Fix Start */
    /* Code Removed */
    /* SES-508 Fix End */
    
    p_rrc_rrm_ue_capability_enquiry_resp->bitmask = 0x0;
    p_rrc_rrm_ue_capability_enquiry_resp->ue_Index = p_ue_context->ue_index;
    
    
    p_rrc_rrm_ue_capability_enquiry_resp->result = RRC_FAILURE;
    
    /* PUP encode and send */
    result = rrc_rrm_il_send_rrc_rrm_ue_capability_enquiry_resp(
                    p_rrc_rrm_ue_capability_enquiry_resp,
                    RRC_UECC_MODULE_ID,
                    RRC_RRM_MODULE_ID,
                    /*SPR_17893_START*/
                    p_ue_context->ue_capability_transaction_id,
                    p_ue_context->cell_index);
                    /*SPR_17893_END*/
     
	RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
		 (p_ue_context->p_gb_context)->facility_name,
		 RRC_INFO,"API:RRC->RRM:RRC_RRM_UE_CAPABILITY_ENQUIRY_RESP:[UE:%u] with result:%u",
		 p_rrc_rrm_ue_capability_enquiry_resp->ue_Index, p_rrc_rrm_ue_capability_enquiry_resp->result);	
     
    if (PNULL != p_rrc_rrm_ue_capability_enquiry_resp)
    {
        rrc_mem_free(p_rrc_rrm_ue_capability_enquiry_resp);
	/* Coverity Fix 83399 Start */
        p_rrc_rrm_ue_capability_enquiry_resp = PNULL;
	/* Coverity Fix 83399 Stop */
    }
    /* SPR 13502 Fix Stop */

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_proximity_indication_ind
*   INPUT        : uecc_ue_context_t               *p_ue_context
*                  void               *p_data
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds and sends RRC_RRM_PROXIMITY_IND message
*       with failure to RRM module
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_proximity_indication_ind(
    uecc_ue_context_t*  p_ue_context,
    void               *p_data)
{
    rrc_return_et                       response = RRC_FAILURE;
    rrc_rrm_proximity_ind_t             rrc_rrm_proximity_ind;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_data);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    do
    {

       memset_wrapper(&rrc_rrm_proximity_ind,
              0,
               sizeof(rrc_rrm_proximity_ind_t));

        response = uecc_rrm_build_proximity_results_ind(
                    p_ue_context,
                    &rrc_rrm_proximity_ind,
                    p_data);

        if(RRC_FAILURE == response)
        {
            break;
        }

        response = rrc_rrm_il_send_rrc_rrm_proximity_ind(
                &rrc_rrm_proximity_ind,
                RRC_UECC_MODULE_ID,
                RRC_RRM_MODULE_ID,
                uecc_ue_ctx_get_op_transction_id(p_ue_context),
                p_ue_context->cell_index);
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return response;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_proximity_results_ind
*   INPUT        : uecc_ue_context_t*                  p_ue_context,
*                  rrc_rrm_proximity_ind_t*            p_rrc_rrm_proximity_ind,
*                  ProximityIndication_r9_IEs*         p_proximityIndication_r9
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds RRC_RRM_PROXIMITY_IND message
*       to RRM module
*
*   RETURNS:
*       None
*
******************************************************************************/
rrc_return_et uecc_rrm_build_proximity_results_ind(
    uecc_ue_context_t*                  p_ue_context,
    rrc_rrm_proximity_ind_t*            p_rrc_rrm_proximity_ind,
    ProximityIndication_r9_IEs*         p_proximityIndication_r9)
{
    rrc_return_et   result = RRC_FAILURE;
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_rrc_rrm_proximity_ind);
    RRC_ASSERT(PNULL != p_proximityIndication_r9);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    do
    {
        p_rrc_rrm_proximity_ind->ue_index = p_ue_context->ue_index;


        p_rrc_rrm_proximity_ind->proximity_ind_type = (U8)p_proximityIndication_r9->type_r9;
        
        result = RRC_SUCCESS;
        switch (p_proximityIndication_r9->carrierFreq_r9.t)
              { 
                case T_ProximityIndication_r9_IEs_carrierFreq_r9_eutra_r9:
                   p_rrc_rrm_proximity_ind->carrier_Freq.presence_bitmask |=
                       RRM_PROXIMITY_ARFCN_VALUE_EUTRA_PRESENT; 
                   p_rrc_rrm_proximity_ind->carrier_Freq.carrier_freq_eutra=
                            (U16)(p_proximityIndication_r9->carrierFreq_r9.u.eutra_r9);
                    break;

                case T_ProximityIndication_r9_IEs_carrierFreq_r9_utra_r9:
                   p_rrc_rrm_proximity_ind->carrier_Freq.presence_bitmask |=             
                       RRM_PROXIMITY_ARFCN_VALUE_UTRA_PRESENT;
                   p_rrc_rrm_proximity_ind->carrier_Freq.carrier_freq_utra=
                            (U16)(p_proximityIndication_r9->carrierFreq_r9.u.utra_r9);
                    break;
                
                default:
                    break;
              }
    }while(0);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_measurment_results_ind
*   INPUT        : uecc_ue_context_t*  p_ue_context,
*                  void*               p_data
*   OUTPUT       : none    
*   DESCRIPTION:
*       This function builds and sends RRC_RRM_MEASURMENT_RESULTS_IND message
*       with failure to RRM module
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_measurment_results_ind(
    uecc_ue_context_t*  p_ue_context,
    void*               p_data)
{
    rrc_return_et                       response = RRC_FAILURE;
    rrc_rrm_measurment_results_ind_t    rrc_rrm_measurment_results_ind;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_data);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    
    do
    {
        
       memset_wrapper(&rrc_rrm_measurment_results_ind,
              0,
               sizeof(rrc_rrm_measurment_results_ind_t));

        response = uecc_rrm_build_measurment_results_ind(
                    p_ue_context,
                    &rrc_rrm_measurment_results_ind,
                    p_data);

        if(RRC_FAILURE == response)
        {
            break;
        }

        response = rrc_rrm_il_send_rrc_rrm_measurment_results_ind(
                &rrc_rrm_measurment_results_ind,
                RRC_UECC_MODULE_ID,
                RRC_RRM_MODULE_ID,
                uecc_ue_ctx_get_op_transction_id(p_ue_context),
                p_ue_context->cell_index);
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return response;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_measurment_results_ind
*   INPUT        : uecc_ue_context_t*                  p_ue_context,
*                  rrc_rrm_measurment_results_ind_t*   p_rrc_rrm_measurment_results_ind,
*                  MeasResults*                        p_meas_results
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds RRC_RRM_MEASURMENT_RESULTS_IND message
*       to RRM module
*
*   RETURNS:
*       None
*
******************************************************************************/
rrc_return_et uecc_rrm_build_measurment_results_ind(
    uecc_ue_context_t*                  p_ue_context,
    rrc_rrm_measurment_results_ind_t*   p_rrc_rrm_measurment_results_ind,
    MeasResults*                        p_meas_results)
{
    rrc_return_et   result = RRC_FAILURE;
    OSRTDListNode*      p_node = PNULL;
    U8 list_count = 0;
    /*SPR 15896 Fix Start*/
    /*Code Removed*/
    /*SPR 15896 Fix Stop*/
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_rrc_rrm_measurment_results_ind);
    RRC_ASSERT(PNULL != p_meas_results);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    do
    {
        p_rrc_rrm_measurment_results_ind->ue_index = p_ue_context->ue_index;
        p_rrc_rrm_measurment_results_ind->meas_id = p_meas_results->measId;
        
	/*SPR 15896 Fix Start*/
        if ( p_ue_context->m.traceActivated)
        {
	/*SPR 15875 Fix Start*/
		if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_MME_INITIATE) &&
				(p_ue_context->p_ue_trace_activation_info != PNULL) &&
				(p_ue_context->p_ue_trace_activation_info->interfaces_to_trace & UU) &&
				((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_trace_activation_info->trace_depth) ||
				 (MEDIUM == p_ue_context->p_ue_trace_activation_info->trace_depth)))
		{
		        P_RRC_TRACE(p_ue_context,set_medium_bitmask(), GEN_MME,"\n <msg function=\"Uu\" name=\"MEASUREMENT REPORT\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
					difftime_wrapper(p_ue_context->p_ue_trace_activation_info->rawtime));
		}
		if((p_ue_context->m.traceActivated & RRC_TRACE_ACTIVATION_CELL_INITIATE) &&
				(p_ue_context->p_ue_cell_trace_activation_info != PNULL) &&
				(p_ue_context->p_ue_cell_trace_activation_info->interfaces_to_trace & UU) &&
				((MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION == p_ue_context->p_ue_cell_trace_activation_info->trace_depth) ||
				 (MEDIUM == p_ue_context->p_ue_cell_trace_activation_info->trace_depth)))
		{
		        P_RRC_TRACE(p_ue_context,set_medium_bitmask(), GEN_CELL,"\n <msg function=\"Uu\" name=\"MEASUREMENT REPORT\" changeTime=\"%.3f\" vendorSpecific=\"false\">",
					difftime_wrapper(p_ue_context->p_ue_cell_trace_activation_info->rawtime));
		}
	/*SPR 15875 Fix Stop*/
	/*SPR 15896 Fix Stop*/
        }
         
        p_rrc_rrm_measurment_results_ind->meas_result_serv_cell.rsrp_result =
            p_meas_results->measResultPCell.rsrpResult;

        /* SPR 2614 Start */
        p_rrc_rrm_measurment_results_ind->meas_result_serv_cell.rsrq_result =
            p_meas_results->measResultPCell.rsrqResult;
        /* SPR 2614 Stop */

        result = RRC_SUCCESS;

	/*SPR 15896 Fix Start*/
	if ( p_ue_context->m.traceActivated)
        {
		P_RRC_TRACE(p_ue_context, set_medium_bitmask(),UU,"\n <ie name=\"MeasId\">%d</ie>",p_meas_results->measId);
		P_RRC_TRACE(p_ue_context, set_medium_bitmask(),UU,"\n <ie name=\"RSRP-Range\">%d</ie>",p_meas_results->measResultPCell.rsrpResult);
		P_RRC_TRACE(p_ue_context, set_medium_bitmask(),UU,"\n <ie name=\"RSRQ-Range\">%d</ie>",p_meas_results->measResultPCell.rsrqResult);
		/*SPR 15875 Fix Stop*/
        }
	/*SPR 15896 Fix Stop*/
        if (1 == p_meas_results->m.measResultNeighCellsPresent)
        {
            p_rrc_rrm_measurment_results_ind->bitmask |=
                RRM_MEASURMENT_RESULTS_NEIGH_CELLS_PRESENT;

            switch (p_meas_results->measResultNeighCells.t)
            {
                case T_MeasResults_measResultNeighCells_measResultListEUTRA:
                    p_rrc_rrm_measurment_results_ind->meas_result_neigh_cells.
                    bitmask |= 
                        RRM_MEAS_RESULT_LIST_EUTRA_PRESENT;
                    p_rrc_rrm_measurment_results_ind->meas_result_neigh_cells.
                    meas_result_list_eutra.count =
                        (U8)(p_meas_results->measResultNeighCells.u.
                        measResultListEUTRA->count);
    
                    p_node = p_meas_results->measResultNeighCells.
                        u.measResultListEUTRA->head;
    
                    if ((p_meas_results->measResultNeighCells.u.
                    measResultListEUTRA->count > 
                    ARRSIZE (p_rrc_rrm_measurment_results_ind->
                        meas_result_neigh_cells.meas_result_list_eutra.
                        meas_result_eutra)) ||
                        (p_meas_results->measResultNeighCells.u.
                        measResultListEUTRA->count <1))
                    {
                        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "uecc_rrm_build_meas_results_eutra wrong list count [%u]",
                        p_meas_results->measResultNeighCells.u.
                        measResultListEUTRA->count);
                        break;
                    }        
                    for (list_count = 0; list_count < p_rrc_rrm_measurment_results_ind->
                    meas_result_neigh_cells.meas_result_list_eutra.count;list_count++)
                    {
                        RRC_ASSERT(PNULL != p_node);
                        RRC_ASSERT(PNULL != p_node->data);

                        if(RRC_SUCCESS != uecc_rrm_build_meas_result_eutra(
                                    p_ue_context->p_gb_context,
                                    p_ue_context, 
                                    &p_rrc_rrm_measurment_results_ind->
                                    meas_result_neigh_cells.meas_result_list_eutra.
                                    meas_result_eutra[list_count],
                                    p_node->data))
                        {
                           RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                   (p_ue_context->p_gb_context)->facility_name,
                                   RRC_ERROR,
                                   "[%s]Unable to build Meas Result Utra",__FUNCTION__);   
                        }

                        p_node = p_node->next;
                    }
                    break;
                case T_MeasResults_measResultNeighCells_measResultListUTRA:
                    p_rrc_rrm_measurment_results_ind->meas_result_neigh_cells.
                    bitmask |= 
                        RRM_MEAS_RESULT_LIST_UTRA_PRESENT;

                    p_rrc_rrm_measurment_results_ind->meas_result_neigh_cells.
                    meas_result_list_utra.count=
                        (U8)(p_meas_results->measResultNeighCells.u.
                        measResultListUTRA->count);

                    p_node = p_meas_results->measResultNeighCells.u.
                                 measResultListUTRA->head;
                    if ((p_meas_results->measResultNeighCells.u.
                    measResultListUTRA->count >
                    ARRSIZE(p_rrc_rrm_measurment_results_ind->
                        meas_result_neigh_cells.
                        meas_result_list_utra.meas_result_utra)) ||
                        (p_meas_results->measResultNeighCells.u.
                         measResultListUTRA->count <1))
                    {
                        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "uecc_rrm_build_meas_results_utra wrong list count [%u]",
                            p_meas_results->measResultNeighCells.u.
                            measResultListUTRA->count);
                        break;
                    }    
                    for (list_count = 0; list_count < p_rrc_rrm_measurment_results_ind->
                    meas_result_neigh_cells.meas_result_list_utra.count; list_count++)
                    {
                        RRC_ASSERT(PNULL != p_node);
                        RRC_ASSERT(PNULL != p_node->data);
                        if(RRC_SUCCESS != uecc_rrm_build_meas_result_utra(
                                     &p_rrc_rrm_measurment_results_ind->
                                     meas_result_neigh_cells.
                                     meas_result_list_utra.
                                     meas_result_utra[list_count],
                                     p_node->data,
                                     p_ue_context,
                                     p_ue_context->p_gb_context))
                        {
                           RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                   (p_ue_context->p_gb_context)->facility_name,
                                   RRC_ERROR,
                                   "[%s]Unable to build Meas Result Utra",__FUNCTION__);   
                        }
                        p_node = p_node->next;
                    }    
                    break;
                case T_MeasResults_measResultNeighCells_measResultListGERAN:

                    p_rrc_rrm_measurment_results_ind->meas_result_neigh_cells.
                    bitmask |= 
                        RRM_MEAS_RESULT_LIST_GERAN_PRESENT;

                    p_rrc_rrm_measurment_results_ind->meas_result_neigh_cells.
                    meas_result_list_geran.count=
                        (U8)(p_meas_results->measResultNeighCells.u.
                        measResultListGERAN->count);

                   
                    p_node = p_meas_results->measResultNeighCells.u.
                                 measResultListGERAN->head;
                    if ((p_meas_results->measResultNeighCells.u.
                        measResultListGERAN->count >
                        ARRSIZE(p_rrc_rrm_measurment_results_ind->
                        meas_result_neigh_cells.
                        meas_result_list_geran.meas_result_geran)) ||
                        (p_meas_results->measResultNeighCells.u.
                         measResultListGERAN->count <1))
                    {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "uecc_rrm_build_meas_results_geran wrong list count [%u]",
                        p_meas_results->measResultNeighCells.u.
                        measResultListGERAN->count);
                        break;
                    }    

                   for (list_count = 0; list_count < p_rrc_rrm_measurment_results_ind->
                    meas_result_neigh_cells.meas_result_list_geran.count; list_count++)
                    {
                        RRC_ASSERT(PNULL != p_node);
                        RRC_ASSERT(PNULL != p_node->data);
                        result = uecc_rrm_build_meas_result_geran(
                                     p_ue_context, 
                                     &p_rrc_rrm_measurment_results_ind->
                                     meas_result_neigh_cells.
                                     meas_result_list_geran.
                                     meas_result_geran[list_count],
                                     p_node->data);
                        if (RRC_FAILURE == result)
                        {
                            break;
                        }    
                        p_node = p_node->next;
                    }    
                    break;

                case T_MeasResults_measResultNeighCells_measResultsCDMA2000:
                    p_rrc_rrm_measurment_results_ind->meas_result_neigh_cells.
                    bitmask = RRM_MEAS_RESULTS_CDMA2000_PRESENT;

                    result = uecc_rrm_build_meas_results_cdma2000(
                                 &p_rrc_rrm_measurment_results_ind->
                                 meas_result_neigh_cells.meas_result_cdma2000,
                                 p_meas_results->
                                 measResultNeighCells.u.measResultsCDMA2000,
                                 p_ue_context,
                                 p_ue_context->p_gb_context);
                    break;

                #ifdef ENDC_ENABLED
                case T_MeasResults_measResultNeighCells_measResultNeighCellListNR_r15:
                    p_rrc_rrm_measurment_results_ind->meas_result_neigh_cells.
                    bitmask |= RRM_MEAS_RESULT_LIST_NR_R15_PRESENT;
                    p_rrc_rrm_measurment_results_ind->meas_result_neigh_cells.
                    meas_result_list_nr_r15.count=
                        (U8)(p_meas_results->measResultNeighCells.u.
                         measResultNeighCellListNR_r15->count);
                    
                    if ((p_meas_results->measResultNeighCells.u.
                        measResultNeighCellListNR_r15->count >
                        ARRSIZE(p_rrc_rrm_measurment_results_ind->
                        meas_result_neigh_cells.
                        meas_result_list_nr_r15.meas_result_nr)) ||
                        (p_meas_results->measResultNeighCells.u.
                          measResultNeighCellListNR_r15->count <1))
                    {
                        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                (p_ue_context->p_gb_context)->facility_name,
                                RRC_WARNING,
                                "uecc_rrm_build_meas_results_nr wrong list count [%u]",
                                p_meas_results->measResultNeighCells.u.
                                measResultNeighCellListNR_r15->count);
                        break;
                    }    
                    
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                                (p_ue_context->p_gb_context)->facility_name,
                                RRC_DETAILED,
                                "uecc_rrm_build_meas_results_nr count [%u]",
                                p_meas_results->measResultNeighCells.u.
                                measResultNeighCellListNR_r15->count);
                    
                    p_node = p_meas_results->measResultNeighCells.
                        u.measResultNeighCellListNR_r15->head;
                   
                   for (list_count = 0; list_count < p_rrc_rrm_measurment_results_ind->
                    meas_result_neigh_cells.meas_result_list_nr_r15.count; list_count++)
                    {
                        RRC_ASSERT(PNULL != p_node);
                        RRC_ASSERT(PNULL != p_node->data);

                        result = uecc_rrm_build_meas_result_nr(
                                     p_ue_context, 
                                     &p_rrc_rrm_measurment_results_ind->
                                     meas_result_neigh_cells.
                                     meas_result_list_nr_r15.
                                     meas_result_nr[list_count],
                                     p_node->data);
                        if (RRC_FAILURE == result)
                        {
                            break;
                        }    
                        p_node = p_node->next;
                    }    
                break;
                #endif
                default:
                    break;
            }
        }

        if(1 == p_meas_results->m.measResultForECID_r9Present)
        {
            p_rrc_rrm_measurment_results_ind->bitmask |=
                RRM_MEASURMENT_RESULTS_FOR_ECID_R9_PRESENT;
            p_rrc_rrm_measurment_results_ind->meas_result_ecid_r9.ue_rxtx_time_diff_result = 
                p_meas_results->measResultForECID_r9.ue_RxTxTimeDiffResult_r9;
            l3_memcpy_wrapper(p_rrc_rrm_measurment_results_ind->meas_result_ecid_r9.current_sfn_r9,
                       p_meas_results->measResultForECID_r9.currentSFN_r9.data,
                       ECID_CURRENT_SFN_R9_OCTET_SIZE);
        }
        /* MeasResultServFreq-r10 changes start */
        
        if(1 == p_meas_results->m.measResultServFreqList_r10Present)
        {
            p_rrc_rrm_measurment_results_ind->bitmask |=
                RRM_MEASURMENT_RESULTS_SERV_FREQ_LIST_R10_PRESENT;

            if(RRC_SUCCESS != process_uecc_rrm_meas_result_servfreqlist(
                              p_ue_context,
                              p_rrc_rrm_measurment_results_ind,
                              p_meas_results))
            {
                     RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                             (p_ue_context->p_gb_context)->facility_name,
                             RRC_ERROR,
                             "[%s]Unable to process Meas Result ServFreqList",__FUNCTION__);  
                     result = RRC_FAILURE;
                     break;
            }
        }
        /* MeasResultServFreq-r10 changes stop */
 

        /* bug_7798 fix */
	/*SPR 15896 Fix Start*/
	if ( p_ue_context->m.traceActivated)
        {
            P_RRC_TRACE(p_ue_context,set_medium_bitmask(), UU,"\n </msg>");
	 /*SPR 15896 Fix Stop*/
        }
        /* bug_7798 fix */
        /* MeasResultServFreq-r10 changes start */
        
        if(1 == p_meas_results->m.measResultServFreqList_r10Present)
        {
            p_rrc_rrm_measurment_results_ind->bitmask |=
                RRM_MEASURMENT_RESULTS_SERV_FREQ_LIST_R10_PRESENT;

            if(RRC_SUCCESS != process_uecc_rrm_meas_result_servfreqlist(
                              p_ue_context,
                              p_rrc_rrm_measurment_results_ind,
                              p_meas_results))
            {
                     RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                             (p_ue_context->p_gb_context)->facility_name,
                             RRC_ERROR,
                             "[%s]Unable to process Meas Result ServFreqList",__FUNCTION__);  
                     result = RRC_FAILURE;
                     break;
            }
        }
        /* MeasResultServFreq-r10 changes stop */


    }
    while(0);
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_results_cdma2000
*   INPUT        : meas_results_cdma2000_t*    p_meas_results_cdma2000,
*                  MeasResultsCDMA2000*        p_asn_meas_results_cdma2000,
*                  uecc_ue_context_t*          p_ue_context,
*                  uecc_gb_context_t*          p_uecc_gb_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds meas_results_cdma2000_t in
*       RRC_RRM_MEASURMENT_RESULTS_IND message
*
*   RETURNS:
*       None
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_results_cdma2000(
    meas_results_cdma2000_t*    p_meas_results_cdma2000,
    MeasResultsCDMA2000*        p_asn_meas_results_cdma2000,
    uecc_ue_context_t*          p_ue_context,
    uecc_gb_context_t*          p_uecc_gb_context
    )
{
    rrc_return_et       result = RRC_FAILURE;
    OSRTDListNode*      p_node = PNULL;
    U8 i = 0;

    RRC_ASSERT(PNULL != p_meas_results_cdma2000);
    RRC_ASSERT(PNULL != p_asn_meas_results_cdma2000);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        p_meas_results_cdma2000->pre_registration_status_hrpd =
            p_asn_meas_results_cdma2000->preRegistrationStatusHRPD;
       /*SPR 15896 Fix Start*/ 
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PreRegistrationStatusHRPD\">%d</ie>",p_meas_results_cdma2000->pre_registration_status_hrpd);                               
       /*SPR 15896 Fix Stop*/ 

        if( (p_asn_meas_results_cdma2000->measResultListCDMA2000.count >
            ARRSIZE(p_meas_results_cdma2000->
                meas_result_list_cdma2000.meas_result_cdma2000)) ||
            (p_asn_meas_results_cdma2000->measResultListCDMA2000.count < 1) )
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_meas_results_cdma2000 wrong list count [%u]",
                p_asn_meas_results_cdma2000->measResultListCDMA2000.count);
            break;
        }

        p_meas_results_cdma2000->meas_result_list_cdma2000.count =
            (U8)p_asn_meas_results_cdma2000->measResultListCDMA2000.count;

       /*SPR 15896 Fix Start*/ 
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"MeasResultListCDMA2000\">");
       /*SPR 15896 Fix Stop*/ 

        p_node = p_asn_meas_results_cdma2000->measResultListCDMA2000.head;

        for(i=0;i<p_meas_results_cdma2000->meas_result_list_cdma2000.count;i++)
        {
            RRC_ASSERT(PNULL != p_node);
            RRC_ASSERT(PNULL != p_node->data);

            result = uecc_rrm_build_meas_result_cdma2000(
                    &p_meas_results_cdma2000->
                        meas_result_list_cdma2000.meas_result_cdma2000[i],
                    p_node->data,
                    p_ue_context,
                    p_uecc_gb_context);

            if(RRC_FAILURE == result)
            {
                break;
            }

            p_node = p_node->next;
        }
        
       /*SPR 15896 Fix Start*/ 
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup>");//MeasResultListCDMA2000
       /*SPR 15896 Fix Stop*/ 
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_result_cdma2000
*   INPUT        : meas_result_cdma2000_t* p_meas_result_cdma2000,
*                  MeasResultCDMA2000*     p_asn_meas_result_cdma2000,
*                  uecc_ue_context_t*      p_ue_context,
*                  uecc_gb_context_t*      p_uecc_gb_context
*   OUTPUT       : none            
*   DESCRIPTION:
*       This function builds meas_result_cdma2000_t in
*       RRC_RRM_MEASURMENT_RESULTS_IND message
*
*   RETURNS:
*       None
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_result_cdma2000(
    meas_result_cdma2000_t* p_meas_result_cdma2000,
    MeasResultCDMA2000*     p_asn_meas_result_cdma2000,
    uecc_ue_context_t*      p_ue_context,
    uecc_gb_context_t*      p_uecc_gb_context)
{
    rrc_return_et   result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_meas_result_cdma2000);
    RRC_ASSERT(PNULL != p_asn_meas_result_cdma2000);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    p_meas_result_cdma2000->phy_cell_id =
        p_asn_meas_result_cdma2000->physCellId;
        
       /*SPR 15896 Fix Start*/ 
    P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PhysCellIdCDMA2000\">%d</ie>",p_meas_result_cdma2000->phy_cell_id);
       /*SPR 15896 Fix Stop*/ 

    if(1 == p_asn_meas_result_cdma2000->m.cgi_InfoPresent)
    {
       /*SPR 15896 Fix Start*/ 
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"Cgi-Info\">");                               
       /*SPR 15896 Fix Stop*/ 
        
        p_meas_result_cdma2000->bitmask = MEAS_RESULT_CDMA2000_CGI_INFO_PRESENT;
        switch(p_asn_meas_result_cdma2000->cgi_Info.t)
        {
            case T_CellGlobalIdCDMA2000_cellGlobalId1XRTT:
                p_meas_result_cdma2000->cgi_info.bitmask =
                    CELL_GLOBAL_ID_CDMA2000_1XRTT_PRESENT;

                if(ARRSIZE(p_asn_meas_result_cdma2000->
                       cgi_Info.u.cellGlobalId1XRTT->data) >
                   ARRSIZE(p_meas_result_cdma2000->
                        cgi_info.cell_global_id_1xrtt))
                {
                    break;
                }

                l3_memcpy_wrapper(p_meas_result_cdma2000->cgi_info.
                    cell_global_id_1xrtt,
                    p_asn_meas_result_cdma2000->
                        cgi_Info.u.cellGlobalId1XRTT->data,
                 ARRSIZE(p_meas_result_cdma2000->
                         cgi_info.cell_global_id_1xrtt));
    
       /*SPR 15896 Fix Start*/ 
                P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"CellGlobalId1XRTT\">%02x%02x%02x%02x%02x%02x</ie>",
                             p_meas_result_cdma2000->cgi_info.cell_global_id_1xrtt[0],
                             p_meas_result_cdma2000->cgi_info.cell_global_id_1xrtt[1],
                             p_meas_result_cdma2000->cgi_info.cell_global_id_1xrtt[2],
                             p_meas_result_cdma2000->cgi_info.cell_global_id_1xrtt[3],
                             p_meas_result_cdma2000->cgi_info.cell_global_id_1xrtt[4],
                             p_meas_result_cdma2000->cgi_info.cell_global_id_1xrtt[5]>>1);
       /*SPR 15896 Fix Stop*/ 

                result = RRC_SUCCESS;
                break;

            case T_CellGlobalIdCDMA2000_cellGlobalIdHRPD:
                p_meas_result_cdma2000->cgi_info.bitmask =
                    CELL_GLOBAL_ID_CDMA2000_HRPD_PRESENT;

                if(ARRSIZE(p_asn_meas_result_cdma2000->
                       cgi_Info.u.cellGlobalIdHRPD->data) >
                   ARRSIZE(p_meas_result_cdma2000->
                       cgi_info.cell_global_id_hrpd))
                {
                    break;
                }

                l3_memcpy_wrapper(p_meas_result_cdma2000->cgi_info.cell_global_id_hrpd,
                    p_asn_meas_result_cdma2000->
                        cgi_Info.u.cellGlobalIdHRPD->data,
                   ARRSIZE(p_meas_result_cdma2000->
                        cgi_info.cell_global_id_hrpd));

       /*SPR 15896 Fix Start*/ 
                P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"CellGlobalIdHRPD\">%02x%02x%02x%02x%02x%02x</ie>",
                                           p_meas_result_cdma2000->cgi_info.cell_global_id_hrpd[0],
                                           p_meas_result_cdma2000->cgi_info.cell_global_id_hrpd[1],
                                           p_meas_result_cdma2000->cgi_info.cell_global_id_hrpd[2],
                                           p_meas_result_cdma2000->cgi_info.cell_global_id_hrpd[3],
                                           p_meas_result_cdma2000->cgi_info.cell_global_id_hrpd[4],
                                           p_meas_result_cdma2000->cgi_info.cell_global_id_hrpd[5]>>1);
       /*SPR 15896 Fix Stop*/ 
                result = RRC_SUCCESS;
                break;

            default:
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_build_meas_result_cdma2000 -> wrong bitmask");
                break;
        }

       /*SPR 15896 Fix Start*/ 
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup>");//Cgi-Info                               
       /*SPR 15896 Fix Stop*/ 
    }
    else
    {
        result = RRC_SUCCESS;
    }

       /*SPR 15896 Fix Start*/ 
    P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"MeasResult\">");                               
       /*SPR 15896 Fix Stop*/ 
    if(1 == p_asn_meas_result_cdma2000->measResult.m.pilotPnPhasePresent)
    {
        p_meas_result_cdma2000->meas_result.bitmask =
            MEAS_RESULT_CDMA2000_PILOT_PN_PHASE_PRESENT;

        p_meas_result_cdma2000->meas_result.pilot_pn_phase =
            p_asn_meas_result_cdma2000->measResult.pilotPnPhase;
       /*SPR 15896 Fix Start*/ 
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PilotPnPhase\">%d</ie>",p_meas_result_cdma2000->meas_result.pilot_pn_phase); 
       /*SPR 15896 Fix Stop*/ 
    }
    p_meas_result_cdma2000->meas_result.pilot_strength =
        p_asn_meas_result_cdma2000->measResult.pilotStrength;
       
    /*SPR 15896 Fix Start*/ 
    if ( p_ue_context->m.traceActivated)
    {
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PilotStrength\">%d</ie>",p_meas_result_cdma2000->meas_result.pilot_strength); 
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup>"); //MeasResult                               
     /*SPR 15896 Fix Stop*/ 
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    
    return result;
}

/* MeasResultServFreq-r10 changes start */
/******************************************************************************************
*   FUNCTION NAME: process_uecc_rrm_meas_result_servfreqlist
*   INPUT        : uecc_ue_context_t*                  p_ue_context
*                  rrc_rrm_measurment_results_ind_t    p_rrc_rrm_measurment_results_ind
*                  MeasResults*                        p_meas_results
*
*   OUTPUT       : None
*   DESCRIPTION:
*       This function processes  measurment report to build SERV_FREQ_LIST in
*       RRC_RRM_MEASURMENT_RESULTS_IND message
*
*   RETURNS      : RRC_SUCCESS/RRC_FAILURE
*
********************************************************************************************/
static rrc_return_et process_uecc_rrm_meas_result_servfreqlist(
    uecc_ue_context_t*                  p_ue_context,
    rrc_rrm_measurment_results_ind_t*   p_rrc_rrm_measurment_results_ind,
    MeasResults*                        p_meas_results)
{
    rrc_return_et       result = RRC_SUCCESS;
    OSRTDListNode*      p_node = PNULL;
    U8 list_count = 0;
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_rrc_rrm_measurment_results_ind);
    RRC_ASSERT(PNULL != p_meas_results);
    
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    
    p_rrc_rrm_measurment_results_ind->meas_result_serv_freq_list_r10.count =
        (U8)(p_meas_results->measResultServFreqList_r10.count);

    p_node = p_meas_results->measResultServFreqList_r10.head;

    if ((p_meas_results->measResultServFreqList_r10.count > 
                ARRSIZE(p_rrc_rrm_measurment_results_ind->
                    meas_result_serv_freq_list_r10.rrc_meas_result_serv_freq_r10)) ||
            (p_meas_results->measResultServFreqList_r10.count < 1))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_meas_results_servfreqlist wrong list count [%u]",
                p_meas_results->measResultServFreqList_r10.count);
        result = RRC_FAILURE;
        return result;
    }

    for (list_count = 0; list_count < p_rrc_rrm_measurment_results_ind->
            meas_result_serv_freq_list_r10.count;list_count++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        uecc_rrm_build_meas_result_serv_freq(
                    p_ue_context->p_gb_context,
                    p_ue_context, 
                    &p_rrc_rrm_measurment_results_ind->
                    meas_result_serv_freq_list_r10.rrc_meas_result_serv_freq_r10[list_count],
                    p_node->data);
        
        p_node = p_node->next;

    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/*******************************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_result_serv_freq
*   INPUT        : uecc_gb_context_t*      p_uecc_gb_context,
*                  uecc_ue_context_t       *p_ue_context,
*                  meas_result_serv_freq_t*    p_meas_result_serv_freq,
*                  MeasResultServFreq_r10*     p_asn_meas_results_servfreq)
*
*   OUTPUT       : None
*   DESCRIPTION:
*       This function build measurment report for SERV_FREQ_LIST in
*       RRC_RRM_MEASURMENT_RESULTS_IND message
*
*   RETURNS      : None
*
***********************************************************************************************/
static void uecc_rrm_build_meas_result_serv_freq(
    uecc_gb_context_t*          p_uecc_gb_context,
    uecc_ue_context_t*          p_ue_context,
    rrc_meas_result_serv_freq_r10_t*    p_meas_result_serv_freq,
    MeasResultServFreq_r10*     p_asn_meas_results_servfreq)
{
    
    
    RRC_ASSERT(PNULL != p_meas_result_serv_freq);
    RRC_ASSERT(PNULL != p_asn_meas_results_servfreq);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
  
    /* Filling phys_cell_id and serv_cell_id */
    p_meas_result_serv_freq->meas_result_best_neigh_cell_r10.phys_cell_id_r10 =
        p_asn_meas_results_servfreq->measResultBestNeighCell_r10.physCellId_r10;
    IF_TRACE_IS_MEDIUM            
    {
        /*coverity_88133_87953_fix_start*/
        P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n <ie name=\"PhysCellId\">%d</ie>",
          p_meas_result_serv_freq->meas_result_best_neigh_cell_r10.phys_cell_id_r10);
        /*coverity_88133_87953_fix_end*/
    }
    p_meas_result_serv_freq->serv_cell_index_r10 = p_asn_meas_results_servfreq->servFreqId_r10;
    /*coverity_88133_87953_fix_start*/
    P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n <ie name=\"ServCellIndex\">%d</ie>",
          p_meas_result_serv_freq->serv_cell_index_r10);
    /*coverity_88133_87953_fix_end*/

    /* Filling secondary cell's RSRP and RSRQ results */
    p_meas_result_serv_freq->meas_result_scell_r10.rsrp_result_r10 = 
        p_asn_meas_results_servfreq->measResultSCell_r10.rsrpResultSCell_r10;
    IF_TRACE_IS_MEDIUM
    {
        /*coverity_88133_87953_fix_start*/
        P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n <ie name=\"RSRP-Range\">%d</ie>",
          p_meas_result_serv_freq->meas_result_scell_r10.rsrp_result_r10);
        /*coverity_88133_87953_fix_end*/
    }
    p_meas_result_serv_freq->meas_result_scell_r10.rsrq_result_r10 = 
        p_asn_meas_results_servfreq->measResultSCell_r10.rsrqResultSCell_r10;
    IF_TRACE_IS_MEDIUM
    {
    /*coverity_88133_87953_fix_start*/    
    P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n <ie name=\"RSRQ-Range\">%d</ie>",
          p_meas_result_serv_freq->meas_result_scell_r10.rsrq_result_r10);
    /*coverity_88133_87953_fix_end*/
    }
    /* Filling best neighbour cell's RSRP and RSRQ results */
    p_meas_result_serv_freq->meas_result_best_neigh_cell_r10.best_neigh_cell_r10.rsrp_result_r10 = 
        p_asn_meas_results_servfreq->measResultBestNeighCell_r10.rsrpResultNCell_r10;
    IF_TRACE_IS_MEDIUM
    {
    /*coverity_88133_87953_fix_start*/    
    P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n <ie name=\"RSRP-Range\">%d</ie>",
        p_meas_result_serv_freq->
        meas_result_best_neigh_cell_r10.best_neigh_cell_r10.rsrp_result_r10);                               
    /*coverity_88133_87953_fix_end*/
    }
    p_meas_result_serv_freq->meas_result_best_neigh_cell_r10.best_neigh_cell_r10.rsrq_result_r10 = 
        p_asn_meas_results_servfreq->measResultBestNeighCell_r10.rsrqResultNCell_r10;
    IF_TRACE_IS_MEDIUM
    {
    /*coverity_88133_87953_fix_start*/    
    P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n <ie name=\"RSRQ-Range\">%d</ie>",
        p_meas_result_serv_freq->
        meas_result_best_neigh_cell_r10.best_neigh_cell_r10.rsrq_result_r10);                               
    /*coverity_88133_87953_fix_end*/
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}
/* MeasResultServFreq-r10 changes stop */

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_result_eutra
*   INPUT        : uecc_gb_context_t*      p_uecc_gb_context,
*                  uecc_ue_context_t       *p_ue_context,
*                  meas_result_eutra_t*    p_meas_result_eutra,
*                  MeasResultEUTRA*        p_asn_meas_results_eutra
*   OUTPUT       : none
*   DESCRIPTION:
*       This function build measurment report for EUTRA RAT in
*       RRC_RRM_MEASURMENT_RESULTS_IND message
*
*   RETURNS:
*       None
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_result_eutra(
    uecc_gb_context_t*      p_uecc_gb_context,
    uecc_ue_context_t       *p_ue_context,
    meas_result_eutra_t*    p_meas_result_eutra,
    MeasResultEUTRA*        p_asn_meas_results_eutra)
{
    OSRTDListNode*      p_node = PNULL;
    rrc_return_et   result = RRC_SUCCESS;
    U8 eutra_count = 0;
    
    RRC_ASSERT(PNULL != p_meas_result_eutra);
    RRC_ASSERT(PNULL != p_asn_meas_results_eutra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
   
    p_meas_result_eutra->phys_cell_id =p_asn_meas_results_eutra->physCellId;
    
       /*SPR 15896 Fix Start*/ 
    P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PhysCellId\">%d</ie>",p_meas_result_eutra->phys_cell_id);
       /*SPR 15896 Fix Stop*/ 

    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                   p_uecc_gb_context->facility_name,
                    RRC_INFO,"p_asn_meas_results_eutra->m.cgi_InfoPresent = %d", p_asn_meas_results_eutra->m.cgi_InfoPresent);
    if (1 == p_asn_meas_results_eutra->m.cgi_InfoPresent)
    {
        result = RRC_FAILURE;
        p_meas_result_eutra->bitmask |= MEAS_RESULT_EUTRA_CGI_INFO_PRESENT;
              
	/*SPR 15896 Fix Start*/
	if ( p_ue_context->m.traceActivated)
	{
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"Cgi-Info\">");
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"CellGlobalIdEUTRA\">");
        }
       /*SPR 15896 Fix Stop*/ 
        /* To get Cell ID and store it in UECC structure of EUTRA */
        l3_memcpy_wrapper(p_meas_result_eutra->cgi_info.
                cell_global_id.cell_identity,
                p_asn_meas_results_eutra->
                cgi_Info.cellGlobalId.cellIdentity.data,
                ARRSIZE(p_meas_result_eutra->
                    cgi_info.cell_global_id.cell_identity)); 

        /* to add plmn information*/    
        uecc_rrm_build_meas_result_eutra_plmn_info(
                    p_uecc_gb_context,
                    p_ue_context, 
                    p_meas_result_eutra, 
                    p_asn_meas_results_eutra);  

        IF_TRACE_IS_MEDIUM
        {
            /*Coverity_87975_fix_start*/
            P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n <ie name=\"CellIdentity\">%02x%02x%02x%x</ie>",
            /*Coverity_87975_fix_end*/        
                p_asn_meas_results_eutra->cgi_Info.cellGlobalId.cellIdentity.data[0],
                p_asn_meas_results_eutra->cgi_Info.cellGlobalId.cellIdentity.data[1],
                p_asn_meas_results_eutra->cgi_Info.cellGlobalId.cellIdentity.data[2],
                p_asn_meas_results_eutra->cgi_Info.cellGlobalId.cellIdentity.data[3]>>4);
            P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n </ieGroup>"); //CellGlobalIdEUTRA ieGroup Closed.
        }
        /* To get Tracking area code and store it in UECC structre for EUTRA */
        l3_memcpy_wrapper(p_meas_result_eutra->cgi_info.tracking_area_code,
                p_asn_meas_results_eutra->cgi_Info.trackingAreaCode.data,
                ARRSIZE(p_meas_result_eutra->cgi_info.tracking_area_code));
        
        IF_TRACE_IS_MEDIUM 
        /*Coverity_87975_fix_start*/
        P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n <ie name=\"TrackingAreaCode\">%02x%02x</ie>",
        /*Coverity_87975_fix_end*/        
                p_meas_result_eutra->cgi_info.tracking_area_code[0],
                p_meas_result_eutra->cgi_info.tracking_area_code[1]);

        if (1 == p_asn_meas_results_eutra->cgi_Info.m.plmn_IdentityListPresent)
        {
            p_meas_result_eutra->cgi_info.bitmask |= 
                MEAS_RESULT_EUTRA_CGI_INFO_PLMN_IDENTITY_LIST_PRESENT;
            p_meas_result_eutra->cgi_info.plmn_identity_list.count =
                (U8)(p_asn_meas_results_eutra->cgi_Info.plmn_IdentityList.count);
            p_node = p_asn_meas_results_eutra->cgi_Info.plmn_IdentityList.head;
            
            for (eutra_count = 0; eutra_count < p_meas_result_eutra->cgi_info.
            plmn_identity_list.count; eutra_count++)
            {
                RRC_ASSERT(PNULL != p_node);
                RRC_ASSERT(PNULL != p_node->data);
                uecc_rrm_build_meas_result_eutra_plmn_list2_info(
                             p_uecc_gb_context,
                             p_ue_context, 
                             &p_meas_result_eutra->cgi_info.plmn_identity_list.
                             cell_identity[eutra_count], 
                             p_node->data);
                /* SPR 13769 Fix Start */
                p_node = p_node->next;
                /* SPR 13769 Fix Stop */
            } 
        }
            
        IF_TRACE_IS_MEDIUM 
        P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n </ieGroup>");// Cgi-Info Closed.

        result = RRC_SUCCESS;
    }
   
    IF_TRACE_IS_MEDIUM
    P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n <ieGroup name=\"MeasResult\">");                               
    if (1 == p_asn_meas_results_eutra->measResult.m.rsrpResultPresent)
    {
        p_meas_result_eutra->meas_result.bitmask |= 
            MEAS_RESULT_EUTRA_MEAS_RESULT_RSRP_PRESENT;
        p_meas_result_eutra->meas_result.rsrp_result = 
            p_asn_meas_results_eutra->measResult.rsrpResult;  
        IF_TRACE_IS_MEDIUM
        /*coverity_88127_fix_start*/    
        P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n <ie name=\"RSRP-Range\">%d</ie>",p_meas_result_eutra->meas_result.rsrp_result);
        /*coverity_88127_fix_end*/
    }
    if (1 == p_asn_meas_results_eutra->measResult.m.rsrqResultPresent)
    {
        p_meas_result_eutra->meas_result.bitmask |= 
            MEAS_RESULT_EUTRA_MEAS_RESULT_RSRQ_PRESENT;
        p_meas_result_eutra->meas_result.rsrq_result =
            p_asn_meas_results_eutra->measResult.rsrqResult; 
        IF_TRACE_IS_MEDIUM
        /*coverity_88127_fix_start*/    
        P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n <ie name=\"RSRQ-Range\">%d</ie>",p_meas_result_eutra->meas_result.rsrq_result);                              
        /*coverity_88127_fix_end*/ 
    }
    
    /* Send CSG Info to RRM */
    if (1 == p_asn_meas_results_eutra->measResult.m.additionalSI_Info_r9Present)
    {
        p_meas_result_eutra->bitmask |= 
            MEAS_RESULT_EUTRA_CSG_INFO_PRESENT;

        IF_TRACE_IS_MEDIUM
        P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n <ieGroup name=\"AdditionalSI-Info-r9\">");                               

        if (1 == p_asn_meas_results_eutra->measResult.additionalSI_Info_r9.
                m.csg_MemberStatus_r9Present)
        {
            p_meas_result_eutra->eutra_csg_info.bitmask |= 
                MEAS_RESULT_EUTRA_MEAS_RESULT_CSG_MEM_STATUS_PRESENT;

            p_meas_result_eutra->eutra_csg_info.csg_membershipStatus =
                (U8)p_asn_meas_results_eutra->measResult.additionalSI_Info_r9.
                csg_MemberStatus_r9; 
    
            IF_TRACE_IS_MEDIUM
            /*coverity_88127_fix_start*/
            P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n  <ie name=\"Csg-MemberStatus-r9\">%d</ie>",p_meas_result_eutra->eutra_csg_info.csg_membershipStatus); 
            /*coverity_88127_fix_end*/
        }
        if (1 == p_asn_meas_results_eutra->measResult.additionalSI_Info_r9.
                m.csg_Identity_r9Present)
        {
            p_meas_result_eutra->eutra_csg_info.bitmask |= 
                MEAS_RESULT_EUTRA_MEAS_RESULT_CSG_ID_PRESENT;

           l3_memcpy_wrapper( &(p_meas_result_eutra->eutra_csg_info.csg_identity),
                p_asn_meas_results_eutra->measResult.additionalSI_Info_r9.
                csg_Identity_r9.data,  sizeof(U8)*CSG_ID_OCTET_SIZE);
            
           p_meas_result_eutra->eutra_csg_info.csg_identity[CSG_ID_OCTET_SIZE-1] &= CSG_RESET_VAL;

        IF_TRACE_IS_MEDIUM
            /*Coverity_87975_fix_start*/
           P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n  <ie name=\"Csg-Identity-r9\">%02x%02x%02x%02x</ie>",
            /*Coverity_87975_fix_end*/       
                              p_meas_result_eutra->eutra_csg_info.csg_identity[0],
                              p_meas_result_eutra->eutra_csg_info.csg_identity[1],
                              p_meas_result_eutra->eutra_csg_info.csg_identity[2],
                              p_meas_result_eutra->eutra_csg_info.csg_identity[3]>>5);
        }

        IF_TRACE_IS_MEDIUM
        P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n </ieGroup>"); //AdditionalSI-Info-r9 Closed                               
    }
    IF_TRACE_IS_MEDIUM
    P_RRC_TRACE(p_ue_context,set_medium_bitmask(),UU,"\n </ieGroup>");//MeasResult Closed                               


    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/******************************************************************************
*   FUNCTION NAME:uecc_rrm_build_meas_result_eutra_plmn_info
*   INPUT        : uecc_gb_context_t*      p_uecc_gb_context,
*                  uecc_ue_context_t       *p_ue_context,
*                  meas_result_eutra_t*    p_meas_result_eutra,
*                  MeasResultEUTRA*        p_asn_meas_results_eutra
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds PLMN info in eutra_measurment_result
*       RRC_RRM_MEASURMENT_RESULTS_IND message
*
*   RETURNS:
*       None
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_result_eutra_plmn_info(
    uecc_gb_context_t*      p_uecc_gb_context,
    uecc_ue_context_t       *p_ue_context,
    meas_result_eutra_t*    p_meas_result_eutra,
    MeasResultEUTRA*        p_asn_meas_results_eutra)
{
    rrc_return_et   result = RRC_FAILURE;
    
    RRC_ASSERT(PNULL != p_meas_result_eutra);
    RRC_ASSERT(PNULL != p_asn_meas_results_eutra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
  
    if (p_asn_meas_results_eutra->
    cgi_Info.cellGlobalId.plmn_Identity.m.mccPresent == 1)
    {
        p_meas_result_eutra->cgi_info.cell_global_id.
            plmn_identity.presence_bitmask |= 
            PLMN_IDENTITY_MCC_PRESENCE_FLAG;

        /* SPR 2611 Start */

        l3_memcpy_wrapper(p_meas_result_eutra->cgi_info.
                cell_global_id.plmn_identity.mcc,
                p_asn_meas_results_eutra->
                cgi_Info.cellGlobalId.plmn_Identity.mcc.elem,
                MCC_OCTET_SIZE);
       /*SPR 15896 Fix Start*/ 
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"PLMN-IdentityList\"> ");
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MCC\">%02x%02x%02x</ie>",
                p_asn_meas_results_eutra->cgi_Info.cellGlobalId.plmn_Identity.mcc.elem[0],
                p_asn_meas_results_eutra->cgi_Info.cellGlobalId.plmn_Identity.mcc.elem[1],
                p_asn_meas_results_eutra->cgi_Info.cellGlobalId.plmn_Identity.mcc.elem[2]);
       /*SPR 15896 Fix Stop*/ 
        /* SPR 2611 Stop */
    }
    /* SPR 2611 Start*/

    l3_memcpy_wrapper(p_meas_result_eutra->cgi_info.
            cell_global_id.plmn_identity.mnc.mnc,
            p_asn_meas_results_eutra->
            cgi_Info.cellGlobalId.plmn_Identity.mnc.elem,
            p_asn_meas_results_eutra->
            cgi_Info.cellGlobalId.plmn_Identity.mnc.n);

    p_meas_result_eutra->cgi_info.cell_global_id.plmn_identity.mnc.count = 
        (U8)(p_asn_meas_results_eutra->
             cgi_Info.cellGlobalId.plmn_Identity.mnc.n);
    /* SPR 2611 Stop */

    /*SPR 15896 Fix Start*/
    if ( p_ue_context->m.traceActivated)
    {
        if( p_asn_meas_results_eutra->cgi_Info.cellGlobalId.plmn_Identity.mnc.n == 2)
        {
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MNC\">%02x%02x</ie>",
                p_asn_meas_results_eutra->cgi_Info.cellGlobalId.plmn_Identity.mnc.elem[0],
                p_asn_meas_results_eutra->cgi_Info.cellGlobalId.plmn_Identity.mnc.elem[1]);
        }
        else if(p_asn_meas_results_eutra->cgi_Info.cellGlobalId.plmn_Identity.mnc.n == 3)
        {
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MNC\">%02x%02x%02x</ie>",
                p_asn_meas_results_eutra->cgi_Info.cellGlobalId.plmn_Identity.mnc.elem[0],
                p_asn_meas_results_eutra->cgi_Info.cellGlobalId.plmn_Identity.mnc.elem[1],
                p_asn_meas_results_eutra->cgi_Info.cellGlobalId.plmn_Identity.mnc.elem[2]);
        }
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup> ");//PLMN-IdentityList
       /*SPR 15896 Fix Stop*/ 
    }

    result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/******************************************************************************
*   FUNCTION NAME:uecc_rrm_build_meas_result_eutra_plmn_list2_info
*   INPUT        :uecc_gb_context_t*      p_uecc_gb_context,
*                 uecc_ue_context_t       *p_ue_context,
*                 plmn_identity_t* p_rrc_rrm_meas_eutra_plmn,
*                 PLMN_Identity*   p_asn_Meas_result_eutra_plmn
*   OUTPUT        none
*   DESCRIPTION:
*       This function builds PLMN list2 info in eutra_measurment_result
*       RRC_RRM_MEASURMENT_RESULTS_IND message
*
*   RETURNS:
*       None
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_result_eutra_plmn_list2_info(
    uecc_gb_context_t*      p_uecc_gb_context,
    uecc_ue_context_t       *p_ue_context,
    plmn_identity_t* p_rrc_rrm_meas_eutra_plmn,
    PLMN_Identity*   p_asn_Meas_result_eutra_plmn)
{
    rrc_return_et   result = RRC_FAILURE;   
    RRC_ASSERT(PNULL !=  p_rrc_rrm_meas_eutra_plmn);
    RRC_ASSERT(PNULL != p_asn_Meas_result_eutra_plmn);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
 
    if (p_asn_Meas_result_eutra_plmn->m.mccPresent == 1)
    {
        p_rrc_rrm_meas_eutra_plmn->presence_bitmask |=
            PLMN_IDENTITY_MCC_PRESENCE_FLAG;
        /* SPR 2611 Start */
        l3_memcpy_wrapper( p_rrc_rrm_meas_eutra_plmn->mcc,
                p_asn_Meas_result_eutra_plmn->mcc.elem,
                MCC_OCTET_SIZE);           
        /* SPR 2611 Stop */

	/*SPR 15896 Fix Start*/
	if ( p_ue_context->m.traceActivated)
	{
		P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"PLMN-IdentityList2\"> ");
		P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MCC\">%02x%02x%02x</ie>",
				p_asn_Meas_result_eutra_plmn->mcc.elem[0],
				p_asn_Meas_result_eutra_plmn->mcc.elem[1],
				p_asn_Meas_result_eutra_plmn->mcc.elem[2]);
	}
	/*SPR 15896 Fix Stop*/ 
    }
    /* SPR 2611 Start */
    l3_memcpy_wrapper(p_rrc_rrm_meas_eutra_plmn->mnc.mnc,
            p_asn_Meas_result_eutra_plmn->mnc.elem,
            p_asn_Meas_result_eutra_plmn->mnc.n);           

    p_rrc_rrm_meas_eutra_plmn->mnc.count = 
        (U8)(p_asn_Meas_result_eutra_plmn->mnc.n);
    /* SPR 2611 Stop */

    /*SPR 15896 Fix Start*/
    if ( p_ue_context->m.traceActivated)
    {
        if(p_asn_Meas_result_eutra_plmn->mnc.n == 2)
        {
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MNC\">%02x%02x</ie>",
                                p_asn_Meas_result_eutra_plmn->mnc.elem[0],
                                p_asn_Meas_result_eutra_plmn->mnc.elem[1]);
        }
        else if(p_asn_Meas_result_eutra_plmn->mnc.n == 3)
        {
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MNC\">%02x%02x%02x</ie>",
                                p_asn_Meas_result_eutra_plmn->mnc.elem[0],
                                p_asn_Meas_result_eutra_plmn->mnc.elem[1],
                                p_asn_Meas_result_eutra_plmn->mnc.elem[2]);
        }
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup> "); //PLMN-IdentityList2 Closed
       /*SPR 15896 Fix Stop*/ 
    }

    result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}   
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_result_utra
*   INPUT        : meas_result_utra_t*    p_meas_result_utra,
*                  MeasResultUTRA*        p_asn_meas_results_utra,
*                  uecc_ue_context_t*     p_ue_context,
*                  uecc_gb_context_t*     p_uecc_gb_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds meas_result_utra_t in
*       RRC_RRM_MEASURMENT_RESULTS_IND message
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_result_utra(
    meas_result_utra_t*    p_meas_result_utra,
    MeasResultUTRA*        p_asn_meas_results_utra,
    uecc_ue_context_t*     p_ue_context,
    uecc_gb_context_t*     p_uecc_gb_context)
{
    OSRTDListNode*      p_node = PNULL;
    rrc_return_et   result = RRC_SUCCESS;
    U8 utra_count = 0;
    RRC_ASSERT(PNULL != p_meas_result_utra);
    RRC_ASSERT(PNULL != p_asn_meas_results_utra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
       
       /*SPR 15896 Fix Start*/ 
    P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"PhysCellId\">");                               
       /*SPR 15896 Fix Stop*/ 

    switch (p_asn_meas_results_utra->physCellId.t)
    {
        case T_MeasResultUTRA_physCellId_fdd:
            p_meas_result_utra->phys_cell_id.bitmask |= 
                MEAS_RESULT_UTRA_PHYS_CELL_ID_FDD_PRESENT;
            p_meas_result_utra->phys_cell_id.fdd = 
                p_asn_meas_results_utra->physCellId.u.fdd;
            
       /*SPR 15896 Fix Start*/ 
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PhysCellIdUTRA-FDD\">%d</ie>",p_meas_result_utra->phys_cell_id.fdd);                               
       /*SPR 15896 Fix Stop*/ 
            break;
            
        case T_MeasResultUTRA_physCellId_tdd:
            p_meas_result_utra->phys_cell_id.bitmask |= 
                MEAS_RESULT_UTRA_PHYS_CELL_ID_TDD_PRESENT;
            p_meas_result_utra->phys_cell_id.tdd =
                p_asn_meas_results_utra->physCellId.u.tdd;
       /*SPR 15896 Fix Start*/ 
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PhysCellIdUTRA-TDD\">%d</ie>",p_meas_result_utra->phys_cell_id.tdd);                               
       /*SPR 15896 Fix Stop*/ 
            break;
            
        default:
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_meas_results_utra -> wrong bitmask");
    }
       /*SPR 15896 Fix Start*/ 
    P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup>");//PhysCellId                               
       /*SPR 15896 Fix Stop*/ 

    if (1 == p_asn_meas_results_utra->m.cgi_InfoPresent)
    {
        p_meas_result_utra->bitmask |= MEAS_RESULT_UTRA_CGI_INFO_PRESENT;
        
	/*SPR 15896 Fix Start*/
	if ( p_ue_context->m.traceActivated)
	{
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"Cgi-Info\">");                               
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"CellGlobalIdUTRA\">");                               
       /*SPR 15896 Fix Stop*/ 
 	}
        p_asn_meas_results_utra->cgi_Info.cellGlobalId.
            cellIdentity.numbits = 28;
        l3_memcpy_wrapper(p_meas_result_utra->cgi_info.
                cell_global_id.cell_identity,
                p_asn_meas_results_utra->
                cgi_Info.cellGlobalId.cellIdentity.data,
                ARRSIZE(p_meas_result_utra->
                    cgi_info.cell_global_id.cell_identity)); 
        
        /* to add plmn information*/    
        uecc_rrm_build_meas_result_utra_plmn_info(
                p_uecc_gb_context,
                p_ue_context,     
                p_meas_result_utra,p_asn_meas_results_utra);    

	/*SPR 15896 Fix Start*/
	if ( p_ue_context->m.traceActivated)
	{
		P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"CellIdentity\">%02x%02x%02x%x</ie>",
				p_asn_meas_results_utra->cgi_Info.cellGlobalId.cellIdentity.data[0],
				p_asn_meas_results_utra->cgi_Info.cellGlobalId.cellIdentity.data[1],
				p_asn_meas_results_utra->cgi_Info.cellGlobalId.cellIdentity.data[2],
				p_asn_meas_results_utra->cgi_Info.cellGlobalId.cellIdentity.data[3]>>4);
		P_RRC_TRACE(p_ue_context,set_medium_bitmask(), UU,"\n </ieGroup>"); //CellGlobalIdUTRA                              
	}
	/*SPR 15896 Fix Stop*/ 
	/* To get location area code and store it in UECC structre for UTRA */

        if (1 == p_asn_meas_results_utra->cgi_Info.m.locationAreaCodePresent)
        {
            p_meas_result_utra->cgi_info.bitmask |=
                MEAS_RESULT_UTRA_CGI_INFO_LOCATION_AREA_CODE_PRESENT;
            l3_memcpy_wrapper(p_meas_result_utra->cgi_info.location_area_code,
                    p_asn_meas_results_utra->cgi_Info.locationAreaCode.data,
                    ARRSIZE(p_meas_result_utra->cgi_info.location_area_code));
            
            /*SPR 15896 Fix Start*/ 
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"LocationAreaCode\">%02x%02x</ie>",
                           p_asn_meas_results_utra->cgi_Info.locationAreaCode.data[0],
                           p_asn_meas_results_utra->cgi_Info.locationAreaCode.data[1]); 
            /*SPR 15896 Fix Stop*/ 
        }
        /* To get routing area code and store it in UECC structre for UTRA */

        if (1 == p_asn_meas_results_utra->cgi_Info.m.routingAreaCodePresent)
        {
            p_meas_result_utra->cgi_info.bitmask |=
                MEAS_RESULT_UTRA_CGI_INFO_ROUTING_AREA_CODE_PRESENT;
            p_meas_result_utra->cgi_info.routing_area_code = 
                p_asn_meas_results_utra->cgi_Info.routingAreaCode.data[0];
            
            /*SPR 15896 Fix Start*/ 
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"RoutingAreaCode\">%02x</ie>",
                         p_asn_meas_results_utra->cgi_Info.routingAreaCode.data[0]);
            /*SPR 15896 Fix Stop*/ 
        }
        if (1 == p_asn_meas_results_utra->cgi_Info.m.plmn_IdentityListPresent)
        {
            p_meas_result_utra->cgi_info.bitmask |= 
                MEAS_RESULT_UTRA_CGI_INFO_PLMN_IDENTITY_LIST_PRESENT;
            p_meas_result_utra->cgi_info.plmn_identity_list.count =
                (U8)(p_asn_meas_results_utra->cgi_Info.plmn_IdentityList.count);
            p_node = p_asn_meas_results_utra->cgi_Info.plmn_IdentityList.head;
            
            for (utra_count = 0; utra_count < p_meas_result_utra->cgi_info.
            plmn_identity_list.count; utra_count++)
            {
                RRC_ASSERT(PNULL != p_node);
                RRC_ASSERT(PNULL != p_node->data);
                uecc_rrm_build_meas_result_utra_plmn_list2_info(
                            p_uecc_gb_context,
                            p_ue_context,  
                            &p_meas_result_utra->cgi_info.plmn_identity_list.
                             cell_identity[utra_count],
                             p_node->data);
            }
        }    
    
       /*SPR 15896 Fix Start*/ 
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup>");//Cgi-Info                               
       /*SPR 15896 Fix Stop*/ 
        result = RRC_SUCCESS;
    }

       /*SPR 15896 Fix Start*/ 
    P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"MeasResult\">");                               
       /*SPR 15896 Fix Stop*/ 
    if (1 == p_asn_meas_results_utra->measResult.m.utra_RSCPPresent)
    {
        p_meas_result_utra->meas_result.bitmask |= 
            MEAS_RESULT_UTRA_MEAS_RESULT_RSCP_PRESENT;
        p_meas_result_utra->meas_result.utra_rscp = 
            p_asn_meas_results_utra->measResult.utra_RSCP;  
    
       /*SPR 15896 Fix Start*/ 
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(),UU,"\n <ie name=\"Utra-RSCP\">%d</ie>",p_meas_result_utra->meas_result.utra_rscp); 
       /*SPR 15896 Fix Stop*/ 
    }
    if (1 == p_asn_meas_results_utra->measResult.m.utra_EcN0Present)
    {
        p_meas_result_utra->meas_result.bitmask |= 
            MEAS_RESULT_UTRA_MEAS_RESULT_ECN0_PRESENT;
        p_meas_result_utra->meas_result.utra_ecn0 = 
            p_asn_meas_results_utra->measResult.utra_EcN0; 
       /*SPR 15896 Fix Start*/ 
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"Utra-EcN0\">%d</ie>",p_meas_result_utra->meas_result.utra_ecn0); 
       /*SPR 15896 Fix Stop*/ 
    }

    /* Send CSG Info to RRM */
    if (1 == p_asn_meas_results_utra->measResult.m.additionalSI_Info_r9Present)
    {
        p_meas_result_utra->bitmask |=
            MEAS_RESULT_EUTRA_CSG_INFO_PRESENT;
        
       /*SPR 15896 Fix Start*/ 
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"AdditionalSI-Info-r9\">");                               
       /*SPR 15896 Fix Stop*/ 

        if (1 == p_asn_meas_results_utra->measResult.additionalSI_Info_r9.
                m.csg_MemberStatus_r9Present)
        {
            p_meas_result_utra->utra_csg_info.bitmask |=
                MEAS_RESULT_EUTRA_MEAS_RESULT_CSG_MEM_STATUS_PRESENT;

            p_meas_result_utra->utra_csg_info.csg_membershipStatus =
                (U8)p_asn_meas_results_utra->measResult.additionalSI_Info_r9.
                csg_MemberStatus_r9;
       /*SPR 15896 Fix Start*/ 
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n  <ie name=\"Csg-MemberStatus-r9\">%d</ie>",p_meas_result_utra->utra_csg_info.csg_membershipStatus);  
       /*SPR 15896 Fix Stop*/ 
        }
        if (1 == p_asn_meas_results_utra->measResult.additionalSI_Info_r9.
                m.csg_Identity_r9Present)
        {
            p_meas_result_utra->utra_csg_info.bitmask |=
                MEAS_RESULT_EUTRA_MEAS_RESULT_CSG_ID_PRESENT;

            l3_memcpy_wrapper( &(p_meas_result_utra->utra_csg_info.csg_identity),
                    p_asn_meas_results_utra->measResult.additionalSI_Info_r9.
                    csg_Identity_r9.data,  sizeof(U8)*CSG_ID_OCTET_SIZE);

            p_meas_result_utra->utra_csg_info.csg_identity[CSG_ID_OCTET_SIZE-1] &= CSG_RESET_VAL;
          
       /*SPR 15896 Fix Start*/ 
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n  <ie name=\"Csg-Identity-r9\">%02x%02x%02x%x</ie>",
                                 p_meas_result_utra->utra_csg_info.csg_identity[0],
                                 p_meas_result_utra->utra_csg_info.csg_identity[1],
                                 p_meas_result_utra->utra_csg_info.csg_identity[2],
                                 p_meas_result_utra->utra_csg_info.csg_identity[3]>>5); 
        }
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup>");//AdditionalSI-Info-r9                         
    }

    P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup>");//MeasResult                           
       /*SPR 15896 Fix Stop*/ 
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_result_utra_plmn_info
*   INPUT        : uecc_gb_context_t*     p_uecc_gb_context,
*                  uecc_ue_context_t*     p_ue_context,
*                  meas_result_utra_t*    p_meas_result_utra,
*                  MeasResultUTRA*        p_asn_meas_results_utra
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds PLMN info of meas_result_utra_t in
*       RRC_RRM_MEASURMENT_RESULTS_IND message
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_result_utra_plmn_info(
    uecc_gb_context_t*     p_uecc_gb_context,
    uecc_ue_context_t*     p_ue_context,
    meas_result_utra_t*    p_meas_result_utra,
    MeasResultUTRA*        p_asn_meas_results_utra)
{
    rrc_return_et   result = RRC_SUCCESS;

    RRC_ASSERT(PNULL != p_meas_result_utra);
    RRC_ASSERT(PNULL != p_asn_meas_results_utra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
   
    if (p_asn_meas_results_utra->
    cgi_Info.cellGlobalId.plmn_Identity.m.mccPresent == 1)
    {
        p_meas_result_utra->cgi_info.cell_global_id.plmn_identity.presence_bitmask |=
            PLMN_IDENTITY_MCC_PRESENCE_FLAG;
        /* SPR 2611 Start */

        l3_memcpy_wrapper(p_meas_result_utra->cgi_info.
                cell_global_id.plmn_identity.mcc,
                p_asn_meas_results_utra->
                cgi_Info.cellGlobalId.plmn_Identity.mcc.elem,
                MCC_OCTET_SIZE
                );
	/*SPR 15896 Fix Start*/
	if ( p_ue_context->m.traceActivated)
        {
            P_RRC_TRACE(p_ue_context,set_medium_bitmask(), UU,"\n <ieGroup name=\"PLMN-IdentityList\"> ");
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MCC\">%02x%02x%02x</ie>",
                  p_asn_meas_results_utra->cgi_Info.cellGlobalId.plmn_Identity.mcc.elem[0],
                  p_asn_meas_results_utra->cgi_Info.cellGlobalId.plmn_Identity.mcc.elem[1],
                  p_asn_meas_results_utra->cgi_Info.cellGlobalId.plmn_Identity.mcc.elem[2]);
        }
	/*SPR 15896 Fix Stop*/

        /* SPR 2611 Stop */
    }
    /* SPR 2611 Start */

    l3_memcpy_wrapper(p_meas_result_utra->cgi_info.
            cell_global_id.plmn_identity.mnc.mnc,
            p_asn_meas_results_utra->
            cgi_Info.cellGlobalId.plmn_Identity.mnc.elem,
            p_asn_meas_results_utra->
            cgi_Info.cellGlobalId.plmn_Identity.mnc.n);            

    p_meas_result_utra->cgi_info.cell_global_id.plmn_identity.mnc.count = 
        (U8)(p_asn_meas_results_utra->cgi_Info.cellGlobalId.
             plmn_Identity.mnc.n);

    /*SPR 15896 Fix Start*/
    if ( p_ue_context->m.traceActivated)
    {
        if(p_asn_meas_results_utra->cgi_Info.cellGlobalId.plmn_Identity.mnc.n == 2)
        {
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MNC\">%02x%02x</ie>",
                    p_asn_meas_results_utra->cgi_Info.cellGlobalId.plmn_Identity.mnc.elem[0],
                    p_asn_meas_results_utra->cgi_Info.cellGlobalId.plmn_Identity.mnc.elem[1]);
        }
        else if(p_asn_meas_results_utra->cgi_Info.cellGlobalId.plmn_Identity.mnc.n == 3)
        {
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MNC\">%02x%02x%02x</ie>",
                    p_asn_meas_results_utra->cgi_Info.cellGlobalId.plmn_Identity.mnc.elem[0],
                    p_asn_meas_results_utra->cgi_Info.cellGlobalId.plmn_Identity.mnc.elem[1],
                    p_asn_meas_results_utra->cgi_Info.cellGlobalId.plmn_Identity.mnc.elem[2]);
        }
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup> ");//PLMN-IdentityList
	/*SPR 15896 Fix Stop*/
    }


    /* SPR 2611 Stop */

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
     return result;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_rrm_build_meas_result_utra_plmn_list2_info
 *   INPUT        : uecc_gb_context_t*     p_uecc_gb_context,
 *                  uecc_ue_context_t*     p_ue_context,
 *                  plmn_identity_t* p_rrc_rrm_meas_utra_plmn,
 *                  PLMN_Identity*   p_asn_Meas_result_utra_plmn
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds PLMN list2 info in meas_result_utra_t in
 *       RRC_RRM_MEASURMENT_RESULTS_IND message
 *
 *   RETURNS:
 *       None
 *
 ******************************************************************************/
rrc_return_et uecc_rrm_build_meas_result_utra_plmn_list2_info(
    uecc_gb_context_t*     p_uecc_gb_context,
    uecc_ue_context_t*     p_ue_context,
    plmn_identity_t* p_rrc_rrm_meas_utra_plmn,
    PLMN_Identity*   p_asn_Meas_result_utra_plmn
    )    
{
    rrc_return_et       result = RRC_SUCCESS;
    RRC_ASSERT(PNULL != p_rrc_rrm_meas_utra_plmn);
    RRC_ASSERT(PNULL != p_asn_Meas_result_utra_plmn);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/

    if (p_asn_Meas_result_utra_plmn->m.mccPresent == 1) 
    {
        p_rrc_rrm_meas_utra_plmn->presence_bitmask |=
            PLMN_IDENTITY_MCC_PRESENCE_FLAG;
        /* SPR 2611 Start */
        l3_memcpy_wrapper( p_rrc_rrm_meas_utra_plmn->mcc,
                p_asn_Meas_result_utra_plmn->mcc.elem,
                MCC_OCTET_SIZE);   
        /* SPR 2611 Stop */
        
	/*SPR 15896 Fix Start*/
	if ( p_ue_context->m.traceActivated)
        {
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"PLMN-IdentityList2\"> ");
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MCC\">%02x%02x%02x</ie>",
                               p_asn_Meas_result_utra_plmn->mcc.elem[0],
                               p_asn_Meas_result_utra_plmn->mcc.elem[1],
                               p_asn_Meas_result_utra_plmn->mcc.elem[2]);
	/*SPR 15896 Fix Stop*/
        }
    }    

    /* SPR 2611 Start */
    l3_memcpy_wrapper(p_rrc_rrm_meas_utra_plmn->mnc.mnc,
            p_asn_Meas_result_utra_plmn->mnc.elem,
            p_asn_Meas_result_utra_plmn->mnc.n);     
    p_rrc_rrm_meas_utra_plmn->mnc.count = 
        (U8)(p_asn_Meas_result_utra_plmn->mnc.n);
    /* SPR 2611 Stop */

    /*SPR 15896 Fix Start*/
    if ( p_ue_context->m.traceActivated)
    {
        if(p_asn_Meas_result_utra_plmn->mnc.n == 2)
        {
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MNC\">%02x%02x</ie>",
                                p_asn_Meas_result_utra_plmn->mnc.elem[0],
                                p_asn_Meas_result_utra_plmn->mnc.elem[1]);
        }
        else if(p_asn_Meas_result_utra_plmn->mnc.n == 3)
        {
            P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MNC\">%02x%02x%02x</ie>",
                                p_asn_Meas_result_utra_plmn->mnc.elem[0],
                                p_asn_Meas_result_utra_plmn->mnc.elem[1],
                                p_asn_Meas_result_utra_plmn->mnc.elem[2]);
        }
        P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup> "); //PLMN-IdentityList2 Closed
	/*SPR 15896 Fix Stop*/
    }

    result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}
/******************************************************************************
 *   FUNCTION NAME: uecc_save_ue_rat_capability
 *   INPUT        : uecc_ue_context_t   *p_ue_context,
 *                  void                *p_api
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function save the ue rat capability per rat tpen uecc context
 *
 *   RETURNS:
 *       rrc_return_t
 *
 ******************************************************************************/


rrc_return_t uecc_save_ue_rat_capability(
        uecc_ue_context_t   *p_ue_context,
        void                *p_api
)
{
    UE_CapabilityRAT_Container *p_UE_CapabilityRAT_Container;
    rrc_return_et   result = RRC_FAILURE;
    UE_Radio_Capability_RAT_Container_t* p_ue_radio_capability = PNULL;
    RAT_Type rat_type;
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_api);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    p_UE_CapabilityRAT_Container = (UE_CapabilityRAT_Container *)p_api;
   
    switch(p_UE_CapabilityRAT_Container->rat_Type)
    {
        case RRC_RAT_TYPE_EUTRA:
        {
            /* CSR 00082289 Fix Start */
            /* CSR 00082289 Fix Stop */
            rat_type = eutra;
            p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t *) 
                ylFind(&p_ue_context->ue_radio_capability,
                      &rat_type, 
                      uecc_rat_type_keyof, 
                      uecc_rat_type_compare);
            if (p_ue_radio_capability != PNULL)
            {
                /*SPR_18125_START*/
                if(PNULL !=  p_ue_radio_capability->p_rat_string)
                {
                    rrc_mem_free(p_ue_radio_capability->p_rat_string);
                    p_ue_radio_capability->p_rat_string = PNULL;
                }
                /*SPR_18125_END*/
                /* SPR 13502 Fix Start */
                p_ue_radio_capability->p_rat_string = (U8 *)rrc_mem_get
                   (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                if (p_ue_radio_capability->p_rat_string == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return result;
                }

                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                p_ue_radio_capability->valid_rat_string = RRC_TRUE;
                p_ue_radio_capability->numocts= 
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
                l3_memcpy_wrapper(p_ue_radio_capability->p_rat_string,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                /* SPR 13502 Fix Stop */

            }
            else
            {
                p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t*)
                    rrc_mem_get (sizeof(UE_Radio_Capability_RAT_Container_t));
                if (p_ue_radio_capability == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    return result;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                }

                /* SPR 13502 Fix Start */
                p_ue_radio_capability->p_rat_string = (U8 *)rrc_mem_get
                   (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                if (p_ue_radio_capability->p_rat_string == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
		            /* Coverity Fix 83406 Start */
        		    rrc_mem_free(p_ue_radio_capability);
		            p_ue_radio_capability = PNULL;
        		    /* Coverity Fix 83406 Stop */
                    return result;
                }
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                p_ue_radio_capability->rat_type = eutra;
                p_ue_radio_capability->valid_rat_string = RRC_TRUE;
                p_ue_radio_capability->numocts= 
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
                l3_memcpy_wrapper(p_ue_radio_capability->p_rat_string,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);

                ylPushTail(&p_ue_context->ue_radio_capability,
                        (YLNODE*)p_ue_radio_capability);
                /* SPR 13502 Fix Stop */
            }
            
            result = RRC_SUCCESS;               
        }
        break;

        case RRC_RAT_TYPE_UTRA:
        {
            if (((p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts) > MAX_ASN_BUFFER)
                    || (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts < 1))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Wrong number of Octets",
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                result = RRC_FAILURE;
                return result;
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            }
            rat_type = utra_1;
            p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t *) 
                ylFind(&p_ue_context->ue_radio_capability,
                      &rat_type, 
                      uecc_rat_type_keyof, 
                      uecc_rat_type_compare);
            if (p_ue_radio_capability != PNULL)
            {
                /*SPR_18125_START*/
                if(PNULL !=  p_ue_radio_capability->p_rat_string)
                {
                    rrc_mem_free(p_ue_radio_capability->p_rat_string);
                    p_ue_radio_capability->p_rat_string = PNULL;
                }
                /*SPR_18125_END*/
                /* SPR 13502 Fix Start */
                p_ue_radio_capability->p_rat_string = (U8 *)rrc_mem_get
                   (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                if (p_ue_radio_capability->p_rat_string == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return result;
                }
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                p_ue_radio_capability->valid_rat_string = RRC_TRUE;
                p_ue_radio_capability->numocts = 
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
                l3_memcpy_wrapper(p_ue_radio_capability->p_rat_string,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                /* SPR 13502 Fix Stop */
            }
            else
            {
            
                p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t*)
                    rrc_mem_get (sizeof(UE_Radio_Capability_RAT_Container_t));
                if (p_ue_radio_capability == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    return result;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                }

                /* SPR 13502 Fix Start */
                p_ue_radio_capability->p_rat_string = (U8 *)rrc_mem_get
                   (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                if (p_ue_radio_capability->p_rat_string == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        		    /* Coverity Fix 83406 Start */
		            rrc_mem_free(p_ue_radio_capability);
        		    p_ue_radio_capability = PNULL;
		            /* Coverity Fix 83406 Stop */
                    return result;
                }

                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                p_ue_radio_capability->rat_type =  utra_1;
                p_ue_radio_capability->valid_rat_string = RRC_TRUE;
                p_ue_radio_capability->numocts= 
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
                l3_memcpy_wrapper(p_ue_radio_capability->p_rat_string,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);

                ylPushTail(&p_ue_context->ue_radio_capability,
                        (YLNODE*)p_ue_radio_capability);
                /* SPR 13502 Fix Stop */
            }

            result = RRC_SUCCESS;
        }
        break;
        
        case RRC_RAT_TYPE_GERAN_CS:
        {
            if (((p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts) > MAX_ASN_BUFFER)
                    || (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts < 1))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Wrong number of Octets",
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                result = RRC_FAILURE;
                return result;
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            }
            rat_type = geran_cs;
            p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t *) 
                ylFind(&p_ue_context->ue_radio_capability,
                      &rat_type, 
                      uecc_rat_type_keyof, 
                      uecc_rat_type_compare);
            if (p_ue_radio_capability != PNULL)
            {
                /*SPR_18125_START*/
                if(PNULL !=  p_ue_radio_capability->p_rat_string)
                {
                    rrc_mem_free(p_ue_radio_capability->p_rat_string);
                    p_ue_radio_capability->p_rat_string = PNULL;
                }
                /*SPR_18125_END*/
                /* SPR 13502 Fix Start */
                p_ue_radio_capability->p_rat_string = (U8 *)rrc_mem_get
                   (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                if (p_ue_radio_capability->p_rat_string == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return result;
                }
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                p_ue_radio_capability->valid_rat_string = RRC_TRUE;
                p_ue_radio_capability->numocts= 
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
                l3_memcpy_wrapper(p_ue_radio_capability->p_rat_string,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                /* SPR 13502 Fix Stop */
            }
            else
            {

                p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t*)
                    rrc_mem_get (sizeof(UE_Radio_Capability_RAT_Container_t));
                if (p_ue_radio_capability == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    return result;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                }

            
                /* SPR 13502 Fix Start */
                p_ue_radio_capability->p_rat_string = (U8 *)rrc_mem_get
                   (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                if (p_ue_radio_capability->p_rat_string == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        		    /* Coverity Fix 83406 Start */
		            rrc_mem_free(p_ue_radio_capability);
        		    p_ue_radio_capability = PNULL;
		            /* Coverity Fix 83406 Stop */
                    return result;
                }
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                p_ue_radio_capability->rat_type = geran_cs;
                p_ue_radio_capability->valid_rat_string = RRC_TRUE;
                p_ue_radio_capability->numocts= 
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
                l3_memcpy_wrapper(p_ue_radio_capability->p_rat_string,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);

                ylPushTail(&p_ue_context->ue_radio_capability,
                        (YLNODE*)p_ue_radio_capability);
                /* SPR 13502 Fix Stop */
            }
            
            result = RRC_SUCCESS;
        }
        break;

        case RRC_RAT_TYPE_GERAN_PS:
        {
            if (((p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts) > MAX_ASN_BUFFER)
                    || (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts < 1))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Wrong number of Octets",
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                result = RRC_FAILURE;
                return result;
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            }
            rat_type = geran_ps;
            p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t *) 
                ylFind(&p_ue_context->ue_radio_capability,
                      &rat_type, 
                      uecc_rat_type_keyof, 
                      uecc_rat_type_compare);
            if (p_ue_radio_capability != PNULL)
            {
                /*SPR_18125_START*/
                if(PNULL !=  p_ue_radio_capability->p_rat_string)
                {
                    rrc_mem_free(p_ue_radio_capability->p_rat_string);
                    p_ue_radio_capability->p_rat_string = PNULL;
                }
                /*SPR_18125_END*/
                /* SPR 13502 Fix Start */
                p_ue_radio_capability->p_rat_string = (U8 *)rrc_mem_get
                   (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                if (p_ue_radio_capability->p_rat_string == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return result;
                }
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                p_ue_radio_capability->valid_rat_string = RRC_TRUE;
                p_ue_radio_capability->numocts= 
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
                l3_memcpy_wrapper(p_ue_radio_capability->p_rat_string,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                /* SPR 13502 Fix Stop */
            }
            else
            {
                p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t*)
                    rrc_mem_get (sizeof(UE_Radio_Capability_RAT_Container_t));
                if (p_ue_radio_capability == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    return result;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                }

                /* SPR 13502 Fix Start */
                p_ue_radio_capability->p_rat_string = (U8 *)rrc_mem_get
                   (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                if (p_ue_radio_capability->p_rat_string == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        		    /* Coverity Fix 83406 Start */
		            rrc_mem_free(p_ue_radio_capability);
        		    p_ue_radio_capability = PNULL;
		            /* Coverity Fix 83406 Stop */
                    return result;
                }
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                p_ue_radio_capability->rat_type = geran_ps;
                p_ue_radio_capability->valid_rat_string = RRC_TRUE;
                p_ue_radio_capability->numocts= 
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
                l3_memcpy_wrapper(p_ue_radio_capability->p_rat_string,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);

                ylPushTail(&p_ue_context->ue_radio_capability,
                        (YLNODE*)p_ue_radio_capability);
                /* SPR 13502 Fix Stop */
            }

            result = RRC_SUCCESS;
        }
        break;

        case RRC_RAT_TYPE_CDMA2000_1XRTT:
        {
            if (((p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts) > MAX_ASN_BUFFER)
                    || (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts < 1))
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"Wrong number of Octets",
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                result = RRC_FAILURE;
                return result;
                RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
            }
            rat_type = cdma2000_1XRTT_1;
            p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t *) 
                ylFind(&p_ue_context->ue_radio_capability,
                      &rat_type, 
                      uecc_rat_type_keyof, 
                      uecc_rat_type_compare);
            if (p_ue_radio_capability != PNULL)
            {
                /*SPR_18125_START*/
                if(PNULL !=  p_ue_radio_capability->p_rat_string)
                {
                    rrc_mem_free(p_ue_radio_capability->p_rat_string);
                    p_ue_radio_capability->p_rat_string = PNULL;
                }
                /*SPR_18125_END*/
                /* SPR 13502 Fix Start */
                p_ue_radio_capability->p_rat_string = (U8 *)rrc_mem_get
                   (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                if (p_ue_radio_capability->p_rat_string == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return result;
                }
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                p_ue_radio_capability->valid_rat_string = RRC_TRUE;
                p_ue_radio_capability->numocts= 
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
                l3_memcpy_wrapper(p_ue_radio_capability->p_rat_string,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                /* SPR 13502 Fix Stop */
                
            }
            else
            {            
                p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t*)
                    rrc_mem_get (sizeof(UE_Radio_Capability_RAT_Container_t));
                if (p_ue_radio_capability == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    return result;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                }

                /* SPR 13502 Fix Start */
                p_ue_radio_capability->p_rat_string = (U8 *)rrc_mem_get
                   (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                if (p_ue_radio_capability->p_rat_string == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
        		    /* Coverity Fix 83406 Start */
		            rrc_mem_free(p_ue_radio_capability);
        		    p_ue_radio_capability = PNULL;
		            /* Coverity Fix 83406 Stop */
                    return result;
                }

                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */
                p_ue_radio_capability->rat_type = cdma2000_1XRTT_1;
                p_ue_radio_capability->valid_rat_string = RRC_TRUE;
                p_ue_radio_capability->numocts= 
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
                l3_memcpy_wrapper(p_ue_radio_capability->p_rat_string,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);

                ylPushTail(&p_ue_context->ue_radio_capability,
                        (YLNODE*)p_ue_radio_capability);
                /* SPR 13502 Fix Stop */
            }
            result = RRC_SUCCESS;
        }
        break;

#ifdef ENDC_ENABLED        
        /*NR_DC Code Change Start*/
        case RRC_RAT_TYPE_NR:
        {
            /*S10_ATTACH_ISSUE +*/
            /*code removed*/
            /*S10_ATTACH_ISSUE -*/

            rat_type = nr;
            p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t *) 
                ylFind(&p_ue_context->ue_radio_capability,
                      &rat_type, 
                      uecc_rat_type_keyof, 
                      uecc_rat_type_compare);
            if (p_ue_radio_capability != PNULL)
            {
                if(PNULL !=  p_ue_radio_capability->p_rat_string)
                {
                    rrc_mem_free(p_ue_radio_capability->p_rat_string);
                    p_ue_radio_capability->p_rat_string = PNULL;
                }
                p_ue_radio_capability->p_rat_string = (U8 *)rrc_mem_get
                   (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                if (p_ue_radio_capability->p_rat_string == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return result;
                }
                memset_wrapper(p_ue_radio_capability->p_rat_string,0,
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                p_ue_radio_capability->valid_rat_string = RRC_TRUE;
                p_ue_radio_capability->numocts= 
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
                l3_memcpy_wrapper(p_ue_radio_capability->p_rat_string,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_DETAILEDALL,"UE capability found for rat type RRC_RAT_TYPE_EUTRA_NR");
            }
            else
            {

                p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t*)
                    rrc_mem_get (sizeof(UE_Radio_Capability_RAT_Container_t));
                if (p_ue_radio_capability == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    return result;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                }

                p_ue_radio_capability->p_rat_string = (U8 *)rrc_mem_get
                   (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                if (p_ue_radio_capability->p_rat_string == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
		            rrc_mem_free(p_ue_radio_capability);
        		    p_ue_radio_capability = PNULL;
                    return result;
                }
                memset_wrapper(p_ue_radio_capability->p_rat_string,0,
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                p_ue_radio_capability->rat_type = nr;
                p_ue_radio_capability->valid_rat_string = RRC_TRUE;
                p_ue_radio_capability->numocts= 
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
                l3_memcpy_wrapper(p_ue_radio_capability->p_rat_string,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);

                ylPushTail(&p_ue_context->ue_radio_capability,
                        (YLNODE*)p_ue_radio_capability);
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_DETAILEDALL,"UE capability inserted for rat type RRC_RAT_TYPE_EUTRA_NR");
            }
            
            result = RRC_SUCCESS;
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_DETAILEDALL,"UE capability receieved for rat type RRC_RAT_TYPE_NR");
        }
        break;

        case RRC_RAT_TYPE_EUTRA_NR:
        {
            /*S10_ATTACH_ISSUE +*/
            /*code removed*/
            /*S10_ATTACH_ISSUE -*/

            rat_type = eutra_nr;
            p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t *) 
                ylFind(&p_ue_context->ue_radio_capability,
                      &rat_type, 
                      uecc_rat_type_keyof, 
                      uecc_rat_type_compare);
            if (p_ue_radio_capability != PNULL)
            {
                if(PNULL !=  p_ue_radio_capability->p_rat_string)
                {
                    rrc_mem_free(p_ue_radio_capability->p_rat_string);
                    p_ue_radio_capability->p_rat_string = PNULL;
                }
                p_ue_radio_capability->p_rat_string = (U8 *)rrc_mem_get
                   (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                if (p_ue_radio_capability->p_rat_string == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return result;
                }
                memset_wrapper(p_ue_radio_capability->p_rat_string,0,
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                p_ue_radio_capability->valid_rat_string = RRC_TRUE;
                p_ue_radio_capability->numocts= 
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
                l3_memcpy_wrapper(p_ue_radio_capability->p_rat_string,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_DETAILEDALL,"UE capability found for rat type RRC_RAT_TYPE_EUTRA_NR");
            }
            else
            {

                p_ue_radio_capability = (UE_Radio_Capability_RAT_Container_t*)
                    rrc_mem_get (sizeof(UE_Radio_Capability_RAT_Container_t));
                if (p_ue_radio_capability == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    return result;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                }

                p_ue_radio_capability->p_rat_string = (U8 *)rrc_mem_get
                   (p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                if (p_ue_radio_capability->p_rat_string == PNULL)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,
                        "Memory Allocation Failure.");
                    result = RRC_FAILURE;
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
		            rrc_mem_free(p_ue_radio_capability);
        		    p_ue_radio_capability = PNULL;
                    return result;
                }
                memset_wrapper(p_ue_radio_capability->p_rat_string,0,
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);
                p_ue_radio_capability->rat_type = eutra_nr;
                p_ue_radio_capability->valid_rat_string = RRC_TRUE;
                p_ue_radio_capability->numocts= 
                    p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts;
                l3_memcpy_wrapper(p_ue_radio_capability->p_rat_string,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.data,
                        p_UE_CapabilityRAT_Container->ueCapabilityRAT_Container.numocts);

                ylPushTail(&p_ue_context->ue_radio_capability,
                        (YLNODE*)p_ue_radio_capability);
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_DETAILEDALL,"UE capability inserted for rat type RRC_RAT_TYPE_EUTRA_NR");
            }
            
            result = RRC_SUCCESS;
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_DETAILEDALL,"UE capability receieved for rat type RRC_RAT_TYPE_EUTRA_NR");
        }
        break;
        /*NR_DC Code Change Stop*/
#endif        
        default:
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_save_ue_rat_capability -> wrong choice");
            break;
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_rrc_rrm_erb_modify_req
*   INPUT        : uecc_ue_context_t*         p_uecc_ue_context
*                  rrc_rrm_erab_modify_req_t* p_rrc_rrm_erb_modify_req
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds RRC_RRM_ERB_MODIFY_REQ message
*
*   RETURNS:
*       None
*
******************************************************************************/
void uecc_rrm_build_rrc_rrm_erb_modify_req
(
    uecc_ue_context_t*         p_uecc_ue_context,
    rrc_rrm_erab_modify_req_t* p_rrc_rrm_erb_modify_req
)
{

    rrm_erab_level_qos_params_t *p_rrm_erab_level_qos_params = PNULL;
    
    rrc_counter_t   e_rab_list_count = RRC_NULL;
    U32             drb_index        = RRC_NULL; 
    
    erab_modify_request_data_t  *p_mod_data       = PNULL;
    erab_to_be_modified_list_t  *p_to_be_mod_list = PNULL;
    
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_rrm_erb_modify_req);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_mod_data = &(p_uecc_ue_context->p_curr_proc_data->u.
        erab_modify_request_data);

    p_to_be_mod_list = &(p_mod_data->erab_to_be_modified_list);

    p_rrc_rrm_erb_modify_req->ue_index = p_uecc_ue_context->ue_index;
    

    /* As the UE AMBR is an optional field, fill it only if its present */
    if (p_mod_data->m.ue_ambr_present)
    {
        p_rrc_rrm_erb_modify_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul =
           p_mod_data->ue_aggregate_maximum_bitrate.
           uEaggregateMaximumBitRateUL;

        p_rrc_rrm_erb_modify_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl =
           p_mod_data->ue_aggregate_maximum_bitrate.
          uEaggregateMaximumBitRateDL;

        p_rrc_rrm_erb_modify_req->bitmask |= RRC_RRM_ERB_MODIFY_REQ_UE_AGG_MAX_BIT_RATE_PRESENT;

    }

    e_rab_list_count = p_to_be_mod_list->erab_to_be_modified_list_counter;

    p_rrc_rrm_erb_modify_req->erab_to_be_modified_item_list.num_of_list =
        e_rab_list_count;

    for(drb_index=0; drb_index < e_rab_list_count; drb_index++)
    {
        p_rrc_rrm_erb_modify_req->erab_to_be_modified_item_list.            
        erab_to_be_setup_item[drb_index].erab_id =
          (U8)(p_to_be_mod_list->erab_to_be_modified_item[drb_index].e_RAB_ID);

        p_rrm_erab_level_qos_params=
            &p_rrc_rrm_erb_modify_req->erab_to_be_modified_item_list.
            erab_to_be_setup_item[drb_index].erab_level_qos_params;

        p_rrm_erab_level_qos_params->bitmask = 0;

        /* qci */
        p_rrm_erab_level_qos_params->qci =
           p_to_be_mod_list->erab_to_be_modified_item[drb_index].
           e_RABlevelQoSParameters.qCI;

        /* alloc_and_reten_prior */
        p_rrm_erab_level_qos_params->alloc_and_reten_prior.priority_level =
            p_to_be_mod_list->erab_to_be_modified_item[drb_index].
            e_RABlevelQoSParameters.allocationRetentionPriority.priorityLevel;

        p_rrm_erab_level_qos_params->alloc_and_reten_prior.
            preemption_capability=
            (U8)(p_to_be_mod_list->erab_to_be_modified_item[drb_index].
            e_RABlevelQoSParameters.allocationRetentionPriority.
            pre_emptionCapability);

        p_rrm_erab_level_qos_params->alloc_and_reten_prior.
            preemption_vulnerability=
            (U8)(p_to_be_mod_list->erab_to_be_modified_item[drb_index].
            e_RABlevelQoSParameters.allocationRetentionPriority.
            pre_emptionVulnerability);

        /* gbr_qos_info */
        if(0!=p_to_be_mod_list->erab_to_be_modified_item[drb_index].
                e_RABlevelQoSParameters.m.gbrQosInformationPresent)
        {
            p_rrm_erab_level_qos_params->bitmask |=
                ERAB_LEVEL_QOS_PARAM_GBR_QOS_INFO_PRESENT;

            p_rrm_erab_level_qos_params->gbr_qos_info.erab_guar_bit_rate_dl =
              (U32) p_to_be_mod_list->erab_to_be_modified_item[drb_index].
              e_RABlevelQoSParameters.gbrQosInformation.
              e_RAB_GuaranteedBitrateDL;

            p_rrm_erab_level_qos_params->gbr_qos_info.erab_guar_bit_rate_ul =
               (U32)p_to_be_mod_list->erab_to_be_modified_item[drb_index].
               e_RABlevelQoSParameters.gbrQosInformation.
               e_RAB_GuaranteedBitrateUL;

            p_rrm_erab_level_qos_params->gbr_qos_info.erab_max_bit_rate_dl=
               (U32)p_to_be_mod_list->erab_to_be_modified_item[drb_index].
               e_RABlevelQoSParameters.gbrQosInformation.e_RAB_MaximumBitrateDL;

            p_rrm_erab_level_qos_params->gbr_qos_info.erab_max_bit_rate_ul=
               (U32)p_to_be_mod_list->erab_to_be_modified_item[drb_index].
               e_RABlevelQoSParameters.gbrQosInformation.e_RAB_MaximumBitrateUL;
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_erb_modify_req
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context
*   OUTPUT       : NONE
*   DESCRIPTION:
*       This function builds and sends RRC_RRM_ERB_MODIFY_REQ message
*       to RRM module (PUP encoding)
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_erb_modify_req
(
    uecc_ue_context_t* p_uecc_ue_context
)
{
    rrc_rrm_erab_modify_req_t rrc_rrm_erb_modify_req;

    rrc_return_et             rrc_response = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&rrc_rrm_erb_modify_req, 0x00, 
            sizeof(rrc_rrm_erab_modify_req_t));

    /* Build message */
    uecc_rrm_build_rrc_rrm_erb_modify_req(p_uecc_ue_context,
            &rrc_rrm_erb_modify_req);

    /* PUP encoding */
    rrc_response = rrc_rrm_il_send_rrc_rrm_erab_modify_req(
                        &rrc_rrm_erb_modify_req,
                        RRC_UECC_MODULE_ID,
                        RRC_RRM_MODULE_ID,
                        uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context),
                        p_uecc_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return rrc_response;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_erb_modify_resp
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function processes RRC_RRM_ERB_MODIFY_RESP message from RRM
*
*   RETURNS:
*       None
*
******************************************************************************/
void uecc_rrm_process_erb_modify_resp
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;
    static rrc_rrm_erab_modify_resp_t        rrc_rrm_erb_modify_resp;
    S32                             length_read = RRC_NULL;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    memset_wrapper(&rrc_rrm_erb_modify_resp, 0, 
               sizeof(rrc_rrm_erab_modify_resp_t));

    do
    {
        /* Encode message */
        result = rrc_il_parse_rrc_rrm_erab_modify_resp(
                    &rrc_rrm_erb_modify_resp,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_ERB_MODIFY_RESP] "
                "The RRC_RRM_ERB_MODIFY_RESP parsing error.");
            break;
        }
        
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", rrc_rrm_erb_modify_resp.ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            rrc_rrm_erb_modify_resp.ue_index);

        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_ERB_MODIFY_RESP] The UE context isn't found.");
            break;
        }

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_ERB_MODIFY_RESP] Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_ERB_MODIFY_RESP] Cell not Active.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }
        /* Check transaction id */
        if (uecc_ue_ctx_get_op_transction_id(p_ue_context) !=
            rrc_get_transaction_id(p_api))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_ERB_MODIFY_RESP] Invalid transaction id.");
            break;
        }

        /* Call UECC_EV_RRM_ERAB_MODIFY_RESP event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_ERAB_MODIFY_RESP,
                &rrc_rrm_erb_modify_resp);
    }
    while(0);

   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_erb_modify_conf
*   INPUT        : uecc_ue_context_t*  p_ue_context,
*                  U16                 response,
*                  U32                 error_code
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds and sends RRC_RRM_ERB_MODIFY_CNF message
*       with response to RRM module for all failed E-RABs
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_erb_modify_conf(
        uecc_ue_context_t*  p_ue_context,
        U16                 response,
        U32                 error_code)
{

    rrc_return_et           rrc_response = RRC_FAILURE;
    rrc_rrm_erb_modify_cnf_t rrc_rrm_erb_modify_cnf;

    U8 drb_index  = RRC_NULL;
    U8 fail_index = RRC_NULL;
    U8 mod_index  = RRC_NULL;

    erab_modify_list_t           *p_mod_list    = PNULL;
    erab_failed_to_modify_list_t *p_failed_list = PNULL;
    /*SPR 22036 Fix Start*/
    erab_list_t*    p_erab_failed_to_rel_list = PNULL;
    /*SPR 22036 Fix Stop*/

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&rrc_rrm_erb_modify_cnf, 0x00, sizeof(rrc_rrm_erb_modify_cnf_t));

    p_mod_list = &(p_ue_context->p_curr_proc_data->u.
            erab_modify_request_data.erab_modify_list);

    p_failed_list = &(p_ue_context->p_curr_proc_data->u.
            erab_modify_request_data.erab_failed_to_modify_list);

    /*SPR 22036 Fix Start*/
    p_erab_failed_to_rel_list = &p_ue_context->p_curr_proc_data->u.erab_modify_request_data.
        erab_release_command_data.erab_failed_to_release_list;
    /*SPR 22036 Fix Stop*/

    rrc_rrm_erb_modify_cnf.ue_index = p_ue_context->ue_index;
    

    if (response == SUCCESS || 
            response == PARTIAL_SUCCESS)
    {
        if (MAX_ERAB_COUNT >= p_mod_list->erab_modify_list_counter)
        {
            /* erab_item_list */
            for (drb_index = 0; 
                    drb_index < p_mod_list->erab_modify_list_counter; 
                    drb_index++)
            {
                if (MAX_LC_COUNT <= mod_index)
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "[RRC_RRM_ERB_MODIFY_CNF] Out of bound Index=%d",mod_index);
                    return rrc_response;
                }
                if (p_mod_list->erab_modify_item[drb_index].status == RRC_SUCCESS)
                {
                    /* Set the Bitmask as the error_list is present */
                    rrc_rrm_erb_modify_cnf.bitmask |= 
                        RRM_ERB_MODIFY_CNF_CONFIRM_LIST_PRESENT;

                    rrc_rrm_erb_modify_cnf.erab_cnf_list.
                        erab_cnf_info[mod_index].erab_id =
                        p_mod_list->erab_modify_item[drb_index].drb_config.erab_id;

                    mod_index++;
                }
            }
        }
        rrc_rrm_erb_modify_cnf.erab_cnf_list.erab_count = mod_index;
    }

/*SPR 22036 Fix Start*/
    if (response == FAILURE || 
            response == PARTIAL_SUCCESS)
    {
        if(p_failed_list->erab_failed_to_modify_list_counter > 0)
    {

        /* erab_item_list */
        for (drb_index = 0; 
                drb_index < p_failed_list->erab_failed_to_modify_list_counter &&
                fail_index < MAX_LC_COUNT; 
                drb_index++)
        {
            if (p_failed_list->erab_failed_to_modify_item[drb_index].failed_at != FAILED_AT_RRM)
            {
            if (p_failed_list->erab_failed_to_modify_item[drb_index].error_code
                    != RRC_ERROR_CODE_LAST)
            {
                /* Set the Bitmask as the error_list is present */
                rrc_rrm_erb_modify_cnf.bitmask |= 
                    RRM_ERB_MODIFY_CNF_ERROR_LIST_PRESENT;

                rrc_rrm_erb_modify_cnf.erab_error_list.
                    erab_error_info[fail_index].erab_id =
                    (U8)p_failed_list->erab_failed_to_modify_item[drb_index].e_RAB_ID;

                if (error_code == RRC_NO_ERROR) 
                {
                    rrc_rrm_erb_modify_cnf.erab_error_list.
                        erab_error_info[fail_index].error_code = 
                        p_failed_list->erab_failed_to_modify_item
                        [drb_index].error_code;
                }
                else
                {
                    p_failed_list->erab_failed_to_modify_item
                        [drb_index].error_code =
                        rrc_rrm_erb_modify_cnf.erab_error_list.
                        erab_error_info[fail_index].error_code = error_code;
                }

                rrc_rrm_erb_modify_cnf.erab_error_list.erab_count++;
                fail_index++;
            }
            }
        }
    }
        /*erab failed release list*/
        if (p_erab_failed_to_rel_list->counter > RRC_NULL)
        {
            for(drb_index = 0;
                    drb_index < p_erab_failed_to_rel_list->counter && fail_index < MAX_LC_COUNT;
                    drb_index++)
            {
                rrc_rrm_erb_modify_cnf.erab_error_list.
                    erab_error_info[fail_index].erab_id =
                    p_erab_failed_to_rel_list->erab_item[drb_index].e_RAB_ID;

                if (error_code == RRC_NO_ERROR) 
                {
                    rrc_rrm_erb_modify_cnf.erab_error_list.
                        erab_error_info[fail_index].error_code = 
                        p_erab_failed_to_rel_list->erab_item[drb_index].error_code;
                }
                else
                {
                    p_failed_list->erab_failed_to_modify_item
                        [drb_index].error_code =
                        p_erab_failed_to_rel_list->erab_item[drb_index].error_code = error_code;
                }
            }
            rrc_rrm_erb_modify_cnf.erab_error_list.erab_count++;
            fail_index++;
        }
    }
/*SPR 22036 Fix Stop*/

    if (response == L3_FATAL)
    {
        rrc_rrm_erb_modify_cnf.response = FAILURE;
    }
    else if ((rrc_rrm_erb_modify_cnf.bitmask & 
                RRM_ERB_MODIFY_CNF_CONFIRM_LIST_PRESENT) && 
            ( rrc_rrm_erb_modify_cnf.bitmask &
              RRM_ERB_MODIFY_CNF_ERROR_LIST_PRESENT))
    {
        rrc_rrm_erb_modify_cnf.response = PARTIAL_SUCCESS;
    }
    else if (rrc_rrm_erb_modify_cnf.bitmask & 
            RRM_ERB_MODIFY_CNF_CONFIRM_LIST_PRESENT)
    {
        rrc_rrm_erb_modify_cnf.response = SUCCESS;
    }
    else if (rrc_rrm_erb_modify_cnf.bitmask &
            RRM_ERB_MODIFY_CNF_ERROR_LIST_PRESENT)
    {
        rrc_rrm_erb_modify_cnf.response = FAILURE;
    }

    /* PUP encoding */
    rrc_response = rrc_rrm_il_send_rrc_rrm_erb_modify_cnf(
            &rrc_rrm_erb_modify_cnf,
            RRC_UECC_MODULE_ID,
            RRC_RRM_MODULE_ID,
            uecc_ue_ctx_get_op_transction_id(p_ue_context),
            p_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return rrc_response;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_rrm_build_and_send_ue_context_mod_req
 *   INPUT        : uecc_ue_context_t   *p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:    This is the function for building and sending
 *                   RRC_RRM_UE_ADMISSION_REQ message to the RRM.
 *
 *   RETURNS:        None
 *
 ******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_ue_context_mod_req(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_rrm_ue_contxt_mod_req_t      rrc_rrm_ue_contxt_mod_req ;
    rrc_return_et                   response = RRC_FAILURE;
/*SPR_18241_START*/
    curr_proc_data_t                *p_curr_proc_data = PNULL; 
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    
    memset_wrapper(&rrc_rrm_ue_contxt_mod_req, 0, sizeof(rrc_rrm_ue_contxt_mod_req_t));


    /* ue_index */
    rrc_rrm_ue_contxt_mod_req.ue_index = p_uecc_ue_context->ue_index;
    
    if(PNULL != p_uecc_ue_context->p_temp_ue_ctx_mod_proc_data)
    {
        p_curr_proc_data = p_uecc_ue_context->p_temp_ue_ctx_mod_proc_data;
    }
    else
    {
        p_curr_proc_data = p_uecc_ue_context->p_curr_proc_data;
    }

    if(PNULL == p_curr_proc_data)
    {
        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                p_uecc_ue_context->p_gb_context->facility_name,
                RRC_WARNING,
                "[uecc_rrm_build_and_send_ue_context_mod_req]"
                " p_curr_proc_data is NULL");
        return response;
    }
    if(PNULL == p_curr_proc_data)
    {
        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                p_uecc_ue_context->p_gb_context->facility_name,
                RRC_WARNING,
                "[uecc_rrm_build_and_send_ue_context_mod_req]"
                " p_curr_proc_data is NULL");
        return response;
    }

    /* ue Aggreagte Max Bit Rate */
    if(p_curr_proc_data->m.AggMaxBitRate)
    {
        rrc_rrm_ue_contxt_mod_req.bitmask |=RRC_RRM_UE_CONTXT_MOD_AMBR_PRESENT; 
        rrc_rrm_ue_contxt_mod_req.ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl =
            p_curr_proc_data->ue_aggregate_maximum_bitrate.
            uEaggregateMaximumBitRateDL;
        rrc_rrm_ue_contxt_mod_req.ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul =
            p_curr_proc_data->ue_aggregate_maximum_bitrate.
            uEaggregateMaximumBitRateUL;
    }
    /* Cs fallback Indicator */
    if(p_curr_proc_data->m.CsfallbackIndicator)
    {
        rrc_rrm_ue_contxt_mod_req.bitmask |= 
            RRC_RRM_UE_CONTXT_MOD_CS_FALLBACK_PRESENT; 
        rrc_rrm_ue_contxt_mod_req.CS_Fallback_Indicator = 
            p_curr_proc_data->cs_fallback_indicator;

        /* Reset Variables */
    //    p_curr_proc_data->m.CsfallbackIndicator = RRC_FALSE;
    }
    /* Subscriber Profile ID */
    if(p_curr_proc_data->spid)
    {
        rrc_rrm_ue_contxt_mod_req.bitmask |=RRC_RRM_UE_CONTXT_MOD_SPID_PRESENT; 
        rrc_rrm_ue_contxt_mod_req.SPID =p_curr_proc_data->spid;

        /* Reset Variables */
        p_curr_proc_data->m.SpId = RRC_FALSE;
    }
    
    /* CSG MEMBERSHIP STATUS */ 
    if(p_curr_proc_data->m.CsgMembershipStatus)
    {
        rrc_rrm_ue_contxt_mod_req.bitmask |=RRC_RRM_UE_CONTXT_MOD_CSG_MEMBERSHIP_STATUS_PRESENT;
        rrc_rrm_ue_contxt_mod_req.csg_membership_status =
            (U8)p_curr_proc_data->csg_membership_status;
    }
   /* CSG MEMBERSHIP STATUS */ 

    /* cr_761 Storing Registered_LAI for Sending it to RRM */
    if((p_curr_proc_data->m.registered_lai_present ) &&
         (PNULL != p_curr_proc_data->p_registered_lai))
    {
        rrc_rrm_ue_contxt_mod_req.bitmask |=
            RRC_RRM_UE_CONTXT_MOD_REGISTERED_LAI_PRESENT;

        rrc_rrm_ue_contxt_mod_req.registered_lai.plmn_identity.num =
                p_curr_proc_data->p_registered_lai->plmn_identity.num;
        
        l3_memcpy_wrapper(&rrc_rrm_ue_contxt_mod_req.registered_lai.plmn_identity.data,
                    p_curr_proc_data->p_registered_lai->plmn_identity.data,
                    p_curr_proc_data->p_registered_lai->plmn_identity.num);
        
        rrc_rrm_ue_contxt_mod_req.registered_lai.lac.num = 
                p_curr_proc_data->p_registered_lai->lac.num;
      
        l3_memcpy_wrapper(&rrc_rrm_ue_contxt_mod_req.registered_lai.lac.data,
                    p_curr_proc_data->p_registered_lai->lac.data,
                    p_curr_proc_data->p_registered_lai->lac.num);
    }
        
/* CSR#59144 fix start */    
    /* If Security Parameters are present in UE Ctx Mod message, then invoke 
       Intracell HO procedure for doing Security ReKeying */
    /* Get T304 Timer from RRM for Intra Cell HO procedure for Security Rekeying if:
     * 1. SecurityKey is presnet OR
     * 2. UE Security Capability is present and at least one of the
     *    following three algorithms derived from UE Security Capability
     *    is different than already stored Algorithms:
     *    a) User Plane Ciphering Algorithm ID
     *    b) Ciphering Algorithm ID
     *    c) Integrity Protection Algorithm ID*/
    else if((p_curr_proc_data->m.SecurityKey_present) ||
            (
             (p_curr_proc_data->m.SecurityCapability_present) &&
             (
              (p_curr_proc_data->userplane_ciphering_algo_id !=
               p_uecc_ue_context->configure_ciphering_user_plane.algorithm_id) ||
              (p_curr_proc_data->ciphering_algo_id !=
               p_uecc_ue_context->configure_ciphering.algorithm_id) ||
              (p_curr_proc_data->integrity_algo_id !=
               p_uecc_ue_context->configure_integrity_protection.algorithm_id)
             )
            )
           )
    {
        p_curr_proc_data->t304_requested_from_rrm = RRC_TRUE;
    }
    /* CSR#59144 fix stop */ 
/*SPR_18241_END*/

    /* Encode and send message */
    response = rrc_rrm_il_send_rrc_rrm_ue_contxt_mod_req(
          &rrc_rrm_ue_contxt_mod_req,
          RRC_UECC_MODULE_ID,
          RRC_RRM_MODULE_ID,
          uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context),
          p_uecc_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}
/******************************************************************************
  *   FUNCTION NAME: uecc_rrm_process_ue_context_modification_resp
  *   INPUT        : void                *p_api
  *                  uecc_gb_context_t   *p_uecc_gb_context
  *   OUTPUT       : none
  *   DESCRIPTION:
  *       This function processes RRM RRC_RRM_UE_CONTXT_MOD_RESP
  *
  *   RETURNS:
  *       None
  *
  *****************************************************************************/
void uecc_rrm_process_ue_context_modification_resp
(
 void                *p_api,             /* Input API buffer */
 uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
 )
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_rrm_ue_contxt_mod_resp_t     rrc_rrm_ue_context_mod_resp;
    S32                             length_read = RRC_NULL;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    
    do
    {
        /* Decode message */
       result = rrc_il_parse_rrc_rrm_ue_contxt_mod_resp(
                &rrc_rrm_ue_context_mod_resp,
                (U8* )p_api +
                RRC_FULL_INTERFACE_HEADERS_SIZE,
                rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                &length_read);
        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_UE_CONTEXT_MOD_RESP]parsing error.");
            break;
        }
        
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", rrc_rrm_ue_context_mod_resp.ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
                rrc_rrm_ue_context_mod_resp.ue_index);

        if(PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_UE_CONTEXT_MOD_RESP]" 
                "The UE context isn't found.");
            break;
        }
        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_UE_CONTEXT_MOD_RESP] Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_UE_CONTEXT_MOD_RESP] Cell not Active.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }
        /* Check transaction id */
        if (uecc_ue_ctx_get_op_transction_id(p_ue_context) !=
                rrc_get_transaction_id(p_api))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_UE_CONTEXT_MOD_RESP]"
                "Invalid transaction id.");
            break;
        }
        /* Call UECC_UE_CONTXT_MOD_RRM_RESP event handler 
         * and pass API data to FSM. */

        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_UE_CONTEXT_MOD_RESP,
                &rrc_rrm_ue_context_mod_resp);
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}


/* ERAB SETUP START */


/* ERAB SETUP STOP */


/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_erb_release_ind_fail_resp
*   INPUT        : void                *p_api,
*                  uecc_ue_context_t   *p_ue_context,
*                  rrc_response_et     response,
*                  U32                 error_code
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds and sends RRC_RRM_ERB_RELEASE_IND_CNF message
*       with failure to RRM module
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_erb_release_ind_fail_resp(
    void                *p_api,
    uecc_ue_context_t   *p_ue_context,
    rrc_response_et     response,
    U32                 error_code)
{

    rrc_return_et   rrc_response = RRC_FAILURE;

    rrc_rrm_erb_release_ind_t     *p_msg;
    rrc_rrm_erb_release_cnf_t     rrc_rrm_erb_release_cnf;

    U8     erab_index   = RRC_NULL;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&rrc_rrm_erb_release_cnf, 0, sizeof(rrc_rrm_erb_release_cnf_t));
    
    p_msg = (rrc_rrm_erb_release_ind_t*)p_api;
    
    rrc_rrm_erb_release_cnf.ue_index = p_ue_context->ue_index;


    rrc_rrm_erb_release_cnf.response = response;

    rrc_rrm_erb_release_cnf.bitmask |= 
            RRM_ERB_RELEASE_CNF_ERROR_LIST_PRESENT;
    
    rrc_rrm_erb_release_cnf.erab_error_list.erab_count = 
    p_msg->erab_to_be_released_item_list.count;

    for (erab_index = 0; 
         erab_index < rrc_rrm_erb_release_cnf.erab_error_list.erab_count;
         erab_index++) 
    {
        rrc_rrm_erb_release_cnf.erab_error_list.
            erab_error_info[erab_index].erab_id = (U8) 
            p_msg->erab_to_be_released_item_list.
            erab_to_be_release_item[erab_index].erab_id; 
        
        rrc_rrm_erb_release_cnf.erab_error_list.
            erab_error_info[erab_index].error_code = error_code; 
    }

    /* PUP encoding */
    rrc_response = rrc_rrm_il_send_rrc_rrm_erb_release_cnf(
                       &rrc_rrm_erb_release_cnf,
                       RRC_UECC_MODULE_ID,
                       RRC_RRM_MODULE_ID,
                       uecc_ue_ctx_get_op_transction_id(p_ue_context),
                       p_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return rrc_response;
}



/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_ue_ho_adm_req
*   INPUT        : uecc_ue_context_t*  p_uecc_ue_context,
*                  rrc_s1ap_handover_request_t *p_rrc_s1ap_ho_request
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds and sends RRC_RRM_UE_HO_ADM_REQ message to RRM.
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_ue_ho_adm_req(
    uecc_ue_context_t*  p_uecc_ue_context,
    rrc_s1ap_handover_request_t *p_rrc_s1ap_ho_request
)
{  
    rrc_return_et result = RRC_FAILURE;
    rrc_source_enb_to_target_enb_transparent_container_t * 
    p_src_to_trg_trans_container = PNULL;
    U8 rat_capability_count = 0;
    src_to_trg_container_t * p_eutra_src_to_trg_container= PNULL;
    UE_CapabilityRAT_ContainerList *p_rat_container_list = PNULL;
    HandoverPreparationInformation_r8_IEs * p_rrc_container = PNULL;
    U32 drb_index = 0;
    /* SPR 13502 Fix Start */
    rrc_rrm_ue_ho_adm_req_t     *p_rrc_rrm_ue_ho_adm_req = PNULL;
    rrm_erab_level_qos_params_t *p_rrm_erab_level_qos_params = PNULL;

    U8 data_fwding_na_list_count = 0;
    s1ap_E_RABToBeSetupListHOReq_element *p_s1ap_erab_to_setup_ho_req_elem = PNULL;
    s1ap_E_RABToBeSetupItemHOReq_iE_Extensions_element
        *p_erab_to_setup_item_ho_req_ie_ext_elem = PNULL;

    
    U8 csg_id_global[CSG_ID_OCTET_SIZE]; /* CR 592: Field Used to compare the CSG ID */
    OSRTDListNode* p_node = PNULL;
    OSRTDListNode* p_node1 = PNULL;
    U8 rrm_erab_count = 0;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_s1ap_ho_request);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_rrc_rrm_ue_ho_adm_req = (rrc_rrm_ue_ho_adm_req_t *)rrc_mem_get
                                (sizeof(rrc_rrm_ue_ho_adm_req_t));
    if (PNULL == p_rrc_rrm_ue_ho_adm_req)
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,
                "Memory Allocation Failure.");
        return RRC_FAILURE;
    }
    /* SES-508 Fix Start */
    /* Code Removed */
    /* SES-508 Fix End */

    if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(p_uecc_ue_context->p_gb_context,
                p_uecc_ue_context->cell_index))
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
            (p_uecc_ue_context->p_gb_context)->facility_name,
            RRC_WARNING,"cell not active");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
	/* Coverity Fix 83395 Start */
        rrc_mem_free (p_rrc_rrm_ue_ho_adm_req);
        p_rrc_rrm_ue_ho_adm_req = PNULL;
	/* Coverity Fix 83395 Stop */
        return RRC_FAILURE;
    }
    do {
        /* Fill message */
        /*ue_index*/
        p_rrc_rrm_ue_ho_adm_req->ue_index = p_uecc_ue_context->ue_index;
        

        /*ho_type*/
        p_rrc_rrm_ue_ho_adm_req->ho_type = (U8)(p_rrc_s1ap_ho_request->handover_type);

        /*cause*/
        p_rrc_rrm_ue_ho_adm_req->cause.type = (U8)(p_rrc_s1ap_ho_request->cause.t);
        p_rrc_rrm_ue_ho_adm_req->cause.value = (U16)
            (p_rrc_s1ap_ho_request->cause.u.radioNetwork);

        /*ue_agg_max_bit_rate*/
        p_rrc_rrm_ue_ho_adm_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul =
            p_uecc_ue_context->ue_aggregate_maximum_bitrate.
            uEaggregateMaximumBitRateUL;
        p_rrc_rrm_ue_ho_adm_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl =
            p_uecc_ue_context->ue_aggregate_maximum_bitrate.
            uEaggregateMaximumBitRateDL;

        /* Filling qos params */
        /* ERAB to be setup list population */
        p_rrc_rrm_ue_ho_adm_req->erab_to_be_setup_item_list.num_of_list =
            p_uecc_ue_context->e_rab_list_count;

        for(drb_index=0; drb_index< MAX_ERAB_COUNT; drb_index++)
        {
            /* Check for presence of DRB config at drb_index */
            if (!p_uecc_ue_context->p_e_rab_list[drb_index])
            {
                continue;
            }

            p_rrc_rrm_ue_ho_adm_req->erab_to_be_setup_item_list.
                erab_to_be_setup_item[rrm_erab_count].erab_id =
                (U8)(drb_index);

            p_rrm_erab_level_qos_params=
                &p_rrc_rrm_ue_ho_adm_req->erab_to_be_setup_item_list.
                erab_to_be_setup_item[rrm_erab_count].erab_level_qos_params;

            p_rrm_erab_level_qos_params->bitmask = 0;

            /* qci */
            p_rrm_erab_level_qos_params->qci =
                p_uecc_ue_context->p_e_rab_list[
                drb_index]->e_RABlevelQoSParameters.qCI;

            /* alloc_and_reten_prior */
            p_rrm_erab_level_qos_params->alloc_and_reten_prior.priority_level =
                p_uecc_ue_context->p_e_rab_list[drb_index]->e_RABlevelQoSParameters.
                allocationRetentionPriority.priorityLevel;

            p_rrm_erab_level_qos_params->alloc_and_reten_prior.
                preemption_capability=
                (U8)(p_uecc_ue_context->p_e_rab_list[
                drb_index]->e_RABlevelQoSParameters.
                     allocationRetentionPriority.pre_emptionCapability);

            p_rrm_erab_level_qos_params->alloc_and_reten_prior.
                preemption_vulnerability=
                (U8)(p_uecc_ue_context->p_e_rab_list[drb_index]->
                     e_RABlevelQoSParameters.allocationRetentionPriority.
                     pre_emptionVulnerability);

            /* gbr_qos_info */
            if(0!=p_uecc_ue_context->p_e_rab_list[drb_index]->
                    e_RABlevelQoSParameters.m.gbrQosInformationPresent)
            {
                p_rrm_erab_level_qos_params->bitmask |=
                    ERAB_LEVEL_QOS_PARAM_GBR_QOS_INFO_PRESENT;
 
                p_rrm_erab_level_qos_params->gbr_qos_info.erab_guar_bit_rate_dl =
                    (U32) p_uecc_ue_context->p_e_rab_list[drb_index]->
                    e_RABlevelQoSParameters.gbrQosInformation.
                    e_RAB_GuaranteedBitrateDL;

                p_rrm_erab_level_qos_params->gbr_qos_info.erab_guar_bit_rate_ul =
                    (U32)p_uecc_ue_context->p_e_rab_list[drb_index]->
                    e_RABlevelQoSParameters.gbrQosInformation.
                    e_RAB_GuaranteedBitrateUL;

                p_rrm_erab_level_qos_params->gbr_qos_info.erab_max_bit_rate_dl=
                    (U32)p_uecc_ue_context->p_e_rab_list[drb_index]->
                    e_RABlevelQoSParameters.gbrQosInformation.
                    e_RAB_MaximumBitrateDL;

                p_rrm_erab_level_qos_params->gbr_qos_info.erab_max_bit_rate_ul=
                    (U32)p_uecc_ue_context->p_e_rab_list[drb_index]->
                    e_RABlevelQoSParameters.gbrQosInformation.
                    e_RAB_MaximumBitrateUL;
            }
            rrm_erab_count++;
        }

        p_node = p_rrc_s1ap_ho_request->e_rab_to_be_setup_list.head;
        for (data_fwding_na_list_count = 0; data_fwding_na_list_count <
                p_rrc_s1ap_ho_request->e_rab_to_be_setup_list.count;
                data_fwding_na_list_count++ )
        {
            RRC_ASSERT(PNULL != p_node);
            RRC_ASSERT(PNULL != p_node->data);

            p_s1ap_erab_to_setup_ho_req_elem =
                ((s1ap_E_RABToBeSetupListHOReq_element *)p_node->data);

            RRC_ASSERT(PNULL != p_s1ap_erab_to_setup_ho_req_elem);
            RRC_ASSERT(PNULL != p_s1ap_erab_to_setup_ho_req_elem->value.u._E_RABToBeSetupItemHOReqIEs_1);

            if(p_s1ap_erab_to_setup_ho_req_elem->value.u._E_RABToBeSetupItemHOReqIEs_1->
                    m.iE_ExtensionsPresent)
            {
                p_node1 =
                    p_s1ap_erab_to_setup_ho_req_elem->value.u.
                    _E_RABToBeSetupItemHOReqIEs_1->iE_Extensions.head;
                RRC_ASSERT(PNULL != p_node1);
                RRC_ASSERT(PNULL != p_node1->data);
                /* Filling  the ext_ie_count*/
                p_rrc_rrm_ue_ho_adm_req->erab_to_be_setup_item_list.
                    erab_to_be_setup_item[data_fwding_na_list_count].bitmask |=
                    ERAB_TO_BE_SETUP_DATA_FWDING_NOT_POSSIBLE_INFO_PRESENT_FLAG;
                /* Fetching the E_RABToBeSetupItemHOReq_iE_Extensions_element*/
                p_erab_to_setup_item_ho_req_ie_ext_elem =
                    (s1ap_E_RABToBeSetupItemHOReq_iE_Extensions_element *)
                    p_node1->data;
                p_rrc_rrm_ue_ho_adm_req->erab_to_be_setup_item_list.
                    erab_to_be_setup_item[data_fwding_na_list_count].
                    data_fwding_not_possible =
                    (U8)p_erab_to_setup_item_ho_req_ie_ext_elem->extensionValue.u._E_RABToBeSetupItemHOReq_ExtIEs_1;
            }
            p_node = p_node->next;
        }

        /* Source to target transparent container */
        if (p_rrc_s1ap_ho_request->
              source_to_target_transparent_container.bitmask &
                RRC_SOURCE_ENB_TO_TARGET_ENB_TRANSPARENT_CONTAINER_PRESENT)
        {
            p_src_to_trg_trans_container = &p_rrc_s1ap_ho_request->
                source_to_target_transparent_container.
                source_enb_to_target_enb_transparent_container;

            /* Store subcriber profile ID */
            p_uecc_ue_context->subscriber_profiler_id = 
                p_src_to_trg_trans_container->subscriberProfileIDforRFP;

            /* RRC_CONTAINER */
            p_rrc_container = &p_src_to_trg_trans_container->rRC_Container;

            /* RRC_CONTAINER:UE Radio Access Capability */
            p_rat_container_list = &p_rrc_container->
                    ue_RadioAccessCapabilityInfo;

            p_eutra_src_to_trg_container = 
            &p_rrc_rrm_ue_ho_adm_req->src_to_trg_container;

            p_node = p_rat_container_list->head;

            p_uecc_ue_context->m.access_stratum_release = 1;

            for(rat_capability_count = 0;
                    rat_capability_count < p_rat_container_list->count ;
                    rat_capability_count++)
            {
                RRC_ASSERT(PNULL != p_node);
                RRC_ASSERT(PNULL != p_node->data);

                if (RRC_FAILURE ==
                    uecc_rrm_build_ue_rat_capability(p_uecc_ue_context,
                        &p_eutra_src_to_trg_container->rrc_radio_capability_info,
                        p_node->data))
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "uecc_rrm_build_ue_rat_capability failed");
                    p_uecc_ue_context->m.access_stratum_release = 0;
                    break;
                }
                /* storing in the uecc context */
                if (RRC_FAILURE == 
                        uecc_save_ue_rat_capability(
                        p_uecc_ue_context,p_node->data))
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "uecc_rrm_build_ue_rat_capability failed");
                    p_uecc_ue_context->m.access_stratum_release = 0;
                    break;
                }
               
                p_node = p_node->next;
            }

            if (RRC_FAILURE == rrc_rrm_build_s1ap_ho_adm_req(
                        p_uecc_ue_context,
                        p_rrc_s1ap_ho_request,
                        p_rrc_container,
                        &p_rrc_rrm_ue_ho_adm_req->src_to_trg_container,
                        &p_rrc_rrm_ue_ho_adm_req->erab_to_be_setup_item_list,
                        p_src_to_trg_trans_container))

            {
                break;
            }
        }

        /* Ho Restriction List */
        if (p_rrc_s1ap_ho_request->bitmask & 
                RRC_S1AP_HANDOVER_REQUEST_HO_RESTRICTION_LIST_PRESENT)
        {
            p_rrc_rrm_ue_ho_adm_req->bitmask |=
                RRC_RRM_UE_HO_ADM_REQ_HO_RESTRICTION_LIST_PRESENT;

            if (RRC_FAILURE == process_fill_ho_restriction_list(
                        p_uecc_ue_context,
                        &p_rrc_rrm_ue_ho_adm_req->ho_restriction_list,
                        &p_rrc_s1ap_ho_request->ho_restriction_list))
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "process_fill_ho_restriction_list failed");
                break;
            }
        }

        /* Request type */
        if (p_rrc_s1ap_ho_request->bitmask & 
                RRC_S1AP_HANDOVER_REQUEST_REQUEST_TYPE_PRESENT)
        {
            p_rrc_rrm_ue_ho_adm_req->bitmask |=
                RRC_RRM_UE_HO_ADM_REQ_REQUEST_TYPE_PRESENT;

            p_rrc_rrm_ue_ho_adm_req->request_type.event_type = 
                (U8)(p_rrc_s1ap_ho_request->request_type.eventType);

            p_rrc_rrm_ue_ho_adm_req->request_type.report_area = 
                (U8)(p_rrc_s1ap_ho_request->request_type.reportArea);
        }

        /* Srvcc operation possible */
        if (p_rrc_s1ap_ho_request->bitmask & 
                RRC_S1AP_HANDOVER_REQUEST_SRVCC_OPERATION_POSSIBLE_PRESENT)
        {
            p_rrc_rrm_ue_ho_adm_req->bitmask |=
                RRC_RRM_UE_HO_ADM_REQ_SRVCC_OP_POSSIBLE_PRESENT;

            /* srvcc-u start */
            p_rrc_rrm_ue_ho_adm_req->srvcc_op_possible = RRC_TRUE;
            /* srvcc-u end */
        }

        if ((PNULL != p_uecc_ue_context->p_gb_context->p_p_csc_context) &&
            (PNULL != p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->cell_index]) &&
            (PNULL != p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->cell_index]->
                        p_csc_init_setup_ind)) 
        {
            /* BUG_8106 */
                    /*cr_592 CSG membership status */
            if(p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->cell_index]->
                            p_csc_init_setup_ind->sib_type_1_Info.cell_access_related_info.presence_bitmask & 
                        CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG)
            {

            /* Coverity Fix 20188 Start */
                        l3_strncpy_wrapper((S8 *)csg_id_global,
                                (const S8 *)(p_uecc_ue_context->p_gb_context->p_p_csc_context[p_uecc_ue_context->cell_index]->
                                p_csc_init_setup_ind->sib_type_1_Info.cell_access_related_info.csg_identity),
                                CSG_ID_OCTET_SIZE);
            /* Coverity Fix 20188 Start */

                        csg_id_global[CSG_ID_OCTET_SIZE-1] &= CSG_RESET_VAL; /* Reset the last 5 bits */

                        /* CSG membership status*/
                        if(p_rrc_s1ap_ho_request->bitmask & RRC_S1AP_HANDOVER_REQUEST_CSG_MEMBERSHIP_STATUS_PRESENT)
                        {
                            /* SPR:10350 Start */
                            p_rrc_rrm_ue_ho_adm_req->bitmask |=
                                RRC_RRM_UE_HO_ADM_REQ_CSG_MEMBERSHIP_STATUS_PRESENT;
                            /* SPR:10350 Stop */
                            if((s1ap_member == p_rrc_s1ap_ho_request->csg_membership_status)
                                    && (0 == memcmp_wrapper(p_rrc_s1ap_ho_request->csg_id.data, csg_id_global,
                                            sizeof(U32))))
                            {
                                p_rrc_rrm_ue_ho_adm_req->csg_membership_status = RRC_MEMBER;    
                            }
                            else if(0 != memcmp_wrapper(p_rrc_s1ap_ho_request->csg_id.data,csg_id_global,
                                        sizeof(U32)))
                            {
                                p_rrc_rrm_ue_ho_adm_req->csg_membership_status = RRC_NOT_MEMBER;
                                p_uecc_ue_context->trg_ho_csg_id_fail_flag = RRC_TRUE; 
                            } 
                        }
            }
            /* BUG_8106 */
        }
        else
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"GLOBAL CSG ID NOT PRESENT IN SIB 1.");    
            break;
        }
       
        /*Storing current ScellConfiguration of UE (sent to RRM) in UE context*/
        if (PNULL == p_uecc_ue_context->p_scell_config)
        {
            p_uecc_ue_context->p_scell_config = rrc_mem_get(sizeof(rrm_scell_config_t));
            if (PNULL == p_uecc_ue_context->p_scell_config)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL," p_uecc_ue_context->p_scell_config: rrc_mem_get failed !");
                /*Coverity 83395 Fix Start*/
                if (PNULL != p_rrc_rrm_ue_ho_adm_req)
                {
                    rrc_mem_free (p_rrc_rrm_ue_ho_adm_req);
                    p_rrc_rrm_ue_ho_adm_req = PNULL;
                }
                /*Coverity 83395 Fix End*/

                return RRC_FAILURE;
            }
            else
            {
                if ((p_rrc_rrm_ue_ho_adm_req->src_to_trg_container.bitmask & 
                            SRC_TO_TRG_CONTAINER_AS_CONFIG_EXT_PRESENT) &&
                        (p_rrc_rrm_ue_ho_adm_req->src_to_trg_container.as_config_ext.bitmask & 
                            SRC_TO_TRG_CONTAINER_AS_CONFIG_SCELL_ADD_MOD_LIST_PRESENT))
                {
                    /* SES-508 Fix Start */
                    /* Code Removed */
                    /* SES-508 Fix End */

                    p_uecc_ue_context->m.scell_config_present = RRC_TRUE;

                    p_uecc_ue_context->p_scell_config->bitmask |=
                        RRM_SCELL_ADD_MOD_LIST_PRESENT;

                    l3_memcpy_wrapper(&p_uecc_ue_context->p_scell_config->scell_add_mod_list,   
                            &p_rrc_rrm_ue_ho_adm_req->src_to_trg_container.as_config_ext.scell_add_mod_list,
                            sizeof(rrc_scell_to_add_mod_list_t));
                }            
            }
        }

        /* mme grp id feature changes start */
        if (RRC_TRUE == p_uecc_ue_context->m.source_gummei_present)
        {
            p_rrc_rrm_ue_ho_adm_req->bitmask |=
                RRC_RRM_UE_HO_ADM_REQ_GUMMEI_INFO_PRESENT;

            uecc_s1ap_generate_plmn_identity_to_int(
                    &(p_rrc_rrm_ue_ho_adm_req->gummei_info.
                    plmn_identity),p_uecc_ue_context->gummei.
                     plmn_identity.data);

            l3_memcpy_wrapper(((void*)p_rrc_rrm_ue_ho_adm_req->gummei_info.
                        mme_group_id),((const void*)&p_uecc_ue_context->
                            gummei.grp_id.data),MAX_MME_GRP_BYTES);

            l3_memcpy_wrapper(((void*)&p_rrc_rrm_ue_ho_adm_req->gummei_info.mmec),
                    ((const void*)&p_uecc_ue_context->gummei.mme_code.data),
                    sizeof(U8));

        }
        /* mme grp id feature changes stop */

        /* SPR 20632 21459 START */
        p_rrc_rrm_ue_ho_adm_req->mme_id = p_uecc_ue_context->mme_id;
        p_rrc_rrm_ue_ho_adm_req->bitmask |= RRC_RRM_UE_HO_ADM_REQ_MME_ID_PRESENT;
        /* SPR 20632 21459 END */

        /* PUP encode and send */
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                  (p_uecc_ue_context->p_gb_context)->facility_name, RRC_INFO,
                  "API:RRC->RRM:RRC_RRM_UE_HO_ADM_REQ:[UE:%u] with HO_type:%u cause:%u",
                  p_rrc_rrm_ue_ho_adm_req->ue_index, p_rrc_rrm_ue_ho_adm_req->ho_type, 
                  p_rrc_rrm_ue_ho_adm_req->cause);

        result = rrc_rrm_il_send_rrc_rrm_ue_ho_adm_req(
                p_rrc_rrm_ue_ho_adm_req,
                RRC_UECC_MODULE_ID,
                RRC_RRM_MODULE_ID,
                uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context),
                p_uecc_ue_context->cell_index);
    }while (0);

    if (PNULL != p_rrc_rrm_ue_ho_adm_req)
    {
	rrc_mem_free (p_rrc_rrm_ue_ho_adm_req);
	/*Coverity 83395 Fix Start*/
	p_rrc_rrm_ue_ho_adm_req = PNULL;
	/*Coverity 83395 Fix End*/
    }
    /* SPR 13502 Fix Stop */

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}


/******************************************************************************
 *   FUNCTION NAME: uecc_rrm_build_and_send_x2ap_ue_ho_adm_req 
 *   INPUT        : uecc_ue_context_t*  p_uecc_ue_context,
 *                  rrc_x2ap_handover_request_t *p_rrc_x2ap_ho_request
 *   OUTPUT       : none
 *   DESCRIPTION:
 *       This function builds and sends RRC_RRM_UE_HO_ADM_REQ message to RRM.
 *
 *   RETURNS:
 *       RRC_SUCCESS/RRC_FAILURE
 *
 ******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_x2ap_ue_ho_adm_req(
        uecc_ue_context_t*  p_uecc_ue_context,
        rrc_x2ap_handover_request_t *p_rrc_x2ap_ho_request
        )
{  
    rrc_return_et result = RRC_FAILURE;
    x2ap_UE_ContextInformation * 
      p_src_to_trg_trans_container = PNULL;
    U8 rat_capability_count = 0;
    src_to_trg_container_t * p_eutra_src_to_trg_container= PNULL;
    UE_CapabilityRAT_ContainerList *p_rat_container_list = PNULL;
    HandoverPreparationInformation_r8_IEs * p_rrc_container = PNULL;
    U32 drb_index = 0;
    /* SPR 13502 Fix Start */
    rrc_rrm_ue_ho_adm_req_t    *p_rrc_rrm_ue_ho_adm_req = PNULL;
    rrm_erab_level_qos_params_t *p_rrm_erab_level_qos_params = PNULL;
    U8 e_rab_list_count = 0;
    AS_Config * p_s1ap_as_config = PNULL;

    OSRTDListNode* p_node = PNULL;
    U8 rrm_erab_count = 0;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_x2ap_ho_request);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_rrc_rrm_ue_ho_adm_req = (rrc_rrm_ue_ho_adm_req_t *)rrc_mem_get
                                (sizeof(rrc_rrm_ue_ho_adm_req_t));
    if (PNULL == p_rrc_rrm_ue_ho_adm_req)
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,
                "Memory Allocation Failure.");
        return RRC_FAILURE;
    }
    /* SES-508 Fix Start */
    /* Code Removed */
    /* SES-508 Fix End */

    do {
        /* Fill message */
        /*ue_index*/
        p_rrc_rrm_ue_ho_adm_req->ue_index = p_uecc_ue_context->ue_index;
        

        /*ho_type*/
        if (X2_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover) 
        {
            p_rrc_rrm_ue_ho_adm_req->ho_type = HANDOVER_TYPE_INTRA_LTE_X2;
        }
        else if(INTER_CELL_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover)
        {
            p_rrc_rrm_ue_ho_adm_req->ho_type = HANDOVER_TYPE_INTER_CELL;
        }
        /*BUG 604 changes start*/
        else if(INTRA_CELL_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover)
        {
            p_rrc_rrm_ue_ho_adm_req->ho_type = HANDOVER_TYPE_INTRA_CELL;
        }
        /*BUG 604 changes stop*/

        /*cause*/
        p_rrc_rrm_ue_ho_adm_req->cause.type = (U8)(p_rrc_x2ap_ho_request->cause.t);
        p_rrc_rrm_ue_ho_adm_req->cause.value = 
            (U16)(p_rrc_x2ap_ho_request->cause.u.radioNetwork);

        /*ue_agg_max_bit_rate*/
        p_rrc_rrm_ue_ho_adm_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul =
            p_uecc_ue_context->ue_aggregate_maximum_bitrate.
            uEaggregateMaximumBitRateUL;
        p_rrc_rrm_ue_ho_adm_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl =
            p_uecc_ue_context->ue_aggregate_maximum_bitrate.
            uEaggregateMaximumBitRateDL;

        /* Filling qos params */
        /* ERAB to be setup list population */
        p_rrc_rrm_ue_ho_adm_req->erab_to_be_setup_item_list.num_of_list =
            p_uecc_ue_context->e_rab_list_count;

        for(drb_index=0; drb_index< MAX_ERAB_COUNT; drb_index++)
        {
            /* Check for presence of DRB config at drb_index */
            if (!p_uecc_ue_context->p_e_rab_list[drb_index])
            {
                continue;
            }

            p_rrc_rrm_ue_ho_adm_req->erab_to_be_setup_item_list.
                erab_to_be_setup_item[rrm_erab_count].erab_id =
                (U8)(drb_index);

            p_rrm_erab_level_qos_params=
                &p_rrc_rrm_ue_ho_adm_req->erab_to_be_setup_item_list.
                erab_to_be_setup_item[rrm_erab_count].erab_level_qos_params;

            p_rrm_erab_level_qos_params->bitmask = 0;

            /* qci */
            p_rrm_erab_level_qos_params->qci =
                p_uecc_ue_context->p_e_rab_list[
                drb_index]->uecc_x2ap_drb_ctx.e_RABlevelQoSParameters.qCI;

            /* alloc_and_reten_prior */
            p_rrm_erab_level_qos_params->alloc_and_reten_prior.priority_level =
                p_uecc_ue_context->p_e_rab_list[drb_index]->uecc_x2ap_drb_ctx.
                e_RABlevelQoSParameters.allocationAndRetentionPriority.
                priorityLevel;

            p_rrm_erab_level_qos_params->alloc_and_reten_prior.
                preemption_capability=
                (U8)(p_uecc_ue_context->p_e_rab_list[
                     drb_index]->uecc_x2ap_drb_ctx.e_RABlevelQoSParameters.
                     allocationAndRetentionPriority.pre_emptionCapability);

            p_rrm_erab_level_qos_params->alloc_and_reten_prior.
                preemption_vulnerability=
                (U8)(p_uecc_ue_context->p_e_rab_list[drb_index]->
                     uecc_x2ap_drb_ctx.e_RABlevelQoSParameters.
                     allocationAndRetentionPriority.pre_emptionVulnerability);

            /* gbr_qos_info */
            if(0!=p_uecc_ue_context->p_e_rab_list[drb_index]->
                    uecc_x2ap_drb_ctx.e_RABlevelQoSParameters.m.
                    gbrQosInformationPresent)
            {
                p_rrm_erab_level_qos_params->bitmask |=
                    ERAB_LEVEL_QOS_PARAM_GBR_QOS_INFO_PRESENT;

                p_rrm_erab_level_qos_params->gbr_qos_info.erab_guar_bit_rate_dl=
                    (U32) p_uecc_ue_context->p_e_rab_list[drb_index]->
                    uecc_x2ap_drb_ctx.e_RABlevelQoSParameters.gbrQosInformation.
                    e_RAB_GuaranteedBitrateDL;

                p_rrm_erab_level_qos_params->gbr_qos_info.erab_guar_bit_rate_ul=
                    (U32)p_uecc_ue_context->p_e_rab_list[drb_index]->
                    uecc_x2ap_drb_ctx.e_RABlevelQoSParameters.gbrQosInformation.
                    e_RAB_GuaranteedBitrateUL;

                p_rrm_erab_level_qos_params->gbr_qos_info.erab_max_bit_rate_dl=
                    (U32)p_uecc_ue_context->p_e_rab_list[drb_index]->
                    uecc_x2ap_drb_ctx.e_RABlevelQoSParameters.gbrQosInformation.
                    e_RAB_MaximumBitrateDL;

                p_rrm_erab_level_qos_params->gbr_qos_info.erab_max_bit_rate_ul=
                    (U32)p_uecc_ue_context->p_e_rab_list[drb_index]->
                    uecc_x2ap_drb_ctx.e_RABlevelQoSParameters.gbrQosInformation.
                    e_RAB_MaximumBitrateUL;
            }
            rrm_erab_count++;
        }
        /* Source to target transparent container */
        p_src_to_trg_trans_container = &p_rrc_x2ap_ho_request->
            rrc_x2ap_ue_ctx_info.ue_context_info;

        /* Store subcriber profile ID */
        if(p_src_to_trg_trans_container->m.subscriberProfileIDforRFPPresent)
        {
            p_uecc_ue_context->subscriber_profiler_id = 
                p_src_to_trg_trans_container->subscriberProfileIDforRFP;
        }
        /* RRC_CONTAINER */
        p_rrc_container = &p_rrc_x2ap_ho_request->rrc_x2ap_ue_ctx_info.
                            rRC_Container;

        /* RRC_CONTAINER:UE Radio Access Capability */
        p_rat_container_list = &p_rrc_container->
            ue_RadioAccessCapabilityInfo;

        p_eutra_src_to_trg_container = 
            &p_rrc_rrm_ue_ho_adm_req->src_to_trg_container;

        p_node = p_rat_container_list->head;

        p_uecc_ue_context->m.access_stratum_release = 1;

        for(rat_capability_count = 0;
                rat_capability_count < p_rat_container_list->count ;
                rat_capability_count++)
        {
            RRC_ASSERT(PNULL != p_node);
            RRC_ASSERT(PNULL != p_node->data);

            if (RRC_FAILURE ==
                    uecc_rrm_build_ue_rat_capability(p_uecc_ue_context,
                        &p_eutra_src_to_trg_container->rrc_radio_capability_info,
                        p_node->data))
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "uecc_rrm_build_ue_rat_capability failed");
                p_uecc_ue_context->m.access_stratum_release = 0;
                break;
            }
            /* storing in the uecc context */
            if (RRC_FAILURE == 
                    uecc_save_ue_rat_capability(
                        p_uecc_ue_context,p_node->data))
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "uecc_rrm_build_ue_rat_capability failed");
                p_uecc_ue_context->m.access_stratum_release = 0;
                break;
            }

            p_node = p_node->next;
        }

        /* check for the mandatory IE  */
        /* RRC_CONTAINER:AS Config and RRC_CONTAINER:AS Context, 
           both IEs must be present , if the HO type is of  "IntraLTE", 
           TS 36.433, SECTION 10.2.2
        */
        if ((0 != p_rrc_container->m.as_ConfigPresent) 
                &&  (0 != p_rrc_container->m.as_ContextPresent))
        {
            p_eutra_src_to_trg_container->bitmask |=
                SRC_TO_TRG_CONTAINER_AS_CONFIG_PRESENT;

            p_eutra_src_to_trg_container->bitmask |=
                SRC_TO_TRG_CONTAINER_AS_CONTEXT_PRESENT;

            if ((p_rrc_container->as_Config.m._v3ExtPresent == 1) &&
                    (p_rrc_container->as_Config.m.sourceSCellConfigList_r10Present == 1))
            {
                p_eutra_src_to_trg_container->bitmask |=
                    SRC_TO_TRG_CONTAINER_AS_CONFIG_EXT_PRESENT;

                p_eutra_src_to_trg_container->as_config_ext.bitmask |=
                    SRC_TO_TRG_CONTAINER_AS_CONFIG_SCELL_ADD_MOD_LIST_PRESENT;

                if (RRC_FAILURE == uecc_rrm_build_scell_config_info (
                        p_uecc_ue_context,
                        &p_eutra_src_to_trg_container->as_config_ext,
                        &p_rrc_container->as_Config.sourceSCellConfigList_r10))
                {
                    RRC_UECC_TRACE ((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR, 
                            "Error occurred while building ScellConfigInfo ");
                    break;
                }
            }
            
            if (RRC_FAILURE ==
                    process_and_fill_as_config_from_s1ap_ho_request(
                        p_uecc_ue_context,
                        &p_eutra_src_to_trg_container->as_config,
                        &p_rrc_container->as_Config))
            {
                RRC_UECC_TRACE ((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "Error occurred during the processing of as_config IE !!");
                break;
            }
            /* Copy Proximity Configuration */
            p_s1ap_as_config = &p_rrc_container->as_Config;

            if ((p_s1ap_as_config->m._v2ExtPresent) &&
                    (p_s1ap_as_config->sourceOtherConfig_r9.
                     m.reportProximityConfig_r9Present))
            {
                p_eutra_src_to_trg_container->bitmask |= SRC_TO_TRG_CONTAINER_AS_CONFIG_PROXIMITY_CONFIG_PRESENT;
                if (p_s1ap_as_config->sourceOtherConfig_r9.
                        reportProximityConfig_r9.m.proximityIndicationEUTRA_r9Present)
                {
                    p_eutra_src_to_trg_container->proximity_config.bitmask |= RRM_PROXIMITY_IND_EUTRA_PRESENT;

                    p_eutra_src_to_trg_container->proximity_config.proximity_ind_eutra =
                        (U8)p_s1ap_as_config->sourceOtherConfig_r9.
                        reportProximityConfig_r9.proximityIndicationEUTRA_r9;
                }

                if (p_s1ap_as_config->sourceOtherConfig_r9.
                        reportProximityConfig_r9.m.proximityIndicationUTRA_r9Present)
                {
                    p_eutra_src_to_trg_container->proximity_config.bitmask |= RRM_PROXIMITY_IND_UTRA_PRESENT;

                    p_eutra_src_to_trg_container->proximity_config.proximity_ind_utra =
                        (U8)p_s1ap_as_config->sourceOtherConfig_r9.
                        reportProximityConfig_r9.proximityIndicationUTRA_r9;
                }
            }

            if (RRC_FAILURE ==
                    process_and_fill_as_context_from_s1ap_ho_request(
                        p_uecc_ue_context,
                        &p_eutra_src_to_trg_container->as_context,
                        &p_rrc_container->as_Context))
            {
                RRC_UECC_TRACE ((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "Error occurred during the processing of as_context IE!!");
                break;
            }

        }
        else
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "Mandatory IE (AS-Config , AS-Context) absent \
                    in HandoverPreparationInformation-r8-IEs !!"); 
	        /* Coverity Fix 83410 Fix Start */
	        break;
	        /* Coverity Fix 83410 Fix Stop */
        }

        /* RRC_CONTAINER:RRM Config , this is an optional one in all cases,
           whether its Intra or Inter LTE */
    /*SPR_19066_START*/
    /* Code Removed */
    /*SPR_19066_END*/

        /* RRC_CONTAINER:Subscriber profile ID */
        if (p_src_to_trg_trans_container->m.subscriberProfileIDforRFPPresent)
        {
            p_eutra_src_to_trg_container->bitmask |= 
                SRC_TO_TRG_CONTAINER_SUB_PROFILE_ID_PRESENT;
            p_eutra_src_to_trg_container->sub_profile_id = 
                p_src_to_trg_trans_container->
                subscriberProfileIDforRFP;
        }

        /* UE History Information*/
        if (RRC_FAILURE == 
                process_and_fill_ue_history_from_x2ap_ho_request(
                    p_uecc_ue_context,
                    &p_eutra_src_to_trg_container->ue_history,
                    &p_rrc_x2ap_ho_request->ue_history_info))
        {
            break;
        }

        /* ERAB INFO LIST */
        p_node = p_src_to_trg_trans_container->e_RABs_ToBeSetup_List.head;

        for (e_rab_list_count =0; e_rab_list_count < 
                p_src_to_trg_trans_container->
                e_RABs_ToBeSetup_List.count; 
                e_rab_list_count++)
        {
            RRC_ASSERT(PNULL != p_node);
            RRC_ASSERT(PNULL != p_node->data);
            RRC_ASSERT(PNULL != (((x2ap_E_RABs_ToBeSetup_List_element*)p_node->data)->
                    value.u._x2ap_E_RABs_ToBeSetup_ItemIEs_1));

            if(((x2ap_E_RABs_ToBeSetup_List_element*)p_node->data)->
                    value.u._x2ap_E_RABs_ToBeSetup_ItemIEs_1->m.dL_ForwardingPresent)
            {
                for(drb_index=0;
                        drb_index < p_rrc_rrm_ue_ho_adm_req->erab_to_be_setup_item_list.
                        num_of_list;
                        drb_index++)
                {
                    if(p_rrc_rrm_ue_ho_adm_req->erab_to_be_setup_item_list.
                            erab_to_be_setup_item[drb_index].erab_id ==
                            ((x2ap_E_RABs_ToBeSetup_List_element*)p_node->data)->
                            value.u._x2ap_E_RABs_ToBeSetup_ItemIEs_1->e_RAB_ID)
                    {
                        p_rrc_rrm_ue_ho_adm_req->erab_to_be_setup_item_list.
                            erab_to_be_setup_item [drb_index].dl_fwding = 1;
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_INFO, "DL_FWD SET For E_RAB ID = %u",
                                p_rrc_rrm_ue_ho_adm_req->erab_to_be_setup_item_list.
                                erab_to_be_setup_item [drb_index].erab_id);
                        break;

                    }

                }
            }
            p_node = p_node->next;
        }

        /* Ho Restriction List */
        if (p_src_to_trg_trans_container->m.handoverRestrictionListPresent)
        {
            p_rrc_rrm_ue_ho_adm_req->bitmask |=
                RRC_RRM_UE_HO_ADM_REQ_HO_RESTRICTION_LIST_PRESENT;
            process_fill_x2ap_ho_restriction_list(
                    p_uecc_ue_context,
                    &p_rrc_rrm_ue_ho_adm_req->ho_restriction_list,
                    &p_src_to_trg_trans_container->handoverRestrictionList);
        }

        /* SRVCC operation possible */
        if (p_rrc_x2ap_ho_request->bitmask &
                X2AP_HANDOVER_REQ_SRVCC_OPERATION_POSSIBLE_PRESENT) 
                
        {
            p_rrc_rrm_ue_ho_adm_req->bitmask |=
                RRC_RRM_UE_HO_ADM_REQ_SRVCC_OP_POSSIBLE_PRESENT;

            /* srvcc-u start */
            p_rrc_rrm_ue_ho_adm_req->srvcc_op_possible = RRC_TRUE;
            /* srvcc-u end */
        }

        if (p_rrc_x2ap_ho_request->bitmask &
                X2AP_HANDOVER_REQ_CSG_MEMBERSHIP_STATUS_PRESENT) 
                
        {
            p_rrc_rrm_ue_ho_adm_req->bitmask |=
                RRC_RRM_UE_HO_ADM_REQ_CSG_MEMBERSHIP_STATUS_PRESENT;

            p_rrc_rrm_ue_ho_adm_req->csg_membership_status = (U8) (p_rrc_x2ap_ho_request->
                    csg_membership_status);
        }

        /*Storing current ScellConfiguration of UE (sent to RRM) in UE context*/
        if (PNULL == p_uecc_ue_context->p_scell_config)
        {
            p_uecc_ue_context->p_scell_config = rrc_mem_get(sizeof(rrm_scell_config_t));
            if (PNULL == p_uecc_ue_context->p_scell_config)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_FATAL,"p_uecc_ue_context->p_scell_config: rrc_mem_get failed !");
                /*Coverity 83410 Fix Start*/
                if (PNULL != p_rrc_rrm_ue_ho_adm_req)
                {
                    rrc_mem_free (p_rrc_rrm_ue_ho_adm_req);
                    p_rrc_rrm_ue_ho_adm_req = PNULL;
                }
                /*Coverity 83410 Fix End*/
                return RRC_FAILURE;
            }
            else
            {
                /* SES-508 Fix Start */
                /* Code Removed */
                /* SES-508 Fix End */

                if ((p_rrc_rrm_ue_ho_adm_req->src_to_trg_container.bitmask & 
                            SRC_TO_TRG_CONTAINER_AS_CONFIG_EXT_PRESENT) &&
                        (p_rrc_rrm_ue_ho_adm_req->src_to_trg_container.as_config_ext.bitmask & 
                            SRC_TO_TRG_CONTAINER_AS_CONFIG_SCELL_ADD_MOD_LIST_PRESENT))
                {
                    p_uecc_ue_context->m.scell_config_present = RRC_TRUE;

                    p_uecc_ue_context->p_scell_config->bitmask |=
                        RRM_SCELL_ADD_MOD_LIST_PRESENT;

                    l3_memcpy_wrapper(&p_uecc_ue_context->p_scell_config->scell_add_mod_list,   
                            &p_rrc_rrm_ue_ho_adm_req->src_to_trg_container.as_config_ext.scell_add_mod_list,
                            sizeof(rrc_scell_to_add_mod_list_t));
                }            
            }
        }

        /* mme grp id feature changes start */
        if (RRC_TRUE == p_uecc_ue_context->m.source_gummei_present)
        {
            p_rrc_rrm_ue_ho_adm_req->bitmask |=
                RRC_RRM_UE_HO_ADM_REQ_GUMMEI_INFO_PRESENT;

            uecc_s1ap_generate_plmn_identity_to_int(
                    &(p_rrc_rrm_ue_ho_adm_req->gummei_info.
                    plmn_identity),p_uecc_ue_context->gummei.
                     plmn_identity.data);

            l3_memcpy_wrapper(((void*)p_rrc_rrm_ue_ho_adm_req->gummei_info.
                        mme_group_id),((const void*)&p_uecc_ue_context->
                            gummei.grp_id.data),MAX_MME_GRP_BYTES);

            l3_memcpy_wrapper(((void*)&p_rrc_rrm_ue_ho_adm_req->gummei_info.mmec),
                    ((const void*)&p_uecc_ue_context->gummei.mme_code.data),
                    sizeof(U8));

        }
        /* mme grp id feature changes stop */

        /* PUP encode and send */

        result = rrc_rrm_il_send_rrc_rrm_ue_ho_adm_req(
                p_rrc_rrm_ue_ho_adm_req,
                RRC_UECC_MODULE_ID,
                RRC_RRM_MODULE_ID,
                uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context),
                p_uecc_ue_context->cell_index);
    }while (0);

    if (PNULL != p_rrc_rrm_ue_ho_adm_req)
    {
        rrc_mem_free (p_rrc_rrm_ue_ho_adm_req);
	/*Coverity 83410 Fix Start*/
	p_rrc_rrm_ue_ho_adm_req = PNULL;
	/*Coverity 83410 Fix End*/
    }
    /* SPR 13502 Fix Stop */

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_ue_ho_adm_cnf
*   INPUT        : uecc_ue_context_t*  p_ue_context,
*                  rrc_return_et response
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds and sends RRC_RRM_UE_HO_ADM_CNF message to RRM.
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_ue_ho_adm_cnf(
    uecc_ue_context_t*  p_ue_context,
    rrc_return_et response
)
{
    rrc_counter_t erab_count = 0;
    rrc_counter_t erab_index = 0;
    rrc_rrm_ue_ho_adm_cnf_t rrc_rrm_ue_ho_adm_cnf;
    erab_item_list_t * p_erab_item_list = PNULL;
    rrm_erab_to_be_released_item_list_t *p_erab_to_be_released_item_list 
        = PNULL;
    rrm_erab_failed_item_list_t *p_rrm_erab_failed_item_list
        = PNULL;
    uecc_e_rab_failed_to_add_list_t* p_uecc_erab_failed_item_list
        = PNULL;
    /*Cov 63642_63641 fix start*/
    if(PNULL == p_ue_context)
    {
        return RRC_FAILURE;
    }
    /*Cov 63642_63641 fix end*/
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    memset_wrapper(&rrc_rrm_ue_ho_adm_cnf, 0, sizeof(rrc_rrm_ue_ho_adm_cnf_t));

    rrc_rrm_ue_ho_adm_cnf.ue_index = p_ue_context->ue_index;
        

    rrc_rrm_ue_ho_adm_cnf.response = response;

/*BUG 604 changes start*/
    //if (INTRA_CELL_HO != p_ue_context->ho_info.s1_or_x2_handover)
    //{
/*BUG 604 changes stop*/
        /* rrc_rrm_ue_ho_adm_cnf.erab_item_list successfully allocated*/
        p_erab_item_list = &rrc_rrm_ue_ho_adm_cnf.erab_item_list;
        p_rrm_erab_failed_item_list = &rrc_rrm_ue_ho_adm_cnf.erab_failed_item_list;

/*BUG 604 changes start*/
        if ((X2_HO == p_ue_context->ho_info.s1_or_x2_handover) ||
            (INTER_CELL_HO == p_ue_context->ho_info.s1_or_x2_handover)||
            (INTRA_CELL_HO == p_ue_context->ho_info.s1_or_x2_handover))
/*BUG 604 changes stop*/
        {
            p_erab_to_be_released_item_list = 
                &rrc_rrm_ue_ho_adm_cnf.erab_to_be_released_item_list;
        }
        for (erab_count = 0; erab_count < MAX_ERAB_COUNT; erab_count++)
        {
            if (p_ue_context->p_e_rab_list[erab_count])
            {
                /*SPR_17382_START*/
/*BUG 604 changes start*/
                if (((X2_HO == p_ue_context->ho_info.s1_or_x2_handover) || 
                     (INTER_CELL_HO == p_ue_context->ho_info.s1_or_x2_handover)||
                     (INTRA_CELL_HO == p_ue_context->ho_info.s1_or_x2_handover))
/*BUG 604 changes stop*/
                        && ((RRC_ERAB_FAILURE_PATH_SWITCH_REQ_ACK == 
                         p_ue_context->p_e_rab_list[erab_count]->
                         uecc_x2ap_drb_ctx.status)
                        || (RRC_ERAB_FAILURE_S1U_RECONFIGURE_CNF == 
                         p_ue_context->p_e_rab_list[erab_count]->
                         uecc_x2ap_drb_ctx.status)))
                /*SPR_17382_END*/
                {
                    p_erab_to_be_released_item_list->
                        erab_to_be_release_item
                        [p_erab_to_be_released_item_list->
                        count].erab_id
                        = (U8)erab_count;
                    p_erab_to_be_released_item_list->
                        erab_to_be_release_item
                        [p_erab_to_be_released_item_list->
                        count].cause
                        = p_ue_context->p_e_rab_list[erab_count]->
                        uecc_x2ap_drb_ctx.cause;
                    p_erab_to_be_released_item_list->count++;
                }
                else
                {
                    p_erab_item_list->erab_id[p_erab_item_list->count] =
                        erab_count;
                    p_erab_item_list->count++;
                }
            }
        }
        p_uecc_erab_failed_item_list = 
            &(p_ue_context->ho_info.p_ho_info->p_trg_ho_info->s1_trg_ho_info.erab_failed_list);
        /* Fill ERAB Failed List */
        for(erab_index = 0, erab_count = p_uecc_erab_failed_item_list->llim_index;
                erab_count < p_uecc_erab_failed_item_list->count;
                erab_count++, erab_index++)
        {
            if ((erab_index < MAX_ERAB_COUNT) && (erab_count < MAX_ERAB_COUNT))
            {
                p_rrm_erab_failed_item_list->erab_failed_item[erab_index].erab_id =
                    (U8)p_uecc_erab_failed_item_list->e_rab_failed_to_add_list[erab_count].e_rab_id;

/*BUG 604 changes start*/
                if ((X2_HO == p_ue_context->ho_info.s1_or_x2_handover) ||
                    (INTER_CELL_HO == p_ue_context->ho_info.s1_or_x2_handover)||
                    (INTRA_CELL_HO == p_ue_context->ho_info.s1_or_x2_handover))
/*BUG 604 changes stop*/
                {
                    fill_rrm_cause_from_x2ap_cause(p_ue_context->p_gb_context,
                            &p_rrm_erab_failed_item_list->erab_failed_item[erab_index].cause,
                            &p_uecc_erab_failed_item_list->e_rab_failed_to_add_list[erab_count].
                            x2ap_cause);
                }
                else
                {
                    fill_rrm_cause_from_s1ap_cause(
                            &p_rrm_erab_failed_item_list->erab_failed_item[erab_index].cause,
                            &p_uecc_erab_failed_item_list->e_rab_failed_to_add_list[erab_count].cause,
                            p_ue_context);
                }
                p_rrm_erab_failed_item_list->count++;
            }
        }
        /* Updater the bitmask*/
        if(p_erab_item_list->count)
        {
            U16 erab_counter = 0;
            U16 erab_admitted_count = 0;
            rrc_rrm_ue_ho_adm_cnf.bitmask |=
                RRC_RRM_UE_HO_ADM_CNF_ERAB_ITEM_LIST_PRESENT;

            erab_admitted_count = p_erab_item_list->count;
            for(erab_counter=0; erab_counter< erab_admitted_count; erab_counter++)
            {
                U32 num_bytes =0;
                U32 num_bits =
                    p_ue_context->p_e_rab_list[p_erab_item_list->erab_id[erab_counter]]
                    ->uecc_x2ap_drb_ctx.transportLayerAddress.numbits;

                /* Copy the E-RAB Level QoS Parameters & Transport Layer Address for
                 * the E-RAB finally accepted on Target eNB */
                if(num_bits%8)
                {
                    num_bytes = (num_bits/8) + 1;
                }
                else
                {
                    num_bytes = num_bits/8;
                }

                p_ue_context->p_e_rab_list[p_erab_item_list->erab_id[erab_counter]]
                    ->self_transport_address_length = (U8)num_bytes;
                l3_memcpy_wrapper(
                        p_ue_context->p_e_rab_list[p_erab_item_list->erab_id[erab_counter]]->self_transport_address,
                        p_ue_context->p_e_rab_list[p_erab_item_list->erab_id[erab_counter]]->uecc_x2ap_drb_ctx.transportLayerAddress.data,
                        num_bytes);
            }
        }
        else
        {
            rrc_rrm_ue_ho_adm_cnf.response = RRC_FAILURE;
        }
        if((X2AP_P_NULL != p_erab_to_be_released_item_list) && 
                (p_erab_to_be_released_item_list->count))
        {
            rrc_rrm_ue_ho_adm_cnf.bitmask |= 
                RRC_RRM_UE_HO_ADM_CNF_ERAB_RELEASE_ITEM_LIST_PRESENT;
        }
        if(p_rrm_erab_failed_item_list->count)
        {
            rrc_rrm_ue_ho_adm_cnf.bitmask |=
                RRC_RRM_UE_HO_ADM_CNF_ERAB_FAILED_ITEM_LIST_PRESENT;
        }
/*BUG 604 changes start*/
    //}
/*BUG 604 changes start*/

    /* SPS Start */
    if (p_ue_context->m.is_sps_recv_frm_rrm && (response != RRC_FAILURE))
    {
        if (p_ue_context->m.sps_config_updated)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_BRIEF, "SPS Configured Successfully");
        }
        else
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_BRIEF, "SPS Not Configured ");
            rrc_rrm_ue_ho_adm_cnf.response = RRC_PARTIAL_SUCCESS;
            rrc_rrm_ue_ho_adm_cnf.bitmask |= RRC_RRM_UE_HO_ADM_CNF_ERROR_CODE_PRESENT;
            rrc_rrm_ue_ho_adm_cnf.error_code = RRM_RRC_SPS_SETUP_FAILED;
        }
    }
    /* SPS Stop */
    
    if ( RRC_TRUE == p_ue_context->m.scell_add_fail_at_lower_layer )
    {
        rrc_rrm_ue_ho_adm_cnf.bitmask |= RRC_RRM_UE_HO_ADM_CNF_ERROR_CODE_PRESENT;
        rrc_rrm_ue_ho_adm_cnf.error_code = RRM_RRC_SCELL_ADDITION_FAILED; 
    }

    /* PUP encode and send */
    response = rrc_rrm_il_send_rrc_rrm_ue_ho_adm_cnf(
            &rrc_rrm_ue_ho_adm_cnf,
            RRC_UECC_MODULE_ID,
            RRC_RRM_MODULE_ID,
            uecc_ue_ctx_get_op_transction_id(p_ue_context),
            p_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return response;
}

/******************************************************************************
*   FUNCTION NAME: process_and_fill_as_config_from_s1ap_ho_request
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context,
*                  as_config_t    *p_rrm_as_config,
*                  AS_Config * p_s1ap_as_config
*   OUTPUT       : none
*   DESCRIPTION:
*       This function fills as config information received from S1AP
        HO REQUEST to RRM UE HO ADM REQ.
*
*   RETURNS:
*          void
*
******************************************************************************/
rrc_return_et process_and_fill_as_config_from_s1ap_ho_request(
        uecc_ue_context_t* p_uecc_ue_context,
        as_config_t    *p_rrm_as_config,
        AS_Config * p_s1ap_as_config)
{
    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrm_as_config);
    RRC_ASSERT(PNULL != p_s1ap_as_config);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do {
        /*Meas config */
        if (RRC_FAILURE == uecc_rrm_build_rrm_meas_config(
                    p_uecc_ue_context,
                    &p_rrm_as_config->meas_config,
                    &p_s1ap_as_config->sourceMeasConfig))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_build_rrm_meas_config "
                    "returned failure!\n");
            break;
        }

        /* Radio resource config dedicated */
        if (RRC_FAILURE == uecc_rrm_build_radio_resource_config_dedicated(
                    p_uecc_ue_context,
                    &p_rrm_as_config->radio_resource_config_dedicated,
                    &p_s1ap_as_config->sourceRadioResourceConfig))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_build_radio_resource_config_dedicated "
                    "returned failure!\n");
            break;
        }

        /* Security algorithm config */
        uecc_rrm_build_security_algorithm_config(
                p_uecc_ue_context,
                &p_rrm_as_config->security_algorithm_config);
                

        /*MIB*/
        uecc_rrm_build_mib_info(
                p_uecc_ue_context,
                &p_rrm_as_config->master_information_block,
                &p_s1ap_as_config->sourceMasterInformationBlock);

        /*SIB1*/
        if (RRC_FAILURE == uecc_rrm_build_sib_type1_info (
                p_uecc_ue_context,
                &p_rrm_as_config->sib_type1_info,
                &p_s1ap_as_config->sourceSystemInformationBlockType1))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_build_sib_type1_info"
                    "returned failure!\n");
            break;
        }

        /*SIB2*/
        if (RRC_FAILURE == uecc_rrm_build_sib_type2_info (
                p_uecc_ue_context,
                &p_rrm_as_config->sib_type2_info,
                &p_s1ap_as_config->sourceSystemInformationBlockType2))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_build_sib_type2_info"
                    "returned failure!\n");
            break;
        }
        /*Antenna info common */
        p_rrm_as_config->antenna_info_common =
            (U8)p_s1ap_as_config->antennaInfoCommon.antennaPortsCount;

        /*ARFCN-ValueEUTRA*/
        p_rrm_as_config->dl_carrier_freq =
            p_s1ap_as_config->sourceDl_CarrierFreq;

        result = RRC_SUCCESS;
    }while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_rrm_meas_config
*   INPUT        : uecc_ue_context_t*  p_uecc_ue_context,
*                  rrm_meas_config_t*   p_rrm_meas_config,
*                  MeasConfig*         p_meas_config
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds rrm_meas_config_t from MeasConfig 
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_rrm_meas_config(
    uecc_ue_context_t*  p_uecc_ue_context,
    rrm_meas_config_t*   p_rrm_meas_config,
    MeasConfig*         p_meas_config
)
{
    rrc_return_et       result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrm_meas_config);
    RRC_ASSERT(PNULL != p_meas_config);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {
        /* MeasObjectToRemoveList */
        if (p_meas_config->m.measObjectToRemoveListPresent)
        {
            p_rrm_meas_config->bitmask |= 
                  UE_ADM_MEAS_OBJECT_TO_REMOVE_LIST_PRESENT;

            result = uecc_rrm_build_meas_object_to_remove_list(
                        &p_rrm_meas_config->meas_object_to_remove_list,
                        &p_meas_config->measObjectToRemoveList,
                        p_uecc_ue_context);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* MeasObjectToAddModList */
        if(p_meas_config->m.measObjectToAddModListPresent)
        {
            p_rrm_meas_config->bitmask |= 
                UE_ADM_MEAS_OBJECT_TO_ADD_MOD_LIST_PRESENT; 

            /* fill list of MeasObjectToAddMod */
            result = uecc_rrm_build_meas_object_to_add_mod_list(
                        &p_rrm_meas_config->meas_object_to_add_mod_list,
                        &p_meas_config->measObjectToAddModList,
                        p_uecc_ue_context);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* ReportConfigToRemoveList */
        if (p_meas_config->m.reportConfigToRemoveListPresent)
        {
            p_rrm_meas_config->bitmask |= 
                UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT;

            result = uecc_rrm_build_report_config_to_remove_list(
                        &p_rrm_meas_config->report_config_to_remove_list,
                        &p_meas_config->reportConfigToRemoveList,
                        p_uecc_ue_context);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* ReportConfigToAddModList */
        if (p_meas_config->m.reportConfigToAddModListPresent)
        {
            p_rrm_meas_config->bitmask |= 
                UE_ADM_MEAS_REPORT_CONFIG_TO_ADD_MOD_LIST_PRESENT;

            /* fill list of ReportConfigToAddMod */
            result = uecc_rrm_build_report_config_to_add_mod_list(
                        &p_rrm_meas_config->report_config_to_add_mod_list,
                        &p_meas_config->reportConfigToAddModList,
                        p_uecc_ue_context);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* MeasIdToRemoveList */
        if (p_meas_config->m.measIdToRemoveListPresent)
        {
            p_rrm_meas_config->bitmask |= 
                UE_ADM_MEAS_ID_TO_REMOVE_LIST_PRESENT;

            result = uecc_rrm_build_meas_id_to_remove_list(
                        &p_rrm_meas_config->meas_id_to_remove_list,
                        &p_meas_config->measIdToRemoveList,
                        p_uecc_ue_context);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* MeasIdToAddModList */
        if (p_meas_config->m.measIdToAddModListPresent)
        {
            p_rrm_meas_config->bitmask |= 
                UE_ADM_MEAS_ID_TO_ADD_MOD_LIST_PRESENT;

            /* fill list of MeasIdToAddMod */
            result = uecc_rrm_build_meas_id_to_add_mod_list(
                        p_uecc_ue_context->p_gb_context, 
                        &p_rrm_meas_config->meas_id_to_add_mod_list,
                        &p_meas_config->measIdToAddModList);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }
        /* QuantityConfig */
        if (p_meas_config->m.quantityConfigPresent)
        {
            p_rrm_meas_config->bitmask |= 
                UE_ADM_MEAS_QUANTITY_CONFIG_PRESENT;

            result = uecc_rrm_build_quantity_config(
                        p_uecc_ue_context->p_gb_context,
                        &p_rrm_meas_config->quantity_config,
                        &p_meas_config->quantityConfig);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* MeasGapConfig */
        if (p_meas_config->m.measGapConfigPresent)
        {
            p_rrm_meas_config->bitmask |= 
                UE_ADM_MEAS_GAP_CONFIG_PRESENT;

            result = uecc_rrm_build_meas_gap_config(
                        &p_rrm_meas_config->meas_gap_config,
                        &p_meas_config->measGapConfig,
                        p_uecc_ue_context);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* s_measure */
        if (p_meas_config->m.s_MeasurePresent)
        {
            p_rrm_meas_config->bitmask |= 
                UE_ADM_MEAS_S_MEASURE_PRESENT;
            p_rrm_meas_config->s_measure=
                p_meas_config->s_Measure ;
        }

        /* PreRegistrationInfoHRPD */
        if (p_meas_config->m.preRegistrationInfoHRPDPresent)
        {
            p_rrm_meas_config->bitmask |= 
                UE_ADM_MEAS_PRE_REGISTRATION_INFO_PRESENT;

            uecc_rrm_build_pre_registration_info_hrpd(
                p_uecc_ue_context->p_gb_context, 
                &p_rrm_meas_config->pre_registration_info_hrpd,
                &p_meas_config->preRegistrationInfoHRPD);
        }

        /* MeasConfig_speedStatePars */
        if (p_meas_config->m.speedStateParsPresent)
        {
            p_rrm_meas_config->bitmask |= 
                UE_ADM_MEAS_SPEED_STATE_PARS_PRESENT;

            result = uecc_rrm_build_meas_config_speed_state_pars(
                        &p_rrm_meas_config->meas_config_speed_state_pars,
                        &p_meas_config->speedStatePars,
                        p_uecc_ue_context);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_build_rrm_curr_meas_config
*   INPUT        : uecc_ue_context_t*  p_uecc_ue_context,
*                  uecc_ue_curr_meas_config_t*  p_ue_curr_meas_config
*                  MeasConfig*         p_meas_config
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds rrm_curr_meas_config_t from MeasConfig 
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_build_rrm_curr_meas_config(
    uecc_ue_context_t*  p_uecc_ue_context,
    uecc_ue_curr_meas_config_t*  p_ue_curr_meas_config,
    MeasConfig*         p_meas_config
)
{
    rrc_return_et       result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_ue_curr_meas_config);
    RRC_ASSERT(PNULL != p_meas_config);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {
        /* MeasObjectToAddModList */
        if(p_meas_config->m.measObjectToAddModListPresent)
        {
            p_ue_curr_meas_config->m.curr_meas_object_to_add_mod_list_present =1; 

            /* fill list of MeasObjectToAddMod */
            result = uecc_rrm_build_curr_meas_object_to_add_mod_list(
                        &p_ue_curr_meas_config->curr_meas_object_to_add_mod_list,
                        &p_meas_config->measObjectToAddModList,p_uecc_ue_context);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }
        /* ReportConfigToAddModList */
        if (p_meas_config->m.reportConfigToAddModListPresent)
        {
            p_ue_curr_meas_config->m.curr_meas_report_config_to_add_mod_list_present = 1;

            /* fill list of ReportConfigToAddMod */
            result = uecc_rrm_build_curr_report_config_to_add_mod_list(
                        &p_ue_curr_meas_config->curr_report_config_to_add_mod_list,
                        &p_meas_config->reportConfigToAddModList,
                        p_uecc_ue_context);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }
        /* MeasIdToAddModList */
        if (p_meas_config->m.measIdToAddModListPresent)
        {
            p_ue_curr_meas_config->m.curr_meas_id_to_add_mod_list_present = 1;

            /* fill list of MeasIdToAddMod */
	    /* SPR 13261 Fix Start */
            result = uecc_rrm_build_curr_meas_id_to_add_mod_list( /* SPR 13261 Fix Stop */
                        p_uecc_ue_context->p_gb_context,
                        &p_ue_curr_meas_config->curr_meas_id_to_add_mod_list,
                        &p_meas_config->measIdToAddModList);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }
        /* QuantityConfig */
        if (p_meas_config->m.quantityConfigPresent)
        {
            p_ue_curr_meas_config->m.curr_meas_quantity_config_present = 1;

            result = uecc_rrm_build_quantity_config(
                        p_uecc_ue_context->p_gb_context,
                        &p_ue_curr_meas_config->curr_quantity_config,
                        &p_meas_config->quantityConfig);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* MeasGapConfig */
        /*SPR_19384_START*/
        /*Meas Gap Config Recievied in HO req will not be stored
            in ue context*/
            /*Code Removed */
        /*SPR_19384_END*/

        /* s_measure */
        if (p_meas_config->m.s_MeasurePresent)
        {
            p_ue_curr_meas_config->m.curr_meas_s_measure_present = 1;
            p_ue_curr_meas_config->curr_s_measure=
                p_meas_config->s_Measure ;
        }

        /* PreRegistrationInfoHRPD */
        if (p_meas_config->m.preRegistrationInfoHRPDPresent)
        {
            p_ue_curr_meas_config->m.curr_meas_pre_registration_info_present = 1;

            uecc_rrm_build_pre_registration_info_hrpd(
                p_uecc_ue_context->p_gb_context,
                &p_ue_curr_meas_config->curr_pre_registration_info_hrpd,
                &p_meas_config->preRegistrationInfoHRPD);
        }

        /* MeasConfig_speedStatePars */
        if (p_meas_config->m.speedStateParsPresent)
        {
            p_ue_curr_meas_config->m.curr_meas_speed_state_pars_present = 1;

            result = uecc_rrm_build_meas_config_speed_state_pars(
                        &p_ue_curr_meas_config->curr_meas_config_speed_state_pars,
                        &p_meas_config->speedStatePars,
                        p_uecc_ue_context);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_build_rrm_meas_config_for_remove_list
*   INPUT        : uecc_ue_context_t*  p_uecc_ue_context,
*                  rrm_meas_config_t*  p_rrm_meas_config,
*                  MeasConfig*         p_meas_config
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds rrm_meas_config_t from MeasConfig 
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_build_rrm_meas_config_for_remove_list(
    uecc_ue_context_t*  p_uecc_ue_context,
    rrm_meas_config_t*  p_rrm_meas_config,
    MeasConfig*         p_meas_config
)
{
    rrc_return_et       result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrm_meas_config);
    RRC_ASSERT(PNULL != p_meas_config);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {
        /* MeasObjectToRemoveList */
        if (p_meas_config->m.measObjectToRemoveListPresent)
        {
            p_rrm_meas_config->bitmask |= 
                  UE_ADM_MEAS_OBJECT_TO_REMOVE_LIST_PRESENT;

            result = uecc_rrm_build_meas_object_to_remove_list(
                        &p_rrm_meas_config->meas_object_to_remove_list,
                        &p_meas_config->measObjectToRemoveList,
                        p_uecc_ue_context);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* ReportConfigToRemoveList */
        if (p_meas_config->m.reportConfigToRemoveListPresent)
        {
            p_rrm_meas_config->bitmask |= 
                UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT;

            result = uecc_rrm_build_report_config_to_remove_list(
                        &p_rrm_meas_config->report_config_to_remove_list,
                        &p_meas_config->reportConfigToRemoveList,
                        p_uecc_ue_context);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* MeasIdToRemoveList */
        if (p_meas_config->m.measIdToRemoveListPresent)
        {
            p_rrm_meas_config->bitmask |= 
                UE_ADM_MEAS_ID_TO_REMOVE_LIST_PRESENT;

            result = uecc_rrm_build_meas_id_to_remove_list(
                        &p_rrm_meas_config->meas_id_to_remove_list,
                        &p_meas_config->measIdToRemoveList,
                        p_uecc_ue_context);

            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}




/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_object_to_remove_list
*   INPUT        : meas_object_to_remove_list_t*   p_rrm_meas_object_to_remove_list,
*                  MeasObjectToRemoveList*         p_meas_object_to_remove_list,
*                  uecc_ue_context_t*              p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds meas_object_to_remove_list_t structure from
        p_meas_object_to_remove_list.
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_object_to_remove_list(
    meas_object_to_remove_list_t*   p_rrm_meas_object_to_remove_list,
    MeasObjectToRemoveList*         p_meas_object_to_remove_list,
    uecc_ue_context_t*              p_uecc_ue_context
)
{
    U8              i=0;
    rrc_return_et   result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_meas_object_to_remove_list);
    RRC_ASSERT(PNULL != p_meas_object_to_remove_list);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {
        if (p_meas_object_to_remove_list->n >= MAX_MEAS_OBJECT_ID)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "[%s] p_meas_object_to_remove_list->n incorrect\n",
                    __FUNCTION__);
            break;
        }
        p_rrm_meas_object_to_remove_list->count =
           (U8) p_meas_object_to_remove_list->n;

        for (i=0; i < p_meas_object_to_remove_list->n; i++)
        {
            p_rrm_meas_object_to_remove_list->meas_object_id[i] =
                p_meas_object_to_remove_list->elem[i];
        }

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_object_to_add_mod_list
*   INPUT        : meas_object_to_add_mod_list_t*  p_rrm_meas_object_to_add_mod_list,
*                  MeasObjectToAddModList*         p_meas_object_to_add_mod_list,
*                  uecc_ue_context_t*              p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds meas_object_to_add_mod_list_t from 
        MeasObjectToAddModList
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_object_to_add_mod_list(
    meas_object_to_add_mod_list_t*  p_rrm_meas_object_to_add_mod_list,
    MeasObjectToAddModList*         p_meas_object_to_add_mod_list,
    uecc_ue_context_t*              p_uecc_ue_context
)
{
    U8 i=0;
    OSRTDListNode*              p_node = PNULL;
    rrc_return_et               result = RRC_SUCCESS;

    RRC_ASSERT(PNULL != p_rrm_meas_object_to_add_mod_list);
    RRC_ASSERT(PNULL != p_meas_object_to_add_mod_list);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_rrm_meas_object_to_add_mod_list->count =
        (U8)p_meas_object_to_add_mod_list->count;

    p_node = p_meas_object_to_add_mod_list->head;

    for (i=0; i < p_meas_object_to_add_mod_list->count; i++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        result = uecc_rrm_build_meas_object_to_add_mod(
                &p_rrm_meas_object_to_add_mod_list->meas_object_to_add_mod[i],
                (MeasObjectToAddMod*)(p_node->data),
                p_uecc_ue_context);

        if (RRC_FAILURE == result)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_meas_object_to_add_mod_list error while build "
                "MeasObjectToAddMod [i=%i]",
                i);
            break;
        }

        p_node = p_node->next;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_object_to_add_mod
*   INPUT        : meas_object_to_add_mod_t*   p_rrm_meas_object_to_add_mod,
*                  MeasObjectToAddMod*         p_meas_object_to_add_mod,
*                  uecc_ue_context_t*              p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds uecc_rrm_build_meas_object_to_add_mod from 
         MeasObjectToAddMod 
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_object_to_add_mod(
    meas_object_to_add_mod_t*   p_rrm_meas_object_to_add_mod,
    MeasObjectToAddMod*         p_meas_object_to_add_mod,
    uecc_ue_context_t*              p_uecc_ue_context)
{
    rrc_return_et               result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_meas_object_to_add_mod);
    RRC_ASSERT(PNULL != p_meas_object_to_add_mod);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    switch (p_meas_object_to_add_mod->measObject.t)
    {
        case T_MeasObjectToAddMod_measObject_measObjectCDMA2000:
            p_rrm_meas_object_to_add_mod->meas_object.bitmask |= 
                MEAS_OBJECT_TO_ADD_CDMA2000_PRESENT;
            p_rrm_meas_object_to_add_mod->meas_object_id =
                p_meas_object_to_add_mod->measObjectId;

            result = uecc_rrm_build_meas_object_cdma2000(
                    p_uecc_ue_context,
                &p_rrm_meas_object_to_add_mod->meas_object.meas_object_cdma2000,
                p_meas_object_to_add_mod->measObject.u.measObjectCDMA2000);

            break;

        case T_MeasObjectToAddMod_measObject_measObjectEUTRA:
            p_rrm_meas_object_to_add_mod->meas_object.bitmask |= 
                MEAS_OBJECT_TO_ADD_EUTRA_PRESENT;
            p_rrm_meas_object_to_add_mod->meas_object_id =
                p_meas_object_to_add_mod->measObjectId;

           result = uecc_rrm_build_meas_object_eutra(
                &p_rrm_meas_object_to_add_mod->meas_object.meas_object_eutra,
                p_meas_object_to_add_mod->measObject.u.measObjectEUTRA,
                p_uecc_ue_context);

                break;

        case T_MeasObjectToAddMod_measObject_measObjectUTRA:
            p_rrm_meas_object_to_add_mod->meas_object.bitmask |= 
                MEAS_OBJECT_TO_ADD_UTRA_PRESENT;
            p_rrm_meas_object_to_add_mod->meas_object_id =
                p_meas_object_to_add_mod->measObjectId;

            result = uecc_rrm_build_meas_object_utra(
                &p_rrm_meas_object_to_add_mod->meas_object.meas_object_utra,
                p_meas_object_to_add_mod->measObject.u.measObjectUTRA,
                p_uecc_ue_context);

                break;

        case T_MeasObjectToAddMod_measObject_measObjectGERAN:
                /* spr_13304_fix_2_start */
                p_rrm_meas_object_to_add_mod->meas_object.bitmask |=
                    MEAS_OBJECT_TO_ADD_GERAN_PRESENT;
                p_rrm_meas_object_to_add_mod->meas_object_id =
                    p_meas_object_to_add_mod->measObjectId;

             result = uecc_rrm_build_meas_object_geran( 
                &p_rrm_meas_object_to_add_mod->meas_object.meas_object_geran,
                p_meas_object_to_add_mod->measObject.u.measObjectGERAN,
                p_uecc_ue_context);

                /* spr_13304_fix_start */
                /* spr_13304_fix_stop */
                
                /* spr_13304_fix_2_stop */

            break;


        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_MeasObjectToAddMod -> wrong bitmask");
            break;
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_curr_meas_object_to_add_mod
*   INPUT        : uecc_meas_object_to_add_mod_t*   p_rrm_meas_object_to_add_mod,
*                  MeasObjectToAddMod*         p_meas_object_to_add_mod,
*                  uecc_ue_context_t*              p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds uecc_rrm_build_curr_meas_object_to_add_mod from 
         MeasObjectToAddMod 
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_curr_meas_object_to_add_mod(
    uecc_meas_object_to_add_mod_t*   p_rrm_meas_object_to_add_mod,
    MeasObjectToAddMod*         p_meas_object_to_add_mod,
    uecc_ue_context_t*              p_uecc_ue_context)
{
    rrc_return_et               result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_meas_object_to_add_mod);
    RRC_ASSERT(PNULL != p_meas_object_to_add_mod);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    switch (p_meas_object_to_add_mod->measObject.t)
    {
        case T_MeasObjectToAddMod_measObject_measObjectCDMA2000:
            p_rrm_meas_object_to_add_mod->meas_object.t = 
                UECC_MEAS_OBJECT_TO_ADD_CDMA2000_PRESENT;
            p_rrm_meas_object_to_add_mod->meas_object_id =
                p_meas_object_to_add_mod->measObjectId;

            result = uecc_rrm_build_meas_object_cdma2000(
                    p_uecc_ue_context, 
                &p_rrm_meas_object_to_add_mod->meas_object.u.meas_object_cdma2000,
                p_meas_object_to_add_mod->measObject.u.measObjectCDMA2000);

            break;

        case T_MeasObjectToAddMod_measObject_measObjectEUTRA:
            p_rrm_meas_object_to_add_mod->meas_object.t = 
                UECC_MEAS_OBJECT_TO_ADD_EUTRA_PRESENT;
            p_rrm_meas_object_to_add_mod->meas_object_id =
                p_meas_object_to_add_mod->measObjectId;

           result = uecc_rrm_build_meas_object_eutra(
                &p_rrm_meas_object_to_add_mod->meas_object.u.meas_object_eutra,
                p_meas_object_to_add_mod->measObject.u.measObjectEUTRA,
                p_uecc_ue_context);

                break;

        case T_MeasObjectToAddMod_measObject_measObjectUTRA:
            p_rrm_meas_object_to_add_mod->meas_object.t = 
                UECC_MEAS_OBJECT_TO_ADD_UTRA_PRESENT;
            p_rrm_meas_object_to_add_mod->meas_object_id =
                p_meas_object_to_add_mod->measObjectId;

            result = uecc_rrm_build_meas_object_utra(
                &p_rrm_meas_object_to_add_mod->meas_object.u.meas_object_utra,
                p_meas_object_to_add_mod->measObject.u.measObjectUTRA,
                p_uecc_ue_context);

                break;

        case T_MeasObjectToAddMod_measObject_measObjectGERAN:
                /* spr_13304_fix_2_start */
                p_rrm_meas_object_to_add_mod->meas_object.t =
                    UECC_MEAS_OBJECT_TO_ADD_GERAN_PRESENT;
                p_rrm_meas_object_to_add_mod->meas_object_id =
                    p_meas_object_to_add_mod->measObjectId;

             result = uecc_rrm_build_meas_object_geran( 
                &p_rrm_meas_object_to_add_mod->meas_object.u.meas_object_geran,
                p_meas_object_to_add_mod->measObject.u.measObjectGERAN,
                p_uecc_ue_context);

                /* spr_13304_fix_start */
                /* spr_13304_fix_stop */
                /* spr_13304_fix_2_stop */

            break;


        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_MeasObjectToAddMod -> wrong bitmask");
            break;
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_object_cdma2000
*   INPUT        : uecc_ue_context_t*              p_uecc_ue_context,
*                  meas_object_cdma2000_t*     p_rrm_meas_object_cdma2000,
*                  MeasObjectCDMA2000*         p_meas_object_cdma2000
*   OUTPUT       : none        
*   DESCRIPTION:
*       This function builds meas_object_cdma2000 from MeasObjectCDMA2000 
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_object_cdma2000(
    uecc_ue_context_t*              p_uecc_ue_context, 
    meas_object_cdma2000_t*     p_rrm_meas_object_cdma2000,
    MeasObjectCDMA2000*         p_meas_object_cdma2000
)
{
    rrc_return_et   result = RRC_FAILURE;
    U8 i=0;

    RRC_ASSERT(PNULL != p_rrm_meas_object_cdma2000);
    RRC_ASSERT(PNULL != p_meas_object_cdma2000);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {
        if (p_meas_object_cdma2000->m.searchWindowSizePresent)
        {
            p_rrm_meas_object_cdma2000->bitmask |= 
                MEAS_OBJECT_CDMA2000_SEARCH_WINDOW_SIZE_PRESENT;
            p_rrm_meas_object_cdma2000->search_window_size =
                p_meas_object_cdma2000->searchWindowSize;
        }

        /* CellIndexList */
        if (p_meas_object_cdma2000->m.cellsToRemoveListPresent)
        {
            /* check list size */
            if (p_meas_object_cdma2000->cellsToRemoveList.n > MAX_CELL_MEAS)
            {
                break;
            }

            p_rrm_meas_object_cdma2000->bitmask |=
                MEAS_OBJECT_CDMA2000_CELLS_TO_REMOVE_LIST_PRESENT;

            p_rrm_meas_object_cdma2000->cells_to_remove_list.count =
                (U8)p_meas_object_cdma2000->cellsToRemoveList.n;

            for (i=0; i < p_meas_object_cdma2000->cellsToRemoveList.n; i++)
            {
                p_rrm_meas_object_cdma2000->cells_to_remove_list.cell_index[i] =
                    p_meas_object_cdma2000->cellsToRemoveList.elem[i];
            }
        }

        /* CellsToAddModListCDMA2000 */
        if (p_meas_object_cdma2000->m.cellsToAddModListPresent)
        {
            p_rrm_meas_object_cdma2000->bitmask |= 
                MEAS_OBJECT_CDMA2000_CELLS_TO_ADD_MOD_LIST_PRESENT;

            /* fill list of CellsToAddModCDMA2000 */
            if (RRC_FAILURE == 
                    uecc_rrm_build_cells_to_add_mod_list_cdma2000_list(
                        p_uecc_ue_context,         
                        &p_rrm_meas_object_cdma2000->cells_to_add_mod_list,
                        &p_meas_object_cdma2000->cellsToAddModList))
            {
                break;
            }
        }

        /* PhysCellIdCDMA2000 */
        if (p_meas_object_cdma2000->m.cellForWhichToReportCGIPresent)
        {
            p_rrm_meas_object_cdma2000->bitmask |= 
                MEAS_OBJECT_CDMA2000_CELL_FOR_WHICH_TO_REPEORT_CGI_PRESENT;
            p_rrm_meas_object_cdma2000->cells_for_which_to_report_cgi =
                p_meas_object_cdma2000->cellForWhichToReportCGI;
        }

        p_rrm_meas_object_cdma2000->cdma2000_type = 
            (U8)p_meas_object_cdma2000->cdma2000_Type;

        p_rrm_meas_object_cdma2000->carrier_freq_cdma2000.band_class =
            (U8)p_meas_object_cdma2000->carrierFreq.bandClass;
        p_rrm_meas_object_cdma2000->carrier_freq_cdma2000.arfcn = 
            p_meas_object_cdma2000->carrierFreq.arfcn;

        p_rrm_meas_object_cdma2000->offset_freq = 
            p_meas_object_cdma2000->offsetFreq;

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_cells_to_add_mod_list_cdma2000_list
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context,
*                  cells_to_add_mod_list_cdma2000_list_t*
*                  p_rrm_cells_to_add_mod_list_cdma2000_list,
*                  CellsToAddModListCDMA2000*              p_cells_to_add_mod_list_cdma2000
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds cells_to_add_mod_list_cdma2000_list from 
          CellsToAddModCDMA2000 in MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_cells_to_add_mod_list_cdma2000_list(
    uecc_ue_context_t* p_uecc_ue_context,
    cells_to_add_mod_list_cdma2000_list_t*
        p_rrm_cells_to_add_mod_list_cdma2000_list,
    CellsToAddModListCDMA2000*              p_cells_to_add_mod_list_cdma2000
)
{
    OSRTDListNode*          p_node = PNULL;
    U8 i=0;

    RRC_ASSERT(PNULL != p_rrm_cells_to_add_mod_list_cdma2000_list);
    RRC_ASSERT(PNULL != p_cells_to_add_mod_list_cdma2000);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* check list size */
    if (p_cells_to_add_mod_list_cdma2000->count>
            MAX_CELL_MEAS)
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "p_cells_to_add_mod_list_cdma2000->count is wrong[%u]",
                p_cells_to_add_mod_list_cdma2000->count);
        return RRC_FAILURE;
    }

    p_rrm_cells_to_add_mod_list_cdma2000_list->count =
        (U8)p_cells_to_add_mod_list_cdma2000->count;

    p_node = p_cells_to_add_mod_list_cdma2000->head;

    for (i=0; i < p_cells_to_add_mod_list_cdma2000->count; i++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        p_rrm_cells_to_add_mod_list_cdma2000_list->
            cells_to_add_mod_cdma2000[i].cell_index = 
            ((CellsToAddModCDMA2000*)p_node->data)->cellIndex;
        p_rrm_cells_to_add_mod_list_cdma2000_list->
            cells_to_add_mod_cdma2000[i].phys_cell_id =
            ((CellsToAddModCDMA2000*)p_node->data)->physCellId;

        p_node = p_node->next;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/* eICIC meas changes start */
/*****************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_subframe_cell_list_r10 
*   INPUT        : meas_subframe_cell_list_r10_t*  p_rrm_meas_subframe_cell_list_r10,
*                  MeasSubframeCellList_r10*       p_meas_subframe_cell_list_r10,
*                  uecc_ue_context_t*              p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds meas_subframe_cell_list_r10 list.
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_subframe_cell_list_r10(
    meas_subframe_cell_list_r10_t*   p_rrm_meas_subframe_cell_list_r10,
    MeasSubframeCellList_r10*        p_meas_subframe_cell_list_r10,
    uecc_ue_context_t*               p_uecc_ue_context)
{
    PhysCellIdRange*              p_phy_cell_id_range = PNULL;
    OSRTDListNode*                p_node = PNULL;
    U8 count = RRC_NULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* check list size */
    if (p_meas_subframe_cell_list_r10->count >
            MAX_CELL_MEAS)
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "p_meas_subframe_cell_list_r10->count"
                "wrong list count [%u]",
                p_meas_subframe_cell_list_r10->count);
        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

        return RRC_FAILURE;
    }
    p_rrm_meas_subframe_cell_list_r10->count =
        (U8)p_meas_subframe_cell_list_r10->count;

    p_node = p_meas_subframe_cell_list_r10->head;
    if(PNULL == p_node)
    {   
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"meas_subframe_cell_list_r10 is empty");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
        return RRC_FAILURE;
    }
    for(count=0; count < p_rrm_meas_subframe_cell_list_r10->count; count++)
    {

        p_phy_cell_id_range = p_node->data;

        p_rrm_meas_subframe_cell_list_r10->meas_subframe_cells[count].start =
            p_phy_cell_id_range->start;

        if(p_phy_cell_id_range->m.rangePresent)
        {
            p_rrm_meas_subframe_cell_list_r10->meas_subframe_cells[count].presence_bitmask |=
                PHY_CELL_ID_RANGE;

            p_rrm_meas_subframe_cell_list_r10->meas_subframe_cells[count].range =
                p_phy_cell_id_range->range; 
        }
        p_node = p_node->next;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;
}
/* eICIC meas changes stop */
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_object_eutra
*   INPUT        : meas_object_eutra_t*     p_rrm_meas_object_eutra,
*                  MeasObjectEUTRA*         p_meas_object_eutra,
*                  uecc_ue_context_t*       p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds meas_object_eutra from 
        MeasObjectEUTRA in MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_object_eutra(
    meas_object_eutra_t*     p_rrm_meas_object_eutra,
    MeasObjectEUTRA*         p_meas_object_eutra,
    uecc_ue_context_t*       p_uecc_ue_context)
{
    rrc_return_et   result = RRC_FAILURE;
    U8 count = 0;

    RRC_ASSERT(PNULL != p_rrm_meas_object_eutra);
    RRC_ASSERT(PNULL != p_meas_object_eutra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {
        /* CellIndexList */
        if (p_meas_object_eutra->m.cellsToRemoveListPresent)
        {
            p_rrm_meas_object_eutra->bitmask |=
                MEAS_OBJECT_EUTRA_CELLS_TO_REMOVE_LIST_PRESENT;

            /* check list size */
            if (p_meas_object_eutra->cellsToRemoveList.n >
                    MAX_CELL_MEAS)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "p_meas_object_eutra->"
                        "cellsToRemoveList.n wrong count[%u]",
                        p_meas_object_eutra->cellsToRemoveList.n);
                break; 
            }

            p_rrm_meas_object_eutra->cells_to_remove_list.count =
                (U8)p_meas_object_eutra->cellsToRemoveList.n;

            for (count = 0; count < p_meas_object_eutra->
                    cellsToRemoveList.n; count++)
            {
                p_rrm_meas_object_eutra->cells_to_remove_list.
                    cell_index[count] =
                    p_meas_object_eutra->cellsToRemoveList.elem[count];
            }
        }

        /* CellsToAddModListEUTRA */
        if (p_meas_object_eutra->m.cellsToAddModListPresent)
        {
            p_rrm_meas_object_eutra->bitmask |= 
                MEAS_OBJECT_EUTRA_CELLS_TO_ADD_MOD_LIST_PRESENT;

            /* fill list of CellsToAddModEUTRA */
            result = uecc_rrm_build_cells_to_add_mod_list(
                    &p_rrm_meas_object_eutra->cells_to_add_mod_list,
                    &p_meas_object_eutra->cellsToAddModList,
                    p_uecc_ue_context);
            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* BlackCellIndexList */
        if (p_meas_object_eutra->m.blackCellsToRemoveListPresent)
        {
            p_rrm_meas_object_eutra->bitmask |= 
                MEAS_OBJECT_EUTRA_BLACK_CELLS_TO_REMOVE_LIST_PRESENT;

            /* check list size */
            if (p_meas_object_eutra->blackCellsToRemoveList.n >
                    MAX_CELL_MEAS)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "p_meas_object_eutra->blackCellsToRemoveList.n"
                        " wrong list count [%u]",
                        p_meas_object_eutra->blackCellsToRemoveList.n);
                break;
            }

            p_rrm_meas_object_eutra->black_cells_to_remove_list.count =
                (U8)p_meas_object_eutra->blackCellsToRemoveList.n;

            for (count=0; count < 
                    p_meas_object_eutra->blackCellsToRemoveList.n;
                    count++)
            {
                p_rrm_meas_object_eutra->black_cells_to_remove_list.
                    cell_index[count] =
                    p_meas_object_eutra->blackCellsToRemoveList.elem[count];
            }
        }

        /* BlackCellsToAddModListEUTRA */
        if (p_meas_object_eutra->m.blackCellsToAddModListPresent)
        {
            p_rrm_meas_object_eutra->bitmask |= 
                MEAS_OBJECT_EUTRA_BLACK_CELLS_TO_ADD_MOD_LIST_PRESENT;

            /* fill list of blackCellsToAddModEUTRA */
            result = uecc_rrm_build_black_cells_to_add_mod_list(
                    &p_rrm_meas_object_eutra->black_cells_to_add_mod_list,
                    &p_meas_object_eutra->blackCellsToAddModList,
                    p_uecc_ue_context);
            if (RRC_FAILURE == result)
            {
                break;
            }
        }

        /* PhysCellIdEUTRA */
        if (p_meas_object_eutra->m.cellForWhichToReportCGIPresent)
        {
            p_rrm_meas_object_eutra->bitmask |= 
                MEAS_OBJECT_EUTRA_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT;
            p_rrm_meas_object_eutra->cell_for_which_to_report_cgi = 
                p_meas_object_eutra->cellForWhichToReportCGI;
        }
        /* eICIC meas changes start */
        /* measSubframePatternConfigNeigh_r10 */
        if(p_meas_object_eutra->m.measSubframePatternConfigNeigh_r10Present)
        {
            p_rrm_meas_object_eutra->bitmask |=
            MEAS_SUBFRAME_PATTERN_CONFIG_NEIGH_R10_PRESENT;
            if(T_MeasSubframePatternConfigNeigh_r10_setup == p_meas_object_eutra->measSubframePatternConfigNeigh_r10.t)
            {
                p_rrm_meas_object_eutra->meas_subframe_pattern_config_neigh_r10.bitmask |= 
                    MEAS_SUBFRAME_PATTERN_CONFIG_NEIGH_R10_SETUP_PRESENT;

                if(T_MeasSubframePattern_r10_subframePatternFDD_r10 ==
                        p_meas_object_eutra->measSubframePatternConfigNeigh_r10.u.setup->measSubframePatternNeigh_r10.t)
                {
                    p_rrm_meas_object_eutra->meas_subframe_pattern_config_neigh_r10.
                        meas_subframe_pattern_config_neigh_r10_setup.meas_subframe_pattern_neigh_r10.bitmask |=
                        RRC_PHY_MEAS_SUBFRAME_PATTERN_FDD_R10;

                    l3_memcpy_wrapper(p_rrm_meas_object_eutra->meas_subframe_pattern_config_neigh_r10.
                        meas_subframe_pattern_config_neigh_r10_setup.meas_subframe_pattern_neigh_r10.
                        subframe_pattern_fdd_r10.data,
                        p_meas_object_eutra->measSubframePatternConfigNeigh_r10.u.setup->measSubframePatternNeigh_r10.
                        u.subframePatternFDD_r10->data,
                        MAX_SUBFRAME_PATTERN_FDD);


                }
                else if(T_MeasSubframePattern_r10_subframePatternTDD_r10 ==
                        p_meas_object_eutra->measSubframePatternConfigNeigh_r10.u.setup->measSubframePatternNeigh_r10.t)
                {
                    p_rrm_meas_object_eutra->meas_subframe_pattern_config_neigh_r10.
                        meas_subframe_pattern_config_neigh_r10_setup.meas_subframe_pattern_neigh_r10.bitmask |=
                        RRC_PHY_MEAS_SUBFRAME_PATTERN_TDD_R10;

                    if(T_MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig1_5_r10 == 
                            p_meas_object_eutra->measSubframePatternConfigNeigh_r10.u.setup->
                            measSubframePatternNeigh_r10.u.subframePatternTDD_r10->t)
                    {
                        p_rrm_meas_object_eutra->meas_subframe_pattern_config_neigh_r10.
                            meas_subframe_pattern_config_neigh_r10_setup.meas_subframe_pattern_neigh_r10.
                            subframe_pattern_tdd_r10.bitmask |=
                            RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG1_5_R10;

                        l3_memcpy_wrapper(p_rrm_meas_object_eutra->meas_subframe_pattern_config_neigh_r10.
                                meas_subframe_pattern_config_neigh_r10_setup.meas_subframe_pattern_neigh_r10.
                                subframe_pattern_tdd_r10.subframe_config1_5_r10,
                                p_meas_object_eutra->measSubframePatternConfigNeigh_r10.u.setup->
                                measSubframePatternNeigh_r10.u.subframePatternTDD_r10->u.
                                subframeConfig1_5_r10->data,
                                MAX_SUBFRAME_CONFIG1_5_TDD);
                    }
                    else if(T_MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig0_r10 ==
                            p_meas_object_eutra->measSubframePatternConfigNeigh_r10.u.setup->
                            measSubframePatternNeigh_r10.u.subframePatternTDD_r10->t)
                    {
                        p_rrm_meas_object_eutra->meas_subframe_pattern_config_neigh_r10.
                            meas_subframe_pattern_config_neigh_r10_setup.meas_subframe_pattern_neigh_r10.
                            subframe_pattern_tdd_r10.bitmask |=
                            RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG0_R10;
                        
                        l3_memcpy_wrapper(p_rrm_meas_object_eutra->meas_subframe_pattern_config_neigh_r10.
                                meas_subframe_pattern_config_neigh_r10_setup.meas_subframe_pattern_neigh_r10.
                                subframe_pattern_tdd_r10.subframe_config0_r10,
                                p_meas_object_eutra->measSubframePatternConfigNeigh_r10.u.setup->
                                measSubframePatternNeigh_r10.u.subframePatternTDD_r10->u.
                                subframeConfig0_r10->data,
                                MAX_SUBFRAME_CONFIG0_TDD);
                    }
                    else if(T_MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig6_r10 == 
                            p_meas_object_eutra->measSubframePatternConfigNeigh_r10.u.setup->
                            measSubframePatternNeigh_r10.u.subframePatternTDD_r10->t)
                    {
                        p_rrm_meas_object_eutra->meas_subframe_pattern_config_neigh_r10.
                            meas_subframe_pattern_config_neigh_r10_setup.meas_subframe_pattern_neigh_r10.
                            subframe_pattern_tdd_r10.bitmask |=
                            RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG6_R10;
                        
                        l3_memcpy_wrapper(p_rrm_meas_object_eutra->meas_subframe_pattern_config_neigh_r10.
                                meas_subframe_pattern_config_neigh_r10_setup.meas_subframe_pattern_neigh_r10.
                                subframe_pattern_tdd_r10.subframe_config6_r10,
                                p_meas_object_eutra->measSubframePatternConfigNeigh_r10.u.setup->
                                measSubframePatternNeigh_r10.u.subframePatternTDD_r10->u.
                                subframeConfig6_r10->data,
                                MAX_SUBFRAME_CONFIG6_TDD);
                    }

                }

                if(p_meas_object_eutra->measSubframePatternConfigNeigh_r10.u.setup->m.measSubframeCellList_r10Present)
                {
                    p_rrm_meas_object_eutra->meas_subframe_pattern_config_neigh_r10.
                        meas_subframe_pattern_config_neigh_r10_setup.bitmask |= 
                        MEAS_SUBFRAME_CELL_LIST_R10_PRESENT;

                    /* fill list of measSubframeCellList_r10 */
                    result = uecc_rrm_build_meas_subframe_cell_list_r10(
                            &p_rrm_meas_object_eutra->meas_subframe_pattern_config_neigh_r10.
                            meas_subframe_pattern_config_neigh_r10_setup.meas_subframe_cell_list_r10,
                            &p_meas_object_eutra->measSubframePatternConfigNeigh_r10.u.setup->measSubframeCellList_r10,
                            p_uecc_ue_context);

                    if(RRC_FAILURE == result)
                    {
                        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                (p_uecc_ue_context->p_gb_context)->facility_name,
                                RRC_WARNING,
                                "Failed in building meas_subframe_cell_list_r10");

                        break;
                    }

                }
            }
        }
        /* eICIC meas changes stop */
        p_rrm_meas_object_eutra->carrier_freq =
            p_meas_object_eutra->carrierFreq;

        p_rrm_meas_object_eutra->allowed_meas_bandwidth =
            (U8)p_meas_object_eutra->allowedMeasBandwidth;

        p_rrm_meas_object_eutra->presence_antenna_port1 =
            p_meas_object_eutra->presenceAntennaPort1 ;

        p_rrm_meas_object_eutra->neigh_cell_config =
            p_meas_object_eutra->neighCellConfig.data[0] ;

        p_rrm_meas_object_eutra->offset_freq =
            (U8)p_meas_object_eutra->offsetFreq ;

        result = RRC_SUCCESS;
    }
    while(0);
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_cells_to_add_mod_list
*   INPUT        : cells_to_add_mod_list_t*   p_rrm_cells_to_add_mod_list_eutra_list,
*                  CellsToAddModList*         p_cells_to_add_mod_list_eutra,
*                  uecc_ue_context_t*         p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds cells_to_add_mod_list from 
        CellsToAddModEUTRA in MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_cells_to_add_mod_list(
    cells_to_add_mod_list_t*   p_rrm_cells_to_add_mod_list_eutra_list,
    CellsToAddModList*         p_cells_to_add_mod_list_eutra,
    uecc_ue_context_t*         p_uecc_ue_context)
{
    CellsToAddMod*          p_cells_add_mod_eutra = PNULL;
    OSRTDListNode*          p_node = PNULL;
    U8 count = 0;

    RRC_ASSERT(PNULL != p_rrm_cells_to_add_mod_list_eutra_list);
    RRC_ASSERT(PNULL != p_cells_to_add_mod_list_eutra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* check list size */
    if (p_cells_to_add_mod_list_eutra->count >
            MAX_CELL_MEAS)
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_meas_object_eutra wrong list count [%u]",
                p_cells_to_add_mod_list_eutra->count);
        return RRC_FAILURE;
    }

    p_rrm_cells_to_add_mod_list_eutra_list->count = 
        (U8)p_cells_to_add_mod_list_eutra->count;
    p_node = p_cells_to_add_mod_list_eutra->head;
    for (count = 0; count < p_cells_to_add_mod_list_eutra->count; count++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        p_cells_add_mod_eutra = (CellsToAddMod*)p_node->data;

        p_rrm_cells_to_add_mod_list_eutra_list->
            cells_to_add_mod[count].cell_index =
            p_cells_add_mod_eutra->cellIndex;
        p_rrm_cells_to_add_mod_list_eutra_list->
            cells_to_add_mod[count].phys_cell_id =
            p_cells_add_mod_eutra->physCellId;
        p_rrm_cells_to_add_mod_list_eutra_list->
            cells_to_add_mod[count].cell_individual_offset =
            (U8)p_cells_add_mod_eutra->cellIndividualOffset;

        p_node = p_node->next;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/*****************************************************************************
*   FUNCTION NAME: uecc_rrm_build_black_cells_to_add_mod_list
*   INPUT        : black_cells_to_add_mod_list_t* p_rrm_black_cells_to_add_mod_list_eutra_list,
*                  BlackCellsToAddModList*        p_black_cells_to_add_mod_list_eutra,
*                  uecc_ue_context_t*             p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds black_cells_to_add_mod_list
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_black_cells_to_add_mod_list(
    black_cells_to_add_mod_list_t* p_rrm_black_cells_to_add_mod_list_eutra_list,
    BlackCellsToAddModList*        p_black_cells_to_add_mod_list_eutra,
    uecc_ue_context_t*             p_uecc_ue_context)
{
    BlackCellsToAddMod*     p_black_cells_add_mod_eutra = PNULL;
    OSRTDListNode*          p_node = PNULL;
    U8 count=0;

    RRC_ASSERT(PNULL != p_rrm_black_cells_to_add_mod_list_eutra_list);
    RRC_ASSERT(PNULL != p_black_cells_to_add_mod_list_eutra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* check list size */
    if (p_black_cells_to_add_mod_list_eutra->count >
            MAX_CELL_MEAS)
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "p_black_cells_to_add_mod_list"
                "_eutra->count wrong list count [%u]",
                p_black_cells_to_add_mod_list_eutra->count);
        return RRC_FAILURE;
    }

    p_rrm_black_cells_to_add_mod_list_eutra_list->count =
        (U8)p_black_cells_to_add_mod_list_eutra->count;
    p_node = p_black_cells_to_add_mod_list_eutra->head;

    for (count=0; count < p_rrm_black_cells_to_add_mod_list_eutra_list->
            count; count++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        p_black_cells_add_mod_eutra = p_node->data;

        p_rrm_black_cells_to_add_mod_list_eutra_list->
            black_cells_to_add_mod[count].cell_index =
            p_black_cells_add_mod_eutra->cellIndex;
        
        if (p_black_cells_add_mod_eutra->physCellIdRange.m.rangePresent)
        {
            p_rrm_black_cells_to_add_mod_list_eutra_list->
                black_cells_to_add_mod[count].
                phys_cell_id_range.presence_bitmask |= 
                PHY_CELL_ID_RANGE;

            p_rrm_black_cells_to_add_mod_list_eutra_list->
                black_cells_to_add_mod[count].phys_cell_id_range.start |= 
                p_black_cells_add_mod_eutra->physCellIdRange.start;

            p_rrm_black_cells_to_add_mod_list_eutra_list->
                black_cells_to_add_mod[count].phys_cell_id_range.range |=
                (U8)(p_black_cells_add_mod_eutra->physCellIdRange.range);
        }   
            
        p_node = p_node->next;
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_object_utra
*   INPUT        : meas_object_utra_t*         p_rrm_meas_object_utra,
*                  MeasObjectUTRA*             p_meas_object_utra,
*                  uecc_ue_context_t*          p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds meas_object_utra from MeasObjectUTRA in 
        MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_object_utra(
    meas_object_utra_t*         p_rrm_meas_object_utra,
    MeasObjectUTRA*             p_meas_object_utra,
    uecc_ue_context_t*          p_uecc_ue_context)
{
    rrc_return_et   result = RRC_FAILURE;
    U8 count = 0;

    RRC_ASSERT(PNULL != p_rrm_meas_object_utra);
    RRC_ASSERT(PNULL != p_meas_object_utra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {
        /* CellIndexList */
        if (p_meas_object_utra->m.cellsToRemoveListPresent)
        {
            p_rrm_meas_object_utra->bitmask |=
                MEAS_OBJECT_UTRA_CELLS_TO_REMOVE_LIST_PRESENT;
            /* check list size */
            if (p_meas_object_utra->cellsToRemoveList.n >
                    MAX_CELL_MEAS)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_build_meas_object_utra wrong list count [%u]",
                    p_rrm_meas_object_utra->cells_to_remove_list.count);
                break;
            }

            p_rrm_meas_object_utra->cells_to_remove_list.count =
                (U8)p_meas_object_utra->cellsToRemoveList.n ;

            for (count=0; count < p_meas_object_utra->cellsToRemoveList.n;
                    count++)
            {
                p_rrm_meas_object_utra->cells_to_remove_list.
                    cell_index[count]=
                    p_meas_object_utra->cellsToRemoveList.elem[count] ;
            }
        }

        /* CellsToAddModListUTRA */
        if (p_meas_object_utra->m.cellsToAddModListPresent)
        {
            p_rrm_meas_object_utra->bitmask |= 
                MEAS_OBJECT_UTRA_CELLS_TO_ADD_MOD_LIST_PRESENT;

            if ( T_MeasObjectUTRA_cellsToAddModList_cellsToAddModListUTRA_FDD
                    ==p_meas_object_utra->cellsToAddModList.t)
            {

                p_rrm_meas_object_utra->cells_to_add_mod_list.bitmask |= 
                    MEAS_OBJECT_UTRA_CELLS_TO_ADD_MOD_LIST_FDD_PRESENT;
                /* fill list of CellsToAddModUTRA-FDD */
                uecc_rrm_build_cells_to_add_mod_list_utra_fdd(
                        p_uecc_ue_context->p_gb_context, 
                        &p_rrm_meas_object_utra->cells_to_add_mod_list.
                        cells_to_add_mod_list_utra_fdd,
                        p_meas_object_utra);

            }
            if ( T_MeasObjectUTRA_cellsToAddModList_cellsToAddModListUTRA_TDD
                    ==p_meas_object_utra->cellsToAddModList.t)
            {
                p_rrm_meas_object_utra->cells_to_add_mod_list.bitmask |= 
                    MEAS_OBJECT_UTRA_CELLS_TO_ADD_MOD_LIST_TDD_PRESENT;
                /* fill list of CellsToAddModUTRA-TDD */
                uecc_rrm_build_cells_to_add_mod_list_utra_tdd(
                        p_uecc_ue_context->p_gb_context,
                        &p_rrm_meas_object_utra->cells_to_add_mod_list.
                        cells_to_add_mod_list_utra_tdd,
                        p_meas_object_utra);
            }
        }

        /* PhysCellIdUTRA */
        if (p_meas_object_utra->m.cellForWhichToReportCGIPresent)
        {
            p_rrm_meas_object_utra->cell_for_which_to_report_cgi.bitmask |= 
                MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT;

            if (p_meas_object_utra->cellForWhichToReportCGI.t ==
                    T_MeasObjectUTRA_cellForWhichToReportCGI_utra_FDD)
            {
                p_rrm_meas_object_utra->cell_for_which_to_report_cgi.
                    bitmask |= 
                 MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_UTRA_FDD_PRESENT;

                p_rrm_meas_object_utra->cell_for_which_to_report_cgi.
                    utra_fdd=
                    p_meas_object_utra->cellForWhichToReportCGI.u.utra_FDD ;
            }
            
            if (p_meas_object_utra->cellForWhichToReportCGI.t == 
                    T_MeasObjectUTRA_cellForWhichToReportCGI_utra_TDD)
            {
                p_rrm_meas_object_utra->cell_for_which_to_report_cgi.
                    bitmask |=
                 MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_UTRA_TDD_PRESENT;
            
                p_rrm_meas_object_utra->cell_for_which_to_report_cgi.utra_tdd=
                    p_meas_object_utra->cellForWhichToReportCGI.u.utra_TDD ;
            }
        }
    
        p_rrm_meas_object_utra->carrier_freq=
            p_meas_object_utra->carrierFreq ;

        p_rrm_meas_object_utra->offset_freq=
            p_meas_object_utra->offsetFreq ;

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_cells_to_add_mod_list_utra_fdd
*   INPUT        : uecc_gb_context_t                 *p_uecc_gb_context,
*                  cells_to_add_mod_list_utra_fdd_t* p_rrm_cells_to_add_mod_list_utra_fdd,
*                  MeasObjectUTRA*                   p_meas_object_utra
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds CellsToAddModUTRA-FDD in MeasConfig structure
*
*   RETURNS:
*        void
*
******************************************************************************/
void uecc_rrm_build_cells_to_add_mod_list_utra_fdd(
    uecc_gb_context_t                 *p_uecc_gb_context,
    cells_to_add_mod_list_utra_fdd_t* p_rrm_cells_to_add_mod_list_utra_fdd,
    MeasObjectUTRA*                   p_meas_object_utra)
{
    OSRTDListNode*          p_node = PNULL;
    U8 count = 0;

    RRC_ASSERT(PNULL != p_rrm_cells_to_add_mod_list_utra_fdd);
    RRC_ASSERT(PNULL != p_meas_object_utra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/

    p_rrm_cells_to_add_mod_list_utra_fdd->count = 
        (U8) (p_meas_object_utra->cellsToAddModList.u.
        cellsToAddModListUTRA_FDD->count);

    p_node = p_meas_object_utra->cellsToAddModList.u.
        cellsToAddModListUTRA_FDD->head;

    for (count = 0; count < 
            p_rrm_cells_to_add_mod_list_utra_fdd->count; count++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        p_rrm_cells_to_add_mod_list_utra_fdd->
            cells_to_add_mod_utra_fdd[count].cell_index=
            ((CellsToAddModUTRA_FDD*)p_node->data)->cellIndex ;
        p_rrm_cells_to_add_mod_list_utra_fdd->
            cells_to_add_mod_utra_fdd[count].phys_cell_id=
            ((CellsToAddModUTRA_FDD*)p_node->data)->physCellId ;
        
        p_node = p_node->next;
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_cells_to_add_mod_list_utra_tdd
*   INPUT        : uecc_gb_context_t                 *p_uecc_gb_context,
*                  cells_to_add_mod_list_utra_tdd_t* p_rrm_cells_to_add_mod_list_utra_tdd,
*                  MeasObjectUTRA*                   p_meas_object_utra
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds CellsToAddModUTRA-TDD in MeasConfig structure
*
*   RETURNS:
*        void
*
******************************************************************************/
void uecc_rrm_build_cells_to_add_mod_list_utra_tdd(
    uecc_gb_context_t                 *p_uecc_gb_context,
    cells_to_add_mod_list_utra_tdd_t* p_rrm_cells_to_add_mod_list_utra_tdd,
    MeasObjectUTRA*                   p_meas_object_utra)
{
    CellsToAddModUTRA_TDD*  p_cells_add_mod_utra_tdd = PNULL;
    OSRTDListNode*          p_node = PNULL;
    U8 count = 0;

    RRC_ASSERT(PNULL != p_rrm_cells_to_add_mod_list_utra_tdd);
    RRC_ASSERT(PNULL != p_meas_object_utra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/

    p_rrm_cells_to_add_mod_list_utra_tdd->count = 
        (U8) (p_meas_object_utra->cellsToAddModList.u.
        cellsToAddModListUTRA_TDD->count);
    p_node = p_meas_object_utra->cellsToAddModList.u.
        cellsToAddModListUTRA_TDD->head;

    for (count = 0; count < 
            p_rrm_cells_to_add_mod_list_utra_tdd->count; count++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        p_cells_add_mod_utra_tdd = p_node->data;

        p_rrm_cells_to_add_mod_list_utra_tdd->
            cells_to_add_mod_utra_tdd[count].cell_index=
            p_cells_add_mod_utra_tdd->cellIndex ;
        p_rrm_cells_to_add_mod_list_utra_tdd->
            cells_to_add_mod_utra_tdd[count].phys_cell_id=
            p_cells_add_mod_utra_tdd->physCellId ;
        
        p_node = p_node->next;
   }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_report_config_to_remove_list
*   INPUT        : report_config_to_remove_list_t* p_rrm_report_config_to_remove_list,
*                  ReportConfigToRemoveList*       p_report_config_to_remove_list,
*                  uecc_ue_context_t*              p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds ReportConfigToRemoveList in MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_report_config_to_remove_list(
    report_config_to_remove_list_t* p_rrm_report_config_to_remove_list,
    ReportConfigToRemoveList*       p_report_config_to_remove_list,
    uecc_ue_context_t*              p_uecc_ue_context
)
{
    U8              i=0;
    rrc_return_et   result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_report_config_to_remove_list);
    RRC_ASSERT(PNULL != p_report_config_to_remove_list);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {
        /* check list size */
        if (p_report_config_to_remove_list->n > MAX_REPORT_CONFIG_ID)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_build_report_config_to_remove_list wrong list "
                    "count [%u]",
                    p_report_config_to_remove_list->n);
            break;
        }

        p_rrm_report_config_to_remove_list->count=
            (U8)p_report_config_to_remove_list->n ;

        for (i=0; i < p_report_config_to_remove_list->n; i++)
        {
            p_rrm_report_config_to_remove_list->report_config_id[i]=
                p_report_config_to_remove_list->elem[i] ;
        }

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_report_config_to_add_mod_list
*   INPUT        : report_config_to_add_mod_list_t*    p_rrm_report_config_to_add_mod_list,
*                  ReportConfigToAddModList*           p_report_config_to_add_mod_list,
*                  uecc_ue_context_t*                  p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds ReportConfigToAddModList in MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_report_config_to_add_mod_list(
    report_config_to_add_mod_list_t*    p_rrm_report_config_to_add_mod_list,
    ReportConfigToAddModList*           p_report_config_to_add_mod_list,
    uecc_ue_context_t*                  p_uecc_ue_context
)
{
    rrc_return_et           result = RRC_SUCCESS;
    ReportConfigToAddMod*   p_report_config_to_add_mod = PNULL;
    OSRTDListNode*          p_node = PNULL;
    U8 i=0;

    RRC_ASSERT(PNULL != p_rrm_report_config_to_add_mod_list);
    RRC_ASSERT(PNULL != p_report_config_to_add_mod_list);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_rrm_report_config_to_add_mod_list->count =
        (U8)p_report_config_to_add_mod_list->count;        

    p_node = p_report_config_to_add_mod_list->head;

    for (i=0; i < p_rrm_report_config_to_add_mod_list->count; i++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        p_report_config_to_add_mod = p_node->data;
        result = uecc_rrm_build_report_config_to_add_mod(
                &p_rrm_report_config_to_add_mod_list->
                report_config_to_add_mod[i],
                p_report_config_to_add_mod,
                p_uecc_ue_context);

        if (RRC_FAILURE == result)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_report_config_to_add_mod_list "
                "error while build "
                "ReportConfigToAddMod [i=%i]",
                i);
            break;
        }
        p_node = p_node->next;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_report_config_to_add_mod
*   INPUT        : report_config_to_add_mod_t* p_rrm_report_config_to_add_mod,
*                  ReportConfigToAddMod*       p_report_config_to_add_mod,
*                  uecc_ue_context_t*          p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds ReportConfigToAddMod in MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_report_config_to_add_mod(
    report_config_to_add_mod_t* p_rrm_report_config_to_add_mod,
    ReportConfigToAddMod*       p_report_config_to_add_mod,
    uecc_ue_context_t*          p_uecc_ue_context
)
{
    rrc_return_et               result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_report_config_to_add_mod);
    RRC_ASSERT(PNULL != p_report_config_to_add_mod);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_rrm_report_config_to_add_mod->report_config_id=
        p_report_config_to_add_mod->reportConfigId ;

    switch(p_report_config_to_add_mod->reportConfig.t)
    {
        case T_ReportConfigToAddMod_reportConfig_reportConfigEUTRA:
            p_rrm_report_config_to_add_mod->report_config.bitmask |=
                REPORT_CONFIG_EUTRA_PRESENT;

            result = uecc_rrm_build_report_config_eutra(
                &p_rrm_report_config_to_add_mod->
                    report_config.report_config_eutra,
                p_report_config_to_add_mod->reportConfig.u.reportConfigEUTRA,
                p_uecc_ue_context);
             /*coverity 81459 fix start*/
            (void)uecc_rrm_build_report_config_eutra_ext(
               &p_rrm_report_config_to_add_mod->report_config,
               p_report_config_to_add_mod->reportConfig.u.reportConfigEUTRA,
               p_uecc_ue_context);
            /*coverity 81459 end start*/
            break;

        case T_ReportConfigToAddMod_reportConfig_reportConfigInterRAT:
            p_rrm_report_config_to_add_mod->report_config.bitmask |=
                REPORT_CONFIG_INTERRAT_PRESENT;

            if (PNULL ==
                p_report_config_to_add_mod->reportConfig.u.reportConfigInterRAT)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,"[%s] Null Pointer access !!\n",
                    __FUNCTION__);
                break;
            }

            result = uecc_rrm_build_report_config_interrat(
                &p_rrm_report_config_to_add_mod->
                    report_config.report_config_interrat,
                p_report_config_to_add_mod->
                    reportConfig.u.reportConfigInterRAT,
                    p_uecc_ue_context);

            break;

        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                 (p_uecc_ue_context->p_gb_context)->facility_name,
                 RRC_WARNING,
                 "uecc_rrm_build_report_config_to_add_mod -> wrong bitmask");
            break;

    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_curr_report_config_to_add_mod
*   INPUT        : uecc_report_config_to_add_mod_t* p_ue_report_config_to_add_mod,
*                  ReportConfigToAddMod*       p_report_config_to_add_mod,
*                  uecc_ue_context_t*          p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds ReportConfigToAddMod in MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_curr_report_config_to_add_mod(
    uecc_report_config_to_add_mod_t* p_ue_report_config_to_add_mod,
    ReportConfigToAddMod*       p_report_config_to_add_mod,
    uecc_ue_context_t*          p_uecc_ue_context
)
{
    rrc_return_et               result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_ue_report_config_to_add_mod);
    RRC_ASSERT(PNULL != p_report_config_to_add_mod);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_ue_report_config_to_add_mod->report_config_id=
        p_report_config_to_add_mod->reportConfigId ;

    switch(p_report_config_to_add_mod->reportConfig.t)
    {
        case T_ReportConfigToAddMod_reportConfig_reportConfigEUTRA:
            p_ue_report_config_to_add_mod->report_config.bitmask |=
                REPORT_CONFIG_EUTRA_PRESENT;

            result = uecc_rrm_build_report_config_eutra(
                &p_ue_report_config_to_add_mod->
                    report_config.report_config_eutra,
                p_report_config_to_add_mod->reportConfig.u.reportConfigEUTRA,
                p_uecc_ue_context);

            result = uecc_rrm_build_report_config_eutra_ext(
               &p_ue_report_config_to_add_mod->report_config,
               p_report_config_to_add_mod->reportConfig.u.reportConfigEUTRA,
               p_uecc_ue_context);
            break;

        case T_ReportConfigToAddMod_reportConfig_reportConfigInterRAT:
            p_ue_report_config_to_add_mod->report_config.bitmask |=
                REPORT_CONFIG_INTERRAT_PRESENT;

            if (PNULL ==
                p_report_config_to_add_mod->reportConfig.u.reportConfigInterRAT)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[%s] Null Pointer access !!\n",
                        __FUNCTION__);
                break;
            }

            result = uecc_rrm_build_report_config_interrat(
                &p_ue_report_config_to_add_mod->
                    report_config.report_config_interrat,
                p_report_config_to_add_mod->
                    reportConfig.u.reportConfigInterRAT,
                    p_uecc_ue_context);

            break;

        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_build_report_config_to_add_mod -> wrong bitmask");
            break;

    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_report_config_eutra
*   INPUT        : report_config_eutra_t*      p_rrm_report_config_eutra,
*                  ReportConfigEUTRA*          p_report_config_eutra,
*                  uecc_ue_context_t*          p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds ReportConfigEUTRA in MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_report_config_eutra(
    report_config_eutra_t*      p_rrm_report_config_eutra,
    ReportConfigEUTRA*          p_report_config_eutra,
    uecc_ue_context_t*          p_uecc_ue_context
)
{
    rrc_return_et result = RRC_FAILURE;
    ReportConfigEUTRA_triggerType_event*            p_type_event = PNULL;
    report_config_eutra_trigger_type_event_t*       p_rrm_type_event = PNULL;

    RRC_ASSERT(PNULL != p_rrm_report_config_eutra);
    RRC_ASSERT(PNULL != p_report_config_eutra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_rrm_report_config_eutra->trigger_quantity =
        (U8)p_report_config_eutra->triggerQuantity ;
    p_rrm_report_config_eutra->report_quantity =
        (U8)p_report_config_eutra->reportQuantity ;
    p_rrm_report_config_eutra->max_report_cells =
        p_report_config_eutra->maxReportCells ;
    p_rrm_report_config_eutra->report_interval =
        (U8)p_report_config_eutra->reportInterval ;
    p_rrm_report_config_eutra->report_amount =
        (U8)p_report_config_eutra->reportAmount ;

    switch(p_report_config_eutra->triggerType.t)
    {
        case T_ReportConfigEUTRA_triggerType_event:
            p_rrm_report_config_eutra->trigger_type.bitmask |=
                REPORT_CONFIG_EUTRA_TRIGGER_TYPE_EVENT_PRESENT;

            if (PNULL == p_report_config_eutra->triggerType.u.event)
            {
                break;
            }

            p_rrm_type_event = &p_rrm_report_config_eutra->trigger_type.event;
            p_type_event = p_report_config_eutra->triggerType.u.event;

            p_rrm_type_event->hysteresis=
                p_type_event->hysteresis;
            p_rrm_type_event->time_to_trigger=
                (U8)p_type_event->timeToTrigger;

            result=
                uecc_rrm_build_report_config_eutra_trigger_type_event_eventid(
                    &p_rrm_type_event->event_id,
                    &p_type_event->eventId,p_uecc_ue_context);

            break;

        case T_ReportConfigEUTRA_triggerType_periodical:
            p_rrm_report_config_eutra->trigger_type.bitmask |=
                REPORT_CONFIG_EUTRA_TRIGGER_TYPE_PERIODICAL_PRESENT;

            if (PNULL == p_report_config_eutra->triggerType.u.periodical)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[%s] Null Pointer access !!\n",
                        __FUNCTION__);
                break;
            }

            p_rrm_report_config_eutra->trigger_type.periodical.purpose=
                (U8) (p_report_config_eutra->triggerType.u.periodical->purpose);

            result = RRC_SUCCESS;

            break;

        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_report_config_eutra -> wrong bitmask");
            break;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_report_config_eutra_ext
*   INPUT        : report_config_to_add_mod_report_config_t*      p_rrm_report_config,
*                  ReportConfigEUTRA*          p_report_config_eutra,
*                  uecc_ue_context_t*          p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds ReportConfigEUTRA in MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_report_config_eutra_ext(
    report_config_to_add_mod_report_config_t*      p_rrm_report_config,
    ReportConfigEUTRA*          p_report_config_eutra,
    uecc_ue_context_t*          p_uecc_ue_context
)
{
    rrc_return_et result = RRC_SUCCESS;

    RRC_ASSERT(PNULL != p_rrm_report_config);
    RRC_ASSERT(PNULL != p_report_config_eutra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,p_uecc_ue_context->p_gb_context->facility_name,
                          RRC_DETAILEDALL,"Unused variable"
                          "p_uecc_ue_context=%p",p_uecc_ue_context);/*SPR 17777+-*/

    /* SPR_20915 - Fix - Starts */
    if ((1 == p_report_config_eutra->m._v2ExtPresent) &&
        (1 == p_report_config_eutra->m.ue_RxTxTimeDiffPeriodical_r9Present) &&
        (PNULL != p_report_config_eutra->triggerType.u.periodical) &&
        (reportStrongestCells == 
             p_report_config_eutra->triggerType.u.periodical->purpose))
    /* SPR_20915 - Fix - Ends */
    {
        p_rrm_report_config->bitmask |= REPORT_CONFIG_EUTRA_EXT_PRESENT;
        p_rrm_report_config->report_config_eutra_ext.bitmask |= 
                             REPORT_CFG_EUTRA_UE_RXTX_TIME_DIFF_PRESENT;
        p_rrm_report_config->report_config_eutra_ext.ue_rxtx_time_diff =
            p_report_config_eutra->ue_RxTxTimeDiffPeriodical_r9;
    }
    /* ReportConfigEUTRA changes start */
    if ((1 == p_report_config_eutra->m._v3ExtPresent) &&
        (1 == p_report_config_eutra->m.reportAddNeighMeas_r10Present))
        {
        p_rrm_report_config->bitmask |= REPORT_CONFIG_EUTRA_EXT_PRESENT;
        p_rrm_report_config->report_config_eutra_ext.bitmask |=
                            REPORT_CFG_EUTRA_REPORT_ADD_NEIGH_MEAS_PRESENT; 
        p_rrm_report_config->report_config_eutra_ext.report_add_neigh_meas_r10 = 
            p_report_config_eutra->reportAddNeighMeas_r10;

        }
    /* ReportConfigEUTRA changes stop */

    /*SPR8897fix_start*/
    /* SPR_20915 - Fix - Starts */
    if ((1 == p_report_config_eutra->m._v2ExtPresent) &&
        (1 == p_report_config_eutra->m.si_RequestForHO_r9Present)&&
        (PNULL != p_report_config_eutra->triggerType.u.periodical) &&
        (reportCGI == p_report_config_eutra->triggerType.u.periodical->purpose)) 
    /* SPR_20915 - Fix - Ends */
    {
        p_rrm_report_config->bitmask |= REPORT_CONFIG_EUTRA_EXT_PRESENT;
        p_rrm_report_config->report_config_eutra_ext.bitmask |= 
            SI_REQUEST_FOR_HO_R9_EUTRA_PRESENT;
        p_rrm_report_config->report_config_eutra_ext.si_request_for_ho_r9 =
            (U8)p_report_config_eutra->si_RequestForHO_r9;
    }
    /*SPR8897fix_stop*/

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_report_config_eutra_trigger_type_event_eventid
*   INPUT        : report_config_eutra_trigger_type_event_eventid_t*   p_rrm_event_id,
*                  ReportConfigEUTRA_triggerType_event_eventId*        p_event_id,
*                  uecc_ue_context_t*                                  p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds ReportConfigEUTRA_triggerType_event_eventId in
*       MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_report_config_eutra_trigger_type_event_eventid(
    report_config_eutra_trigger_type_event_eventid_t*   p_rrm_event_id,
    ReportConfigEUTRA_triggerType_event_eventId*        p_event_id,
    uecc_ue_context_t*                                  p_uecc_ue_context
)
{
    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_event_id);
    RRC_ASSERT(PNULL != p_event_id);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    switch(p_event_id->t)
    {
        case T_ReportConfigEUTRA_triggerType_event_eventId_eventA1:
            p_rrm_event_id->bitmask |=
                REPORT_CONFIG_EUTRA_TRIGGER_TYPE_EVENT_EVENTID_A1_PRESENT;

            if (PNULL == p_event_id->u.eventA1)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[%s] Null Pointer access !!\n",
                        __FUNCTION__);
                break;
            }

            result = uecc_rrm_build_threshold_eutra(
                    &p_rrm_event_id->event_a1.a1_threshold,
                    &p_event_id->u.eventA1->a1_Threshold,p_uecc_ue_context);
            break;

        case T_ReportConfigEUTRA_triggerType_event_eventId_eventA2:
            p_rrm_event_id->bitmask |=
                REPORT_CONFIG_EUTRA_TRIGGER_TYPE_EVENT_EVENTID_A2_PRESENT;

            if (PNULL == p_event_id->u.eventA2)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[%s] Null Pointer access !!\n",
                        __FUNCTION__);
                break;
            }

            result = uecc_rrm_build_threshold_eutra(
                    &p_rrm_event_id->event_a2.a2_threshold,
                    &p_event_id->u.eventA2->a2_Threshold,p_uecc_ue_context);
            break;

        case T_ReportConfigEUTRA_triggerType_event_eventId_eventA3:
            p_rrm_event_id->bitmask |=
                REPORT_CONFIG_EUTRA_TRIGGER_TYPE_EVENT_EVENTID_A3_PRESENT;

            if (PNULL == p_event_id->u.eventA3)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[%s] Null Pointer access !!\n",
                        __FUNCTION__);
                break;
            }

            p_rrm_event_id->event_a3.a3_offset=
                p_event_id->u.eventA3->a3_Offset ;
            p_rrm_event_id->event_a3.report_on_leave=
                p_event_id->u.eventA3->reportOnLeave ;

            result = RRC_SUCCESS;
            break;

        case T_ReportConfigEUTRA_triggerType_event_eventId_eventA4:
            p_rrm_event_id->bitmask |=
                REPORT_CONFIG_EUTRA_TRIGGER_TYPE_EVENT_EVENTID_A4_PRESENT;

            if (PNULL == p_event_id->u.eventA4)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[%s] Null Pointer access !!\n",
                        __FUNCTION__);
                break;
            }
            result = uecc_rrm_build_threshold_eutra(
                        &p_rrm_event_id->event_a4.a4_threshold,
                        &p_event_id->u.eventA4->a4_Threshold,p_uecc_ue_context);
            break;

        case T_ReportConfigEUTRA_triggerType_event_eventId_eventA5:
            p_rrm_event_id->bitmask |=
                REPORT_CONFIG_EUTRA_TRIGGER_TYPE_EVENT_EVENTID_A5_PRESENT;

            if (PNULL == p_event_id->u.eventA5)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[%s] Null Pointer access !!\n",
                        __FUNCTION__);
                break;
            }
            result = uecc_rrm_build_threshold_eutra(
                        &p_rrm_event_id->event_a5.a5_threshold1,
                        &p_event_id->u.eventA5->a5_Threshold1,p_uecc_ue_context);
            if (RRC_FAILURE == result)
            {
                break;
            }

            result = uecc_rrm_build_threshold_eutra(
                        &p_rrm_event_id->event_a5.a5_threshold2,
                        &p_event_id->u.eventA5->a5_Threshold2,p_uecc_ue_context);
            break;

        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_report_config_eutra_trigger_type_event_eventid"
                " - wrong bitmask");
            break;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_threshold_eutra
*   INPUT        : threshold_eutra_t*  p_rrm_threshold_eutra,
*                  ThresholdEUTRA*     p_threshold_eutra,
*                  uecc_ue_context_t*  p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds ThresholdEUTRA in
*       MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_threshold_eutra(
    threshold_eutra_t*  p_rrm_threshold_eutra,
    ThresholdEUTRA*     p_threshold_eutra,
    uecc_ue_context_t*  p_uecc_ue_context
)
{
    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_threshold_eutra);
    RRC_ASSERT(PNULL != p_threshold_eutra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);


    switch(p_threshold_eutra->t)
    {
        case T_ThresholdEUTRA_threshold_RSRP:
            p_rrm_threshold_eutra->bitmask |= 
                THRESHOLD_EUTRA_RSRP_PRESENT;
            p_rrm_threshold_eutra->threshold_rsrp=
                p_threshold_eutra->u.threshold_RSRP ;
            result = RRC_SUCCESS;
            break;

        case T_ThresholdEUTRA_threshold_RSRQ:
            p_rrm_threshold_eutra->bitmask |= 
                THRESHOLD_EUTRA_RSRQ_PRESENT;
            p_rrm_threshold_eutra->threshold_rsrq=
                p_threshold_eutra->u.threshold_RSRQ ;
            result = RRC_SUCCESS;
            break;

        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_build_threshold_eutra -> wrong bitmask");
            break;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_report_config_interrat
*   INPUT        : report_config_interrat_t*   p_rrm_report_config_interrat,
*                  ReportConfigInterRAT*       p_report_config_interrat,
*                  uecc_ue_context_t*          p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds ReportConfigInterRAT in MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_report_config_interrat(
    report_config_interrat_t*   p_rrm_report_config_interrat,
    ReportConfigInterRAT*       p_report_config_interrat,
    uecc_ue_context_t*          p_uecc_ue_context
)
{
    rrc_return_et result = RRC_FAILURE;
    ReportConfigInterRAT_triggerType_event*         p_type_event = PNULL;
    report_config_interrat_trigger_type_event_t*    p_rrm_type_event = PNULL;

    RRC_ASSERT(PNULL != p_rrm_report_config_interrat);
    RRC_ASSERT(PNULL != p_report_config_interrat);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_rrm_report_config_interrat->max_report_cells=
        p_report_config_interrat->maxReportCells ;
    p_rrm_report_config_interrat->report_interval=
        (U8)p_report_config_interrat->reportInterval ;
    p_rrm_report_config_interrat->report_amount=
        (U8)p_report_config_interrat->reportAmount ;

    switch(p_report_config_interrat->triggerType.t)
    {
        case T_ReportConfigInterRAT_triggerType_event:
            p_rrm_report_config_interrat->trigger_type.bitmask |=
                REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_PRESENT;

            if (PNULL == p_report_config_interrat->triggerType.u.event)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[%s] Null Pointer access !!\n",
                        __FUNCTION__);
                break;
            }

            p_rrm_type_event=&p_rrm_report_config_interrat->trigger_type.event;
            p_type_event = p_report_config_interrat->triggerType.u.event;

            p_rrm_type_event->hysteresis=
                p_type_event->hysteresis; 
            p_rrm_type_event->time_to_trigger=
                (U8)p_type_event->timeToTrigger;

            result =
               uecc_rrm_build_report_config_interrat_trigger_type_event_eventid(
                    &p_rrm_type_event->event_id,
                    &p_type_event->eventId,
                    p_uecc_ue_context);

            break;

        case T_ReportConfigInterRAT_triggerType_periodical:
            p_rrm_report_config_interrat->trigger_type.bitmask |=
                REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_PERIODICAL_PRESENT;

            if (PNULL == p_report_config_interrat->triggerType.u.periodical)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[%s] Null Pointer access !!\n",
                        __FUNCTION__);
                break;
            }

            p_rrm_report_config_interrat->trigger_type.periodical.purpose=
                (U8)p_report_config_interrat->triggerType.u.periodical->purpose ;
            /*SPR8897fix_start*/
            if( (p_report_config_interrat->m._v2ExtPresent)&&
                    (p_report_config_interrat->m.si_RequestForHO_r9Present) )
            {
                p_rrm_report_config_interrat->bitmask |= SI_REQUEST_FOR_HO_R9_INTERRAT_PRESENT;
                p_rrm_report_config_interrat->si_request_for_ho_r9 = 
                    (U8)p_report_config_interrat->si_RequestForHO_r9;
            }    
            /*SPR8897fix_stop*/

            result = RRC_SUCCESS;
            break;

        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_build_report_config_interrat -> wrong bitmask");
            break;
    }

#ifdef ENDC_ENABLED
    if ( REPORT_QUANTITY_CELL_NR_R15_PRESENT &
        p_rrm_report_config_interrat->bitmask )
    {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_DETAILED,
                    "REPORT_QUANTITY_CELL_NR_R15_PRESENT");
        p_report_config_interrat->m._v8ExtPresent = RRC_ONE;
        p_report_config_interrat->m.reportQuantityCellNR_r15Present = RRC_ONE;

        p_report_config_interrat->reportQuantityCellNR_r15.ss_rsrp =
            p_rrm_report_config_interrat->report_quantity_cell_nr_r15.ss_rsrp; 

        p_report_config_interrat->reportQuantityCellNR_r15.ss_rsrq =
            p_rrm_report_config_interrat->report_quantity_cell_nr_r15.ss_rsrq; 

        p_report_config_interrat->reportQuantityCellNR_r15.ss_sinr =
            p_rrm_report_config_interrat->report_quantity_cell_nr_r15.ss_sinr; 
    }

    if ( MAX_REPORT_RS_INDEX_PRESENT &
        p_rrm_report_config_interrat->bitmask )
    {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_DETAILED,
                    "MAX_REPORT_RS_INDEX_PRESENT");
        p_report_config_interrat->m._v8ExtPresent = RRC_ONE;
        p_report_config_interrat->m.maxReportRS_Index_r15Present = RRC_ONE;

        p_report_config_interrat->maxReportRS_Index_r15 =
            p_rrm_report_config_interrat->max_report_rs_index_r15; 
    }

    if ( REPORT_QUANTITY_RS_INDEX_NR_PRESENT &
        p_rrm_report_config_interrat->bitmask )
    {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_DETAILED,
                    "MAX_REPORT_RS_INDEX_PRESENT");
        p_report_config_interrat->m._v8ExtPresent = RRC_ONE;
        p_report_config_interrat->m.reportQuantityRS_IndexNR_r15Present = RRC_ONE;

        p_report_config_interrat->reportQuantityRS_IndexNR_r15.ss_rsrp =
            p_rrm_report_config_interrat->report_quantity_rs_index_nr_r15.ss_rsrp; 

        p_report_config_interrat->reportQuantityRS_IndexNR_r15.ss_rsrq =
            p_rrm_report_config_interrat->report_quantity_rs_index_nr_r15.ss_rsrq; 

        p_report_config_interrat->reportQuantityRS_IndexNR_r15.ss_sinr =
            p_rrm_report_config_interrat->report_quantity_rs_index_nr_r15.ss_sinr; 
    }

    if ( REPORT_RS_INDEX_RESULTS_NR_PRESENT &
        p_rrm_report_config_interrat->bitmask )
    {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_DETAILED,
                    "MAX_REPORT_RS_INDEX_PRESENT");
        p_report_config_interrat->m._v8ExtPresent = RRC_ONE;
        p_report_config_interrat->m.reportRS_IndexResultsNRPresent = RRC_ONE;

        p_report_config_interrat->reportRS_IndexResultsNR =
            p_rrm_report_config_interrat->report_rs_index_results_nr; 
    }

    if ( REPORT_SFTD_MEAS_PRESENT &
        p_rrm_report_config_interrat->bitmask )
    {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_DETAILED,
                    "MAX_REPORT_RS_INDEX_PRESENT");
        p_report_config_interrat->m._v8ExtPresent = RRC_ONE;
        p_report_config_interrat->m.reportSFTD_Meas_r15Present = RRC_ONE;

        p_report_config_interrat->reportSFTD_Meas_r15 =
            p_rrm_report_config_interrat->report_sftd_meas_r15; 
    }
#endif
    if( p_report_config_interrat->m._v3ExtPresent )
    {
        if( p_report_config_interrat->m.reportQuantityUTRA_FDD_r10Present )
        {
            p_rrm_report_config_interrat->bitmask |= REPORT_QUANTITY_UTRA_FDD_R10_PRESENT;
            p_rrm_report_config_interrat->report_quantity_UTRA_FDD_r10 = 
                 p_report_config_interrat->reportQuantityUTRA_FDD_r10;
        }    
    }    


    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME:uecc_rrm_build_report_config_interrat_trigger_type_event_eventid
*   INPUT        :report_config_interrat_trigger_type_event_eventid_t*    p_rrm_event_id,
*                 ReportConfigInterRAT_triggerType_event_eventId*         p_event_id,
*                 uecc_ue_context_t*                                      p_uecc_ue_context
*   OUTPUT      : none
*   DESCRIPTION:
*       This function builds ReportConfigInterRAT_triggerType_event_eventId in
*       MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_report_config_interrat_trigger_type_event_eventid(
    report_config_interrat_trigger_type_event_eventid_t*    p_rrm_event_id,
    ReportConfigInterRAT_triggerType_event_eventId*         p_event_id,
    uecc_ue_context_t*                                      p_uecc_ue_context
)
{
    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_event_id);
    RRC_ASSERT(PNULL != p_event_id);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    switch(p_event_id->t)
    {
        case T_ReportConfigInterRAT_triggerType_event_eventId_eventB1:
            p_rrm_event_id->bitmask |=
                REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B1_PRESENT;

            if (PNULL == p_event_id->u.eventB1)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[%s] Null Pointer access !!\n",
                        __FUNCTION__);
                break;
            }

            result = uecc_rrm_build_rrm_b1_threshold(
                    &p_rrm_event_id->event_b1,
                    &p_event_id->u.eventB1->b1_Threshold,
                    p_uecc_ue_context);
            break;

        case T_ReportConfigInterRAT_triggerType_event_eventId_eventB2:
            p_rrm_event_id->bitmask |=
                REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B2_PRESENT;
            if (PNULL == p_event_id->u.eventB2)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[%s] Null Pointer access !!\n",
                        __FUNCTION__);
                break;
            }

            result =
      uecc_rrm_build_report_config_interrat_trigger_type_event_eventid_event_b2(
                    &p_rrm_event_id->event_b2,
                    p_event_id->u.eventB2,p_uecc_ue_context);
            break;


        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_report_config_interrat"
                "_trigger_type_event_eventid"
                " - wrong bitmask");
            break;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_rrm_b1_threshold
*   INPUT        : report_config_interrat_trigger_type_event_eventid_event_b1_t*
*                  p_rrm_b1_threshold,
*                  ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold*
*                  p_b1_threshold,
*                  uecc_ue_context_t*                                      p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds ThresholdEUTRA in
*       MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_rrm_b1_threshold(
    report_config_interrat_trigger_type_event_eventid_event_b1_t*
        p_rrm_b1_threshold,
    ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold*
        p_b1_threshold,
    uecc_ue_context_t*                                      p_uecc_ue_context
)
{
    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_b1_threshold);
    RRC_ASSERT(PNULL != p_b1_threshold);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    switch(p_b1_threshold->t)
    {
        case T_ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold_b1_ThresholdUTRA:
            p_rrm_b1_threshold->bitmask |= 
    REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B1_THRESHOLD_UTRA_PRESENT;

            if (PNULL == p_b1_threshold->u.b1_ThresholdUTRA)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[%s] Null Pointer access !!\n",
                        __FUNCTION__);
                break;
            }

            result = uecc_rrm_build_threshold_utra(
                    &p_rrm_b1_threshold->b1_threshold_utra,
                    p_b1_threshold->u.b1_ThresholdUTRA,
                    p_uecc_ue_context);
            break;

        case T_ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold_b1_ThresholdGERAN:
            p_rrm_b1_threshold->bitmask |= 
    REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B1_THRESHOLD_GERAN_PRESENT;
        p_rrm_b1_threshold->b1_threshold_geran=
            p_b1_threshold->u.b1_ThresholdGERAN ;
            result = RRC_SUCCESS;
            break;

        case T_ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold_b1_ThresholdCDMA2000:
            p_rrm_b1_threshold->bitmask |= 
 REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B1_THRESHOLD_CDMA2000_PRESENT;

            p_rrm_b1_threshold->b1_threshold_cdma2000=
                p_b1_threshold->u.b1_ThresholdCDMA2000 ;
            result = RRC_SUCCESS;
            break;

        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_build_rrm_b1_threshold - wrong bitmask");
            break;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_threshold_utra
*   INPUT        : threshold_utra_t*   p_rrm_threshold_utra,
*                  ThresholdUTRA*      p_threshold_utra,
*                  uecc_ue_context_t*  p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds ThresholdUTRA in
*       MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_threshold_utra(
    threshold_utra_t*   p_rrm_threshold_utra,
    ThresholdUTRA*      p_threshold_utra,
    uecc_ue_context_t*  p_uecc_ue_context
)
{
    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_threshold_utra);
    RRC_ASSERT(PNULL != p_threshold_utra);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    switch(p_threshold_utra->t)
    {
        case T_ThresholdUTRA_utra_RSCP:
            p_rrm_threshold_utra->bitmask |=
                THRESHOLD_UTRA_RSCP_PRESENT;
            p_rrm_threshold_utra->threshold_rscp=
                p_threshold_utra->u.utra_RSCP;
            result = RRC_SUCCESS;
            break;

        case T_ThresholdUTRA_utra_EcN0:
            p_rrm_threshold_utra->bitmask |=
                THRESHOLD_UTRA_ECN0_PRESENT;
            p_rrm_threshold_utra->threshold_ecn0=
                p_threshold_utra->u.utra_EcN0;
            result = RRC_SUCCESS;
            break;

        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_build_threshold_utra -> wrong bitmask");
            break;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME:
*       uecc_rrm_build_report_config_interrat_trigger_type_event_eventid_event_b2
*   INPUT        :report_config_interrat_trigger_type_event_eventid_event_b2_t*
*                 p_rrm_b2_threshold,
*                 ReportConfigInterRAT_triggerType_event_eventId_eventB2*         p_event_b2,
*                 uecc_ue_context_t*                                      p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds
*           ReportConfigInterRAT_triggerType_event_eventId_eventB2 in
*           MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et
 uecc_rrm_build_report_config_interrat_trigger_type_event_eventid_event_b2(
    report_config_interrat_trigger_type_event_eventid_event_b2_t*
        p_rrm_b2_threshold,
    ReportConfigInterRAT_triggerType_event_eventId_eventB2*         p_event_b2,
    uecc_ue_context_t*                                      p_uecc_ue_context
)
{
    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_b2_threshold);
    RRC_ASSERT(PNULL != p_event_b2);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {
        result = uecc_rrm_build_threshold_eutra(
                &p_rrm_b2_threshold->b2_threshold_eutra,
                &p_event_b2->b2_Threshold1,
                p_uecc_ue_context);

        if (RRC_FAILURE == result)
        {
            break;
        }

        switch(p_event_b2->b2_Threshold2.t)
        {
            case T_ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2_b2_Threshold2UTRA:
                p_rrm_b2_threshold->bitmask |= 
    REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B2_THRESHOLD_UTRA_PRESENT;

                if (PNULL == p_event_b2->b2_Threshold2.u.b2_Threshold2UTRA)
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,"[%s] Null Pointer access !!\n",
                            __FUNCTION__);
                    break;
                }

                result = uecc_rrm_build_threshold_utra(
                        &p_rrm_b2_threshold->b2_threshold_utra,
                        p_event_b2->b2_Threshold2.u.b2_Threshold2UTRA,
                        p_uecc_ue_context);
                break;

            case T_ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2_b2_Threshold2GERAN:
                p_rrm_b2_threshold->bitmask |= 
    REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B2_THRESHOLD_GERAN_PRESENT;

            p_rrm_b2_threshold->b2_threshold_geran=
                p_event_b2->b2_Threshold2.u.b2_Threshold2GERAN ;
                result = RRC_SUCCESS;
                break;

            case T_ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2_b2_Threshold2CDMA2000:
                p_rrm_b2_threshold->bitmask |= 
 REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B2_THRESHOLD_CDMA2000_PRESENT;
    p_event_b2->b2_Threshold2.t =
T_ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2_b2_Threshold2CDMA2000;
    p_rrm_b2_threshold->b2_threshold_cdma2000=
        p_event_b2->b2_Threshold2.u.b2_Threshold2CDMA2000 ;
                result = RRC_SUCCESS;
                break;

            default:
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "%s - wrong bitmask:%d",__FUNCTION__,
                    p_rrm_b2_threshold->bitmask);
                break;
        }
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_id_to_remove_list
*   INPUT        : meas_id_to_remove_list_t*   p_rrm_meas_id_to_remove_list,
*                  MeasIdToRemoveList*         p_meas_id_to_remove_list,
*                  uecc_ue_context_t*          p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds MeasIdToRemoveList in
*       MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_id_to_remove_list(
    meas_id_to_remove_list_t*   p_rrm_meas_id_to_remove_list,
    MeasIdToRemoveList*         p_meas_id_to_remove_list,
    uecc_ue_context_t*          p_uecc_ue_context
)
{
    U8              i=0;
    rrc_return_et   result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_meas_id_to_remove_list);
    RRC_ASSERT(PNULL != p_meas_id_to_remove_list);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {
        /* check list size */
        if (  p_meas_id_to_remove_list->n > MAX_MEAS_ID)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "uecc_rrm_build_meas_id_to_remove_list "
                    "wrong list count [%u]",
                    p_meas_id_to_remove_list->n);
            break;
        }

        p_rrm_meas_id_to_remove_list->count=
            (U8)p_meas_id_to_remove_list->n ;

        for (i=0; i < p_meas_id_to_remove_list->n; i++)
        {
            p_rrm_meas_id_to_remove_list->meas_id[i]=
                p_meas_id_to_remove_list->elem[i] ;
        }

        result = RRC_SUCCESS;
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_id_to_add_mod_list
*   INPUT        : uecc_gb_context_t           *p_uecc_gb_context,
*                  meas_id_to_add_mod_list_t*  p_rrm_meas_id_to_add_mod_list,
*                  MeasIdToAddModList*         p_meas_id_to_add_mod_list
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds MeasIdToAddModList in
*       MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_id_to_add_mod_list(
    uecc_gb_context_t           *p_uecc_gb_context,
    meas_id_to_add_mod_list_t*  p_rrm_meas_id_to_add_mod_list,
    MeasIdToAddModList*         p_meas_id_to_add_mod_list
)
{
    rrc_return_et   result = RRC_SUCCESS;
    MeasIdToAddMod* p_meas_id_to_add_mod = PNULL;
    OSRTDListNode*  p_node = PNULL;
    U8 i=0;

    RRC_ASSERT(PNULL != p_rrm_meas_id_to_add_mod_list);
    RRC_ASSERT(PNULL != p_meas_id_to_add_mod_list);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/

    p_rrm_meas_id_to_add_mod_list->count = (U8)p_meas_id_to_add_mod_list->count;
    p_node = (p_meas_id_to_add_mod_list->head);

    for (i=0; i < p_rrm_meas_id_to_add_mod_list->count; i++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        p_meas_id_to_add_mod = p_node->data;
        p_rrm_meas_id_to_add_mod_list->meas_id_to_add_mod[i].meas_id=
            p_meas_id_to_add_mod->measId ;
        p_rrm_meas_id_to_add_mod_list->meas_id_to_add_mod[i].meas_object_id=
            p_meas_id_to_add_mod->measObjectId ;
        p_rrm_meas_id_to_add_mod_list->meas_id_to_add_mod[i].report_config_id=
            p_meas_id_to_add_mod->reportConfigId ;

        p_node = p_node->next;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_quantity_config
*   INPUT        : uecc_gb_context_t           *p_uecc_gb_context,
*                  quantity_config_t*  p_rrm_quantity_config,
*                  QuantityConfig*     p_quantity_config
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds QuantityConfig in
*       MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_quantity_config(
    uecc_gb_context_t           *p_uecc_gb_context,
    quantity_config_t*  p_rrm_quantity_config,
    QuantityConfig*     p_quantity_config)
{
    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_quantity_config);
    RRC_ASSERT(PNULL != p_quantity_config);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/

    do
    {
        if (p_quantity_config->m.quantityConfigCDMA2000Present)
        {
            p_rrm_quantity_config->bitmask |= 
                QUANTITY_CONFIG_CDMA2000_PRESENT;

            p_rrm_quantity_config->quantity_config_cdma2000.
                meas_quantity_cdma2000 = (U8)
                (p_quantity_config->quantityConfigCDMA2000.
                measQuantityCDMA2000) ;

            result = RRC_SUCCESS;
        }

        if (p_quantity_config->m.quantityConfigEUTRAPresent)
        {
            p_rrm_quantity_config->bitmask |= 
                QUANTITY_CONFIG_EUTRA_PRESENT;

            p_rrm_quantity_config->quantity_config_eutra.filter_coefficient_rsrp
                = p_quantity_config->quantityConfigEUTRA.filterCoefficientRSRP;

            p_rrm_quantity_config->quantity_config_eutra.filter_coefficient_rsrq
                = p_quantity_config->quantityConfigEUTRA.filterCoefficientRSRQ;

            result = RRC_SUCCESS;
        }

        if (p_quantity_config->m.quantityConfigUTRAPresent)
        {
            p_rrm_quantity_config->bitmask |= 
                QUANTITY_CONFIG_UTRA_PRESENT;

            p_rrm_quantity_config->quantity_config_utra.
                meas_quantity_utra_fdd = (U8)
                p_quantity_config->quantityConfigUTRA.measQuantityUTRA_FDD ;

            p_rrm_quantity_config->quantity_config_utra.
                meas_quantity_utra_tdd = (U8)
                p_quantity_config->quantityConfigUTRA.measQuantityUTRA_TDD ;

            p_rrm_quantity_config->quantity_config_utra.filter_coefficient=
                (U8) (p_quantity_config->quantityConfigUTRA.filterCoefficient);

            result = RRC_SUCCESS;

        }

        if (p_quantity_config->m.quantityConfigGERANPresent)
        {
            p_rrm_quantity_config->bitmask |=
                QUANTITY_CONFIG_GERAN_PRESENT;

            p_rrm_quantity_config->quantity_config_geran.
                meas_quantity_geran = (U8)
                p_quantity_config->quantityConfigGERAN.measQuantityGERAN;

            p_rrm_quantity_config->quantity_config_geran.
                filter_coefficient = (U8)
                p_quantity_config->quantityConfigGERAN.filterCoefficient;

            result = RRC_SUCCESS;
        }
        
        if (p_quantity_config->m._v2ExtPresent)
        {
            if(p_quantity_config->m.quantityConfigUTRA_v1020Present)
            {    
                p_rrm_quantity_config->bitmask |=
                    QUANTITY_CONFIG_UTRA_v1020_PRESENT;

                p_rrm_quantity_config->quantity_config_UTRA_v1020.
                    filterCoefficient2_FDD_r10 = (U8)
                    p_quantity_config->quantityConfigUTRA_v1020.filterCoefficient2_FDD_r10;
            result = RRC_SUCCESS;
            }
        }


    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_gap_config
*   INPUT        : meas_gap_config_t*  p_rrm_meas_gap_config,
*                  MeasGapConfig*      p_meas_gap_config,
*                  uecc_ue_context_t*  p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds MeasGapConfig in
*       MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_gap_config(
    meas_gap_config_t*  p_rrm_meas_gap_config,
    MeasGapConfig*      p_meas_gap_config,
    uecc_ue_context_t*  p_uecc_ue_context)
{
    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_meas_gap_config);
    RRC_ASSERT(PNULL != p_meas_gap_config);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {
        /*SPR Fixed during IntraRAT HO Integration:
         * Bitmasking was missing/incorrect.*/
        p_rrm_meas_gap_config->bitmask = 0;
        if (p_meas_gap_config->t == T_MeasGapConfig_setup)
        {
            if (PNULL == p_meas_gap_config->u.setup)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[%s] Null Pointer access !!\n",
                        __FUNCTION__);
                break;
            }
            p_rrm_meas_gap_config->meas_gap_config_type = 1;
            p_rrm_meas_gap_config->bitmask |=
                MEAS_GAP_CONFIG_SETUP_CONFIG_INFO_PRESENT;

            switch(p_meas_gap_config->u.setup->gapOffset.t)
            {
                case T_MeasGapConfig_setup_gapOffset_gp0:
                    p_rrm_meas_gap_config->setup_config_info.bitmask |=
                        MEAS_GAP_CONFIG_GP0_PRESENT;
                    p_rrm_meas_gap_config->setup_config_info.gp0=
                        p_meas_gap_config->u.setup->gapOffset.u.gp0 ;
                    result = RRC_SUCCESS;
                    break;

                case T_MeasGapConfig_setup_gapOffset_gp1:
                    p_rrm_meas_gap_config->setup_config_info.bitmask |= 
                        MEAS_GAP_CONFIG_GP1_PRESENT;
                    p_rrm_meas_gap_config->setup_config_info.gp1=
                        p_meas_gap_config->u.setup->gapOffset.u.gp1 ;
                    result = RRC_SUCCESS;
                    break;

                default:
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "uecc_rrm_build_meas_gap_config -> wrong bitmask");
                    break;
            }
        }
        else
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_BRIEF,"[%s]p_meas_gap_config->t = "
                    "T_MeasGapConfig_release;",__FUNCTION__);
            p_rrm_meas_gap_config->meas_gap_config_type = 0;

            result = RRC_SUCCESS;
        }
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_pre_registration_info_hrpd
*   INPUT        : uecc_gb_context_t               *p_uecc_gb_context,
*                  pre_registration_info_hrpd_t*   p_rrm_pre_registration_info_hrpd,
*                  PreRegistrationInfoHRPD*        p_pre_registration_info_hrpd
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds PreRegistrationInfoHRPD in
*       MeasConfig structure
*
*   RETURNS:
*       None
*
******************************************************************************/
void uecc_rrm_build_pre_registration_info_hrpd(
    uecc_gb_context_t               *p_uecc_gb_context,
    pre_registration_info_hrpd_t*   p_rrm_pre_registration_info_hrpd,
    PreRegistrationInfoHRPD*        p_pre_registration_info_hrpd
)
{
    RRC_ASSERT(PNULL != p_rrm_pre_registration_info_hrpd);
    RRC_ASSERT(PNULL != p_pre_registration_info_hrpd);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/

    p_rrm_pre_registration_info_hrpd->pre_registration_allowed=
        p_pre_registration_info_hrpd->preRegistrationAllowed ;

    if (p_pre_registration_info_hrpd->m.preRegistrationZoneIdPresent)
    {
        p_rrm_pre_registration_info_hrpd->bitmask |=
            PRE_REGISTRATION_ZONE_ID_PRESENT ;
        p_rrm_pre_registration_info_hrpd->pre_registration_zone_id=
            p_pre_registration_info_hrpd->preRegistrationZoneId ;
    }

    if (p_pre_registration_info_hrpd->m.
            secondaryPreRegistrationZoneIdListPresent)
    {
        p_rrm_pre_registration_info_hrpd->bitmask |= 
            PRE_REGISTRATION_SECONDARY_ZONE_ID_LIST_PRESENT;
        p_rrm_pre_registration_info_hrpd->
            secondary_pre_registration_zone_id_list.count=
            (U8) (p_pre_registration_info_hrpd->
            secondaryPreRegistrationZoneIdList.n) ;
        p_rrm_pre_registration_info_hrpd-> 
            secondary_pre_registration_zone_id_list. 
            pre_registration_zone_id_hrpd[0]=
            p_pre_registration_info_hrpd->secondaryPreRegistrationZoneIdList. 
            elem[0] ;
        p_rrm_pre_registration_info_hrpd->
            secondary_pre_registration_zone_id_list.
            pre_registration_zone_id_hrpd[1]=
            p_pre_registration_info_hrpd->secondaryPreRegistrationZoneIdList.
            elem[1] ;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_config_speed_state_pars
*   INPUT        : meas_config_speed_state_pars_t* p_rrm_meas_config_speed_state_pars,
*                  MeasConfig_speedStatePars*      p_meas_config_speed_state_pars,
*                  uecc_ue_context_t*              p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds MeasConfig_speedStatePars in
*       MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_config_speed_state_pars(
    meas_config_speed_state_pars_t* p_rrm_meas_config_speed_state_pars,
    MeasConfig_speedStatePars*      p_meas_config_speed_state_pars,
    uecc_ue_context_t*              p_uecc_ue_context)
{
    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_meas_config_speed_state_pars);
    RRC_ASSERT(PNULL != p_meas_config_speed_state_pars);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {
        if (p_meas_config_speed_state_pars->t == 
                T_MeasConfig_speedStatePars_setup)
        {
            p_rrm_meas_config_speed_state_pars->bitmask |=
                MEAS_CONFIG_SPEED_STATE_SETUP_PRESENT;

            if (PNULL == p_meas_config_speed_state_pars->u.setup)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,"[%s] Null Pointer access !!\n",
                        __FUNCTION__);
                break;
            }

            p_rrm_meas_config_speed_state_pars->setup.  
                mobility_state_parameters.t_evaluation=
                (U8) (p_meas_config_speed_state_pars->u.setup->
                mobilityStateParameters.  
                t_Evaluation);

            p_rrm_meas_config_speed_state_pars->setup.  
                mobility_state_parameters.t_hyst_normal=
                (U8) (p_meas_config_speed_state_pars->u.setup->
                mobilityStateParameters.t_HystNormal);

            p_rrm_meas_config_speed_state_pars-> 
                setup.mobility_state_parameters.m_cell_charge_medium=
                p_meas_config_speed_state_pars->u.setup->
                mobilityStateParameters.  
                n_CellChangeMedium ;

            p_rrm_meas_config_speed_state_pars->setup.  
                mobility_state_parameters.m_cell_charge_high=
                p_meas_config_speed_state_pars->u.setup->
                mobilityStateParameters.  
                n_CellChangeHigh ;

            p_rrm_meas_config_speed_state_pars->setup.  
                time_to_trigger_sf.sf_medium=
                (U8)p_meas_config_speed_state_pars->u.setup->timeToTrigger_SF.  
                sf_Medium ;

            p_rrm_meas_config_speed_state_pars->setup.  
                time_to_trigger_sf.sf_high=
                (U8) (p_meas_config_speed_state_pars->u.setup->timeToTrigger_SF.  
                sf_High);

            result = RRC_SUCCESS;
        }
        else
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_BRIEF,"[%s]p_meas_config_speed_state_pars->t ="
                    "T_MeasConfig_speedStatePars_release;",__FUNCTION__);
            result = RRC_SUCCESS;
        }
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_radio_resource_config_dedicated
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context,
*                  radio_resource_config_dedicated_t * p_rrm_radio_resource_config_dedicated,
*                  RadioResourceConfigDedicated * p_s1ap_sourceRadioResourceConfig
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds radio_resource_config_dedicated
*       as_config_t structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/

rrc_return_et   uecc_rrm_build_radio_resource_config_dedicated(
        uecc_ue_context_t* p_uecc_ue_context,
      radio_resource_config_dedicated_t * p_rrm_radio_resource_config_dedicated,
        RadioResourceConfigDedicated * p_s1ap_sourceRadioResourceConfig)
{

    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrm_radio_resource_config_dedicated);
    RRC_ASSERT(PNULL != p_s1ap_sourceRadioResourceConfig);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do {

        if (p_s1ap_sourceRadioResourceConfig->m.srb_ToAddModListPresent)
        {
            if (RRC_FAILURE == uecc_rrm_build_rrm_srb_to_add_info_list(
                        p_uecc_ue_context,
                        &p_rrm_radio_resource_config_dedicated->
                        rrm_srb_to_add_info,
                        &p_s1ap_sourceRadioResourceConfig->srb_ToAddModList))
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "uecc_rrm_build_rrm_srb_to_add_info_list "
                        "returned failure!\n");

                break;
            }
        }

        if (p_s1ap_sourceRadioResourceConfig->m.drb_ToAddModListPresent)
        {
            if (RRC_FAILURE == uecc_rrm_build_drb_to_add_mod_list(
                        p_uecc_ue_context, 
                        &p_rrm_radio_resource_config_dedicated->
                        rrm_drb_to_add_info_list,
                        &p_s1ap_sourceRadioResourceConfig->drb_ToAddModList))
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "uecc_rrm_build_drb_to_add_mod_list "
                        "returned failure!\n");
                break;
            }
        }
        
        if (p_s1ap_sourceRadioResourceConfig->m.mac_MainConfigPresent)
        {
            if (RRC_FAILURE == uecc_rrm_build_mac_main_config(
                        p_uecc_ue_context, 
                        &p_rrm_radio_resource_config_dedicated->mac_main_config,
                        &p_s1ap_sourceRadioResourceConfig->mac_MainConfig))
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "uecc_rrm_build_mac_main_config "
                        "returned failure!\n");
                break;
            }
        }

        if (p_s1ap_sourceRadioResourceConfig->m.sps_ConfigPresent)
        {
            p_rrm_radio_resource_config_dedicated->bitmask |=
                RADIO_RESOURCE_CONFIG_DEDICATED_SPS_CONFIG_PRESENT ;

            if (RRC_FAILURE == uecc_rrm_build_asn1_sps_config(
                        p_uecc_ue_context, 
                        &p_rrm_radio_resource_config_dedicated->sps_config,
                        &p_s1ap_sourceRadioResourceConfig->sps_Config))
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "uecc_rrm_build_asn1_sps_config"
                        "returned failure!\n");
                break;
            }
        }

//SPR 13sep2011
        if (p_s1ap_sourceRadioResourceConfig->m.physicalConfigDedicatedPresent)
        {
            p_rrm_radio_resource_config_dedicated->bitmask |=
                RADIO_RESOURCE_CONFIG_DEDICATED_PHYSICAL_CONFIG_DEDICATED_PRESENT ;

            if (RRC_FAILURE == uecc_rrm_build_rrm_physical_config_dedicated(
                p_uecc_ue_context, 
                &p_rrm_radio_resource_config_dedicated->
                rrc_phy_physical_config_dedicated,
                &p_s1ap_sourceRadioResourceConfig->physicalConfigDedicated))
            {
              RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                  (p_uecc_ue_context->p_gb_context)->facility_name,
                  RRC_WARNING,
                  "uecc_rrm_build_rrm_physical_config_dedicated"
                  "returned failure!\n");
              break;
            }
        }

        
        /* cr_220 Rlf Timers & Constants */
        if (p_s1ap_sourceRadioResourceConfig->m.rlf_TimersAndConstants_r9Present)
        {
          p_rrm_radio_resource_config_dedicated->bitmask |= 
          RADIO_RESOURCE_CONFIG_DEDICATED_RLF_TIMERS_AND_CONSTANTS_PRESENT;

          if(T_RLF_TimersAndConstants_r9_setup ==
              p_s1ap_sourceRadioResourceConfig->rlf_TimersAndConstants_r9.t)
          {

            if (PNULL ==
                p_s1ap_sourceRadioResourceConfig->rlf_TimersAndConstants_r9.u.setup)
            {
                break;
            }

            p_rrm_radio_resource_config_dedicated->rlf_timers_and_constants_r9.bitmask =
                RLF_TIMERS_AND_CONSTANTS_SETUP_PRESENT;

            p_rrm_radio_resource_config_dedicated->rlf_timers_and_constants_r9.setup.t301_r9
            = (U8)p_s1ap_sourceRadioResourceConfig->rlf_TimersAndConstants_r9.u.setup->t301_r9;
          
            p_rrm_radio_resource_config_dedicated->rlf_timers_and_constants_r9.setup.t310_r9
            = (U8)p_s1ap_sourceRadioResourceConfig->rlf_TimersAndConstants_r9.u.setup->t310_r9;

            p_rrm_radio_resource_config_dedicated->rlf_timers_and_constants_r9.setup.n310_r9
            = (U8)p_s1ap_sourceRadioResourceConfig->rlf_TimersAndConstants_r9.u.setup->n310_r9;

            p_rrm_radio_resource_config_dedicated->rlf_timers_and_constants_r9.setup.t311_r9
            = (U8)p_s1ap_sourceRadioResourceConfig->rlf_TimersAndConstants_r9.u.setup->t311_r9;

            p_rrm_radio_resource_config_dedicated->rlf_timers_and_constants_r9.setup.n311_r9
            = (U8)p_s1ap_sourceRadioResourceConfig->rlf_TimersAndConstants_r9.u.setup->n311_r9;

          }
          else
          {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "rlf_TimersAndConstants_r9.u.setup not present\n");
            break;
          }
        }
 
        result = RRC_SUCCESS;
    }while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_rrm_srb_to_add_info_list
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context,
*                  rrm_sr*b_info_t            *  p_rrm_srb_to_add_info,
*                  SRB_ToAddModList * p_SRB_ToAddModList
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds srb_to_add_info_list
*       as_config_t structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/

rrc_return_et   uecc_rrm_build_rrm_srb_to_add_info_list(
        uecc_ue_context_t* p_uecc_ue_context,
         rrm_srb_info_t            *  p_rrm_srb_to_add_info,
        SRB_ToAddModList * p_SRB_ToAddModList)
{
    SRB_ToAddMod * p_SRB_ToAddMod = PNULL;
    OSRTDListNode*      p_node = PNULL;
    U8 count = 0;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrm_srb_to_add_info);
    RRC_ASSERT(PNULL != p_SRB_ToAddModList);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_node = p_SRB_ToAddModList->head;

    for (count = 0; count < p_SRB_ToAddModList->count;
            count++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);
        p_SRB_ToAddMod = (SRB_ToAddMod*)p_node->data;

        if (1 == p_SRB_ToAddMod->srb_Identity)
        {
            p_rrm_srb_to_add_info->bitmask |=
                RRM_SRB_INFO_SRB1_CONFIG_PRESENT;

            uecc_rrm_build_rrm_srb_to_add_mod(
                    &p_rrm_srb_to_add_info->srb1_config,
                    p_SRB_ToAddMod,p_uecc_ue_context);
        }
        else if (2 == p_SRB_ToAddMod->srb_Identity)
        {
            p_rrm_srb_to_add_info->bitmask |=
                RRM_SRB_INFO_SRB2_CONFIG_PRESENT;
            uecc_rrm_build_rrm_srb_to_add_mod(
                    &p_rrm_srb_to_add_info->srb2_config,
                    p_SRB_ToAddMod,p_uecc_ue_context);
        }
        else
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "Invalid SRB ID!!!\n");
            return RRC_FAILURE;
        }

        p_node = p_node->next;
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_rrm_srb_to_add_mod
*   INPUT        : rrm_srb_config_t   *p_rrm_srb_config,
*                  SRB_ToAddMod       *p_asn1_srb_elem,
*                  uecc_ue_context_t*  p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*                Builds rrm_srb_config_t frm SRB-ToAddMod IE 
*
*   RETURNS:     RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_rrm_srb_to_add_mod(
    rrm_srb_config_t   *p_rrm_srb_config,
    SRB_ToAddMod       *p_asn1_srb_elem,
    uecc_ue_context_t*  p_uecc_ue_context
)
{
    rrc_return_et                       result = RRC_FAILURE;

    RRC_ASSERT( PNULL != p_rrm_srb_config );
    RRC_ASSERT( PNULL != p_asn1_srb_elem );

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do {
        /* srb_Identity */

        /* RLC Configuration */
        if (p_asn1_srb_elem->m.rlc_ConfigPresent && 
                (p_asn1_srb_elem->rlc_Config.t ==
                 T_SRB_ToAddMod_rlc_Config_explicitValue))
        {
            p_rrm_srb_config->bitmask |= 
                RRM_SRB_CONFIG_AM_CONFIG_PRESENT;
            p_rrm_srb_config->srb_am_config.bitmask |= 
                RRM_SRB_AM_CONFIG_EXPLICIT_PRESENT;

            if (PNULL == p_asn1_srb_elem->rlc_Config.u.explicitValue)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "NULL pointer access !!\n");
                break;
            }
            if (p_asn1_srb_elem->rlc_Config.u.explicitValue->t !=
                    T_RLC_Config_am)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "SRB 1 config in not am!!\n");
                break;
            }
            if (PNULL == p_asn1_srb_elem->rlc_Config.u.explicitValue->u.am)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_ERROR,
                        "[SRB-ToAddMod] ASN malloc failed");
                break;
            }
            /* UL */

            /* t_PollRetransmit */
            p_rrm_srb_config->srb_am_config.am_config_explicit.ul_am_rlc.  
                t_poll_retransmit=
                (U8) (p_asn1_srb_elem->rlc_Config.u.explicitValue->u.am->ul_AM_RLC. 
                t_PollRetransmit);

            /* pollPDU */
            p_rrm_srb_config->srb_am_config.am_config_explicit.ul_am_rlc.  
                poll_pdu = (U8)
                (p_asn1_srb_elem->rlc_Config.u.explicitValue->u.am->ul_AM_RLC.  
                pollPDU) ;

            /* pollByte */
            p_rrm_srb_config->srb_am_config.am_config_explicit.ul_am_rlc.  
                poll_byte = (U8)
                (p_asn1_srb_elem->rlc_Config.u.explicitValue->u.am->ul_AM_RLC.  
                pollByte) ;

            /* maxRetxThreshold */
            p_rrm_srb_config->srb_am_config.am_config_explicit.ul_am_rlc.  
                max_retx_threshold = (U8)
                (p_asn1_srb_elem->rlc_Config.u.explicitValue->u.am->ul_AM_RLC.  
                maxRetxThreshold) ;

            /* DL */

            /* t_Reordering */
            p_rrm_srb_config->srb_am_config.am_config_explicit.dl_am_rlc.  
                t_reordering = (U8)
                (p_asn1_srb_elem->rlc_Config.u.explicitValue->u.am->dl_AM_RLC.  
                t_Reordering) ;

            /* t_StatusProhibit */
            p_rrm_srb_config->srb_am_config.am_config_explicit.dl_am_rlc.  
                t_status_prohibit = (U8)
                (p_asn1_srb_elem->rlc_Config.u.explicitValue->u.am->dl_AM_RLC.  
                t_StatusProhibit) ;

        }
        else
        {
            p_rrm_srb_config->bitmask |= 
                RRM_SRB_CONFIG_AM_CONFIG_PRESENT;
        }

        if ((p_asn1_srb_elem->m.logicalChannelConfigPresent) &&
            (p_asn1_srb_elem->logicalChannelConfig.t ==
             T_SRB_ToAddMod_logicalChannelConfig_explicitValue))
            {
                if (PNULL ==
                        p_asn1_srb_elem->logicalChannelConfig.u.explicitValue)
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,
                            "[SRB-ToAddMod] logicalChannelConfig."
                            "u.explicitValue is NULL");
                    break;
                }

                if (p_asn1_srb_elem->logicalChannelConfig.u.explicitValue->m.
                        ul_SpecificParametersPresent)
                {  
                    p_rrm_srb_config->bitmask |= 
                        RRM_SRB_CONFIG_LOGICAL_CHANNEL_CONFIG_PRESENT;
                    p_rrm_srb_config->logical_channel_config.bitmask |=
                        RRM_UL_SPECIFIC_PARAMETERS_EXPLICIT_PRESENT;
                    /* priority */
                    p_rrm_srb_config->logical_channel_config.  
                        ul_specific_parameters_explicit.priority=
                        p_asn1_srb_elem->logicalChannelConfig.u.explicitValue-> 
                        ul_SpecificParameters.priority ;

                    /* prioritisedBitRate */
                    p_rrm_srb_config->logical_channel_config.  
                        ul_specific_parameters_explicit.prioritized_bit_rate=
                        (U8)(p_asn1_srb_elem->logicalChannelConfig.u.explicitValue-> 
                        ul_SpecificParameters.prioritisedBitRate) ;

                    /* bucketSizeDuration */
                    p_rrm_srb_config->logical_channel_config.  
                        ul_specific_parameters_explicit.bucket_size_duration=
                        (U8)(p_asn1_srb_elem->logicalChannelConfig.u.explicitValue-> 
                        ul_SpecificParameters.bucketSizeDuration) ;


                    if (p_asn1_srb_elem->logicalChannelConfig.u.explicitValue->
                            ul_SpecificParameters.m.logicalChannelGroupPresent)
                    {                    /* logicalChannelGroup */

                        p_rrm_srb_config->logical_channel_config.
                            ul_specific_parameters_explicit.bitmask |= 
                           RRC_UL_SPECIFIC_PARAMETERS_LOGICAL_CH_GROUP_PRESENT ;

                        p_rrm_srb_config->logical_channel_config.  
                         ul_specific_parameters_explicit.logical_channel_group=
                       p_asn1_srb_elem->logicalChannelConfig.u.explicitValue-> 
                            ul_SpecificParameters.logicalChannelGroup ;
                    }
                }
                /* lc_sr_mask_r9 */
                if (p_asn1_srb_elem->logicalChannelConfig.u.explicitValue->m.
                logicalChannelSR_Mask_r9Present)
                {
                   if (p_asn1_srb_elem->logicalChannelConfig.u.explicitValue->m.
                      ul_SpecificParametersPresent)
                   {  
                       p_rrm_srb_config->logical_channel_config.bitmask |=
                           RRM_UL_SPECIFIC_PARAMETERS_LC_SR_MASK_R9_PRESENT;

                       p_rrm_srb_config->logical_channel_config.lc_sr_mask_r9 =
                           (U8)p_asn1_srb_elem->logicalChannelConfig.u.explicitValue->
                           logicalChannelSR_Mask_r9;
                   }
                   else
                   {
                       RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "[SRB-ToAddMod] logicalChannelConfig."
                            "u.explicitValue->m.ul_SpecificParametersPresent"
                            "must be present");
                       break;
                   }
                }              
            }

        result = RRC_SUCCESS;

    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_drb_to_add_mod_list
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context,
*                  rrm_drb_to_add_info_list_t * p_rrm_drb_to_add_info_list,
*                  DRB_ToAddModList * p_DRB_ToAddModList
*   OUTPUT       : none
*   DESCRIPTION:    This function fills 'DRB_ToAddModList' from information
*                   of 'rrm_drb_to_add_info_list_t'
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_drb_to_add_mod_list(
        uecc_ue_context_t* p_uecc_ue_context,
        rrm_drb_to_add_info_list_t * p_rrm_drb_to_add_info_list,
        DRB_ToAddModList * p_DRB_ToAddModList
)
{
    DRB_ToAddMod                    *p_asn1_drb_elem = PNULL;
    OSRTDListNode                   *p_node = PNULL;
    U8                              drb_idx = RRC_NULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrm_drb_to_add_info_list);
    RRC_ASSERT(PNULL != p_DRB_ToAddModList);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_rrm_drb_to_add_info_list->drb_count = (U8)p_DRB_ToAddModList->count;
    p_node = p_DRB_ToAddModList->head;
    
    for (drb_idx=0; drb_idx < p_rrm_drb_to_add_info_list->drb_count; drb_idx++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        p_asn1_drb_elem = p_node->data;
        if (RRC_SUCCESS !=
            uecc_rrm_build_drb_to_add_mod(
                    &p_rrm_drb_to_add_info_list->drb_config[drb_idx],
                    p_asn1_drb_elem,
                    p_uecc_ue_context))
        {
            RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        p_node = p_node->next;
    }
    if ( (PNULL != p_uecc_ue_context->ho_info.p_ho_info) &&
            (PNULL != p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info) )
    {
        l3_memcpy_wrapper (&(p_uecc_ue_context->ho_info.p_ho_info->
                       p_trg_ho_info->drb_info_recv_from_src), 
                    p_rrm_drb_to_add_info_list,  sizeof(rrm_drb_to_add_info_list_t));
    }               

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return RRC_SUCCESS;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_drb_to_add_mod
*   INPUT        : rrm_drb_config_t *p_rrm_drb_config,
*                  DRB_ToAddMod      *p_asn1_drb_elem,
*                  uecc_ue_context_t* p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:    This function fills 'DRB_ToAddMod' from information
*                   of 'rrm_drb_config_t'
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_drb_to_add_mod(
    rrm_drb_config_t *p_rrm_drb_config,
    DRB_ToAddMod      *p_asn1_drb_elem,
    uecc_ue_context_t* p_uecc_ue_context
)
{
    PDCP_Config* p_pdcp_conf = PNULL;
    RLC_Config* p_rlc_conf = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    if (p_asn1_drb_elem->m.eps_BearerIdentityPresent)
    {
        p_rrm_drb_config->bitmask |=
            RRM_DRB_CONFIG_BEARED_ID_PRESENT;

        /* eps_BearerIdentity */
        p_rrm_drb_config->erab_id=
            p_asn1_drb_elem->eps_BearerIdentity ;
        /*SPR 15086 Fix Start */
        if (PNULL != p_uecc_ue_context->p_e_rab_list[p_rrm_drb_config->erab_id])
        {
            p_uecc_ue_context->p_e_rab_list[p_rrm_drb_config->erab_id]->drb_config.
                  drb_id = p_asn1_drb_elem->drb_Identity;
        } 
        /*SPR 15086 Fix Stop */
    }

    /* drb_Identity */
    p_rrm_drb_config->drb_id=
        p_asn1_drb_elem->drb_Identity ;

    /* PDCP config */
    if (p_asn1_drb_elem->m.pdcp_ConfigPresent)
    {
        p_rrm_drb_config->bitmask |=
            RRM_DRB_CONFIG_PDCP_CONFIG_PRESENT;

        p_pdcp_conf = &p_asn1_drb_elem->pdcp_Config;

        if (p_pdcp_conf->m.discardTimerPresent)
        {
            p_rrm_drb_config->pdcp_config.bitmask |=
                RRC_PDCP_CONFIG_DISCARD_TIMER_PRESENT;

            /* discardTimer */
            p_rrm_drb_config->pdcp_config.discard_timer=
                (U8)p_pdcp_conf->discardTimer;
        }

        /* rlc_AM */
        if (p_pdcp_conf->m.rlc_AMPresent)
        {
            p_rrm_drb_config->pdcp_config.bitmask |=
                RRC_PDCP_CONFIG_RLC_AM_STATUS_REPORT_REQ_PRESENT;

            /* statusReportRequired */
            p_rrm_drb_config->pdcp_config.rlc_am_status_report_required=
                p_pdcp_conf->rlc_AM.statusReportRequired ;
        }

        if (p_pdcp_conf->m.rlc_UMPresent)
        {
            p_rrm_drb_config->pdcp_config.bitmask |= 
                RRC_PDCP_CONFIG_RLC_UM_PDCP_SN_SIZE_PRESENT;

            /* pdcp_SN_Size */
            p_rrm_drb_config->pdcp_config.rlc_um_pdcp_sn_size=
                (U8)p_pdcp_conf->rlc_UM.pdcp_SN_Size ;
        }

        if (p_pdcp_conf->headerCompression.t ==
                T_PDCP_Config_headerCompression_rohc)
        {
            p_rrm_drb_config->pdcp_config.header_compression.bitmask |= 
                RRC_PDCP_HEADER_COMPRESSION_ROHC_CONFIG_PRESENT;
            /* ROHC enabled */

            if (PNULL == p_asn1_drb_elem->pdcp_Config.headerCompression.u.rohc)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "generate_drb_to_add_mod: ASN malloc failed");
                RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                return RRC_FAILURE;
            }

            /* maxCID */
            p_rrm_drb_config->pdcp_config.header_compression.
                rohc_config.max_cid=
                p_pdcp_conf->headerCompression.u.rohc->maxCID ;

            /* profiles */
            p_rrm_drb_config->pdcp_config.header_compression.
                rohc_config.  rohc_profile.profile0x0001=
                p_pdcp_conf->headerCompression.u.rohc->profiles.
                profile0x0001 ;
            p_rrm_drb_config->pdcp_config.header_compression.rohc_config.
                rohc_profile.profile0x0002=
                p_pdcp_conf->headerCompression.u.rohc->profiles.
                profile0x0002 ;
            p_rrm_drb_config->pdcp_config.header_compression.rohc_config.  
                rohc_profile.profile0x0003=
                p_pdcp_conf->headerCompression.u.rohc->profiles.
                profile0x0003 ;
            p_rrm_drb_config->pdcp_config.header_compression.rohc_config.  
                rohc_profile.profile0x0004=
                p_pdcp_conf->headerCompression.u.rohc->profiles.
                profile0x0004 ;
            p_rrm_drb_config->pdcp_config.header_compression.rohc_config.  
                rohc_profile.profile0x0006=
                p_pdcp_conf->headerCompression.u.rohc->profiles.
                profile0x0006 ;
            p_rrm_drb_config->pdcp_config.header_compression.rohc_config.  
                rohc_profile.profile0x0101=
                p_pdcp_conf->headerCompression.u.rohc->profiles.
                profile0x0101 ;
            p_rrm_drb_config->pdcp_config.header_compression.rohc_config.  
                rohc_profile.profile0x0102=
                p_pdcp_conf->headerCompression.u.rohc->profiles.profile0x0102 ;
            p_rrm_drb_config->pdcp_config.header_compression.rohc_config.  
                rohc_profile.profile0x0103=
                p_pdcp_conf->headerCompression.u.rohc->profiles.profile0x0103 ;
            p_rrm_drb_config->pdcp_config.header_compression.rohc_config.  
                rohc_profile.profile0x0104=
                p_pdcp_conf->headerCompression.u.rohc->profiles.
                profile0x0104 ;
        }
    }

    if (p_asn1_drb_elem->m.rlc_ConfigPresent)
    {
        p_rrm_drb_config->bitmask |= 
            RRM_DRB_CONFIG_RLC_CONFIG_UE_PRESENT;

        p_rlc_conf = &p_asn1_drb_elem->rlc_Config;

        switch( p_rlc_conf->t)
        {
            case T_RLC_Config_am:
            /* AM Mode RLC*/
            p_rrm_drb_config->rlc_config_ue.bitmask |= 
            RRC_RLC_CONFIG_AM_CONFIG_PRESENT;

            if (PNULL == p_rlc_conf->u.am)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "generate_drb_to_add_mod: ASN malloc failed");
                RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                return RRC_FAILURE;
            }

            /*UL*/
            /* t_PollRetransmit */
            p_rrm_drb_config->rlc_config_ue.am_config.
                ul_am_rlc.t_poll_retransmit=
                (U8)p_rlc_conf->u.am->ul_AM_RLC.t_PollRetransmit ;

            /* pollPDU */
            p_rrm_drb_config->rlc_config_ue.am_config.ul_am_rlc.poll_pdu=
                (U8)p_rlc_conf->u.am->ul_AM_RLC.pollPDU ;

            /* pollByte */
            p_rrm_drb_config->rlc_config_ue.am_config.ul_am_rlc.poll_byte=
                (U8)p_rlc_conf->u.am->ul_AM_RLC.pollByte ;

            /* maxRetxThreshold */
            p_rrm_drb_config->rlc_config_ue.am_config.
                ul_am_rlc.max_retx_threshold=
                (U8)p_rlc_conf->u.am->ul_AM_RLC.maxRetxThreshold ;


            /* DL */

            /* t_Reordering */
            p_rrm_drb_config->rlc_config_ue.am_config.dl_am_rlc.t_reordering=
                (U8)p_rlc_conf->u.am->dl_AM_RLC.t_Reordering ;

            /* t_StatusProhibit */
            p_rrm_drb_config->rlc_config_ue.am_config.
                dl_am_rlc.t_status_prohibit=
                (U8)p_rlc_conf->u.am->dl_AM_RLC.t_StatusProhibit ;

            break;

        case T_RLC_Config_um_Bi_Directional:
            /* Bi-Directional */
            p_rrm_drb_config->rlc_config_ue.bitmask |= 
            RRC_RLC_CONFIG_UM_BI_DIRECTIONAL_CONFIG_PRESENT;

            if (PNULL == p_rlc_conf->u.um_Bi_Directional)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "generate_drb_to_add_mod: ASN malloc failed");
                RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                return RRC_FAILURE;
            }

            /* UL */

            /* sn_FieldLength */
            p_rrm_drb_config->rlc_config_ue.
                um_bi_directional_config.ul_um_rlc.sn_field_length=
                (U8)p_rlc_conf->u.um_Bi_Directional->ul_UM_RLC.sn_FieldLength ;

            /* DL */

            /* sn_FieldLength */
            p_rrm_drb_config->rlc_config_ue.
                um_bi_directional_config.dl_um_rlc.sn_field_length=
                (U8)p_rlc_conf->u.um_Bi_Directional->dl_UM_RLC.sn_FieldLength ;

            /* t_Reordering */
            p_rrm_drb_config->rlc_config_ue.um_bi_directional_config.
                dl_um_rlc.t_reordering=
                (U8)p_rlc_conf->u.um_Bi_Directional->dl_UM_RLC.t_Reordering ;

            break;

        case T_RLC_Config_um_Uni_Directional_UL:
            /* Uni Directional Upload */
            p_rrm_drb_config->rlc_config_ue.bitmask |= 
            RRC_RLC_CONFIG_UM_UNI_DIRECTIONAL_CONFIG_UL_PRESENT;

            if (PNULL == p_rlc_conf->u.um_Uni_Directional_UL)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "generate_drb_to_add_mod: ASN malloc failed");
                RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                return RRC_FAILURE;
            }

            /* sn_FieldLength */
            p_rrm_drb_config->rlc_config_ue.um_uni_directional_ul_config.
                ul_um_rlc.sn_field_length=
                (U8)p_rlc_conf->u.um_Uni_Directional_UL->ul_UM_RLC.sn_FieldLength ;

            break;

        case T_RLC_Config_um_Uni_Directional_DL:
            /* Uni Directional Download */
            p_rrm_drb_config->rlc_config_ue.bitmask |= 
            RRC_RLC_CONFIG_UM_UNI_DIRECTIONAL_CONFIG_DL_PRESENT;

            if (PNULL == p_rlc_conf->u.um_Uni_Directional_DL)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "generate_drb_to_add_mod: ASN malloc failed");
                RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                return RRC_FAILURE;
            }

            /* sn_FieldLength */
            p_rrm_drb_config->rlc_config_ue.um_uni_directional_dl_config.
                dl_um_rlc.sn_field_length=
                (U8)p_rlc_conf->u.um_Uni_Directional_DL->dl_UM_RLC.sn_FieldLength ;

            /* t_Reordering */
            p_rrm_drb_config->rlc_config_ue.um_uni_directional_dl_config.
                dl_um_rlc.t_reordering=
                (U8)p_rlc_conf->u.um_Uni_Directional_DL->dl_UM_RLC.t_Reordering ;

            break;

        default:
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_ERROR,
                "generate_drb_to_add_mod: wrong bitmask=%i",
                p_rrm_drb_config->rlc_config_ue.bitmask);
            RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }

    if (p_asn1_drb_elem->m.logicalChannelIdentityPresent)
    {
        p_rrm_drb_config->bitmask |= 
            RRM_DRB_CONFIG_LOGICAL_CHANNEL_IDENTITY_PRESENT;

        /* logicalChannelIdentity */
        p_rrm_drb_config->logical_channel_identity=
            p_asn1_drb_elem->logicalChannelIdentity ;
    }

    if (p_asn1_drb_elem->m.logicalChannelConfigPresent &&
            p_asn1_drb_elem->logicalChannelConfig.m.
            ul_SpecificParametersPresent)
    {
        p_rrm_drb_config->bitmask |=
            RRM_DRB_CONFIG_LOGICAL_CHANNEL_CONFIG_PRESENT;
        p_rrm_drb_config->logical_channel_config.bitmask |=
            RRM_UL_SPECIFIC_PARAMETERS_EXPLICIT_PRESENT;

        if (p_asn1_drb_elem->logicalChannelConfig.ul_SpecificParameters.m.
                logicalChannelGroupPresent)
        {
            p_rrm_drb_config->logical_channel_config.
            ul_specific_parameters_explicit.bitmask |=
                RRC_UL_SPECIFIC_PARAMETERS_LOGICAL_CH_GROUP_PRESENT;

            /* logicalChannelGroup */
            p_rrm_drb_config->logical_channel_config.
            ul_specific_parameters_explicit.logical_channel_group=
                p_asn1_drb_elem->logicalChannelConfig.
                ul_SpecificParameters.logicalChannelGroup ;
        }

        /* priority */
        p_rrm_drb_config->logical_channel_config.
        ul_specific_parameters_explicit.priority=
            p_asn1_drb_elem->logicalChannelConfig.ul_SpecificParameters.
            priority ;

        /* prioritisedBitRate */
        p_rrm_drb_config->logical_channel_config.
        ul_specific_parameters_explicit.prioritized_bit_rate=
            (U8)(p_asn1_drb_elem->logicalChannelConfig.
            ul_SpecificParameters.prioritisedBitRate) ;

        /* bucketSizeDuration */
        p_rrm_drb_config->logical_channel_config.
        ul_specific_parameters_explicit.bucket_size_duration=
            (U8)p_asn1_drb_elem->logicalChannelConfig.ul_SpecificParameters. 
            bucketSizeDuration ;

    }
    /* lc_sr_mask_r9 */
    if (p_asn1_drb_elem->logicalChannelConfig.m.logicalChannelSR_Mask_r9Present)
    {
        if (p_asn1_drb_elem->logicalChannelConfig.ul_SpecificParameters.m.
           logicalChannelGroupPresent)
        {
            p_rrm_drb_config->logical_channel_config.bitmask |=
                 RRM_UL_SPECIFIC_PARAMETERS_LC_SR_MASK_R9_PRESENT;
            p_rrm_drb_config->logical_channel_config.lc_sr_mask_r9 =
                (U8)p_asn1_drb_elem->logicalChannelConfig.logicalChannelSR_Mask_r9;
       }
       else
       {
          RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                  (p_uecc_ue_context->p_gb_context)->facility_name,
                  RRC_ERROR,
              "[DRB Config] logicalChannelConfig."
              "u.explicitValue->m.ul_SpecificParametersPresent"
              "must be present");
          /* should it return RRC_FAILURE form here  */; 
       }
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_mac_main_config
*   INPUT        : uecc_ue_context_t                  *p_uecc_ue_context,
*                  rrc_mac_main_config_t *        p_mac_main_config,
*                  RadioResourceConfigDedicated_mac_MainConfig     *p_asn1_mac
*   OUTPUT       : none
*   DESCRIPTION:
*                Builds rrm_mac_config_t from ASN1 MAC-MainConfig 
*
*   RETURNS:     RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_mac_main_config(
        uecc_ue_context_t                  *p_uecc_ue_context,
    rrc_mac_main_config_t *        p_mac_main_config,
        RadioResourceConfigDedicated_mac_MainConfig     *p_asn1_mac
)
{
    rrc_return_et                       result = RRC_FAILURE;

    RRC_ASSERT( PNULL != p_uecc_ue_context );
    RRC_ASSERT( PNULL != p_mac_main_config );
    RRC_ASSERT( PNULL != p_asn1_mac );

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do {

        if ( p_asn1_mac->t ==
                T_RadioResourceConfigDedicated_mac_MainConfig_defaultValue)
        {
            /* Apply default values and exit */
            result = RRC_SUCCESS;
            break;
        }
        else
        {
            if (PNULL == p_asn1_mac->u.explicitValue)
            {
                break;
            }

            /* ul-SCH-Config */
            if (p_asn1_mac->u.explicitValue->m.ul_SCH_ConfigPresent)
            {
                p_mac_main_config->bitmask |=
                    RRC_MAC_MAIN_CONFIG_UL_SCH_CONFIG_PRESENT;

                /* Max HARQ Transmissions */
                if (p_asn1_mac->u.explicitValue->ul_SCH_Config.m.
                        maxHARQ_TxPresent)
                {
                    p_mac_main_config->ul_sch_config.bitmask |= 
                        RRC_UL_SCH_CONFIG_MAX_HARQ_TX_PRESENT;

                    p_mac_main_config->ul_sch_config.max_harq_tx=
                        (U8)p_asn1_mac->u.explicitValue->ul_SCH_Config.maxHARQ_Tx ;
                }

                /* periodicBSR_Timer */
                if (p_asn1_mac->u.explicitValue->ul_SCH_Config.m.
                        periodicBSR_TimerPresent)
                {
                    p_mac_main_config->ul_sch_config.bitmask |= 
                        RRC_UL_SCH_CONFIG_PERIODIC_BSR_TIMER_PRESENT;

                    p_mac_main_config->ul_sch_config.periodic_bsr_timer=
                        (U8) (p_asn1_mac->u.explicitValue->ul_SCH_Config.
                        periodicBSR_Timer) ;
                }

                /* retxBSR_Timer */
                p_mac_main_config->ul_sch_config.retx_bsr_timer=
                    (U8)p_asn1_mac->u.explicitValue->ul_SCH_Config.retxBSR_Timer ;

                /* ttiBundling */
                p_mac_main_config->ul_sch_config.tti_bundling=
                    p_asn1_mac->u.explicitValue->ul_SCH_Config.ttiBundling ;
            }

            /* DRX_Config */
            if (p_asn1_mac->u.explicitValue->m.drx_ConfigPresent)
            {
                p_mac_main_config->bitmask |= 
                    RRC_MAC_MAIN_CONFIG_DRX_CONFIG_PRESENT;

                if (p_asn1_mac->u.explicitValue->drx_Config.t ==
                        T_DRX_Config_setup)
                {
                    p_mac_main_config->drx_config.bitmask |=
                        RRC_DRX_CONFIG_PARAM_PRESENT;

                    if (PNULL == p_asn1_mac->u.explicitValue->
                            drx_Config.u.setup)
                    {
                        break;
                    }
                    /*SPR Fixed during IntraRAT HO Integration:
                     * drx_config_type: 0 - for release, 1 - for setup */
                    p_mac_main_config->drx_config.drx_config_type |= 1;
                    /* onDurationTimer */
                    p_mac_main_config->drx_config.drx_config_param.  
                        on_duration_timer=
                        (U8)p_asn1_mac->u.explicitValue->drx_Config.u.setup-> 
                        onDurationTimer ;

                    /* drx_InactivityTime */
                    p_mac_main_config->drx_config.drx_config_param.  
                        drx_inactivity_timer=
                        (U8)p_asn1_mac->u.explicitValue->drx_Config.u.setup-> 
                        drx_InactivityTimer ;

                    /* drx_RetransmissionTimer */
                    p_mac_main_config->drx_config.drx_config_param.  
                        drx_retransmission_timer=
                        (U8)p_asn1_mac->u.explicitValue->drx_Config.u.setup-> 
                        drx_RetransmissionTimer ;

                    /* LongDRX_CycleStartOffset */
                    fill_macConfig_longDrxCycle_startOffset(p_uecc_ue_context,
                        &p_mac_main_config->drx_config.drx_config_param.
                            long_drx_cycle_start_offset,
                        &p_asn1_mac->u.explicitValue->drx_Config.u.
                            setup->longDRX_CycleStartOffset);

                    /* short DRX */
                    if (p_asn1_mac->u.explicitValue->drx_Config.u.setup->m.
                            shortDRXPresent)
                    {
                        p_mac_main_config->drx_config.
                            drx_config_param.bitmask |= 
                            RRC_DRX_CONFIG_SHORT_DRX_PRESENT;

                        p_mac_main_config->drx_config.drx_config_param.  
                            short_drx.short_drx_cycle=
                            (U8)p_asn1_mac->u.explicitValue->drx_Config.u.
                            setup->shortDRX.shortDRX_Cycle ;

                        p_mac_main_config->drx_config.drx_config_param.  
                            short_drx.short_drx_cycle_timer=
                            p_asn1_mac->u.explicitValue->drx_Config.u.
                            setup->shortDRX.drxShortCycleTimer ;
                    }
                }
                /* timeAlignmentTimerDedicated */
                p_mac_main_config->time_alignment_timer_dedicated=
                    (U8)p_asn1_mac->u.explicitValue->timeAlignmentTimerDedicated ;

                /* MAC_MainConfig_phr_Config */
                if (p_asn1_mac->u.explicitValue->m.phr_ConfigPresent)
                {
                    p_mac_main_config->bitmask |=
                        RRC_MAC_MAIN_CONFIG_PHR_CONFIG_PRESENT;

                    if (p_asn1_mac->u.explicitValue->phr_Config.t ==
                            T_MAC_MainConfig_phr_Config_setup)
                    {
                        p_mac_main_config->phr_config.bitmask |=
                            RRC_PHR_CONFIG_PARAM_PRESENT;

                        if (PNULL == 
                                p_asn1_mac->u.explicitValue->phr_Config.u.setup)
                        {
                            break;
                        }

                        /* Periodic PHR Timer */
                        p_mac_main_config->phr_config.phr_config_param.  
                            periodic_phr_timer=
                            (U8)p_asn1_mac->u.explicitValue->phr_Config.u.
                            setup->periodicPHR_Timer ;

                        /* Prohibit PHR Timer */
                        p_mac_main_config->phr_config.phr_config_param.  
                            prohibit_phr_timer=
                            (U8)(p_asn1_mac->u.explicitValue->phr_Config.u.
                            setup->prohibitPHR_Timer)  ;

                        /* DL pathloss change */
                        p_mac_main_config->phr_config.phr_config_param.  
                            dl_pathloss_change=
                            (U8)(p_asn1_mac->u.explicitValue->phr_Config.u.
                            setup->dl_PathlossChange) ;
                    }
                }
                /* cr_311 check CR number for sr_ProhibitTimer_r9 */
                if (p_asn1_mac->u.explicitValue->m.sr_ProhibitTimer_r9Present)  
                {
                     p_mac_main_config->bitmask |=
                        RRC_MAC_MAIN_CONFIG_SR_PROHIBIT_TIMER_R9_PRESENT;

                     p_mac_main_config->sr_prohibit_timer_r9 =
                     p_asn1_mac->u.explicitValue->sr_ProhibitTimer_r9;
                }
            }

            if ((p_asn1_mac->u.explicitValue->m._v3ExtPresent == 1) &&
                (p_asn1_mac->u.explicitValue->m.mac_MainConfig_v1020Present == 1))
            {
                p_mac_main_config->bitmask |= RRC_MAC_MAIN_CONFIG_V1020_PRESENT;
                
                if (p_asn1_mac->u.explicitValue->mac_MainConfig_v1020.m.
                        sCellDeactivationTimer_r10Present)
                {
                    p_mac_main_config->mac_main_config_v1020.bitmask |=
                        RRC_MAC_MAIN_CONFIG_V1020_SCELL_DEACTIVATION_TIMER_PRESENT;

                    p_mac_main_config->mac_main_config_v1020.scell_deactivation_timer = 
                        (U8)p_asn1_mac->u.explicitValue->mac_MainConfig_v1020.
                            sCellDeactivationTimer_r10;
                }
                if (p_asn1_mac->u.explicitValue->mac_MainConfig_v1020.m.
                        extendedBSR_Sizes_r10Present)
                {
                    p_mac_main_config->mac_main_config_v1020.bitmask |=
                        RRC_MAC_MAIN_CONFIG_V1020_EXTENDED_BSR_SIZES_PRESENT;

                    p_mac_main_config->mac_main_config_v1020.extended_bsr_sizes = 
                        (U8)p_asn1_mac->u.explicitValue->mac_MainConfig_v1020.
                        extendedBSR_Sizes_r10;
                }
                if (p_asn1_mac->u.explicitValue->mac_MainConfig_v1020.m.
                        extendedPHR_r10Present)
                {
                    p_mac_main_config->mac_main_config_v1020.bitmask |=
                        RRC_MAC_MAIN_CONFIG_V1020_EXTENDED_PHR_PRESENT;

                    p_mac_main_config->mac_main_config_v1020.extended_phr = 
                        (U8)p_asn1_mac->u.explicitValue->mac_MainConfig_v1020.
                        extendedPHR_r10;
                }
            }
            result = RRC_SUCCESS;
        }
    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_asn1_sps_config
*   INPUT        : uecc_ue_context_t   *p_uecc_ue_context,
*                  rrc_sps_config_t *p_rrm_sps_config,
*                  SPS_Config          *p_asn1_sps
*   OUTPUT       : none
*   DESCRIPTION:
*                Builds rrc_sps_config_t from ASN1 SPS_Config IE
*
*   RETURNS:     RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_asn1_sps_config(
    uecc_ue_context_t   *p_uecc_ue_context,
    rrc_sps_config_t *p_rrm_sps_config,
    SPS_Config          *p_asn1_sps
)
{
    rrc_return_et          result = RRC_FAILURE;


    RRC_ASSERT( PNULL != p_uecc_ue_context );
    RRC_ASSERT( PNULL != p_rrm_sps_config );
    RRC_ASSERT( PNULL != p_asn1_sps );
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {
        /* CRNTI */
        if (p_asn1_sps->m.semiPersistSchedC_RNTIPresent)
        {
            p_rrm_sps_config->bitmask |=
                RRC_SPS_CONFIG_C_RNTI_PRESENT;

            l3_memcpy_wrapper( p_rrm_sps_config->semi_presist_sched_c_rnti,
                    p_asn1_sps->semiPersistSchedC_RNTI.data,
                    sizeof(p_rrm_sps_config->semi_presist_sched_c_rnti));
        }

        /* SPS DL CONFIGURATION */
        if (p_asn1_sps->m.sps_ConfigDLPresent)
        {
            p_rrm_sps_config->bitmask |= 
                RRC_SPS_CONFIG_SPS_CONFIG_DL_PRESENT;

            if (p_asn1_sps->sps_ConfigDL.t == T_SPS_ConfigDL_setup)
            {
                p_rrm_sps_config->sps_config_dl.bitmask |=
                    RRC_SPS_CONFIG_DL_PARAM_PRESENT;

                if (PNULL == p_asn1_sps->sps_ConfigDL.u.setup)
                {
                    break;
                }
                /* SPR 20747 Fix Start */
                if ((PNULL != p_uecc_ue_context->ho_info.p_ho_info) &&
                     (PNULL != p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info))
                {
                    p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->is_sps_recv_from_src 
                                                              |= SRC_SPS_CONFIG_DL_PRESENT;
                }
                /* SPR 20747 Fix Stop */
                /* semiPersistSchedIntervalDL */
                p_rrm_sps_config->sps_config_dl.sps_config_dl_param.  
                    semi_persist_sched_interval_dl=
                    (U8)p_asn1_sps->sps_ConfigDL.u.setup->
                    semiPersistSchedIntervalDL ;

                /* numberOfConfSPS_Processes */
                p_rrm_sps_config->sps_config_dl.sps_config_dl_param.  
                    number_of_conf_sps_processes=
                    p_asn1_sps->sps_ConfigDL.u.setup->
                    numberOfConfSPS_Processes ;

                /* n1_PUCCH_AN_PersistentList */
                if (p_asn1_sps->sps_ConfigDL.u.setup->
                        n1PUCCH_AN_PersistentList.n >
                        MAX_N1_PUCCH_AN_PERSIST_SIZE)
                {
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "Wrong n1_pucch_an_persist_list.count value: %i",
                            p_rrm_sps_config->sps_config_dl.sps_config_dl_param.
                            n1_pucch_an_persist_list.count);

                    break;
                }

                p_rrm_sps_config->sps_config_dl.sps_config_dl_param.  
                    n1_pucch_an_persist_list.count=
                    (U8)p_asn1_sps->sps_ConfigDL.u.setup->
                    n1PUCCH_AN_PersistentList.n ;

                l3_memcpy_wrapper(
                        p_rrm_sps_config->sps_config_dl.sps_config_dl_param.
                        n1_pucch_an_persist_list.n1_pucch_an_persist,
                        p_asn1_sps->sps_ConfigDL.u.setup-> 
                        n1PUCCH_AN_PersistentList.elem,
                        sizeof(p_asn1_sps->sps_ConfigDL.u.setup->
                            n1PUCCH_AN_PersistentList.elem));


            }
        }

        /* SPS UL Configuration */
        if (p_asn1_sps->m.sps_ConfigULPresent)
        {
            p_rrm_sps_config->bitmask |=
                RRC_SPS_CONFIG_SPS_CONFIG_UL_PRESENT;

            if (p_asn1_sps->sps_ConfigUL.t == T_SPS_ConfigUL_setup)
            {
                p_rrm_sps_config->sps_config_ul.bitmask |=
                    RRC_SPS_CONFIG_UL_PARAM_PRESENT;

                if (PNULL == p_asn1_sps->sps_ConfigUL.u.setup)
                {
                    break;
                }

                /* SPR 20747 Fix Start */
                if ((PNULL != p_uecc_ue_context->ho_info.p_ho_info) &&
                     (PNULL != p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info))
                {
                    p_uecc_ue_context->ho_info.p_ho_info->p_trg_ho_info->is_sps_recv_from_src 
                                                              |= SRC_SPS_CONFIG_UL_PRESENT;
                }
                /* SPR 20747 Fix Stop */
                /* semiPersistSchedIntervalUL */
                p_rrm_sps_config->sps_config_ul.sps_config_ul_param.  
                    semi_persist_sched_interval_ul=
                    (U8)p_asn1_sps->sps_ConfigUL.u.setup->
                    semiPersistSchedIntervalUL ;

                /* IimplicitReleaseAfter */
                p_rrm_sps_config->sps_config_ul.sps_config_ul_param.  
                    implicit_release_after=
                    (U8)p_asn1_sps->sps_ConfigUL.u.setup->implicitReleaseAfter ;

                /* p0_Persistent */
                if (p_asn1_sps->sps_ConfigUL.u.setup->m.p0_PersistentPresent)
                {
                    p_rrm_sps_config->sps_config_ul.sps_config_ul_param.
                        bitmask |=
                        RRC_SPS_CONFIG_UL_P_0_PERSISTENT_PRESENT;

                    /* p0_NominalPUSCH_Persistent */
                    p_rrm_sps_config->sps_config_ul.sps_config_ul_param.  
                        p_zero_persistent.p_zero_nominal_pusch_persistent=
                        p_asn1_sps->sps_ConfigUL.u.setup->
                        p0_Persistent.p0_NominalPUSCH_Persistent ;

                    /* p_zero_ue_pusch_persistent */
                    p_rrm_sps_config->sps_config_ul.sps_config_ul_param.  
                        p_zero_persistent.p_zero_ue_pusch_persistent=
                        p_asn1_sps->sps_ConfigUL.u.setup->
                        p0_Persistent.p0_UE_PUSCH_Persistent ;
                }

                /* twoIntervalsConfig */
                if (p_asn1_sps->sps_ConfigUL.u.setup->m.
                        twoIntervalsConfigPresent)
                {
                    p_rrm_sps_config->sps_config_ul.
                        sps_config_ul_param.bitmask |= 
                        RRC_SPS_CONFIG_UL_TWO_INTERVALS_CONFIG_PRESENT;
                }
            }

        }

        result = RRC_SUCCESS;

    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;
}


/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_rrm_physical_config_dedicated
*   INPUT        : uecc_ue_context_t                       *p_uecc_ue_context,
*                  rrc_phy_physical_config_dedicated_t *p_rrm_physical_config_dedicated,
*                  PhysicalConfigDedicated                 *p_asn1_phy
*   OUTPUT       : none
*   DESCRIPTION:
*                Builds rrc_phy_physical_config_dedicated_t from
                 ASN1 PhysicalConfigDedicated IE.
*
*   RETURNS:     RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_rrm_physical_config_dedicated(
    uecc_ue_context_t                       *p_uecc_ue_context,
    rrc_phy_physical_config_dedicated_t *p_rrm_physical_config_dedicated,
    PhysicalConfigDedicated                 *p_asn1_phy
)
{
    rrc_return_et                                 result = RRC_FAILURE;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrm_physical_config_dedicated);
    RRC_ASSERT(PNULL != p_asn1_phy);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do
    {
        if (RRC_FAILURE == fill_rrm_physical_config_parameter(
                            p_uecc_ue_context, p_asn1_phy,
                            p_rrm_physical_config_dedicated))
        {
            break;
        }

        /* CQI Reporting */
        if (p_asn1_phy->m.cqi_ReportConfigPresent)
        {
            p_rrm_physical_config_dedicated->bitmask 
                |= RRC_PHY_CQI_REPORTING_PRESENT;

            if (p_asn1_phy->cqi_ReportConfig.m.cqi_ReportModeAperiodicPresent)
            {
                p_rrm_physical_config_dedicated->cqi_reporting.bitmask |= 
                    RRC_PHY_CQI_REPORTING_MODE_APERIODIC_PRESENT;

                /* cqi_ReportModeAperiodic */
                p_rrm_physical_config_dedicated->cqi_reporting.
                    cqi_reporting_mode_aperiodic=
                    (U8)p_asn1_phy->cqi_ReportConfig.cqi_ReportModeAperiodic ;
            }

            /* nomPDSCH_RS_EPRE_Offset */
            p_rrm_physical_config_dedicated->cqi_reporting.
                nom_pdsch_rs_epre_offset=
                p_asn1_phy->cqi_ReportConfig.nomPDSCH_RS_EPRE_Offset ;

            /* cqi_ReportingPeriodic */
            if (p_asn1_phy->cqi_ReportConfig.m.cqi_ReportPeriodicPresent)
            {
                p_rrm_physical_config_dedicated->cqi_reporting.bitmask |=
                    RRC_PHY_CQI_REPORTING_PERIODIC_PRESENT;

                if (p_asn1_phy->cqi_ReportConfig.cqi_ReportPeriodic.t ==
                        T_CQI_ReportPeriodic_setup)
                {
                    p_rrm_physical_config_dedicated->
                        cqi_reporting.cqi_reporting_periodic.bitmask |=
                        RRC_PHY_CQI_REPORTING_PERIODIC_PARAM_PRESENT;

                    if (PNULL ==
                            p_asn1_phy->cqi_ReportConfig.
                            cqi_ReportPeriodic.u.setup)
                    {
                        break;
                    }

                    /* cqi_PUCCH_ResourceIndex */
                    p_rrm_physical_config_dedicated->
                        cqi_reporting.cqi_reporting_periodic.
                        cqi_reporting_periodic_param.cqi_pucch_resource_index=
                        p_asn1_phy->cqi_ReportConfig.
                        cqi_ReportPeriodic.u.setup-> cqi_PUCCH_ResourceIndex ;

                    /* cqi_pmi_config_index*/
                    p_rrm_physical_config_dedicated->
                        cqi_reporting.cqi_reporting_periodic.  
                        cqi_reporting_periodic_param.cqi_pmi_config_index=
                        p_asn1_phy->cqi_ReportConfig.
                        cqi_ReportPeriodic.u.setup-> cqi_pmi_ConfigIndex ;

                    /* CQI Format Indicator */
                    if (p_asn1_phy->cqi_ReportConfig.cqi_ReportPeriodic.u.
                            setup->cqi_FormatIndicatorPeriodic.t ==
             T_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI)
                    {
                        p_rrm_physical_config_dedicated->
                            cqi_reporting.cqi_reporting_periodic.
                            cqi_reporting_periodic_param.
                            cqi_format_indicator_periodic.
                            bitmask |= RRC_PHY_SUBBAND_CQI_PARAM_PRESENT;
                        /* subbandCQI Format Indicator */

                        if (PNULL == p_asn1_phy->cqi_ReportConfig.
                                cqi_ReportPeriodic.u.setup->
                                cqi_FormatIndicatorPeriodic.u.subbandCQI)
                        {
                            break;
                        }

                        /* k */
                        p_rrm_physical_config_dedicated->
                            cqi_reporting.cqi_reporting_periodic.  
                            cqi_reporting_periodic_param.  
                            cqi_format_indicator_periodic.subband_cqi_param.k=
                            p_asn1_phy->cqi_ReportConfig.
                            cqi_ReportPeriodic.u.setup-> 
                            cqi_FormatIndicatorPeriodic.u.subbandCQI->k ;
                    }

                    /* ri_ConfigIndex */
                    if (p_asn1_phy->cqi_ReportConfig.cqi_ReportPeriodic.u.
                            setup->m.ri_ConfigIndexPresent)
                    {
                        p_rrm_physical_config_dedicated->
                            cqi_reporting.cqi_reporting_periodic.
                            cqi_reporting_periodic_param.bitmask |=
                            RRC_PHY_CQI_RI_CONFIG_INDEX_PRESENT;

                        p_rrm_physical_config_dedicated->
                            cqi_reporting.cqi_reporting_periodic.  
                            cqi_reporting_periodic_param.ri_config_index=
                            p_asn1_phy->cqi_ReportConfig.cqi_ReportPeriodic.u.
                            setup->ri_ConfigIndex ;
                    }

                    /* simultaneousAckNackAndCQI */
                    p_rrm_physical_config_dedicated->
                        cqi_reporting.cqi_reporting_periodic.  
                        cqi_reporting_periodic_param.  
                        simultaneous_ack_nack_and_cqi=
                        p_asn1_phy->cqi_ReportConfig.
                        cqi_ReportPeriodic.u.setup-> 
                        simultaneousAckNackAndCQI ;
                }
            }
        }

        /* SoundingRsUl_ConfigDedicated */
        if (p_asn1_phy->m.soundingRS_UL_ConfigDedicatedPresent)
        {
            p_rrm_physical_config_dedicated->bitmask |=
                RRC_PHY_SOUNDING_RS_UL_CONFIG_DEDICATED_PRESENT;

            if (p_asn1_phy->soundingRS_UL_ConfigDedicated.t ==
                    T_SoundingRS_UL_ConfigDedicated_setup)
            {
                p_rrm_physical_config_dedicated->
                    sounding_rs_ul_config_dedicated.bitmask |=
                    RRC_PHY_SOUNDING_RS_UL_CONFIG_DEDICATED_PARAM_PRESENT;

                if (PNULL == p_asn1_phy->soundingRS_UL_ConfigDedicated.u.setup)
                {
                    break;
                }

                /* srs_Bandwidth */
                p_rrm_physical_config_dedicated->
                    sounding_rs_ul_config_dedicated.  
                    sounding_rs_ul_config_dedicated_param.srs_bandwidth=
                    (U8)p_asn1_phy->soundingRS_UL_ConfigDedicated
                    .u.setup-> srs_Bandwidth ;

                /* srs_HoppingBandwidth */
                p_rrm_physical_config_dedicated->
                    sounding_rs_ul_config_dedicated.  
                    sounding_rs_ul_config_dedicated_param.srs_hopping_bandwidth=
                    (U8)p_asn1_phy->soundingRS_UL_ConfigDedicated.u.setup-> 
                    srs_HoppingBandwidth ;

                /* freqDomainPosition */
                p_rrm_physical_config_dedicated->
                    sounding_rs_ul_config_dedicated.  
                    sounding_rs_ul_config_dedicated_param.  
                    frequency_domain_position=
                    p_asn1_phy->soundingRS_UL_ConfigDedicated.
                    u.setup-> freqDomainPosition ;

                /* duration */
                p_rrm_physical_config_dedicated->
                    sounding_rs_ul_config_dedicated.  
                    sounding_rs_ul_config_dedicated_param.duration=
                    p_asn1_phy->soundingRS_UL_ConfigDedicated.
                    u.setup->duration ;

                /* srs_ConfigIndex */
                p_rrm_physical_config_dedicated->
                    sounding_rs_ul_config_dedicated.  
                    sounding_rs_ul_config_dedicated_param.  
                    srs_configuration_index=
                    p_asn1_phy->soundingRS_UL_ConfigDedicated
                    .u.setup-> srs_ConfigIndex ;

                /* transmissionComb */
                p_rrm_physical_config_dedicated->
                    sounding_rs_ul_config_dedicated.  
                    sounding_rs_ul_config_dedicated_param.transmission_comb=
                    p_asn1_phy->soundingRS_UL_ConfigDedicated.
                    u.setup-> transmissionComb ;

                /* cyclicShift */
                p_rrm_physical_config_dedicated->
                    sounding_rs_ul_config_dedicated.  
                    sounding_rs_ul_config_dedicated_param.cyclic_shift=
                    (U8)p_asn1_phy->soundingRS_UL_ConfigDedicated.
                    u.setup->cyclicShift ;
            }
        }

        /* Antenna Information */
        if (p_asn1_phy->m.antennaInfoPresent)
        {
            p_rrm_physical_config_dedicated->bitmask |= 
                RRC_PHY_ANTENNA_INFORMATION_PRESENT;

            if (p_asn1_phy->antennaInfo.t ==
                    T_PhysicalConfigDedicated_antennaInfo_explicitValue)

            {
                p_rrm_physical_config_dedicated->antenna_information.bitmask |=
                    RRC_PHY_ANTENNA_INFORMATION_EXPLICIT_VALUE_PRESENT;
                if (PNULL == p_asn1_phy->antennaInfo.u.explicitValue)
                {
                    break;
                }

                /* transmissionMode */
                p_rrm_physical_config_dedicated->antenna_information.  
                    antenna_information_explicit_value.transmission_mode=
                    (U8)p_asn1_phy->antennaInfo.u.explicitValue->transmissionMode ;
                fill_phyConfigDed_antenna_explicitValue( 
                        p_uecc_ue_context,
                        &(p_rrm_physical_config_dedicated->antenna_information.
                            antenna_information_explicit_value),
                        p_asn1_phy->antennaInfo.u.explicitValue);

                p_rrm_physical_config_dedicated->antenna_information.  
                    antenna_information_explicit_value.  
                    ue_transmit_antenna_selection. 
                    request_type=
                    (U8)p_asn1_phy->antennaInfo.u.explicitValue-> 
                       ue_TransmitAntennaSelection.t - 1;

                /* UE Transmit Antenna Selection */
                    if (p_asn1_phy->antennaInfo.u.explicitValue->
                        ue_TransmitAntennaSelection.t  ==
                       T_AntennaInfoDedicated_ue_TransmitAntennaSelection_setup)
                {
                p_rrm_physical_config_dedicated->antenna_information.
                        antenna_information_explicit_value.
                        ue_transmit_antenna_selection.bitmask |=
                        RRC_PHY_UE_TRANSMIT_ANTENNA_SELECTION_TYPE_PRESENT;

                    /* enable */
                p_rrm_physical_config_dedicated->antenna_information.  
                    antenna_information_explicit_value.  
                    ue_transmit_antenna_selection. 
                    ue_transmit_antenna_selection_type=
                    (U8)p_asn1_phy->antennaInfo.u.explicitValue-> 
                       ue_TransmitAntennaSelection.u.setup ;
                }
                
            }

        }

        if (RRC_FAILURE == fill_phyConfigDed_info_sched_cqi_antennaV920(
		    p_uecc_ue_context,
                    p_asn1_phy,
                    p_rrm_physical_config_dedicated))
        {
            result =  RRC_FAILURE;
            break;
        }

        if ((p_asn1_phy->m._v3ExtPresent) &&
                (p_asn1_phy->m.antennaInfo_r10Present))
        {
            if (RRC_FAILURE == fill_phyConfigDed_antennaInfo_r10(
                        p_uecc_ue_context,
                        p_asn1_phy,
                        p_rrm_physical_config_dedicated))
            {
                RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                        p_uecc_ue_context->p_gb_context->facility_name,
                        RRC_ERROR,
                        "Fill rrc_antenna_info_r10_t failed ");
                result =  RRC_FAILURE;
                break;
            }
        }

        if ((p_asn1_phy->m._v3ExtPresent) && (p_asn1_phy->m.antennaInfoUL_r10Present))
        {
            p_rrm_physical_config_dedicated->bitmask |= 
                RRC_PHY_ANTENNA_INFO_UL_R10_PRESENT;
            
            if (p_asn1_phy->antennaInfoUL_r10.m.transmissionModeUL_r10Present)
            {
                p_rrm_physical_config_dedicated->antenna_info_ul_r10.bitmask |=
                    RRC_ANTENNA_INFO_UL_R10_TRANSMISSION_MODE_PRESENT;

                p_rrm_physical_config_dedicated->antenna_info_ul_r10.transmission_mode_ul = 
                    (U8)p_asn1_phy->antennaInfoUL_r10.transmissionModeUL_r10;
            }

            if (p_asn1_phy->antennaInfoUL_r10.m.fourAntennaPortActivated_r10Present)
            {
                p_rrm_physical_config_dedicated->antenna_info_ul_r10.bitmask |=
                    RRC_ANTENNA_INFO_UL_R10_FOUR_ANTENNA_PORT_ACTIVATED_PRESENT;

                p_rrm_physical_config_dedicated->antenna_info_ul_r10.
                    four_antenna_port_activated = (U8)p_asn1_phy->antennaInfoUL_r10.
                    fourAntennaPortActivated_r10;
            }
        }
        
        if ((p_asn1_phy->m._v3ExtPresent) && (p_asn1_phy->m.
                    cqi_ReportConfig_r10Present))
        {
            if (RRC_FAILURE == fill_phyConfigDed_CQI_ReportConfig_r10(
                        p_uecc_ue_context,
                        p_asn1_phy,
                        p_rrm_physical_config_dedicated))
            {
                RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                        p_uecc_ue_context->p_gb_context->facility_name,
                        RRC_ERROR,
                        "Failed to fill CQI_ReportConfig_r10");
                result =  RRC_FAILURE;
                break;
            }
        }

        if ((p_asn1_phy->m._v4ExtPresent) && (p_asn1_phy->m.
                        additionalSpectrumEmissionCA_r10Present))
        {
            if (RRC_FAILURE == fill_phyConfigDed_additional_spectrum_emission_ca_r10(
                        p_uecc_ue_context,
                        p_asn1_phy,
                        p_rrm_physical_config_dedicated))
            {
                RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                        p_uecc_ue_context->p_gb_context->facility_name,
                        RRC_ERROR,
                        "Failed to fill additional_spectrum_emission_ca_r10");
                result =  RRC_FAILURE;
                break;
            }
        }

        if ((p_asn1_phy->m._v3ExtPresent) && (p_asn1_phy->m.
                    pucch_ConfigDedicated_v1020Present))
        {
            if (RRC_FAILURE == fill_phyConfigDed_pucch_channel_selection_config_v1020(
                        p_uecc_ue_context,
                        p_asn1_phy,
                        p_rrm_physical_config_dedicated))
            {
                RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                        p_uecc_ue_context->p_gb_context->facility_name,
                        RRC_ERROR,
                        "Failed to fill pucch_channel_selection_config_v1020");
                result =  RRC_FAILURE;
                break;
            }
        }

        result = RRC_SUCCESS;
    } while (0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_security_algorithm_config
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context,
*                  security_algorithm_config_t        *p_rrm_security_algorithm_config
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds radio_resource_config_dedicated
*       as_config_t structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/

void uecc_rrm_build_security_algorithm_config(
        uecc_ue_context_t* p_uecc_ue_context,
        security_algorithm_config_t        *p_rrm_security_algorithm_config
)
{

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrm_security_algorithm_config);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Indicate to RRM the algorithms selected by ENB RRC */
    p_rrm_security_algorithm_config->ciphering_algo =
         (U8)(p_uecc_ue_context->configure_ciphering.algorithm_id);

    p_rrm_security_algorithm_config->integrity_protect_algo =
         (U8)(p_uecc_ue_context->configure_integrity_protection.algorithm_id);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: process_and_fill_as_context_from_s1ap_ho_request
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context,
*                  as_context_t    *p_rrm_as_context,
*                  AS_Context * p_s1ap_as_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function fills as config information received from S1AP
        HO REQUEST to RRM UE HO ADM REQ.
*
*   RETURNS:
*          void
*
******************************************************************************/
rrc_return_et process_and_fill_as_context_from_s1ap_ho_request(
        uecc_ue_context_t* p_uecc_ue_context,
        as_context_t    *p_rrm_as_context,
        AS_Context * p_s1ap_as_context)
{
    U32 count = 0;
    OSRTDListNode*      p_node = PNULL;
    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrm_as_context);
    RRC_ASSERT(PNULL != p_s1ap_as_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    do {

        if (!p_s1ap_as_context->m.reestablishmentInfoPresent)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "p_s1ap_as_context->m.reestablishmentInfoPresent is zero !!");
            break;
        }

#ifdef LTE_L3_BIG_ENDIAN
                l3_memcpy_wrapper(&p_rrm_as_context->target_cell_short_mac_i,
                p_s1ap_as_context->reestablishmentInfo.targetCellShortMAC_I.data,
                        sizeof(U16));
#elif LTE_L3_LITTLE_ENDIAN
        p_rrm_as_context->target_cell_short_mac_i = (U16)
                    (p_s1ap_as_context->reestablishmentInfo.
                       targetCellShortMAC_I.data[0] << 8 |
                    p_s1ap_as_context->reestablishmentInfo.
                       targetCellShortMAC_I.data[1]);
#else
/*ERROR_PLEASE_SPECIFY_ENDIANNESS*/
#endif

        p_rrm_as_context->source_phy_cell_id =
            p_s1ap_as_context->reestablishmentInfo.sourcePhysCellId;

        if (p_s1ap_as_context->reestablishmentInfo.m.
                additionalReestabInfoListPresent)
        {
            p_rrm_as_context->bitmask |=
                AS_CONTEXT_ADDITIONAL_REESTAB_INFO_PRESENT;

            p_rrm_as_context->additional_reestab_info_list.count =
                (U8)p_s1ap_as_context->reestablishmentInfo.
                additionalReestabInfoList.count;
            p_node = p_s1ap_as_context->reestablishmentInfo.
                additionalReestabInfoList.head;

            for (count = 0; count < 
                    p_rrm_as_context->additional_reestab_info_list.count && 
                    count < MAX_NUM_TARGET_CELL;
                    count++)
            {
                RRC_ASSERT(PNULL != p_node);
                RRC_ASSERT(PNULL != p_node->data);

                l3_memcpy_wrapper(&p_rrm_as_context->additional_reestab_info_list.
                        additional_reestab_info[count].cell_Id,
                        ((AdditionalReestabInfo*)p_node->data)->cellIdentity.data,
                        CELL_ID_OCTET_SIZE);
#ifdef LTE_L3_BIG_ENDIAN
                l3_memcpy_wrapper(&p_rrm_as_context->additional_reestab_info_list.
                        additional_reestab_info[count].short_mac_i,
                        ((AdditionalReestabInfo*)p_node->data)->shortMAC_I.data,
                        sizeof(U16));
#elif LTE_L3_LITTLE_ENDIAN
                p_rrm_as_context->additional_reestab_info_list.
                    additional_reestab_info[count].short_mac_i = (U16)
                    (((AdditionalReestabInfo*)p_node->data)->shortMAC_I.data[0] << 8 |
                    ((AdditionalReestabInfo*)p_node->data)->shortMAC_I.data[1]);
#else
/*ERROR_PLEASE_SPECIFY_ENDIANNESS*/
#endif
                p_node = p_node->next;
            }
        }

        result = RRC_SUCCESS;
    }while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: process_and_fill_ue_history_from_s1ap_ho_request
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context,
*                  ue_history_t                       *p_rrm_ue_history,
*                  rrc_ue_history_information_t  * p_rrc_ue_history_information
*   OUTPUT       : none
*   DESCRIPTION:
*       This function fills ue history information received from S1AP
        HO REQUEST to RRM UE HO ADM REQ.
*
*   RETURNS:
*          void
*
******************************************************************************/
rrc_return_et process_and_fill_ue_history_from_s1ap_ho_request(
        uecc_ue_context_t* p_uecc_ue_context,
        ue_history_t                       *p_rrm_ue_history,
        rrc_ue_history_information_t  * p_rrc_ue_history_information
)
{
    U16 count = 0;
    rrc_return_et result = RRC_FAILURE;
    last_visited_e_utran_cell_information_t    *
        p_last_visited_e_utran_cell_information = PNULL;
    last_visited_utran_cell_information_t       *
        p_last_visited_utran_cell_information = PNULL;
    s1ap_LastVisitedCell_Item *p_lastVisited_cell_item = PNULL;
    ranap_LastVisitedUTRANCell_Item  ranap_last_visitedUTRANCell_Item;   
    s1ap_LastVisitedUTRANCellInformation  *p_utran_cell = PNULL;
    s1ap_Cause s1ap_result;
    OSCTXT      asn1_ctxt;

        RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&ranap_last_visitedUTRANCell_Item, 0, 
                            sizeof(ranap_last_visitedUTRANCell_Item));
    memset_wrapper(&asn1_ctxt, 0, sizeof(OSCTXT)); 

     /* Init ASN1 context */
    if ( RT_OK != rtInitContext(&asn1_ctxt))
    {
        /* Drop message */
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name, RRC_ERROR,
       "[rrc_s1ap_rrc_container_intrl_dec] ASN context initialization failed.");
        RRC_UT_TRACE_EXIT();
        return result;
    }

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrm_ue_history);

    do {

        p_rrm_ue_history->last_visited_cell_list.count =
            p_rrc_ue_history_information->count;
        
        for (count =0; count < p_rrc_ue_history_information->count;
                count++)
        {
            p_lastVisited_cell_item = 
                &p_rrc_ue_history_information->lastVisited_cell_item[count];

            switch (p_lastVisited_cell_item->t)
            {
                case T_s1ap_LastVisitedCell_Item_e_UTRAN_Cell:
                    p_rrm_ue_history->last_visited_cell_list.
                        last_visited_cell_info[count].bitmask |=
                        LAST_VISITED_CELL_INFO_E_UTRAN_CELL_INFORMATION_PRESENT;

                    p_last_visited_e_utran_cell_information =   
                        &p_rrm_ue_history->last_visited_cell_list.
                        last_visited_cell_info[count].
                        last_visited_e_utran_cell_information;

                    uecc_s1ap_generate_plmn_identity_to_int(
                            &p_last_visited_e_utran_cell_information->
                            global_cell_id.plmn_identity,
                            p_lastVisited_cell_item->
                            u.e_UTRAN_Cell->global_Cell_ID.pLMNidentity.data);

                    l3_memcpy_wrapper(p_last_visited_e_utran_cell_information->
                            global_cell_id.cell_identity,
                            p_lastVisited_cell_item->
                             u.e_UTRAN_Cell->
                            global_Cell_ID.cell_ID.data,
                            ARRSIZE(p_lastVisited_cell_item->
                                u.e_UTRAN_Cell->
                            global_Cell_ID.cell_ID.data));

                    p_last_visited_e_utran_cell_information->
                        cell_type.cell_size =
                        (U8)p_lastVisited_cell_item->
                         u.e_UTRAN_Cell->
                        cellType.cell_Size;

                    p_last_visited_e_utran_cell_information->
                       time_ue_stayed_in_cell =
                       p_lastVisited_cell_item->
                       u.e_UTRAN_Cell->
                      time_UE_StayedInCell;

                    break;
                case T_s1ap_LastVisitedCell_Item_uTRAN_Cell:
                    asn1Init_ranap_LastVisitedUTRANCell_Item(
                            &ranap_last_visitedUTRANCell_Item);
                    p_rrm_ue_history->last_visited_cell_list.
                        last_visited_cell_info[count].bitmask |=
                        LAST_VISITED_CELL_INFO_UTRAN_CELL_INFORMATION_PRESENT;
                    
                    p_last_visited_utran_cell_information =   
                        &p_rrm_ue_history->last_visited_cell_list.
                        last_visited_cell_info[count].
                        last_visited_utran_cell_information;

                    if (PNULL != p_lastVisited_cell_item->u.uTRAN_Cell)
                    {
                        p_utran_cell = p_lastVisited_cell_item->u.uTRAN_Cell;
                        rrc_s1ap_last_visited_utran_cell_information_intrl_dec(
                                &(asn1_ctxt),
                                p_utran_cell,
                                &(ranap_last_visitedUTRANCell_Item),
                                &s1ap_result);

                        if (S1AP_CAUSE_SUCCESS != s1ap_result.t)
                        {
                            /* Message parsing error */
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name,
                                    RRC_WARNING,
                                    "ranap_last_visitedUTRANCell_Item"
                                    " Parsing error");

                            /*SPR_18125_START*/
                            rtFreeContext(&asn1_ctxt);
                            /*SPR_18125_END*/
                            /* Drop. */
                            RRC_UT_TRACE_EXIT();
                            return result;
                        }
                    }

                    uecc_s1ap_generate_plmn_identity_to_int(
                            &(p_last_visited_utran_cell_information->
                            utran_cell_id.plmn_identity),
                            ranap_last_visitedUTRANCell_Item.
                            uTRAN_CellID.pLMNidentity.data);

                    l3_memcpy_wrapper(p_last_visited_utran_cell_information->
                            utran_cell_id.cell_identity,
                            &ranap_last_visitedUTRANCell_Item.
                            uTRAN_CellID.cellID,
                            sizeof(ranap_last_visitedUTRANCell_Item.
                            uTRAN_CellID.cellID));

                    p_last_visited_utran_cell_information->
                        cell_type.cell_size =
                        (U8)ranap_last_visitedUTRANCell_Item.
                        cellType;

                    p_last_visited_utran_cell_information->
                       time_ue_stayed_in_cell =
                       ranap_last_visitedUTRANCell_Item.
                       time_UE_StayedInCell;

                       break;
                case T_s1ap_LastVisitedCell_Item_gERAN_Cell:
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,"[%s]Geran not supported ",
                            __FUNCTION__);
                    break;
                case T_s1ap_LastVisitedCell_Item_extElem1:
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->
                            context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,"[%s]T_LastVisitedCell_Item_extElem1",
                            __FUNCTION__);
                    break;
                default:
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->
                            context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "[%s]Unkown LastVisitedCell_Item type !!",
                        __FUNCTION__);
            }
        }
        result = RRC_SUCCESS;
    }while(0);

    rtFreeContext(&asn1_ctxt);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: process_and_fill_ue_history_from_x2ap_ho_request
*   INPUT        : uecc_ue_context_t*              p_uecc_ue_context,
*                  ue_history_t*                   p_rrm_ue_history,
*                  x2ap_UE_HistoryInformation*     p_rrc_ue_history_information
*   OUTPUT       : none
*   DESCRIPTION:
*       This function fills ue history information received from X2AP
        HO REQUEST to RRM UE HO ADM REQ.
*
*   RETURNS:
*          void
*
******************************************************************************/
rrc_return_et process_and_fill_ue_history_from_x2ap_ho_request(
        uecc_ue_context_t*              p_uecc_ue_context,
        ue_history_t*                   p_rrm_ue_history,
        x2ap_UE_HistoryInformation*     p_rrc_ue_history_information
)
{
    U16 count = 0;
    rrc_return_et result = RRC_FAILURE;
    last_visited_e_utran_cell_information_t    *
        p_last_visited_e_utran_cell_information = PNULL;
    last_visited_utran_cell_information_t       *
        p_last_visited_utran_cell_information = PNULL;
    x2ap_LastVisitedCell_Item *p_lastVisited_cell_item = PNULL;
    ranap_LastVisitedUTRANCell_Item  ranap_last_visitedUTRANCell_Item;   
    x2ap_LastVisitedUTRANCellInformation  *p_utran_cell = PNULL;
    x2ap_Cause x2ap_result;
    OSCTXT      asn1_ctxt;
    OSRTDListNode* p_node = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(&ranap_last_visitedUTRANCell_Item, 0, 
                            sizeof(ranap_last_visitedUTRANCell_Item));
    memset_wrapper(&asn1_ctxt, 0, sizeof(OSCTXT)); 

    memset_wrapper(&x2ap_result, 0, sizeof(x2ap_Cause));

     /* Init ASN1 context */
    if ( RT_OK != rtInitContext(&asn1_ctxt))
    {
        /* Drop message */
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name, RRC_ERROR,
                "[process_and_fill_ue_history_from_x2ap_ho_request]" 
                "ASN context initialization failed.");
        RRC_UT_TRACE_EXIT();
        return result;
    }

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrm_ue_history);

    p_rrm_ue_history->last_visited_cell_list.count = 0;
    do {

        for (p_node = p_rrc_ue_history_information->head;
                (count<p_rrc_ue_history_information->count)
                && (count < MAX_NO_OF_CELLS_UE_HISTORY);
                count++)
        {
            RRC_ASSERT(PNULL != p_node);
            RRC_ASSERT(PNULL != p_node->data);

            p_lastVisited_cell_item = 
                (x2ap_LastVisitedCell_Item*)p_node->data;
            switch (p_lastVisited_cell_item->t)
            {
                case T_x2ap_LastVisitedCell_Item_e_UTRAN_Cell:
                    p_rrm_ue_history->last_visited_cell_list.
                        last_visited_cell_info[count].bitmask |=
                        LAST_VISITED_CELL_INFO_E_UTRAN_CELL_INFORMATION_PRESENT;

                    p_last_visited_e_utran_cell_information =   
                        &p_rrm_ue_history->last_visited_cell_list.
                        last_visited_cell_info[count].
                        last_visited_e_utran_cell_information;

                    uecc_s1ap_generate_plmn_identity_to_int(
                            &p_last_visited_e_utran_cell_information->
                            global_cell_id.plmn_identity,
                            p_lastVisited_cell_item->
                            u.e_UTRAN_Cell->global_Cell_ID.pLMN_Identity.data);

                    l3_memcpy_wrapper(p_last_visited_e_utran_cell_information->
                            global_cell_id.cell_identity,
                            p_lastVisited_cell_item->
                            u.e_UTRAN_Cell->
                            global_Cell_ID.eUTRANcellIdentifier.data,
                            ARRSIZE(p_lastVisited_cell_item->
                                u.e_UTRAN_Cell->
                                global_Cell_ID.eUTRANcellIdentifier.data));

                    p_last_visited_e_utran_cell_information->
                        cell_type.cell_size =
                        (U8)p_lastVisited_cell_item->
                        u.e_UTRAN_Cell->
                        cellType.cell_Size;

                    p_last_visited_e_utran_cell_information->
                        time_ue_stayed_in_cell =
                        p_lastVisited_cell_item->
                        u.e_UTRAN_Cell->
                        time_UE_StayedInCell;

                    break;
                case T_x2ap_LastVisitedCell_Item_uTRAN_Cell:
                    asn1Init_ranap_LastVisitedUTRANCell_Item(
                            &ranap_last_visitedUTRANCell_Item);
                    p_rrm_ue_history->last_visited_cell_list.
                        last_visited_cell_info[count].bitmask |=
                        LAST_VISITED_CELL_INFO_UTRAN_CELL_INFORMATION_PRESENT;

                    p_last_visited_utran_cell_information =   
                        &p_rrm_ue_history->last_visited_cell_list.
                        last_visited_cell_info[count].
                        last_visited_utran_cell_information;

                    if (PNULL != p_lastVisited_cell_item->u.uTRAN_Cell)
                    {
                        p_utran_cell = p_lastVisited_cell_item->u.uTRAN_Cell;
                        rrc_x2ap_last_visited_utran_cell_information_intrl_dec(
                                &(asn1_ctxt),
                                p_utran_cell,
                                &(ranap_last_visitedUTRANCell_Item),
                                &x2ap_result);

                        if (S1AP_CAUSE_SUCCESS != x2ap_result.t)
                        {
                            /* Message parsing error */
                            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                                    (p_uecc_ue_context->p_gb_context)->facility_name, RRC_WARNING,
                                    "ranap_last_visitedUTRANCell_Item"
                                    " Parsing error");

                            /*SPR_18125_START*/
                            rtFreeContext(&asn1_ctxt);
                            /*SPR_18125_END*/
                            /* Drop. */
                            RRC_UT_TRACE_EXIT();
                            return result;
                        }
                    }

                    uecc_s1ap_generate_plmn_identity_to_int(
                            &(p_last_visited_utran_cell_information->
                                utran_cell_id.plmn_identity),
                            ranap_last_visitedUTRANCell_Item.
                            uTRAN_CellID.pLMNidentity.data);

                    l3_memcpy_wrapper(p_last_visited_utran_cell_information->
                            utran_cell_id.cell_identity,
                            &ranap_last_visitedUTRANCell_Item.
                            uTRAN_CellID.cellID,
                            sizeof(ranap_last_visitedUTRANCell_Item.
                                uTRAN_CellID.cellID));

                    p_last_visited_utran_cell_information->
                        cell_type.cell_size =
                        (U8)ranap_last_visitedUTRANCell_Item.
                        cellType;

                    p_last_visited_utran_cell_information->
                        time_ue_stayed_in_cell =
                        ranap_last_visitedUTRANCell_Item.
                        time_UE_StayedInCell;

                    break;
                case T_x2ap_LastVisitedCell_Item_gERAN_Cell:
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_INFO,"[%s]Geran not supported ",
                            __FUNCTION__);
                    break;
                case T_x2ap_LastVisitedCell_Item_extElem1:
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_INFO,"[%s]T_LastVisitedCell_Item_extElem1",
                         __FUNCTION__);
                    break;
                default:
                    RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->
                                context_index,
                            (p_uecc_ue_context->p_gb_context)->facility_name,
                            RRC_WARNING,
                            "[%s]Unkown LastVisitedCell_Item type !!",
                            __FUNCTION__);
            }
            p_rrm_ue_history->last_visited_cell_list.count++;
            p_node=p_node->next;
        }
        result = RRC_SUCCESS;
    }while(0);

    rtFreeContext(&asn1_ctxt);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_s1ap_generate_plmn_identity_to_int
*   INPUT        : plmn_identity_t    *p_plmn_identity,
*                  const OSOCTET      *p_s1ap_plmn_identity
*   OUTPUT       : none
*   DESCRIPTION:
*       This function converts PLMN identiy from S1AP format to internal
        format.
*
*   RETURNS:
*       Number of octets in resulting buffer
*
******************************************************************************/
void uecc_s1ap_generate_plmn_identity_to_int(
    plmn_identity_t    *p_plmn_identity,
    const OSOCTET      *p_s1ap_plmn_identity)
{
    /* TS 3GPP TS 36.413 V8.5.1 - 9.2.3.8  PLMN Identity
     * - digits 0 to 9, encoded 0000 to 1001,
     * - 1111 used as filler digit,
     * two digits per octet,
     * - bits 4 to 1 of octet n encoding digit 2n-1
     * - bits 8 to 5 of octet n encoding digit 2n
     *
     * -The Selected PLMN identity consists of 3 digits from MCC
     * followed by either
     * -a filler digit plus 2 digits from MNC (in case of 2 digit MNC) or
     * -3 digits from MNC (in case of a 3 digit MNC).
     * */

    /* MCC should be present always */
    p_plmn_identity->presence_bitmask |=
        PLMN_IDENTITY_MCC_PRESENCE_FLAG;

    /* PLMN Identity 1st octet : Pack first 2 digits of MCC */
    p_plmn_identity->mcc[0] = 
        p_s1ap_plmn_identity[0] & 0x0F;
    p_plmn_identity->mcc[1] =
        (p_s1ap_plmn_identity[0] & 0xF0) >> 4;

    /* PLMN Identity 2nd octet: Pack 3rd digit of MCC */
    p_plmn_identity->mcc[2] = 
        p_s1ap_plmn_identity[1] & 0x0F;

        /* if filler digit */
    if ((p_s1ap_plmn_identity[1] & 0xF0) == 0xF0)
    {
        p_plmn_identity->mnc.count = 2;

        /* PLMN Identity 3rd octet : 1st and 2nd digit of MNC */
        p_plmn_identity->mnc.mnc[0] = 
            p_s1ap_plmn_identity[2] & 0x0F;
        p_plmn_identity->mnc.mnc[1] = 
            (p_s1ap_plmn_identity[2] & 0xF0) >> 4;
    }
    else
    {
        /* PLMN Identity 3rd octet : Pack 1st digit of MNC */
        p_plmn_identity->mnc.count = 3;

        p_plmn_identity->mnc.mnc[0] = 
            (p_s1ap_plmn_identity[1] & 0xF0) >> 4;

        /* PLMN Identity 3rd octet : 2nd and 3rd digit of MNC */
        p_plmn_identity->mnc.mnc[1] = 
            p_s1ap_plmn_identity[2] & 0x0F;
        p_plmn_identity->mnc.mnc[2] = 
            (p_s1ap_plmn_identity[2] & 0xF0) >> 4;
    }
}


/******************************************************************************
*   FUNCTION NAME: process_fill_ho_restriction_list
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context,
*                  ho_restriction_list_t * p_ho_restriction_list,
*                  s1ap_HandoverRestrictionList * p_s1ap_HandoverRestrictionList
*   OUTPUT       : none
*   DESCRIPTION:
*       This function fills ue history information received from S1AP
        HO REQUEST to RRM UE HO ADM REQ.
*
*   RETURNS:
*          void
*
******************************************************************************/
rrc_return_et process_fill_ho_restriction_list(
        uecc_ue_context_t* p_uecc_ue_context,
        ho_restriction_list_t * p_ho_restriction_list,
        s1ap_HandoverRestrictionList * p_s1ap_HandoverRestrictionList
)
{
    OSRTDListNode*      p_node = PNULL;
    U16 count = 0;
    U16 tac_count = 0;
    U16 lac_count = 0;
    rrc_return_et result = RRC_FAILURE;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_ho_restriction_list);
    RRC_ASSERT(PNULL != p_s1ap_HandoverRestrictionList);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,p_uecc_ue_context->p_gb_context->facility_name,
                          RRC_DETAILEDALL,"Unused variable"
                          "p_uecc_ue_context=%p",p_uecc_ue_context);/*SPR 17777+-*/
    do {
        uecc_s1ap_generate_plmn_identity_to_int(
                &p_ho_restriction_list->serving_plmn_identity ,
                p_s1ap_HandoverRestrictionList->servingPLMN.data);

        if (p_s1ap_HandoverRestrictionList->m.equivalentPLMNsPresent)
        {
            p_ho_restriction_list->bitmask |= 
                HO_RESTRICTION_EQUIV_PLMN_LIST_PRESENT;
            p_ho_restriction_list->equiv_plmn_list.count =
                (U8)p_s1ap_HandoverRestrictionList->equivalentPLMNs.n;

            for (count = 0; count < p_ho_restriction_list->
                    equiv_plmn_list.count; count++)
            {
                uecc_s1ap_generate_plmn_identity_to_int(
                        &p_ho_restriction_list->equiv_plmn_list.
                        equiv_plmn[count].plmn_identity,
                        p_s1ap_HandoverRestrictionList->equivalentPLMNs.
                        elem[count].data);
            }
        }
        if (p_s1ap_HandoverRestrictionList->m.forbiddenTAsPresent)
        {
            p_ho_restriction_list->bitmask |= 
                HO_RESTRICTION_FORBIDDEN_TA_LIST_PRESENT;

            p_ho_restriction_list->forbidden_ta_list.count = 
                (U16)p_s1ap_HandoverRestrictionList->forbiddenTAs.count;
            p_node = p_s1ap_HandoverRestrictionList->forbiddenTAs.head;

            for (count =0; count < 
                    p_s1ap_HandoverRestrictionList->forbiddenTAs.count;
                    count++)
            {
                RRC_ASSERT(PNULL != p_node);
                RRC_ASSERT(PNULL != p_node->data);
                if (MAX_NO_OF_EPLMNS_PlUS_ONE <= count)
                {
                    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                    return result;
                }
                uecc_s1ap_generate_plmn_identity_to_int(&p_ho_restriction_list->
                        forbidden_ta_list.forbidden_ta[count].plmn_identity,
                        ((s1ap_ForbiddenTAs_Item*)p_node->data)->pLMN_Identity.data);

                p_ho_restriction_list->forbidden_ta_list.
                    forbidden_ta[count].forbidden_tac.count =
                    (U16)(((s1ap_ForbiddenTAs_Item*)p_node->data)->forbiddenTACs.n);

                for (tac_count = 0; tac_count < 
                        p_ho_restriction_list->forbidden_ta_list.
                        forbidden_ta[count].forbidden_tac.count;
                        tac_count++)
                {
                    if (MAX_NO_OF_FORBIDDEN_TACS <= tac_count)
                    {
                        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                        return result;
                    }
                    l3_memcpy_wrapper(p_ho_restriction_list->forbidden_ta_list.
                            forbidden_ta[count].forbidden_tac.
                            forbidden_tac[tac_count].tac,
                            ((s1ap_ForbiddenTAs_Item*)p_node->data)->
                            forbiddenTACs.elem[tac_count].data,
                            ((s1ap_ForbiddenTAs_Item*)p_node->data)->
                            forbiddenTACs.elem[tac_count].numocts);
                }
                p_node = p_node->next;
            }
        }
        if (p_s1ap_HandoverRestrictionList->m.forbiddenLAsPresent)
        {
            p_ho_restriction_list->bitmask |= 
                HO_RESTRICTION_FORBIDDEN_LA_LIST_PRESENT;

            p_ho_restriction_list->forbidden_la_list.count =
                (U16)p_s1ap_HandoverRestrictionList->forbiddenLAs.count;
            p_node = p_s1ap_HandoverRestrictionList->forbiddenLAs.head;

            for (count =0; count < 
                    p_s1ap_HandoverRestrictionList->forbiddenLAs.count;
                    count++)
            {
                RRC_ASSERT(PNULL != p_node);
                RRC_ASSERT(PNULL != p_node->data);

                uecc_s1ap_generate_plmn_identity_to_int(
                        &p_ho_restriction_list->forbidden_la_list.
                        forbidden_la[count].plmn_identity,
                        ((s1ap_ForbiddenLAs_Item*)p_node->data)->
                        pLMN_Identity.data);

                p_ho_restriction_list->forbidden_la_list.
                    forbidden_la[count].forbidden_lacs_list.count =
                    (U16)(((s1ap_ForbiddenLAs_Item*)p_node->data)->forbiddenLACs.n);

                for (lac_count = 0; lac_count < 
                    ((s1ap_ForbiddenLAs_Item*)p_node->data)->forbiddenLACs.n;
                        lac_count++)
                {
                    l3_memcpy_wrapper(p_ho_restriction_list->
                            forbidden_la_list.forbidden_la[
                            count].forbidden_lacs_list.
                             forbidden_lac[lac_count].lac,
                            ((s1ap_ForbiddenLAs_Item*)p_node->data)->
                            forbiddenLACs.elem[lac_count].data,
                            ((s1ap_ForbiddenLAs_Item*)p_node->
                            data)->forbiddenLACs.
                            elem[lac_count].numocts);
                }

                p_node = p_node->next;
            }
        }
        if (p_s1ap_HandoverRestrictionList->m.forbiddenInterRATsPresent)
        {
            p_ho_restriction_list->bitmask |= 
                HO_RESTRICTION_FORBIDDEN_INTER_RAT_PRESENT;
            p_ho_restriction_list->forbidden_inter_rat =
                (U8)p_s1ap_HandoverRestrictionList->forbiddenInterRATs;
        }
#ifdef ENDC_ENABLED
		if (p_s1ap_HandoverRestrictionList->m.iE_ExtensionsPresent)
		{
			for(count = 0; count < p_s1ap_HandoverRestrictionList->iE_Extensions.count;count++)
			{
				p_node = p_s1ap_HandoverRestrictionList->iE_Extensions.head;
				s1ap_HandoverRestrictionList_iE_Extensions_element *p_ie_Extensions_element
					= (s1ap_HandoverRestrictionList_iE_Extensions_element *)p_node->data;
				if (p_ie_Extensions_element->id == 
						ASN1V_s1ap_id_NRrestrictioninEPSasSecondaryRAT)
				{
					p_ho_restriction_list->bitmask |= 
                			HO_RESTRICTION_NR_RESTRICTION_PRESENT;
					p_ho_restriction_list->nr_restriction_EPS_as_SecRat
						= p_ie_Extensions_element->extensionValue.u._HandoverRestrictionList_ExtIEs_1;
				}

				p_node = p_node->next;
			}
		}		
#endif
        result = RRC_SUCCESS;
    }while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: process_fill_x2ap_ho_restriction_list
*   INPUT        : uecc_ue_context_t* p_uecc_ue_context,
*                  ho_restriction_list_t * p_ho_restriction_list,
*                  x2ap_HandoverRestrictionList * p_x2ap_HandoverRestrictionList
*   OUTPUT       : none
*   DESCRIPTION:
*       This function fills ue history information received from X2AP
        HO REQUEST to RRM UE HO ADM REQ.
*
*   RETURNS:
*          void
*
******************************************************************************/
rrc_return_et process_fill_x2ap_ho_restriction_list(
        uecc_ue_context_t* p_uecc_ue_context,
        ho_restriction_list_t * p_ho_restriction_list,
        x2ap_HandoverRestrictionList * p_x2ap_HandoverRestrictionList
)
{
    OSRTDListNode*      p_node = PNULL;
    U16 count = 0;
    U16 tac_count = 0;
    U16 lac_count = 0;
    rrc_return_et result = RRC_FAILURE;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_ho_restriction_list);
    RRC_ASSERT(PNULL != p_x2ap_HandoverRestrictionList);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,p_uecc_ue_context->p_gb_context->facility_name,
                        RRC_DETAILEDALL,"Unused variable"
                        "p_uecc_ue_context=%p",p_uecc_ue_context);/*SPR 17777+-*/
    do {
        uecc_s1ap_generate_plmn_identity_to_int(
                &p_ho_restriction_list->serving_plmn_identity ,
                p_x2ap_HandoverRestrictionList->servingPLMN.data);

        if (p_x2ap_HandoverRestrictionList->m.equivalentPLMNsPresent)
        {
            p_ho_restriction_list->bitmask |= 
                HO_RESTRICTION_EQUIV_PLMN_LIST_PRESENT;
            p_ho_restriction_list->equiv_plmn_list.count =
                (U8)p_x2ap_HandoverRestrictionList->equivalentPLMNs.n;

            for (count = 0; count < p_ho_restriction_list->
                    equiv_plmn_list.count; count++)
            {
                uecc_s1ap_generate_plmn_identity_to_int(
                        &p_ho_restriction_list->equiv_plmn_list.
                        equiv_plmn[count].plmn_identity,
                        p_x2ap_HandoverRestrictionList->equivalentPLMNs.
                        elem[count].data);
            }
        }
        if (p_x2ap_HandoverRestrictionList->m.forbiddenTAsPresent)
        {
            p_ho_restriction_list->bitmask |= 
                HO_RESTRICTION_FORBIDDEN_TA_LIST_PRESENT;

            p_ho_restriction_list->forbidden_ta_list.count = 
                (U16)p_x2ap_HandoverRestrictionList->forbiddenTAs.count;
            p_node = p_x2ap_HandoverRestrictionList->forbiddenTAs.head;

            for (count =0; count < 
                    p_x2ap_HandoverRestrictionList->forbiddenTAs.count;
                    count++)
            {
                RRC_ASSERT(PNULL != p_node);
                RRC_ASSERT(PNULL != p_node->data);

                uecc_s1ap_generate_plmn_identity_to_int(&p_ho_restriction_list->
                        forbidden_ta_list.forbidden_ta[count].plmn_identity,
                        ((x2ap_ForbiddenTAs_Item*)p_node->data)->pLMN_Identity.data);

                p_ho_restriction_list->forbidden_ta_list.
                    forbidden_ta[count].forbidden_tac.count =
                    (U16)(((x2ap_ForbiddenTAs_Item*)p_node->data)->forbiddenTACs.n);

                for (tac_count = 0; tac_count < 
                        p_ho_restriction_list->forbidden_ta_list.
                        forbidden_ta[count].forbidden_tac.count;
                        tac_count++)
                {
                    l3_memcpy_wrapper(p_ho_restriction_list->forbidden_ta_list.
                            forbidden_ta[count].forbidden_tac.
                            forbidden_tac[tac_count].tac,
                            ((x2ap_ForbiddenTAs_Item*)p_node->data)->
                            forbiddenTACs.elem[tac_count].data,
                            ((x2ap_ForbiddenTAs_Item*)p_node->data)->
                            forbiddenTACs.elem[tac_count].numocts);
                }
                p_node = p_node->next;
            }
        }
        if (p_x2ap_HandoverRestrictionList->m.forbiddenLAsPresent)
        {
            p_ho_restriction_list->bitmask |= 
                HO_RESTRICTION_FORBIDDEN_LA_LIST_PRESENT;

            p_ho_restriction_list->forbidden_la_list.count =
                (U16)p_x2ap_HandoverRestrictionList->forbiddenLAs.count;
            p_node = p_x2ap_HandoverRestrictionList->forbiddenLAs.head;

            for (count =0; count < 
                    p_x2ap_HandoverRestrictionList->forbiddenLAs.count;
                    count++)
            {
                RRC_ASSERT(PNULL != p_node);
                RRC_ASSERT(PNULL != p_node->data);

                uecc_s1ap_generate_plmn_identity_to_int(
                        &p_ho_restriction_list->forbidden_la_list.
                        forbidden_la[count].plmn_identity,
                        ((x2ap_ForbiddenLAs_Item*)p_node->data)->
                        pLMN_Identity.data);

                p_ho_restriction_list->forbidden_la_list.
                    forbidden_la[count].forbidden_lacs_list.count =
                    (U16)(((x2ap_ForbiddenLAs_Item*)p_node->data)->forbiddenLACs.n);

                for (lac_count = 0; lac_count < 
                    ((s1ap_ForbiddenLAs_Item*)p_node->data)->forbiddenLACs.n;
                        lac_count++)
                {
                    l3_memcpy_wrapper(p_ho_restriction_list->
                            forbidden_la_list.forbidden_la[
                            count].forbidden_lacs_list.
                             forbidden_lac[lac_count].lac,
                            ((x2ap_ForbiddenLAs_Item*)p_node->data)->
                            forbiddenLACs.elem[lac_count].data,
                            ((x2ap_ForbiddenLAs_Item*)p_node->
                            data)->forbiddenLACs.
                            elem[lac_count].numocts);
                }

                p_node = p_node->next;
            }
        }
        if (p_x2ap_HandoverRestrictionList->m.forbiddenInterRATsPresent)
        {
            p_ho_restriction_list->bitmask |= 
                HO_RESTRICTION_FORBIDDEN_INTER_RAT_PRESENT;
            p_ho_restriction_list->forbidden_inter_rat =
                (U8)p_x2ap_HandoverRestrictionList->forbiddenInterRATs;
        }

        result = RRC_SUCCESS;
    }while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_mib_info
*   INPUT        : uecc_ue_context_t   *p_uecc_ue_context,
*                  mib_info_t                      *p_mib_info ,
*                  MasterInformationBlock * p_asn_MasterInformationBlock
*   OUTPUT       : none
*   DESCRIPTION:
*       This function copies the MIBs to asn structure .
*
*   RETURNS:
*
******************************************************************************/
void     uecc_rrm_build_mib_info(
    uecc_ue_context_t   *p_uecc_ue_context,
    mib_info_t                      *p_mib_info ,  
   MasterInformationBlock * p_asn_MasterInformationBlock 
)
{

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_mib_info);
    RRC_ASSERT(PNULL != p_asn_MasterInformationBlock);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,p_uecc_ue_context->p_gb_context->facility_name,
                          RRC_DETAILEDALL,"Unused variable"
                          "p_uecc_ue_context=%p",p_uecc_ue_context);/*SPR 17777+-*/
   
    /* Fill MIB with values from p_mib_info */
    memset_wrapper(p_mib_info, 0, sizeof(mib_info_t));

    p_mib_info-> dl_band_width              = 
        (U8)p_asn_MasterInformationBlock->dl_Bandwidth;
    p_mib_info->phich_config.phich_duration = 
        (U8)p_asn_MasterInformationBlock->phich_Config.phich_Duration;
    p_mib_info->phich_config.phich_resource = 
        (U8)p_asn_MasterInformationBlock->phich_Config.phich_Resource;
    
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_sib_type1_info
*   INPUT        : uecc_ue_context_t   *p_uecc_ue_context,
*                  sib_type_1_Info_t   *p_sib_type1_info,
*                  SystemInformationBlockType1 *p_asn1_sib1
*   OUTPUT       : none
*   DESCRIPTION:
*       This function copies SIBTyp1 msg to asn structure 
*       scheduled.
*
*   RETURNS:
*       RRC_SUCCESS - if successfully encodes all MIBs.
*       RRC_FAILURE - otherwise
*
******************************************************************************/
rrc_return_et uecc_rrm_build_sib_type1_info(
            uecc_ue_context_t   *p_uecc_ue_context,
            sib_type_1_Info_t   *p_sib_type1_info,  
            SystemInformationBlockType1 *p_asn1_sib1 
)
{
    rrc_return_et ret_val               = RRC_SUCCESS;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_sib_type1_info);
    RRC_ASSERT(PNULL != p_asn1_sib1);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    if (RRC_SUCCESS != uecc_rrm_build_cell_access_related_info(
                &p_sib_type1_info->cell_access_related_info,
                &p_asn1_sib1->cellAccessRelatedInfo,
                p_uecc_ue_context))
    {
        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    if ( p_asn1_sib1->m.p_MaxPresent )
    {
        p_sib_type1_info->presence_bitmask |= SIB_TYPE_1_P_MAX_PRESENCE_FLAG;
        p_sib_type1_info->p_max =  p_asn1_sib1->p_Max;
    }

    if ( p_asn1_sib1->m.tdd_ConfigPresent)
    {
        p_sib_type1_info->presence_bitmask |= 
            SIB_TYPE_1_TDD_CONFIG_PRESENT_FLAG;
        p_sib_type1_info->tdd_config.sub_frame_assignment = 
            (U8)p_asn1_sib1->tdd_Config.subframeAssignment;
        p_sib_type1_info->tdd_config.special_sub_frame_pattern = 
            (U8)p_asn1_sib1->tdd_Config.specialSubframePatterns;
    }
    p_sib_type1_info->cell_selection_Info.q_rx_lev_min = 
        p_asn1_sib1->cellSelectionInfo.q_RxLevMin;

    if ( p_asn1_sib1->cellSelectionInfo.m.q_RxLevMinOffsetPresent)
    {
        p_sib_type1_info->cell_selection_Info.presence_bitmask |= 
            CELL_SELECT_INFO_Q_RX_LEV_MIN_OFFSET_PRESENCE_FLAG;
        p_sib_type1_info->cell_selection_Info.q_rx_lev_min_offset = 
            p_asn1_sib1->cellSelectionInfo.q_RxLevMinOffset;
        p_sib_type1_info->cell_selection_Info.q_rx_lev_min = 
            p_asn1_sib1->cellSelectionInfo.q_RxLevMin;
    }

    p_sib_type1_info->freq_band_indicator = p_asn1_sib1->freqBandIndicator;
    if (RRC_SUCCESS != uecc_rrm_build_sib1_sched_inf( 
                             &p_sib_type1_info->scheduling_info_list,
                             &p_asn1_sib1->schedulingInfoList,
                             p_uecc_ue_context))
    {
        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* Make sure that SIs scheduling information is OK */
    /* p_sib1->si_WindowLength should be defined in term of
     *  SystemInformationBlockType1_si_WindowLength_Root */
    if ( p_asn1_sib1->si_WindowLength > ms40)
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "Wrong SI window length=%u. Should be up to "
                "RRM_RRC_SI_WINDOW_LEN_MS_40==ms40",
                p_asn1_sib1->si_WindowLength);
        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
        return RRC_FAILURE;
    }


    p_sib_type1_info->si_window_length    =  (U8)p_asn1_sib1->si_WindowLength;
    p_sib_type1_info->si_value_tag        =  p_asn1_sib1->systemInfoValueTag;

    if ( p_asn1_sib1->m.nonCriticalExtensionPresent )
    {
        p_sib_type1_info->presence_bitmask |= 
                         SIB_TYPE_1_NON_CRITICAL_EXTENSION_PRESENT_FLAG;
        if ( p_asn1_sib1->nonCriticalExtension.m.nonCriticalExtensionPresent )
        {
            p_sib_type1_info->non_critical_extension.presence_bitmask |=
                     SIB_TYPE_1_V890_IES_NON_CROTICAL_EXTENSION_PRESENT_FLAG;
            if ( p_asn1_sib1->nonCriticalExtension.nonCriticalExtension.\
                            m.ims_EmergencySupport_r9Present )
            {
                p_sib_type1_info->non_critical_extension.\
                  non_critical_extension.presence_bitmask |=
                    SIB_TYPE_1_V920_IES_IMS_EMERGENCY_SUPPORT_PRESENT_FLAG;
                p_sib_type1_info->non_critical_extension.\
                  non_critical_extension.ims_emergency_support =
                    (U8)p_asn1_sib1->nonCriticalExtension.nonCriticalExtension.\
                      ims_EmergencySupport_r9;
            }
            /*cr_398 cellSelectionInfo_v920 changes*/
            if (p_asn1_sib1->nonCriticalExtension.nonCriticalExtension.
                            m.cellSelectionInfo_v920Present)
            {
                p_sib_type1_info->non_critical_extension.
                  non_critical_extension.presence_bitmask |=
                    SIB_TYPE_1_V920_IES_CELL_SELECTION_INFO_V920_PRESENT_FLAG;

                p_sib_type1_info->non_critical_extension.
                  non_critical_extension.cell_selection_info_v920.q_qual_min_r9 =
                    (S8)p_asn1_sib1->nonCriticalExtension.nonCriticalExtension.
                      cellSelectionInfo_v920.q_QualMin_r9;

                if (p_asn1_sib1->nonCriticalExtension.nonCriticalExtension.
                            cellSelectionInfo_v920.m.q_QualMinOffset_r9Present)
                {
                    p_sib_type1_info->non_critical_extension.
                      non_critical_extension.cell_selection_info_v920.presence_bitmask |=
                       CELL_SELECTION_INFO_Q_QUAL_MIN_OFFSET_R9_PRESENT_FLAG; 
                
                  p_sib_type1_info->non_critical_extension.
                    non_critical_extension.cell_selection_info_v920.q_qual_min_offset_r9 =
                    (U8)p_asn1_sib1->nonCriticalExtension.nonCriticalExtension.
                      cellSelectionInfo_v920.q_QualMinOffset_r9;
                }
            }
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return ret_val;
}
/******************************************************************************
  *   FUNCTION NAME: uecc_rrm_build_sib_type2_info
  *   INPUT        : uecc_ue_context_t   *p_uecc_ue_context,
  *                  sib_type_2_Info_t   *p_rrm_sib2,
  *                  SystemInformationBlockType2 *p_asn1_sib2
  *   OUTPUT       : none                                
  *  DESCRIPTION:
  *       This function copies SIBTyp1 msg to asn structure
  *       scheduled.
  *
  *   RETURNS:
  *       RRC_SUCCESS - if successfully encodes all MIBs.
  *       RRC_FAILURE - otherwise
  *
******************************************************************************/
rrc_return_et uecc_rrm_build_sib_type2_info  (
                uecc_ue_context_t   *p_uecc_ue_context,
                sib_type_2_Info_t   *p_rrm_sib2,  
                SystemInformationBlockType2 *p_asn1_sib2 
)
{
    rrc_return_et ret_value               = RRC_SUCCESS;


    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrm_sib2);
    RRC_ASSERT(PNULL != p_asn1_sib2);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    if ( p_asn1_sib2->m.ac_BarringInfoPresent)
    {
        p_rrm_sib2->presence_bitmask |= SIB2_ACCESS_BARR_INFO_PRESENCE_FLAG;

        p_rrm_sib2->access_barring_info.acBarringForEmergency 
            = p_asn1_sib2->ac_BarringInfo.ac_BarringForEmergency; 

        if (p_asn1_sib2->ac_BarringInfo.m.ac_BarringForMO_SignallingPresent )
        {
            p_rrm_sib2->access_barring_info.presence_bitmask |= 
                AC_BARR_INFO_MO_SIG_PRESENCE_FLAG;

            ret_value = fill_rrm_access_class_barring_info(
                    p_uecc_ue_context->p_gb_context, 
                    &p_rrm_sib2->access_barring_info.
                    ac_barring_for_mo_signalling,
                    &p_asn1_sib2->ac_BarringInfo.ac_BarringForMO_Signalling
                    );

            if (RRC_FAILURE == ret_value)
            {
                RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
        }

        if (  p_asn1_sib2->ac_BarringInfo.m.ac_BarringForMO_DataPresent)
        {
            p_rrm_sib2->access_barring_info.presence_bitmask |= 
                AC_BARR_INFO_MO_DATA_PRESENCE_FLAG;

            ret_value = fill_rrm_access_class_barring_info(
                    p_uecc_ue_context->p_gb_context, 
                    &p_rrm_sib2->access_barring_info.ac_barring_for_mo_data,
                    &p_asn1_sib2->ac_BarringInfo.ac_BarringForMO_Data
                    );

            if (RRC_FAILURE == ret_value)
            {
                RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
        }
    }    /* - radioResourceConfigCommon */
    ret_value = fill_rrm_radio_resource_config_common(
            p_uecc_ue_context->p_gb_context, 
            &p_rrm_sib2-> radio_resource_config_common_sib,
            &p_asn1_sib2->radioResourceConfigCommon);

    if (RRC_FAILURE == ret_value)
    {
        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* - ue_TimersAndConstants */

    p_rrm_sib2->ue_timers_and_constants.timer_300  = 
        (U8)p_asn1_sib2->ue_TimersAndConstants.t300;
    p_rrm_sib2->ue_timers_and_constants.timer_301  = 
        (U8)p_asn1_sib2->ue_TimersAndConstants.t301;
    p_rrm_sib2->ue_timers_and_constants.timer_310  = 
        (U8)p_asn1_sib2->ue_TimersAndConstants.t310;
    p_rrm_sib2->ue_timers_and_constants.timer_n310 = 
        (U8)p_asn1_sib2->ue_TimersAndConstants.n310;
    p_rrm_sib2->ue_timers_and_constants.timer_311  = 
        (U8)p_asn1_sib2->ue_TimersAndConstants.t311;
    p_rrm_sib2->ue_timers_and_constants.timer_n311 = 
        (U8)p_asn1_sib2->ue_TimersAndConstants.n311;

    /* - frequencyInformation */

    p_rrm_sib2->freq_info.presence_bitmask = 0;

    if ( p_asn1_sib2->freqInfo.m.ul_CarrierFreqPresent )
    {
        p_rrm_sib2->freq_info.presence_bitmask |=
            FREQ_INFO_UL_CARRER_FREQ_PRESENCE_FLAG;
        p_rrm_sib2->freq_info.ul_carrier_freq |= 
            p_asn1_sib2->freqInfo.ul_CarrierFreq;
    }

    if ( p_asn1_sib2->freqInfo.m.ul_BandwidthPresent )
    {
        p_rrm_sib2->freq_info.presence_bitmask |= 
            FREQ_INFO_UL_BW_PRESENCE_FLAG;
        p_rrm_sib2->freq_info.ul_bandwidth = 
            (U8)p_asn1_sib2->freqInfo.ul_Bandwidth;
    }

    p_rrm_sib2->freq_info.add_spectrum_emission = 
        p_asn1_sib2->freqInfo.additionalSpectrumEmission;

    /* - mbsfn_SubframeConfiguration */
    if ( p_asn1_sib2->m.mbsfn_SubframeConfigListPresent)
    {
        p_rrm_sib2->presence_bitmask |= 
            SIB2_MBSFN_SUBFRAME_CONF_LIST_PRESENCE_FLAG;
        ret_value = fill_rrm_subframe_config(
                &p_rrm_sib2->mbsfn_subframe_config_list,
                &p_asn1_sib2->mbsfn_SubframeConfigList,
                p_uecc_ue_context);

        if (RRC_FAILURE == ret_value)
        {
            RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
    }

    p_rrm_sib2->time_align_timer = 
        (U8)p_asn1_sib2->timeAlignmentTimerCommon;

    /*cr_345 ssac_BarringForMMTEL change*/
    if (p_asn1_sib2->m._v3ExtPresent)
    {
        if (p_asn1_sib2->m.ssac_BarringForMMTEL_Voice_r9Present )
        {
            p_rrm_sib2->presence_bitmask |= 
                SIB2_SSAC_BARRING_FOR_MMTEL_VOICE_PRESENCE_FLAG;

            ret_value = fill_rrm_access_class_barring_info(
                p_uecc_ue_context->p_gb_context, 
                &p_rrm_sib2->ssac_barring_for_mmtel_voice_r9,
                &p_asn1_sib2->ssac_BarringForMMTEL_Voice_r9
                );

            if (RRC_FAILURE == ret_value)
            {
                RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
        }
        if (p_asn1_sib2->m.ssac_BarringForMMTEL_Video_r9Present )
        {
            p_rrm_sib2->presence_bitmask |= 
                SIB2_SSAC_BARRING_FOR_MMTEL_VIDEO_PRESENCE_FLAG;

            ret_value = fill_rrm_access_class_barring_info(
                p_uecc_ue_context->p_gb_context, 
                &p_rrm_sib2->ssac_barring_for_mmtel_video_r9,
                &p_asn1_sib2->ssac_BarringForMMTEL_Video_r9
                );

            if (RRC_FAILURE == ret_value)
            {
                RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
        }
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return ret_value;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_cell_access_related_info
*   INPUT        : cell_access_related_info_t                                  *p_cell_ari
*                  SystemInformationBlockType1_cellAccessRelatedInfo           *p_asn1_cell_ari
*                  uecc_ue_context_t                                           *p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function converts cell_access_related_info_t to
*       SystemInformationBlockType1_cellAccessRelatedInformation
*       and checks if input data are valid.
*
*   RETURNS:
*       RRC_SUCCESS - if all data are valid
*       RRC_FAILURE - if data are invalid or if there are not enough memory
*
******************************************************************************/
static rrc_return_et uecc_rrm_build_cell_access_related_info
(
    /* destination */
    cell_access_related_info_t                                  *p_cell_ari,
    /* source */
    SystemInformationBlockType1_cellAccessRelatedInfo           *p_asn1_cell_ari,
    uecc_ue_context_t                                           *p_uecc_ue_context
)
{
    U8                          i               = RRC_NULL;
    U8                          digit           = RRC_NULL;
    OSRTDListNode               *p_node         = PNULL;
    PLMN_IdentityInfo           *p_asn1_l_elem  = PNULL;
    plmn_identity_info_t        *p_l_elem       = PNULL;


    RRC_ASSERT(PNULL != p_cell_ari);
    RRC_ASSERT(PNULL != p_asn1_cell_ari);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /* SPR 23209 FIXED START*/

    /* PLMN-IdentityList */
    if ( p_asn1_cell_ari->plmn_IdentityList.count > MAX_PLMN_IDS)
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "Wrong size of PLMN-IdentityList: current=%u, RRM max=%u",
                p_asn1_cell_ari->plmn_IdentityList.count,
                MAX_PLMN_IDS);
        return RRC_FAILURE;
    }
    /* SPR 23209 FIXED END*/

    p_cell_ari->plmn_Id_info_list.count = 
        (U8)p_asn1_cell_ari->plmn_IdentityList.count;
    p_node = p_asn1_cell_ari->plmn_IdentityList.head;

    for (i = 0; i < p_cell_ari->plmn_Id_info_list.count; i++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        p_asn1_l_elem = (PLMN_IdentityInfo*)p_node->data;

        p_l_elem = &p_cell_ari->plmn_Id_info_list.plmn_identity_info[i];

        /* Check MCC condition: mcc must be present in the first
         *  PLMN-IdentityList item */
        if (    (0 == i) &&
                !(p_asn1_l_elem->plmn_Identity.m.mccPresent ))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING, "Mcc must be present in the first PLMN"
                    "-IdentityList item");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        if (p_asn1_l_elem->plmn_Identity.m.mccPresent )
        {
            p_l_elem->plmn_identity.presence_bitmask |=
                PLMN_IDENTITY_MCC_PRESENCE_FLAG;

            for (digit = 0; digit < ARRSIZE(p_l_elem->plmn_identity.mcc);
                    digit++)
            {
                p_l_elem-> plmn_identity.mcc[digit] =
                    p_asn1_l_elem->plmn_Identity.mcc.elem[digit]; 
            }
        }

        if ( (p_l_elem->plmn_identity.mnc.count > ARRSIZE(p_asn1_l_elem->
                        plmn_Identity.mnc.elem)) ||
                (p_l_elem->plmn_identity.mnc.count > 
                 ARRSIZE(p_l_elem-> plmn_identity.mnc.mnc)))
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "Too many MNC digits: current=%u, RRM max=%u, ASN.1 max=%u",
                    p_l_elem->plmn_identity.mnc.count,
                    ARRSIZE(p_l_elem->plmn_identity.mnc.mnc),
                    ARRSIZE(p_asn1_l_elem->plmn_Identity.mnc.elem));
            RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        p_l_elem->plmn_identity.mnc.count = (U8)p_asn1_l_elem->plmn_Identity.mnc.n;

        for (digit = 0; digit < p_l_elem->plmn_identity.mnc.count; digit++)
        {
            p_l_elem->plmn_identity.mnc.mnc[digit] =
                p_asn1_l_elem->plmn_Identity.mnc.elem[digit];
        }

        p_l_elem->cell_res_for_operator_use =
            (U8)p_asn1_l_elem->cellReservedForOperatorUse;

        p_node = p_node->next;
    }

    l3_memcpy_wrapper( p_cell_ari->tac,
            p_asn1_cell_ari->trackingAreaCode.data,
            sizeof(p_cell_ari->tac));

    l3_memcpy_wrapper( p_cell_ari->cell_Id ,
            p_asn1_cell_ari->cellIdentity.data,
            sizeof(p_asn1_cell_ari->cellIdentity.data));

    p_cell_ari->cell_barred = (U8)p_asn1_cell_ari->cellBarred;
    p_cell_ari->intra_freq_reselection = (U8)p_asn1_cell_ari->intraFreqReselection;

    if (RRC_FALSE == p_asn1_cell_ari->csg_Indication)
    {
        p_cell_ari->csg_indication = FALSE;
    }
    else
    {
        p_cell_ari->csg_indication  = TRUE;
    }

    if ((RRC_TRUE == p_asn1_cell_ari->csg_Indication) &&
            (0 == p_asn1_cell_ari->m.csg_IdentityPresent))
    {
        /* Logical check: we should have p_cell_ari->csg_identity
         *  if p_cell_ari->csg_indication is TRUE */
        /* Otherwise I don't understand how UE should behaviour in this case */
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING, "We should have"
        " p_asn1_cell_ari->csg_Identity if"
                " p_asn1_cell_ari->csg_Indication is TRUE");
        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    if ( p_asn1_cell_ari->m.csg_IdentityPresent )
    {
        p_cell_ari->presence_bitmask |= CELL_ACCESS_INFO_CSG_ID_PRESENCE_FLAG;
        
        l3_memcpy_wrapper( p_cell_ari->csg_identity,
                p_asn1_cell_ari->csg_Identity.data,
                sizeof(p_asn1_cell_ari->csg_Identity.data));

        p_cell_ari->csg_identity[CSG_ID_OCTET_SIZE-1] &= CSG_RESET_VAL;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/***************************************************************************
*   FUNCTION NAME: uecc_rrm_build_sib1_sched_inf
*   INPUT        : scheduling_info_list_t       *p_sched_inf
*                  SchedulingInfoList          *p_asn1_sched_inf
*                  uecc_ue_context_t           *p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function converts 
*       SchedulingInformation_element to scheduling_info_list_t
*
*   RETURNS:
*       RRC_SUCCESS - if all data are valid
*       RRC_FAILURE - if data are invalid or if there are not enough memory
*
******************************************************************************/
static rrc_return_et uecc_rrm_build_sib1_sched_inf
(
    scheduling_info_list_t       *p_sched_inf,       /* destination*/
    SchedulingInfoList          *p_asn1_sched_inf,  /* source */
    uecc_ue_context_t           *p_uecc_ue_context
)
{
    U8                              i               = RRC_NULL;
    U8                              SIB             = RRC_NULL;
    OSRTDListNode                   *p_node         = PNULL;
    SchedulingInfo                  *p_asn1_l_elem  = PNULL;
    scheduling_info_t                *p_l_elem       = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    if ((p_asn1_sched_inf->count < 1) ||
            (p_asn1_sched_inf->count > MAX_SI_MESSAGE) )
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "Wrong number of SIs=%u. Should be 1..min(RRM=%u, ASN.1=%u)",
                p_asn1_sched_inf->count,
                MAX_SI_MESSAGE);
        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* Store the SI Mapping count in cell context */
    p_sched_inf->count = (U8)p_asn1_sched_inf->count;
    p_node = p_asn1_sched_inf->head;

    for (i = 0; i < p_sched_inf->count; i++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        p_asn1_l_elem  = (SchedulingInfo*)(p_node->data);
        p_l_elem = &p_sched_inf->scheduling_info[i];

        if (p_asn1_l_elem->si_Periodicity > rf512)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING, "Wrong periodicity of SI=%u. Should be "
                    "up to rf512", p_l_elem->si_periodicity);
            RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        p_l_elem->si_periodicity = (U8)p_asn1_l_elem->si_Periodicity;

        /* Check number of SIBs in this SI */
        if (p_asn1_l_elem->sib_MappingInfo.n > MAX_SIB_MESSAGE_1)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "Wrong number of SIBs in SI=%u."
                    " Should be 0..min(RRM=%u, ASN.1"
                    "=%u)",
                    p_asn1_l_elem->sib_MappingInfo.n);
            RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
            return RRC_FAILURE;
        }
        RRC_ASSERT(MAX_SIB_MESSAGE_1 == ARRSIZE(p_asn1_l_elem->sib_MappingInfo.
                    elem));

        p_l_elem->sib_mapping_info.count = (U8)p_asn1_l_elem->sib_MappingInfo.n;

        /* Initialise the SI_SIBS_BITMASK */
        for (SIB = 0; SIB < p_l_elem->sib_mapping_info.count; SIB++)
        {
            /* SPR 18922 changes Start */
            if (p_asn1_l_elem->sib_MappingInfo.elem[SIB] > sibType13_v920)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "Wrong SIB=%u in SI. Should be up to sibType13_v920",
                        p_l_elem->sib_mapping_info.sib_type[SIB]);
                RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                return RRC_FAILURE;
            }
            /* SPR 18922 changes end */
            p_l_elem->sib_mapping_info.sib_type[SIB] =
                (U8)p_asn1_l_elem->sib_MappingInfo.elem[SIB];
        }
        p_node = p_node->next;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;
}


/******************************************************************************
*   FUNCTION NAME: fill_rrm_access_class_barring_info
*   INPUT        : uecc_gb_context_t               *p_uecc_gb_context
*                  access_class_barring_Info_t     *p_access_class
*                  AC_BarringConfig                *p_asn1_access_class
*   OUTPUT       : none
*   DESCRIPTION:
*       This function converts fills access_class_barring_Info_t from
*       AC_BarringConfig (previously named AccessClassBarringInformation)
*
*   RETURNS:
*       RRC_SUCCESS - all data are valid
*       RRC_FAILURE - data are invalid or if there are not enough memory
*
******************************************************************************/
static rrc_return_et fill_rrm_access_class_barring_info (
 uecc_gb_context_t               *p_uecc_gb_context,
 access_class_barring_Info_t     *p_access_class,         /* source */
 AC_BarringConfig                *p_asn1_access_class   /* destination */
)
{

    RRC_ASSERT(PNULL != p_asn1_access_class);
    RRC_ASSERT(PNULL != p_access_class);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/

    p_access_class->ac_barring_factor =
        (U8)p_asn1_access_class->ac_BarringFactor;
    p_access_class->ac_barring_time =
        (U8)p_asn1_access_class->ac_BarringTime;

    p_access_class->ac_barring_for_special_ac =  
        p_asn1_access_class->ac_BarringForSpecialAC.data[0];

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return RRC_SUCCESS;
}



/******************************************************************************
*   FUNCTION NAME: fill_rrm_radio_resource_config_common
*   INPUTS       : uecc_gb_context_t                   *p_uecc_gb_context
*                  radio_resource_config_common_sib_t  *p_rrm_cc
*                  RadioResourceConfigCommonSIB        *p_asn1_cc
*   OUTPUTS      : None
*   DESCRIPTION:
*       This function converts RadioResourceConfigCommonSIB to
*       radio_resource_config_common_sib_t 
*
*   RETURNS:
*       RRC_SUCCESS - all data are valid
*       RRC_FAILURE - data are invalid or if there are not enough memory
*
******************************************************************************/
static rrc_return_et fill_rrm_radio_resource_config_common
(   
    uecc_gb_context_t               *p_uecc_gb_context, 
    radio_resource_config_common_sib_t  *p_rrm_cc ,   
    RadioResourceConfigCommonSIB        *p_asn1_cc 
)
{

    RRC_ASSERT(PNULL != p_asn1_cc);
    RRC_ASSERT(PNULL != p_rrm_cc);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
 
    /* - rach_Configuration */
    /* -- rach_Configuration/preambleInformation */
    p_rrm_cc->rach_config_common.preamble_info.ra_preamble_count =
        (U8)p_asn1_cc->rach_ConfigCommon.preambleInfo.numberOfRA_Preambles;

    if ( p_asn1_cc->rach_ConfigCommon.preambleInfo.m.
            preamblesGroupAConfigPresent)
    {
        p_rrm_cc->rach_config_common.preamble_info.presence_bitmask |= 
            PREAMBLE_INFO_GROUP_A_CONFIG_PRESENCE_FLAG;
        p_rrm_cc->rach_config_common.preamble_info.
            preambles_group_a_config.ra_preambles_group_a_size = 
            (U8)(p_asn1_cc->rach_ConfigCommon.preambleInfo.preamblesGroupAConfig.
            sizeOfRA_PreamblesGroupA) ;

        p_rrm_cc->rach_config_common.preamble_info.
            preambles_group_a_config.group_a_msg_size =
            (U8)(p_asn1_cc->rach_ConfigCommon.preambleInfo.
            preamblesGroupAConfig.messageSizeGroupA) ;

        p_rrm_cc->rach_config_common.preamble_info.preambles_group_a_config.
            group_b_msg_power_offset = (U8)(p_asn1_cc->rach_ConfigCommon.
            preambleInfo.preamblesGroupAConfig.messagePowerOffsetGroupB);

    }

    /* -- rach_Configuration/powerRampingParameters */  
    p_rrm_cc->rach_config_common.power_ramping_params.
        power_ramping_step = (U8)(p_asn1_cc->rach_ConfigCommon.
        powerRampingParameters.powerRampingStep);

    p_rrm_cc->rach_config_common.power_ramping_params.
        preamble_init_rec_target_pow = (U8)(p_asn1_cc->rach_ConfigCommon.
        powerRampingParameters.preambleInitialReceivedTargetPower); 

    /* -- rach_Configuration/ra_SupervisionInformation */ 
    p_rrm_cc->rach_config_common.ra_supervision_info.
        preamble_trans_max = (U8)(p_asn1_cc->rach_ConfigCommon.
        ra_SupervisionInfo.preambleTransMax); 

    p_rrm_cc->rach_config_common.ra_supervision_info.
        ra_resp_win_size = (U8)(p_asn1_cc->rach_ConfigCommon.
        ra_SupervisionInfo.ra_ResponseWindowSize);

    p_rrm_cc->rach_config_common.ra_supervision_info.
        mac_cont_resol_timer = (U8)(p_asn1_cc->rach_ConfigCommon.
        ra_SupervisionInfo.mac_ContentionResolutionTimer);

    p_rrm_cc->rach_config_common.max_harq_msg_3_tx = 
        p_asn1_cc->rach_ConfigCommon.maxHARQ_Msg3Tx;

    /* - bcch_Configuration */
    p_rrm_cc->bcch_config.mod_period_coeff = 
        (U8)p_asn1_cc->bcch_Config.modificationPeriodCoeff;

    /* - pcch_Configuration */
    p_rrm_cc->pcch_config.default_paging_cycle = 
        (U8)p_asn1_cc->pcch_Config.defaultPagingCycle;

    p_rrm_cc->pcch_config.nb = (U8)p_asn1_cc->pcch_Config.nB;

    /* - prach_Configuration */
    p_rrm_cc->prach_config_sib.root_seq_index = 
        p_asn1_cc->prach_Config.rootSequenceIndex ;

    /* -- prach_Configuration/prach_ConfigInfo */
    p_rrm_cc->prach_config_sib.prach_config_info.prach_config_index =
        p_asn1_cc->prach_Config.prach_ConfigInfo.prach_ConfigIndex;

    p_rrm_cc->prach_config_sib.prach_config_info.high_speed_flag = 
        p_asn1_cc->prach_Config.prach_ConfigInfo.highSpeedFlag;

    p_rrm_cc->prach_config_sib.prach_config_info.zero_cor_zone_config =
        p_asn1_cc->prach_Config.prach_ConfigInfo.zeroCorrelationZoneConfig;

    p_rrm_cc->prach_config_sib.prach_config_info.prach_freq_offset =
        p_asn1_cc->prach_Config.prach_ConfigInfo.prach_FreqOffset;

    /* - pdsch_Configuration */
    p_rrm_cc->pdsch_config_common.ref_signal_power = 
        p_asn1_cc->pdsch_ConfigCommon.referenceSignalPower;

    p_rrm_cc->pdsch_config_common.pb = p_asn1_cc->pdsch_ConfigCommon.p_b;

    /* - pusch_Configuration */

    /* -- pusch_Configuration/pusch_ConfigBasic */
    p_rrm_cc->pusch_config_common.pusch_config_basic.nsb =
        p_asn1_cc->pusch_ConfigCommon.pusch_ConfigBasic.n_SB;

    p_rrm_cc->pusch_config_common.pusch_config_basic.hopping_mode =
        (U8)p_asn1_cc->pusch_ConfigCommon.pusch_ConfigBasic.hoppingMode ;

    p_rrm_cc->pusch_config_common.pusch_config_basic.pusch_hopping_offset = 
        p_asn1_cc->pusch_ConfigCommon.pusch_ConfigBasic.pusch_HoppingOffset;

    p_rrm_cc->pusch_config_common.pusch_config_basic.enable_64_qam =
        p_asn1_cc->pusch_ConfigCommon.pusch_ConfigBasic.enable64QAM;

    /* -- pusch_Configuration/ul_ReferenceSignalsPUSCH */
    p_rrm_cc->pusch_config_common.ul_ref_signals_pusch.
        group_hopping_enabled = p_asn1_cc->pusch_ConfigCommon.
        ul_ReferenceSignalsPUSCH.groupHoppingEnabled; 

    p_rrm_cc->pusch_config_common.ul_ref_signals_pusch.
        group_assign_pusch = p_asn1_cc->pusch_ConfigCommon.
        ul_ReferenceSignalsPUSCH.groupAssignmentPUSCH;

    p_rrm_cc->pusch_config_common.ul_ref_signals_pusch.
        seq_hopping_enabled = p_asn1_cc->pusch_ConfigCommon.
        ul_ReferenceSignalsPUSCH.sequenceHoppingEnabled ;

    p_rrm_cc->pusch_config_common.ul_ref_signals_pusch.
        cyclic_shift = p_asn1_cc->pusch_ConfigCommon.
        ul_ReferenceSignalsPUSCH.cyclicShift;

    /* - pucch_Configuration */
    p_rrm_cc->pucch_config_common.delta_pucch_shift =
        (U8)p_asn1_cc->pucch_ConfigCommon.deltaPUCCH_Shift;

    p_rrm_cc->pucch_config_common.n_rb_cqi =
        p_asn1_cc->pucch_ConfigCommon.nRB_CQI ;

    p_rrm_cc->pucch_config_common.n_cs_an =
        p_asn1_cc->pucch_ConfigCommon.nCS_AN ;

    p_rrm_cc->pucch_config_common.n_one_pucch_an =
        p_asn1_cc->pucch_ConfigCommon.n1PUCCH_AN ;

    /* - soundingRS_UL_ConfigCommon */
    if ( p_asn1_cc->soundingRS_UL_ConfigCommon.t == 
            T_SoundingRS_UL_ConfigCommon_setup) 
    {
        p_rrm_cc->sounding_rs_ul_config_common.presence_bitmask |= 
            SOUNDING_RS_UL_CONFIG_COMMON_SETUP_PRESENCE_FLAG;

       if (PNULL == p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup)
        {
            /* Not enough memory */
            return RRC_FAILURE;
        }

        p_rrm_cc->sounding_rs_ul_config_common.setup.
            srs_bw_config = (U8)(p_asn1_cc->soundingRS_UL_ConfigCommon.
            u.setup->srs_BandwidthConfig);

        p_rrm_cc->sounding_rs_ul_config_common.setup.
            srs_subframe_config = (U8)(p_asn1_cc->soundingRS_UL_ConfigCommon.
            u.setup->srs_SubframeConfig) ;

        p_rrm_cc->sounding_rs_ul_config_common.setup.
            ack_nack_srs_simul_trans = p_asn1_cc->soundingRS_UL_ConfigCommon
            .u.setup->ackNackSRS_SimultaneousTransmission;

        if ( p_asn1_cc->soundingRS_UL_ConfigCommon.u.setup->
                m.srs_MaxUpPtsPresent)
        {
            p_rrm_cc->sounding_rs_ul_config_common.setup.
                presence_bitmask |= 
                SOUNDING_RS_UL_CONFIG_COMMON_SETUP_SRS_MAX_UP_PTS_PRESENCE_FLAG;
            p_rrm_cc->sounding_rs_ul_config_common.setup.
                srs_max_up_pts =          
                (U8)(p_asn1_cc->soundingRS_UL_ConfigCommon.
                u.setup->srs_MaxUpPts);
        }
    }
    /* - uplinkPowerControl */
    p_rrm_cc->uplink_power_control_common.p_zero_nominal_Pusch =
        p_asn1_cc->uplinkPowerControlCommon.p0_NominalPUSCH;

    p_rrm_cc->uplink_power_control_common.alpha =
        (U8)p_asn1_cc->uplinkPowerControlCommon.alpha;

    p_rrm_cc->uplink_power_control_common.p_zero_nominal_pucch =
        p_asn1_cc->uplinkPowerControlCommon.p0_NominalPUCCH ;

    p_rrm_cc->uplink_power_control_common.delta_preamble_msg_three =
        p_asn1_cc->uplinkPowerControlCommon.deltaPreambleMsg3;

    /* -- uplinkPowerControl/deltaFList_PUCCH */
    p_rrm_cc->uplink_power_control_common.delta_f_list_pucch.
        delta_f_pucch_format_one = (U8)(p_asn1_cc->uplinkPowerControlCommon.
        deltaFList_PUCCH.deltaF_PUCCH_Format1);

    p_rrm_cc->uplink_power_control_common.delta_f_list_pucch.
        delta_f_pucch_format_one_b = (U8)(p_asn1_cc->uplinkPowerControlCommon.
        deltaFList_PUCCH.deltaF_PUCCH_Format1b);

    p_rrm_cc->uplink_power_control_common.delta_f_pucch_format_two.
        delta_f_pucch_format_two = (U8)(p_asn1_cc->uplinkPowerControlCommon.
        deltaFList_PUCCH.deltaF_PUCCH_Format2) ;

    p_rrm_cc->uplink_power_control_common.delta_f_pucch_format_two.
        delta_f_pucch_format_two_a = (U8)(p_asn1_cc->uplinkPowerControlCommon.
        deltaFList_PUCCH.deltaF_PUCCH_Format2a); 

    p_rrm_cc->uplink_power_control_common.delta_f_pucch_format_two.
        delta_f_pucch_format_two_b = (U8)(p_asn1_cc->uplinkPowerControlCommon.
        deltaFList_PUCCH.deltaF_PUCCH_Format2b);

    p_rrm_cc->ul_cyc_prefix_len =  (U8)p_asn1_cc->ul_CyclicPrefixLength;
    
    
    if ((p_asn1_cc->m._v2ExtPresent == 1) &&
            (p_asn1_cc->m.uplinkPowerControlCommon_v1020Present == 1))
    {
        p_rrm_cc->presence_bitmask |= RRC_CONFIG_COMMON_SIB_POWER_CONTROL_CMN_V1020;

        p_rrm_cc->uplink_power_control_common_v1020.pucch_format3_r10 = 
            p_asn1_cc->uplinkPowerControlCommon_v1020.deltaF_PUCCH_Format3_r10;

        p_rrm_cc->uplink_power_control_common_v1020.pucch_format1_bcs_r10 =
            p_asn1_cc->uplinkPowerControlCommon_v1020.deltaF_PUCCH_Format1bCS_r10;
    }
    
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
*   FUNCTION NAME: fill_rrm_subframe_config
*   INPUT        : mbsfn_subframe_config_list_t    *p_rrm_sc
*                  MBSFN_SubframeConfigList        *p_asn1_sc
*                  uecc_ue_context_t               *p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function converts 
*       MBSFN_SubframeConfiguration to mbsfn_subframe_config_list_t
*       and checks whether input data are valid.
*
*   RETURNS:
*       RRC_SUCCESS - all data are valid
*       RRC_FAILURE - data are invalid 
*
******************************************************************************/
static rrc_return_et fill_rrm_subframe_config
(
    mbsfn_subframe_config_list_t    *p_rrm_sc,           /* source */
    MBSFN_SubframeConfigList        *p_asn1_sc,     /* destination */
    uecc_ue_context_t               *p_uecc_ue_context
)
{
    rrc_counter_t subframe_index                        = RRC_NULL;
    MBSFN_SubframeConfig                *p_asn1_sc_elem = PNULL;
    OSRTDListNode *p_asn1_list_node                     = PNULL;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    RRC_ASSERT(PNULL != p_asn1_sc);
    RRC_ASSERT(PNULL != p_rrm_sc);

    if ((p_asn1_sc->count > ARRSIZE(p_rrm_sc->mbsfn_subframe_config)) 
            || (p_asn1_sc->count > MAX_MBSFN_SUBFRAME_CONFIG))
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
            (p_uecc_ue_context->p_gb_context)->facility_name,
            RRC_WARNING,
            "Incorrect subframe config list count=%u. Should be 1..min(RRM=%u,"
             " ASN.1=%u)",
            p_asn1_sc->count,
            ARRSIZE(p_rrm_sc->mbsfn_subframe_config),
            MAX_MBSFN_SUBFRAME_CONFIG);
        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
        return RRC_FAILURE;
    }

    /* Fill MBSFN_SubframeConfiguration */
    p_rrm_sc->count = (U8)p_asn1_sc->count;
    p_asn1_list_node = p_asn1_sc->head;

    for (subframe_index = 0; subframe_index < p_rrm_sc->count; subframe_index++)
    {
        RRC_ASSERT(PNULL != p_asn1_list_node);
        RRC_ASSERT(PNULL != p_asn1_list_node->data);

        p_asn1_sc_elem =  (MBSFN_SubframeConfig*)p_asn1_list_node->data;

        /* Fill MBSFN_SubframeConfiguration_element */
        p_rrm_sc->mbsfn_subframe_config[subframe_index].
            radio_frame_alloc_period=
            (U8)p_asn1_sc_elem->radioframeAllocationPeriod ;

        p_rrm_sc->mbsfn_subframe_config[subframe_index].  
            radio_frame_alloc_offset=
            p_asn1_sc_elem->radioframeAllocationOffset ;

        /* - subframeAllocation */

        if (p_asn1_sc_elem->subframeAllocation.t ==
                T_MBSFN_SubframeConfig_subframeAllocation_oneFrame)
        {
            p_rrm_sc->mbsfn_subframe_config[subframe_index].
                subframe_allocation.presence_bitmask |= 
                SUBFRAME_ALLOCATION_ONE_FRAME;

            if (!p_asn1_sc_elem->subframeAllocation.u.oneFrame)
            {    
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                    (p_uecc_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,
                    "p_asn1_sc_elem->subframeAllocation.u.oneFrame is null!!");
                return RRC_FAILURE;
            }

            l3_memcpy_wrapper(p_rrm_sc->mbsfn_subframe_config[subframe_index].
                    subframe_allocation.one_frame,
                    p_asn1_sc_elem->subframeAllocation.u.oneFrame->data,
                sizeof(p_rrm_sc->mbsfn_subframe_config[subframe_index].
                    subframe_allocation.one_frame));
        }
        else if (p_asn1_sc_elem->subframeAllocation.t ==
                T_MBSFN_SubframeConfig_subframeAllocation_fourFrames )
        {
            p_rrm_sc->mbsfn_subframe_config[subframe_index].
                subframe_allocation.
                presence_bitmask |= SUBFRAME_ALLOCATION_FOUR_FRAMES ;

            if (!p_asn1_sc_elem->subframeAllocation.u.fourFrames)
            {
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                    "p_asn1_sc_elem->subframeAllocation.u.fourFrames is null!!");
                return RRC_FAILURE;
            }

            l3_memcpy_wrapper(
                    p_rrm_sc->mbsfn_subframe_config[subframe_index].
                    subframe_allocation.four_frames,
                    p_asn1_sc_elem->subframeAllocation.u.fourFrames->data,
                    sizeof(p_rrm_sc->mbsfn_subframe_config[subframe_index].
                        subframe_allocation.four_frames));
        }
        else
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "Incorrect subframe_allocation.presence_bitmask=%u",
                p_rrm_sc->mbsfn_subframe_config[subframe_index].
                subframe_allocation.
                    presence_bitmask);
            RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
            return RRC_FAILURE;
        }

        p_asn1_list_node = p_asn1_list_node->next; 
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return RRC_SUCCESS;
}



/******************************************************************************
 *   FUNCTION NAME: uecc_rrm_build_and_send_handover_command
 *   INPUT        : uecc_ue_context_t   *p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:    This is the function for building and sending
 *                   RRC_RRM_UE_ADMISSION_REQ message to the RRM.
 *
 *   RETURNS:        None
 *
 ******************************************************************************/
rrc_return_t uecc_rrm_build_and_send_handover_command(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_rrm_ue_ho_command_request_t *p_rrc_rrm_ue_ho_command_request = PNULL;
    rrc_return_et                   result = RRC_FAILURE;
    uecc_s1_src_ho_info_t           *p_s1_src_ho_info = PNULL;
    rrc_counter_t                   erab_id = 0, erab_cnt= 0;
    uecc_e_rab_failed_to_add_list_t erab_failed_list; 
    uecc_e_rab_not_admitted_to_add_list_t  erab_not_admitted_list; 
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_rrc_rrm_ue_ho_command_request = rrc_mem_get(sizeof(rrc_rrm_ue_ho_command_request_t));

    if (PNULL == p_rrc_rrm_ue_ho_command_request)
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,
                "[uecc_rrm_build_and_send_handover_command] rrc_mem_get failed.");
        return RRC_FAILURE;
    }

    /* SES-508 Fix Start */
    /* Code Removed */
    /* SES-508 Fix End */

    /* Fill message */
    /* ue_index */
    p_rrc_rrm_ue_ho_command_request->ue_index = p_uecc_ue_context->ue_index;

    p_s1_src_ho_info = &(p_uecc_ue_context->ho_info.p_ho_info->
            p_src_ho_info->s1_src_ho_info);
    if ( S1_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover )
    {
      if(p_s1_src_ho_info->bitmask &
          ERAB_SUBJECT_TO_DATA_FORWARDING_LIST_PRESENT)
      {
        p_rrc_rrm_ue_ho_command_request->bitmask 
          |= RRC_RRM_UE_HO_CMD_REQ_ERAB_SUB_TO_FORWARD_LIST_PRESENT;
        /* filling the erab_id */
        for(erab_id =0,erab_cnt=0; erab_id < MAX_ERAB_COUNT; erab_id++)
        {
          if(p_s1_src_ho_info->src_drb_fwd_list.
              erab_ho_src_drb_forward_list[erab_id])
          {

            p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
              drb_sub_to_fwd[erab_cnt].erab_id = (U8)erab_id;
            p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
              drb_sub_to_fwd[erab_cnt].forward_direction = 
              p_s1_src_ho_info->src_drb_fwd_list.
              erab_ho_src_drb_forward_list[erab_id]->forward_direction; 
            erab_cnt++;
          }
        }
        p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.erab_count 
          = (U8)erab_cnt;
      }
      if(p_s1_src_ho_info->bitmask & E_RAB_FAILED_LIST_PRESENT )
      {
        p_rrc_rrm_ue_ho_command_request->bitmask 
          |= RRC_RRM_UE_HO_CMD_REQ_ERAB_TO_RELEASE_LIST_PRESENT;
        /*filling erab_to_release_list */
        erab_failed_list = p_s1_src_ho_info->erab_failed_list; 
        for (erab_cnt = 0; erab_cnt < erab_failed_list.count; erab_cnt++ )
        {
          /* filling erab_id */
          p_rrc_rrm_ue_ho_command_request->erab_to_release_list.
            erab_to_release[erab_cnt].erab_id =
            (U16)erab_failed_list.e_rab_failed_to_add_list[erab_cnt].e_rab_id;
          /* filling failure cause */
          uecc_rrm_build_rrm_cause(&p_rrc_rrm_ue_ho_command_request->
              erab_to_release_list.erab_to_release[erab_cnt].rrm_cause,
              &erab_failed_list.e_rab_failed_to_add_list[erab_cnt].cause,
              p_uecc_ue_context);
        }
        p_rrc_rrm_ue_ho_command_request->erab_to_release_list.erab_count = (U8)erab_cnt;
      }

      /*  filling NAS_SECURITY INFO (In case of Handover to UTRAN/GERAN) */
      if((HANDOVER_TYPE_LTE_TO_UTRAN == p_s1_src_ho_info->p_rrc_rrm_ho_required->ho_type)
          || (HANDOVER_TYPE_LTE_TO_GERAN == p_s1_src_ho_info->p_rrc_rrm_ho_required->ho_type))
      {
        p_rrc_rrm_ue_ho_command_request->nas_security_param.nas_msg_length
          = p_s1_src_ho_info->inter_rat_ho_info.nas_security_param_from_E_UTRAN_numocts;
        l3_memcpy_wrapper(p_rrc_rrm_ue_ho_command_request->nas_security_param.nas_security_param,
            p_s1_src_ho_info->inter_rat_ho_info.p_nas_security_param_from_E_UTRAN_data,
            p_rrc_rrm_ue_ho_command_request->nas_security_param.nas_msg_length);
        p_rrc_rrm_ue_ho_command_request->bitmask |= RRC_RRM_UE_HO_CMD_REQ_NAS_SECURITY_PARAM_PRESENT;

        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
            (p_uecc_ue_context->p_gb_context)->facility_name,
            RRC_INFO, "NAS Security is successfully filled"
            "in case of inter RAT HO");

      }
    }
    else if ((X2_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover) ||
             (INTER_CELL_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover))
    {
      if(p_s1_src_ho_info->bitmask &
          X2AP_ERAB_ADMITTED_LIST_PRESENT)
      {
        /* filling the erab_id */
        for(erab_id =0,erab_cnt=0; erab_id < MAX_ERAB_COUNT; erab_id++)
        {
          if((p_s1_src_ho_info->src_erab_admitted_list.
              erab_ho_src_drb_admitted_info[erab_id]) &&
              (UECC_FORWARDING_DIRECTION_ABSENT != 
                p_s1_src_ho_info->src_erab_admitted_list.
                 erab_ho_src_drb_admitted_info[erab_id]->forward_direction))
          {
            p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
              drb_sub_to_fwd[erab_cnt].erab_id = (U8)erab_id;
            p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
              drb_sub_to_fwd[erab_cnt].forward_direction = 
              p_s1_src_ho_info->src_erab_admitted_list.
              erab_ho_src_drb_admitted_info[erab_id]->forward_direction; 
             /*CR 764 changes start*/
            if (p_s1_src_ho_info->src_erab_admitted_list.
                erab_ho_src_drb_admitted_info[erab_id]->forward_direction ==
                    UECC_FORWARDING_DIRECTION_DL)
            {
                p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].bitmask |= 
                    ERAB_SUB_TO_FORWARD_LIST_DL_GTP_TUNNEL_END_POINT_PRESENT;
               
                if (!(p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->dl_gtp_tunnel_end_point.
                    transportLayerAddress.numbits % RRC_OCTET_SIZE))
                { 
                    p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].dl_transport_layer_address.
                    length = (U8)(p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->dl_gtp_tunnel_end_point.
                    transportLayerAddress.numbits/RRC_OCTET_SIZE); 
                }
                else
                {
                    p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].dl_transport_layer_address.
                    length = (U8)((p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->dl_gtp_tunnel_end_point.
                    transportLayerAddress.numbits/RRC_OCTET_SIZE) + 1); 
                    
                }
                
                l3_memcpy_wrapper(p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].dl_transport_layer_address.data, 
                    p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->dl_gtp_tunnel_end_point.
                    transportLayerAddress.data,
                    p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].dl_transport_layer_address.length);
            }
            else if (p_s1_src_ho_info->src_erab_admitted_list.
                erab_ho_src_drb_admitted_info[erab_id]->forward_direction ==
                    UECC_FORWARDING_DIRECTION_UL)
            {
                p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].bitmask |=
                ERAB_SUB_TO_FORWARD_LIST_UL_GTP_TUNNEL_END_POINT_PRESENT;
                
                if (!(p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->ul_gtp_tunnel_end_point.
                    transportLayerAddress.numbits % RRC_OCTET_SIZE))
                {
                    p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].ul_transport_layer_address.length = 
                    (U8)(p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->ul_gtp_tunnel_end_point.
                    transportLayerAddress.numbits/RRC_OCTET_SIZE);
                }
                else
                {
                    p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].ul_transport_layer_address.length = 
                    (U8)((p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->ul_gtp_tunnel_end_point.
                    transportLayerAddress.numbits/RRC_OCTET_SIZE) + 1);
                }
    
                l3_memcpy_wrapper(p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].ul_transport_layer_address.data,
                    p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->ul_gtp_tunnel_end_point.
                    transportLayerAddress.data,
                    p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].ul_transport_layer_address.length);
            }
            else if (p_s1_src_ho_info->src_erab_admitted_list.
                erab_ho_src_drb_admitted_info[erab_id]->forward_direction ==
                    UECC_FORWARDING_DIRECTION_BOTH)
            {
                p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].bitmask |= 
                    ERAB_SUB_TO_FORWARD_LIST_DL_GTP_TUNNEL_END_POINT_PRESENT;
                
                if (!(p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->dl_gtp_tunnel_end_point.
                    transportLayerAddress.numbits % RRC_OCTET_SIZE))
                { 
                    p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].dl_transport_layer_address.
                    length = (U8)(p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->dl_gtp_tunnel_end_point.
                    transportLayerAddress.numbits/RRC_OCTET_SIZE); 
                }
                else
                {
                    p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].dl_transport_layer_address.
                    length = (U8)((p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->dl_gtp_tunnel_end_point.
                    transportLayerAddress.numbits/RRC_OCTET_SIZE) + 1); 
                    
                }
                
                l3_memcpy_wrapper(p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].dl_transport_layer_address.data, 
                    p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->dl_gtp_tunnel_end_point.
                    transportLayerAddress.data,
                    p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].dl_transport_layer_address.length);
                
                p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].bitmask |=
                ERAB_SUB_TO_FORWARD_LIST_UL_GTP_TUNNEL_END_POINT_PRESENT;

                if (!(p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->ul_gtp_tunnel_end_point.
                    transportLayerAddress.numbits % RRC_OCTET_SIZE))
                {
                    p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].ul_transport_layer_address.length = 
                    (U8)(p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->ul_gtp_tunnel_end_point.
                    transportLayerAddress.numbits/RRC_OCTET_SIZE);
                }
                else
                {
                    p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].ul_transport_layer_address.length = 
                    (U8)((p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->ul_gtp_tunnel_end_point.
                    transportLayerAddress.numbits/RRC_OCTET_SIZE) + 1);
                }
    
                l3_memcpy_wrapper(p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].ul_transport_layer_address.data,
                    p_s1_src_ho_info->src_erab_admitted_list.
                    erab_ho_src_drb_admitted_info[erab_id]->ul_gtp_tunnel_end_point.
                    transportLayerAddress.data,
                    p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].ul_transport_layer_address.length);
            }
            /*CR 764 changes stop*/
            erab_cnt++;
          }
          if ( erab_cnt > 0 )
          {
              p_rrc_rrm_ue_ho_command_request->bitmask 
                  |= RRC_RRM_UE_HO_CMD_REQ_ERAB_SUB_TO_FORWARD_LIST_PRESENT;
          }
        }
        p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.erab_count 
          = (U8)erab_cnt;

      }
      if(p_s1_src_ho_info->bitmask & X2AP_ERAB_NOT_ADMITTED_LIST_PRESENT )
      {
        p_rrc_rrm_ue_ho_command_request->bitmask 
          |= RRC_RRM_UE_HO_CMD_REQ_ERAB_TO_RELEASE_LIST_PRESENT;
        /*filling erab_to_release_list */
        erab_not_admitted_list = p_s1_src_ho_info->erab_not_admitted_list; 
        for (erab_cnt = 0; erab_cnt < erab_not_admitted_list.count; erab_cnt++ )
        {
          /* filling erab_id */
          p_rrc_rrm_ue_ho_command_request->erab_to_release_list.
            erab_to_release[erab_cnt].erab_id =
            (U16)erab_not_admitted_list.e_rab_not_admitted_to_add_list[erab_cnt].e_rab_id;
          /* filling failure cause */
          /*uecc_rrm_build_rrm_cause(&p_rrc_rrm_ue_ho_command_request->
              erab_to_release_list.erab_to_release[erab_cnt].rrm_cause,
              &erab_not_admitted_list.e_rab_not_admitted_to_add_list[erab_cnt].cause);*/
          uecc_rrm_build_rrm_x2ap_cause(&p_rrc_rrm_ue_ho_command_request->
              erab_to_release_list.erab_to_release[erab_cnt].rrm_cause,
              &erab_not_admitted_list.e_rab_not_admitted_to_add_list[erab_cnt].cause,
              p_uecc_ue_context);
        }
        p_rrc_rrm_ue_ho_command_request->erab_to_release_list.erab_count = (U8)erab_cnt;
      }
    }
    /*BUG 604 changes start*/
    else if(INTRA_CELL_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover)
    {
        /* filling the erab_id */
        for(erab_id = RRC_NULL, erab_cnt = RRC_NULL; erab_id < MAX_ERAB_COUNT; erab_id++)
        {
            if ((p_s1_src_ho_info->src_erab_admitted_list.erab_ho_src_drb_admitted_info[erab_id])
                    &&(p_uecc_ue_context->p_e_rab_list[erab_id]->drb_config.
                        rlc_config_enb.rlc_config.bitmask & RRC_RLC_CONFIG_AM_CONFIG_PRESENT))
            {
                p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].erab_id = (U8)erab_id;
                p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.
                    drb_sub_to_fwd[erab_cnt].forward_direction = 
                    UECC_FORWARDING_DIRECTION_BOTH;
                
                erab_cnt++;
            }
        }
        if ( erab_cnt > RRC_NULL )
        {
            p_rrc_rrm_ue_ho_command_request->bitmask 
                |= RRC_RRM_UE_HO_CMD_REQ_ERAB_SUB_TO_FORWARD_LIST_PRESENT;
        }
        p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list.erab_count 
          = (U8)erab_cnt;
    }
    /*BUG 604 changes stop*/
    /* CSFB_CDMA2000_HO start*/
    /* Filling HO_STATUS*/
    if (RRC_TRUE == p_uecc_ue_context->ho_info.cdma_ho_ongoing)
    {
        p_rrc_rrm_ue_ho_command_request->bitmask 
          |= RRC_RRM_UE_HO_CMD_REQ_CDMA2000_HO_STATUS_PRESENT;
        /* 1xrtt HO*/
        if (HANDOVER_TYPE_LTE_TO_CDMA2000_1XRTT == 
                p_s1_src_ho_info->p_rrc_rrm_ho_required->ho_type)
        {
            if (HO_SUCCESS == p_uecc_ue_context->cdma2000_info.
                dl_s1_cdma2000_tunneling_1xrtt.cdma2000_ho_status)
            {
                p_rrc_rrm_ue_ho_command_request->
                    cdma2000_ho_status[CDMA2000_1XRTT] = CDMA2000_HO_SUCCESS; 
            }
            else
            {
                p_rrc_rrm_ue_ho_command_request->
                    cdma2000_ho_status[CDMA2000_1XRTT] = CDMA2000_HO_FAILURE; 
            }
            /*set 1xrtt index to HO No Report*/
            p_rrc_rrm_ue_ho_command_request->
                cdma2000_ho_status[CDMA2000_HRPD] = CDMA2000_HO_NO_REPORT; 
        }
        /* hrpd HO*/
        if (HANDOVER_TYPE_LTE_TO_CDMA2000_HRPD == 
                p_s1_src_ho_info->p_rrc_rrm_ho_required->ho_type)
        {
            if (HO_SUCCESS == p_uecc_ue_context->cdma2000_info.
                dl_s1_cdma2000_tunneling_hrpd.cdma2000_ho_status)
            {
                p_rrc_rrm_ue_ho_command_request->
                    cdma2000_ho_status[CDMA2000_HRPD] = CDMA2000_HO_SUCCESS; 
            }
            else
            {
                p_rrc_rrm_ue_ho_command_request->
                    cdma2000_ho_status[CDMA2000_HRPD] = CDMA2000_HO_FAILURE; 
            }
            /*set hrpd index to HO No Report*/
            p_rrc_rrm_ue_ho_command_request->
                cdma2000_ho_status[CDMA2000_1XRTT] = CDMA2000_HO_NO_REPORT; 
           
        }
        /* conc hrpd-1xrtt HO*/
        if (HANDOVER_TYPE_LTE_TO_CDMA2000_CONC_1XRTT_HRPD == 
                p_s1_src_ho_info->p_rrc_rrm_ho_required->ho_type)
        {
            if ((HO_SUCCESS == p_uecc_ue_context->cdma2000_info.
                dl_s1_cdma2000_tunneling_1xrtt.cdma2000_ho_status)
                    &&
                (RRC_FALSE == p_uecc_ue_context->cdma2000_info.timer_expired_f_1xrtt))    
            {
                p_rrc_rrm_ue_ho_command_request->
                    cdma2000_ho_status[CDMA2000_1XRTT] = CDMA2000_HO_SUCCESS; 
            }
            else
            {
                p_rrc_rrm_ue_ho_command_request->
                    cdma2000_ho_status[CDMA2000_1XRTT] = CDMA2000_HO_FAILURE; 
            }
            if ((HO_SUCCESS == p_uecc_ue_context->cdma2000_info.                      
                dl_s1_cdma2000_tunneling_hrpd.cdma2000_ho_status)
                    &&
                (RRC_FALSE == p_uecc_ue_context->cdma2000_info.timer_expired_f_hrpd))   
            {
                p_rrc_rrm_ue_ho_command_request->
                    cdma2000_ho_status[CDMA2000_HRPD] = CDMA2000_HO_SUCCESS; 
            }
            else
            {
                p_rrc_rrm_ue_ho_command_request->
                    cdma2000_ho_status[CDMA2000_HRPD] = CDMA2000_HO_FAILURE; 
            }
        }
    }
    /* CSFB_CDMA2000_HO stop*/

    /* Encode and send message */
    result = rrc_rrm_il_send_rrc_rrm_ue_ho_command_request(
            p_rrc_rrm_ue_ho_command_request,
            RRC_UECC_MODULE_ID,
            RRC_RRM_MODULE_ID,
            uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context),
            p_uecc_ue_context->cell_index);

    if (p_rrc_rrm_ue_ho_command_request)
    {
        rrc_mem_free(p_rrc_rrm_ue_ho_command_request);
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_rrm_build_and_send_ho_failure
 *   INPUT        : uecc_ue_context_t   *p_uecc_ue_context
 *   OUTPUT       : none
 *   DESCRIPTION:    This is the function for building and sending
 *                   RRC_RRM_HO_FAILURE message to the RRM.
 *
 *   RETURNS:        None
 *
 ******************************************************************************/
rrc_return_t uecc_rrm_build_and_send_ho_failure(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
        )
{
    rrc_rrm_ho_failure_t *p_rrc_rrm_ho_failure = PNULL;
    rrc_return_et        result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    
    p_rrc_rrm_ho_failure = rrc_mem_get(sizeof(rrc_rrm_ho_failure_t));

    if (PNULL == p_rrc_rrm_ho_failure)
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,
                "[uecc_rrm_build_and_send_ho_failure] rrc_mem_get failed.");
        return RRC_FAILURE;
    }

    /* SES-508 Fix Start */
    /* Code Removed */
    /* SES-508 Fix End */

    /* Fill message */
    /* ue_index */
    p_rrc_rrm_ho_failure->ue_index = p_uecc_ue_context->ue_index;

    /* filling rrm_cause using s1ap_cause received in ue_context*/
    /*BUG 604 changes start*/
    if ((X2_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover) ||
            (INTER_CELL_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover)||
            (INTRA_CELL_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover))
    /*BUG 604 changes stop*/
    {
        uecc_rrm_build_rrm_x2ap_cause(&p_rrc_rrm_ho_failure->rrm_cause,
                &p_uecc_ue_context->ho_info.x2ap_cause,
                p_uecc_ue_context);
    }
    else
    {
        if(S1_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover)
        {

            uecc_rrm_build_rrm_cause(&p_rrc_rrm_ho_failure->rrm_cause,
                    &p_uecc_ue_context->ho_info.cause, p_uecc_ue_context);
        }
/*BUG 604 changes start*/
/*BUG 604 changes stop*/
        else if (CCO_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover)
        {
            p_rrc_rrm_ho_failure->rrm_cause.type = T_s1ap_Cause_radioNetwork;
            p_rrc_rrm_ho_failure->rrm_cause.value = s1ap_unspecified_2;
        }
        /* Bug 817 Fix Start */
        else if (INVALID_HO == p_uecc_ue_context->ho_info.s1_or_x2_handover)
        {
            p_rrc_rrm_ho_failure->rrm_cause.type = T_s1ap_Cause_radioNetwork;
            p_rrc_rrm_ho_failure->rrm_cause.value = s1ap_interaction_with_other_procedure;
        }
        /* Bug 817 Fix Stop */
    }
    /* Encode and send message */
    result = rrc_rrm_il_send_rrc_rrm_ho_failure(
            p_rrc_rrm_ho_failure,
            RRC_UECC_MODULE_ID,
            RRC_RRM_MODULE_ID,
            uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context),
            p_uecc_ue_context->cell_index);

    if (p_rrc_rrm_ho_failure)
    {
        rrc_mem_free(p_rrc_rrm_ho_failure);
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
 *   FUNCTION NAME: uecc_rrm_build_and_send_ho_cancel_resp
 *   INPUT        : uecc_ue_context_t   *p_uecc_ue_context
 *                  rrc_return_et       response
 *   OUTPUT       : none
 *   DESCRIPTION:    This is the function for building and sending
 *                   RRC_RRM_HO_CANCEL_RESP message to the RRM.
 *
 *   RETURNS:        None
 *
 ******************************************************************************/
rrc_return_t uecc_rrm_build_and_send_ho_cancel_resp(
        uecc_ue_context_t   *p_uecc_ue_context,      /* UECC UE context */
        rrc_return_et       response
        )
{
    rrc_rrm_ho_cancel_resp_t rrc_rrm_ho_cancel_resp;
    rrc_return_et        result = RRC_FAILURE;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /*reset */
    memset_wrapper(&rrc_rrm_ho_cancel_resp, 0,
            sizeof(rrc_rrm_ho_cancel_resp_t));
       
    /* Fill message */

    /* ue_index */
    rrc_rrm_ho_cancel_resp.ue_index = p_uecc_ue_context->ue_index;
    

    /* rrm_cause */
    rrc_rrm_ho_cancel_resp.response = response;

    /* Encode and send message */
    result = rrc_rrm_il_send_rrc_rrm_ho_cancel_resp(
            &rrc_rrm_ho_cancel_resp,
            RRC_UECC_MODULE_ID,
            RRC_RRM_MODULE_ID,
            uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context),
            p_uecc_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}




/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_result_geran
*   INPUT        : uecc_ue_context_t       *p_ue_context,
*                  meas_result_geran_t*    p_meas_result_geran,
*                  MeasResultGERAN*        p_asn_meas_result_geran
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds meas_result_geran_t in
*       RRC_RRM_MEASURMENT_RESULTS_IND message
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_result_geran(
     uecc_ue_context_t       *p_ue_context,
     meas_result_geran_t*    p_meas_result_geran,
     MeasResultGERAN*        p_asn_meas_result_geran
)
{
	/* coverity_fix_54693_start */
	rrc_return_et   result = RRC_SUCCESS;   

	RRC_ASSERT(PNULL != p_meas_result_geran);
	RRC_ASSERT(PNULL != p_asn_meas_result_geran);

	/*SPR 15896 Fix Start*/
	P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"CarrierFreqGERAN\">");
	/*SPR 15896 Fix Stop*/
	/* Fill Carrier Frequency */
	p_meas_result_geran->carrier_freq.arfcn = 
		p_asn_meas_result_geran->carrierFreq.arfcn;
	/*SPR 15896 Fix Start*/
	P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"ARFCN-ValueGERAN\">%d</ie>",p_meas_result_geran->carrier_freq.arfcn);
	/*SPR 15896 Fix Stop*/

	p_meas_result_geran->carrier_freq.band_indicator = 
		(U8)p_asn_meas_result_geran->carrierFreq.bandIndicator;
	/*SPR 15896 Fix Start*/
	if ( p_ue_context->m.traceActivated)
	{
		P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"BandIndicatorGERAN\">%d</ie>",p_meas_result_geran->carrier_freq.band_indicator);
		P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup>");//CarrierFreqGERAN
		/*SPR 15896 Fix Stop*/
	}

	/*SPR 15896 Fix Start*/
	P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"PhysCellIdGERAN\">");
	/*SPR 15896 Fix Stop*/
	/* Fill Physical Cell ID */
	p_meas_result_geran->phys_cell_id.network_colour_code = 
		p_asn_meas_result_geran->physCellId.networkColourCode.data[0] >> 5;
	/*SPR 15896 Fix Start*/
	P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"NetworkColourCode\">%d</ie>",p_meas_result_geran->phys_cell_id.network_colour_code); 
	/*SPR 15896 Fix Stop*/

	p_meas_result_geran->phys_cell_id.base_station_colour_code = 
		p_asn_meas_result_geran->physCellId.baseStationColourCode.data[0] >> 5;
	/*SPR 15896 Fix Start*/
	if ( p_ue_context->m.traceActivated)
	{
		P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"BaseStationColourCode\">%d</ie>",p_meas_result_geran->phys_cell_id.base_station_colour_code);
		P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup>");//PhysCellIdGERAN
		/*SPR 15896 Fix Stop*/
	}

	/* Fill CGI Info If present */ 
	if (p_asn_meas_result_geran->m.cgi_InfoPresent)
	{
		/* Set Bitmask */
		p_meas_result_geran->bitmask =
			MEAS_RESULT_GERAN_CGI_INFO_PRESENT;

		/*SPR 15896 Fix Start*/
		if ( p_ue_context->m.traceActivated)
		{
			P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"Cgi-Info\">");                               
			P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"CellGlobalIdGERAN\">");                               
			/*SPR 15896 Fix Stop*/
		}
		/* Fill Cell Global ID IE*/
		if (p_asn_meas_result_geran->cgi_Info.cellGlobalId.plmn_Identity.m.mccPresent)
		{
			/* Fill PLMN IDENTITY */
			p_meas_result_geran->cgi_info.cell_global_id.plmn_identity.
				presence_bitmask = PLMN_IDENTITY_MCC_PRESENCE_FLAG;

			l3_memcpy_wrapper(p_meas_result_geran->cgi_info.cell_global_id.
					plmn_identity.mcc,
					p_asn_meas_result_geran->cgi_Info.cellGlobalId.
					plmn_Identity.mcc.elem,
					MCC_OCTET_SIZE);

			/*SPR 15896 Fix Start*/
			if ( p_ue_context->m.traceActivated)
			{
				P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"PLMN-IdentityList\"> ");
				P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MCC\">%02x%02x%02x</ie>",
						p_meas_result_geran->cgi_info.cell_global_id.plmn_identity.mcc[0],
						p_meas_result_geran->cgi_info.cell_global_id.plmn_identity.mcc[1],
						p_meas_result_geran->cgi_info.cell_global_id.plmn_identity.mcc[2]); 
				/*SPR 15896 Fix Stop*/
			}
		}     
		p_meas_result_geran->cgi_info.cell_global_id.plmn_identity.mnc.count = 
			(U8)p_asn_meas_result_geran->cgi_Info.cellGlobalId.plmn_Identity.mnc.n;

		l3_memcpy_wrapper(p_meas_result_geran->cgi_info.cell_global_id.
				plmn_identity.mnc.mnc,
				p_asn_meas_result_geran->cgi_Info.cellGlobalId.
				plmn_Identity.mnc.elem,
				p_asn_meas_result_geran->cgi_Info.cellGlobalId.
				plmn_Identity.mcc.n);

		/*SPR 15896 Fix Start*/
		if ( p_ue_context->m.traceActivated)
		{
			if(p_meas_result_geran->cgi_info.cell_global_id.plmn_identity.mnc.count == 2)
			{
				P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MNC\">%02x%02x</ie>",
						p_meas_result_geran->cgi_info.cell_global_id.plmn_identity.mnc.mnc[0],
						p_meas_result_geran->cgi_info.cell_global_id.plmn_identity.mnc.mnc[1]);
			}
			else if(p_meas_result_geran->cgi_info.cell_global_id.plmn_identity.mnc.count == 3)
			{
				P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"PLMN_Identity-MNC\">%02x%02x%02x</ie>",
						p_meas_result_geran->cgi_info.cell_global_id.plmn_identity.mnc.mnc[0],
						p_meas_result_geran->cgi_info.cell_global_id.plmn_identity.mnc.mnc[1],
						p_meas_result_geran->cgi_info.cell_global_id.plmn_identity.mnc.mnc[2]);
			}
			P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup> ");//PLMN-IdentityList
			/*SPR 15896 Fix Stop*/
		}

		/* Fill Location Area Code */
		l3_memcpy_wrapper(p_meas_result_geran->cgi_info.cell_global_id.
				location_area_code,
				p_asn_meas_result_geran->cgi_Info.cellGlobalId.
				locationAreaCode.data,
				sizeof(p_meas_result_geran->cgi_info.cell_global_id.location_area_code));

		/*SPR 15896 Fix Start*/
		P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"LocationAreaCode\">%02x%02x</ie>",
				p_meas_result_geran->cgi_info.cell_global_id.location_area_code[0],
				p_meas_result_geran->cgi_info.cell_global_id.location_area_code[1]); 
		/*SPR 15896 Fix Stop*/

		/* Fill Cell Identity */
		l3_memcpy_wrapper(p_meas_result_geran->cgi_info.cell_global_id.
				cell_identity,
				p_asn_meas_result_geran->cgi_Info.cellGlobalId.
				cellIdentity.data,
				sizeof(p_meas_result_geran->cgi_info.cell_global_id.location_area_code));

		/*SPR 15896 Fix Start*/
		if ( p_ue_context->m.traceActivated)
		{
			P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"CellIdentity\">%02x%02x</ie>",
					p_meas_result_geran->cgi_info.cell_global_id.cell_identity[0],
					p_meas_result_geran->cgi_info.cell_global_id.cell_identity[1]);
			P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup>");//CellGlobalIdGERAN                               
			/*SPR 15896 Fix Stop*/
		}

		/* Fill Routing Area Code If present */
		if (p_asn_meas_result_geran->cgi_Info.m.routingAreaCodePresent)
		{
			p_meas_result_geran->cgi_info.bitmask = 
				MEAS_RESULT_GERAN_CGI_INFO_ROUTING_AREA_CODE_PRESENT;

			p_meas_result_geran->cgi_info.routing_area_code = 
				p_asn_meas_result_geran->cgi_Info.routingAreaCode.data[0];

			/*SPR 15896 Fix Start*/
			P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"RoutingAreaCode\">%d</ie>",p_meas_result_geran->cgi_info.routing_area_code);
			/*SPR 15896 Fix Stop*/
		}

		/*SPR 15896 Fix Start*/
		P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n </ieGroup>");//Cgi-Info                               
		/*SPR 15896 Fix Stop*/
	}
	/* Fill Meas Result */
	p_meas_result_geran->meas_result.rssi = 
		p_asn_meas_result_geran->measResult.rssi;

	/*SPR 15896 Fix Start*/
	if ( p_ue_context->m.traceActivated)
	{
		P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ieGroup name=\"MeasResult\">");                               
		P_RRC_TRACE(p_ue_context, set_medium_bitmask(), UU,"\n <ie name=\"RSSI\">%d</ie>",p_meas_result_geran->meas_result.rssi);
		P_RRC_TRACE(p_ue_context,set_medium_bitmask(), UU,"\n </ieGroup>");                               
		/*SPR 15896 Fix Stop*/
	}
	RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
	return result;
}
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_result_nr
*   INPUT        : uecc_ue_context_t       *p_ue_context,
*                  meas_result_ind_nr_t*   p_meas_result_nr,
*                  MeasResultCellNR_r15*   p_asn_meas_result_nr
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds meas_result_ind_nr_t in
*       RRC_RRM_MEASURMENT_RESULTS_IND message
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_result_nr(
     uecc_ue_context_t       *p_ue_context,
     meas_result_ind_nr_t*    p_meas_result_nr,
     MeasResultCellNR_r15*    p_asn_meas_result_nr
)
{
    OSRTDListNode*  p_node = PNULL;
    U8              list_count = RRC_ZERO;
    rrc_return_et   result = RRC_SUCCESS;
    MeasResultSSB_IndexList_r15 *p_list = PNULL;
    MeasResultSSB_Index_r15  *p_elem = PNULL;

    RRC_ASSERT(PNULL != p_meas_result_nr);
    RRC_ASSERT(PNULL != p_asn_meas_result_nr);

    /* Fill phys_cell_id_r15 */
    p_meas_result_nr->phys_cell_id_r15 = 
        p_asn_meas_result_nr->pci_r15;

    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
            (p_ue_context->p_gb_context)->facility_name,
            RRC_DETAILED,
            "phys_cell_id_r15 [%u]:",
            p_meas_result_nr->phys_cell_id_r15);

    /* Fill MeasResultNR_r15 */
    /*rsrpResult_r15*/
    if(p_asn_meas_result_nr->measResultCell_r15.m.rsrpResult_r15Present)
    {
        p_meas_result_nr->meas_result_cell_r15.bitmask |= 
            THRESHOLD_LIST_NR_RSRP_PRESENT;

        p_meas_result_nr->meas_result_cell_r15.rsrp_nr_r15 =
            p_asn_meas_result_nr->measResultCell_r15.rsrpResult_r15;

        if((p_meas_result_nr->meas_result_cell_r15.rsrp_nr_r15 > 127))
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "rsrpResult_r15 [%u]:",
                    p_meas_result_nr->meas_result_cell_r15.rsrp_nr_r15);
            return RRC_FAILURE;
        }
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_DETAILED,
                "rsrpResult_r15 [%u]:",
                p_meas_result_nr->meas_result_cell_r15.rsrp_nr_r15);
    }
    /*rsrqResult_r15*/
    if(p_asn_meas_result_nr->measResultCell_r15.m.rsrqResult_r15Present)
    {
        p_meas_result_nr->meas_result_cell_r15.bitmask |= 
            THRESHOLD_LIST_NR_RSRQ_PRESENT;

        p_meas_result_nr->meas_result_cell_r15.rsrq_nr_r15 =
            p_asn_meas_result_nr->measResultCell_r15.rsrqResult_r15;

        if((p_meas_result_nr->meas_result_cell_r15.rsrq_nr_r15 > 127)) 
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "rsrqResult_r15 [%u]:",
                    p_meas_result_nr->meas_result_cell_r15.rsrq_nr_r15);
            return RRC_FAILURE;
        }
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_DETAILED,
                "rsrqResult_r15 [%u]:",
                p_meas_result_nr->meas_result_cell_r15.rsrq_nr_r15);
    }
    /*rs_sinr_Result_r15*/
    if(p_asn_meas_result_nr->measResultCell_r15.m.rs_sinr_Result_r15Present )
    {
        p_meas_result_nr->meas_result_cell_r15.bitmask |= 
            THRESHOLD_LIST_NR_SINR_PRESENT;

        p_meas_result_nr->meas_result_cell_r15.sinr_nr_r15 =
            p_asn_meas_result_nr->measResultCell_r15.rs_sinr_Result_r15;

        if((p_meas_result_nr->meas_result_cell_r15.sinr_nr_r15 > 127)) 
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_ERROR,
                    "sinr_nr_r15 [%u]:",
                    p_meas_result_nr->meas_result_cell_r15.sinr_nr_r15);
            return RRC_FAILURE;
        }
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_DETAILED,
                "sinr_nr_r15 [%u]:",
                p_meas_result_nr->meas_result_cell_r15.sinr_nr_r15);
    }
    if(p_asn_meas_result_nr->m.measResultRS_IndexList_r15Present) 
    {
        p_meas_result_nr->bitmask = MEAS_RESULT_NR_RS_INDEX_LIST_R15_PRESENT ; 
    /*MeasResultSSB_IndexList_r15*/
    p_list = &p_asn_meas_result_nr->measResultRS_IndexList_r15;

    p_meas_result_nr->rs_index_list_r15.count = p_list->count;

    if ((p_meas_result_nr->rs_index_list_r15.count >
                ARRSIZE(p_meas_result_nr->rs_index_list_r15.
                    meas_result_ssb_index_r15)) ||
            (p_meas_result_nr->rs_index_list_r15.count <1))
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_meas_results_nr wrong rs_index_list_r15 count [%u]",
                p_meas_result_nr->rs_index_list_r15.count);
        return RRC_FAILURE;
    }    
    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
            (p_ue_context->p_gb_context)->facility_name,
            RRC_DETAILED,
            "uecc_rrm_build_meas_results_nr rs_index_list_r15 count [%u]",
            p_meas_result_nr->rs_index_list_r15.count);

    p_node = p_list->head; 

    for(list_count = 0 ; list_count < p_meas_result_nr->rs_index_list_r15.count;
            list_count++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);
        p_elem =(MeasResultSSB_Index_r15*)p_node->data;

        p_meas_result_nr->rs_index_list_r15.meas_result_ssb_index_r15[list_count].ssb_index_r15 =
            p_elem->ssb_Index_r15; 

        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_DETAILED,
                "uecc_rrm_build_meas_results_nr ssb_Index_r15 [%u]",
                p_meas_result_nr->rs_index_list_r15.meas_result_ssb_index_r15[list_count].ssb_index_r15);

        /*meas_result_ssb_index_r15*/
        if(p_elem->m.measResultSSB_Index_r15Present)
        {
            p_meas_result_nr->rs_index_list_r15.meas_result_ssb_index_r15[list_count].bitmask = 
                MEAS_RESULT_SSB_INDEX_R15_PRESENT; 
            /*rsrpResult_r15*/
            if(p_elem->measResultSSB_Index_r15.m.rsrpResult_r15Present)
            {
                p_meas_result_nr->rs_index_list_r15.
                    meas_result_ssb_index_r15[list_count].meas_result_ssb_index_r15.bitmask |= 
                    THRESHOLD_LIST_NR_RSRP_PRESENT;

                p_meas_result_nr->rs_index_list_r15.meas_result_ssb_index_r15[list_count].
                    meas_result_ssb_index_r15.rsrp_nr_r15 =
                    p_elem->measResultSSB_Index_r15.rsrpResult_r15;

                if((p_meas_result_nr->rs_index_list_r15.meas_result_ssb_index_r15[list_count].
                            meas_result_ssb_index_r15.rsrp_nr_r15 > 127)) 
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,
                            "rsrpResult_r15 [%u]:",
                            p_meas_result_nr->rs_index_list_r15.meas_result_ssb_index_r15[list_count].
                            meas_result_ssb_index_r15.rsrp_nr_r15);
                    return RRC_FAILURE;
                }
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_DETAILED,
                        "rsrpResult_r15 [%u]:",
                        p_meas_result_nr->rs_index_list_r15.meas_result_ssb_index_r15[list_count].
                        meas_result_ssb_index_r15.rsrp_nr_r15);
            }
            /*rsrqResult_r15*/
            if(p_elem->measResultSSB_Index_r15.m.rsrqResult_r15Present)
            {
                p_meas_result_nr->rs_index_list_r15.
                    meas_result_ssb_index_r15[list_count].meas_result_ssb_index_r15.bitmask |=
                    THRESHOLD_LIST_NR_RSRQ_PRESENT;

                p_meas_result_nr->rs_index_list_r15.meas_result_ssb_index_r15[list_count].
                    meas_result_ssb_index_r15.rsrq_nr_r15 =
                    p_elem->measResultSSB_Index_r15.rsrqResult_r15;

                if((p_meas_result_nr->rs_index_list_r15.
                            meas_result_ssb_index_r15[list_count].meas_result_ssb_index_r15.rsrq_nr_r15 > 127)) 
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,
                            "rsrqResult_r15 [%u]:",
                            p_meas_result_nr->rs_index_list_r15.
                            meas_result_ssb_index_r15[list_count].meas_result_ssb_index_r15.rsrq_nr_r15);
                    return RRC_FAILURE;
                }
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_DETAILED,
                        "rsrqResult_r15 [%u]:",
                        p_meas_result_nr->rs_index_list_r15.
                        meas_result_ssb_index_r15[list_count].meas_result_ssb_index_r15.rsrq_nr_r15);
            }
            /*rs_sinr_Result_r15*/
            if(p_elem->measResultSSB_Index_r15.m.rs_sinr_Result_r15Present )
            {
                p_meas_result_nr->rs_index_list_r15.
                    meas_result_ssb_index_r15[list_count].meas_result_ssb_index_r15.bitmask |=
                    THRESHOLD_LIST_NR_SINR_PRESENT;

                p_meas_result_nr->rs_index_list_r15.
                    meas_result_ssb_index_r15[list_count].meas_result_ssb_index_r15.sinr_nr_r15 =
                    p_elem->measResultSSB_Index_r15.rs_sinr_Result_r15;

                if((p_meas_result_nr->rs_index_list_r15.meas_result_ssb_index_r15[list_count].
                            meas_result_ssb_index_r15.sinr_nr_r15 > 127))
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,
                            "sinr_nr_r15 [%u]:",
                            p_meas_result_nr->rs_index_list_r15.meas_result_ssb_index_r15[list_count].
                            meas_result_ssb_index_r15.sinr_nr_r15);
                    return RRC_FAILURE;
                }
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_DETAILED,
                        "sinr_nr_r15 [%u]:",
                        p_meas_result_nr->rs_index_list_r15.meas_result_ssb_index_r15[list_count].
                        meas_result_ssb_index_r15.sinr_nr_r15);
            }
        }
        p_node = p_node->next;
    }
    }
    return result;
}
/* coverity_fix_54693_stop */

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_curr_meas_object_to_add_mod_list
*   INPUT        : uecc_meas_object_to_add_mod_list_t*  p_ue_meas_object_to_add_mod_list,
*                  MeasObjectToAddModList*         p_meas_object_to_add_mod_list,
*                  uecc_ue_context_t*              p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds meas_object_to_add_mod_list_t from 
        MeasObjectToAddModList
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_curr_meas_object_to_add_mod_list(
    uecc_meas_object_to_add_mod_list_t*  p_ue_meas_object_to_add_mod_list,
    MeasObjectToAddModList*         p_meas_object_to_add_mod_list,
    uecc_ue_context_t*              p_uecc_ue_context
)
{
    U8 i=0;
    OSRTDListNode*              p_node = PNULL;
    rrc_return_et               result = RRC_SUCCESS;
    uecc_meas_object_to_add_mod_t*  p_curr_meas_config = PNULL;

    RRC_ASSERT(PNULL != p_ue_meas_object_to_add_mod_list);
    RRC_ASSERT(PNULL != p_meas_object_to_add_mod_list);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);


    p_node = p_meas_object_to_add_mod_list->head;


    for (i=0; i < p_meas_object_to_add_mod_list->count; i++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);
        
        p_curr_meas_config = (uecc_meas_object_to_add_mod_t*)
               rrc_mem_get(sizeof(uecc_meas_object_to_add_mod_t));

        if (p_curr_meas_config == PNULL)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_FATAL,"Memory Allocation Failure");
            return RRC_FAILURE;
        }

        /* SES-508 Fix Start */
        /* Code Removed */
        /* SES-508 Fix End */

        result = uecc_rrm_build_curr_meas_object_to_add_mod(
                p_curr_meas_config,
                (MeasObjectToAddMod*)(p_node->data),
                p_uecc_ue_context);

        if (RRC_FAILURE == result)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_curr_meas_object_to_add_mod_list error while build "
                "MeasObjectToAddMod [i=%i]",
                i);
            /* coverity_fix_63279_start */
            rrc_mem_free(p_curr_meas_config);
            /* Coverity ID 85922 Fix Start*/
          /*  p_curr_meas_config = PNULL; */
            /* Coverity ID 85922 Fix End*/
            /* coverity_fix_63279_stop */
            break;
        }
        else
        {
            ylPushTail(p_ue_meas_object_to_add_mod_list,
                    (YLNODE*)p_curr_meas_config);  
        }

        p_node = p_node->next;
        
    }
    /*Coverity 88114 Fix Code deleted*/

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_curr_report_config_to_add_mod_list
*   INPUT        : uecc_report_config_to_add_mod_list_t*    p_ue_report_config_to_add_mod_list,
*                  ReportConfigToAddModList*                p_report_config_to_add_mod_list,
*                  uecc_ue_context_t*                       p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds ReportConfigToAddModList in Current MeasConfig 
*       structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_curr_report_config_to_add_mod_list(
    uecc_report_config_to_add_mod_list_t*    p_ue_report_config_to_add_mod_list,
    ReportConfigToAddModList*                p_report_config_to_add_mod_list,
    uecc_ue_context_t*                       p_uecc_ue_context
)
{
    rrc_return_et           result                     = RRC_SUCCESS;
    ReportConfigToAddMod*   p_report_config_to_add_mod = PNULL;
    OSRTDListNode*          p_node                     = PNULL;
    U8                      i                          = RRC_NULL;
    uecc_report_config_to_add_mod_t* p_report_config   = PNULL;

    RRC_ASSERT(PNULL != p_ue_report_config_to_add_mod_list);
    RRC_ASSERT(PNULL != p_report_config_to_add_mod_list);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    p_node = p_report_config_to_add_mod_list->head;


    for (i=0; i < p_report_config_to_add_mod_list->count; i++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        p_report_config = (uecc_report_config_to_add_mod_t*)
            rrc_mem_get(sizeof(uecc_report_config_to_add_mod_t));
        if (p_report_config == PNULL)
        {
            RRC_UECC_TRACE ((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_FATAL, "Memory Allocation Failure");
            return RRC_FAILURE;
        }

        /* SES-508 Fix Start */
        /* Code Removed */
        /* SES-508 Fix End */

        p_report_config_to_add_mod = p_node->data;
        result = uecc_rrm_build_curr_report_config_to_add_mod(
                p_report_config,
                p_report_config_to_add_mod,
                p_uecc_ue_context);

        if (RRC_FAILURE == result)
        {
            RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_curr_report_config_to_add_mod_list "
                "error while build "
                "ReportConfigToAddMod [i=%i]",
                i);
            /* coverity_fix_63277_start */
            rrc_mem_free(p_report_config);
            /* Coverity ID 85875 Fix Start*/
           /* p_report_config = PNULL; */
            /* Coverity ID 85875 Fix End*/
            /* coverity_fix_63277_stop */
            break;
        }
        p_node = p_node->next;
        ylPushTail(p_ue_report_config_to_add_mod_list,
                (YLNODE*)p_report_config);
        
    }

    /* Coverity Fix 87921 Code Delted*/
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_ue_ho_adm_cnf_failure
*   INPUT        : uecc_ue_context_t*  p_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds and sends RRC_RRM_UE_HO_ADM_CNF message to RRM.
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_ue_ho_adm_cnf_failure(
    uecc_ue_context_t*  p_ue_context
)
{
    rrc_rrm_ue_ho_adm_cnf_t rrc_rrm_ue_ho_adm_cnf;
    rrc_return_et   response = RRC_FAILURE;   

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    
    memset_wrapper(&rrc_rrm_ue_ho_adm_cnf, 0, sizeof(rrc_rrm_ue_ho_adm_cnf_t));

    rrc_rrm_ue_ho_adm_cnf.ue_index = p_ue_context->ue_index;
    

    rrc_rrm_ue_ho_adm_cnf.response = response;
    rrc_rrm_ue_ho_adm_cnf.bitmask = 0x00;

    /* PUP encode and send */
    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
            (p_ue_context->p_gb_context)->facility_name, RRC_WARNING,
            "API:RRC->RRM:RRC_RRM_UE_HO_ADM_CNF:[UE:%u] with response:%u",
            rrc_rrm_ue_ho_adm_cnf.ue_index, rrc_rrm_ue_ho_adm_cnf.response);
    response = rrc_rrm_il_send_rrc_rrm_ue_ho_adm_cnf(
            &rrc_rrm_ue_ho_adm_cnf,
            RRC_UECC_MODULE_ID,
            RRC_RRM_MODULE_ID,
            uecc_ue_ctx_get_op_transction_id(p_ue_context),
            p_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return response;
}

/******************************************************************************
*  * FUNCTION NAME: uecc_llim_build_and_send_rrc_rrm_intra_enb_ho_ind
*   INPUT        : uecc_ue_context_t*  p_ue_context
*   OUTPUT       : none
*
*   DESCRIPTION:    This is the function for building and sending
*                   RRC_RRM_INTRA_ENB_HO_IND message to the RRM.
*
*   RETURNS:        None
*
******************************************************************************/
rrc_return_t uecc_llim_build_and_send_rrc_rrm_intra_enb_ho_ind(
        uecc_ue_context_t   *p_uecc_ue_context      /* UECC UE context */
)
{
    rrc_rrm_intra_enb_ho_ind_t     rrc_rrm_intra_enb_ho_ind;
    rrc_return_et                  response = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /* Fill message */
    memset_wrapper(&rrc_rrm_intra_enb_ho_ind, RRC_NULL, sizeof(rrc_rrm_intra_enb_ho_ind_t));
    


    /* ue_index */
    rrc_rrm_intra_enb_ho_ind.ue_index = p_uecc_ue_context->ue_index;

    /*BUG 604 changes start*/
    /* bitmask */
    rrc_rrm_intra_enb_ho_ind.bitmask |= RRC_RRM_INTRA_CELL_HO_CAUSE_TYPE_PRESENT;

    if (RRC_TRUE == p_uecc_ue_context->ue_ctx_mod_security_flag)
    {
        rrc_rrm_intra_enb_ho_ind.intracell_ho_cause = UE_CONTEXT_MODIFICATION;
    }
    else
    {
        rrc_rrm_intra_enb_ho_ind.intracell_ho_cause = PDCP_COUNT_WRAPAROUND;
    }
    /*BUG 604 changes stop*/
    /* Encode and send message */
    response = rrc_rrm_il_send_rrc_rrm_intra_enb_ho_ind(
                    &rrc_rrm_intra_enb_ho_ind,
                    RRC_UECC_MODULE_ID,
                    RRC_RRM_MODULE_ID,
                    uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context),
                    p_uecc_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return response;
}

/*CA_RE_ESTAB_START*/
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_ue_reestab_config_cnf
*   INPUT        : uecc_ue_context_t*  p_ue_context
*                  U8                  response,
*   OUTPUT       : none
*
*   DESCRIPTION:
*       This function builds and sends 
        RRC_RRM_UE_REESTAB_CONFIG_CNF message
*       with success/failure to RRM module
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_ue_reestab_config_cnf(
    uecc_ue_context_t*  p_ue_context, /*UECC UE Context*/
    U8                  response
)
{
    rrc_rrm_ue_reestab_config_cnf_t rrc_rrm_ue_reestab_config_cnf = {0};
    rrc_return_et                  rrc_response = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_ue_context);

    rrc_rrm_ue_reestab_config_cnf.ue_index = p_ue_context->ue_index;
    rrc_rrm_ue_reestab_config_cnf.response = response;

    if (FAILURE == response)
    {
        rrc_rrm_ue_reestab_config_cnf.bitmask |= 
            RRC_RRM_UE_REESTAB_CONFIG_CNF_FAIL_CAUSE_PRESENT;
    }
    else if (SUCCESS == response)
    {
        rrc_rrm_ue_reestab_config_cnf.bitmask = RRC_NULL;
    }

    rrc_response = rrc_rrm_il_send_rrc_rrm_ue_reestab_config_cnf(
                    &rrc_rrm_ue_reestab_config_cnf,
                    RRC_UECC_MODULE_ID,
                    RRC_RRM_MODULE_ID,
                    uecc_ue_ctx_get_op_transction_id(p_ue_context),
                    p_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return rrc_response;
}
/*CA_RE_ESTAB_STOP*/

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_ue_reconfig_resp
*   INPUT        : uecc_ue_context_t*  p_ue_context
*                  U8                  response,
*                  U32                 fail_cause
*   OUTPUT       : none
*
*   DESCRIPTION:
*       This function builds and sends 
        RRC_RRM_UE_RECONFIG_RESP message
*       with success/failure to RRM module
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_ue_reconfig_resp(
    uecc_ue_context_t*  p_ue_context,
    U8                  response,
    U32                 fail_cause)
{
    rrc_rrm_ue_reconfig_resp_t rrc_rrm_ue_reconfig_resp = {0};
    rrc_return_et                  rrc_response = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    RRC_ASSERT(PNULL != p_ue_context);

    rrc_rrm_ue_reconfig_resp.ue_index = p_ue_context->ue_index;
    rrc_rrm_ue_reconfig_resp.response = response;



    if(FAILURE == response)
    {
        rrc_rrm_ue_reconfig_resp.bitmask |= RRM_UE_RECONFIG_RESP_API_FAIL_CAUSE_PRESENT;
        rrc_rrm_ue_reconfig_resp.fail_cause = fail_cause;
    }
    else if (SUCCESS == response)
    {
        rrc_rrm_ue_reconfig_resp.bitmask = 0;
        rrc_rrm_ue_reconfig_resp.fail_cause = RRM_RRC_NO_ERROR;
    }

    rrc_response = rrc_rrm_il_send_rrc_rrm_ue_reconfig_resp(
                    &rrc_rrm_ue_reconfig_resp,
                    RRC_UECC_MODULE_ID,
                    RRC_RRM_MODULE_ID,
                    /* SPR 21991 Fix Start */
                    p_ue_context->rrm_curr_trans_id,
                    /* SPR 21991 Fix End */
                    p_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return rrc_response;
}

/******************************************************************************
* FUNCTION NAME:  uecc_rrm_build_and_send_csfb_parameters_req_cdma2000
*   INPUT        : uecc_ue_context_t*  p_ue_context
*   OUTPUT       : none
*
* DESCRIPTION:    This is the function for building and sending
*                 RRC_RRM_CSFB_PARAMETERS_REQ_CDMA2000 message to the RRM.
*
* RETURNS:        None
*
******************************************************************************/
rrc_return_t uecc_rrm_build_and_send_csfb_parameters_req_cdma2000(
    uecc_ue_context_t   *p_uecc_ue_context)
{
    rrc_rrm_csfb_parameters_req_cdma2000_t 
                         rrc_rrm_csfb_parameters_req_cdma2000;
    rrc_return_et        result = RRC_FAILURE;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    /*reset */
    memset_wrapper(&rrc_rrm_csfb_parameters_req_cdma2000, 0,
            sizeof(rrc_rrm_csfb_parameters_req_cdma2000_t));

    /* Fill message */

    /* ue_index */
    rrc_rrm_csfb_parameters_req_cdma2000.ue_index = 
                       p_uecc_ue_context->ue_index;

    /* Encode and send message */
    result =  rrc_rrm_il_send_rrc_rrm_csfb_parameters_req_cdma2000(
                      &rrc_rrm_csfb_parameters_req_cdma2000,
                      RRC_UECC_MODULE_ID,
                      RRC_RRM_MODULE_ID,
                      uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context),
                      p_uecc_ue_context->cell_index);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}



/******************************************************************************
* FUNCTION NAME :validate_ho_cause 
* INPUT         :rrm_cause_t         *p_rrm_cause
*                uecc_gb_context_t   *p_uecc_gb_context
* OUTPUT        : none
* DESCRIPTION   :This is the function for validating the handover cause when
*                handover type is INTER_CELL_HO or X2_HO.
*
* RETURNS       :RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_t validate_ho_cause
(   
    rrm_cause_t         *p_rrm_cause,        /* RRM Cause */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */)
{
    rrc_return_et result = RRC_SUCCESS;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    RRC_ASSERT(PNULL != p_rrm_cause);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    
    switch(p_rrm_cause->type)
    {
        case T_x2ap_Cause_radioNetwork:
            if (p_rrm_cause->value > x2ap_not_supported_QCI_value)
            {
                result = RRC_FAILURE;
            }
            break;

        case T_x2ap_Cause_transport:
            if (p_rrm_cause->value > x2ap_unspecified_3)
            {
                result = RRC_FAILURE;
            }
            break;
        
        case T_x2ap_Cause_protocol:
            if (p_rrm_cause->value > 
                    x2ap_abstract_syntax_error_falsely_constructed_message)
            {
                result = RRC_FAILURE;
            }
            break;
        
        case T_x2ap_Cause_misc:
            if (p_rrm_cause->value > x2ap_unspecified)
            {
                result = RRC_FAILURE;
            }
            break;
        default:
            RRC_UECC_TRACE((p_uecc_gb_context)->context_index,
                (p_uecc_gb_context)->facility_name,
                RRC_WARNING,
                " Invalid cause type:%d",p_rrm_cause->type);
            result = RRC_FAILURE;
    }
    
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/* SPS Start */
/*****************************************************************************
 * Function Name  : uecc_rrm_parse_and_update_sps_config 
 * Inputs         : uecc_ue_context_t*  p_ue_context
 *                  rrc_sps_config_t    *p_rrm_sps_config
 * Outputs        : None 
 * Returns        : rrc_return_et
 * Description    : This function parses and updates SPS config
 ********************************************************************************/
rrc_return_et uecc_rrm_parse_and_update_sps_config(
        uecc_ue_context_t*  p_ue_context,
        rrc_sps_config_t *p_rrm_sps_config)
{

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if (p_ue_context->p_sps_config != NULL)
    {
        /* Check if SPS Setup Config is received - if yes it is invalid 
         * SPS release config is expected
         * */
        if ((p_rrm_sps_config->sps_config_dl.bitmask &
                    RRC_SPS_CONFIG_DL_PARAM_PRESENT) ||
                (p_rrm_sps_config->sps_config_ul.bitmask &
                 RRC_SPS_CONFIG_UL_PARAM_PRESENT))
        { /* Setup SPS config is received i.e. Inavlid SPS Config
          * Ignoring it.
          */
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING, "Invalid SPS Config is received from RRM."
                    "SPS setup config received. Expected SPS release config. Ignoring it");
            return RRC_FAILURE;
        }
        else
        {
            p_ue_context->m.is_sps_setup_or_rel_recv = 1; /* Release SPS Config is received */
        }

    }
    else
    {
        if (!((p_rrm_sps_config->sps_config_dl.bitmask &
                    RRC_SPS_CONFIG_DL_PARAM_PRESENT) ||
                (p_rrm_sps_config->sps_config_ul.bitmask &
                 RRC_SPS_CONFIG_UL_PARAM_PRESENT)))
        {
          	 /* SPR 20747 Fix Start */
          	if ((PNULL != p_ue_context->ho_info.p_ho_info) && (PNULL != p_ue_context->ho_info.p_ho_info->p_trg_ho_info) &&
	           ((p_ue_context->ho_info.p_ho_info->p_trg_ho_info->is_sps_recv_from_src & SRC_SPS_CONFIG_UL_PRESENT) ||
	              (p_ue_context->ho_info.p_ho_info->p_trg_ho_info->is_sps_recv_from_src & SRC_SPS_CONFIG_DL_PRESENT)))
	 	 {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                             RRC_DETAILED, "SPS Release is recived when trg handover is ongoing");

               	          p_ue_context->m.is_sps_recv_frm_rrm = 1;
           		  p_ue_context->m.is_sps_setup_or_rel_recv = 1; /*  SPS Release Config is received */

            		  return RRC_SUCCESS;
	         }
	 	else
          	{
         		   RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                		(p_ue_context->p_gb_context)->facility_name,
                                 RRC_WARNING, "SPS release config received. Expected SPS setup config. Ignoring it");
            return RRC_FAILURE;
        }

              /* SPR 20747 Fix End */ 
        }
        else /* Setup SPS Config is recv */
        {
            p_ue_context->m.is_sps_setup_or_rel_recv = 0; /* Setup SPS Config is received */
        }

        /* Allocate Memory to SPS Config */
        p_ue_context->p_sps_config = (rrc_sps_config_t *)rrc_mem_get(sizeof(rrc_sps_config_t));

        if (PNULL == p_ue_context->p_sps_config)
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR, "Memory allocation failed for SPS Config");
            return RRC_FAILURE;
        }
        /* SES-508 Fix Start */
        /* Code Removed */
        /* SES-508 Fix End */
    }

    /* Store rrc_sps_config_t if present */
    p_ue_context->m.sps_config_present = 1;
    p_ue_context->m.sps_config_updated = 1;
    p_ue_context->m.is_sps_recv_frm_rrm = 1;

    if (p_rrm_sps_config->bitmask &
            RRC_SPS_CONFIG_SPS_CONFIG_DL_PRESENT)
    {
        p_ue_context->p_sps_config->bitmask |= RRC_SPS_CONFIG_SPS_CONFIG_DL_PRESENT;
        p_ue_context->p_sps_config->sps_config_dl =
            p_rrm_sps_config->sps_config_dl;
    }

    if (p_rrm_sps_config->bitmask &
            RRC_SPS_CONFIG_SPS_CONFIG_UL_PRESENT)
    {
        p_ue_context->p_sps_config->bitmask |= RRC_SPS_CONFIG_SPS_CONFIG_UL_PRESENT;
        p_ue_context->p_sps_config->sps_config_ul =
            p_rrm_sps_config->sps_config_ul;
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;

}
/*SPS Stop */
/* Counter Check START */
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_counter_check_req
*   INPUT        : void*                p_api
*                  uecc_gb_context_t*   p_uecc_gb_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function processes RRM RRC_RRM_COUNTER_CHECK_REQ 
*
*   RETURNS:
*       None
*
******************************************************************************/
void uecc_rrm_process_counter_check_req
(
 void*                p_api,             /* Input API buffer */
 uecc_gb_context_t*   p_uecc_gb_context  /* UECC global context */
 )
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t*              p_ue_context = PNULL;
    rrc_rrm_counter_check_req_t     rrc_rrm_counter_check_req;
    S32                             length_read = RRC_NULL;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;
    ue_reconfig_queue_node_t        *p_ue_reconfig_queue_node = PNULL;
    list_t                          *p_ue_reconfig_queue = PNULL;

    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {
        /* Decode message */
        result = rrc_il_parse_rrc_rrm_counter_check_req( &rrc_rrm_counter_check_req,
                (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                &length_read);

        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_COUNTER_CHECK_REQ] parsing error.");
            break;
        }

        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", rrc_rrm_counter_check_req.ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
                rrc_rrm_counter_check_req.ue_index);

        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_COUNTER_CHECK_REQ] The UE context isn't found.");
            break;
        }

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_COUNTER_CHECK_REQ] Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_COUNTER_CHECK_REQ] Cell not Active.");
            break;
        }
        if(RRC_TRUE == p_ue_context->counter_check_info.counter_check_proc_running)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_COUNTER_CHECK_REQ] Counter Check Proc already running for this UE");
            if(RRC_SUCCESS != uecc_rrm_build_and_send_counter_check_failure(p_ue_context,
                       RRM_RRC_INTERACTION_WITH_OTHER_PROCEDURE_FAILURE))
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_ERROR,
                        "RRC_RRM_COUNTER_CHECK_RESP failure message not sent to RRM");
            }
            break;
        }

        /* save the transaction_id of RRM procedure in UE context
          counter_check_transaction_id */
        p_ue_context->counter_check_info.counter_check_trans_id = rrc_get_transaction_id(p_api);


        /* check if main FSM state is valid or not */
        if (p_ue_context->uecc_fsm.p_current_state->s_name != PNULL)
        {
            if ((!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                            (const S8 *)"UECC_UE_IDLE")) ||
                    (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                 (const S8 *)"UECC_UE_CONNECTION_SETUP_ONGOING")) ||
                    (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                 (const S8 *)"UECC_UE_WAIT_FOR_CONNECTION_RELEASE")) ||
                    (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                 (const S8 *)"UECC_UE_CONNECTION_RELEASE_ONGOING")) ||
                    (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                 (const S8 *)"UECC_UE_WAIT_FOR_S1_CONNECTION")) ||
                    (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                 (const S8 *)"UECC_UE_SRC_HO_ONGOING"))) 
            {
                /* Build and send the RRC_RRM_COUNTER_CHECK_RESP(failure) to RRM. */
                if (RRC_SUCCESS != uecc_rrm_build_and_send_counter_check_failure(
                            p_ue_context, RRM_RRC_INTERACTION_WITH_OTHER_PROCEDURE_FAILURE))
                {
                    /* Process failure according to selected failure actions list */
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_WARNING,
                            "Failure to build and send counter check resp to RRM.");
                    break;
                }
                break;
            }
        }
        
        if ( (PNULL != p_ue_context->uecc_fsm.p_current_state->s_name )
                              &&
             (RRC_NULL != strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                    (const S8 *)"UECC_UE_CONNECTED")))
        {
            p_ue_reconfig_queue_node = (ue_reconfig_queue_node_t*)
                rrc_mem_get(sizeof(ue_reconfig_queue_node_t) + rrc_get_api_buf_size(p_api));
            
            if (PNULL != p_ue_reconfig_queue_node)
            {
                p_ue_reconfig_queue_node->message_type = COUNTER_CHECK_REQUEST;

                l3_memcpy_wrapper((void*)p_ue_reconfig_queue_node->message ,
                        (const void*)p_api, rrc_get_api_buf_size(p_api));

                p_ue_reconfig_queue = &p_ue_context->ue_reconfig_queue;

                if ((RECONFIGURATION_Q_GET_COUNT(p_ue_reconfig_queue)) < 
                        RECONFIGURATION_Q_MAX_LENGTH)
                {
                    RECONFIGURATION_Q_ENQUEUE(p_ue_reconfig_queue, 
                            p_ue_reconfig_queue_node);
                    
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_INFO,
                            "[RRC_RRM_COUNTER_CHECK_REQ] Enqueued in "
                            "reconfiguration queue . Queue length :%d",
                            RECONFIGURATION_Q_GET_COUNT(p_ue_reconfig_queue));
                }
                else
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_ERROR, 
                            "[RRC_RRM_COUNTER_CHECK_REQ]Reconfiguration Queue Full : Message Discarded");

                    /* Build and send the RRC_RRM_COUNTER_CHECK_RESP(failure) to RRM. */
                    if (RRC_SUCCESS != uecc_rrm_build_and_send_counter_check_failure(
                                p_ue_context, RRM_RRC_INTERNAL_FAILURE))
                    {
                        /* Process failure according to selected failure actions list */
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,
                                "Failure to build and send counter check resp to RRM.");
                    }
                    /* coverity_fix_63280_start */
                    rrc_mem_free(p_ue_reconfig_queue_node);
                    /* Coverity ID 85894 Fix Start*/
                  /*  p_ue_reconfig_queue_node = PNULL; */
                    /* Coverity ID 85894 Fix End*/
                    /* coverity_fix_63280_stop */
                }
            }
            else
            {
                RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                        p_uecc_gb_context->facility_name,
                        RRC_ERROR,
                        "Mem Alloc failed : Ignoring [RRC_RRM_COUNTER_CHECK_REQ]");                
            }
        }
        else
        {
            uecc_rrm_counter_check_req_handler(p_ue_context, &rrc_rrm_counter_check_req);
        }
    }
    while(0);

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/****************************************************************************
 * Function Name  : uecc_rrm_counter_check_req_handler
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 *                  void*   - api data
 * Outputs        : None
 * Returns        : None
 * Description    : This action routine is called UECC receives
 * RRC_RRM_COUNTER_CHECK_REQ message
 *****************************************************************************/

void uecc_rrm_counter_check_req_handler(
        uecc_ue_context_t   *p_ue_context,      /* UECC UE context */
        void                *p_api              /* Input API buffer */
)
{
    U8          fail_cause = RRC_NULL;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_api);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* Start timer */
    uecc_rrm_counter_check_start_timer(p_ue_context);

    /*Set Counter Check proc running flag in ue context
     * */
    p_ue_context->counter_check_info.counter_check_proc_running = RRC_TRUE;

    /* COUNTER CHECK REQ */
    if (RRC_SUCCESS !=
            uecc_llim_build_and_send_drb_count_msb_req(p_ue_context, p_api))
    {
        uecc_rrm_counter_check_stop_timer(p_ue_context);
        fail_cause = RRM_RRC_INTERNAL_FAILURE;  
        if(RRC_SUCCESS != uecc_rrm_build_and_send_counter_check_failure(p_ue_context,fail_cause))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name,
                    RRC_ERROR,
                    "RRC_RRM_COUNTER_CHECK failure message not sent to RRM");
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/****************************************************************************
* Function Name  : uecc_rrm_counter_check_start_timer
* Inputs         : uecc_ue_context_t* - pointer to UE context
* Outputs        : None
* Returns        : None
* Description    : Starts UE_COUNTER_CHECK_RRM_REQ Procedural timer
*****************************************************************************/
void uecc_rrm_counter_check_start_timer(
        uecc_ue_context_t   *p_ue_context
        )
{
    uecc_timer_buffer_t repeated_timer_buf;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if ( PNULL != p_ue_context->timers_data.timers_ids[UECC_UE_COUNTER_CHECK_GUARD_TIMER] )
    {
        /* Already started */
        return;
    }


    /* Start the Procedural timer*/
    repeated_timer_buf.type = UECC_TIMER_TYPE_RRC_PROCEDURAL;
    repeated_timer_buf.id = UECC_UE_COUNTER_CHECK_GUARD_TIMER;
    repeated_timer_buf.auto_delete = RRC_TRUE;
    repeated_timer_buf.ue_index = p_ue_context->ue_index;
    repeated_timer_buf.fsm_event_id = UECC_EV_COUNTER_CHECK_TIMER_EXPIRY;

    p_ue_context->timers_data.timers_ids[UECC_UE_COUNTER_CHECK_GUARD_TIMER] = rrc_start_timer(
            p_ue_context->p_gb_context->ue_timers_data.durations[UECC_UE_COUNTER_CHECK_GUARD_TIMER],
            &repeated_timer_buf,
            sizeof(uecc_timer_buffer_t),
            uecc_ue_timers_descriptors[UECC_UE_COUNTER_CHECK_GUARD_TIMER].is_repeated);

    if ( PNULL == p_ue_context->timers_data.timers_ids[UECC_UE_COUNTER_CHECK_GUARD_TIMER])
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                p_ue_context->p_gb_context->facility_name,
                RRC_ERROR,
                "[UECC_UE_COUNTER_CHECK_GUARD_TIMER] Starting error");
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/****************************************************************************
* Function Name  : uecc_rrm_counter_check_stop_timer
* Inputs         : uecc_ue_context_t* - pointer to UE context
* Outputs        : None
* Returns        : None
* Description    : Stop UE_RRM_COUNTER_CHECK Procedural timer
*****************************************************************************/
void uecc_rrm_counter_check_stop_timer(
        uecc_ue_context_t   *p_ue_context
)
{

    RRC_ASSERT(PNULL != p_ue_context);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /* Stop procedural timer */
    if (p_ue_context->timers_data.timers_ids[UECC_UE_COUNTER_CHECK_GUARD_TIMER] != PNULL)
    {
        RRC_UECC_TRACE(
                p_ue_context->p_gb_context->context_index,
                p_ue_context->p_gb_context->facility_name,
                RRC_BRIEF,
                "Stop timer [UECC_UE_COUNTER_CHECK_GUARD_TIMER]");

        rrc_stop_timer(p_ue_context->timers_data.timers_ids[UECC_UE_COUNTER_CHECK_GUARD_TIMER]);
        p_ue_context->timers_data.timers_ids[UECC_UE_COUNTER_CHECK_GUARD_TIMER] = PNULL;
    }

    else if(p_ue_context->timers_data.timers_ids[UECC_UE_COUNTER_CHECK_GUARD_TIMER] == PNULL)
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                p_ue_context->p_gb_context->facility_name,
                RRC_BRIEF,
                "Timer Already Stopped [UECC_UE_COUNTER_CHECK_GUARD_TIMER]");
    }


    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_counter_check_failure
*   INPUT        : uecc_ue_context_t               *p_ue_context
*                  U8                               fail_cause
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds COUNTER CHECK MESSAGE with negative response
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_counter_check_failure(
        uecc_ue_context_t               *p_ue_context,      /* UECC UE context */
        U8                               fail_cause
)
{
    rrc_return_et       result = RRC_FAILURE;

    rrc_rrm_counter_check_resp_t rrc_rrm_counter_check_resp;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&rrc_rrm_counter_check_resp, RRC_NULL, sizeof(rrc_rrm_counter_check_resp_t));

    rrc_rrm_counter_check_resp.bitmask |= RRM_COUNTER_CHECK_RESP_FAIL_CAUSE_PRESENCE_FLAG;


    rrc_rrm_counter_check_resp.ue_index = p_ue_context->ue_index;

    rrc_rrm_counter_check_resp.response = RRC_FAILURE;
    rrc_rrm_counter_check_resp.fail_cause = fail_cause;

    /* PUP encode and send */
    result = rrc_rrm_il_send_rrc_rrm_counter_check_resp (
            &rrc_rrm_counter_check_resp,
            RRC_UECC_MODULE_ID,
            RRC_RRM_MODULE_ID,
            p_ue_context->counter_check_info.counter_check_trans_id,
            p_ue_context->cell_index);

    memset_wrapper( &p_ue_context->counter_check_info, RRC_NULL, sizeof(counter_check_info_t));

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}

/******************************************************************************
*   FUNCTION NAME:  uecc_rrm_build_and_send_counter_check_success
*   INPUT        :  uecc_ue_context_t   *p_uecc_ue_context
*                   CounterCheckResponse_r8_IEs    *p_counterCheckResponse_r8
*   OUTPUT       : none
*   DESCRIPTION:    This is the function for building and sending
*                   RRC_RRM_COUNTER_CHECK_RESP message to the RRM.
*
*   RETURNS:        None
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_counter_check_success(
        uecc_ue_context_t   *p_uecc_ue_context,      /* UECC UE context */
        CounterCheckResponse_r8_IEs    *p_counterCheckResponse_r8
)
{
    rrc_rrm_counter_check_resp_t      rrc_rrm_counter_check_response;
    rrc_return_et        result = RRC_FAILURE;
    OSRTDListNode        *p_node = PNULL;
    DRB_CountInfo        *p_drb_count_info = PNULL;
    U8 i = 0;

    RRC_ASSERT(PNULL != p_uecc_ue_context);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    /*reset */
    memset_wrapper(&rrc_rrm_counter_check_response, RRC_NULL,
            sizeof(rrc_rrm_counter_check_resp_t));

    rrc_rrm_counter_check_response.bitmask |= 
        RRM_COUNTER_CHECK_RESP_DRB_COUNT_INFO_LIST_PRESENCE_FLAG;
    rrc_rrm_counter_check_response.bitmask |= 
        RRM_COUNTER_CHECK_RESP_DRB_COUNTMSB_INFO_LIST_PRESENCE_FLAG;
    /* Fill message */
    /* ue_index */
    rrc_rrm_counter_check_response.ue_index = 
        p_uecc_ue_context->ue_index;
    

    /* response */
    rrc_rrm_counter_check_response.response = RRC_SUCCESS;

    l3_memcpy_wrapper(&(rrc_rrm_counter_check_response.drb_countMSB_info_list),
            &(p_uecc_ue_context->counter_check_info.drb_countMSB_info_list),
            sizeof(drb_countMSB_info_list_t));

    rrc_rrm_counter_check_response.drb_count_info_list.drb_count =
        (U8)p_counterCheckResponse_r8->drb_CountInfoList.count;

    p_node = p_counterCheckResponse_r8->drb_CountInfoList.head;

    if ((p_counterCheckResponse_r8->drb_CountInfoList.count >
                ARRSIZE(rrc_rrm_counter_check_response.
                    drb_count_info_list.drb_count_info)) ||
            (p_counterCheckResponse_r8->drb_CountInfoList.count<1))
    {
        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                p_uecc_ue_context->p_gb_context->facility_name,
                RRC_WARNING,
                "uecc_rrm_build_and_send_counter_check_success wrong list count [%u]",
                p_counterCheckResponse_r8->drb_CountInfoList.count);

        RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
        return result;
    }


    for(i = 0; i< p_counterCheckResponse_r8->drb_CountInfoList.count; i++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        p_drb_count_info = (DRB_CountInfo*)p_node->data;

        rrc_rrm_counter_check_response.drb_count_info_list.drb_count_info[i].drb_Identity =
            p_drb_count_info->drb_Identity;
        rrc_rrm_counter_check_response.drb_count_info_list.drb_count_info[i].count_Uplink =
            p_drb_count_info->count_Uplink;
        rrc_rrm_counter_check_response.drb_count_info_list.drb_count_info[i].count_Downlink =
            p_drb_count_info->count_Downlink;

        p_node = p_node->next;
    }

    /* Encode and send message */
    result = rrc_rrm_il_send_rrc_rrm_counter_check_resp(
                    &rrc_rrm_counter_check_response,
                    RRC_UECC_MODULE_ID,
                    RRC_RRM_MODULE_ID,
                    p_uecc_ue_context->counter_check_info.counter_check_trans_id,
                    p_uecc_ue_context->cell_index);

    memset_wrapper(&(p_uecc_ue_context->counter_check_info),
            RRC_NULL, sizeof(counter_check_info_t));

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    /*Coverity 87741 Fix Start*/
    return result;
    /*Coverity 87741 Fix End*/
}
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_ue_information_resp
*   INPUT        : uecc_ue_context_t               *p_ue_context
*                  UEInformationResponse_r9        *p_UEInformationResp_r9
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds and sends RRC_RRM_UE_INFORMATION_RESP message
*       with success to RRM module
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_ue_information_resp(
    uecc_ue_context_t               *p_ue_context,      /* UECC UE context */
    UEInformationResponse_r9        *p_UEInformationResp_r9
)
{
	/* coverity_fix_54695_start */
	OSRTDListNode*      p_node = PNULL;
	OSRTDListNode*      p_node1 = PNULL;
	static rrc_rrm_ue_information_resp_t rrc_rrm_ue_information_resp;
	rrc_return_et       result = RRC_FAILURE;
	U8 i = 0,j=0,list_count =0;
	MeasResult2EUTRA_r9 *p_MeasResult2EUTRA_r9;
	MeasResult2UTRA_r9  *p_MeasResult2UTRA_r9;
	MeasResult2CDMA2000_r9  *p_meas_cdma;
	UEInformationResponse_r9_IEs *p_UEInformationResp = PNULL;

	RRC_ASSERT(PNULL != p_ue_context);
	RRC_ASSERT(PNULL != p_UEInformationResp_r9);
	RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

	do
	{
		p_UEInformationResp = p_UEInformationResp_r9->criticalExtensions.u.c1->u.ueInformationResponse_r9;
		if(PNULL == p_UEInformationResp)
		{
			RRC_UECC_TRACE(
					p_ue_context->p_gb_context->context_index,
					p_ue_context->p_gb_context->facility_name,
					RRC_ERROR,
					"INVALID MESSAGE");
			break;
		}
		memset_wrapper(&rrc_rrm_ue_information_resp, 0, sizeof(rrc_rrm_ue_information_resp_t));
		rrc_rrm_ue_information_resp.ue_Index = p_ue_context->ue_index;


		rrc_rrm_ue_information_resp.response = RRC_SUCCESS;

		if (1 == p_UEInformationResp->m.rach_Report_r9Present)
		{
			rrc_rrm_ue_information_resp.bitmask |=
				RRC_UE_INFO_RACH_REPORT_PRESENT;
			rrc_rrm_ue_information_resp.rach_report.no_of_preamables_sent = 
				p_UEInformationResp->rach_Report_r9.numberOfPreamblesSent_r9;
			rrc_rrm_ue_information_resp.rach_report.contention_detected = 
				p_UEInformationResp->rach_Report_r9.contentionDetected_r9;
		}
		if (1 == p_UEInformationResp->m.rlf_Report_r9Present)
		{
			rrc_rrm_ue_information_resp.bitmask |=
				RRC_UE_INFO_RLF_REPORT_PRESENT;
			rrc_rrm_ue_information_resp.rlf_report.meas_result_serv_cell.rsrp_result = 
				p_UEInformationResp->rlf_Report_r9.measResultLastServCell_r9.rsrpResult_r9;
			if(1 == p_UEInformationResp->rlf_Report_r9.measResultLastServCell_r9.m.rsrqResult_r9Present)
			{
				rrc_rrm_ue_information_resp.rlf_report.meas_result_serv_cell.bitmask |=
					RRC_UE_INFO_MEAS_RESULT_RSRQ_PRESENT;

				rrc_rrm_ue_information_resp.rlf_report.meas_result_serv_cell.rsrq_result =
					p_UEInformationResp->rlf_Report_r9.measResultLastServCell_r9.rsrqResult_r9;
			}
			if(1 == p_UEInformationResp->rlf_Report_r9.m.measResultNeighCells_r9Present)
			{
				rrc_rrm_ue_information_resp.rlf_report.bitmask |=
					RRC_UE_INFO_MEAS_RESULT_NEIGH_CELLS_PRESENT;

				if(1 == p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.m.measResultListEUTRA_r9Present)
				{

					rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.bitmask |=
						RRC_UE_INFO_MEAS_RESULT_LIST_EUTRA_PRESENT;

					rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.meas_result_list_eutra.count = 
						(U8)p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.measResultListEUTRA_r9.count;

					p_node = p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.measResultListEUTRA_r9.head;

					if ((p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
								measResultListEUTRA_r9.count >
								ARRSIZE(rrc_rrm_ue_information_resp.rlf_report.
									meas_result_neigh_cell.
									meas_result_list_eutra.meas_result_eutra)) ||
							(p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
							 measResultListEUTRA_r9.count <1))
					{
						RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
								p_ue_context->p_gb_context->facility_name,
								RRC_WARNING,
								"uecc_rrm_build_and_send_ue_information_resp wrong list count [%u] \
								for MeasResultList2EUTRA_r9",
								p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
								measResultListEUTRA_r9.count);
						break;
					}    
					for(i = 0; i< p_UEInformationResp->rlf_Report_r9.
							measResultNeighCells_r9.measResultListEUTRA_r9.count; i++)
					{
						RRC_ASSERT(PNULL != p_node);
						RRC_ASSERT(PNULL != p_node->data);

						p_MeasResult2EUTRA_r9 = (MeasResult2EUTRA_r9*)p_node->data;
						rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.meas_result_list_eutra.
							meas_result_eutra[i].carrier_freq = p_MeasResult2EUTRA_r9->carrierFreq_r9;
						rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.meas_result_list_eutra.
							meas_result_eutra[i].meas_result_list_eutra.count = 
							(U8)p_MeasResult2EUTRA_r9->measResultList_r9.count;
						p_node1 = p_MeasResult2EUTRA_r9->measResultList_r9.head; 

						if ((p_MeasResult2EUTRA_r9->measResultList_r9.count >
									ARRSIZE(rrc_rrm_ue_information_resp.rlf_report.
										meas_result_neigh_cell.
										meas_result_list_eutra.meas_result_eutra[i].meas_result_list_eutra
										.meas_result_eutra)) ||
								(p_MeasResult2EUTRA_r9->measResultList_r9.count <1))
						{
							RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
									p_ue_context->p_gb_context->facility_name,
									RRC_WARNING,
									"uecc_rrm_build_and_send_ue_information_resp wrong list count [%u] \
									for MeasResultEUTRA",
									p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
									measResultListEUTRA_r9.count);
							break;
						}    
						for(j = 0; j < p_MeasResult2EUTRA_r9->measResultList_r9.count; j++)
						{
							RRC_ASSERT(PNULL != p_node1);
							RRC_ASSERT(PNULL != p_node1->data);
							result = uecc_rrm_build_meas_result_eutra(
									p_ue_context->p_gb_context, p_ue_context,
									&rrc_rrm_ue_information_resp.rlf_report.
									meas_result_neigh_cell.meas_result_list_eutra.
									meas_result_eutra[i].meas_result_list_eutra.meas_result_eutra[j],
									p_node1->data); 

							if (RRC_FAILURE == result)
							{   
								break;
							}    
							p_node1 = p_node1->next;
						}
						p_node = p_node->next;
					}

				}

				if(1 == p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.m.measResultListUTRA_r9Present)
				{

					rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.bitmask |=
						RRC_UE_INFO_MEAS_RESULT_LIST_UTRA_PRESENT;

					rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.meas_result_list_utra.count = 
						(U8)p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.measResultListUTRA_r9.count;

					p_node = p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.measResultListUTRA_r9.head;

					if ((p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
								measResultListUTRA_r9.count >
								ARRSIZE(rrc_rrm_ue_information_resp.rlf_report.
									meas_result_neigh_cell.
									meas_result_list_utra.meas_result_utra)) ||
							(p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
							 measResultListUTRA_r9.count <1))
					{
						RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
								p_ue_context->p_gb_context->facility_name,
								RRC_WARNING,
								"uecc_rrm_build_and_send_ue_information_resp wrong list count [%u] \
								for MeasResultUTRA",
								p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
								measResultListUTRA_r9.count);
						break;
					}    
					for(i = 0; i< p_UEInformationResp->rlf_Report_r9.
							measResultNeighCells_r9.measResultListUTRA_r9.count; i++)
					{
						RRC_ASSERT(PNULL != p_node);
						RRC_ASSERT(PNULL != p_node->data);

						p_MeasResult2UTRA_r9 = (MeasResult2UTRA_r9*)p_node->data;
						rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.meas_result_list_utra.
							meas_result_utra[i].carrier_freq = p_MeasResult2UTRA_r9->carrierFreq_r9;

						rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.meas_result_list_utra.
							meas_result_utra[i].meas_result_list_utra.count = 
							(U8)p_MeasResult2UTRA_r9->measResultList_r9.count;
						p_node1 = p_MeasResult2UTRA_r9->measResultList_r9.head;

						if ((p_MeasResult2UTRA_r9->measResultList_r9.count >
									ARRSIZE(rrc_rrm_ue_information_resp.rlf_report.
										meas_result_neigh_cell.
										meas_result_list_utra.meas_result_utra[i].meas_result_list_utra.
										meas_result_utra)) ||
								(p_MeasResult2UTRA_r9->measResultList_r9.count <1))
						{
							RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
									p_ue_context->p_gb_context->facility_name,
									RRC_WARNING,
									"uecc_rrm_build_and_send_ue_information_resp wrong list count [%u] \
									for MeasResultUTRA",
									p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
									measResultListUTRA_r9.count);
							break;
						}    
						for(j = 0; j < p_MeasResult2UTRA_r9->measResultList_r9.count; j++)
						{
							RRC_ASSERT(PNULL != p_node1);
							RRC_ASSERT(PNULL != p_node1->data);
							result =  uecc_rrm_build_meas_result_utra(
									&rrc_rrm_ue_information_resp.rlf_report.
									meas_result_neigh_cell.meas_result_list_utra.meas_result_utra[i].
									meas_result_list_utra.meas_result_utra[j],
									p_node1->data,
									p_ue_context,
									p_ue_context->p_gb_context);

							if (RRC_FAILURE == result)
							{
								break;
							}    
							p_node1 = p_node1->next;
						}
						p_node = p_node->next;
					}
				}

				if(1 == p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.m.measResultListGERAN_r9Present)
				{

					rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.bitmask |=
						RRM_MEAS_RESULT_LIST_GERAN_PRESENT;

					rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.
						meas_result_list_geran.count=
						(U8)(p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
								measResultListGERAN_r9.count);


					p_node = p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
						measResultListGERAN_r9.head;
					if ((p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
								measResultListGERAN_r9.count >
								ARRSIZE(rrc_rrm_ue_information_resp.rlf_report.
									meas_result_neigh_cell.
									meas_result_list_geran.meas_result_geran)) ||
							(p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
							 measResultListGERAN_r9.count <1))
					{
						RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
								p_ue_context->p_gb_context->facility_name,
								RRC_WARNING,
								"uecc_rrm_build_meas_results_geran wrong list count [%u]",
								p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
								measResultListGERAN_r9.count);
						break;
					}    
					for (list_count = 0; list_count < p_UEInformationResp->rlf_Report_r9.
							measResultNeighCells_r9.measResultListGERAN_r9.count; list_count++)
					{
						RRC_ASSERT(PNULL != p_node);
						RRC_ASSERT(PNULL != p_node->data);

						result = uecc_rrm_build_meas_result_geran(
								p_ue_context,
								&rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.
								meas_result_list_geran.
								meas_result_geran[list_count],
								p_node->data);
						if (RRC_FAILURE == result)
						{
							break;
						}    
						p_node = p_node->next;
					}    
				}

				if(1 == p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.m.measResultsCDMA2000_r9Present)
				{

					rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.bitmask |=
						RRC_UE_INFO_MEAS_RESULT_LIST_CDMA2000_PRESENT;

					rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.meas_result_list2_cdma2000.count = 
						(U8)p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.measResultsCDMA2000_r9.count;

					p_node = p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.measResultsCDMA2000_r9.head;

					if ((p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
								measResultsCDMA2000_r9.count >
								ARRSIZE(rrc_rrm_ue_information_resp.rlf_report.
									meas_result_neigh_cell.
									meas_result_list2_cdma2000.meas_result_cdma2000)) ||
							(p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
							 measResultsCDMA2000_r9.count <1))
					{
						RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
								p_ue_context->p_gb_context->facility_name,
								RRC_WARNING,
								"uecc_rrm_build_and_send_ue_information_resp wrong list count [%u] \
								for MeasResultList2CDMA2000",
								p_UEInformationResp->rlf_Report_r9.measResultNeighCells_r9.
								measResultsCDMA2000_r9.count);
						break;
					}    
					for(i = 0; i< p_UEInformationResp->rlf_Report_r9.
							measResultNeighCells_r9.measResultsCDMA2000_r9.count; i++)
					{
						RRC_ASSERT(PNULL != p_node);
						RRC_ASSERT(PNULL != p_node->data);

						p_meas_cdma = (MeasResult2CDMA2000_r9*)p_node->data;

						rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.meas_result_list2_cdma2000.
							meas_result_cdma2000[i].carrier_freq_cdma2000.band_class = 
							(U8)p_meas_cdma->carrierFreq_r9.bandClass;

						rrc_rrm_ue_information_resp.rlf_report.meas_result_neigh_cell.meas_result_list2_cdma2000.
							meas_result_cdma2000[i].carrier_freq_cdma2000.arfcn = p_meas_cdma->carrierFreq_r9.arfcn;

						result = uecc_rrm_build_meas_results_cdma2000(
								&rrc_rrm_ue_information_resp.rlf_report.
								meas_result_neigh_cell.meas_result_list2_cdma2000.meas_result_cdma2000[i].
								meas_result_cdma2000,
								&(p_meas_cdma->measResultList_r9),
								p_ue_context,
								p_ue_context->p_gb_context);

						if (RRC_FAILURE == result)
						{
							break;
						}    

						p_node = p_node->next;
					}
				}
			}
			if(1 == p_UEInformationResp->rlf_Report_r9.m._v2ExtPresent)
			{
				if(1 == p_UEInformationResp->rlf_Report_r9.m.locationInfo_r10Present)
				{
					rrc_rrm_ue_information_resp.rlf_report.bitmask |=
						RRC_UE_INFO_RLF_REPORT_LOACTION_INFO_PRESENT;
					if(T_LocationInfo_r10_locationCoordinates_r10_ellipsoid_Point_r10 == p_UEInformationResp->rlf_Report_r9.locationInfo_r10.locationCoordinates_r10.t)
					{
						if(p_UEInformationResp->rlf_Report_r9.locationInfo_r10.locationCoordinates_r10.u.ellipsoid_Point_r10 != PNULL)
						{
							rrc_rrm_ue_information_resp.rlf_report.location_info.location_coordiate.bitmask |=
								RRC_RLF_LOCATION_CORD_ELLIPSOID_POINT_PRESENT;
							rrc_rrm_ue_information_resp.rlf_report.location_info.location_coordiate.ellipsoid_point.data_length =
								p_UEInformationResp->rlf_Report_r9.locationInfo_r10.locationCoordinates_r10.u.ellipsoid_Point_r10->numocts;
							l3_memcpy_wrapper(rrc_rrm_ue_information_resp.rlf_report.location_info.location_coordiate.ellipsoid_point.data,
									p_UEInformationResp->rlf_Report_r9.locationInfo_r10.locationCoordinates_r10.u.ellipsoid_Point_r10->data,
									rrc_rrm_ue_information_resp.rlf_report.location_info.location_coordiate.ellipsoid_point.data_length);
						}
						else
						{
							RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
									p_ue_context->p_gb_context->facility_name,
									RRC_WARNING,
									"uecc_rrm_build_and_send_ue_information_resp : "
									"ellispoid_point null.");
							break;
						}
					}
					else if(T_LocationInfo_r10_locationCoordinates_r10_ellipsoidPointWithAltitude_r10 == p_UEInformationResp->rlf_Report_r9.locationInfo_r10.locationCoordinates_r10.t)
					{
						if(p_UEInformationResp->rlf_Report_r9.locationInfo_r10.locationCoordinates_r10.u.ellipsoidPointWithAltitude_r10 != PNULL)
						{
							rrc_rrm_ue_information_resp.rlf_report.location_info.location_coordiate.ellipsoid_point_altitude.data_length = 
								p_UEInformationResp->rlf_Report_r9.locationInfo_r10.locationCoordinates_r10.u.ellipsoidPointWithAltitude_r10->numocts;
							l3_memcpy_wrapper(rrc_rrm_ue_information_resp.rlf_report.location_info.location_coordiate.ellipsoid_point_altitude.data,
									p_UEInformationResp->rlf_Report_r9.locationInfo_r10.locationCoordinates_r10.u.ellipsoidPointWithAltitude_r10->data,
									rrc_rrm_ue_information_resp.rlf_report.location_info.location_coordiate.ellipsoid_point_altitude.data_length);
						}
						else
						{
							RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
									p_ue_context->p_gb_context->facility_name,
									RRC_WARNING,
									"uecc_rrm_build_and_send_ue_information_resp : "
									"ellispoid_point_altitude null.");
							break;
						}
					}
					else
					{
						RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
								p_ue_context->p_gb_context->facility_name,
								RRC_WARNING,
								"uecc_rrm_build_and_send_ue_information_resp : "
								"Invalid option set");
						break;
					}
					if(1 == p_UEInformationResp->rlf_Report_r9.locationInfo_r10.m.horizontalVelocity_r10Present)
					{
						rrc_rrm_ue_information_resp.rlf_report.location_info.bitmask |=
							RRC_RLF_LOCATION_INFO_HORIZON_VELOCITY_PRESENT;
						rrc_rrm_ue_information_resp.rlf_report.location_info.horizontal_velocity.data_length = 
							p_UEInformationResp->rlf_Report_r9.locationInfo_r10.horizontalVelocity_r10.numocts;
						l3_memcpy_wrapper(rrc_rrm_ue_information_resp.rlf_report.location_info.horizontal_velocity.data,
								p_UEInformationResp->rlf_Report_r9.locationInfo_r10.horizontalVelocity_r10.data,
								rrc_rrm_ue_information_resp.rlf_report.location_info.horizontal_velocity.data_length);
					}
					if(1 == p_UEInformationResp->rlf_Report_r9.locationInfo_r10.m.gnss_TOD_msec_r10Present)
					{
						rrc_rrm_ue_information_resp.rlf_report.location_info.bitmask |=
							RRC_RLF_LOCATION_INFO_GNSS_TOD_MSEC_PRESENT;
						rrc_rrm_ue_information_resp.rlf_report.location_info.gnss_tod_msec.data_length = 
							p_UEInformationResp->rlf_Report_r9.locationInfo_r10.gnss_TOD_msec_r10.numocts;
						l3_memcpy_wrapper(rrc_rrm_ue_information_resp.rlf_report.location_info.gnss_tod_msec.data,
								p_UEInformationResp->rlf_Report_r9.locationInfo_r10.gnss_TOD_msec_r10.data,
								rrc_rrm_ue_information_resp.rlf_report.location_info.gnss_tod_msec.data_length);
					}
				}
				if(1 == p_UEInformationResp->rlf_Report_r9.m.failedPCellId_r10Present)
				{
					rrc_rrm_ue_information_resp.rlf_report.bitmask |=
						RRC_UE_INFO_FAILED_PCELLID_PRESENT;
					if(T_RLF_Report_r9_failedPCellId_r10_cellGlobalId_r10 == p_UEInformationResp->rlf_Report_r9.failedPCellId_r10.t)
					{
						if(p_UEInformationResp->rlf_Report_r9.failedPCellId_r10.u.cellGlobalId_r10 != PNULL)
						{
							rrc_rrm_ue_information_resp.rlf_report.failed_pcellid.bitmask |=
								RRC_RLF_FAILED_PCI_CELL_GLOBAL_ID_PRESENT;
							copy_cell_id(&rrc_rrm_ue_information_resp.rlf_report.failed_pcellid.cell_global_id,
									p_UEInformationResp->rlf_Report_r9.failedPCellId_r10.u.cellGlobalId_r10);
						}
					}
					else if(T_RLF_Report_r9_failedPCellId_r10_pci_arfcn_r10 == p_UEInformationResp->rlf_Report_r9.failedPCellId_r10.t)
					{
						if(p_UEInformationResp->rlf_Report_r9.failedPCellId_r10.u.pci_arfcn_r10 != PNULL)
						{
							rrc_rrm_ue_information_resp.rlf_report.failed_pcellid.bitmask |=
								RRC_RLF_FAILED_PCI_ARFCN_PRESENT;
							rrc_rrm_ue_information_resp.rlf_report.failed_pcellid.pci_arfcn.phys_cell_id = 
								p_UEInformationResp->rlf_Report_r9.failedPCellId_r10.u.pci_arfcn_r10->physCellId_r10;
							rrc_rrm_ue_information_resp.rlf_report.failed_pcellid.pci_arfcn.carrier_freq = 
								p_UEInformationResp->rlf_Report_r9.failedPCellId_r10.u.pci_arfcn_r10->carrierFreq_r10;
						}
					}
					else
					{
						RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
								p_ue_context->p_gb_context->facility_name,
								RRC_WARNING,
								"uecc_rrm_build_and_send_ue_information_resp : "
								"Invalid option set");
						break;
					}
				}
				if(1 == p_UEInformationResp->rlf_Report_r9.m.reestablishmentCellId_r10Present)
				{
					rrc_rrm_ue_information_resp.rlf_report.bitmask |=
						RRC_UE_INFO_REESTABLISHMENT_CELLID_PRESENT;
					copy_cell_id(&rrc_rrm_ue_information_resp.rlf_report.reestablish_cell_id,
							&p_UEInformationResp->rlf_Report_r9.reestablishmentCellId_r10);
				}
				if(1 == p_UEInformationResp->rlf_Report_r9.m.timeConnFailure_r10Present)
				{
					rrc_rrm_ue_information_resp.rlf_report.bitmask |=
						RRC_UE_INFO_TIME_CONN_FALURE_PRESENT;
					rrc_rrm_ue_information_resp.rlf_report.time_conn_failure =
						p_UEInformationResp->rlf_Report_r9.timeConnFailure_r10;
				}
				if(1 == p_UEInformationResp->rlf_Report_r9.m.connectionFailureType_r10Present)
				{
					rrc_rrm_ue_information_resp.rlf_report.bitmask |=
						RRC_UE_INFO_CONN_FALURE_TYPE_PRESENT;
					rrc_rrm_ue_information_resp.rlf_report.conn_failure_type = 
						p_UEInformationResp->rlf_Report_r9.connectionFailureType_r10;
				}
				if(1 == p_UEInformationResp->rlf_Report_r9.m.previousPCellId_r10Present)
				{
					rrc_rrm_ue_information_resp.rlf_report.bitmask |=
						RRC_UE_INFO_PREV_PCELLID_PRESENT;
					copy_cell_id(&rrc_rrm_ue_information_resp.rlf_report.previous_pcell_id,
							&p_UEInformationResp->rlf_Report_r9.previousPCellId_r10);
				}
			}

		}

		result = rrc_rrm_il_send_rrc_rrm_ue_information_resp(
				&rrc_rrm_ue_information_resp,
				RRC_UECC_MODULE_ID,
				RRC_RRM_MODULE_ID,
				p_ue_context->ue_info_transaction_id, 
				p_ue_context->cell_index);
	}while(0);   


	RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
	return result;
}
/* coverity_fix_54695_stop */

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_and_send_rrc_rrm_ue_information_failure
*   INPUT        : uecc_ue_context_t               *p_ue_context
*                  U8                               fail_cause
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds UE INFORMATION MESSAGE with negative response
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_rrc_rrm_ue_information_failure(
    uecc_ue_context_t               *p_ue_context,      /* UECC UE context */
    U8                               fail_cause
)
{
    rrc_return_et       result = RRC_FAILURE;

    static rrc_rrm_ue_information_resp_t rrc_rrm_ue_info_resp;
    
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&rrc_rrm_ue_info_resp, RRC_NULL, sizeof(rrc_rrm_ue_information_resp_t));
    
    rrc_rrm_ue_info_resp.bitmask |= RRC_RRM_UE_INFO_RESP_CAUSE_PRESENT;


    rrc_rrm_ue_info_resp.ue_Index = p_ue_context->ue_index;

    rrc_rrm_ue_info_resp.response = RRC_FAILURE;
    rrc_rrm_ue_info_resp.fail_cause = fail_cause;
    
    /* PUP encode and send */
    result = rrc_rrm_il_send_rrc_rrm_ue_information_resp(
                    &rrc_rrm_ue_info_resp,
                    RRC_UECC_MODULE_ID,
                    RRC_RRM_MODULE_ID,
                    p_ue_context->ue_info_transaction_id,
                    p_ue_context->cell_index);
     
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}

/****************************************************************************
 * Function Name  : uecc_rrm_ue_information_req_timer_expiry_handler
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 *                : uecc_timer_buffer_t- pointer to timer buffer
 * Outputs        : None
 * Returns        : None
 * Description    : handle timer expiry UECC_EV_UE_INFO_TIMER_EXPIRY 
 *                : for ue information procedure
 ****************************************************************************/
void uecc_rrm_ue_information_req_timer_expiry_handler(
    uecc_gb_context_t      *p_gb_context,
    uecc_timer_buffer_t*    p_uecc_timer_buffer    /* Timer buffer */
)
{
    U8        fail_cause = RRC_NULL;
    /*CA_PHASE3_INTER_CELL_MRO_START*/
    uecc_ue_context_t *p_ue_context = PNULL;
    /*CA_PHASE3_INTER_CELL_MRO_STOP*/

    RRC_ASSERT(PNULL != p_gb_context);
    RRC_ASSERT(PNULL != p_gb_context->ue_db.ue_contexts);
    RRC_ASSERT(PNULL != p_uecc_timer_buffer);
    
    /*CA_PHASE3_INTER_CELL_MRO_START*/
    p_ue_context = uecc_ue_ctx_get(p_gb_context,
            p_uecc_timer_buffer->ue_index);
    RRC_ASSERT(PNULL != p_ue_context);

    RRC_UECC_UT_TRACE_ENTER(p_gb_context);

    /* coverity_fix_64031_start */
    if(PNULL == p_ue_context)
    {
        RRC_UECC_TRACE(p_gb_context->context_index,
                p_gb_context->facility_name,RRC_ERROR,
                "ue context not found");
        return;
    }
    /* coverity_fix_64031_stop */

    uecc_ue_timer_mark_as_expired(
            p_gb_context,
            p_uecc_timer_buffer->id,
            &p_ue_context->timers_data);

    /*Reset UE Information proc indicator in UE Context */
    p_ue_context->ue_info_proc_running = RRC_FALSE;
    fail_cause = RRM_RRC_UE_INFO_TIMER_EXPIRY;       

        /* BUG:9438 fix start */
        /* ue_information response is not received so rlf report will not be sent in
           reestablishment indication */
        p_ue_context->rlf_proc_flags.m.rlf_report_present = X2AP_NULL;
        /* BUG:9438 fix stop */

    if (p_ue_context->rlf_proc_flags.ue_info_proc_intrl == RRC_TRUE)
    {
        /*CA_PHASE3_INTER_CELL_MRO_START*/
        if (RRC_TRUE == p_ue_context->too_late_inter_cell_ho_flg)
        {    
            if (RRC_FAILURE == x2ap_build_and_send_rlf_ind(p_ue_context,
                        p_ue_context->p_gb_context))
            {     
                RRC_UECC_TRACE(p_gb_context->context_index,
                        p_gb_context->facility_name,
                        RRC_ERROR,"x2ap_build_and_send_rlf_ind failed.");
            }    
            p_ue_context->too_late_inter_cell_ho_flg = RRC_FALSE;
        }   
        /*CA_PHASE3_INTER_CELL_MRO_STOP*/
        else 
        {
            if (RRC_FAILURE == x2ap_build_and_send_reestablishment_ind(
                        p_ue_context))
            {
                RRC_UECC_TRACE(p_gb_context->context_index,
                        p_gb_context->facility_name,RRC_ERROR,
                        "x2ap_build_and_send_reestablishment_ind failed.");

            }
        }
        p_ue_context->rlf_proc_flags.ue_info_proc_intrl = RRC_FALSE;
    }
    else
    {
        if (RRC_SUCCESS != 
                uecc_rrm_build_and_send_rrc_rrm_ue_information_failure(
                    p_ue_context,fail_cause))
        {
            RRC_UECC_TRACE(
                    p_gb_context->context_index,
                    p_gb_context->facility_name,
                    RRC_ERROR,
                    "RRC_RRM_UE_INFORMATION failure message not sent to RRM");
        }
    }
    /*CA_PHASE3_INTER_CELL_MRO_STOP*/

    RRC_UECC_UT_TRACE_EXIT(p_gb_context);
}

/****************************************************************************
 * Function Name  : uecc_rrm_ue_information_req_stop_timer
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : None
 * Description    : Stop UE_RRM_UE_INFO_REQ Procedural timer
 ****************************************************************************/
void uecc_rrm_ue_information_req_stop_timer(
    uecc_ue_context_t   *p_ue_context
)
{

    RRC_ASSERT(PNULL != p_ue_context);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    /*Reset UE Information proc indicator in UE Context */
    p_ue_context->ue_info_proc_running = RRC_FALSE;

    /* Stop procedural timer */
    if (p_ue_context->timers_data.timers_ids[UECC_UE_INFORMATION_GUARD_TIMER] != PNULL)
    {
        RRC_UECC_TRACE(
        p_ue_context->p_gb_context->context_index,
        p_ue_context->p_gb_context->facility_name,
        RRC_BRIEF,
        "Stop timer [UECC_RRM_UE_INFORMATION_REQ_TIMER]");
        
        rrc_stop_timer(p_ue_context->timers_data.timers_ids[UECC_UE_INFORMATION_GUARD_TIMER]);
        p_ue_context->timers_data.timers_ids[UECC_UE_INFORMATION_GUARD_TIMER] = PNULL;
    }

    else if(p_ue_context->timers_data.timers_ids[UECC_UE_INFORMATION_GUARD_TIMER] == PNULL)
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
        p_ue_context->p_gb_context->facility_name,
        RRC_BRIEF,
        "Timer Already Stopped [UECC_RRM_UE_INFORMATION_REQ_TIMER]");
    }
        
    if (p_ue_context->rlf_proc_flags.ue_info_proc_intrl == RRC_TRUE)
    {
        if(RRC_FAILURE == x2ap_build_and_send_reestablishment_ind(
                    p_ue_context))
        {
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name,RRC_ERROR,
                    "x2ap_build_and_send_reestablishment_ind failed.");
        }
        p_ue_context->rlf_proc_flags.ue_info_proc_intrl = RRC_FALSE;
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/****************************************************************************
 * Function Name  : uecc_fsm_rrm_ue_information_req_start_timer
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 * Outputs        : None
 * Returns        : None
 * Description    : Starts UE_UI_RRM_REQ Procedural timer
 ****************************************************************************/
void uecc_fsm_rrm_ue_information_req_start_timer(
    uecc_ue_context_t   *p_ue_context
)
{
    uecc_timer_buffer_t repeated_timer_buf;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if ( PNULL != p_ue_context->timers_data.timers_ids[UECC_UE_INFORMATION_GUARD_TIMER] )
    {
        /* Already started */
        return;
    }


    /* Start the Procedural timer*/
    repeated_timer_buf.type = UECC_TIMER_TYPE_RRC_PROCEDURAL;
    repeated_timer_buf.id = UECC_UE_INFORMATION_GUARD_TIMER;
    repeated_timer_buf.auto_delete = RRC_TRUE;
    repeated_timer_buf.ue_index = p_ue_context->ue_index;
    repeated_timer_buf.fsm_event_id = UECC_EV_UE_INFO_TIMER_EXPIRY;

    

    p_ue_context->timers_data.timers_ids[UECC_UE_INFORMATION_GUARD_TIMER] = rrc_start_timer(
        p_ue_context->p_gb_context->ue_timers_data.durations[UECC_UE_INFORMATION_GUARD_TIMER],
        &repeated_timer_buf,
        sizeof(uecc_timer_buffer_t),
        uecc_ue_timers_descriptors[UECC_UE_INFORMATION_GUARD_TIMER].is_repeated);

    if ( PNULL == p_ue_context->timers_data.timers_ids[UECC_UE_INFORMATION_GUARD_TIMER])
    {
        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
        p_ue_context->p_gb_context->facility_name,
        RRC_ERROR,
        "[UECC_UE_INFORMATION_GUARD_TIMER] Starting error");
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_ue_information_req
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function processes uecc_rrm_process_ue_information_req message
*       from RRM
*
*   RETURNS:
*       None
*
******************************************************************************/
void uecc_rrm_process_ue_information_req
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    rrc_return_et                       result = RRC_FAILURE;
    uecc_ue_context_t*                  p_ue_context = PNULL;
    rrc_rrm_ue_information_req_t        rrc_rrm_ue_info_req;
    S32                                 length_read = RRC_NULL;
    U8                                  fail_cause = RRC_NULL;
    rrc_cell_index_t                    cell_index = RRC_INVALID_CELL_INDEX;
    ue_reconfig_queue_node_t            *p_ue_reconfig_queue_node = PNULL;
    list_t                              *p_ue_reconfig_queue = PNULL;

    RRC_ASSERT(PNULL != p_api);
    RRC_ASSERT(PNULL != p_uecc_gb_context);
    
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    
    do
    {
        memset_wrapper(&rrc_rrm_ue_info_req, RRC_NULL,
                sizeof(rrc_rrm_ue_information_req_t));
    
        result = rrc_il_parse_rrc_rrm_ue_information_req(
                    &rrc_rrm_ue_info_req,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_WARNING,
            "uecc_rrm_process_ue_information_req : "
            "The RRC_RRM_UE_INFORMATION_REQ parsing error.");
            
            break;
        }

        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", rrc_rrm_ue_info_req.ue_Index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            rrc_rrm_ue_info_req.ue_Index);

        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
            p_uecc_gb_context->facility_name,
            RRC_WARNING,
            "uecc_rrm_process_ue_information_req : " 
            "The UE context isn't found");

            break;
        }

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_UE_ADMISSION_RESP] Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,"cell not active");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }

        /* save the transaction_id of RRM procedure in UE context
         * ue_info_transaction_id
         * */
        p_ue_context->ue_info_transaction_id = rrc_get_transaction_id(p_api);

        /* check if main FSM state is not 
         * UECC_UE_IDLE, UECC_UE_CONNECTION_SETUP_ONGOING
         * UECC_WAIT_FOR_CONNECTION_RELEASE, UECC_UE_CONNECTION_RELEASE_ONGOING
         * 
         * also have to check with the UECC_UE_WAIT_FOR_S1_CONNECTION
         * and UECC_S1_CONNECTION_ONGOING 
         */ 
        if (p_ue_context->uecc_fsm.p_current_state->s_name != PNULL)
        {
            if ((!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                            (const S8 *)"UECC_UE_IDLE")) ||
                    (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                 (const S8 *)"UECC_UE_CONNECTION_SETUP_ONGOING")) ||
                    (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                 (const S8 *)"UECC_UE_WAIT_FOR_CONNECTION_RELEASE")) ||
                    (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                 (const S8 *)"UECC_UE_CONNECTION_RELEASE_ONGOING")) ||
                    (!strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                                 (const S8 *)"UECC_UE_WAIT_FOR_S1_CONNECTION")))
            {
                fail_cause = RRM_RRC_UE_INFO_INTERACTION_WITH_OTHER_PROCEDURE_FAILURE;
                  /* Build and send the RRC_RRM_UE_INFORMATION_RESP(failure) to RRM. */
                  if (RRC_SUCCESS != uecc_rrm_build_and_send_rrc_rrm_ue_information_failure
                          (p_ue_context, fail_cause))
                  {
                    /* Process failure according to selected failure actions list */
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "Failure to build and send ue information resp to RRM.");
                    
                    break;
                  }
                break;
            }
        }
        /*Klockwork Fix*/
        if((PNULL  !=  p_ue_context->uecc_fsm.p_current_state->s_name)
                        && 
          (RRC_NULL != strcmp_wrapper(p_ue_context->uecc_fsm.p_current_state->s_name,
                    (const S8 *)"UECC_UE_CONNECTED"))) /*Klockwork Fix*/
        {
            p_ue_reconfig_queue_node = (ue_reconfig_queue_node_t *)
                rrc_mem_get(sizeof(ue_reconfig_queue_node_t) + rrc_get_api_buf_size(p_api));
            
            if (PNULL != p_ue_reconfig_queue_node)
            {
                p_ue_reconfig_queue_node->message_type = UE_INFORMATION_REQUEST;
                
                l3_memcpy_wrapper((void*)p_ue_reconfig_queue_node->message,
                        (const void*)p_api, rrc_get_api_buf_size(p_api));

                p_ue_reconfig_queue = &p_ue_context->ue_reconfig_queue;

                if ((RECONFIGURATION_Q_GET_COUNT(p_ue_reconfig_queue)) < 
                        RECONFIGURATION_Q_MAX_LENGTH)
                {
                    RECONFIGURATION_Q_ENQUEUE(p_ue_reconfig_queue, 
                            p_ue_reconfig_queue_node);
                    
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_INFO,
                            "[RRC_RRM_UE_INFORMATION_REQ] Enqueued in "
                            "reconfiguration queue . Queue length :%d",
                            RECONFIGURATION_Q_GET_COUNT(p_ue_reconfig_queue));
                }
                else
                {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_ERROR, 
                            "[RRC_RRM_UE_INFORMATION_REQ]Reconfiguration Queue Full : Message Discarded");

                    /* Build and send the RRC_RRM_UE_INFORMATION_RESP(failure) to RRM. */
                    if (RRC_SUCCESS != uecc_rrm_build_and_send_rrc_rrm_ue_information_failure
                            (p_ue_context, RRM_RRC_UE_INFO_INTERNAL_FAILURE))
                    {
                        /* Process failure according to selected failure actions list */
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                                p_uecc_gb_context->facility_name,
                                RRC_WARNING,
                                "Failure to build and send ue information resp to RRM.");
                    }
                    /* coverity_fix_63282_start */
                    rrc_mem_free(p_ue_reconfig_queue_node);
                    /* Coverity ID 85896 Fix Start*/
                   /* p_ue_reconfig_queue_node = PNULL; */
                    /* Coverity ID 85896 Fix End*/
                    /* coverity_fix_63282_stop */
                }
            }
            else
            {
                    RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_ERROR,
                    "Mem Alloc failed : Ignoring [RRC_RRM_UE_INFORMATION_REQ]");                
            }
        }
        else
        {
            uecc_rrm_ue_information_req_handler(p_ue_context, &rrc_rrm_ue_info_req);
        }
    }
    while(0);

   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/****************************************************************************
 * Function Name  : uecc_rrm_ue_information_req_handler
 * Inputs         : uecc_ue_context_t* - pointer to UE context
 *                  void*   - api data
 * Outputs        : None
 * Returns        : None
 * Description    : This action routine is called UECC receives
 *                  RRC_RRM_UE_INFORMATION_REQ message
 ****************************************************************************/

void uecc_rrm_ue_information_req_handler(
    uecc_ue_context_t   *p_ue_context,      /* UECC UE context */
    void                *p_api              /* Input API buffer */
)
{
    U8          fail_cause = RRC_NULL;
    
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_api);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);


    /* Start timer */
    uecc_fsm_rrm_ue_information_req_start_timer(p_ue_context);

    /*Set UE Information proc running flag in ue context */
    p_ue_context->ue_info_proc_running = RRC_TRUE;

    /* UE INFORMATION REQ */
    if (RRC_SUCCESS !=
            uecc_llim_build_and_send_rrc_ue_information(p_ue_context, p_api))
    {
         uecc_rrm_ue_information_req_stop_timer(p_ue_context);
         fail_cause = RRM_RRC_UE_INFO_INTERNAL_FAILURE;             ;
         if(RRC_SUCCESS != uecc_rrm_build_and_send_rrc_rrm_ue_information_failure(p_ue_context,fail_cause))
         {
             RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
             p_ue_context->p_gb_context->facility_name,
             RRC_ERROR,
             "RRC_RRM_UE_INFORMATION failure message not sent to RRM");
         }
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/* CR 543 changes */
/****************************************************************************
 * Function Name  : uecc_rrm_build_band_combination_parameters_r10
 * Inputs         : band_combination_parameters_r10_t                    *
 * p_band_combination_params
 *                  BandCombinationParameters_r10 * p_band_comb_asn_params 
 * Outputs        : None
 * Returns        : None
 * Description    : This action routine is called UECC receives
 *                  RRC_RRM_UE_INFORMATION_REQ message
 ****************************************************************************/
void uecc_rrm_build_band_combination_parameters_r10(
        uecc_ue_context_t                   *p_ue_context,      /* Added UE context */
        band_combination_parameters_r10_t   *p_band_combination_params,
        void *                              p_api)
{
    U8                  i = 0 ;
    U8                  j = 0 ;
    OSRTDListNode*      p_node = PNULL;
    OSRTDListNode*      p_ca_node = PNULL;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_band_combination_params);
    RRC_ASSERT(PNULL != p_api);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);   
    RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,p_ue_context->p_gb_context->facility_name,
                          RRC_DETAILEDALL,"Unused variable"
                          "p_ue_context=%p",p_ue_context);/*SPR 17777 +-*/
    memset_wrapper(p_band_combination_params, RRC_NULL, 
            sizeof(band_combination_parameters_r10_t));

    BandCombinationParameters_r10       *p_band_comb_asn_params;
    BandParameters_r10       *p_band_parameter_data;
    CA_MIMO_ParametersUL_r10 *p_ca_mimo_ul_params;
    CA_MIMO_ParametersDL_r10 *p_ca_mimo_dl_params;
    p_band_comb_asn_params = (BandCombinationParameters_r10 *)p_api;
    p_band_combination_params->count = p_band_comb_asn_params->count;
    p_node = p_band_comb_asn_params->head; 
    for( i = 0; i < p_band_comb_asn_params->count ;i++)
    {
        p_band_parameter_data = (BandParameters_r10 *)p_node->data;
        /* filling band eutra release 10 */
        p_band_combination_params->band_parameters_info[i].band_eutra_r10 = p_band_parameter_data->bandEUTRA_r10; 
        /* filling uplink band parameters release 10 */
        if( 1 == p_band_parameter_data->m.bandParametersUL_r10Present )
        {
            p_band_combination_params->
                band_parameters_info[i].bitmask |=
                RRC_RRM_BAND_PARAMETERS_UL_R10_IES_PRESENT;
            
            p_band_combination_params->band_parameters_info[i].
                band_parameters_ul_r10.count = p_band_parameter_data->
                    bandParametersUL_r10.count;
            
            p_ca_node = p_band_parameter_data->bandParametersUL_r10.head;
            
            for(j = 0; j < p_band_parameter_data->bandParametersUL_r10.count ; j++)
            {
                p_ca_mimo_ul_params = (CA_MIMO_ParametersUL_r10 *)p_ca_node->data;
                
                p_band_combination_params->band_parameters_info[i].
                    band_parameters_ul_r10.ca_mimo_parameters_ul_r10[j].
                       ca_band_width_class_ul_r10 =
                       (ca_band_width_class_r10_et)p_ca_mimo_ul_params->ca_BandwidthClassUL_r10;

                if(1 == p_ca_mimo_ul_params->m.supportedMIMO_CapabilityUL_r10Present)
                {
                    p_band_combination_params->band_parameters_info[i].
                        band_parameters_ul_r10.ca_mimo_parameters_ul_r10[j].bitmask = 0;

                    p_band_combination_params->band_parameters_info[i].
                        band_parameters_ul_r10.ca_mimo_parameters_ul_r10[j].bitmask |= 
                            RRC_RRM_SUPPORTED_MIMO_CAPABILITY_UL_R10_IE_PRESENT;
                    
                    p_band_combination_params->band_parameters_info[i].
                        band_parameters_ul_r10.ca_mimo_parameters_ul_r10[j].
                          supported_mimo_capability_ul_r10 =
                          (mimo_capability_ul_r10_et)p_ca_mimo_ul_params->
                            supportedMIMO_CapabilityUL_r10;
                }
                p_ca_node = p_ca_node->next;
            }
        }
        /* filling downlink band parameters release 10 */
        if( 1 == p_band_parameter_data->m.bandParametersDL_r10Present )
        {
            p_band_combination_params->
                band_parameters_info[i].bitmask |=
                RRC_RRM_BAND_PARAMETERS_DL_R10_IES_PRESENT;

            p_band_combination_params->band_parameters_info[i].
                band_parameters_dl_r10.count = p_band_parameter_data->bandParametersDL_r10.count;

            p_ca_node = p_band_parameter_data->bandParametersDL_r10.head;

            for(j = 0; j < p_band_parameter_data->bandParametersDL_r10.count ; j++)
            {
                p_ca_mimo_dl_params = (CA_MIMO_ParametersDL_r10 *)p_ca_node->data;

                p_band_combination_params->band_parameters_info[i].
                    band_parameters_dl_r10.ca_mimo_parameters_dl_r10[j].
                      ca_band_width_class_dl_r10 = (ca_band_width_class_r10_et)p_ca_mimo_dl_params->ca_BandwidthClassDL_r10;

                if(1 == p_ca_mimo_dl_params->m.supportedMIMO_CapabilityDL_r10Present)
                {
                    p_band_combination_params->band_parameters_info[i].
                        band_parameters_dl_r10.ca_mimo_parameters_dl_r10[j].bitmask = 0;

                    p_band_combination_params->band_parameters_info[i].
                        band_parameters_dl_r10.ca_mimo_parameters_dl_r10[j].bitmask |= 
                          RRC_RRM_SUPPORTED_MIMO_CAPABILITY_DL_R10_IE_PRESENT;

                    p_band_combination_params->band_parameters_info[i].
                        band_parameters_dl_r10.ca_mimo_parameters_dl_r10[j].
                          supported_mimo_capability_dl_r10 =
                          (mimo_capability_dl_r10_et)p_ca_mimo_dl_params->
                            supportedMIMO_CapabilityDL_r10;
                }
                p_ca_node = p_ca_node->next;
            }
        }
        p_node = p_node->next; 
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}
/* CR 543 changes */
/* CR 678 changes */
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_check_band_in_rf_parameters
*
*   DESCRIPTION:
*       This function builds UE INFORMATION MESSAGE with negative response
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_check_band_in_rf_parameters(
    uecc_gb_context_t           *p_uecc_gb_context, 
    RF_Parameters               *p_rf_parameters,
    RF_Parameters_v1020         *p_rf_rel10_parameters)
{
    U8                  i = 0;
    U8                  j = 0;
    U8                  k = 0;
    rrc_return_et       result = RRC_FAILURE;
    rrc_bool_et         present = RRC_FALSE;
    OSRTDListNode*      p_node = PNULL;
    OSRTDListNode*      p_rel10_node = PNULL;
    OSRTDListNode*      p_band_param_node = PNULL;
    BandCombinationParameters_r10   *p_band_combination_params = PNULL;
    BandParameters_r10              *p_band_parameters = PNULL;
    SupportedBandEUTRA              *p_sup_band_eutra = PNULL;

    RRC_ASSERT(PNULL != p_uecc_gb_context);
    RRC_ASSERT(PNULL != p_rf_parameters);
    RRC_ASSERT(PNULL != p_rf_rel10_parameters);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
    p_rel10_node = p_rf_rel10_parameters->supportedBandCombination_r10.head;
    for( i = 0 ; i < p_rf_rel10_parameters->supportedBandCombination_r10.count ; i++ )
    {
        p_band_combination_params = (BandCombinationParameters_r10 *)p_rel10_node->data;
        if (PNULL != p_band_combination_params)
        {
            p_band_param_node = p_band_combination_params->head;
            if (PNULL != p_band_param_node)
            {
                for( j = 0 ; j < p_band_combination_params->count ; j++ )
                {
                    p_band_parameters = (BandParameters_r10 *)p_band_param_node->data;
                    if(PNULL != p_band_parameters)
                    {
                        p_node = p_rf_parameters->supportedBandListEUTRA.head;
                        for( k = 0 ; k < p_rf_parameters->supportedBandListEUTRA.count ; k++ )
                        {
                            p_sup_band_eutra = (SupportedBandEUTRA *)p_node->data;
                            if( p_band_parameters->bandEUTRA_r10 == p_sup_band_eutra->bandEUTRA )
                            {
                                present = RRC_TRUE ;
                                result = RRC_SUCCESS;
                                break;
                            }
                            p_node = p_node->next;
                        }
                        if( RRC_FALSE == present )
                        {
                            result = RRC_FAILURE ;
                            return result;
                        }
                        p_band_param_node = p_band_param_node->next;
                        present = RRC_FALSE;
                    }
                }
            }
            p_rel10_node = p_rel10_node->next ;
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    
    return result;
}
/* CR 678 changes */



/*CR 895 changes start*/

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_ue_eutra_capability_v9a0
*
*   DESCRIPTION:
*       This function builds UE_EUTRA_Capability_v9a0_IEs message
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_ue_eutra_capability_v9a0(
        uecc_ue_context_t               *p_ue_context,      /* Added UE context */        
        ue_eutra_capability_v9a0_ies_t *p_ue_eutra_capability,
        UE_EUTRA_Capability_v9a0_IEs   *p_UE_EUTRA_Capability_v9a0
)
{
    rrc_return_et       result = RRC_FAILURE;
    U32                 index = 0;
    RRC_ASSERT(PNULL != p_UE_EUTRA_Capability_v9a0);
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,p_ue_context->p_gb_context->facility_name,
                          RRC_DETAILEDALL,"Unused variable"
                          "p_ue_context=%p",p_ue_context);/*SPR 17777 +-*/
    if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->m.featureGroupIndRel9Add_r9Present)
    {
        p_ue_eutra_capability->bitmask |= RRC_RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_IND_REL9_ADD_PRESENT;
        
        l3_memcpy_wrapper(p_ue_eutra_capability->feature_group_ind_rel9add_r9, 
                p_UE_EUTRA_Capability_v9a0->featureGroupIndRel9Add_r9.data,
                ARRSIZE(p_ue_eutra_capability->feature_group_ind_rel9add_r9));
    }

    if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->m.fdd_Add_UE_EUTRA_Capabilities_r9Present)
    {
        p_ue_eutra_capability->bitmask |= RRC_RRM_UE_EUTRA_CAPABILITY_ADDFDD_MODE_R9_PRESENT;
        
        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.m.
                phyLayerParameters_r9Present)
        {
            p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.bitmask |= 
                RRC_RRM_UE_EUTRA_CAPABILITY_PHY_LAYER_PARAMETERS_R9_PRESENT;

            p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.phy_layer_parameters_r9.
                ue_TxAntennaSelectionSupported = p_UE_EUTRA_Capability_v9a0->
                fdd_Add_UE_EUTRA_Capabilities_r9.phyLayerParameters_r9.ue_TxAntennaSelectionSupported;

            p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.phy_layer_parameters_r9.
                ue_SpecificRefSigsSupported = p_UE_EUTRA_Capability_v9a0->
                fdd_Add_UE_EUTRA_Capabilities_r9.phyLayerParameters_r9.ue_SpecificRefSigsSupported;
        }

        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.m.
                featureGroupIndicators_r9Present)
        {
            p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.bitmask |=
                RRC_RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_INDICATORS_R9_PRESENT;

            l3_memcpy_wrapper(p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.feature_group_indicators_r9,
                    p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.featureGroupIndicators_r9.
                    data, ARRSIZE(p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.
                        feature_group_indicators_r9));
        }

        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.m.
                featureGroupIndRel9Add_r9Present)
        {
            p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.bitmask |=
                RRC_RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_IND_R9ADD_PRESENT;

            l3_memcpy_wrapper(p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.feature_group_ind_rel9add_r9,
                    p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.featureGroupIndRel9Add_r9.data,
                    ARRSIZE(p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.feature_group_ind_rel9add_r9));
        }

        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.m.
                interRAT_ParametersGERAN_r9Present)
        {
            p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.bitmask |=
                RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_GERAN_R9_PRESENT;

            p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.inter_rat_parameters_geran_r9.
                supported_band_list_geran.count = p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.
                interRAT_ParametersGERAN_r9.supportedBandListGERAN.n;

            for (index = 0; index < p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.
                    interRAT_ParametersGERAN_r9.supportedBandListGERAN.n; index++)
            {
                p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.inter_rat_parameters_geran_r9.
                    supported_band_list_geran.supported_band_geran[index] = 
                    p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.
                    interRAT_ParametersGERAN_r9.supportedBandListGERAN.elem[index];
            }

            p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.inter_rat_parameters_geran_r9.
                inter_rat_ps_ho_to_geran = p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.
                interRAT_ParametersGERAN_r9.interRAT_PS_HO_ToGERAN;
        }

        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.m.
            interRAT_ParametersUTRA_r9Present)
        {
            p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.bitmask |= 
                RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_UTRA_R9_PRESENT;

            p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.inter_rat_parameters_utra_r9.
                e_redirection_utra_r9 = p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.
                interRAT_ParametersUTRA_r9.e_RedirectionUTRA_r9;
        }

        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.m.
                interRAT_ParametersCDMA2000_r9Present)
        {
            p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.bitmask |=
                RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_CDMA2000_R9_PRESENT;
            
            if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.
                    interRAT_ParametersCDMA2000_r9.m.e_CSFB_ConcPS_Mob1XRTT_r9Present)
            {
                p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.inter_rat_parameters_cdma2000_r9.
                    bitmask |= IRAT_PARAMS_CDMA_V920_E_CSFB_CONC_PS_MOB_1XRTT_R9_PRESENT;

                p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.inter_rat_parameters_cdma2000_r9.
                    eCSFB_1xrtt_r9 = p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.
                    interRAT_ParametersCDMA2000_r9.e_CSFB_1XRTT_r9;

                p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.inter_rat_parameters_cdma2000_r9.
                    eCSFB_conc_ps_mobility_1xrtt_r9 = p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.
                    interRAT_ParametersCDMA2000_r9.e_CSFB_ConcPS_Mob1XRTT_r9;
            }
        }

        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.m.
                neighCellSI_AcquisitionParameters_r9Present)
        {
            p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.bitmask |=
                RRC_RRM_UE_EUTRA_CAPABILITY_NEIGH_CELLSI_ACQUISITION_PARAMS_R9_PRESENT;
            
            if ((RRC_TRUE == p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.
                    neighCellSI_AcquisitionParameters_r9.m.intraFreqSI_AcquisitionForHO_r9Present) &&
                    (supported_25 == p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.
                     neighCellSI_AcquisitionParameters_r9.intraFreqSI_AcquisitionForHO_r9))
            {
                p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.neigh_cellsi_acquisition_parameters_r9.
                    intra_freq_si_acquisition_for_ho_supported_r9 = RRC_TRUE;
            }
                
            if ((RRC_TRUE == p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.
                        neighCellSI_AcquisitionParameters_r9.m.interFreqSI_AcquisitionForHO_r9Present) &&
                    (supported_26 == p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.
                     neighCellSI_AcquisitionParameters_r9.interFreqSI_AcquisitionForHO_r9))
            {
                p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.neigh_cellsi_acquisition_parameters_r9.
                    inter_freq_si_acquisition_for_ho_supported_r9 = RRC_TRUE;
            }

            if ((RRC_TRUE == p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.
                        neighCellSI_AcquisitionParameters_r9.m.utran_SI_AcquisitionForHO_r9Present) &&
                    (supported_27 == p_UE_EUTRA_Capability_v9a0->fdd_Add_UE_EUTRA_Capabilities_r9.
                     neighCellSI_AcquisitionParameters_r9.utran_SI_AcquisitionForHO_r9))
            {
                p_ue_eutra_capability->fdd_add_ue_eutra_capabilities_r9.neigh_cellsi_acquisition_parameters_r9.
                    utran_si_acquisition_for_ho_supported_r9 = RRC_TRUE;
            }
        }
    }

    if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->m.tdd_Add_UE_EUTRA_Capabilities_r9Present)
    {
        p_ue_eutra_capability->bitmask |= RRC_RRM_UE_EUTRA_CAPABILITY_ADDTDD_MODE_R9_PRESENT;
        
        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.m.
                phyLayerParameters_r9Present)
        {
            p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.bitmask |= 
                RRC_RRM_UE_EUTRA_CAPABILITY_PHY_LAYER_PARAMETERS_R9_PRESENT;

            p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.phy_layer_parameters_r9.
                ue_TxAntennaSelectionSupported = p_UE_EUTRA_Capability_v9a0->
                tdd_Add_UE_EUTRA_Capabilities_r9.phyLayerParameters_r9.ue_TxAntennaSelectionSupported;

            p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.phy_layer_parameters_r9.
                ue_SpecificRefSigsSupported = p_UE_EUTRA_Capability_v9a0->
                tdd_Add_UE_EUTRA_Capabilities_r9.phyLayerParameters_r9.ue_SpecificRefSigsSupported;
        }

        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.m.
                featureGroupIndicators_r9Present)
        {
            p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.bitmask |=
                RRC_RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_INDICATORS_R9_PRESENT;

            l3_memcpy_wrapper(p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.feature_group_indicators_r9,
                    p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.featureGroupIndicators_r9.
                    data, ARRSIZE(p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.
                        feature_group_indicators_r9));
        }

        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.m.
                featureGroupIndRel9Add_r9Present)
        {
            p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.bitmask |=
                RRC_RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_IND_R9ADD_PRESENT;

            l3_memcpy_wrapper(p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.feature_group_ind_rel9add_r9,
                    p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.featureGroupIndRel9Add_r9.data,
                    ARRSIZE(p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.feature_group_ind_rel9add_r9));
        }

        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.m.
                interRAT_ParametersGERAN_r9Present)
        {
            p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.bitmask |=
                RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_GERAN_R9_PRESENT;

            p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.inter_rat_parameters_geran_r9.
                supported_band_list_geran.count = (U8)p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.
                interRAT_ParametersGERAN_r9.supportedBandListGERAN.n;

            for (index = 0; index < p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.
                    interRAT_ParametersGERAN_r9.supportedBandListGERAN.n; index++)
            {
                p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.inter_rat_parameters_geran_r9.
                    supported_band_list_geran.supported_band_geran[index] = 
                    p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.
                    interRAT_ParametersGERAN_r9.supportedBandListGERAN.elem[index];
            }

            p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.inter_rat_parameters_geran_r9.
                inter_rat_ps_ho_to_geran = p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.
                interRAT_ParametersGERAN_r9.interRAT_PS_HO_ToGERAN;
        }

        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.m.
            interRAT_ParametersUTRA_r9Present)
        {
            p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.bitmask |= 
                RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_UTRA_R9_PRESENT;

            p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.inter_rat_parameters_utra_r9.
                e_redirection_utra_r9 = p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.
                interRAT_ParametersUTRA_r9.e_RedirectionUTRA_r9;
        }

        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.m.
                interRAT_ParametersCDMA2000_r9Present)
        {
            p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.bitmask |=
                RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_CDMA2000_R9_PRESENT;
            
            if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.
                    interRAT_ParametersCDMA2000_r9.m.e_CSFB_ConcPS_Mob1XRTT_r9Present)
            {
                p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.inter_rat_parameters_cdma2000_r9.
                    bitmask |= IRAT_PARAMS_CDMA_V920_E_CSFB_CONC_PS_MOB_1XRTT_R9_PRESENT;

                p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.inter_rat_parameters_cdma2000_r9.
                    eCSFB_1xrtt_r9 = p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.
                    interRAT_ParametersCDMA2000_r9.e_CSFB_1XRTT_r9;

                p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.inter_rat_parameters_cdma2000_r9.
                    eCSFB_conc_ps_mobility_1xrtt_r9 = p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.
                    interRAT_ParametersCDMA2000_r9.e_CSFB_ConcPS_Mob1XRTT_r9;
            }
        }

        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.m.
                neighCellSI_AcquisitionParameters_r9Present)
        {
            p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.bitmask |=
                RRC_RRM_UE_EUTRA_CAPABILITY_NEIGH_CELLSI_ACQUISITION_PARAMS_R9_PRESENT;
            
            if ((RRC_TRUE == p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.
                    neighCellSI_AcquisitionParameters_r9.m.intraFreqSI_AcquisitionForHO_r9Present) &&
                    (supported_25 == p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.
                     neighCellSI_AcquisitionParameters_r9.intraFreqSI_AcquisitionForHO_r9))
            {
                p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.neigh_cellsi_acquisition_parameters_r9.
                    intra_freq_si_acquisition_for_ho_supported_r9 = RRC_TRUE;
            }
                
            if ((RRC_TRUE == p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.
                        neighCellSI_AcquisitionParameters_r9.m.interFreqSI_AcquisitionForHO_r9Present) &&
                    (supported_26 == p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.
                     neighCellSI_AcquisitionParameters_r9.interFreqSI_AcquisitionForHO_r9))
            {
                p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.neigh_cellsi_acquisition_parameters_r9.
                    inter_freq_si_acquisition_for_ho_supported_r9 = RRC_TRUE;
            }

            if ((RRC_TRUE == p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.
                        neighCellSI_AcquisitionParameters_r9.m.utran_SI_AcquisitionForHO_r9Present) &&
                    (supported_27 == p_UE_EUTRA_Capability_v9a0->tdd_Add_UE_EUTRA_Capabilities_r9.
                     neighCellSI_AcquisitionParameters_r9.utran_SI_AcquisitionForHO_r9))
            {
                p_ue_eutra_capability->tdd_add_ue_eutra_capabilities_r9.neigh_cellsi_acquisition_parameters_r9.
                    utran_si_acquisition_for_ho_supported_r9 = RRC_TRUE;
            }
        }

    }
    /* CR 1007 changes start*/ 
    if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->m.nonCriticalExtensionPresent)
    {
        p_ue_eutra_capability->bitmask |= RRC_RRM_UE_EUTRA_CAPABILITY_V9c0_IES_PRESENT;
        
        if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->nonCriticalExtension.m.
                interRAT_ParametersUTRA_v9c0Present)
        {
            p_ue_eutra_capability->ue_eutra_capability_v9c0_ies.bitmask |= 
                RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMS_UTRA_v9c0_PRESENT;
            
            if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->nonCriticalExtension.
                    interRAT_ParametersUTRA_v9c0.m.voiceOverPS_HS_UTRA_FDD_r9Present)
            {
                p_ue_eutra_capability->ue_eutra_capability_v9c0_ies.inter_rat_parameters_utra_v9c0.
                    bitmask |= VOICEOVERPS_HS_UTRA_FDD_R9_PRESENT;

                p_ue_eutra_capability->ue_eutra_capability_v9c0_ies.inter_rat_parameters_utra_v9c0.
                    voice_over_ps_hs_utra_fdd_r9 =
                    (voice_over_ps_hs_utra_fdd_r9_et)p_UE_EUTRA_Capability_v9a0->nonCriticalExtension.
                    interRAT_ParametersUTRA_v9c0.voiceOverPS_HS_UTRA_FDD_r9;

            }

            if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->nonCriticalExtension.
                    interRAT_ParametersUTRA_v9c0.m.voiceOverPS_HS_UTRA_TDD128_r9Present)
            {
                p_ue_eutra_capability->ue_eutra_capability_v9c0_ies.inter_rat_parameters_utra_v9c0.
                    bitmask |= VOICEOVERPS_HS_UTRA_TDD_R9_PRESENT;

                p_ue_eutra_capability->ue_eutra_capability_v9c0_ies.inter_rat_parameters_utra_v9c0.
                    voice_over_ps_hs_utra_tdd128_r9 =
                    (voice_over_ps_hs_utra_tdd128_r9_et)p_UE_EUTRA_Capability_v9a0->nonCriticalExtension.
                    interRAT_ParametersUTRA_v9c0.voiceOverPS_HS_UTRA_TDD128_r9;
            }

            if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->nonCriticalExtension.
                    interRAT_ParametersUTRA_v9c0.m.srvcc_FromUTRA_FDD_ToUTRA_FDD_r9Present)
            {
                p_ue_eutra_capability->ue_eutra_capability_v9c0_ies.inter_rat_parameters_utra_v9c0.
                    bitmask |= SRVCC_FROM_UTRA_FDD_TO_UTRA_FDD_r9_PRESENT;

                p_ue_eutra_capability->ue_eutra_capability_v9c0_ies.inter_rat_parameters_utra_v9c0.
                    srvcc_from_utra_fdd_to_utra_fdd_r9 =
                    (srvcc_from_utra_fdd_to_utra_fdd_r9_et)p_UE_EUTRA_Capability_v9a0->nonCriticalExtension.
                    interRAT_ParametersUTRA_v9c0.srvcc_FromUTRA_FDD_ToUTRA_FDD_r9;
            }

            if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->nonCriticalExtension.
                    interRAT_ParametersUTRA_v9c0.m.srvcc_FromUTRA_FDD_ToGERAN_r9Present)
            {
                p_ue_eutra_capability->ue_eutra_capability_v9c0_ies.inter_rat_parameters_utra_v9c0.
                    bitmask |= SRVCC_FROM_UTRA_FDD_TO_GERAN_R9_PRESENT;

                p_ue_eutra_capability->ue_eutra_capability_v9c0_ies.inter_rat_parameters_utra_v9c0.
                    srvcc_from_utra_fdd_to_geran_r9 =
                    (srvcc_from_utra_fdd_to_geran_r9_et)p_UE_EUTRA_Capability_v9a0->nonCriticalExtension.
                    interRAT_ParametersUTRA_v9c0.srvcc_FromUTRA_FDD_ToGERAN_r9;
            }

            if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->nonCriticalExtension.
                    interRAT_ParametersUTRA_v9c0.m.srvcc_FromUTRA_TDD128_ToUTRA_TDD128_r9Present)
            {
                p_ue_eutra_capability->ue_eutra_capability_v9c0_ies.inter_rat_parameters_utra_v9c0.
                    bitmask |= SRVCC_FROM_UTRA_TDD128_TO_UTRA_TDD128_R9_PRESENT;

                p_ue_eutra_capability->ue_eutra_capability_v9c0_ies.inter_rat_parameters_utra_v9c0.
                    srvcc_from_utra_tdd128_to_utra_tdd128_r9 =
                    (srvcc_from_utra_tdd128_to_utra_tdd128_r9_et)p_UE_EUTRA_Capability_v9a0->nonCriticalExtension.
                    interRAT_ParametersUTRA_v9c0.srvcc_FromUTRA_TDD128_ToUTRA_TDD128_r9;
            }

            if (RRC_TRUE == p_UE_EUTRA_Capability_v9a0->nonCriticalExtension.
                    interRAT_ParametersUTRA_v9c0.m.srvcc_FromUTRA_TDD128_ToGERAN_r9Present)
            {
                p_ue_eutra_capability->ue_eutra_capability_v9c0_ies.inter_rat_parameters_utra_v9c0.
                    bitmask |= SRVCC_FROM_UTRA_TDD128_TO_GERAN_R9_PRESENT;

                p_ue_eutra_capability->ue_eutra_capability_v9c0_ies.inter_rat_parameters_utra_v9c0.
                    srvcc_from_utra_tdd128_to_geran_r9 =
                    (srvcc_from_utra_tdd128_to_geran_r9_et)p_UE_EUTRA_Capability_v9a0->nonCriticalExtension.
                    interRAT_ParametersUTRA_v9c0.srvcc_FromUTRA_TDD128_ToGERAN_r9;
            }
        }
    }
    /* CR 1007 changes stop */

    result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}
/*CR 895 changes stop*/

/* CR 919 changes start*/
/***************************************************************************************
*   FUNCTION NAME : fill_ue_eutra_capability_v1060_ies 
*
*   INPUT         : UE_EUTRA_Capability_v1060_IEs *p_asn_UE_EUTRA_Capability_v1060_IEs,
*                   ue_eutra_capability_v1060_ies_t *p_ue_eutra_capability_v1060_ies
*
*   OUTPUT        : None
*
*   DESCRIPTION   : This function builds EUTRA CAPABILITY v1060 IEs.
*
*   RETURNS       : None
****************************************************************************************/
void fill_ue_eutra_capability_v1060_ies( 
    UE_EUTRA_Capability_v1060_IEs   *p_asn_UE_EUTRA_Capability_v1060_IEs,
    ue_eutra_capability_v1060_ies_t *p_ue_eutra_capability_v1060_ies
    )
{
    /* SPR_17315_Fix2_Start */
    p_ue_eutra_capability_v1060_ies->bitmask = RRC_NULL; 
    /* SPR_17315_Fix2_End */

    
    if (p_asn_UE_EUTRA_Capability_v1060_IEs->m.
            fdd_Add_UE_EUTRA_Capabilities_v1060Present)
    {
        p_ue_eutra_capability_v1060_ies->bitmask |= 
            RRC_RRM_FDD_ADD_UE_EUTRA_CAPABILITIES_v1060_PRESENT;
    /* SPR_17315_Fix2_Start */
        p_ue_eutra_capability_v1060_ies->fdd_add_ue_eutra_capability_v1060.bitmask = RRC_NULL;
    /* SPR_17315_Fix2_End */

        if(p_asn_UE_EUTRA_Capability_v1060_IEs->fdd_Add_UE_EUTRA_Capabilities_v1060.m.
                phyLayerParameters_v1060Present)
        {
            p_ue_eutra_capability_v1060_ies->fdd_add_ue_eutra_capability_v1060.
                bitmask |= RRC_RRM_UE_EUTRA_CAPABILITIES_v1060_PHY_LAYER_PARAMETERS_PRESENT;

            fill_phylayer_params_v1060(&p_asn_UE_EUTRA_Capability_v1060_IEs->
                    fdd_Add_UE_EUTRA_Capabilities_v1060.phyLayerParameters_v1060, 
                    &p_ue_eutra_capability_v1060_ies->fdd_add_ue_eutra_capability_v1060.
                    phylayer_parameter_v1060);
        }

        if(p_asn_UE_EUTRA_Capability_v1060_IEs->fdd_Add_UE_EUTRA_Capabilities_v1060.m.
                featureGroupIndRel10_v1060Present)
        {
            p_ue_eutra_capability_v1060_ies->fdd_add_ue_eutra_capability_v1060.
                bitmask |= RRC_RRM_UE_EUTRA_CAPABILITIES_v1060_FEATURE_GRP_IND_REL10_PRESENT;

            l3_memcpy_wrapper(&p_ue_eutra_capability_v1060_ies->
                    fdd_add_ue_eutra_capability_v1060.featuregroup_ind_r10_v1060,
                    &p_asn_UE_EUTRA_Capability_v1060_IEs->
                    fdd_Add_UE_EUTRA_Capabilities_v1060.featureGroupIndRel10_v1060.
                    data, p_asn_UE_EUTRA_Capability_v1060_IEs->
                    fdd_Add_UE_EUTRA_Capabilities_v1060.featureGroupIndRel10_v1060.
                    numbits);
        }

        if(p_asn_UE_EUTRA_Capability_v1060_IEs->fdd_Add_UE_EUTRA_Capabilities_v1060.m.
                interRAT_ParametersCDMA2000_v1060Present)
        {
            p_ue_eutra_capability_v1060_ies->fdd_add_ue_eutra_capability_v1060.
                bitmask |= RRC_RRM_UE_EUTRA_CAPABILITIES_v1060_IRAT_PARAMS_CDMA2000_PRESENT;

            p_ue_eutra_capability_v1060_ies->fdd_add_ue_eutra_capability_v1060.
                inter_rat_parameters_cdma2000_v1060.eCSFB_dual_1xrtt_r10 = 
                p_asn_UE_EUTRA_Capability_v1060_IEs->fdd_Add_UE_EUTRA_Capabilities_v1060.
                interRAT_ParametersCDMA2000_v1060.e_CSFB_dual_1XRTT_r10;
        }

        if(p_asn_UE_EUTRA_Capability_v1060_IEs->fdd_Add_UE_EUTRA_Capabilities_v1060.m.
                interRAT_ParametersUTRA_TDD_v1060Present)
        {
            p_ue_eutra_capability_v1060_ies->fdd_add_ue_eutra_capability_v1060.
                bitmask |= RRC_RRM_UE_EUTRA_CAPABILITIES_v1060_IRAT_PARAMS_UTRA_TDD_PRESENT;

            p_ue_eutra_capability_v1060_ies->fdd_add_ue_eutra_capability_v1060.
                inter_rat_parameters_utra_tdd_v1060.e_redirection_utra_tdd_r10 = 
                p_asn_UE_EUTRA_Capability_v1060_IEs->fdd_Add_UE_EUTRA_Capabilities_v1060.
                interRAT_ParametersUTRA_TDD_v1060.e_RedirectionUTRA_TDD_r10;
        }
    }

    if(p_asn_UE_EUTRA_Capability_v1060_IEs->m.
            tdd_Add_UE_EUTRA_Capabilities_v1060Present)
    {
        p_ue_eutra_capability_v1060_ies->bitmask |=
            RRC_RRM_TDD_ADD_UE_EUTRA_CAPABILITIES_v1060_PRESENT;
    /* SPR_17315_Fix2_Start */
        p_ue_eutra_capability_v1060_ies->tdd_add_ue_eutra_capability_v1060.
                bitmask = RRC_NULL;
    /* SPR_17315_Fix2_End */

        if(p_asn_UE_EUTRA_Capability_v1060_IEs->tdd_Add_UE_EUTRA_Capabilities_v1060.m.
                phyLayerParameters_v1060Present)
        {
            p_ue_eutra_capability_v1060_ies->tdd_add_ue_eutra_capability_v1060.
                bitmask |= RRC_RRM_UE_EUTRA_CAPABILITIES_v1060_PHY_LAYER_PARAMETERS_PRESENT;

            fill_phylayer_params_v1060(&p_asn_UE_EUTRA_Capability_v1060_IEs->
                    tdd_Add_UE_EUTRA_Capabilities_v1060.phyLayerParameters_v1060,
                    &p_ue_eutra_capability_v1060_ies->tdd_add_ue_eutra_capability_v1060.
                    phylayer_parameter_v1060);
        }

        if(p_asn_UE_EUTRA_Capability_v1060_IEs->tdd_Add_UE_EUTRA_Capabilities_v1060.m.
                featureGroupIndRel10_v1060Present)
        {
            p_ue_eutra_capability_v1060_ies->tdd_add_ue_eutra_capability_v1060.
                bitmask |= RRC_RRM_UE_EUTRA_CAPABILITIES_v1060_FEATURE_GRP_IND_REL10_PRESENT;

            l3_memcpy_wrapper(&p_ue_eutra_capability_v1060_ies->
                    tdd_add_ue_eutra_capability_v1060.featuregroup_ind_r10_v1060,
                    &p_asn_UE_EUTRA_Capability_v1060_IEs->
                    tdd_Add_UE_EUTRA_Capabilities_v1060.featureGroupIndRel10_v1060.
                    data, p_asn_UE_EUTRA_Capability_v1060_IEs->
                    tdd_Add_UE_EUTRA_Capabilities_v1060.featureGroupIndRel10_v1060.
                    numbits);
        }

        if(p_asn_UE_EUTRA_Capability_v1060_IEs->tdd_Add_UE_EUTRA_Capabilities_v1060.m.
                interRAT_ParametersCDMA2000_v1060Present)
        {
            p_ue_eutra_capability_v1060_ies->tdd_add_ue_eutra_capability_v1060.
                bitmask |= RRC_RRM_UE_EUTRA_CAPABILITIES_v1060_IRAT_PARAMS_CDMA2000_PRESENT;

            p_ue_eutra_capability_v1060_ies->tdd_add_ue_eutra_capability_v1060.
                inter_rat_parameters_cdma2000_v1060.eCSFB_dual_1xrtt_r10 = 
                p_asn_UE_EUTRA_Capability_v1060_IEs->tdd_Add_UE_EUTRA_Capabilities_v1060.
                interRAT_ParametersCDMA2000_v1060.e_CSFB_dual_1XRTT_r10;
        }

        if(p_asn_UE_EUTRA_Capability_v1060_IEs->tdd_Add_UE_EUTRA_Capabilities_v1060.m.
                interRAT_ParametersUTRA_TDD_v1060Present)
        {
            p_ue_eutra_capability_v1060_ies->tdd_add_ue_eutra_capability_v1060.
                bitmask |= RRC_RRM_UE_EUTRA_CAPABILITIES_v1060_IRAT_PARAMS_UTRA_TDD_PRESENT;

            p_ue_eutra_capability_v1060_ies->tdd_add_ue_eutra_capability_v1060.
                inter_rat_parameters_utra_tdd_v1060.e_redirection_utra_tdd_r10 = 
                p_asn_UE_EUTRA_Capability_v1060_IEs->tdd_Add_UE_EUTRA_Capabilities_v1060.
                interRAT_ParametersUTRA_TDD_v1060.e_RedirectionUTRA_TDD_r10;
        }
    }
}

/******************************************************************************
*   FUNCTION NAME : fill_phylayer_params_v1060 
*
*   INPUT         : PhyLayerParameters_v1020 *p_asn_PhyLayerParameters_v1060,
*                   phylayer_parameters_v1020_ies_t *p_phylayer_parameter_v1060
*
*   ONUTPUT       : None
*
*   DESCRIPTION   : This function builds EUTRA CAPABILITY PHY LAYER PARAMETERS v1060 .
*
*   RETURNS       : None
******************************************************************************/
void fill_phylayer_params_v1060(
    PhyLayerParameters_v1020   *p_asn_PhyLayerParameters_v1060, //*p_asn_UE_EUTRA_Capability_v1060_IEs,
    phylayer_parameters_v1020_ies_t *p_phylayer_parameter_v1060 //*p_ue_eutra_capability_v1060_ies
    )
{
    U32 count = RRC_NULL;
    OSRTDListNode*      p_node = PNULL;
    NonContiguousUL_RA_WithinCC_r10 *p_ul_ra_withincc = PNULL;
    /* SPR_17315_Fix2_Start */
    p_phylayer_parameter_v1060->bitmask = RRC_NULL;
    /* SPR_17315_Fix2_End */

    /* filling two antenna ports for pucch rel 10 */
    if( RRC_TRUE == p_asn_PhyLayerParameters_v1060->m.
            twoAntennaPortsForPUCCH_r10Present )
    {
        p_phylayer_parameter_v1060->bitmask |= 
                RRC_RRM_TWO_ANTENNA_PORTS_FOR_PUCCH_R10_PRESENT;

        p_phylayer_parameter_v1060->two_antenna_ports_for_pucch_r10 = 
            (two_antenna_ports_for_pucch_r10_et)p_asn_PhyLayerParameters_v1060->twoAntennaPortsForPUCCH_r10 ;
    }

    /* filling tm9_With_8Tx_FDD_r10 */
    if( RRC_TRUE == p_asn_PhyLayerParameters_v1060->m.tm9_With_8Tx_FDD_r10Present)
    {
        p_phylayer_parameter_v1060->bitmask |= RRC_RRM_TM9_WITH_8TX_FDD_R10_PRESENT;

        p_phylayer_parameter_v1060->tm9_with_8tx_fdd_r10 = 
            (tm9_with_8tx_fdd_r10_et)p_asn_PhyLayerParameters_v1060->tm9_With_8Tx_FDD_r10;
    }

    /* filling pmi_disabling_r10 */
    if( RRC_TRUE == p_asn_PhyLayerParameters_v1060->m.pmi_Disabling_r10Present )
    {
        p_phylayer_parameter_v1060->bitmask |= 
            RRC_RRM_PMI_DISABLING_R10_PRESENT ;
        
        p_phylayer_parameter_v1060->pmi_disabling_r10 = 
            (pmi_disabling_r10_et)p_asn_PhyLayerParameters_v1060->pmi_Disabling_r10;
    }

    /* filling cross_carrier_scheduling_r10 */
    if( RRC_TRUE == p_asn_PhyLayerParameters_v1060->m.crossCarrierScheduling_r10Present)
    {
        p_phylayer_parameter_v1060->bitmask |= RRC_RRM_CROSS_CARRIER_SCHEDULING_R10_PRESENT;

        p_phylayer_parameter_v1060->cross_carrier_scheduling_r10 = 
            (cross_carrier_scheduling_r10_et)p_asn_PhyLayerParameters_v1060->crossCarrierScheduling_r10;
    }

    /* filling simultaneous_pucch_pusch_r10 */
    if( RRC_TRUE == p_asn_PhyLayerParameters_v1060->m.simultaneousPUCCH_PUSCH_r10Present )
    {
        p_phylayer_parameter_v1060->bitmask |= RRC_RRM_SIMULTANEOUS_PUCCH_PUSCH_R10_PRESENT;

        p_phylayer_parameter_v1060->simultaneous_pucch_pusch_r10 = 
            (simultaneous_pucch_pusch_r10_et)p_asn_PhyLayerParameters_v1060->simultaneousPUCCH_PUSCH_r10;
    }

    /* filling multi_cluster_pusch_withincc_r10 */
    if( RRC_TRUE == p_asn_PhyLayerParameters_v1060->m.multiClusterPUSCH_WithinCC_r10Present )
    {
        p_phylayer_parameter_v1060->bitmask |= 
                RRC_RRM_MULTI_CLUSTER_PUSCH_WITHINCC_R10_PRESENT ;

        p_phylayer_parameter_v1060->multi_cluster_pusch_withincc_r10 = 
            (multi_cluster_pusch_withincc_r10_et)p_asn_PhyLayerParameters_v1060->multiClusterPUSCH_WithinCC_r10;
    }

    /* filling nonContiguousUL_RA_WithinCC_List_r10 */
    if( RRC_TRUE == p_asn_PhyLayerParameters_v1060->m.
            nonContiguousUL_RA_WithinCC_List_r10Present )
    {
        p_phylayer_parameter_v1060->bitmask |= 
                RRC_RRM_MULTI_NONCONTIGUOUSUL_RA_WITHINCC_LIST_R10_PRESENT ;

        p_node = p_asn_PhyLayerParameters_v1060->nonContiguousUL_RA_WithinCC_List_r10.
            head;

        p_phylayer_parameter_v1060->noncontiguousul_ra_withincc_list_r10.count = 
            (U8)p_asn_PhyLayerParameters_v1060->nonContiguousUL_RA_WithinCC_List_r10.count;

        for( count = 0; count < p_asn_PhyLayerParameters_v1060->
                nonContiguousUL_RA_WithinCC_List_r10.count ; count++ )
        {
            p_ul_ra_withincc = (NonContiguousUL_RA_WithinCC_r10 *)p_node->data ;
            
            if(RRC_TRUE == p_ul_ra_withincc->m.nonContiguousUL_RA_WithinCC_Info_r10Present )
            {
                p_phylayer_parameter_v1060->noncontiguousul_ra_withincc_list_r10.
                    noncontiguousul_ra_withincc_r10[count].bitmask = RRC_NULL ;

                p_phylayer_parameter_v1060->noncontiguousul_ra_withincc_list_r10.
                    noncontiguousul_ra_withincc_r10[count].bitmask |= 
                    RRC_RRM_NONCONTIGUOUSUL_RA_WITHINCC_INFO_R10;

                p_phylayer_parameter_v1060->noncontiguousul_ra_withincc_list_r10.
                    noncontiguousul_ra_withincc_r10[count].noncontiguousul_ra_withincc_info_r10 = 
                    (noncontiguousul_ra_withincc_info_r10_et)p_ul_ra_withincc->nonContiguousUL_RA_WithinCC_Info_r10 ;
            }
            p_node = p_node->next;
        }
    }
}
/* CR 919 changes stop*/

/******************************************************************************
*   FUNCTION NAME  :  copy_cell_id
*
*   INPUT          :  rrm_cell_global_id_eutra_t *p_dest,
*                     CellGlobalIdEUTRA *p_src
*   OUTPUT         :  None
*
*   DESCRIPTION:    This function is used to copy cell identity
*
*   RETURNS        :  None          
******************************************************************************/

void copy_cell_id(rrm_cell_global_id_eutra_t *p_dest,CellGlobalIdEUTRA *p_src)
{
    RRC_ASSERT(p_dest != PNULL);
    RRC_ASSERT(p_src != PNULL);
    if(p_src->plmn_Identity.m.mccPresent == 1)
    {
        p_dest->plmn_identity.presence_bitmask |=
            PLMN_IDENTITY_MCC_PRESENCE_FLAG;
        l3_memcpy_wrapper(p_dest->plmn_identity.mcc,
                p_src->plmn_Identity.mcc.elem,
                MCC_OCTET_SIZE);
    }

    l3_memcpy_wrapper(p_dest->plmn_identity.mnc.mnc,
            p_src->plmn_Identity.mnc.elem,
            p_src->plmn_Identity.mnc.n);
    p_dest->plmn_identity.mnc.count = 
        p_src->plmn_Identity.mnc.n;

    l3_memcpy_wrapper(&p_dest->cell_identity,
            &p_src->cellIdentity,
            sizeof(p_dest->cell_identity));

    return;
}
/*************************************************************************************************
*   FUNCTION NAME :  uecc_rrm_build_and_send_inter_freq_meas_ind
*
*   INPUT         :  uecc_ue_context_t *p_uecc_ue_context,
*                    InterFreqRSTDMeasurementIndication_r10_IEs_rstd_InterFreqIndication_r10
*                    *p_rstd_inter_freq_ind
*
*   OUTPUT        :  None
*
*   DESCRIPTION   :  This is the function for building and sending
*                    RRC_RRM_INTER_FREQ_MEASUREMENT_IND message to the RRM.
*
*   RETURNS       :  RRC_SUCCESS/RRC_FAILURE
**************************************************************************************************/


rrc_return_et uecc_rrm_build_and_send_inter_freq_meas_ind(
        uecc_ue_context_t   *p_uecc_ue_context,      /* UECC UE context */
        InterFreqRSTDMeasurementIndication_r10_IEs_rstd_InterFreqIndication_r10 *p_rstd_inter_freq_ind
)
{
    InterFreqRSTDMeasurementIndication_r10_IEs_rstd_InterFreqIndication_r10_start *p_interFreqRstdMeasInd_start_r10 = PNULL;
    rrc_rrm_inter_freq_rstd_measurement_ind_t   rrc_rrm_inter_freq_rstd_meas_ind;
    rrc_return_et        result = RRC_FAILURE;
    OSRTDListNode        *p_node = PNULL;
    U8 i = 0;
    RSTD_InterFreqInfo_r10 *p_rstd_inter_freq_info = PNULL;



    RRC_ASSERT(PNULL != p_uecc_ue_context);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    RRC_ASSERT(PNULL != p_rstd_inter_freq_ind);

    /*reset */
    memset_wrapper(&rrc_rrm_inter_freq_rstd_meas_ind, RRC_NULL,
            sizeof(rrc_rrm_inter_freq_rstd_measurement_ind_t));
    rrc_rrm_inter_freq_rstd_meas_ind.ue_index = 
        p_uecc_ue_context->ue_index;
    if(p_rstd_inter_freq_ind->t == T_InterFreqRSTDMeasurementIndication_r10_IEs_rstd_InterFreqIndication_r10_start)
    {
        p_interFreqRstdMeasInd_start_r10 = p_rstd_inter_freq_ind->u.start;
        RRC_ASSERT(PNULL != p_interFreqRstdMeasInd_start_r10);

        rrc_rrm_inter_freq_rstd_meas_ind.bitmask |=
            RRM_INTER_FREQ_RSTD_START;
        rrc_rrm_inter_freq_rstd_meas_ind.bitmask |= 
            RRM_INTER_FREQ_RSTD_INFO_LIST_PRESENT;

        /* ue_index */

        rrc_rrm_inter_freq_rstd_meas_ind.rstd_inter_freq_info_list.num_rstd_intfreq_list  =  p_interFreqRstdMeasInd_start_r10->rstd_InterFreqInfoList_r10.count;

        p_node = p_interFreqRstdMeasInd_start_r10->rstd_InterFreqInfoList_r10.head;

        for(i = 0; i< rrc_rrm_inter_freq_rstd_meas_ind.rstd_inter_freq_info_list.num_rstd_intfreq_list ; i++)
        {
            RRC_ASSERT(PNULL != p_node);
            RRC_ASSERT(PNULL != p_node->data);

            p_rstd_inter_freq_info = (RSTD_InterFreqInfo_r10 *)p_node->data;

            rrc_rrm_inter_freq_rstd_meas_ind.rstd_inter_freq_info_list.rstd_interfreq_list[i].carrier_freq = p_rstd_inter_freq_info->carrierFreq_r10;
            rrc_rrm_inter_freq_rstd_meas_ind.rstd_inter_freq_info_list.rstd_interfreq_list[i].meas_prs_offset = p_rstd_inter_freq_info->measPRS_Offset_r10;

            p_node = p_node->next;
        }
    }
    else if(p_rstd_inter_freq_ind->t == T_InterFreqRSTDMeasurementIndication_r10_IEs_rstd_InterFreqIndication_r10_stop)
    {
        rrc_rrm_inter_freq_rstd_meas_ind.bitmask |=
            RRM_INTER_FREQ_RSTD_STOP;
    }
    else
    {
        RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,
                p_uecc_ue_context->p_gb_context->facility_name,
                RRC_ERROR,
                "INVALID OPTION SET");
        return RRC_FAILURE;
    }

    /* Encode and send message */
    result = rrc_rrm_il_send_rrc_rrm_inter_freq_rstd_measurement_ind(
            &rrc_rrm_inter_freq_rstd_meas_ind,
            RRC_UECC_MODULE_ID,
            RRC_RRM_MODULE_ID,
            uecc_ue_ctx_get_op_transction_id(p_uecc_ue_context),
            p_uecc_ue_context->cell_index);


    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

    return result;
}

/* lipa start */

/******************************************************************************
*   FUNCTION NAME   :  uecc_rrm_build_and_send_rrc_rrm_local_error_ind
*
*   INPUT           :  uecc_gb_context_t *p_uecc_gb_context,
*                      U8 cause,
*                      void *p_api
*
*   OUTPUT          :  None
*                      
*   DESCRIPTION     :  This is the function for building and sending
*                      RRC_RRM_LOCAL_ERROR_IND message to the RRM
*                      whenever RRC_OAM_DELETE_LGW_REQ or 
*                      RRC_S1U_PATH_FAILURE_IND is recieved.
*
*   RETURNS         :  RRC_SUCCESS/RRC_FAILURE
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_rrc_rrm_local_error_ind(
       uecc_gb_context_t  *p_uecc_gb_context,      /* UECC Global context */
       U8                  cause,
      /* cause to be filled in rrc_rrm_local_error_ind */
       void               *p_api
)
{
    U16    index         = 0;
    U8    erab_counter  = 0;
    U16   count         = 0;
    uecc_ue_context_t *p_ue_context = PNULL ;
    rrc_return_et        result = RRC_FAILURE;
    rrc_bool_t matching_erab_found = RRC_FALSE;
    rrc_uecc_llim_s1u_path_failure_ind_t  *p_s1u_path_failure = PNULL;
/*SPR 21653 changes start*/
    U8  max_cells = MAX_NUM_CELLS ;
    rrc_rrm_local_error_ind_t *p_rrc_rrm_local_error_ind[8];
/*SPR 21653 changes end*/
    rrc_impacted_items_t *p_rrc_impacted_items = PNULL;

    U8              ip_address_octet_size = 0 ; 
    U8              ip_address[RRC_MAX_IP_ADDR_LEN_IPV6] = {0};

    U8              primary_tunnel_len = 0 ; 
    U8              sec_tunnel_len = 0 ; 
    U8              primary_tunnel_ip[RRC_MAX_IP_ADDR_LEN_IPV6] = {0};
    U8              sec_tunnel_ip[RRC_MAX_IP_ADDR_LEN_IPV6] = {0};
    
    RRC_ASSERT( PNULL != p_uecc_gb_context );
    RRC_ASSERT( PNULL != p_api );

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    if(0 == cause || cause >  OAM_INITIATED_LGW_DEL)
    {
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_ERROR,
                "INVALID CAUSE");
         return RRC_FAILURE;
    } 
    for (index = 0 ; index < max_cells ; index++)
    {
         p_rrc_rrm_local_error_ind[index] = (rrc_rrm_local_error_ind_t *)
                             rrc_mem_get(sizeof(rrc_rrm_local_error_ind_t));

         /* SES-508 Fix Start */
         /* Code Removed */
         /* SES-508 Fix End */

	     p_rrc_rrm_local_error_ind[index]->cause = cause ;
    }

    if (cause == GTP_PATH_FAIL)
    {
        p_s1u_path_failure =
            (rrc_uecc_llim_s1u_path_failure_ind_t*)((U8*)p_api + RRC_API_HEADER_SIZE);

        ip_address_octet_size = p_s1u_path_failure->ip_address_octet_size;
        l3_memcpy_wrapper((void *)&(ip_address),
                (void *)&(p_s1u_path_failure->ip_address),
                ip_address_octet_size);    
    }


    /*Traverse all UEs and all active E-RABs to check whether they're impacted or not*/
	for (index = 0;
         index < p_uecc_gb_context->total_ue_supported;
		 index++)
    {
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
                index);

        if (PNULL == p_ue_context)
        {
            continue;
        }
        for ( erab_counter = 0 ; 
              erab_counter < MAX_ERAB_COUNT;
              erab_counter++ )
        {
            if( PNULL == p_ue_context->p_e_rab_list[erab_counter])
            {
                continue;
            }

            /* Resetting the flag */
            matching_erab_found = RRC_FALSE;

            /*Send Local Error Indication in case of LGW got deleted*/
            if (cause == OAM_INITIATED_LGW_DEL)  
            {
                if ( ( RRC_TRUE == p_ue_context->p_e_rab_list[erab_counter]->
                            m.Lipa_RabPresent )
                               &&
                     ( PNULL != p_ue_context->p_e_rab_list[erab_counter]->
                          correlation_id))
                {
                    matching_erab_found = RRC_TRUE;
                }
            }

            /*Send Local Error Indication in case of Path Failure*/
            else if(cause == GTP_PATH_FAIL)
            {
                if ( ( RRC_TRUE == p_ue_context->p_e_rab_list[erab_counter]->
                             m.Lipa_RabPresent )
                               &&
                     ( PNULL != p_ue_context->p_e_rab_list[erab_counter]->
                          correlation_id))
                {
                    primary_tunnel_len = p_uecc_gb_context->lgw_data_length;

                    l3_memcpy_wrapper((void *)primary_tunnel_ip, p_uecc_gb_context->lgw_ip_addr,
                               primary_tunnel_len);

                    if (0 == p_ue_context->p_e_rab_list[erab_counter]->transportLayerAddress.numbits % 8)
                    {
                       sec_tunnel_len = 
                      (p_ue_context->p_e_rab_list[erab_counter]->transportLayerAddress.numbits)/8 ;
                    }
                    else 
                    {
                      sec_tunnel_len =
                      ((p_ue_context->p_e_rab_list[erab_counter]->transportLayerAddress.numbits)/8) + 1 ;
                    }
                    l3_memcpy_wrapper((void *)sec_tunnel_ip,p_ue_context->p_e_rab_list[erab_counter]->transportLayerAddress.data,
                                sec_tunnel_len);

                    /*klockwork fix*/
                    if ((ip_address_octet_size <= RRC_MAX_IP_ADDR_LEN_IPV6)
                                  &&
                        ((U32)ip_address_octet_size == sec_tunnel_len)
                                   &&
                        (0 == 
                           memcmp_wrapper(sec_tunnel_ip, ip_address, ip_address_octet_size)))
                    {
                           matching_erab_found = RRC_TRUE; 
                    }

                }
                else 
                { 
                       
                    if (0 == p_ue_context->p_e_rab_list[erab_counter]->transportLayerAddress.numbits % 8)
                    {
                         primary_tunnel_len = 
                           (p_ue_context->p_e_rab_list[erab_counter]->transportLayerAddress.numbits)/8 ;
                    }
                    else 
                    {
                         primary_tunnel_len = 
                        ((p_ue_context->p_e_rab_list[erab_counter]->transportLayerAddress.numbits)/8) + 1 ;
                        
                   }
                    l3_memcpy_wrapper((void *)primary_tunnel_ip,p_ue_context->p_e_rab_list[erab_counter]->transportLayerAddress.data,
                                primary_tunnel_len);
                }

                    /*klockwork fix*/
                if ((ip_address_octet_size <= RRC_MAX_IP_ADDR_LEN_IPV6)
                                           &&
                    ((U32)ip_address_octet_size == primary_tunnel_len ) 
                                          &&
                    (0 == 
                     memcmp_wrapper(primary_tunnel_ip, ip_address, ip_address_octet_size)))

                { 
                    matching_erab_found = RRC_TRUE;
                }
            }
            if (RRC_TRUE == matching_erab_found)
            {
                
                p_rrc_impacted_items = &p_rrc_rrm_local_error_ind[p_ue_context->cell_index]->impacted_items;
     
                count = p_rrc_impacted_items->impacted_items_count;
          
		if(count < MAX_LOCAL_ERROR_IMPACTED_ITEMS)
		{
			p_rrc_impacted_items->impacted_items_list[count].bitmask |= 
				RRM_LOCAL_ERROR_IND_ERAB_ID_PRESENT; 

			p_rrc_impacted_items->impacted_items_list[count].ue_index = 
				p_ue_context->ue_index;
			p_rrc_impacted_items->impacted_items_list[count].erab_id = 
				erab_counter;
			p_rrc_impacted_items->impacted_items_count++;
		}

                /*If impacted item list count reaches its max value, then send the msg to RRM
                  and proceed with the remaining impacted items to send subsequent messages*/
                if ( p_rrc_impacted_items->impacted_items_count == MAX_LOCAL_ERROR_IMPACTED_ITEMS )
                {
                     p_rrc_rrm_local_error_ind[p_ue_context->cell_index]->bitmask |= 
                        RRM_LOCAL_ERROR_IND_IMPACTED_ITEM_LIST_PRESENT;

                    result = rrc_rrm_il_send_rrc_rrm_local_error_ind(
                            p_rrc_rrm_local_error_ind[p_ue_context->cell_index],
                            RRC_UECC_MODULE_ID,
                            RRC_RRM_MODULE_ID,
                            RRC_TRANSACTION_ID_ABSENT,
                            p_ue_context->cell_index); /*As the message is generic for any UE Ctx, 
                                                        so no UE-specific trans id is needed*/

                    if (RRC_SUCCESS == result)
                    {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_INFO,
                            "LOCAL ERROR INDICATION SENT successfully to RRM");
                    }
                    else
                     {
                        RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                            p_uecc_gb_context->facility_name,
                            RRC_ERROR,
                            "Sending LOCAL ERROR INDICATION to RRM failed");
                    }  
                    /* build more local error indications*/  
                    memset_wrapper( p_rrc_rrm_local_error_ind[p_ue_context->cell_index],
                            RRC_NULL, sizeof (rrc_rrm_local_error_ind_t)); 

                    p_rrc_rrm_local_error_ind[p_ue_context->cell_index]->cause = cause ; 
                    
                    /*Reset the count value */
                    p_rrc_rrm_local_error_ind[p_ue_context->cell_index]->impacted_items.impacted_items_count = 0;
                } 
            }
        } /*end of erab index for loop*/
    } /*end of ue index for loop*/
 
    for(count = 0 ; count < max_cells ; count++)
    {
        if ( p_rrc_rrm_local_error_ind[count]->impacted_items.impacted_items_count > 0 )
        {
            p_rrc_rrm_local_error_ind[count]->bitmask |= 
                RRM_LOCAL_ERROR_IND_IMPACTED_ITEM_LIST_PRESENT;

            /* Encode and send message */
            result = rrc_rrm_il_send_rrc_rrm_local_error_ind(
                    p_rrc_rrm_local_error_ind[count],
                    RRC_UECC_MODULE_ID,
                    RRC_RRM_MODULE_ID,
                    RRC_TRANSACTION_ID_ABSENT,
                    count); /*As the message is generic for any UE Ctx, 
                                                  so no UE-specific trans id is needed*/
            /* Coverity_Fix 97186 ++ */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_INFO,"API:RRC->RRM:RRC_RRM_LOCAL_ERROR_IND: with cause:%u",
                    p_rrc_rrm_local_error_ind[count]->cause);
            /* Coverity_Fix 97186 -- */
        }
    }
    for (index = 0 ; index < max_cells ; index++)
    {
        rrc_mem_free(p_rrc_rrm_local_error_ind[index]);
        p_rrc_rrm_local_error_ind[index] = PNULL;
    }
   
    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}

/******************************************************************************
*   FUNCTION NAME : uecc_rrm_build_and_send_rrc_rrm_local_error_ind_for_s1u_error
*
*   INPUT         : uecc_ue_context_t *p_ue_context,
*                   rrc_uecc_llim_s1u_error_ind_t *p_data 
*
*   OUTOUT        : None
*
*   DESCRIPTION   : This is the function for building and sending
*                   RRC_RRM_LOCAL_ERROR_IND message to the RRM
*                   whenever RRC_S1U_ERROR_IND is received.
*
*   RETURNS       : RRC_SUCCESS/RRC_FAILURE
******************************************************************************/
rrc_return_et uecc_rrm_build_and_send_rrc_rrm_local_error_ind_for_s1u_error(
  uecc_ue_context_t      *p_ue_context,   /* UECC Global context */
  rrc_uecc_llim_s1u_error_ind_t *p_data  /* cause to be filled in rrc_rrm_local_error_ind */
)
{
    rrc_return_et        result = RRC_FAILURE;
    rrc_rrm_local_error_ind_t rrc_rrm_local_error_ind ;
    U8 count = 0; 
    U8 erab_counter = 0 ;
    rrc_impacted_items_t *p_rrc_impacted_items = PNULL;

    RRC_ASSERT( PNULL != p_ue_context );
    RRC_ASSERT( PNULL != p_data );

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper( &rrc_rrm_local_error_ind,
            RRC_NULL, sizeof(rrc_rrm_local_error_ind_t)); 


    rrc_rrm_local_error_ind.cause = GTP_ERROR_IND ; 

    p_rrc_impacted_items =
        &rrc_rrm_local_error_ind.impacted_items;

    for ( erab_counter = 0; 
            erab_counter < MAX_ERAB_COUNT;
            erab_counter++ )
    {
        if( PNULL == p_ue_context->p_e_rab_list[erab_counter])
        {
            continue;
        }
        /* Comparing the lc_id received in error ind with the 
           lc_id of the erabs established for the UE */
        if ( p_data->lc_id == 
                p_ue_context->p_e_rab_list[erab_counter]->drb_config.logical_channel_identity)
        {
            p_rrc_impacted_items->impacted_items_list[count].bitmask |=
                RRM_LOCAL_ERROR_IND_ERAB_ID_PRESENT; 

            p_rrc_impacted_items->impacted_items_list[count].ue_index = 
                p_data->ue_index;
            p_rrc_impacted_items->impacted_items_list[count].erab_id = 
                erab_counter;
            p_rrc_impacted_items->impacted_items_count = 1;

            rrc_rrm_local_error_ind.bitmask |= 
                RRM_LOCAL_ERROR_IND_IMPACTED_ITEM_LIST_PRESENT;

            if(RRC_FAILURE == rrc_rrm_il_send_rrc_rrm_local_error_ind(
                        &rrc_rrm_local_error_ind,
                        RRC_UECC_MODULE_ID,
                        RRC_RRM_MODULE_ID,
                        RRC_TRANSACTION_ID_ABSENT,
                        p_ue_context->cell_index))
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                        p_ue_context->p_gb_context->facility_name,
                        RRC_WARNING,
                        "Sending RRC_RRM_LOCAL_ERROR_IND failed to RRM");
                result = RRC_FAILURE;
                break;
            }
            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                    p_ue_context->p_gb_context->facility_name,
                    RRC_INFO,
                    "RRC_RRM_LOCAL_ERROR_IND sent successfully to RRM");

            result = RRC_SUCCESS;
        }
    }
    
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}
/* lipa end */

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_scell_config_info
*
*   INPUT        : uecc_ue_context_t   *p_uecc_ue_context,
*                  as_config_ext_t     *p_rrm_as_config_ext,
*                  SCellToAddModList_r10   *p_sourceSCellConfigList_r10*                 
*
*   OUTPUT       : None
*
*   DESCRIPTION  : This function builds as_config_ext_t  
*
*   RETURNS      : RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_scell_config_info (
        uecc_ue_context_t   *p_ue_context,
        as_config_ext_t     *p_rrm_as_config_ext,
        SCellToAddModList_r10    *p_sourceSCellConfigList_r10 
        )
{
    OSRTDListNode* p_node = PNULL;
    U8  index = RRC_NULL;
    rrc_scell_to_add_mod_t  *p_rrc_scell_to_add_mod = PNULL;
    
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_rrm_as_config_ext);
    RRC_ASSERT(PNULL != p_sourceSCellConfigList_r10);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
   
    p_node = p_sourceSCellConfigList_r10->head;
        
    p_rrm_as_config_ext->scell_add_mod_list.count = 
        p_sourceSCellConfigList_r10->count;

    for (index = RRC_NULL; index < p_sourceSCellConfigList_r10->count;
            index++)
    {
        if (!((PNULL != p_node) && (PNULL != p_node->data)))
        {
           return RRC_FAILURE; 
        }

        p_rrc_scell_to_add_mod = &p_rrm_as_config_ext->scell_add_mod_list.
            rrc_scell_to_add_mod[index];

        p_rrc_scell_to_add_mod->scellIndex = ((SCellToAddMod_r10 *)p_node->data)->
            sCellIndex_r10;

        if (((SCellToAddMod_r10 *)p_node->data)->m.cellIdentification_r10Present)
        {
            p_rrc_scell_to_add_mod->bitmask |= 
                RRM_SCELL_ADD_MOD_CELL_IDENTIFICATION_PRESENT;

            p_rrc_scell_to_add_mod->scell_Id.phy_cell_id = 
                ((SCellToAddMod_r10 *)p_node->data)->cellIdentification_r10.
                physCellId_r10;
            p_rrc_scell_to_add_mod->scell_Id.dl_carrier_freq = 
                ((SCellToAddMod_r10 *)p_node->data)->cellIdentification_r10.
                dl_CarrierFreq_r10;
        }

        if (((SCellToAddMod_r10 *)p_node->data)->m.
                radioResourceConfigCommonSCell_r10Present)
        {
            p_rrc_scell_to_add_mod->bitmask |=
                RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_COMMON_SCELL_PRESENT;

            uecc_rrm_build_radio_res_config_common_scell (
                        p_ue_context,
                        &p_rrc_scell_to_add_mod->radio_res_config_common_scell,
                        &(((SCellToAddMod_r10 *)p_node->data)->
                            radioResourceConfigCommonSCell_r10) );
        }

        if (((SCellToAddMod_r10 *)p_node->data)->m.
                radioResourceConfigDedicatedSCell_r10Present)
        {
            p_rrc_scell_to_add_mod->bitmask |=
                RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_DEDICATED_SCELL_PRESENT;


            uecc_rrm_build_radio_res_config_dedicted_scell (
                        p_ue_context,
                        &p_rrc_scell_to_add_mod->radio_res_config_dedicated_scell,
                        &(((SCellToAddMod_r10 *)p_node->data)->
                            radioResourceConfigDedicatedSCell_r10));
        }
        p_node = p_node->next;
    }
    
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}


/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_radio_res_config_common_scell
*
*   INPUT        : uecc_ue_context_t   *p_ue_context,
*                  rrc_radio_res_config_common_scell_t  *p_config_common_scell
*                  RadioResourceConfigCommonSCell_r10
*                                      *p_radioResourceConfigCommonSCell_r10
*   OUTPUT       : none
*
*   DESCRIPTION  : This function builds rrc_radio_res_config_common_scell_t
*
*   RETURNS      : None
*
******************************************************************************/
void uecc_rrm_build_radio_res_config_common_scell (
        uecc_ue_context_t   *p_ue_context,
        rrc_radio_res_config_common_scell_t  *p_config_common_scell,
        RadioResourceConfigCommonSCell_r10   *p_radioResourceConfigCommonSCell_r10
        )
{
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_config_common_scell);
    RRC_ASSERT(PNULL != p_radioResourceConfigCommonSCell_r10);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,p_ue_context->p_gb_context->facility_name,
                          RRC_DETAILEDALL,"Unused variable"
                          "p_ue_context=%p",p_ue_context);/*SPR 17777 +-*/
    p_config_common_scell->radio_res_common_scell_non_ul_config.dl_bandwidth = 
       (U8)p_radioResourceConfigCommonSCell_r10->nonUL_Configuration_r10.
       dl_Bandwidth_r10;

    p_config_common_scell->radio_res_common_scell_non_ul_config.antenna_port_count = 
       (U8)p_radioResourceConfigCommonSCell_r10->nonUL_Configuration_r10.
       antennaInfoCommon_r10.antennaPortsCount;

    p_config_common_scell->radio_res_common_scell_non_ul_config.phich_config.
        phich_resource = (U8)p_radioResourceConfigCommonSCell_r10->nonUL_Configuration_r10.
        phich_Config_r10.phich_Resource;

    p_config_common_scell->radio_res_common_scell_non_ul_config.phich_config.
        phich_duration = (U8)p_radioResourceConfigCommonSCell_r10->nonUL_Configuration_r10.
        phich_Config_r10.phich_Duration;

    p_config_common_scell->radio_res_common_scell_non_ul_config.pdsch_config_common.
        ref_signal_power = p_radioResourceConfigCommonSCell_r10->nonUL_Configuration_r10.
        pdsch_ConfigCommon_r10.referenceSignalPower;

    p_config_common_scell->radio_res_common_scell_non_ul_config.pdsch_config_common.
        pb = p_radioResourceConfigCommonSCell_r10->nonUL_Configuration_r10.
        pdsch_ConfigCommon_r10.p_b;

    if (p_radioResourceConfigCommonSCell_r10->nonUL_Configuration_r10.m.
            tdd_Config_r10Present)
    {
        p_config_common_scell->radio_res_common_scell_non_ul_config.bitmask |=
            RRM_SCELL_COMMOM_NON_UL_TDD_CONFIG_PRESENT;

        p_config_common_scell->radio_res_common_scell_non_ul_config.tdd_config.
            sub_frame_assignment = (U8)p_radioResourceConfigCommonSCell_r10->
            nonUL_Configuration_r10.tdd_Config_r10.subframeAssignment;

        p_config_common_scell->radio_res_common_scell_non_ul_config.tdd_config.
            special_sub_frame_pattern = (U8)p_radioResourceConfigCommonSCell_r10->
            nonUL_Configuration_r10.tdd_Config_r10.specialSubframePatterns;
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_radio_res_config_dedicted_scell
*
*   INPUT        : uecc_ue_context_t                       *p_ue_context,
*                  rrc_radio_res_config_dedicated_scell_t  *p_config_dedicated_scell
*                  RadioResourceConfigDedicatedSCell_r10
*                                      *p_radio_Res_Config_Dedicated_SCell
*   OUTPUT       : none
*
*   DESCRIPTION  : This function builds rrc_radio_res_config_dedicated_scell_t
*
*   RETURNS      : None
*
******************************************************************************/
void uecc_rrm_build_radio_res_config_dedicted_scell (
        uecc_ue_context_t   *p_ue_context,
        rrc_radio_res_config_dedicated_scell_t  *p_config_dedicated_scell,/*dest*/
        RadioResourceConfigDedicatedSCell_r10   *p_radio_Res_Config_Dedicated_SCell/*src*/
        )
{
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_config_dedicated_scell);
    RRC_ASSERT(PNULL != p_radio_Res_Config_Dedicated_SCell);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if (p_radio_Res_Config_Dedicated_SCell->m.
            physicalConfigDedicatedSCell_r10Present)
    {
        p_config_dedicated_scell->bitmask |= 
            RRM_PHYSICAL_CONFIG_DEDICATED_SCELL_CONFIG_PRESENT;

        if ( p_radio_Res_Config_Dedicated_SCell->physicalConfigDedicatedSCell_r10.
                m.nonUL_Configuration_r10Present )
        {
            p_config_dedicated_scell->physical_config_dedicated_scell.
                bitmask |= RRM_RADIO_RES_CONFIG_DEDICATED_SCELL_NON_UL_CONFIG_PRESENT;

            uecc_rrm_build_phy_config_dedicated_non_ul_config(
                    p_ue_context,
                    &p_config_dedicated_scell->physical_config_dedicated_scell.
                    radio_res_dedicated_scell_non_ul_config,
                    &p_radio_Res_Config_Dedicated_SCell->physicalConfigDedicatedSCell_r10.
                    nonUL_Configuration_r10); 
        }

        if (p_radio_Res_Config_Dedicated_SCell->physicalConfigDedicatedSCell_r10.
                m.ul_Configuration_r10Present )
        {
            p_config_dedicated_scell->physical_config_dedicated_scell.
                bitmask |= RRM_RADIO_RES_CONFIG_DEDICATED_SCELL_UL_CONFIG_PRESENT;

            uecc_rrm_build_phy_config_dedicated_ul_config( 
                    p_ue_context,
                    &p_config_dedicated_scell->physical_config_dedicated_scell.
                    radio_res_dedicated_scell_ul_config, 
                    &p_radio_Res_Config_Dedicated_SCell->physicalConfigDedicatedSCell_r10.
                    ul_Configuration_r10);
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}


/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_phy_config_dedicated_non_ul_config
*
*   INPUT        : uecc_ue_context_t                *p_ue_context
*                  rrc_radio_res_dedicated_scell_non_ul_config_t
*                                                   *p_scell_non_ul_config
*                  PhysicalConfigDedicatedSCell_r10_nonUL_Configuration_r10
*                                                   *p_nonUL_Configuration_r10
*   OUTPUT       : none
*
*   DESCRIPTION  : This function builds
*                  rrc_radio_res_dedicated_scell_non_ul_config_t
*
*   RETURNS      : None
*
******************************************************************************/
void uecc_rrm_build_phy_config_dedicated_non_ul_config (
        uecc_ue_context_t                       *p_ue_context,
        rrc_radio_res_dedicated_scell_non_ul_config_t *p_scell_non_ul_config,   /*dest*/
        PhysicalConfigDedicatedSCell_r10_nonUL_Configuration_r10    
                                                *p_nonUL_Configuration_r10  /*src*/
        )
{  
    U8 length = RRC_NULL;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_scell_non_ul_config);
    RRC_ASSERT(PNULL != p_nonUL_Configuration_r10);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
   
    if (p_nonUL_Configuration_r10->m.antennaInfo_r10Present)
    {
        p_scell_non_ul_config->bitmask |= 
            RRM_SCELL_DEDICATED_NON_UL_ANTENNA_INFO_PRESENT;
        
        p_scell_non_ul_config->antenna_info_dedicated_r10.transmission_mode = 
           (U8)p_nonUL_Configuration_r10->antennaInfo_r10.transmissionMode_r10;

        if (p_nonUL_Configuration_r10->antennaInfo_r10.m.
                codebookSubsetRestriction_r10Present)
        {
            p_scell_non_ul_config->antenna_info_dedicated_r10.bitmask |=
                RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

            p_scell_non_ul_config->antenna_info_dedicated_r10.
                codebook_subset_restriction_r10.num_bits = 
                p_nonUL_Configuration_r10->antennaInfo_r10.
                codebookSubsetRestriction_r10.numbits;

            if (!(p_nonUL_Configuration_r10->antennaInfo_r10.
                    codebookSubsetRestriction_r10.numbits % RRC_OCTET_SIZE))
            {
                length = ((U8)p_nonUL_Configuration_r10->antennaInfo_r10.
                    codebookSubsetRestriction_r10.numbits / RRC_OCTET_SIZE);
            }
            else
            {
                length = (((U8)p_nonUL_Configuration_r10->antennaInfo_r10.
                    codebookSubsetRestriction_r10.numbits / RRC_OCTET_SIZE ) + 1);
            }
            
            memset_wrapper(&p_scell_non_ul_config->antenna_info_dedicated_r10.
                    codebook_subset_restriction_r10.value, RRC_NULL,
                    CBSR_MAX_VALUE_V1020);

            l3_memcpy_wrapper(p_scell_non_ul_config->antenna_info_dedicated_r10.
                    codebook_subset_restriction_r10.value,
                    p_nonUL_Configuration_r10->antennaInfo_r10.
                    codebookSubsetRestriction_r10.data, length);
        }

        switch(p_nonUL_Configuration_r10->antennaInfo_r10.
                ue_TransmitAntennaSelection.t)
        {
            case T_AntennaInfoDedicated_r10_ue_TransmitAntennaSelection_setup :
            {
                p_scell_non_ul_config->antenna_info_dedicated_r10.
                    ue_transmit_antenna_selection.bitmask |=
                    RRC_PHY_UE_TRANSMIT_ANTENNA_SELECTION_TYPE_PRESENT;

                p_scell_non_ul_config->antenna_info_dedicated_r10.
                    ue_transmit_antenna_selection.ue_transmit_antenna_selection_type =
                    (U8)p_nonUL_Configuration_r10->antennaInfo_r10.
                    ue_TransmitAntennaSelection.u.setup;

                p_scell_non_ul_config->antenna_info_dedicated_r10.
                    ue_transmit_antenna_selection.request_type = RRC_TRUE;
            }
            break;

            case T_AntennaInfoDedicated_r10_ue_TransmitAntennaSelection_release:
            {
                p_scell_non_ul_config->antenna_info_dedicated_r10.
                    ue_transmit_antenna_selection.request_type = RRC_NULL;
            }break;

            default :
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                        p_ue_context->p_gb_context->facility_name,
                        RRC_ERROR,
                        "Invalid value ue_TransmitAntennaSelection.t");
                return ;
            }
        }
    }

    if (p_nonUL_Configuration_r10->m.pdsch_ConfigDedicated_r10Present)
    {
        p_scell_non_ul_config->bitmask |= 
            RRM_SCELL_DEDICATED_NON_UL_PDSCH_CONFIG_DEDICATED_PRESENT;

          p_scell_non_ul_config->pdsch_configuration_dedicated.p_a =
            (U8)p_nonUL_Configuration_r10->pdsch_ConfigDedicated_r10.p_a;
    }
    
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}


/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_phy_config_dedicated_ul_config
*
*   INPUT        : uecc_ue_context_t                *p_ue_context
*                  rrc_radio_res_dedicated_scell_ul_config_t
*                                                   *p_scell_ul_config
*                  PhysicalConfigDedicatedSCell_r10_ul_Configuration_r10
*                                                   *p_ul_Configuration_r10
*   OUTPUT       : none
*
*   DESCRIPTION  : This function builds
*                  rrc_radio_res_dedicated_scell_ul_config_t
*
*   RETURNS      : None
*
******************************************************************************/
void uecc_rrm_build_phy_config_dedicated_ul_config (
        uecc_ue_context_t                *p_ue_context,
        rrc_radio_res_dedicated_scell_ul_config_t *p_scell_ul_config,/*dest*/
        PhysicalConfigDedicatedSCell_r10_ul_Configuration_r10
                                         *p_ul_Configuration_r10    /*src*/
        )
{
    CQI_ReportPeriodic_r10_setup    *p_setup = PNULL;
    rrc_phy_cqi_report_periodic_r10_setup_t *p_cqi_report_periodic_setup = PNULL;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_scell_ul_config);
    RRC_ASSERT(PNULL != p_ul_Configuration_r10);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if (p_ul_Configuration_r10->m.cqi_ReportConfigSCell_r10Present)
    {
        p_scell_ul_config->bitmask |= RRM_SCELL_DEDICATED_UL_CQI_CONFIG_SCELL_PRESENT;

        if (p_ul_Configuration_r10->cqi_ReportConfigSCell_r10.m.
                cqi_ReportModeAperiodic_r10Present)
        {
            p_scell_ul_config->cqi_report_config_scell.bitmask |=
                RRM_SCELL_CQI_REPORT_CONFIG_APERIODIC_PRESENT;
            
            p_scell_ul_config->cqi_report_config_scell.cqi_reporting_mode_aperiodic =
                (U8)p_ul_Configuration_r10->cqi_ReportConfigSCell_r10.
                cqi_ReportModeAperiodic_r10;
        }

        p_scell_ul_config->cqi_report_config_scell.nomPDSCH_RS_EPRE_Offset = 
            p_ul_Configuration_r10->cqi_ReportConfigSCell_r10.
            nomPDSCH_RS_EPRE_Offset_r10;

        if (p_ul_Configuration_r10->cqi_ReportConfigSCell_r10.m.
                cqi_ReportPeriodicSCell_r10Present)
        {
            p_scell_ul_config->cqi_report_config_scell.bitmask |=
                RRM_SCELL_CQI_REPORT_CONFIG_PERIODIC_PRESENT;
            
            switch (p_ul_Configuration_r10->cqi_ReportConfigSCell_r10.
                    cqi_ReportPeriodicSCell_r10.t)
            {
                case T_CQI_ReportPeriodic_r10_setup :
                    {
                        p_scell_ul_config->cqi_report_config_scell.cqi_report_periodic_r10.
                            bitmask |= RRC_PHY_CQI_REPORT_PERIODIC_R10SETUP_PRESENT;
                       
                        p_scell_ul_config->cqi_report_config_scell.cqi_report_periodic_r10.
                            request_type = RRC_TRUE;

                        p_setup = p_ul_Configuration_r10->cqi_ReportConfigSCell_r10.
                            cqi_ReportPeriodicSCell_r10.u.setup;

                        p_cqi_report_periodic_setup = &p_scell_ul_config->
                            cqi_report_config_scell.cqi_report_periodic_r10.setup;
                        
                        if (PNULL != p_setup)
                        {
                            uecc_rrm_build_phy_cqi_report_periodic_r10_setup (p_ue_context,
                                    p_cqi_report_periodic_setup, p_setup );
                        }
                        /* Coverity Fix 62230 Start */
                        else
                        {
                            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                                    p_ue_context->p_gb_context->facility_name,
                                    RRC_ERROR,
                                    "p_setup equal to NULL");
                            return;

                        }
                        /* Coverity Fix 62230 End */

                        
                        if (p_setup->m.ri_ConfigIndexPresent)
                        {
                            p_cqi_report_periodic_setup->bitmask |=
                                RRC_CQI_REPORT_PERIODIC_R10_SETUP_RI_CONFIG_INDEX_PRESENT;
                            
                            p_cqi_report_periodic_setup->ri_config_index = 
                                p_setup->ri_ConfigIndex; 
                        }

                        p_cqi_report_periodic_setup->simultaneous_ack_nack_cqi = 
                            p_setup->simultaneousAckNackAndCQI;

                        if (p_setup->m.cqi_Mask_r9Present)
                        {
                            p_cqi_report_periodic_setup->bitmask |=
                                RRC_CQI_REPORT_PERIODIC_R10_SETUP_CQI_MASK_PRESENT;

                            p_cqi_report_periodic_setup->cqi_mask_r9 = 
                                p_setup->cqi_Mask_r9;                            
                        }

                        if (p_setup->m.csi_ConfigIndex_r10Present)
                        {
                            p_cqi_report_periodic_setup->bitmask |=
                                RRC_CQI_REPORT_PERIODIC_R10_SETUP_CSI_CONFIG_INDEX_PRESENT;
                            
                            switch(p_setup->csi_ConfigIndex_r10.t)
                            {
                                case T_CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup :
                                    {
                                        if (PNULL != p_setup->csi_ConfigIndex_r10.u.setup)
                                        {
                                            p_cqi_report_periodic_setup->csi_config_index.
                                                bitmask |=
                                                RRC_PHY_CQI_REPORT_PERIODIC_R10_SETUP_CSI_CONFIG_INDEX_SETUP_PRESENT;
                                            
                                            p_cqi_report_periodic_setup->csi_config_index.
                                                request_type = RRC_TRUE;

                                            p_cqi_report_periodic_setup->csi_config_index.
                                                setup.cqi_pmi_config_index2 = p_setup->
                                                csi_ConfigIndex_r10.u.setup->
                                                cqi_pmi_ConfigIndex2_r10;

                                            if (p_setup->csi_ConfigIndex_r10.u.setup->m.
                                                    ri_ConfigIndex2_r10Present)
                                            {
                                                p_cqi_report_periodic_setup->csi_config_index.
                                                    setup.bitmask |=
                                                    RRC_PHY_CQI_PERIODIC_R10_SETUP_CSI_RI_CONFIG_INDEX2_PRESENT;

                                                p_cqi_report_periodic_setup->csi_config_index.
                                                    setup.ri_config_index2 = p_setup->
                                                    csi_ConfigIndex_r10.u.setup->
                                                    ri_ConfigIndex2_r10;
                                            }
                                        }
                                    }break;

                                case T_CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_release :
                                    {
                                        p_cqi_report_periodic_setup->csi_config_index.
                                            request_type = RRC_NULL;
                                    }break;
                                
                                default :
                                    {
                                        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                                                p_ue_context->p_gb_context->facility_name,
                                                RRC_ERROR,
                                                "Invalid value csi_ConfigIndex_r10.t");
                                        return ;
                                    }
                            }
                        }
                    }
                    break;

                case T_CQI_ReportPeriodic_r10_release :
                    {
                        p_scell_ul_config->cqi_report_config_scell.cqi_report_periodic_r10.
                            request_type = RRC_NULL;
                    }
                    break;

                default:
                    {
                        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                                p_ue_context->p_gb_context->facility_name,
                                RRC_ERROR,
                                "Invalid value cqi_ReportPeriodicSCell_r10.t");
                        return ;
                    }
            }
        }

        if (p_ul_Configuration_r10->cqi_ReportConfigSCell_r10.m.
                pmi_RI_Report_r10Present)
        {
            p_scell_ul_config->cqi_report_config_scell.bitmask |=
                RRM_SCELL_CQI_REPORT_CONFIG_PMI_RI_REPORT_PRESENT;

            p_scell_ul_config->cqi_report_config_scell.cqi_report_pmi_ri_report_r10 = 
                (U8)p_ul_Configuration_r10->cqi_ReportConfigSCell_r10.pmi_RI_Report_r10;
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_phy_cqi_report_periodic_r10_setup 
*
*   INPUT        : uecc_ue_context_t    *p_ue_context
*                  rrc_phy_cqi_report_periodic_r10_setup_t
*                                       *p_cqi_report_periodic_setup
*                  CQI_ReportPeriodic_r10_setup *p_setup
*
*   OUTPUT       : none
*
*   DESCRIPTION  : This function builds
*                  rrc_phy_cqi_report_periodic_r10_setup_t
*
*   RETURNS      : None
*
******************************************************************************/
void uecc_rrm_build_phy_cqi_report_periodic_r10_setup (
        uecc_ue_context_t                *p_ue_context,
        rrc_phy_cqi_report_periodic_r10_setup_t *p_cqi_report_periodic_setup,/*Dest*/
        CQI_ReportPeriodic_r10_setup *p_setup   /*src*/
        )
{
    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_cqi_report_periodic_setup);
    RRC_ASSERT(PNULL != p_setup);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    p_cqi_report_periodic_setup->cqi_pucch_resource_index = 
        p_setup->cqi_PUCCH_ResourceIndex_r10;

    if (p_setup->m.cqi_PUCCH_ResourceIndexP1_r10Present)
    {
        p_cqi_report_periodic_setup->bitmask |= 
            RRC_CQI_REPORT_PERIODIC_R10_SETUP_PUCCH_REPORT_INDEX_P1_PRESENT;

        p_cqi_report_periodic_setup->cqi_pucch_resource_index_p1 = 
            p_setup->cqi_PUCCH_ResourceIndexP1_r10;
    }

    p_cqi_report_periodic_setup->cqi_pmi_config_index = 
        p_setup->cqi_pmi_ConfigIndex;

    switch(p_setup->cqi_FormatIndicatorPeriodic_r10.t)
    {
        case T_CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10 :
            {
                p_cqi_report_periodic_setup->cqi_format_ind_periodic.bitmask |=
                    RRC_PHY_CQI_FORMAT_IND_PERIODIC_WIDEBAND_CQI_PRESENT;

                if ((PNULL != p_setup->cqi_FormatIndicatorPeriodic_r10.u.widebandCQI_r10 )
                        && (p_setup->cqi_FormatIndicatorPeriodic_r10.u.widebandCQI_r10->m.
                            csi_ReportMode_r10Present))
                {  
                    p_cqi_report_periodic_setup->cqi_format_ind_periodic.
                        cqi_format_ind_wideband.bitmask |=
                        RRC_PHY_CQI_FORMAT_IND_PERIODIC_WIDEBAND_CQI_REPORT_MODE_PRESENT;

                    p_cqi_report_periodic_setup->cqi_format_ind_periodic.
                        cqi_format_ind_wideband.csi_report_mode = (U8)p_setup->
                        cqi_FormatIndicatorPeriodic_r10.u.widebandCQI_r10->
                        csi_ReportMode_r10;
                }                
            }break;

        case T_CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_subbandCQI_r10 :
            {
                p_cqi_report_periodic_setup->cqi_format_ind_periodic.bitmask |=
                    RRC_PHY_CQI_FORMAT_IND_PERIODIC_SUBBAND_CQI_PRESENT;
                
                if (PNULL != p_setup->cqi_FormatIndicatorPeriodic_r10.u.subbandCQI_r10 )
                {
                    p_cqi_report_periodic_setup->cqi_format_ind_periodic.
                        cqi_format_ind_subband.k = p_setup->
                        cqi_FormatIndicatorPeriodic_r10.u.subbandCQI_r10->k;

                    p_cqi_report_periodic_setup->cqi_format_ind_periodic.
                        cqi_format_ind_subband.periodicy_factor = (U8)p_setup->
                        cqi_FormatIndicatorPeriodic_r10.u.subbandCQI_r10->
                        periodicityFactor_r10;
                }
            }break;

        default :
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                        p_ue_context->p_gb_context->facility_name,
                        RRC_ERROR,
                        "Invalid value cqi_FormatIndicatorPeriodic_r10.t");
                return ;
            }
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

}

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_rrm_config_candidate_cell_info
*
*   INPUT        : uecc_ue_context_t    *p_ue_context
*                  candidate_cell_info_list_t  *p_candidate_cell_info_list
*                  CandidateCellInfoList_r10   *p_candidateCellInfoList_r10
*                  
*   OUTPUT       : none
*
*   DESCRIPTION  : This function builds
*                  rrc_phy_cqi_report_periodic_r10_setup_t
*
*   RETURNS      : None
*
******************************************************************************/
void uecc_rrm_build_rrm_config_candidate_cell_info (
        uecc_ue_context_t    *p_ue_context,
        candidate_cell_info_list_t  *p_candidate_cell_info_list, /*dest*/
        CandidateCellInfoList_r10   *p_candidateCellInfoList_r10 /*src*/
        )
{
    OSRTDListNode* p_node = PNULL;
    U8 index = RRC_NULL;
    candidate_cell_info_t   *p_cell_info = PNULL;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_candidate_cell_info_list);
    RRC_ASSERT(PNULL != p_candidateCellInfoList_r10);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,p_ue_context->p_gb_context->facility_name,
                          RRC_DETAILEDALL,"Unused variable"
                          "p_ue_context=%p",p_ue_context);/*SPR 17777 +-*/
    p_candidate_cell_info_list->count = p_candidateCellInfoList_r10->count;

    p_node = p_candidateCellInfoList_r10->head;

    for (index = RRC_NULL; index < p_candidate_cell_info_list->count;
            index++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);
        RRC_ASSERT(PNULL != ((CandidateCellInfo_r10 *)p_node->data));
        
        p_cell_info = &p_candidate_cell_info_list->candidate_cell_info[index];

        p_cell_info->phy_cell_id = ((CandidateCellInfo_r10 *)p_node->data)->
            physCellId_r10;

        p_cell_info->carrier_freq = ((CandidateCellInfo_r10 *)p_node->data)->
            dl_CarrierFreq_r10;

        if ( ((CandidateCellInfo_r10 *)p_node->data)->m.rsrpResult_r10Present)
        {
            p_cell_info->bitmask |= CANDIDATE_CELL_INFO_RSRP_PRESENT;
            p_cell_info->rsrp_result = ((CandidateCellInfo_r10 *)p_node->data)->
                rsrpResult_r10;
        }

        if ( ((CandidateCellInfo_r10 *)p_node->data)->m.rsrqResult_r10Present)
        {
            p_cell_info->bitmask |= CANDIDATE_CELL_INFO_RSRQ_PRESENT;
            p_cell_info->rsrq_result = ((CandidateCellInfo_r10 *)p_node->data)->
                rsrqResult_r10;
        }

        p_node = p_node->next;
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
}


/*****************************************************************************************
*   FUNCTION NAME : fill_phyConfigDed_antennaInfo_r10 
*
*   INPUT         : uecc_ue_context_t *p_ue_context,
*                   PhysicalConfigDedicated *p_asn1_phy,
*                   rrc_phy_physical_config_dedicated_t *p_rrm_physical_config_dedicated
*
*   OUTPUT        : None
*
*   DESCRIPTION   : This function fills up PhysicalConfigDedicated_antennaInfo_r10
*                   information in physical config dedicated info field
*
*   RETURNS       : RRC_FAILURE/RRC_SUCCESS
******************************************************************************************/
rrc_return_et fill_phyConfigDed_antennaInfo_r10 (
        uecc_ue_context_t                   *p_ue_context,
	    PhysicalConfigDedicated             *p_asn1_phy,    /*src*/
        rrc_phy_physical_config_dedicated_t *p_rrm_physical_config_dedicated    /*dest*/
)
{
    U8 length = RRC_NULL;

    RRC_ASSERT(PNULL != p_rrm_physical_config_dedicated);
    RRC_ASSERT(PNULL != p_asn1_phy);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    p_rrm_physical_config_dedicated->bitmask |= RRC_PHY_ANTENNA_INFO_R10_PRESENT;

    switch(p_asn1_phy->antennaInfo_r10.t)
    {
        case T_PhysicalConfigDedicated_antennaInfo_r10_explicitValue_r10 : 
            {
                if (PNULL == p_asn1_phy->antennaInfo_r10.u.explicitValue_r10)
                {
                    return RRC_FAILURE;
                }

                p_rrm_physical_config_dedicated->antenna_info_r10.bitmask |= 
                    RRC_ANTENNA_INFO_R10_EXPLICIT_VALUE_PRESENT;

                p_rrm_physical_config_dedicated->antenna_info_r10.explicit_value.
                    transmission_mode = (U8)p_asn1_phy->antennaInfo_r10.u.
                    explicitValue_r10->transmissionMode_r10;

                if (p_asn1_phy->antennaInfo_r10.u.explicitValue_r10->m.
                        codebookSubsetRestriction_r10Present)
                {
                    p_rrm_physical_config_dedicated->antenna_info_r10.explicit_value.
                        bitmask |= RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT;
                    
                    p_rrm_physical_config_dedicated->antenna_info_r10.explicit_value.
                        codebook_subset_restriction_r10.num_bits = p_asn1_phy->
                            antennaInfo_r10.u.explicitValue_r10->codebookSubsetRestriction_r10.
                            numbits;
                    
                    RRC_ASSERT((CBSR_MAX_VALUE_V1020 * RRC_OCTET_SIZE) >= p_asn1_phy->
                            antennaInfo_r10.u.explicitValue_r10->
                            codebookSubsetRestriction_r10.numbits);

                    if (!(p_asn1_phy->antennaInfo_r10.u.explicitValue_r10->
                                codebookSubsetRestriction_r10.numbits % RRC_OCTET_SIZE))
                    {
                        length = (p_asn1_phy->antennaInfo_r10.u.explicitValue_r10->
                                codebookSubsetRestriction_r10.numbits/RRC_OCTET_SIZE);
                    }
                    else
                    {
                        length = ((p_asn1_phy->antennaInfo_r10.u.explicitValue_r10->
                                    codebookSubsetRestriction_r10.numbits/RRC_OCTET_SIZE) + 1);
                    }

                    l3_memcpy_wrapper(p_rrm_physical_config_dedicated->antenna_info_r10.
                            explicit_value.codebook_subset_restriction_r10.value,
                            p_asn1_phy->antennaInfo_r10.u.explicitValue_r10->
                            codebookSubsetRestriction_r10.data, length);
                }

                switch(p_asn1_phy->antennaInfo_r10.u.explicitValue_r10->
                        ue_TransmitAntennaSelection.t)
                {
                    case T_AntennaInfoDedicated_r10_ue_TransmitAntennaSelection_setup :
                        {
                            p_rrm_physical_config_dedicated->antenna_info_r10.explicit_value.
                                ue_transmit_antenna_selection.bitmask |= 
                                RRC_PHY_UE_TRANSMIT_ANTENNA_SELECTION_TYPE_PRESENT;

                            p_rrm_physical_config_dedicated->antenna_info_r10.explicit_value.
                                ue_transmit_antenna_selection.
                                ue_transmit_antenna_selection_type = (U8)p_asn1_phy->
                                antennaInfo_r10.u.explicitValue_r10->
                                ue_TransmitAntennaSelection.u.setup;

                            p_rrm_physical_config_dedicated->antenna_info_r10.explicit_value.
                                ue_transmit_antenna_selection.request_type = 1;
                        }break;
                    case T_AntennaInfoDedicated_r10_ue_TransmitAntennaSelection_release :
                        {
                            p_rrm_physical_config_dedicated->antenna_info_r10.explicit_value.
                                ue_transmit_antenna_selection.request_type = RRC_NULL;
                        }break;

                    default :
                        {
                            RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                                    p_ue_context->p_gb_context->facility_name,
                                    RRC_ERROR,
                                    "Invalid value ue_TransmitAntennaSelection.t");
                            return RRC_FAILURE;
                        }
                }
            }break;

        case T_PhysicalConfigDedicated_antennaInfo_r10_defaultValue :
            break;

        default :
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                        p_ue_context->p_gb_context->facility_name,
                        RRC_ERROR,
                        "Invalid value p_asn1_phy->antennaInfo_r10.t");
                return RRC_FAILURE;
            }

    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/*********************************************************************************************
*   FUNCTION NAME : fill_phyConfigDed_CQI_ReportConfig_r10 
*
*   INPUT         : uecc_ue_context_t *p_ue_context,
*                   PhysicalConfigDedicated *p_asn1_phy,
*                   rrc_phy_physical_config_dedicated_t *p_rrm_physical_config_dedicated
*
*   OUTPUT        : None
*
*   DESCRIPTION   : This function fills up CQI_ReportConfig_r10
*                   information in physical config dedicated info field
*   RETURNS       : RRC_FAILURE/RRC_SUCCESS
*
**********************************************************************************************/
rrc_return_et fill_phyConfigDed_CQI_ReportConfig_r10 (
        uecc_ue_context_t                   *p_ue_context,
	    PhysicalConfigDedicated             *p_asn1_phy,    /*src*/
        rrc_phy_physical_config_dedicated_t *p_rrm_physical_config_dedicated    /*dest*/
)
{
    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_rrm_physical_config_dedicated);
    RRC_ASSERT(PNULL != p_asn1_phy);
    
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    p_rrm_physical_config_dedicated->bitmask |= 
        RRC_PHY_CQI_REPORT_CONFIG_R10_PRESENT;

    if (p_asn1_phy->cqi_ReportConfig_r10.m.cqi_ReportAperiodic_r10Present)
    {
        p_rrm_physical_config_dedicated->cqi_report_config_r10.bitmask |=
            RRC_PHY_CQI_REPORT_CONFIG_R10_REPORT_APERIODIC_R10_PRESENT;

        switch(p_asn1_phy->cqi_ReportConfig_r10.cqi_ReportAperiodic_r10.t)
        {
            case T_CQI_ReportAperiodic_r10_setup :
                {
                    if (PNULL == p_asn1_phy->cqi_ReportConfig_r10.
                            cqi_ReportAperiodic_r10.u.setup)
                    {
                        return RRC_FAILURE;
                    }
                    p_rrm_physical_config_dedicated->cqi_report_config_r10.
                        cqi_report_aperiodic_r10.bitmask |= 
                        RRC_PHY_CQI_REPORT_APERIODIC_R10_SETUP_PRESENT;
                    
                    p_rrm_physical_config_dedicated->cqi_report_config_r10.
                        cqi_report_aperiodic_r10.request_type = 1;

                    p_rrm_physical_config_dedicated->cqi_report_config_r10.
                        cqi_report_aperiodic_r10.setup.cqi_reporting_mode_aperiodic =
                        (U8)p_asn1_phy->cqi_ReportConfig_r10.cqi_ReportAperiodic_r10.
                        u.setup->cqi_ReportModeAperiodic_r10;

                    if (p_asn1_phy->cqi_ReportConfig_r10.cqi_ReportAperiodic_r10.
                            u.setup->m.aperiodicCSI_Trigger_r10Present)
                    {
                        p_rrm_physical_config_dedicated->cqi_report_config_r10.
                            cqi_report_aperiodic_r10.setup.bitmask |=
                            RRC_CQI_REPORT_APERIODIC_R10_SETUP_APERIODIC_CSI_TRIGGER_PRESENT;

                        RRC_ASSERT((RRC_OCTET_SIZE) >= (p_asn1_phy->cqi_ReportConfig_r10.
                                    cqi_ReportAperiodic_r10.u.setup->aperiodicCSI_Trigger_r10.
                                    trigger1_r10.numbits));

                        /*trigger1_r10 and trigger2_r10 are bit strings of
                         * max 8 bits */
                        l3_memcpy_wrapper(&p_rrm_physical_config_dedicated->cqi_report_config_r10.
                                cqi_report_aperiodic_r10.setup.aperiodic_csi_trigger.
                                trigger1 ,p_asn1_phy->cqi_ReportConfig_r10.cqi_ReportAperiodic_r10.
                                u.setup->aperiodicCSI_Trigger_r10.trigger1_r10.data,
                                (sizeof(p_rrm_physical_config_dedicated->cqi_report_config_r10.
                                    cqi_report_aperiodic_r10.setup.aperiodic_csi_trigger.
                                    trigger1)));

                        RRC_ASSERT((RRC_OCTET_SIZE) >= (p_asn1_phy->cqi_ReportConfig_r10.
                                    cqi_ReportAperiodic_r10.u.setup->aperiodicCSI_Trigger_r10.
                                    trigger2_r10.numbits));

                        l3_memcpy_wrapper(&p_rrm_physical_config_dedicated->cqi_report_config_r10.
                                cqi_report_aperiodic_r10.setup.aperiodic_csi_trigger.
                                trigger2, p_asn1_phy->cqi_ReportConfig_r10.cqi_ReportAperiodic_r10.
                                u.setup->aperiodicCSI_Trigger_r10.trigger2_r10.data,
                                (sizeof(p_rrm_physical_config_dedicated->cqi_report_config_r10.
                                        cqi_report_aperiodic_r10.setup.aperiodic_csi_trigger.
                                        trigger2)));                   
                        
                    }
                }break;

            case T_CQI_ReportAperiodic_r10_release :
                {
                    p_rrm_physical_config_dedicated->cqi_report_config_r10.
                        cqi_report_aperiodic_r10.request_type = RRC_NULL;
                }break;

            default :
                {
                    RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                            p_ue_context->p_gb_context->facility_name,
                            RRC_ERROR,
                            "Invalid value cqi_ReportAperiodic_r10.t");
                    return RRC_FAILURE;

                }
        }

    }

    p_rrm_physical_config_dedicated->cqi_report_config_r10.nomPDSCH_rs_epre_offset =
        p_asn1_phy->cqi_ReportConfig_r10.nomPDSCH_RS_EPRE_Offset;

    if (p_asn1_phy->cqi_ReportConfig_r10.m.cqi_ReportPeriodic_r10Present)
    {
        p_rrm_physical_config_dedicated->cqi_report_config_r10.bitmask |=
            RRC_PHY_CQI_REPORT_CONFIG_R10_REPORT_PERIODIC_R10_PRESENT;

        result = fill_phy_cqi_report_periodic_r10(p_ue_context, p_asn1_phy->cqi_ReportConfig_r10.
                cqi_ReportPeriodic_r10, &p_rrm_physical_config_dedicated->
                cqi_report_config_r10.cqi_report_periodic_r10);
        if (result == RRC_FAILURE)
        {
            return result;
        }

    }

    if (p_asn1_phy->cqi_ReportConfig_r10.m.pmi_RI_Report_r9Present)
    {
        p_rrm_physical_config_dedicated->cqi_report_config_r10.bitmask |=
            RRC_PHY_CQI_REPORT_CONFIG_R10_PMI_RI_REPORT_R9_PRESENT;

        p_rrm_physical_config_dedicated->cqi_report_config_r10.
            cqi_report_pmi_ri_report_r10 = (U8)p_asn1_phy->cqi_ReportConfig_r10.
            pmi_RI_Report_r9;
    }

    if (p_asn1_phy->cqi_ReportConfig_r10.m.csi_SubframePatternConfig_r10Present)
    {
        p_rrm_physical_config_dedicated->cqi_report_config_r10.bitmask |=
            RRC_PHY_CQI_REPORT_CONFIG_R10_CSI_SUBFRAME_PATTERN_CONFIG_R10_PRESENT;

        result = fill_phy_cqi_report_csi_subframePattern_r10(p_ue_context, 
                p_asn1_phy->cqi_ReportConfig_r10.csi_SubframePatternConfig_r10,
                &p_rrm_physical_config_dedicated->cqi_report_config_r10.
                csi_subframePattern_r10);
        if (result == RRC_FAILURE)
        {
            return result;
        }
        /* eICIC code changes start */
        if(T_CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_release == 
                p_asn1_phy->cqi_ReportConfig_r10.csi_SubframePatternConfig_r10.t)
        {
            p_rrm_physical_config_dedicated->cqi_report_config_r10.cqi_report_periodic_r10.setup.bitmask |=
                RRC_CQI_REPORT_PERIODIC_R10_SETUP_CSI_CONFIG_INDEX_PRESENT;

            p_rrm_physical_config_dedicated->cqi_report_config_r10.cqi_report_periodic_r10.setup.
                csi_config_index.request_type = RELEASE;
        }
        /* eICIC code changes stop */
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}


/******************************************************************************
*   FUNCTION NAME: 
*   fill_phy_cqi_report_periodic_r10
*
*   INPUT        : uecc_ue_context_t *p_ue_context,
*                  CQI_ReportPeriodic_r10 cqi_ReportPeriodic_r10,
*                  rrc_phy_cqi_report_periodic_r10_t *p_rrm_cqi_report_periodic_r10
*
*   OUTPUT       : None
*
*   DESCRIPTION  : This function fills up CQI_ReportPeriodic_r10
*                  information in physical config dedicated info field
*
*   RETURNS      : RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et fill_phy_cqi_report_periodic_r10 (
        uecc_ue_context_t                   *p_ue_context,
        CQI_ReportPeriodic_r10 cqi_ReportPeriodic_r10, /*src*/
        rrc_phy_cqi_report_periodic_r10_t   *p_rrm_cqi_report_periodic_r10 /*dest*/
        )
{

    RRC_ASSERT(PNULL != p_rrm_cqi_report_periodic_r10);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    
    switch(cqi_ReportPeriodic_r10.t)
    {
        case T_CQI_ReportPeriodic_r10_setup :
            {
                if (PNULL == cqi_ReportPeriodic_r10.u.setup)
                {
                    return RRC_FAILURE;
                }
                else
                {
                    p_rrm_cqi_report_periodic_r10->bitmask |=
                        RRC_PHY_CQI_REPORT_PERIODIC_R10SETUP_PRESENT;
                    
                    p_rrm_cqi_report_periodic_r10->request_type = 1;

                    uecc_rrm_build_phy_cqi_report_periodic_r10_setup (p_ue_context,
                        &p_rrm_cqi_report_periodic_r10->setup ,cqi_ReportPeriodic_r10.u.setup); 

                    if (cqi_ReportPeriodic_r10.u.setup->m.ri_ConfigIndexPresent)
                    {
                        p_rrm_cqi_report_periodic_r10->setup.bitmask |=
                            RRC_CQI_REPORT_PERIODIC_R10_SETUP_RI_CONFIG_INDEX_PRESENT;

                        p_rrm_cqi_report_periodic_r10->setup.ri_config_index = 
                            cqi_ReportPeriodic_r10.u.setup->ri_ConfigIndex;
                    }

                    p_rrm_cqi_report_periodic_r10->setup.simultaneous_ack_nack_cqi = 
                        cqi_ReportPeriodic_r10.u.setup->simultaneousAckNackAndCQI;

                    if (cqi_ReportPeriodic_r10.u.setup->m.cqi_Mask_r9Present)
                    {
                        p_rrm_cqi_report_periodic_r10->setup.bitmask |=
                            RRC_CQI_REPORT_PERIODIC_R10_SETUP_CQI_MASK_PRESENT;

                        p_rrm_cqi_report_periodic_r10->setup.cqi_mask_r9 = 
                            (U8)cqi_ReportPeriodic_r10.u.setup->cqi_Mask_r9;
                    }

                    if (cqi_ReportPeriodic_r10.u.setup->m.csi_ConfigIndex_r10Present)
                    {
                        p_rrm_cqi_report_periodic_r10->setup.bitmask |= 
                            RRC_CQI_REPORT_PERIODIC_R10_SETUP_CSI_CONFIG_INDEX_PRESENT;
                        
                        switch(cqi_ReportPeriodic_r10.u.setup->csi_ConfigIndex_r10.t)
                        {

                            case T_CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup:
                                {
                                    if (PNULL == cqi_ReportPeriodic_r10.u.setup->
                                            csi_ConfigIndex_r10.u.setup)
                                    {
                                        return RRC_FAILURE;
                                    }
                                    else
                                    {
                                        p_rrm_cqi_report_periodic_r10->setup.
                                            csi_config_index.bitmask |=
                                            RRC_PHY_CQI_REPORT_PERIODIC_R10_SETUP_CSI_CONFIG_INDEX_SETUP_PRESENT;
                                        
                                        p_rrm_cqi_report_periodic_r10->setup.
                                            csi_config_index.request_type = 1;

                                        p_rrm_cqi_report_periodic_r10->setup.csi_config_index.
                                            setup.cqi_pmi_config_index2 = cqi_ReportPeriodic_r10.u.
                                            setup->csi_ConfigIndex_r10.u.setup->cqi_pmi_ConfigIndex2_r10;

                                        if (cqi_ReportPeriodic_r10.u.setup->csi_ConfigIndex_r10.
                                                u.setup->m.ri_ConfigIndex2_r10Present)
                                        {
                                            p_rrm_cqi_report_periodic_r10->setup.csi_config_index.
                                                setup.bitmask |= 
                                                RRC_PHY_CQI_PERIODIC_R10_SETUP_CSI_RI_CONFIG_INDEX2_PRESENT;

                                            p_rrm_cqi_report_periodic_r10->setup.csi_config_index.
                                                setup.ri_config_index2 = cqi_ReportPeriodic_r10.u.
                                                setup->csi_ConfigIndex_r10.u.setup->ri_ConfigIndex2_r10;
                                        }
                                    }
                                }break;
                            case T_CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_release :
                                {
                                    p_rrm_cqi_report_periodic_r10->setup.
                                        csi_config_index.request_type = RRC_NULL;
                                }break;

                            default :
                                {
                                    RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                                            p_ue_context->p_gb_context->facility_name,
                                            RRC_ERROR,
                                            "Invalid value csi_ConfigIndex_r10.t");
                                    return RRC_FAILURE;
                                }
                        }
                    }
                }
            }break;

        case T_CQI_ReportPeriodic_r10_release :
            {
                p_rrm_cqi_report_periodic_r10->request_type = RRC_NULL;
            }break;

        default :
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                        p_ue_context->p_gb_context->facility_name,
                        RRC_ERROR,
                        "Invalid value cqi_ReportPeriodic_r10.t");
                return RRC_FAILURE;
            }
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}


/******************************************************************************
*   FUNCTION NAME: fill_phy_cqi_report_csi_subframePattern_r10 
*
*   INPUT        : uecc_ue_context_t    *p_ue_context
*                  CQI_ReportConfig_r10_csi_SubframePatternConfig_r10
*                                        asn_csi_SubframePattern
*                  rrc_phy_cqi_report_csi_subframePattern_r10_t
*                                        *p_rrm_csi_subframePattern
*                  
*   OUTPUT       : none
*
*   DESCRIPTION  : This function fills rrc_phy_cqi_report_csi_subframePattern_r10_t                  
*
*   RETURNS      : RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et fill_phy_cqi_report_csi_subframePattern_r10 (
        uecc_ue_context_t    *p_ue_context,
        CQI_ReportConfig_r10_csi_SubframePatternConfig_r10
                             asn_csi_SubframePattern,   /*src*/
        rrc_phy_cqi_report_csi_subframePattern_r10_t
                             *p_rrm_csi_subframePattern /*dest*/
        )
{
    rrc_return_et result = RRC_FAILURE;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_rrm_csi_subframePattern);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    
    switch(asn_csi_SubframePattern.t)
    {
        case T_CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_setup :
            {
                if (PNULL == asn_csi_SubframePattern.u.setup)
                {
                    return RRC_FAILURE;
                }
                else
                {
                    p_rrm_csi_subframePattern->bitmask |= 
                        RRC_PHY_CQI_REPORT_CONFIG_R10_CSI_SUBFRAMEPATTERN_CONFIG_SETUP;
                    
                    p_rrm_csi_subframePattern->request_type = 1;

                    result = fill_phy_meas_subframe_pattern_r10(p_ue_context, 
                            asn_csi_SubframePattern.u.setup->csi_MeasSubframeSet1_r10,
                            &p_rrm_csi_subframePattern->csi_subframe_pattern_config_r10_setup.
                            csi_meas_subframe_set1_r10);
                    if (result == RRC_FAILURE)
                    {
                        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                                p_ue_context->p_gb_context->facility_name,
                                RRC_ERROR,
                                "Fill phy_meas_subframe_pattern set 1 failed ");
                        return RRC_FAILURE;
                    }

                    result = fill_phy_meas_subframe_pattern_r10(p_ue_context, 
                            asn_csi_SubframePattern.u.setup->csi_MeasSubframeSet2_r10,
                            &p_rrm_csi_subframePattern->csi_subframe_pattern_config_r10_setup.
                            csi_meas_subframe_set2_r10);
                    if (result == RRC_FAILURE)
                    {
                        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                                p_ue_context->p_gb_context->facility_name,
                                RRC_ERROR,
                                "Fill phy_meas_subframe_pattern set 2 failed ");
                        return RRC_FAILURE;
                    }
                }
            }break;

        case T_CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_release :
            {
                p_rrm_csi_subframePattern->request_type = RRC_NULL;
            }break;

        default :
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                        p_ue_context->p_gb_context->facility_name,
                        RRC_ERROR,
                        "Invalid value csi_SubframePatternConfig_r10.t");
                return RRC_FAILURE;

            }
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;

}


/******************************************************************************
*   FUNCTION NAME: fill_phy_meas_subframe_pattern_r10 
*
*   INPUT        : uecc_ue_context_t    *p_ue_context,
*                  MeasSubframePattern_r10  asn_MeasSubframeSet1_r10,
*                  rrc_phy_meas_subframe_pattern_r10_t
*                                       *p_rrm_subframe_set1_r10
*
*   OUTPUT       : none
*
*   DESCRIPTION  : This function fills rrc_phy_meas_subframe_pattern_r10_t                  
*
*   RETURNS      : RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et fill_phy_meas_subframe_pattern_r10 (
        uecc_ue_context_t    *p_ue_context,
        MeasSubframePattern_r10  asn_MeasSubframeSet1_r10,  /*src*/
        rrc_phy_meas_subframe_pattern_r10_t *p_rrm_subframe_set1_r10 /*dest*/
        )
{   
    U8 length = RRC_NULL;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_rrm_subframe_set1_r10);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    switch(asn_MeasSubframeSet1_r10.t)
    {
        case T_MeasSubframePattern_r10_subframePatternFDD_r10 :
            {
                if (PNULL == asn_MeasSubframeSet1_r10.u.subframePatternFDD_r10)
                {
                    return RRC_FAILURE;
                }
                else
                {
                    p_rrm_subframe_set1_r10->bitmask |=
                        RRC_PHY_MEAS_SUBFRAME_PATTERN_FDD_R10;

                    RRC_ASSERT((MAX_SUBFRAME_PATTERN_FDD * RRC_OCTET_SIZE) >=
                            (asn_MeasSubframeSet1_r10.u.subframePatternFDD_r10->numbits));

                    if (!(asn_MeasSubframeSet1_r10.u.subframePatternFDD_r10->numbits %
                                RRC_OCTET_SIZE))
                    {
                        length = (asn_MeasSubframeSet1_r10.u.
                                subframePatternFDD_r10->numbits / RRC_OCTET_SIZE);
                    }
                    else
                    {
                        length = ((asn_MeasSubframeSet1_r10.u.
                                    subframePatternFDD_r10->numbits / RRC_OCTET_SIZE) + 1);
                    }

                    l3_memcpy_wrapper(&p_rrm_subframe_set1_r10->subframe_pattern_fdd_r10.
                            data, asn_MeasSubframeSet1_r10.u.subframePatternFDD_r10->
                            data, length);
                }


            } break;

        case T_MeasSubframePattern_r10_subframePatternTDD_r10 :
            {
                if (PNULL == asn_MeasSubframeSet1_r10.u.subframePatternTDD_r10)
                {
                    return RRC_FAILURE;
                }
                else
                {
                    p_rrm_subframe_set1_r10->bitmask |= 
                        RRC_PHY_MEAS_SUBFRAME_PATTERN_TDD_R10;

                    switch (asn_MeasSubframeSet1_r10.u.subframePatternTDD_r10->t)
                    {
                        case T_MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig1_5_r10 :
                            {
                                if (PNULL == asn_MeasSubframeSet1_r10.u.
                                        subframePatternTDD_r10->u.subframeConfig1_5_r10)
                                {
                                    return RRC_FAILURE;
                                }
                                else
                                {   
                                    p_rrm_subframe_set1_r10->subframe_pattern_tdd_r10.
                                        bitmask |= RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG1_5_R10;

                                    RRC_ASSERT((MAX_SUBFRAME_CONFIG1_5_TDD * RRC_OCTET_SIZE) >=
                                            (asn_MeasSubframeSet1_r10.u.subframePatternTDD_r10->u.
                                             subframeConfig1_5_r10->numbits));

                                    if (!(asn_MeasSubframeSet1_r10.u.subframePatternTDD_r10->u.
                                                subframeConfig1_5_r10->numbits % RRC_OCTET_SIZE))
                                    {
                                        length = (asn_MeasSubframeSet1_r10.u.subframePatternTDD_r10->u.
                                                subframeConfig1_5_r10->numbits / RRC_OCTET_SIZE);
                                    }
                                    else
                                    {
                                        length = ((asn_MeasSubframeSet1_r10.u.subframePatternTDD_r10->u.
                                                    subframeConfig1_5_r10->numbits / RRC_OCTET_SIZE) + 1);
                                    }

                                    l3_memcpy_wrapper(p_rrm_subframe_set1_r10->subframe_pattern_tdd_r10.
                                            subframe_config1_5_r10, asn_MeasSubframeSet1_r10.u.
                                            subframePatternTDD_r10->u.subframeConfig1_5_r10->data,
                                            length);
                                }
                            }break;

                        case T_MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig0_r10 :
                            {
                                if (PNULL == asn_MeasSubframeSet1_r10.u.
                                        subframePatternTDD_r10->u.subframeConfig0_r10)
                                {
                                    return RRC_FAILURE;
                                }
                                else
                                {
                                    p_rrm_subframe_set1_r10->subframe_pattern_tdd_r10.
                                        bitmask |= RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG0_R10;

                                    RRC_ASSERT((MAX_SUBFRAME_CONFIG0_TDD * RRC_OCTET_SIZE) >=
                                            (asn_MeasSubframeSet1_r10.u.subframePatternTDD_r10->
                                             u.subframeConfig0_r10->numbits));

                                    if (!(asn_MeasSubframeSet1_r10.u.subframePatternTDD_r10->
                                                u.subframeConfig0_r10->numbits % RRC_OCTET_SIZE))
                                    {
                                        length = (asn_MeasSubframeSet1_r10.u.subframePatternTDD_r10->
                                                u.subframeConfig0_r10->numbits / RRC_OCTET_SIZE);
                                    }
                                    else
                                    {
                                        length = ((asn_MeasSubframeSet1_r10.u.subframePatternTDD_r10->
                                                    u.subframeConfig0_r10->numbits / RRC_OCTET_SIZE) + 1);
                                    }

                                    l3_memcpy_wrapper(p_rrm_subframe_set1_r10->subframe_pattern_tdd_r10.
                                            subframe_config0_r10, asn_MeasSubframeSet1_r10.u.
                                            subframePatternTDD_r10->u.subframeConfig0_r10->
                                            data, length);
                                }
                            }break;

                        case T_MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig6_r10 :
                            {
                                if (PNULL == asn_MeasSubframeSet1_r10.u.
                                        subframePatternTDD_r10->u.subframeConfig6_r10)
                                {
                                    return RRC_FAILURE;
                                }
                                else
                                {
                                    p_rrm_subframe_set1_r10->subframe_pattern_tdd_r10.
                                        bitmask |= RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG6_R10;

                                    RRC_ASSERT((MAX_SUBFRAME_CONFIG6_TDD * RRC_OCTET_SIZE) >=
                                            (asn_MeasSubframeSet1_r10.u.subframePatternTDD_r10->
                                             u.subframeConfig6_r10->numbits));

                                    if (!(asn_MeasSubframeSet1_r10.u.subframePatternTDD_r10->
                                                u.subframeConfig6_r10->numbits % RRC_OCTET_SIZE))
                                    {
                                        length = (asn_MeasSubframeSet1_r10.u.subframePatternTDD_r10->
                                                u.subframeConfig6_r10->numbits / RRC_OCTET_SIZE);
                                    }
                                    else
                                    {
                                        length = ((asn_MeasSubframeSet1_r10.u.subframePatternTDD_r10->
                                                    u.subframeConfig6_r10->numbits / RRC_OCTET_SIZE) + 1);
                                    }

                                    l3_memcpy_wrapper(p_rrm_subframe_set1_r10->subframe_pattern_tdd_r10.
                                            subframe_config6_r10, asn_MeasSubframeSet1_r10.u.
                                            subframePatternTDD_r10->u.subframeConfig6_r10->
                                            data, length);
                                }

                            }break;
                        default :
                            {
                                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                                        p_ue_context->p_gb_context->facility_name,
                                        RRC_ERROR,
                                        "Invalid value subframePatternTDD_r10.t");
                                return RRC_FAILURE;

                            }
                    }
                }
            }break;

        default :
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                        p_ue_context->p_gb_context->facility_name,
                        RRC_ERROR,
                        "Invalid value csi_MeasSubframeSet1_r10.t");
                return RRC_FAILURE;
            }
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}


/******************************************************************************
*   FUNCTION NAME: fill_phyConfigDed_additional_spectrum_emission_ca_r10 
*
*   INPUT        : uecc_ue_context_t                   *p_ue_context,
*                  PhysicalConfigDedicated             *p_asn1_phy, 
*                  rrc_phy_physical_config_dedicated_t *p_rrm_physical_config_dedicated
*
*   OUTPUT       : none
*
*   DESCRIPTION  : This function fills rrc_additional_spectrum_emission_ca_r10_t                  
*
*   RETURNS      : RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et fill_phyConfigDed_additional_spectrum_emission_ca_r10 (
        uecc_ue_context_t                   *p_ue_context,
	    PhysicalConfigDedicated             *p_asn1_phy,    /*src*/
        rrc_phy_physical_config_dedicated_t *p_rrm_physical_config_dedicated    /*dest*/
        )
{

    RRC_ASSERT(PNULL != p_rrm_physical_config_dedicated);
    RRC_ASSERT(PNULL != p_asn1_phy);
    
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    p_rrm_physical_config_dedicated->bitmask |= 
        RRC_PHY_CONFIG_DEDICATED_EXTENDED_PRESENT;

    p_rrm_physical_config_dedicated->phy_physical_config_dedicated_extended.
        bitmask |= RRC_PHY_ADDITIONAL_SPECTRUM_EMISSION_CA_R10_PRESENT;

    switch(p_asn1_phy->additionalSpectrumEmissionCA_r10.t)
    {
        case T_PhysicalConfigDedicated_additionalSpectrumEmissionCA_r10_setup :
            {
                if (PNULL == p_asn1_phy->additionalSpectrumEmissionCA_r10.u.setup)
                {
                    return RRC_FAILURE;
                }
                else
                {
                    p_rrm_physical_config_dedicated->phy_physical_config_dedicated_extended.
                        additional_spectrum_emission_ca.bitmask |=
                        RRC_PHY_ADDITIONAL_SPECTRUM_EMISSION_CA_R10_PCELL_PRESENT;
                    
                    p_rrm_physical_config_dedicated->phy_physical_config_dedicated_extended.
                        additional_spectrum_emission_ca.request_type = 1;

                    p_rrm_physical_config_dedicated->phy_physical_config_dedicated_extended.
                        additional_spectrum_emission_ca.additional_spectrum_emission_pcell =
                        p_asn1_phy->additionalSpectrumEmissionCA_r10.u.setup->
                        additionalSpectrumEmissionPCell_r10;
                }
            }break;

        case T_PhysicalConfigDedicated_additionalSpectrumEmissionCA_r10_release :
            {
                p_rrm_physical_config_dedicated->phy_physical_config_dedicated_extended.
                    additional_spectrum_emission_ca.request_type = RRC_NULL;
            }break;
        
        default :
            {
                RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                        p_ue_context->p_gb_context->facility_name,
                        RRC_ERROR,
                        "Invalid value additionalSpectrumEmissionCA_r10.t");
                return RRC_FAILURE;
            }
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}

/******************************************************************************
*   FUNCTION NAME: fill_phyConfigDed_pucch_channel_selection_config_v1020 
*
*   INPUT        : uecc_ue_context_t                   *p_ue_context,
*                  PhysicalConfigDedicated             *p_asn1_phy, 
*                  rrc_phy_physical_config_dedicated_t *p_rrm_physical_config_dedicated
*
*   OUTPUT       : none
*
*   DESCRIPTION  : This function fills rrc_pucch_channel_selection_config_v1020_t                  
*
*   RETURNS      : RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et fill_phyConfigDed_pucch_channel_selection_config_v1020 (
        uecc_ue_context_t                   *p_ue_context,
	    PhysicalConfigDedicated             *p_asn1_phy,    /*src*/
        rrc_phy_physical_config_dedicated_t *p_rrm_physical_config_dedicated    /*dest*/
        )
{
    n1pucch_an_cs_list_r10_t    *p_n1pucch_an_cs_list = PNULL;
    PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_setup
                                *p_asn_n1PUCCH_AN_CS_r10_setup = PNULL;
    OSRTDListNode* p_node = PNULL;
    U8 index = RRC_NULL;
    U8 count = RRC_NULL;

    RRC_ASSERT(PNULL != p_rrm_physical_config_dedicated);
    RRC_ASSERT(PNULL != p_asn1_phy);
    
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);
    
    if (p_asn1_phy->pucch_ConfigDedicated_v1020.m.pucch_Format_r10Present)
    {
        switch(p_asn1_phy->pucch_ConfigDedicated_v1020.pucch_Format_r10.t)
        {
            case T_PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10 :
                {
                    if (PNULL == p_asn1_phy->pucch_ConfigDedicated_v1020.
                            pucch_Format_r10.u.channelSelection_r10)
                    {
                        return RRC_FAILURE;
                    }
                    else
                    {   
                        p_rrm_physical_config_dedicated->bitmask |=
                            RRC_PHY_CONFIG_DEDICATED_EXTENDED_PRESENT;

                        p_rrm_physical_config_dedicated->phy_physical_config_dedicated_extended.
                            bitmask |= RRC_PHY_PUCCH_CHANNEL_SELECTION_CONFIG_R10_PRESENT;
                        
                        if (p_asn1_phy->pucch_ConfigDedicated_v1020.
                                pucch_Format_r10.u.channelSelection_r10->m.
                                n1PUCCH_AN_CS_r10Present)
                        {
                            p_rrm_physical_config_dedicated->phy_physical_config_dedicated_extended.
                                pucch_channel_selection_config_v1020.bitmask |=
                                RRC_N1PUCCH_AN_CS_R10_PRESENT;

                            switch(p_asn1_phy->pucch_ConfigDedicated_v1020.
                                    pucch_Format_r10.u.channelSelection_r10->
                                    n1PUCCH_AN_CS_r10.t)
                            {
                                case T_PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_release :
                                    {
                                        p_rrm_physical_config_dedicated->
                                            phy_physical_config_dedicated_extended.
                                            pucch_channel_selection_config_v1020.
                                            channel_selection_n1_pucch_an_cs_r10.bitmask = RRC_NULL;

                                        p_rrm_physical_config_dedicated->
                                            phy_physical_config_dedicated_extended.
                                            pucch_channel_selection_config_v1020.
                                            channel_selection_n1_pucch_an_cs_r10.
                                            request_type = RRC_NULL;

                                    }break;

                                case T_PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_setup :
                                    {
                                        if (PNULL == p_asn1_phy->pucch_ConfigDedicated_v1020.
                                                pucch_Format_r10.u.channelSelection_r10->
                                                n1PUCCH_AN_CS_r10.u.setup)
                                        {
                                            return RRC_FAILURE;
                                        }
                                        else
                                        {
                                            p_rrm_physical_config_dedicated->
                                                phy_physical_config_dedicated_extended.
                                                pucch_channel_selection_config_v1020.
                                                channel_selection_n1_pucch_an_cs_r10.bitmask |=
                                                RRC_N1PUCCH_AN_CS_LIST_R10_PRESENT;

                                            p_rrm_physical_config_dedicated->
                                                phy_physical_config_dedicated_extended.
                                                pucch_channel_selection_config_v1020.
                                                channel_selection_n1_pucch_an_cs_r10.
                                                request_type = 1;

                                            p_n1pucch_an_cs_list = &p_rrm_physical_config_dedicated->
                                                phy_physical_config_dedicated_extended.
                                                pucch_channel_selection_config_v1020.
                                                channel_selection_n1_pucch_an_cs_r10.
                                                n1pucch_an_cs_list_r10;

                                            p_asn_n1PUCCH_AN_CS_r10_setup = 
                                                p_asn1_phy->pucch_ConfigDedicated_v1020. 
                                                pucch_Format_r10.u.channelSelection_r10->
                                                n1PUCCH_AN_CS_r10.u.setup;
                                            
                                            p_node = p_asn_n1PUCCH_AN_CS_r10_setup->
                                                n1PUCCH_AN_CS_List_r10.head;

                                            p_n1pucch_an_cs_list->count = 
                                                p_asn_n1PUCCH_AN_CS_r10_setup->
                                                n1PUCCH_AN_CS_List_r10.count;

                                            for (index = RRC_NULL; index < p_n1pucch_an_cs_list->count;
                                                    index++)
                                            {
                                                RRC_ASSERT(PNULL != p_node);
                                                RRC_ASSERT(PNULL != p_node->data);

                                                p_n1pucch_an_cs_list->n1_pucch_an_cs[index].
                                                    count = ((N1PUCCH_AN_CS_r10 *)p_node->data)->n;

                                                for (count = RRC_NULL; count < p_n1pucch_an_cs_list->
                                                        n1_pucch_an_cs[index].count; count++)
                                                {
                                                    p_n1pucch_an_cs_list->n1_pucch_an_cs[index].
                                                            n1_pucch_an_cs[count] = 
                                                            ((N1PUCCH_AN_CS_r10 *)p_node->data)->elem[count];
                                                }
                                                p_node = p_node->next;
                                            }
                                        }
                                    }break;

                                default :
                                    {
                                        RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                                                p_ue_context->p_gb_context->facility_name,
                                                RRC_ERROR,
                                                "Invalid value n1PUCCH_AN_CS_r10.t");
                                        return RRC_FAILURE;
                                    }
                            }
                        }
                    }
                }break;

            case T_PUCCH_ConfigDedicated_v1020_pucch_Format_r10_format3_r10 :
                {
                }break;

            default :
                {
                    RRC_UECC_TRACE(p_ue_context->p_gb_context->context_index,
                            p_ue_context->p_gb_context->facility_name,
                            RRC_ERROR,
                            "Invalid value pucch_Format_r10.t");
                    return RRC_FAILURE;
                }
        }
    }
    
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return RRC_SUCCESS;
}




/****************************************************************************
 * Function Name  : rrc_rrm_update_scells_operation_list 
 * Inputs         : scell_config - Scell configuration  *                                  
 *                  uecc_ue_context_t* - pointer to UE context
 *                 
 * Outputs        : None
 * Returns        : None
 * Description    : This action routine is called inorder to update 
 *                  scells_operation_list in UE Context and validate the Scell
 *                  Configuration received from RRM
 ****************************************************************************/
rrc_return_et rrc_rrm_validate_scell_config (
        rrm_scell_config_t         *p_scell_config,
        uecc_ue_context_t          *p_uecc_ue_context)
{

    U8              count = RRC_NULL;
    rrc_bool_et     cell_index_present = RRC_FALSE;
    U8              scell_index = RRC_NULL;
    
    rrc_return_et   result = RRC_SUCCESS;
    
    U8              index = RRC_NULL;
    U8              scells_to_add = RRC_NULL;
    U8              scells_to_delete = RRC_NULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
   
    if ((PNULL != p_uecc_ue_context->uecc_fsm.proc_descriptor.
                p_active_proc) && 
            ( PNULL != p_uecc_ue_context->p_curr_proc_data))
    {
        if (!(strcmp_wrapper(p_uecc_ue_context->uecc_fsm.proc_descriptor.
                        p_active_proc->s_id, (const S8 *)"UE_RRM_UE_RECONFIG_P")))
        {
            if ( p_scell_config->bitmask & RRM_SCELL_RELEASE_LIST_PRESENT )
            {
                for ( count = RRC_NULL ; ((count < p_scell_config->scell_release_list.
                        count) && (count < MAX_SCELL)); count++ )
                {
                    if ( !( p_scell_config->scell_release_list.
                                rrc_scell_to_release[count].bitmask & 
                                RRM_SCELL_TO_RELEASE_CELL_INDEX_PRESENT ) )
                    {
                        RRC_TRACE(RRC_WARNING,"Cell Index is not present in"
                                "scell_release_list");
                        return RRC_FAILURE;
                    }
                }
            }
        }
    }
    
    if ( p_scell_config->bitmask & RRM_SCELL_ADD_MOD_LIST_PRESENT )
    {
        for ( count = RRC_NULL ; ((count < p_scell_config->scell_add_mod_list.
                        count) && (count < MAX_SCELL)) ; count++ )
        {
            if ( !( p_scell_config->scell_add_mod_list.
                        rrc_scell_to_add_mod[count].bitmask & 
                        RRM_SCELL_ADD_MOD_CELL_INDEX_PRESENT ) )
            {
                RRC_TRACE(RRC_WARNING,"Cell Index is not present in"
                        "scell_add_mod_list");
                return RRC_FAILURE;

            }

        }
    }


    if (PNULL != p_uecc_ue_context->p_scell_config) 
    {
        if ( p_uecc_ue_context->p_scell_config->bitmask &
                RRM_SCELL_ADD_MOD_LIST_PRESENT )
        {
            /*Checking the Scell configuration provided by RRM
             * and updating the scells operation type in the UE context */
            if (p_scell_config->bitmask & RRM_SCELL_ADD_MOD_LIST_PRESENT)
            {
                for ( count = RRC_NULL; count < p_scell_config->
                        scell_add_mod_list.count; count++)
                {
                    scell_index = p_scell_config->scell_add_mod_list.
                        rrc_scell_to_add_mod[count].scellIndex;

                    for (index = RRC_NULL; index < p_uecc_ue_context->
                            p_scell_config->scell_add_mod_list.count; index++)
                    {
                        if (scell_index == p_uecc_ue_context->p_scell_config->scell_add_mod_list.
                                rrc_scell_to_add_mod[index].scellIndex)
                        {
                            cell_index_present = RRC_TRUE;
                            break;
                        }
                    }

                    p_uecc_ue_context->scells_operation_list[scell_index].
                        chk_cellid_exist = RRC_TRUE;

                    if ( RRC_TRUE == cell_index_present )
                    {
                        p_uecc_ue_context->scells_operation_list[scell_index].
                            operation_type = MODIFY_SCELL;
                        
                        cell_index_present = RRC_FALSE;
                    }
                    else
                    {
                        p_uecc_ue_context->scells_operation_list[scell_index].
                            operation_type = ADD_SCELL;
                    }
                }
            }
        }
        
        cell_index_present = RRC_FALSE;

        if (p_scell_config->bitmask & RRM_SCELL_RELEASE_LIST_PRESENT)
        {
            for (count = RRC_NULL; count < p_scell_config->scell_release_list.count; 
                    count++)
            {
                scell_index = p_scell_config->scell_release_list.
                    rrc_scell_to_release[count].scellIndex;

                for (index = RRC_NULL; index < p_uecc_ue_context->
                        p_scell_config->scell_add_mod_list.count; index++)
                {
                    if (scell_index == p_uecc_ue_context->
                            p_scell_config->scell_add_mod_list.
                            rrc_scell_to_add_mod[index].scellIndex)
                    {
                        cell_index_present = RRC_TRUE;
                        break;
                    }
                }

                if ( RRC_TRUE == cell_index_present )
                {
                    /* Coverity Fix 62231 Start */
                    if ( ( RRC_TRUE == p_uecc_ue_context->scells_operation_list[scell_index].
                            chk_cellid_exist ) && ( p_uecc_ue_context->scells_operation_list[scell_index].
                                operation_type == MODIFY_SCELL ))
                    {
                    /* Coverity Fix 62231 End */
                        p_uecc_ue_context->scells_operation_list[scell_index].
                            scell_to_add_after_deletion_flag = RRC_TRUE;
                        p_uecc_ue_context->scells_operation_list[scell_index].
                            operation_type = DELETE_SCELL;
                        p_uecc_ue_context->scells_operation_list[scell_index].
                            chk_cellid_exist = RRC_TRUE;
                    }
                    else
                    {
                        p_uecc_ue_context->scells_operation_list[scell_index].
                            operation_type = DELETE_SCELL;
                        p_uecc_ue_context->scells_operation_list[scell_index].
                            chk_cellid_exist = RRC_TRUE;
                    }
                    
                    cell_index_present = RRC_FALSE;
                }
                else
                {
                    RRC_TRACE(RRC_ERROR,
                            "[%s]SCELL to release is not configured ! ",__FUNCTION__);
                    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }
            }
        }

        for (index = RRC_NULL ; index < MAX_NUM_CELLS; index++)
        {
            if(RRC_TRUE == p_uecc_ue_context->scells_operation_list[index].
                    chk_cellid_exist)
            {
                if (p_uecc_ue_context->scells_operation_list[index].operation_type == ADD_SCELL)
                {
                    scells_to_add++;
                }
                else if ( (p_uecc_ue_context->scells_operation_list[index].operation_type == DELETE_SCELL) &&
                        ( RRC_FALSE == p_uecc_ue_context->scells_operation_list[index].
                            scell_to_add_after_deletion_flag ))
                {
                    scells_to_delete++;
                }
                else if ( (p_uecc_ue_context->scells_operation_list[index].operation_type == DELETE_SCELL) &&
                        ( RRC_TRUE == p_uecc_ue_context->scells_operation_list[index].
                            scell_to_add_after_deletion_flag ))
                {
                     scells_to_delete++;
                     scells_to_add++;
                }
            }
        }

        if (((p_uecc_ue_context->p_scell_config->scell_add_mod_list.count) + 
                    scells_to_add - scells_to_delete ) > MAX_SCELL )
        {
            RRC_TRACE(RRC_ERROR,
                    "[%s]SCELL Validation Failed .",__FUNCTION__);
            result = RRC_FAILURE;
        }
    }
    else
    {
        if (p_scell_config->bitmask & RRM_SCELL_ADD_MOD_LIST_PRESENT)
        {
            for (count = RRC_NULL; count < p_scell_config->scell_add_mod_list.
                    count; count++)
            {   
                scell_index = p_scell_config->scell_add_mod_list.
                    rrc_scell_to_add_mod[count].scellIndex;

                p_uecc_ue_context->scells_operation_list[scell_index].
                    chk_cellid_exist = RRC_TRUE;

                p_uecc_ue_context->scells_operation_list[scell_index].
                    operation_type = ADD_SCELL;
            }
        }

        if(p_scell_config->bitmask & RRM_SCELL_RELEASE_LIST_PRESENT)
        {    
            /*If UE is reconfigured dynamically for the first time then 
             * release list should not be present*/
            RRC_TRACE(RRC_ERROR,
                    "[%s]SCELL Release List should not be present ! ",__FUNCTION__);
            result = RRC_FAILURE;
        }    
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}

/*****************************************************************************
 *  * Function Name  : uecc_rrm_process_scell_config 
 *  * Input          : uecc_ue_context_t*            p_ue_context
 *  *                  rrm_scell_config_t*           p_msg_scell_config
 *  * Output         : None                 
 *  * Returns        : RRC_SUCCESS/RRC_FAILURE
 *  * Description    : This function processes scell config received from 
 *                     UE Reconfig Request message.
 *  ****************************************************************************/
rrc_return_et uecc_rrm_process_scell_config
(
 uecc_ue_context_t    *p_ue_context,
 rrm_scell_config_t   *p_msg_scell_config   
)
{
    /* Coverity Fix 61052 */
    rrc_return_et    result = RRC_SUCCESS;
    U8   count = RRC_NULL;
    U8   max_num_scell = RRC_NULL;
    U8   scell_index = RRC_NULL;
    rrc_scell_to_add_mod_t *p_rrc_scell_to_add_mod = PNULL;
    rrc_cqi_report_config_scell_r10_t   *p_rrc_cqi_report_config_scell_r10 = PNULL;
    rrc_antenna_info_dedicated_r10_t    *p_rrc_antenna_info_dedicated_r10 = PNULL;

    U8   scell_non_ul_config_present = RRC_FALSE;
    
    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if((p_msg_scell_config->bitmask & RRM_SCELL_ADD_MOD_LIST_PRESENT) ||
            p_msg_scell_config->bitmask & RRM_SCELL_RELEASE_LIST_PRESENT)
    {
        
        result = rrc_rrm_validate_scell_config(p_msg_scell_config,
                p_ue_context);

        if (RRC_FAILURE != result)
        {
            /* SPR 14562 Fix start */
            if(p_msg_scell_config->bitmask & RRM_SCELL_ADD_MOD_LIST_PRESENT)
            {
            /* SPR 14562 Fix end */

               max_num_scell = p_msg_scell_config->scell_add_mod_list.count;
            }

            for(count = RRC_NULL; count < max_num_scell; count++)
            {
                p_rrc_scell_to_add_mod = &p_msg_scell_config->
                    scell_add_mod_list.rrc_scell_to_add_mod[count];

                scell_index = 
                    p_msg_scell_config->scell_add_mod_list.rrc_scell_to_add_mod[count].
                    scellIndex;
                
                p_ue_context->scells_operation_list[scell_index].
                    valid_ind = RRC_TRUE;

                if((p_rrc_scell_to_add_mod->bitmask &
                            RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_DEDICATED_SCELL_PRESENT)
                        && (p_rrc_scell_to_add_mod->
                            radio_res_config_dedicated_scell.bitmask &
                            RRM_PHYSICAL_CONFIG_DEDICATED_SCELL_CONFIG_PRESENT))
                {
                    if((p_rrc_scell_to_add_mod->
                                radio_res_config_dedicated_scell.
                                physical_config_dedicated_scell.bitmask &
                                RRM_RADIO_RES_CONFIG_DEDICATED_SCELL_UL_CONFIG_PRESENT)
                            && (p_rrc_scell_to_add_mod->
                                radio_res_config_dedicated_scell.
                                physical_config_dedicated_scell.
                                radio_res_dedicated_scell_ul_config.bitmask &
                                RRM_SCELL_DEDICATED_UL_CQI_CONFIG_SCELL_PRESENT))
                    {
                        p_rrc_cqi_report_config_scell_r10 = &p_rrc_scell_to_add_mod->
                            radio_res_config_dedicated_scell.physical_config_dedicated_scell.
                            radio_res_dedicated_scell_ul_config.
                            cqi_report_config_scell;

                        if(!((p_rrc_cqi_report_config_scell_r10->bitmask &
                                        RRM_SCELL_CQI_REPORT_CONFIG_APERIODIC_PRESENT) ||
                                    ((p_rrc_cqi_report_config_scell_r10->bitmask &
                                      RRM_SCELL_CQI_REPORT_CONFIG_PERIODIC_PRESENT) &&
                                     (p_rrc_cqi_report_config_scell_r10->
                                      cqi_report_periodic_r10.bitmask &
                                      RRC_PHY_CQI_REPORT_PERIODIC_R10SETUP_PRESENT)))) 
                        {
                            if(p_rrc_cqi_report_config_scell_r10->bitmask &
                                    RRM_SCELL_CQI_REPORT_CONFIG_PMI_RI_REPORT_PRESENT)
                            {
                            p_rrc_cqi_report_config_scell_r10->bitmask ^=
                                RRM_SCELL_CQI_REPORT_CONFIG_PMI_RI_REPORT_PRESENT;
                        }
                        }

                    }

                    if(p_rrc_scell_to_add_mod->radio_res_config_dedicated_scell.
                            physical_config_dedicated_scell.bitmask & 
                            RRM_RADIO_RES_CONFIG_DEDICATED_SCELL_NON_UL_CONFIG_PRESENT)
                    {
                        
                        scell_non_ul_config_present = RRC_TRUE;
                        
                        if(p_rrc_scell_to_add_mod->radio_res_config_dedicated_scell.
                                physical_config_dedicated_scell.
                                radio_res_dedicated_scell_non_ul_config.bitmask &
                                RRM_SCELL_DEDICATED_NON_UL_ANTENNA_INFO_PRESENT)
                        {
                            p_rrc_antenna_info_dedicated_r10 = &p_rrc_scell_to_add_mod->
                                radio_res_config_dedicated_scell.
                                physical_config_dedicated_scell.
                                radio_res_dedicated_scell_non_ul_config.
                                antenna_info_dedicated_r10;

                            if(TRANSMISSION_MODE_TM3 ==
                                    p_rrc_antenna_info_dedicated_r10->transmission_mode ||
                                    TRANSMISSION_MODE_TM4 ==
                                    p_rrc_antenna_info_dedicated_r10->transmission_mode ||
                                    TRANSMISSION_MODE_TM5 ==
                                    p_rrc_antenna_info_dedicated_r10->transmission_mode ||
                                    TRANSMISSION_MODE_TM6 ==
                                    p_rrc_antenna_info_dedicated_r10->transmission_mode ||
                                    TRANSMISSION_MODE_TM8_V920 ==
                                    p_rrc_antenna_info_dedicated_r10->transmission_mode)
                            {
                                if(!(p_rrc_antenna_info_dedicated_r10->bitmask &
                                            RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT))
                                {
                                    RRC_TRACE(RRC_INFO,"RRM Messages CA Config incomplete");
                                    
                                    return RRC_FAILURE;
                                    
                                }
                            }
                            else
                            {
                                if((p_rrc_antenna_info_dedicated_r10->bitmask &
                                            RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT))
                                {
                                    p_rrc_antenna_info_dedicated_r10->bitmask ^=
                                        RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT;
                                }
                            }
                        }
                    }
                }
                if(MODIFY_SCELL == 
                        p_ue_context->scells_operation_list[scell_index].operation_type)
                {
                    if(p_msg_scell_config->scell_add_mod_list.rrc_scell_to_add_mod[count].
                            bitmask & RRM_SCELL_ADD_MOD_CELL_IDENTIFICATION_PRESENT) 
                    {
                        p_msg_scell_config->scell_add_mod_list.rrc_scell_to_add_mod[count].
                            bitmask ^= RRM_SCELL_ADD_MOD_CELL_IDENTIFICATION_PRESENT;
                    }
                    if(p_msg_scell_config->scell_add_mod_list.rrc_scell_to_add_mod[count].
                            bitmask & RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_COMMON_SCELL_PRESENT)
                    {
                        p_msg_scell_config->scell_add_mod_list.rrc_scell_to_add_mod[count].
                            bitmask ^= RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_COMMON_SCELL_PRESENT;
                        
                        RRC_TRACE(RRC_INFO,"Common Scell Configuration should not be present "
                                "for Scell Modification scell_index = %d",scell_index);
                        return RRC_FAILURE;
                        
                    }
                }
                else 
                {

                    if(!((p_rrc_scell_to_add_mod->bitmask & RRM_SCELL_ADD_MOD_CELL_IDENTIFICATION_PRESENT) &&
                                (p_rrc_scell_to_add_mod->bitmask & 
                                 RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_COMMON_SCELL_PRESENT) &&
                                (p_rrc_scell_to_add_mod->bitmask & 
                                 RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_DEDICATED_SCELL_PRESENT) && 
                                (p_rrc_scell_to_add_mod->bitmask &
                                 RRM_SCELL_ADD_MOD_MAC_SCELL_CONFIG_EXTENSION_SCELL_PRESENT) &&
                                (p_rrc_scell_to_add_mod->mac_main_config_extensions.bitmask &
                                 RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_DL_NUM_HARQ_PROC_PRESENT) &&
                                (p_rrc_scell_to_add_mod->mac_main_config_extensions.bitmask &
                                 RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_USER_LOCATION_TYPE_PRESENT) &&
                                (p_rrc_scell_to_add_mod->mac_main_config_extensions.bitmask &
                                 RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_DL_INIT_MCS_PRESENT) &&
                                (p_rrc_scell_to_add_mod->mac_main_config_extensions.bitmask &
                                 RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_NUM_OF_LAYER_INFO_PRESENT) &&
                                (p_rrc_scell_to_add_mod->mac_main_config_extensions.bitmask &
                                 RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_CODE_BOOK_INDEX_INFO_PRESENT) &&
                                (RRC_TRUE == scell_non_ul_config_present) &&
                                (p_rrc_scell_to_add_mod->radio_res_config_dedicated_scell.
                                 physical_config_dedicated_scell.
                                 radio_res_dedicated_scell_non_ul_config.bitmask &
                                 RRM_SCELL_DEDICATED_NON_UL_PDSCH_CONFIG_DEDICATED_PRESENT) &&
                                (p_rrc_scell_to_add_mod->radio_res_config_dedicated_scell.
                                 physical_config_dedicated_scell.
                                 radio_res_dedicated_scell_non_ul_config.bitmask &
                                 RRM_SCELL_DEDICATED_NON_UL_ANTENNA_INFO_PRESENT)))
                                 {
                                     RRC_TRACE(RRC_INFO,"RRM Messages CA Config incomplete");
                                     
                                     return RRC_FAILURE;
                                     
                                 }
                }
            }

            if ((PNULL != p_ue_context->uecc_fsm.proc_descriptor.
                        p_active_proc) && 
                    ( PNULL != p_ue_context->p_curr_proc_data))
            {
                if (!(strcmp_wrapper(p_ue_context->uecc_fsm.proc_descriptor.
                                p_active_proc->s_id, (const S8 *)"UE_RRM_UE_RECONFIG_P")))
                {
                    p_ue_context->p_curr_proc_data->u.rrm_ue_reconfig_request_data.p_scell_config =
                        rrc_mem_get(sizeof(rrm_scell_config_t));

                    if(PNULL != 
                            p_ue_context->p_curr_proc_data->u.rrm_ue_reconfig_request_data.p_scell_config)
                    {
                        l3_memcpy_wrapper(p_ue_context->p_curr_proc_data->u.rrm_ue_reconfig_request_data.
                                p_scell_config, p_msg_scell_config, 
                                sizeof(rrm_scell_config_t));
                        
                        p_ue_context->p_curr_proc_data->u.rrm_ue_reconfig_request_data.
                            m.scell_config_updated = RRC_TRUE;
                        p_ue_context->m.scell_config_present = RRC_TRUE;
                    }
                    else
                    {
                        RRC_TRACE(RRC_FATAL,"RRM Message :"
                                "Memory Allocation Failed");
                        result = RRC_FAILURE;
                    }
                }
            }
        }
        else
        {
            RRC_TRACE(RRC_INFO,"validation failed for scell_config");
        }
    }
    else
    {
        RRC_TRACE(RRC_INFO,"RRM Messages CA Config incomplete");
        
        result = RRC_FAILURE;
        
    }
    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/****************************************************************************
 * Function Name  : rrc_rrm_update_ue_ctx_scell_config
 * Inputs         : rrc_rrm_ue_ho_adm_resp_t* - pointer to
 *                                              RRC_RRM_UE_HO_ADM_RESP
 *                  uecc_ue_context_t*        - pointer to UE context
 *                 
 * Outputs        : None
 * Returns        : None
 * Description    : This action routine is called inorder to update original 
 *                  scell configuration in UE context according to the 
 *                  configuration recieved from RRM.
 ****************************************************************************/
void  rrc_rrm_update_ue_ctx_scell_config (rrm_scell_config_t *p_scell_config,
        uecc_ue_context_t*  p_uecc_ue_context)
{
    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_scell_config);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    U8 count = RRC_NULL;
    U8 index = RRC_NULL;
    U8 scell_count = RRC_NULL;
    U8 num_scells_delete = RRC_NULL;
    rrc_bool_et cell_index_present = RRC_FALSE;

/*coverity fix 61044*/
    if(PNULL == p_uecc_ue_context->p_scell_config)
    {
        RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                (p_uecc_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,
                "scell config in ue context is NULL ");
        return;
    }
/*coverity fix 61044*/

    /*Updating the ScellConfig in UE Context according to the configuration
     * received from RRM */
    /* Here count signifies the cell_index*/
    for (count = RRC_NULL; count < MAX_NUM_CELLS; count++)
    {
        if (( RRC_TRUE == p_uecc_ue_context->scells_operation_list[count].
                    chk_cellid_exist ) &&
                ( DELETE_SCELL == p_uecc_ue_context->scells_operation_list[count].
                  operation_type ))
        {
            if ( p_uecc_ue_context->p_scell_config->bitmask &
                    RRM_SCELL_ADD_MOD_LIST_PRESENT )
            {
                for (index = RRC_NULL; ((index < p_uecc_ue_context->
                        p_scell_config->scell_add_mod_list.count) && 
                        (index < MAX_SCELL)); index++)
                {
                    if (count == p_uecc_ue_context->p_scell_config->
                            scell_add_mod_list.rrc_scell_to_add_mod[index].
                            scellIndex)
                    {

                        for ( scell_count = RRC_NULL ; (scell_count < (p_uecc_ue_context->
                                p_scell_config->scell_add_mod_list.count - num_scells_delete) - 1) &&
                                (scell_count < (MAX_SCELL - 1)); scell_count++)
                        {
                            l3_memcpy_wrapper(&p_uecc_ue_context->p_scell_config->
                                    scell_add_mod_list.rrc_scell_to_add_mod[scell_count],
                                    &p_uecc_ue_context->p_scell_config->scell_add_mod_list.
                                    rrc_scell_to_add_mod[scell_count + 1],
                                    sizeof(rrc_scell_to_add_mod_t));

                        }
                        num_scells_delete++;
                        
                        break ;
                        
                    }
                }
            }

        }
    }

    p_uecc_ue_context->p_scell_config->scell_add_mod_list.count = (p_uecc_ue_context->
            p_scell_config->scell_add_mod_list.count - num_scells_delete);

    /*Bug_12506_fix_start*/
    if (RRC_NULL == p_uecc_ue_context->p_scell_config->scell_add_mod_list.count)
    {
	    if (p_uecc_ue_context->p_scell_config->bitmask &
			    RRM_SCELL_ADD_MOD_LIST_PRESENT)
	    {
		    p_uecc_ue_context->p_scell_config->bitmask ^=
			    RRM_SCELL_ADD_MOD_LIST_PRESENT;
	    }
    }
    /*Bug_12506_fix_stop*/

    memset_wrapper(&p_uecc_ue_context->p_scell_config->
            scell_add_mod_list.rrc_scell_to_add_mod[
            p_uecc_ue_context->p_scell_config->scell_add_mod_list.count],RRC_NULL,
            (num_scells_delete * sizeof(rrc_scell_to_add_mod_t)));

    cell_index_present = RRC_FALSE;

    /* Here count signifies the cell_index*/
    for (count = RRC_NULL; count < MAX_NUM_CELLS; count++)
    {
        if ( RRC_TRUE == p_uecc_ue_context->scells_operation_list[count].
                chk_cellid_exist ) 
        {
            if (( ADD_SCELL == p_uecc_ue_context->scells_operation_list[count].
                        operation_type ) || 
                    (MODIFY_SCELL == p_uecc_ue_context->scells_operation_list[count].
                            operation_type) || 
                     ((DELETE_SCELL == p_uecc_ue_context->scells_operation_list[count].operation_type) &&
                      (RRC_TRUE == p_uecc_ue_context->scells_operation_list[count].scell_to_add_after_deletion_flag)))
            {
                if( p_uecc_ue_context->p_scell_config->bitmask &
                        RRM_SCELL_ADD_MOD_LIST_PRESENT )
                {
                    /* cyclomatic_FIX start */
                    for (index = RRC_NULL; ((index < p_scell_config->scell_add_mod_list.count) &&
                                (index < MAX_SCELL)); index++)
                        /* cyclomatic_FIX stop */
                    {
                        if ( count == p_scell_config->scell_add_mod_list.
                                rrc_scell_to_add_mod[index].scellIndex )
                        {
                            /* cyclomatic_FIX start */
                            for (scell_count = RRC_NULL; ((scell_count < p_uecc_ue_context->
                                            p_scell_config->scell_add_mod_list.count) && 
                                        (index < MAX_SCELL)); scell_count++)
                                /* cyclomatic_FIX stop */
                            {
                                if ( count == p_uecc_ue_context->p_scell_config->scell_add_mod_list.
                                        rrc_scell_to_add_mod[scell_count].scellIndex )
                                {
                                    uecc_rrm_modify_scell_config(&p_scell_config->scell_add_mod_list.
                                            rrc_scell_to_add_mod[index],
                                            &p_uecc_ue_context->p_scell_config->scell_add_mod_list.
                                            rrc_scell_to_add_mod[scell_count],
                                            p_uecc_ue_context);

                                    cell_index_present = RRC_TRUE;
                                }
                            }

                            if ( RRC_FALSE == cell_index_present )
                            {
                                l3_memcpy_wrapper(&p_uecc_ue_context->p_scell_config->scell_add_mod_list.
                                        rrc_scell_to_add_mod[p_uecc_ue_context->p_scell_config->
                                        scell_add_mod_list.count++],
                                        &p_scell_config->scell_add_mod_list.rrc_scell_to_add_mod[index], 
                                        sizeof(rrc_scell_to_add_mod_t));

                            }
                            
                            cell_index_present = RRC_FALSE;
                            
                        }
                    }
                }
                else
                {
                    l3_memcpy_wrapper(p_uecc_ue_context->p_scell_config,
                            p_scell_config,sizeof(rrm_scell_config_t));
                }
            }
        }
    }


    if ( p_scell_config->bitmask & 
            RRM_SCELL_CONFIG_CA_LC_BANDWIDTH_DIST_INFO_PRESENT ) 
    {
        p_uecc_ue_context->p_scell_config->bitmask |= 
            RRM_SCELL_CONFIG_CA_LC_BANDWIDTH_DIST_INFO_PRESENT;

        l3_memcpy_wrapper(p_uecc_ue_context->p_scell_config->ca_lc_bandwidth_dist_info.
                band_width_distribution,
                p_scell_config->ca_lc_bandwidth_dist_info.band_width_distribution, 
                MAX_CELLS_PER_UE );
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return;
}

/****************************************************************************
* Function Name  : uecc_rrm_modify_scell_config 
* Inputs         : rrc_scell_to_add_mod_t  *p_rrm_scell_to_add_mod - pointer to
*                  scell configuration received in RRC_RRM_UE_HO_ADM_RESP ,
*                  rrc_scell_to_add_mod_t  *p_ue_ctx_scell_to_add_mod - 
*                  pointer to scell configuration in UE context, 
*                  uecc_ue_context_t*        - pointer to UE context
*                 
* Outputs        : None
* Returns        : None
* Description    : This action routine is called inorder to update original 
*                  scell configuration in UE context according to the 
*                  configuration recieved from RRM.
****************************************************************************/
void uecc_rrm_modify_scell_config (
        rrc_scell_to_add_mod_t  *p_rrm_scell_to_add_mod, /*src*/
        rrc_scell_to_add_mod_t  *p_ue_ctx_scell_to_add_mod, /*trg*/
        uecc_ue_context_t       *p_uecc_ue_context)
{
    rrc_radio_res_dedicated_scell_non_ul_config_t   *p_rrm_scell_non_ul_config = PNULL;
    rrc_radio_res_dedicated_scell_non_ul_config_t   *p_ue_ctx_scell_non_ul_config = PNULL;
    rrc_radio_res_dedicated_scell_ul_config_t       *p_rrm_scell_ul_config = PNULL;
    rrc_radio_res_dedicated_scell_ul_config_t       *p_ue_ctx_scell_ul_config = PNULL;

    RRC_ASSERT(PNULL != p_rrm_scell_to_add_mod);
    RRC_ASSERT(PNULL != p_ue_ctx_scell_to_add_mod);
    RRC_ASSERT(PNULL != p_uecc_ue_context);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    
    if ( (PNULL != p_rrm_scell_to_add_mod) && (PNULL != p_ue_ctx_scell_to_add_mod) )
    {
        if(p_rrm_scell_to_add_mod->bitmask &
                RRM_SCELL_ADD_MOD_CELL_INDEX_PRESENT)
        {
            p_ue_ctx_scell_to_add_mod->bitmask |=
                RRM_SCELL_ADD_MOD_CELL_INDEX_PRESENT;

            p_ue_ctx_scell_to_add_mod->cell_index =
                p_rrm_scell_to_add_mod->cell_index;
        }
        if(p_rrm_scell_to_add_mod->bitmask &
                RRM_SCELL_ADD_MOD_CELL_IDENTIFICATION_PRESENT)
        {
            p_ue_ctx_scell_to_add_mod->bitmask |=
                RRM_SCELL_ADD_MOD_CELL_IDENTIFICATION_PRESENT;
            l3_memcpy_wrapper(&p_ue_ctx_scell_to_add_mod->scell_Id,
                    &p_rrm_scell_to_add_mod->scell_Id,
                    sizeof(rrc_scell_Identification_t));
        }
        if(p_rrm_scell_to_add_mod->bitmask & 
                RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_COMMON_SCELL_PRESENT)
        {
             p_ue_ctx_scell_to_add_mod->bitmask |=
                 RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_COMMON_SCELL_PRESENT;
            uecc_rrm_update_common_scell_non_ul_config(
                    &p_rrm_scell_to_add_mod->radio_res_config_common_scell.
                    radio_res_common_scell_non_ul_config,&p_ue_ctx_scell_to_add_mod->
                    radio_res_config_common_scell.radio_res_common_scell_non_ul_config,
                    p_uecc_ue_context);
        }
        if ( p_rrm_scell_to_add_mod->bitmask & 
                RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_DEDICATED_SCELL_PRESENT ) 
        {
            p_ue_ctx_scell_to_add_mod->bitmask |=
                 RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_DEDICATED_SCELL_PRESENT;
                                

            if ( p_rrm_scell_to_add_mod->radio_res_config_dedicated_scell.bitmask &
                    RRM_PHYSICAL_CONFIG_DEDICATED_SCELL_CONFIG_PRESENT)
            {
                p_ue_ctx_scell_to_add_mod->radio_res_config_dedicated_scell.bitmask |=
                     RRM_PHYSICAL_CONFIG_DEDICATED_SCELL_CONFIG_PRESENT;

                if ( p_rrm_scell_to_add_mod->radio_res_config_dedicated_scell.
                      physical_config_dedicated_scell.bitmask & 
                        RRM_RADIO_RES_CONFIG_DEDICATED_SCELL_NON_UL_CONFIG_PRESENT)
                {
                    p_ue_ctx_scell_to_add_mod->radio_res_config_dedicated_scell.
                      physical_config_dedicated_scell.bitmask |=
                      RRM_RADIO_RES_CONFIG_DEDICATED_SCELL_NON_UL_CONFIG_PRESENT;

                    p_rrm_scell_non_ul_config = &p_rrm_scell_to_add_mod->
                        radio_res_config_dedicated_scell.physical_config_dedicated_scell.
                        radio_res_dedicated_scell_non_ul_config;

                    p_ue_ctx_scell_non_ul_config = &p_ue_ctx_scell_to_add_mod->
                        radio_res_config_dedicated_scell.physical_config_dedicated_scell.
                        radio_res_dedicated_scell_non_ul_config;

                    uecc_rrm_update_dedicated_scell_non_ul_config (
                            p_rrm_scell_non_ul_config,
                            p_ue_ctx_scell_non_ul_config,
                            p_uecc_ue_context);
                }

                if ( p_rrm_scell_to_add_mod->radio_res_config_dedicated_scell.
                        physical_config_dedicated_scell.bitmask &
                          RRM_RADIO_RES_CONFIG_DEDICATED_SCELL_UL_CONFIG_PRESENT)
                {
                    p_ue_ctx_scell_to_add_mod->radio_res_config_dedicated_scell.
                       physical_config_dedicated_scell.bitmask |=
                       RRM_RADIO_RES_CONFIG_DEDICATED_SCELL_UL_CONFIG_PRESENT;

                    p_rrm_scell_ul_config = &p_rrm_scell_to_add_mod->
                        radio_res_config_dedicated_scell.physical_config_dedicated_scell.
                        radio_res_dedicated_scell_ul_config;

                    p_ue_ctx_scell_ul_config = &p_ue_ctx_scell_to_add_mod->
                        radio_res_config_dedicated_scell.physical_config_dedicated_scell.
                         radio_res_dedicated_scell_ul_config;

                    uecc_rrm_update_dedicated_scell_ul_config ( p_rrm_scell_ul_config,
                            p_ue_ctx_scell_ul_config,
                            p_uecc_ue_context);
                }
            }
        }
        if(p_rrm_scell_to_add_mod->bitmask & 
                RRM_SCELL_ADD_MOD_MAC_SCELL_CONFIG_EXTENSION_SCELL_PRESENT)
        {
            p_ue_ctx_scell_to_add_mod->bitmask |=
                RRM_SCELL_ADD_MOD_MAC_SCELL_CONFIG_EXTENSION_SCELL_PRESENT;
            uecc_rrm_update_mac_scell_config_extension(
                    &p_rrm_scell_to_add_mod->mac_main_config_extensions,
                    &p_ue_ctx_scell_to_add_mod->mac_main_config_extensions,
                    p_uecc_ue_context);
        }
        if(p_rrm_scell_to_add_mod->bitmask &
                RRM_SCELL_ADD_MOD_MIMO_CAPABILITY_DL_R10_SCELL_PRESENT)
        {
            p_ue_ctx_scell_to_add_mod->bitmask |=
                RRM_SCELL_ADD_MOD_MIMO_CAPABILITY_DL_R10_SCELL_PRESENT;
            p_ue_ctx_scell_to_add_mod->supported_mimo_capability_dl_r10 = 
                p_rrm_scell_to_add_mod->supported_mimo_capability_dl_r10;
        }
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);

}

/****************************************************************************
 * Function Name  : uecc_rrm_update_dedicated_scell_non_ul_config 
 * Inputs         : rrc_radio_res_dedicated_scell_non_ul_config_t
 *                                               *p_rrm_scell_non_ul_config
 *                  - pointer to rrc_radio_res_dedicated_scell_non_ul_config_t 
 *                  received in scell config in RRC_RRM_UE_HO_ADM_RESP ,
 *                  rrc_radio_res_dedicated_scell_non_ul_config_t
 *                                               *p_ue_ctx_scell_non_ul_config
 *                  - pointer to rrc_radio_res_dedicated_scell_non_ul_config_t
 *                  in scell config in UE context ,
 *                  uecc_ue_context_t*        - pointer to UE context
 *                 
 * Outputs        : None
 * Returns        : None
 * Description    : This action routine is called inorder to update original 
 *                  scell configuration in UE context according to the 
 *                  configuration recieved from RRM.
 ****************************************************************************/
void uecc_rrm_update_dedicated_scell_non_ul_config (
        rrc_radio_res_dedicated_scell_non_ul_config_t   *p_rrm_scell_non_ul_config,     /*src*/
        rrc_radio_res_dedicated_scell_non_ul_config_t   *p_ue_ctx_scell_non_ul_config,  /*dest*/
        uecc_ue_context_t                               *p_uecc_ue_context)
{
    RRC_ASSERT ( PNULL != p_uecc_ue_context);
    RRC_ASSERT ( PNULL != p_rrm_scell_non_ul_config );
    RRC_ASSERT ( PNULL != p_ue_ctx_scell_non_ul_config );

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,p_uecc_ue_context->p_gb_context->facility_name,
                          RRC_DETAILEDALL,"Unused variable"
                          "p_uecc_ue_context=%p",p_uecc_ue_context);/*SPR 17777+-*/

    if ( p_rrm_scell_non_ul_config->bitmask & 
            RRM_SCELL_DEDICATED_NON_UL_ANTENNA_INFO_PRESENT )
    {
        p_ue_ctx_scell_non_ul_config->bitmask |= 
            RRM_SCELL_DEDICATED_NON_UL_ANTENNA_INFO_PRESENT;

        p_ue_ctx_scell_non_ul_config->antenna_info_dedicated_r10.transmission_mode = 
            p_rrm_scell_non_ul_config->antenna_info_dedicated_r10.transmission_mode;

        if ( p_rrm_scell_non_ul_config->antenna_info_dedicated_r10.bitmask & 
                RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT )
        {
            p_ue_ctx_scell_non_ul_config->antenna_info_dedicated_r10.bitmask |=
                RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT;

            p_ue_ctx_scell_non_ul_config->antenna_info_dedicated_r10.
                codebook_subset_restriction_r10.num_bits = 
                p_rrm_scell_non_ul_config->antenna_info_dedicated_r10.
                codebook_subset_restriction_r10.num_bits;

            l3_memcpy_wrapper(&p_ue_ctx_scell_non_ul_config->antenna_info_dedicated_r10.
                    codebook_subset_restriction_r10.value, p_rrm_scell_non_ul_config->
                    antenna_info_dedicated_r10.codebook_subset_restriction_r10.value,
                    ((p_ue_ctx_scell_non_ul_config->antenna_info_dedicated_r10.
                      codebook_subset_restriction_r10.num_bits + RRC_OCTET_WINDOW) / 
                     RRC_OCTET_SIZE));
        }

        if ( p_rrm_scell_non_ul_config->antenna_info_dedicated_r10.
                ue_transmit_antenna_selection.bitmask &
                RRC_PHY_UE_TRANSMIT_ANTENNA_SELECTION_TYPE_PRESENT)
        {
            p_ue_ctx_scell_non_ul_config->antenna_info_dedicated_r10.
                ue_transmit_antenna_selection.bitmask |= 
                RRC_PHY_UE_TRANSMIT_ANTENNA_SELECTION_TYPE_PRESENT;

            p_ue_ctx_scell_non_ul_config->antenna_info_dedicated_r10.
                ue_transmit_antenna_selection.request_type = RRC_TRUE;

            p_ue_ctx_scell_non_ul_config->antenna_info_dedicated_r10.
                ue_transmit_antenna_selection.ue_transmit_antenna_selection_type =
                p_rrm_scell_non_ul_config->antenna_info_dedicated_r10.
                ue_transmit_antenna_selection.ue_transmit_antenna_selection_type;
        }
        else
        {
            p_ue_ctx_scell_non_ul_config->antenna_info_dedicated_r10.
                ue_transmit_antenna_selection.request_type = RRC_FALSE;
        }
    }

    if ( p_rrm_scell_non_ul_config->bitmask & 
            RRM_SCELL_DEDICATED_NON_UL_PDSCH_CONFIG_DEDICATED_PRESENT )
    {
        p_ue_ctx_scell_non_ul_config->bitmask |= 
            RRM_SCELL_DEDICATED_NON_UL_PDSCH_CONFIG_DEDICATED_PRESENT;

        p_ue_ctx_scell_non_ul_config->pdsch_configuration_dedicated.p_a = 
            p_rrm_scell_non_ul_config->pdsch_configuration_dedicated.p_a;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/****************************************************************************
 * Function Name  : uecc_rrm_update_dedicated_scell_ul_config 
 * Inputs         : rrc_radio_res_dedicated_scell_ul_config_t
 *                                               *p_rrm_scell_ul_config
 *                  - pointer to rrc_radio_res_dedicated_scell_ul_config_t 
 *                  received in scell config in RRC_RRM_UE_HO_ADM_RESP ,
 *                  rrc_radio_res_dedicated_scell_ul_config_t
 *                                               *p_ue_ctx_scell_ul_config
 *                  - pointer to rrc_radio_res_dedicated_scell_ul_config_t
 *                  in scell config in UE context ,
 *                  uecc_ue_context_t*        - pointer to UE context
 *                 
 * Outputs        : None
 * Returns        : None
 * Description    : This action routine is called inorder to update original 
 *                  scell configuration in UE context according to the 
 *                  configuration recieved from RRM.
 ****************************************************************************/
void uecc_rrm_update_dedicated_scell_ul_config (
        rrc_radio_res_dedicated_scell_ul_config_t   *p_rrm_scell_ul_config,     /*src*/
        rrc_radio_res_dedicated_scell_ul_config_t   *p_ue_ctx_scell_ul_config,  /*dest*/
        uecc_ue_context_t                           *p_uecc_ue_context
        )
{
    RRC_ASSERT( PNULL != p_rrm_scell_ul_config );
    RRC_ASSERT( PNULL != p_ue_ctx_scell_ul_config );
    RRC_ASSERT( PNULL != p_uecc_ue_context );

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    if ( p_rrm_scell_ul_config->bitmask & 
            RRM_SCELL_DEDICATED_UL_CQI_CONFIG_SCELL_PRESENT )
    {
        p_ue_ctx_scell_ul_config->bitmask |= 
            RRM_SCELL_DEDICATED_UL_CQI_CONFIG_SCELL_PRESENT;

        if ( p_rrm_scell_ul_config->cqi_report_config_scell.bitmask &
                RRM_SCELL_CQI_REPORT_CONFIG_APERIODIC_PRESENT )
        {
            p_ue_ctx_scell_ul_config->cqi_report_config_scell.bitmask |=
                RRM_SCELL_CQI_REPORT_CONFIG_APERIODIC_PRESENT;

            p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                cqi_reporting_mode_aperiodic = p_rrm_scell_ul_config->
                cqi_report_config_scell.cqi_reporting_mode_aperiodic;
        }

        p_ue_ctx_scell_ul_config->cqi_report_config_scell.
            nomPDSCH_RS_EPRE_Offset = p_rrm_scell_ul_config->
            cqi_report_config_scell.nomPDSCH_RS_EPRE_Offset;

        if ( p_rrm_scell_ul_config->cqi_report_config_scell.bitmask &
                RRM_SCELL_CQI_REPORT_CONFIG_PERIODIC_PRESENT )
        {
            p_ue_ctx_scell_ul_config->cqi_report_config_scell.bitmask |=
                RRM_SCELL_CQI_REPORT_CONFIG_PERIODIC_PRESENT;

            if ( p_rrm_scell_ul_config->cqi_report_config_scell.
                    cqi_report_periodic_r10.bitmask & 
                    RRC_PHY_CQI_REPORT_PERIODIC_R10SETUP_PRESENT )
            {
                p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                    cqi_report_periodic_r10.bitmask |= 
                    RRC_PHY_CQI_REPORT_PERIODIC_R10SETUP_PRESENT;

                p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                    cqi_report_periodic_r10.request_type = RRC_TRUE;

                p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                    cqi_report_periodic_r10.setup.cqi_pucch_resource_index =
                    p_rrm_scell_ul_config->cqi_report_config_scell.
                    cqi_report_periodic_r10.setup.cqi_pucch_resource_index;

                if ( p_rrm_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.bitmask &
                        RRC_CQI_REPORT_PERIODIC_R10_SETUP_PUCCH_REPORT_INDEX_P1_PRESENT )
                {
                    p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.bitmask |=
                        RRC_CQI_REPORT_PERIODIC_R10_SETUP_PUCCH_REPORT_INDEX_P1_PRESENT;

                    p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.cqi_pucch_resource_index_p1 =
                        p_rrm_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.cqi_pucch_resource_index_p1;
                }

                p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                    cqi_report_periodic_r10.setup.cqi_pmi_config_index = 
                    p_rrm_scell_ul_config->cqi_report_config_scell.
                    cqi_report_periodic_r10.setup.cqi_pmi_config_index;

                uecc_rrm_update_cqi_format_ind_periodic (&p_rrm_scell_ul_config->
                        cqi_report_config_scell.cqi_report_periodic_r10.
                        setup.cqi_format_ind_periodic ,
                        &p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.cqi_format_ind_periodic,
                        p_uecc_ue_context);

                if ( p_rrm_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.bitmask &
                        RRC_CQI_REPORT_PERIODIC_R10_SETUP_RI_CONFIG_INDEX_PRESENT )
                {
                    p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.bitmask |=
                        RRC_CQI_REPORT_PERIODIC_R10_SETUP_RI_CONFIG_INDEX_PRESENT;

                    p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.ri_config_index = 
                        p_rrm_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.ri_config_index;
                }

                p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                    cqi_report_periodic_r10.setup.simultaneous_ack_nack_cqi = 
                    p_rrm_scell_ul_config->cqi_report_config_scell.
                    cqi_report_periodic_r10.setup.simultaneous_ack_nack_cqi;

                if ( p_rrm_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.bitmask &
                        RRC_CQI_REPORT_PERIODIC_R10_SETUP_CQI_MASK_PRESENT )
                {
                    p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.bitmask |=
                        RRC_CQI_REPORT_PERIODIC_R10_SETUP_CQI_MASK_PRESENT;

                    p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.cqi_mask_r9 = 
                        p_rrm_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.cqi_mask_r9;
                }

                if ( p_rrm_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.bitmask & 
                        RRC_CQI_REPORT_PERIODIC_R10_SETUP_CSI_CONFIG_INDEX_PRESENT) 
                {
                    p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                        cqi_report_periodic_r10.setup.bitmask |= 
                        RRC_CQI_REPORT_PERIODIC_R10_SETUP_CSI_CONFIG_INDEX_PRESENT;

                    if (p_rrm_scell_ul_config->cqi_report_config_scell.
                            cqi_report_periodic_r10.setup.csi_config_index.bitmask &
                            RRC_PHY_CQI_REPORT_PERIODIC_R10_SETUP_CSI_CONFIG_INDEX_SETUP_PRESENT )
                    {
                        p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                            cqi_report_periodic_r10.setup.csi_config_index.bitmask |=
                            RRC_PHY_CQI_REPORT_PERIODIC_R10_SETUP_CSI_CONFIG_INDEX_SETUP_PRESENT;

                        p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                            cqi_report_periodic_r10.setup.csi_config_index.
                            request_type = RRC_TRUE;

                        p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                            cqi_report_periodic_r10.setup.csi_config_index.
                            setup.cqi_pmi_config_index2 = p_rrm_scell_ul_config->
                            cqi_report_config_scell.cqi_report_periodic_r10.
                            setup.csi_config_index.setup.cqi_pmi_config_index2;

                        if ( p_rrm_scell_ul_config->cqi_report_config_scell.
                                cqi_report_periodic_r10.setup.csi_config_index.
                                setup.bitmask & 
                                RRC_PHY_CQI_PERIODIC_R10_SETUP_CSI_RI_CONFIG_INDEX2_PRESENT ) 
                        {
                            p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                                cqi_report_periodic_r10.setup.csi_config_index.
                                setup.bitmask |= 
                                RRC_PHY_CQI_PERIODIC_R10_SETUP_CSI_RI_CONFIG_INDEX2_PRESENT;

                            p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                                cqi_report_periodic_r10.setup.csi_config_index.
                                setup.ri_config_index2 = p_rrm_scell_ul_config->
                                cqi_report_config_scell.cqi_report_periodic_r10.setup.
                                csi_config_index.setup.ri_config_index2;                                        
                        }
                    }
                    else
                    {
                        p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                            cqi_report_periodic_r10.setup.csi_config_index.
                            request_type = RRC_FALSE;
                    }
                }
            }
            else
            {
                p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                    cqi_report_periodic_r10.request_type = RRC_FALSE;
            }
        }

        if ( p_rrm_scell_ul_config->cqi_report_config_scell.bitmask &
                RRM_SCELL_CQI_REPORT_CONFIG_PMI_RI_REPORT_PRESENT )
        {
            p_ue_ctx_scell_ul_config->cqi_report_config_scell.bitmask |=
                RRM_SCELL_CQI_REPORT_CONFIG_PMI_RI_REPORT_PRESENT;

            p_ue_ctx_scell_ul_config->cqi_report_config_scell.
                cqi_report_pmi_ri_report_r10 = p_rrm_scell_ul_config->
                cqi_report_config_scell.cqi_report_pmi_ri_report_r10;
        }
    }
    
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/****************************************************************************
 * Function Name  : uecc_rrm_update_cqi_format_ind_periodic 
 * Inputs         : rrc_phy_cqi_format_ind_periodic_r10_t 
 *                                         *p_rrm_cqi_format_ind_periodic
 *                  - pointer to rrc_phy_cqi_format_ind_periodic_r10_t 
 *                  received in scell config in RRC_RRM_UE_HO_ADM_RESP ,
 *                  rrc_phy_cqi_format_ind_periodic_r10_t
 *                                         *p_ue_ctx_cqi_format_ind_periodic
 *                  - pointer to rrc_phy_cqi_format_ind_periodic_r10_t
 *                  in scell config in UE context ,
 *                  uecc_ue_context_t*        - pointer to UE context
 *                 
 * Outputs        : None
 * Returns        : None
 * Description    : This action routine is called inorder to update original 
 *                  scell configuration in UE context according to the 
 *                  configuration recieved from RRM.
 ****************************************************************************/
void uecc_rrm_update_cqi_format_ind_periodic (
        rrc_phy_cqi_format_ind_periodic_r10_t   *p_rrm_cqi_format_ind_periodic, /*src*/
        rrc_phy_cqi_format_ind_periodic_r10_t   *p_ue_ctx_cqi_format_ind_periodic, /*dest*/
        uecc_ue_context_t                       *p_uecc_ue_context)
{
    RRC_ASSERT( PNULL != p_rrm_cqi_format_ind_periodic );
    RRC_ASSERT( PNULL != p_ue_ctx_cqi_format_ind_periodic );
    RRC_ASSERT( PNULL != p_uecc_ue_context );

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,p_uecc_ue_context->p_gb_context->facility_name,
                          RRC_DETAILEDALL,"Unused variable"
                          "p_uecc_ue_context=%p",p_uecc_ue_context);/*SPR 17777+-*/
    if ( p_rrm_cqi_format_ind_periodic->bitmask &
            RRC_PHY_CQI_FORMAT_IND_PERIODIC_WIDEBAND_CQI_PRESENT )
    {
        if ( p_rrm_cqi_format_ind_periodic->cqi_format_ind_wideband.bitmask &
                RRC_PHY_CQI_FORMAT_IND_PERIODIC_WIDEBAND_CQI_REPORT_MODE_PRESENT )
        {
            p_ue_ctx_cqi_format_ind_periodic->cqi_format_ind_wideband.bitmask |=
                RRC_PHY_CQI_FORMAT_IND_PERIODIC_WIDEBAND_CQI_REPORT_MODE_PRESENT;

            p_ue_ctx_cqi_format_ind_periodic->cqi_format_ind_wideband.csi_report_mode =
                p_rrm_cqi_format_ind_periodic->cqi_format_ind_wideband.csi_report_mode;
        }
    }
    else if ( p_rrm_cqi_format_ind_periodic->bitmask &
            RRC_PHY_CQI_FORMAT_IND_PERIODIC_SUBBAND_CQI_PRESENT )
    {
        p_ue_ctx_cqi_format_ind_periodic->cqi_format_ind_subband.k = 
            p_rrm_cqi_format_ind_periodic->cqi_format_ind_subband.k;

        p_ue_ctx_cqi_format_ind_periodic->cqi_format_ind_subband.periodicy_factor = 
            p_rrm_cqi_format_ind_periodic->cqi_format_ind_subband.periodicy_factor;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/****************************************************************************
 * Function Name  : uecc_rrm_update_common_scell_non_ul_config 
 * Inputs         : rrc_radio_res_common_scell_non_ul_config_t 
 *                                         *p_rrm_common_scell_non_ul_config
 *                  - pointer to rrc_phy_cqi_format_ind_periodic_r10_t 
 *                  rrc_radio_res_common_scell_non_ul_config_t
 *                                         *p_ue_ctx_common_scell_non_ul_config
 *                  - pointer to rrc_radio_res_common_scell_non_ul_config_t
 *                  in scell config in UE context ,
 *                  uecc_ue_context_t*        - pointer to UE context
 *                 
 * Outputs        : None
 * Returns        : None
 * Description    : This action routine is called inorder to update original 
 *                  scell configuration in UE context according to the 
 *                  configuration recieved from RRM.
 ****************************************************************************/
static void uecc_rrm_update_common_scell_non_ul_config (
        rrc_radio_res_common_scell_non_ul_config_t *p_rrm_common_scell_non_ul_config,
        rrc_radio_res_common_scell_non_ul_config_t *p_ue_ctx_common_scell_non_ul_config,
        uecc_ue_context_t                          *p_uecc_ue_context
        )
{
    RRC_ASSERT( PNULL != p_rrm_common_scell_non_ul_config );
    RRC_ASSERT( PNULL != p_ue_ctx_common_scell_non_ul_config );
    RRC_ASSERT( PNULL != p_uecc_ue_context );

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,p_uecc_ue_context->p_gb_context->facility_name,
                          RRC_DETAILEDALL,"Unused variable"
                          "p_uecc_ue_context=%p",p_uecc_ue_context);/*SPR 17777+-*/
    p_ue_ctx_common_scell_non_ul_config->dl_bandwidth = 
        p_rrm_common_scell_non_ul_config->dl_bandwidth;
    p_ue_ctx_common_scell_non_ul_config->antenna_port_count = 
        p_rrm_common_scell_non_ul_config->antenna_port_count;

    l3_memcpy_wrapper(&p_ue_ctx_common_scell_non_ul_config->phich_config,
            &p_rrm_common_scell_non_ul_config->phich_config,
            sizeof(phich_config_t));

    l3_memcpy_wrapper(&p_ue_ctx_common_scell_non_ul_config->pdsch_config_common,
            &p_rrm_common_scell_non_ul_config->pdsch_config_common,
            sizeof(pdsch_config_common_t));

    if(p_rrm_common_scell_non_ul_config->bitmask & 
            RRM_SCELL_COMMOM_NON_UL_TDD_CONFIG_PRESENT)
    {
        p_ue_ctx_common_scell_non_ul_config->bitmask |=
            RRM_SCELL_COMMOM_NON_UL_TDD_CONFIG_PRESENT;
        l3_memcpy_wrapper(&p_ue_ctx_common_scell_non_ul_config->tdd_config,
                &p_rrm_common_scell_non_ul_config->tdd_config,
                sizeof(tdd_config_t));
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/****************************************************************************
 * Function Name  : uecc_rrm_update_common_scell_non_ul_config 
 * Inputs         : rrc_scell_mac_main_config_extensions_t 
 *                                         *p_rrm_scell_mac_main_config_extension
 *                  - pointer to rrc_scell_mac_main_config_extensions_t 
 *                  rrc_scell_mac_main_config_extensions_t
 *                                         *p_ue_ctx_scell_mac_main_config_extension
 *                  - pointer to rrc_scell_mac_main_config_extensions_t
 *                  in scell config in UE context ,
 *                  uecc_ue_context_t*        - pointer to UE context
 *                 
 * Outputs        : None
 * Returns        : None
 * Description    : This action routine is called inorder to update original 
 *                  scell configuration in UE context according to the 
 *                  configuration recieved from RRM.
 ****************************************************************************/
static void uecc_rrm_update_mac_scell_config_extension(
        rrc_scell_mac_main_config_extensions_t *p_rrm_scell_mac_main_config_extension,
        rrc_scell_mac_main_config_extensions_t *p_ue_ctx_scell_mac_main_config_extension,
        uecc_ue_context_t                      *p_uecc_ue_context
        )
{

    RRC_ASSERT( PNULL != p_rrm_scell_mac_main_config_extension );
    RRC_ASSERT( PNULL != p_ue_ctx_scell_mac_main_config_extension );
    RRC_ASSERT( PNULL != p_uecc_ue_context );

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,p_uecc_ue_context->p_gb_context->facility_name,
                          RRC_DETAILEDALL,"Unused variable"
                          "p_uecc_ue_context=%p",p_uecc_ue_context);/*SPR 17777+-*/
    if(p_rrm_scell_mac_main_config_extension->bitmask &
            RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_DL_NUM_HARQ_PROC_PRESENT)
    {
        p_ue_ctx_scell_mac_main_config_extension->bitmask |=
            RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_DL_NUM_HARQ_PROC_PRESENT;
        p_ue_ctx_scell_mac_main_config_extension->dl_num_harq_process = 
            p_rrm_scell_mac_main_config_extension->dl_num_harq_process;
    }
    if(p_rrm_scell_mac_main_config_extension->bitmask &
            RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_DL_INIT_MCS_PRESENT)
    {
        p_ue_ctx_scell_mac_main_config_extension->bitmask |=
            RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_DL_INIT_MCS_PRESENT;
        p_ue_ctx_scell_mac_main_config_extension->dl_i_mcs = 
            p_rrm_scell_mac_main_config_extension->dl_i_mcs;
    }
    if(p_rrm_scell_mac_main_config_extension->bitmask &
            RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_NUM_OF_LAYER_INFO_PRESENT)
    {
        p_ue_ctx_scell_mac_main_config_extension->bitmask |=
            RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_NUM_OF_LAYER_INFO_PRESENT;
        p_ue_ctx_scell_mac_main_config_extension->num_of_layer = 
            p_rrm_scell_mac_main_config_extension->num_of_layer;
    }
    if(p_rrm_scell_mac_main_config_extension->bitmask &
            RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_CODE_BOOK_INDEX_INFO_PRESENT)
    {
        p_ue_ctx_scell_mac_main_config_extension->bitmask |=
            RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_CODE_BOOK_INDEX_INFO_PRESENT;
        p_ue_ctx_scell_mac_main_config_extension->code_book_index =
            p_rrm_scell_mac_main_config_extension->code_book_index;
    }
    if(p_rrm_scell_mac_main_config_extension->bitmask &
            RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_USER_LOCATION_TYPE_PRESENT)
    {
        p_ue_ctx_scell_mac_main_config_extension->bitmask |=
            RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_USER_LOCATION_TYPE_PRESENT;
        p_ue_ctx_scell_mac_main_config_extension->user_location_type = 
            p_rrm_scell_mac_main_config_extension->user_location_type;

    }
    if(p_rrm_scell_mac_main_config_extension->bitmask &
            RRM_MAC_MAIN_CONFIG_EXT_RF_PARAMS_PRESENT)
    {
        p_ue_ctx_scell_mac_main_config_extension->bitmask |=
            RRM_MAC_MAIN_CONFIG_EXT_RF_PARAMS_PRESENT;
        p_ue_ctx_scell_mac_main_config_extension->rf_params_half_duplex_fdd = 
            p_rrm_scell_mac_main_config_extension->rf_params_half_duplex_fdd;
    }

    /* BUG 11948 Fix Start */
    if ( p_rrm_scell_mac_main_config_extension->bitmask &
	    RRM_MAC_SCELL_ACTIVATE_STATUS_PRESENT ) 	
    {
	p_ue_ctx_scell_mac_main_config_extension->bitmask |=
	    RRM_MAC_SCELL_ACTIVATE_STATUS_PRESENT;
	p_ue_ctx_scell_mac_main_config_extension->scell_activate_status =
	    p_rrm_scell_mac_main_config_extension->scell_activate_status;
    }
    /* BUG 11948 Fix Stop */
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}

/* SPR 13261 Fix Start */

/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_curr_meas_id_to_add_mod_list
*   INPUT        : uecc_gb_context_t           *p_uecc_gb_context,
*                  curr_meas_id_to_add_mod_list_t*  p_rrm_meas_id_to_add_mod_list,
*                  MeasIdToAddModList*         p_meas_id_to_add_mod_list
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds MeasIdToAddModList in
*       MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_curr_meas_id_to_add_mod_list(
    uecc_gb_context_t           *p_uecc_gb_context,/* SPR 15905 Fix Start */
    curr_meas_id_to_add_mod_list_t*  p_rrm_meas_id_to_add_mod_list,/* SPR 15905 Fix Stop */
    MeasIdToAddModList*         p_meas_id_to_add_mod_list
)
{
    rrc_return_et   result = RRC_SUCCESS;
    MeasIdToAddMod* p_meas_id_to_add_mod = PNULL;
    OSRTDListNode*  p_node = PNULL;
    U8 i=0;

    RRC_ASSERT(PNULL != p_rrm_meas_id_to_add_mod_list);
    RRC_ASSERT(PNULL != p_meas_id_to_add_mod_list);
    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);
    RRC_UECC_TRACE(p_uecc_gb_context->context_index, p_uecc_gb_context->facility_name, 
                       RRC_DETAILEDALL, "Unused variable"
                       "p_uecc_gb_context=%p",p_uecc_gb_context);/*SPR 17777 +-*/
    p_rrm_meas_id_to_add_mod_list->count = (U8)p_meas_id_to_add_mod_list->count;
    p_node = (p_meas_id_to_add_mod_list->head);

    for (i=0; i < p_rrm_meas_id_to_add_mod_list->count; i++)
    {
        RRC_ASSERT(PNULL != p_node);
        RRC_ASSERT(PNULL != p_node->data);

        p_meas_id_to_add_mod = p_node->data;
	
        p_rrm_meas_id_to_add_mod_list->meas_id_to_add_mod
            [p_meas_id_to_add_mod->measId - 1].meas_id=
                                p_meas_id_to_add_mod->measId ;
        p_rrm_meas_id_to_add_mod_list->meas_id_to_add_mod
            [p_meas_id_to_add_mod->measId - 1].meas_object_id=
                                p_meas_id_to_add_mod->measObjectId ;
        p_rrm_meas_id_to_add_mod_list->meas_id_to_add_mod
            [p_meas_id_to_add_mod->measId - 1].report_config_id=
                                p_meas_id_to_add_mod->reportConfigId ;
        
	p_node = p_node->next;
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
    return result;
}


/* SPR 13261 Fix Stop */


/* spr_13304_fix_2_start */
                
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_meas_object_geran
*   INPUT        : meas_object_utra_t*         p_rrm_meas_object_utra,
*                  MeasObjectUTRA*             p_meas_object_utra,
*                  uecc_ue_context_t*          p_uecc_ue_context
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds meas_object_geran from MeasObjectGERAN in 
        MeasConfig structure
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et uecc_rrm_build_meas_object_geran(
    meas_object_geran_t *        p_rrm_meas_object_geran,
    MeasObjectGERAN     *        p_meas_object_geran,
    uecc_ue_context_t   *        p_uecc_ue_context)
{   
    U8 count = RRC_NULL;
    rrc_return_et result = RRC_SUCCESS;
    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);
    RRC_UECC_TRACE(p_uecc_ue_context->p_gb_context->context_index,p_uecc_ue_context->p_gb_context->facility_name,
                             RRC_DETAILEDALL,"Unused variable"
                             "p_uecc_ue_context=%p",p_uecc_ue_context);/*SPR17777 +-*/
    p_rrm_meas_object_geran->carrier_freqs.starting_arfcn = p_meas_object_geran->
        carrierFreqs.startingARFCN;

    p_rrm_meas_object_geran->carrier_freqs.band_indicator = p_meas_object_geran->
        carrierFreqs.bandIndicator;

    switch(p_meas_object_geran->carrierFreqs.followingARFCNs.t)
    {
        case T_CarrierFreqsGERAN_followingARFCNs_explicitListOfARFCNs :
            {
                if ( PNULL != p_meas_object_geran->carrierFreqs.
                        followingARFCNs.u.explicitListOfARFCNs )
                {
                    p_rrm_meas_object_geran->carrier_freqs.following_arfcns.presence_bitmask |=
                        GERAN_EXPL_LIST_OF_ARFCNS_PRESENCE_FLAG;

                    p_rrm_meas_object_geran->carrier_freqs.following_arfcns.
                        explicit_list_of_arfcns.count = p_meas_object_geran->carrierFreqs.
                        followingARFCNs.u.explicitListOfARFCNs->n;

                    for ( count = RRC_NULL; ((count < p_meas_object_geran->carrierFreqs.
                                    followingARFCNs.u.explicitListOfARFCNs->n) && 
                                (count < MAX_EXPL_ARFCNS )); count++ )
                    {
                        p_rrm_meas_object_geran->carrier_freqs.following_arfcns.
                            explicit_list_of_arfcns.data[count] = p_meas_object_geran->
                            carrierFreqs.followingARFCNs.u.explicitListOfARFCNs->
                            elem[count];
                    }
                }
            }
            break ;

        case T_CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs :
            {
                if ( PNULL != p_meas_object_geran->carrierFreqs.followingARFCNs.u.
                        equallySpacedARFCNs )
                {
                    p_rrm_meas_object_geran->carrier_freqs.following_arfcns.
                        presence_bitmask |=
                            GERAN_EQ_SPACED_ARFCNS_PRESENCE_FLAG;

                    p_rrm_meas_object_geran->carrier_freqs.following_arfcns.
                        equally_spaced_arfcns.arfcn_spacing = p_meas_object_geran->
                        carrierFreqs.followingARFCNs.u.equallySpacedARFCNs->
                        arfcn_Spacing;

                    p_rrm_meas_object_geran->carrier_freqs.following_arfcns.
                        equally_spaced_arfcns.num_of_following_arfcns = p_meas_object_geran->
                        carrierFreqs.followingARFCNs.u.equallySpacedARFCNs->
                        numberOfFollowingARFCNs;
                }
            }
            break;
        case T_CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs :
            {
                if ( PNULL != p_meas_object_geran->carrierFreqs.followingARFCNs.u.
                        variableBitMapOfARFCNs )
                {
                    p_rrm_meas_object_geran->carrier_freqs.following_arfcns.
                        presence_bitmask |=
                            GERAN_VAR_BITMAP_ARFCNS_PRESENCE_FLAG;

                    p_rrm_meas_object_geran->carrier_freqs.following_arfcns.
                        var_bitmap_of_arfcns.count = p_meas_object_geran->
                        carrierFreqs.followingARFCNs.u.variableBitMapOfARFCNs->
                        numocts;

                    for ( count = RRC_NULL ; ((count < p_rrm_meas_object_geran->
                            carrier_freqs.following_arfcns.var_bitmap_of_arfcns.count) &&
                                ( count < MAX_VAR_BITMAP_OF_ARFCNS )); count++ )
                    {
                        p_rrm_meas_object_geran->carrier_freqs.following_arfcns.
                            var_bitmap_of_arfcns.data[count] = p_meas_object_geran->
                            carrierFreqs.followingARFCNs.u.variableBitMapOfARFCNs->
                            data[count];
                    }
                }
            }
            break;
        default : 
            {
                RRC_TRACE(RRC_WARNING ,"Invalid value of "
                        "CarrierFreqsGERAN_followingARFCNs.t [%d] received ",
                        p_meas_object_geran->carrierFreqs.followingARFCNs.t);
            }
    }

    p_rrm_meas_object_geran->offset_freq = p_meas_object_geran->offsetFreq;

    if ( p_meas_object_geran->m.ncc_PermittedPresent )
    {
        p_rrm_meas_object_geran->ncc_Permitted = p_meas_object_geran->ncc_Permitted.data[0];
    }

    if ( p_meas_object_geran->m.cellForWhichToReportCGIPresent )
    {
        p_rrm_meas_object_geran->bitmask |= 
            MEAS_OBJECT_GERAN_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT;

        p_rrm_meas_object_geran->cell_for_which_to_report_cgi.base_station_colour_code = 
            p_meas_object_geran->cellForWhichToReportCGI.baseStationColourCode.data[0];

        p_rrm_meas_object_geran->cell_for_which_to_report_cgi.network_colour_code = 
            p_meas_object_geran->cellForWhichToReportCGI.networkColourCode.data[0];
    }

    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
    return result;
}
/* spr_13304_fix_2_stop */



#ifdef ENDC_ENABLED
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_ue_nr_capability
*   INPUT        : uecc_ue_context_t        *p_ue_context
*                  nr_radio_capability_info_t
*                                           *p_nr_radio_capability_info_t
*                  nr_rrc_UE_NR_Capability
*                                           *p_UE_NR_Capability
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds NR RAT capability.
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/
rrc_return_et
uecc_rrm_build_ue_nr_capability
(
    uecc_ue_context_t                *p_ue_context,
    nr_radio_capability_info_t       *p_nr_radio_capability_info,
    nr_rrc_UE_NR_Capability          *p_UE_NR_Capability
)       
{
    rrc_return_et       result              = RRC_SUCCESS;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_nr_radio_capability_info);
    RRC_ASSERT(PNULL != p_UE_NR_Capability);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if ( p_UE_NR_Capability->m.measAndMobParametersPresent )
    {
        if ( p_UE_NR_Capability->measAndMobParameters.m.
            measAndMobParametersCommonPresent )
        {
            if ( p_UE_NR_Capability->measAndMobParameters.
                measAndMobParametersCommon.m.
                    supportedGapPatternPresent )
            {
                p_nr_radio_capability_info->bitmask |=
                    RRC_NR_SUPPORTED_GAP_PATTERN_PRESENT;

                if (RRC_SUCCESS != rrc_cp_unpack_U32(&p_nr_radio_capability_info->
                    supported_gap_pattern,
                        p_UE_NR_Capability->measAndMobParameters.
                            measAndMobParametersCommon.supportedGapPattern.data, "supportedGapPattern"))
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                         RRC_ERROR,"Failed to build supportedGapPattern.");
                }

            }
            else
            {
                RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                        (p_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,"supportedGapPattern Not Present in UE_NR_Capability");
            }
        }
        else
        {
            RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                    (p_ue_context->p_gb_context)->facility_name,
                    RRC_WARNING,"measAndMobParametersCommon Not Present in UE_NR_Capability");
        }
    }
    else
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"measAndMobParameters Not Present in UE_NR_Capability");
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/*NR_DC Code Change Start*/
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_build_ue_eutra_nr_capability
*   INPUT        : uecc_ue_context_t        *p_ue_context
*                  eutra_nr_radio_capability_info_t
*                                           *p_eutra_nr_radio_capability_info_t
*                  nr_rrc_UE_MRDC_Capability
*                                           *p_UE_MRDC_Capability
*   OUTPUT       : none
*   DESCRIPTION:
*       This function builds EUTRA NR RAT capability.
*
*   RETURNS:
*       RRC_SUCCESS/RRC_FAILURE
*
******************************************************************************/

rrc_return_et uecc_rrm_build_ue_eutra_nr_capability(
    uecc_ue_context_t                  *p_ue_context,      /* Added UE context */
    eutra_nr_radio_capability_info_t   *p_eutra_nr_radio_capability_info,
    nr_rrc_UE_MRDC_Capability          *p_UE_MRDC_Capability
)       
{
    rrc_return_et       result              = RRC_SUCCESS;
    OSRTDListNode*      p_node              = PNULL;
    OSRTDListNode*      p_node_band_paramters
                                            = PNULL;
    U16                 band_comb_count     = RRC_NULL;
    U16                 band_parameters_count
                                            = RRC_NULL;
    nr_rrc_BandCombination
                        *p_band_combination = PNULL;
    nr_rrc_BandParameters 
                        *p_band_parameters  = PNULL;

    RRC_ASSERT(PNULL != p_ue_context);
    RRC_ASSERT(PNULL != p_eutra_nr_radio_capability_info);
    RRC_ASSERT(PNULL != p_UE_MRDC_Capability);

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    if ( p_UE_MRDC_Capability->rf_ParametersMRDC.m.supportedBandCombinationListPresent )
    {
        p_eutra_nr_radio_capability_info->rf_parameters_mrdc.bitmask |=
            RF_PARAMETERS_MRDC_SUPPORTED_BAND_COMB_LIST_PRESENT;

        p_node = p_UE_MRDC_Capability->rf_ParametersMRDC.supportedBandCombinationList.head;
        
        for ( band_comb_count = RRC_NULL;
                p_node;
                (p_node = p_node->next))
        {
            p_band_combination = (nr_rrc_BandCombination *)(p_node->data);

            /*
            p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.
                band_combination[band_comb_count].feature_set_combination =
                p_band_combination->featureSetCombination;
            */
            p_node_band_paramters = p_band_combination->bandList.head;

            for (band_parameters_count = RRC_NULL;
                    p_node_band_paramters;
                    (p_node_band_paramters = p_node_band_paramters->next))
            {
                p_band_parameters = (nr_rrc_BandParameters *)(p_node_band_paramters->data);

                if ( T_nr_rrc_BandParameters_eutra == p_band_parameters->t ) 
                {
                    p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.
                        band_combination[band_comb_count].band_combination_band_list.
                        band[band_parameters_count].bitmask |=
                        BAND_PARAMETERS_EUTRA_PRESENT;

                    p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.
                        band_combination[band_comb_count].band_combination_band_list.
                        band[band_parameters_count].eutra.band_eutra =
                        p_band_parameters->u.eutra->bandEUTRA;

                    if (p_band_parameters->u.eutra->m.ca_BandwidthClassDL_EUTRAPresent)
                    {
                        p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.
                            band_combination[band_comb_count].band_combination_band_list.
                            band[band_parameters_count].eutra.bitmask |=
                            BAND_PARAMETERS_CA_BANDWIDTH_CLASS_DL_PRESENT;

                        p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.
                            band_combination[band_comb_count].band_combination_band_list.
                            band[band_parameters_count].eutra.ca_bandwidth_class_dl_eutra =
                            p_band_parameters->u.eutra->ca_BandwidthClassDL_EUTRA;

                    }

                    if (p_band_parameters->u.eutra->m.ca_BandwidthClassUL_EUTRAPresent)
                    {
                        p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.
                            band_combination[band_comb_count].band_combination_band_list.
                            band[band_parameters_count].eutra.bitmask |=
                            BAND_PARAMETERS_CA_BANDWIDTH_CLASS_UL_PRESENT;

                        p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.
                            band_combination[band_comb_count].band_combination_band_list.
                            band[band_parameters_count].eutra.ca_bandwidth_class_ul_eutra =
                            p_band_parameters->u.eutra->ca_BandwidthClassUL_EUTRA;

                    }
                }
                else if ( T_nr_rrc_BandParameters_nr == p_band_parameters->t )
                {
                    p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.
                        band_combination[band_comb_count].band_combination_band_list.
                        band[band_parameters_count].bitmask |=
                        BAND_PARAMETERS_NR_PRESENT;

                    p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.
                        band_combination[band_comb_count].band_combination_band_list.
                        band[band_parameters_count].nr.band_nr =
                        p_band_parameters->u.nr->bandNR;

                    if (p_band_parameters->u.nr->m.ca_BandwidthClassDL_NRPresent)
                    {
                        p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.
                            band_combination[band_comb_count].band_combination_band_list.
                            band[band_parameters_count].nr.bitmask |=
                            BAND_PARAMETERS_CA_BANDWIDTH_CLASS_DL_NR_PRESENT;

                        p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.
                            band_combination[band_comb_count].band_combination_band_list.
                            band[band_parameters_count].nr.ca_bandwidth_class_dl_nr =
                            p_band_parameters->u.nr->ca_BandwidthClassDL_NR;

                    }

                    if (p_band_parameters->u.nr->m.ca_BandwidthClassUL_NRPresent)
                    {
                        p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.
                            band_combination[band_comb_count].band_combination_band_list.
                            band[band_parameters_count].nr.bitmask |=
                            BAND_PARAMETERS_CA_BANDWIDTH_CLASS_UL_NR_PRESENT;

                        p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.
                            band_combination[band_comb_count].band_combination_band_list.
                            band[band_parameters_count].nr.ca_bandwidth_class_ul_nr =
                            p_band_parameters->u.nr->ca_BandwidthClassUL_NR;

                    }

                }
                else
                {
                    RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                            (p_ue_context->p_gb_context)->facility_name,
                            RRC_ERROR,
                            "Invalid Band Paramter Type! %d", p_band_parameters->t);
                    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
                    return RRC_FAILURE;
                }

                band_parameters_count++;
            }
            p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.
                band_combination[band_comb_count].band_combination_band_list.count =
                band_parameters_count;

            band_comb_count++;
        }
        p_eutra_nr_radio_capability_info->rf_parameters_mrdc.supported_band_comb_list.count =
            band_comb_count;
    }
    else
    {
        RRC_UECC_TRACE((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_WARNING,"Support Band Combination List Not Present in UE_MRDC_Capability");
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);
    return result;
}

/*********************************************************************************
*   FUNCTION NAME: rrcUeEutraCapabilityV1510IesEndc
*   INPUT        : UE_EUTRA_Capability_v1510_IEs      *pUeEutraCapabilityV1510
*                  uecc_ue_context_t*                 *pUeContext
*                  ue_eutra_capability_v1510_ies_t    *pRrmUeEutraCapabilityV1510
*   OUTPUT       : ue_eutra_capability_v1510_ies_t    *pRrmUeEutraCapabilityV1510
*   DESCRIPTION  : This function builds Ue Eutra capability V1510 for RRM
*   RETURNS      : RRC_SUCCESS/RRC_FAILURE
**********************************************************************************/
static
rrc_return_et
rrcUeEutraCapabilityV1510IesEndc
(
    UE_EUTRA_Capability_v1510_IEs      *pUeEutraCapabilityV1510,
    uecc_ue_context_t                  *pUeContext,
    ue_eutra_capability_v1510_ies_t    *pRrmUeEutraCapabilityV1510
)
{
    rrc_return_et    retVal = RRC_SUCCESS;

    RRC_UECC_UT_TRACE_ENTER(pUeContext->p_gb_context);

    RRC_ASSERT(PNULL != pUeEutraCapabilityV1510);
    RRC_ASSERT(PNULL != pUeContext);
    RRC_ASSERT(PNULL != pRrmUeEutraCapabilityV1510);

    do
    {
         pRrmUeEutraCapabilityV1510->bitmask = RRC_NULL;

        /*
         * Filling IRAT_ParametersNR release 15 
         */
        if ( RRC_TRUE == pUeEutraCapabilityV1510->m.irat_ParametersNR_r15Present
           )
        {
            pRrmUeEutraCapabilityV1510->bitmask |=
                RRC_RRM_UE_EUTRA_CAPABILITY_ENDC_PARAMETERS_R15_PRESENT;

            pRrmUeEutraCapabilityV1510->endcParameters.bitmask |=
                RRC_RRM_IRAT_PARAMETERS_NR_R15_PRESENT;

            RRC_UECC_TRACE(pUeContext->p_gb_context->context_index, 
                    pUeContext->p_gb_context->facility_name, 
                    RRC_DETAILED,"IRAT parameters NR r15 is present in UE eutra capability");

            if ( RRC_TRUE == pUeEutraCapabilityV1510->irat_ParametersNR_r15.m.en_DC_r15Present )
            {
                pRrmUeEutraCapabilityV1510->endcParameters.iratParametersNrR15.bitmask |=
                    RRC_RRM_EN_DC_R15_PRESENT;

                pRrmUeEutraCapabilityV1510->endcParameters.iratParametersNrR15.enDcR15Supported
                    = pUeEutraCapabilityV1510->irat_ParametersNR_r15.en_DC_r15 + RRC_ONE;

                /*
                 * Store EN DC R15 in ue context
                 */
                pUeContext->endcConfigInfo.enDcR15Supported =
                    pUeEutraCapabilityV1510->irat_ParametersNR_r15.en_DC_r15 + RRC_ONE;

                pUeContext->endcConfigInfo.bitmask |=
                    RRC_UECC_LLIM_ENDC_R15_PRESENT;
            }
            else
            {
                RRC_UECC_TRACE(pUeContext->p_gb_context->context_index, 
                        pUeContext->p_gb_context->facility_name, 
                        RRC_ERROR,"EN DC R15 is not supported in ue eutra capability recieved \n");
                retVal = RRC_FAILURE;
                break;
            }
        }
    }while(RRC_NULL);

    RRC_UECC_UT_TRACE_EXIT(pUeContext->p_gb_context);
    return retVal;
}
/*NR_DC Code Change Stop*/
/* OPTION3X Changes Start */
/******************************************************************************
*   FUNCTION NAME: uecc_rrm_process_dc_bearer_change_req
*   INPUT        : void                *p_api
*                  uecc_gb_context_t   *p_uecc_gb_context
*   OUTPUT       : none 
*   RETURN       : none
*   DESCRIPTION:
*       This function processes RRC_RRM_DC_BEARER_CHANGE_REQ message from RRM
******************************************************************************/
void uecc_rrm_process_dc_bearer_change_req
(
    void                *p_api,             /* Input API buffer */
    uecc_gb_context_t   *p_uecc_gb_context  /* UECC global context */
)
{
    rrc_return_et                   result = RRC_FAILURE;
    uecc_ue_context_t               *p_ue_context = PNULL;
    rrc_rrm_dc_bearer_change_req_t  *p_rrc_rrm_dc_bearer_change_req = PNULL;
    S32                             length_read = RRC_NULL;
    rrc_cell_index_t                cell_index = RRC_INVALID_CELL_INDEX;

    RRC_UECC_UT_TRACE_ENTER(p_uecc_gb_context);

    do
    {

        p_rrc_rrm_dc_bearer_change_req = rrc_mem_get(sizeof(rrc_rrm_dc_bearer_change_req_t));
        if (PNULL == p_rrc_rrm_dc_bearer_change_req)
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,       
                    RRC_ERROR,
                    "[RRC_RRM_DC_BEARER_CHANGE_REQ] Mem Alloc failed");
            break;
        }

        /* Decode message */
        result = rrc_il_parse_rrc_rrm_dc_bearer_change_req(
                    p_rrc_rrm_dc_bearer_change_req,
                    (U8* )p_api + RRC_FULL_INTERFACE_HEADERS_SIZE,
                    rrc_get_api_buf_size(p_api)-RRC_FULL_INTERFACE_HEADERS_SIZE,
                    &length_read);

        if ( RRC_SUCCESS != result )
        {
            /* Message parsing error */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_DC_BEARER_CHANGE_REQ] "
                "The RRC_RRM_DC_BEARER_CHANGE_REQ parsing error.");
            break;
        }
        RRC_UECC_TRACE(p_uecc_gb_context->context_index,p_uecc_gb_context->facility_name,
                RRC_BRIEF,"[UE_INDEX:%u]", p_rrc_rrm_dc_bearer_change_req->ue_index);
        /* Process message */
        p_ue_context = uecc_ue_ctx_get(p_uecc_gb_context,
            p_rrc_rrm_dc_bearer_change_req->ue_index);

        if ( PNULL == p_ue_context )
        {
            /* Error. Can't find UE context */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_DC_BEARER_CHANGE_REQ] The UE context isn't found.");
            break;
        }

        rrc_uecc_get_cell_index_from_rrm_api (p_ue_context,
                p_api, &cell_index);

        if (RRC_INVALID_CELL_INDEX == cell_index)
        {
            /* Error. Can't find Cell Index */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_DC_BEARER_CHANGE_REQ] Invalid Cell Index.");
            break;
        }

        if(RRC_FAILURE == rrc_uecc_check_is_cell_valid_and_active(
                    p_uecc_gb_context, cell_index))
        {
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                    p_uecc_gb_context->facility_name,
                    RRC_WARNING,
                    "[RRC_RRM_DC_BEARER_CHANGE_REQ] Cell not Active.");
            RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
            break;
        }
        /* Check transaction id */
        if (uecc_ue_ctx_get_op_transction_id(p_ue_context) !=
            rrc_get_transaction_id(p_api))
        {
            /* Error. Invalid transaction id */
            /* - Drop message */
            RRC_UECC_TRACE(p_uecc_gb_context->context_index,
                p_uecc_gb_context->facility_name,
                RRC_WARNING,
                "[RRC_RRM_DC_BEARER_CHANGE_REQ] Invalid transaction id.");
            break;
        }

        /* Call UECC_EV_RRM_DC_BEARER_CHANGE_REQ event handler *
         * and pass API data to FSM. */
        /* WARNING. The uecc_event_queue_push_event can't be used here because
         * the stack variable is used for storing the API data
         * */
        uecc_fsm_process_event(
                p_ue_context,
                UECC_EV_RRM_DC_BEARER_CHANGE_REQ,
                p_rrc_rrm_dc_bearer_change_req);

        rrc_mem_free(p_rrc_rrm_dc_bearer_change_req);
        p_rrc_rrm_dc_bearer_change_req = PNULL;
    }
    while(0);
    if (PNULL != p_rrc_rrm_dc_bearer_change_req)
    {
        rrc_mem_free(p_rrc_rrm_dc_bearer_change_req);
    }

   RRC_UECC_UT_TRACE_EXIT(p_uecc_gb_context);
}

/******************************************************************************
*   function name: uecc_rrm_build_and_send_dc_bearer_change_cnf
*   input        : uecc_ue_context_t    *p_ue_context
*   output       : none 
*   return       : none
*   description  : this function builds and sends rrc_rrm_dc_bearer_change_cnf
*                  message to rrm.
******************************************************************************/
rrc_return_t
uecc_rrm_build_and_send_dc_bearer_change_cnf
(
    uecc_ue_context_t               *p_ue_context,
    U8                              response 
)
{
    rrc_drb_to_modify_list_t            *p_drb_list = PNULL;
    rrc_rrm_dc_bearer_change_cnf_t      rrc_rrm_dc_bearer_change_cnf;
    rrc_return_et                       result = RRC_FAILURE;
    U8                                  drb_index = RRC_NULL;
    U8                                  error_list_count = RRC_NULL;
    U8                                  succ_list_count  = RRC_NULL;

    RRC_UECC_UT_TRACE_ENTER(p_ue_context->p_gb_context);

    memset_wrapper(&rrc_rrm_dc_bearer_change_cnf, RRC_NULL,
            sizeof(rrc_rrm_dc_bearer_change_cnf_t));

    /*
     * Fill message
     */
    /*
     * Clear Bitmask to 0
     */
    rrc_rrm_dc_bearer_change_cnf.bitmask = RRC_NULL;

    /*
     * ue_index
     */
    rrc_rrm_dc_bearer_change_cnf.ue_index = 
        p_ue_context->ue_index;
    
    /*
     * response
     */
    rrc_rrm_dc_bearer_change_cnf.response = response;

    p_drb_list =&(p_ue_context->
            p_curr_proc_data->u.rrm_dc_bearer_change_request_data.
            drb_to_modify_list);  

    /*
     * Set Success and Error List
     */ 
    for ( drb_index = RRC_NULL; drb_index < p_drb_list->drb_count; drb_index++ )
    {
    	/*Logical_Error*/
        if ( (RRC_SUCCESS == response) && (RRC_TRUE == p_drb_list->drb_config[drb_index].erab_success))
    	/*Logical_Error*/
        {
            /*
             * Set E_RAB ID in Success List
             */
            rrc_rrm_dc_bearer_change_cnf.erab_cnf_list.erab_cnf_info
                [succ_list_count].erab_id = p_drb_list->drb_config
                [drb_index].erab_id;

            ++succ_list_count;

            rrc_rrm_dc_bearer_change_cnf.bitmask |= 
                RRC_RRM_DC_BEARER_CHANGE_CNF_ERAB_CNF_LIST_PRESENT;
        }
        else
        {
            rrc_rrm_dc_bearer_change_cnf.erab_error_list.erab_error_info
                [error_list_count].erab_id = p_drb_list->drb_config 
                [drb_index].erab_id;

            rrc_rrm_dc_bearer_change_cnf.erab_error_list.erab_error_info
                [error_list_count].error_code = response;

            rrc_rrm_dc_bearer_change_cnf.bitmask |= 
                RRC_RRM_DC_BEARER_CHANGE_CNF_ERAB_ERROR_LIST_PRESENT;          

            error_list_count++;  
        }
    }

    /*
     * Set Count of ERAB ERROR List
     */
    rrc_rrm_dc_bearer_change_cnf.erab_error_list.erab_count =
        error_list_count;

    /*
     *Set Count of Success List
     */
    rrc_rrm_dc_bearer_change_cnf.erab_cnf_list.erab_count =
        succ_list_count;
    
    result = rrc_rrm_il_send_rrc_rrm_dc_bearer_change_cnf(
        &rrc_rrm_dc_bearer_change_cnf,
        RRC_UECC_MODULE_ID,
        RRC_RRM_MODULE_ID,
        uecc_ue_ctx_get_op_transction_id(p_ue_context),
        p_ue_context->cell_index);

    if ( RRC_FAILURE == result )
    {
        RRC_UECC_TRACE ((p_ue_context->p_gb_context)->context_index,
                (p_ue_context->p_gb_context)->facility_name,
                RRC_ERROR, 
                "Error occurred while sending DC bearer change cnf to RRM");
    }

    RRC_UECC_UT_TRACE_EXIT(p_ue_context->p_gb_context);

    return result;
}
/* OPTION3X Changes End */

/******************************************************************************
*   FUNCTION NAME : uecc_rrm_build_rrc_rrm_erb_release_req_endc
*   INPUT         : uecc_ue_context_t*         p_uecc_ue_context
*                   rrc_rrm_erb_release_req_t* p_rrc_rrm_erb_release_req
*   OUTPUT        : none
*   DESCRIPTION   : This function builds RRC_RRM_ERB_RELEASE_REQ message
*   RETURNS       : None
******************************************************************************/
void uecc_rrm_build_rrc_rrm_erb_release_req_endc
(
    uecc_ue_context_t* p_uecc_ue_context,
    rrc_rrm_erb_release_req_t* p_rrc_rrm_erb_release_req
)
{
    erab_list_t     erab_list;
    U32             counter = RRC_NULL;
    U32             drb_index = RRC_NULL;
    U32             erab_index = RRC_NULL;

    RRC_ASSERT(PNULL != p_uecc_ue_context);
    RRC_ASSERT(PNULL != p_rrc_rrm_erb_release_req);

    RRC_UECC_UT_TRACE_ENTER(p_uecc_ue_context->p_gb_context);

    memset_wrapper(p_rrc_rrm_erb_release_req, RRC_NULL, 
        sizeof(rrc_rrm_erb_release_req_t));

    /*
     * Fill RRC_RRM_ERB_RELEASE_REQ API
     */
    p_rrc_rrm_erb_release_req->ue_index = p_uecc_ue_context->ue_index;

    if ( RRC_ONE == p_uecc_ue_context->m.ue_agg_max_bit_rate_updated )
    {
        p_rrc_rrm_erb_release_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_ul =
            p_uecc_ue_context->ue_aggregate_maximum_bitrate.
            uEaggregateMaximumBitRateUL;

        p_rrc_rrm_erb_release_req->ue_agg_max_bit_rate.ue_agg_max_bit_rate_dl =
             p_uecc_ue_context->ue_aggregate_maximum_bitrate.
            uEaggregateMaximumBitRateDL;

        p_rrc_rrm_erb_release_req->bitmask |= 
            RRC_RRM_ERB_RELEASE_REQ_UE_AGG_MAX_BIT_RATE_PRESENT;
    }

    for ( erab_index = RRC_NULL; erab_index < MAX_ERAB_COUNT;
        erab_index++ )
    {
        if ( PNULL != p_uecc_ue_context->p_e_rab_list[erab_index] )
        {
            if ( p_uecc_ue_context->p_e_rab_list[erab_index]->m.DC_BearerTypePresent )
            {
                erab_list.erab_item[counter].e_RAB_ID =
                    p_uecc_ue_context->p_e_rab_list[erab_index]->e_RAB_ID;

                erab_list.erab_item[counter].cause.u.radioNetwork =
                    RRC_THREE;
                erab_list.erab_item[counter].cause.t =
                    RRC_ONE;
                p_uecc_ue_context->endc_erab_release_list.erab_item[erab_index].e_RAB_ID =
                    erab_list.erab_item[counter].e_RAB_ID;
                counter++;
                RRC_UECC_TRACE((p_uecc_ue_context->p_gb_context)->context_index,
                        (p_uecc_ue_context->p_gb_context)->facility_name,
                        RRC_WARNING,
                        "uecc_rrm_build_rrc_rrm_erb_release_req_endc inside dc bearer index %d ue ctx erb id %d",counter,
                        p_uecc_ue_context->endc_erab_release_list.erab_item[erab_index].e_RAB_ID);
            }
        }
    }

    p_rrc_rrm_erb_release_req->erab_to_be_released_item_list.count =
        counter;
    erab_list.counter = counter;
    p_uecc_ue_context->endc_erab_release_list.counter = counter;
    

    for( drb_index = RRC_NULL; 
         drb_index < p_rrc_rrm_erb_release_req->erab_to_be_released_item_list
            .count; 
        drb_index++ )
    {
        p_rrc_rrm_erb_release_req->erab_to_be_released_item_list.
            erab_to_be_release_item[drb_index].erab_id =
            (U8)(erab_list.erab_item[drb_index].e_RAB_ID);

        p_rrc_rrm_erb_release_req->erab_to_be_released_item_list.
            erab_to_be_release_item[drb_index].cause.type = 1;
        p_rrc_rrm_erb_release_req->erab_to_be_released_item_list.
            erab_to_be_release_item[drb_index].cause.value = 21;
    }
    RRC_UECC_UT_TRACE_EXIT(p_uecc_ue_context->p_gb_context);
}
#endif
