/*! \file son_utils.h
 *  \brief This file contains the enums, struct, constants definitions used
 *      by the common wrappers of SON.
 *  \date January 20, 2012
 *  \author Gautam Shah/Shilpi Jain
 */

/*!
 *  \copyright {Copyright (c) 2012, Aricent Inc. All Rights Reserved}
 */
#ifndef _SON_UTILS_H_
#define _SON_UTILS_H_

/*! \headerfile son_defines.h <>
 */
#include <son_defines.h>

/*! \headerfile son_types.h <>
 */
#include <son_types.h>

/*! \headerfile son_oam_intf.h <>
 */
#include <son_oam_intf.h>

/*! \headerfile cspl.h <>
   */
#include <cspl.h>

/*! \headerfile time.h <>
 */
#include <time.h>

/*! \headerfile sys/time.h <>
 */
#include <sys/time.h>

/*! \headerfile lteLogger.h <>
   */
#include <lteLogger.h>

/*! \headerfile sched.h <>
 */
#include <sched.h>

void set_cell_and_ue_index(U8 cell_index, U16 ue_index);
void set_cell_index(U8 cell_index);
void set_ue_index(U16 ue_index);
U8   get_cell_index(void);
U16  get_ue_index(void);
void free_cell_and_ue_index(void* info);

#define GET_CELL_INDEX()      get_cell_index()
#define GET_UE_INDEX()        get_ue_index()
#define SET_CELL_INDEX(value) set_cell_index(value)
#define SET_UE_INDEX(value)   set_ue_index(value)
#define SET_CELL_AND_UE_INDEX(cell_index, ue_index) set_cell_and_ue_index(cell_index, ue_index)

/* Platform-dependent defines */

/*! \def SON_MEMSET
 *  \brief An alias for memset
 */
#define SON_MEMSET              memset

/*! \def SON_MEMCPY
 *  \brief An alias for memcpy
 */
#define SON_MEMCPY              memcpy

/*! \def SON_MEMCMP
 *  \brief An alias for memcmp
 */
#define SON_MEMCMP              memcmp

/*! \def SON_FREE
 *  \brief An alias for free
 */
#define SON_FREE(X)             free((void *)X)

/*! \def SON_STRTOK(X,Y)
 *  \brief An alias for strtok
 */
#define SON_STRTOK(X, Y)         strtok((char *)X, (const char *)Y)

/*! \def SON_STRLEN(X)
 * \brief An alias for strlen
 */
#define SON_STRLEN(X)           strlen((const char *)X)

/*! \def SON_STRNLEN(X, Y)
 * \brief An alias for strnlen
 */
#define SON_STRNLEN(X, Y)           strnlen((const char *)X, (son_size_t)Y)

/*! \def SON_STRNCPY(X,Y,Z)
 * \brief An alias for strncpy
 */
#define SON_STRNCPY(X, Y, Z)     strncpy((char *)X, (const char *)Y, (son_size_t)Z)

/*! \def SON_STRDUP(X)
 * \brief An alias for strdup
 */
#define SON_STRDUP(X)          strdup((char *)X)

/*! \def SON_STRCAT(X,Y)
 * \brief An alias for strcat
 */
#define SON_STRCAT(X, Y)        strcat((char *)X, (char *)Y)

/*! \def SON_STRNCAT(X,Y,Z)
 * \brief An alias for strncat
 */
#define SON_STRNCAT(X, Y, Z)        strncat((char *)X, (char *)Y, (son_size_t)Z)

/*! \def SON_STRNCMP(X,Y,Z)
 * \brief An alias for strncmp
 */
#define SON_STRNCMP(X, Y, Z)    strncmp((char *)X, (char *)Y, Z)

/*! \def SON_SNPRINTF(A,B,C,D)
 *  \brief An alias for snprintf
 */
#define SON_SNPRINTF(A, B, C, D)   snprintf((char *)A, B, C, D)

/*! \def SON_QVLOGVA(X,Y,Z)
 *  \brief An alias for CSPL qvLogVa function
 */
#define SON_QVLOGVA(X, Y, Z)      qvLogVa(X, (const char *)Y, Z)

/*! \def SON_FOPEN(X,Y)
 *  \brief An alias for fopen
 */
#define SON_FOPEN(X, Y)        fopen((const char *)X, (const char *)Y)

/*! \def SON_FTELL(X)
 *  \brief An alias for ftell
 */
#define SON_FTELL(X)          ftell((FILE *)X)

/*! \def SON_FREAD(A,B,C,D)
 *  \brief An alias for fread
 */
#define SON_FREAD(A, B, C, D)    fread((void *)A, (size_t)B, (size_t)C, (FILE *)D)

/*! \def SON_FSEEK(X,Y,Z)
 *  \brief An alias for fseek
 */
#define SON_FSEEK(X, Y, Z)      fseek((FILE *)X, (long)Y, (int)Z)

/*! \def SON_FCLOSE(X,Y)
 *  \brief An alias for fclose
 */
#define SON_FCLOSE(X)         fclose((FILE *)X)
#define SON_NTOHL(X)         ntohl(X)
/* SPR-18735 START */
/*! \def SON_CEIL(X,Y)
 *  \brief An implementation for calculating ceiling value of a float
 */
#define SON_CEIL(X) ((son_u32)(X) + ((X) > SON_NULL && (X) != (son_u32)(X)))
/* SPR-18735 END */

/*! \def SON_MIN_TRANSACTION_ID
 *  \brief Macro storing the value of minimum transaction Identifier
 *  generated by SON
 */
#define SON_MIN_TRANSACTION_ID  1

/*! \def SON_MAX_TRANSACTION_ID
 *  \brief Macro storing the value of maximum transaction Identifier
 *  generated by SON
 */
#define SON_MAX_TRANSACTION_ID  0xFFFF

/*! \a const son_log_facility_name
 *  \brief SON Log facility name
 */
extern const son_8 *son_log_facility_name;

/*! \def SON_LOG_LEVEL_NONE
 *  \brief Macro defining log level for no log/trace
 */
/* SPR 22304 Fix Start */
#ifdef ATTRIBUTE_COMP
    void son_trace_dbg(
            U32 is_log_enable,const son_8 *son_log_facility_name,U8 log_level,
            const char* format, ...);
    void son_trace_dbg_1(
            U8 log_level,
            const char* format, ...);

#define SON_TRACE_DBG(is_log_enable,son_log_facility_name,log_level,format, ...)   son_trace_dbg(is_log_enable,son_log_facility_name, log_level, format, ## __VA_ARGS__);
#define SON_TRACE_DBG_1(log_level,format, ...)   son_trace_dbg_1(log_level, format, ## __VA_ARGS__);
#define SON_DEBUG_TRACE SON_TRACE_DBG_1
#define SON_LOG SON_TRACE_DBG
#endif
/* SPR 22304 Fix End */
#define SON_LOG_LEVEL_NONE  QVLOG_NONE

#ifdef SON_ADV_LOGGER
    #define LOGGER_TYPE SON_ADV_LOGGER
#endif

#ifdef SON_INTERNAL_LOGGER
    #define LOGGER_TYPE SON_INTERNAL_LOGGER
#endif

#ifdef SON_IN_MEM_LOGGER 
 #define LOGGER_TYPE SON_IN_MEM_LOGGER
#endif

#if (SON_ADV_LOGGER == LOGGER_TYPE)

/*
 *  Advanced logger
 */

    #include <advlogging.h>

extern AdvL_ContextIndex g_advl_ctxt[SON_MAX_INTERNAL_MODULES];
extern AdvL_ContextIndex g_main_advl_ctxt;

/*! \fn son_void_t son_set_module_loglevel_limit(son_u8 log_level)
 *  \brief This function sets the module log level to advance logger
 *  \param log_level    Log level to be used(SON_ERROR, SON_BRIEF etc.)
 */
son_void_t
son_set_module_loglevel_limit
(
    son_u8 log_level
);

/*! \def SET_MODULE_LOG_LEVEL(log_level)
 *  \brief Macro defining the function to set module's log level
 */
    #define SET_MODULE_LOG_LEVEL(log_level) \
    son_set_module_loglevel_limit(log_level);

/*! \def SON_LOG_CTXT_CONSOLE
 *  \brief Macro to set the logs to appear on console
 */
    #define SON_LOG_CTXT_CONSOLE    LogContext_Default

/*! \def SON_LOG_CTXT_FILE
 *  \brief Macro to set the logs to appear in a file
 */
    #define SON_LOG_CTXT_FILE       LogTarget_File

/*! \def SON_CRITICAL
 *  \brief Macro defining log level for CRITICAL logs/traces
 */
    #define SON_CRITICAL            LogFatal

/*! \def SON_ERROR
 *  \brief Macro defining log level for ERROR logs/traces
 */
    #define SON_ERROR               LogError

/*! \def SON_WARNING
 *  \brief Macro defining log level for WARNING logs/traces
 */
    #define SON_WARNING             LogWarning

/*! \def SON_INFO
 *  \brief Macro defining log level for INFO logs/traces
 */
    #define SON_INFO                LogInfo

/*! \def SON_BRIEF
 *  \brief Macro defining log level for BRIEF logs/traces
 */
    #define SON_BRIEF               LogBrief

/*! \def SON_DETAILED
 *  \brief Macro defining log level for DETAILED logs/traces
 */
    #define SON_DETAILED            LogDetailed

/*! \def SON_DETAILEDALL
 *  \brief Macro defining log level for COMP_PARSE logs/traces
 */
    #define SON_DETAILEDALL          LogDebug

/*! \def SON_INIT_LOG(log_file_name)
 *  \brief Macro to be used to initialize advance logging.
 */
    #define SON_INIT_LOG(log_file_name) son_init_log(log_file_name)

/*! \def SON_LOG(is_log_enable, facility_name, log_level, format, ...)
 *  \brief Macro to be used for logging. Its first argument tells if the
 *      corresponding log is be printed or not. Second argument gives the
 *      information about the facility using the log. Third argument gives
 *      the log level(INFO, WARNING etc.). Forth argument is used to give
 *      any nformation related to the event using the log.
 */
/* SPR_17377_Warning_fix + */
/* SPR 22304 Fix Start */
#ifndef ATTRIBUTE_COMP
/* SPR 22304 Fix End */
/* SPR_17377_Warning_fix - */
    #define SON_LOG(is_log_enable, facility_name, log_level, format, ...) \
    { \
        if (SON_OAM_LOG_ON == is_log_enable) \
        { \
            son_u16 module_id = 0; \
            module_id = qvGetServiceName(qvSelf()); \
            if((module_id >= SON_MIN_INT_MODULE_ID) && (module_id <= SON_MAX_MODULE_ID)) \
            { \
                write_log_message(g_advl_ctxt[module_id - \
                                              SON_MIN_INT_MODULE_ID], log_level, __FILE__, \
                    __LINE__, __func__, facility_name, GET_CELL_INDEX(), GET_UE_INDEX(), format, \
                    ## __VA_ARGS__); \
            } \
        } \
    }
/* SPR_17377_Warning_fix + */
#endif
/* SPR_17377_Warning_fix - */

/*! \def SON_PANIC(format, ...)
 *  \brief Macro to be used by the encapsulation code for aborting the
 *      process in error situation. Its argument is used to give any
 *      information related to the event using the log.
 */
    #define SON_PANIC(format, ...) \
    { \
        write_log_message(g_main_advl_ctxt, SON_ERROR, __FILE__, \
            __LINE__, __func__, son_log_facility_name, GET_CELL_INDEX(), GET_UE_INDEX(), format, \
            ## __VA_ARGS__); \
        son_abort(); \
    }

/*! \def SON_ENCAPS_WARNING(format, ...)
 *  \brief Macro to be used by the encapsulation code to print some warning.
 *      Its argument is used to give any information related to the event
 *      using the log.
 */
    #define SON_ENCAPS_WARNING(format, ...) \
    { \
        write_log_message(g_main_advl_ctxt, SON_ERROR, __FILE__, \
            __LINE__, __func__, son_log_facility_name, GET_CELL_INDEX(), GET_UE_INDEX(), format, \
            ## __VA_ARGS__); \
    }

#elif (SON_INTERNAL_LOGGER == LOGGER_TYPE)

/*
 *   Internal logger
 */

/*! \fn son_void_t set_module_log_level(son_u8 log_level)
 *  \brief It is used to set the module log level to CSPL logging framework.
 *  \param log_level        Log Level to be set(SON_ERROR, SON_BRIEF etc.)
 */
son_void_t
set_module_log_level
(
    son_u8 log_level
);

/*! \fn son_void_t son_trace_message(son_s32 log_level, const son_s8
 *      *p_facility_name, const son_s8* format, ...)
 *  \brief It is used to print the logs and traces
 *  \param log_level        Log Level to be set(SON_ERROR, SON_BRIEF etc.)
 *  \param p_facility_name  String describing the facility of the log/trace
 *  \param p_format         Pointer to format specifier string
 *  \param ...              Variable number of arguments
 */
son_void_t
son_trace_message
(
    son_s32 log_level,
    const son_8    *p_facility_name,
    const son_s8    *p_format,
    ...
);

/*! \def SON_INIT_LOG(log_file_name)
 *  \brief Macro to be used to initialize advance logging.
 */
    #define SON_INIT_LOG(log_file_name)

/*! \def SET_MODULE_LOG_LEVEL(log_level)
 *  \brief Macro defining the function to set module's log level
 */
    #define SET_MODULE_LOG_LEVEL(log_level) set_module_log_level(log_level)

/*! \def SON_CRITICAL
 *  \brief Macro defining log level for CRITICAL logs/traces
 */
    #define SON_CRITICAL    QVLOG_CRITICAL

/*! \def SON_ERROR
 *  \brief Macro defining log level for ERROR logs/traces
 */
    #define SON_ERROR       QVLOG_MAJOR

/*! \def SON_WARNING
 *  \brief Macro defining log level for WARNING logs/traces
 */
    #define SON_WARNING     QVLOG_MINOR

/*! \def SON_INFO
 *  \brief Macro defining log level for INFO logs/traces
 */
    #define SON_INFO        QVLOG_INFO

/*! \def SON_BRIEF
 *  \brief Macro defining log level for BRIEF logs/traces
 */
    #define SON_BRIEF       QVLOG_INFO

/*! \def SON_DETAILED
 *  \brief Macro defining log level for DETAILED logs/traces
 */
    #define SON_DETAILED    QVLOG_DETAIL

/*! \def SON_DETAILEDALL
 *  \brief Macro defining log level for COMP_PARSER logs/traces
 */
    #define SON_DETAILEDALL  QVLOG_DUMP 

/*! \def SON_LOG(is_log_enable, facility_name, log_level, format, ...)
 *  \brief Macro to be used for logging. Its first argument tells if the
 *      corresponding log is be printed or not. Second argument gives the
 *      information about the facility using the log. Third argument gives
 *      the log level(INFO, WARNING etc.). Forth argument is used to give
 *      any nformation related to the event using the log.
 */
    #define SON_LOG(is_log_enable, facility_name, log_level, format, ...) \
    if (SON_OAM_LOG_ON == is_log_enable) son_trace_message \
            ((son_s32)log_level, facility_name, (const son_s8 *)format, \
            ## __VA_ARGS__)

/*! \def SON_PANIC(format, ...)
 *  \brief Macro to be used by the encapsulation code for aborting the
 *      process in error situation. Its argument is used to give any
 *      information related to the event using the log.
 */
    #define SON_PANIC(format, ...) qvPanic((const son_8 *)format, ## __VA_ARGS__)

/*! \def SON_ENCAPS_WARNING(format, ...)
 *  \brief Macro to be used by the encapsulation code to print some warning
 *      . Its argument is used to give any information related to the event
 *      using the log.
 */
    #define SON_ENCAPS_WARNING(format, ...) qvWarning((const son_8 *)format, \
    ## __VA_ARGS__)

#elif (LOGGER_TYPE == SON_IN_MEM_LOGGER)

/* SPR 20585 Fix Start */
#include <advlogging.h>
/* SPR 20585 Fix End */
    /*! \fn son_void_t set_module_log_level(son_u8 log_level)
     *  \brief It is used to set the module log level to CSPL logging framework.
     *  \param log_level        Log Level to be set(SON_ERROR, SON_BRIEF etc.)
     */
    son_void_t
    set_module_log_level
    (
        son_u8 log_level
    );



    #define SET_MODULE_LOG_LEVEL(log_level) set_module_log_level(log_level)

    #define SON_INIT_LOG(log_file_name)

    /* SPR 21275 changes start */
    #define SON_CRITICAL        LGR_CRITICAL
    #define SON_ERROR           LGR_ERROR
    #define SON_WARNING         LGR_WARNING
    #define SON_INFO            LGR_INFO
    #define SON_BRIEF           LGR_BRIEF
    #define SON_DETAILED        LGR_DETAILED
    #define SON_DETAILEDALL     LGR_DEBUG
    /* SPR 21275 changes end */

/* SPR 22304 Fix Start */
#ifndef ATTRIBUTE_COMP
    #define SON_LOG(is_log_enable, facility_name, log_level, format, ...) \
        {\
            if ((U32)SON_OAM_LOG_ON == (U32)is_log_enable)\
            {\
                QMODULE module;\
                module = qvSelf();\
                if (module && log_level <= qvGetModuleLogLevel(module)){\
		/* SPR 21820 Start */\
                print_log_message(log_level, __FILE__, __LINE__, __func__,\
                        (char *)facility_name, GET_CELL_INDEX(), GET_UE_INDEX(), LGR_FALSE, format, ##__VA_ARGS__);}\
		/* SPR 21820 End */\
            }\
        }
#endif
/* SPR 22304 Fix End */
   /*! \def SON_PANIC(format, ...)
    *  \brief Macro to be used by the encapsulation code for aborting the process
    *      in error situation. Its argument is used to give any information
    *      related to the event using the log.
    */

    #define SON_PANIC(format, ...) \
        {\
            QMODULE module;\
            module = qvSelf();\
            if (module && SON_ERROR <= qvGetModuleLogLevel(module)){\
	    /* SPR 21820 Start */\
            print_log_message(SON_ERROR, __FILE__, __LINE__, __func__,\
                    (char *)son_log_facility_name, GET_CELL_INDEX(), GET_UE_INDEX(), LGR_FALSE, format, ##__VA_ARGS__);}\
	    /* SPR 21820 End */\
        }

   /*! \def SON_ENCAPS_WARNING (format, ...)
    *  \brief Macro to be used by the encapsulation code to print some warning.
    *         Its argument is used to give any information related to the event
    *         using the log.
    */
    #define SON_ENCAPS_WARNING(format, ...) \
        {\
            QMODULE module;\
            module = qvSelf();\
            if (module && SON_WARNING <= qvGetModuleLogLevel(module)){\
	    /* SPR 21820 Start */\
            print_log_message(SON_WARNING, __FILE__, __LINE__, __func__,\
                    (char *)son_log_facility_name, GET_CELL_INDEX(), GET_UE_INDEX(), LGR_FALSE, format, ##__VA_ARGS__);}\
	    /* SPR 21820 End */\
        }

#elif (LOGGER_TYPE > SON_IN_MEM_LOGGER)
    #error Wrong logger type specified!
#else /* if (SON_ADV_LOGGER == LOGGER_TYPE) */
    #define SON_LOG(facility_name, log_level, format, ...)
#endif /* if (SON_ADV_LOGGER == LOGGER_TYPE) */

#define SON_COMP_PARSE SON_DETAILEDALL

/* This will be used when debugging flag is ON. In this logging mode will
 *  be considered as enabled. */

/*! \def SON_DEBUG_TRACE(log_level, format, ...)
 *  \brief Macro to be used for debugging purpose traces.
 */
/* SPR_17377_Warning_fix + */
/* SPR 22304 Fix Start */
#ifndef ATTRIBUTE_COMP
/* SPR 22304 Fix End */
/* SPR_17377_Warning_fix - */
#define SON_DEBUG_TRACE(log_level, format, ...) \
    SON_LOG(SON_OAM_LOG_ON, son_log_facility_name, log_level, format, \
    ## __VA_ARGS__)

/*! \def SON_TRACE(is_log_enable, log_level, format, ...)
 *  \brief Macro to be used for tracing. It is same as SON_LOG macro
 *      but with a default facility name(LTE_SON).
 */
#define SON_TRACE(is_log_enable, log_level, format, ...) \
    SON_LOG(is_log_enable, son_log_facility_name, log_level, format, \
    ## __VA_ARGS__)
/* SPR_17377_Warning_fix + */
#endif
/* SPR_17377_Warning_fix - */

/*
 *   ASSERT
 */

/*! \fn son_void_t son_assert(son_void_t  *p_file, son_u32 line,
 *     son_void_t *p_expression)
 *  \brief Assert function to check the validity of an expression
 *  \param p_file          Name of file
 *  \param line            Line number of log/trace in file
 *  \param p_expression    Pointer to expression to be checked
 */

 /*SPR-12970-Start- SON_DEBUG applied to son_assert*/
#ifdef SON_DEBUG
son_void_t
son_assert
(
    son_void_t  *p_file,
    son_u32 line,
    son_void_t  *p_expression
);

/*! \def SON_ASSERT(exp)
 *  \brief Macro to be used during UT for validating expressions.
 */
#define SON_ASSERT(exp) (son_void_t)((exp) || \
                                     (son_assert(__FILE__, __LINE__,#exp), 0))
#else
#define SON_ASSERT(exp)
#endif /* ifdef SON_DEBUG */
/*SPR-12970-End*/

/*
 *   UT Trace
 */
/* #define SON_DEBUG */
#ifdef SON_DEBUG

/* During DEBUG the following traces should come irrespective of log
 *  enabled/disabled */

/*! \def SON_UT_TRACE_ENTER()
 *  \brief Macro used to depict entry in a particular function when
 *  SON_DEBUG flag is true. It prints the function and the file name
 *  which is helpful to trace the code flow.
 */
    #define SON_UT_TRACE_ENTER() \
    SON_DEBUG_TRACE(SON_DETAILED, "Entering function: %s in file: %s\n", \
    __FUNCTION__, __FILE__)

/*! \def SON_UT_TRACE_EXIT()
 *  \brief Macro used to depict exit from a particular function when
 *  SON_DEBUG flag is true. It prints the function and the file name which
 *  is helpful to trace the code flow.
 */
    #define SON_UT_TRACE_EXIT() \
    SON_DEBUG_TRACE(SON_DETAILED, "Exiting function: %s in file: %s\n", \
    __FUNCTION__, __FILE__)

/* During DEBUG the following traces should come irrespective of log
 *  enabled/disabled */

/*! \def SON_FSM_INIT_TRACE(fsm_name, state_name)
 *  \brief Macro used to depict the INIT state of a module when SON_DEBUG
 *  flag is true.
 */
    #define SON_FSM_INIT_TRACE(fsm_name, state_name) \
    SON_DEBUG_TRACE(SON_BRIEF, "[%s] initialized, initial state [%s]" \
                               "\n", fsm_name, state_name)

/*! \def SON_FSM_EVENT_TRACE(fsm_name, event_name, state_name)
 *  \brief Macro used to indicate reception of an event in a particular
 *  state when SON_DEBUG flag is true.
 */
    #define SON_FSM_EVENT_TRACE(fsm_name, event_name, state_name) \
    SON_DEBUG_TRACE(SON_BRIEF, "[%s] event [%s] received in state " \
                               "[%s]\n", fsm_name, event_name, state_name)

#else /* ifdef SON_DEBUG */

/*! \def SON_UT_TRACE_ENTER()
 *  \brief Macro expansion when SON_DEBUG flag is false.
 */
    #define SON_UT_TRACE_ENTER()

/*! \def SON_UT_TRACE_EXIT()
 *  \brief Macro expansion when SON_DEBUG flag is false.
 */
    #define SON_UT_TRACE_EXIT()

/*! \def SON_FSM_INIT_TRACE(fsm_name, state_name)
 *  \brief Macro expansion when SON_DEBUG flag is false.
 */
    #define SON_FSM_INIT_TRACE(fsm_name, state_name)

/*! \def SON_FSM_EVENT_TRACE(fsm_name, event_name, state_name)
 *  \brief Macro expansion when SON_DEBUG flag is false.
 */
    #define SON_FSM_EVENT_TRACE(fsm_name, event_name, state_name)
#endif /* ifdef SON_DEBUG */


/*! \def SON_EIGHT
 *  \brief This Macro represents the numeric value 8
 */
#define SON_EIGHT 8

/*! \def SON_CPU_ZERO
 * \brief An alias for CPU_ZERO
 */
#define SON_CPU_ZERO    CPU_ZERO

/*! \def SON_CPU_SET
 * \brief An alias for CPU_SET
 */
#define SON_CPU_SET     CPU_SET

/*! \def SON_VA_START
 * \brief An alias for va_start
 */
#define SON_VA_START    va_start

/*! \def SON_VA_END
 * \brief An alias for va_end
 */
#define SON_VA_END      va_end

/****************************************************************************
 * Macro to log message hex dump
 ****************************************************************************/
#define SON_LOG_HEX_DUMP(direction, msgBuf, msgLength, moduleId, apiId, version)\
SON_LOG(SON_OAM_LOG_ON, "SON UTILS", SON_BRIEF, \
        "[%s] [MODULE:%s(%u)] [API:%s(%u)] [SIZE:%u] [VER:%u]", \
        direction, son_get_module(moduleId), moduleId, \
        son_get_msg_api_name(apiId, moduleId), apiId, \
        msgLength, version); 

/*SPR 18200 Start*/
son_void_t *
son_malloc
(
    son_u32 size 
);
/*SPR 18200 End*/
/*! \fn son_exit
 *  \brief It is used to exit from binary.
 *  \param value    The exit value of the process
 */
son_void_t
son_exit
(
    son_s32 value
);

/*! \a const son_manifest_mif
 *  \brief CSPL Manifest structure for SMIF module
 */
extern const QMANIFEST son_manifest_mif;

/*! \a const son_manifest_apps
 *  \brief CSPL Manifest structure for SONApps module
 */
extern const QMANIFEST son_manifest_apps;

/*! \a const decl son_manifest_nmm
 *  \brief CSPL Manifest structure for SONNmm module
 */
extern const QMANIFEST son_manifest_nmm;

/*! \a const son_manifest_es
 *  \brief CSPL Manifest structure for SONES module
 */
extern const QMANIFEST son_manifest_es;

/*! \a const son_manifest_anr
 *  \brief CSPL Manifest structure for SONANR module
 */
extern const QMANIFEST son_manifest_anr;

/*! \a const decl son_manifest_x2
 *  \brief CSPL Manifest structure for SON X2 module
 */
extern const QMANIFEST son_manifest_x2;

/*! \a const decl son_manifest_mro
 *  \brief CSPL Manifest structure for SON MRO module
 */
extern const QMANIFEST son_manifest_mro;

/*! \a const decl  son_manifest_mlb
 *  \brief CSPL Manifest structure for SONMLB module
 */
extern const QMANIFEST son_manifest_mlb;

/*! \a const decl son_manifest_rach_opt
 *  \brief CSPL Manifest structure for SON RACH OPT module
 */
extern const QMANIFEST son_manifest_rach_opt;

/*! \a const decl SON_MODE_NAMES
 *  \brief Stores SON mode values such as CENTRALIZED/DISTRIBUTED
 */
extern const son_s8 *SON_MODE_NAMES[];

/*! \a const decl RA_CONFIG_FDD_DATA_FOR_PREAMBLE
 *  \brief Array storing possible values of Preamble format and density value 
    for all possible PRACH configuraion index for frame type 1. PRACH 
    configuraion index range from 0 to 63 so each entry in this array 
    corresponds to data for particular PRACH configuration index starting at 
    index 0.
 */
extern const frame_type_1_ra_config_data_for_preamble RA_CONFIG_FDD_DATA_FOR_PREAMBLE[SON_MAX_PRACH_CONFIG_IDX];

/*! \a const decl RA_CONFIG_TDD_DATA_FOR_PREAMBLE
 *  \brief Array storing possible values of Preamble format and density value 
    for all possible PRACH configuraion index for frame type 2. PRACH 
    configuraion index range from 0 to 63 so each entry in this array 
    corresponds to data for particular PRACH configuration index starting at 
    index 0.
 */
extern const frame_type_2_ra_config_data_for_preamble RA_CONFIG_TDD_DATA_FOR_PREAMBLE[SON_MAX_PRACH_CONFIG_IDX];

/*! \a const decl DUPLEX_MODE_OF_CELL
 *  \brief Array storing the duplex mode values for a cell. 
 */
extern const son_8 *DUPLEX_MODE_OF_CELL[SON_MAX_NUM_OF_DUPLEX_MODES]; 

typedef struct _son_thread_arg_t
{
    QDRIVER         driver_id;
    const QWAIT     *p_qwait;
    lgr_thread_id_t logical_thid;
}son_thrd_arg_t;

/*! \  struct son_listener_t
 *  \brief Listener stuctue storing the socked descriptors being used for
 *      communicaiton with external entities.
 *  \param sd_udp_rrm   UDP socket descriptor for communication with RRM
 *  \param sd_udp_rrc   UDP socket descriptor for communication with RRC
 *  \param sd_udp_oam   UDP socket descriptor for communication with OAM
 *  \param sd_udp_phy   UDP socket descriptor for communication with PHY
 */
typedef struct _son_listener_t
{
    son_s32 sd_udp_rrm;
    son_s32 sd_udp_rrc;
    son_s32 sd_udp_oam;
    son_s32 sd_udp_phy;
}son_listener_t;

/*! \fn son_void_t son_send_msg(son_void_t  *p_msg, son_u16 dst_module_id)
 *  \brief It sends the message to the destination module using qvSend
 *  \param p_msg            Message that will be passed
 *  \param dst_module_id    Module id for which message will be passed
 */
/*SPR 20172 FIX START*/
#define son_send_msg(p_msg,dst_module) do {\
	son_send_msg_ex(p_msg,dst_module);\
	p_msg = PNULL;\
}while(0)
son_void_t
son_send_msg_ex
/*SPR 20172 FIX End*/
(
    son_void_t  *p_msg,
    son_u16 dst_module_id
);

/******************************************************************************
*   Memory management functions
******************************************************************************/

/*! \fn son_void_t son_msg_mem_get(size_t size)
 *  \brief It returns memory buffer from memory pool.
 *  \param size     Size of buffer which will be allocated
 */
son_void_t *
son_msg_mem_get
(
    size_t size
);

/*! \fn son_void_t son_msg_mem_free(son_void_t *p_buffer)
 *  \brief It frees memory buffer allocated to memory pool.
 *  \param p_buffer Pointer to buffer which will be freed
 */
son_void_t
son_msg_mem_free
(
    son_void_t *p_buffer
);

/*! \fn son_void_t son_sys_mem_get(son_size_t size)
 *  \brief It returns memory buffer from the system.
 *  \param size Size of buffer which will be allocated
 */
son_void_t *
son_sys_mem_get
(
    son_size_t size
);

/*! \fn son_void_t son_sys_mem_free(son_void_t *p_buffer)
 *  \brief It frees memory buffer allocated from sytem.
 *  \param p_buffer Pointer to buffer which will be freed
 */
son_void_t
son_sys_mem_free
(
    son_void_t *p_buffer
);

/*! \fn son_void_t * son_mem_get (son_size_t size)
 *  \brief This function returns memory buffer from memory pool
 *  \param size Size of memory to be allocated
 */
son_void_t *
son_mem_get
(
    son_size_t size
);

/*! \fn son_void_t  son_mem_free(son_void_t *p_buffer)
 *  \brief This function frees memory buffer allocated in pool
 *  \param p_buffer Pointer to memory buffer to be freed
 */
son_void_t
son_mem_free
(
    son_void_t *p_buffer
);

/******************************************************************************
*   Memory management functions End
******************************************************************************/

/*! \fn son_void_t son_register_modules(son_void_t)
 *  \brief It registers various SON modules with CSPL.
 */
son_void_t
son_register_modules
(
/*SPR 17777 +-*/ 
#ifdef SON_IN_MEM_LOGGER
   son_thrd_arg_t *p_thrd_arg
#else
   void
#endif
/*SPR 17777 +-*/ 
);

/*! \fn son_void_t son_construct_cspl_header(son_void_t *p_buf,
 *     son_u8 version, son_u16 from, son_u16 to, son_u16 api_id,
 *     son_u8 priority, son_u16 paramlen)
 *  \brief It is used to create the CSPL Header of the message
 *  \param p_buf        Pointer to the buffer to which header is appended
 *  \param version      version of API
 *  \param from         Source module Id
 *  \param to           Destination module Id
 *  \param api_id       API Identifier
 *  \param priority     Priority of the message
 *  \param paramlen     length of the parameters
 */
son_void_t
son_construct_cspl_header
(
    son_void_t  *p_buf,
    son_u8 version,
    son_u16 from,
    son_u16 to,
    son_u16 api_id,
    son_u8 priority,
    son_u16 paramlen
);

/*! \fn son_void_t son_parse_cspl_header(son_void_t  *p_buf, STACKAPIHDR
 *      p_cspl_hdr)
 *  \brief It is used to parse the CSPL Header and populate the STACKAPIHDR
 *      structure
 *  \param p_buf        Pointer the CSPL header
 *  \param p_cspl_hdr   Pointer to the STACKAPIHDR structure to be populated
 */
son_void_t
son_parse_cspl_header
(
    son_void_t  *p_buf,
    STACKAPIHDR *p_cspl_hdr
);

/*! \fn son_void_t son_create_send_buffer(son_u8 *p_mem, son_module_id_et from,
 *     son_module_id_et to, son_procedure_code_et api, son_u16 length)
 *  \brief This function creates the message and send it to the required
 *      destination.
 *  \param p_mem        Pointer to the memory containing data to be send
 *  \param from         Source module Id
 *  \param to           Destination module Id
 *  \param api          Procedure Code (API Identifier)
 *  \param length       Length of the data
 */
son_void_t
son_create_send_buffer
(
    son_u8                  *p_mem,
    son_module_id_et from,
    son_module_id_et to,
    son_procedure_code_et api,
    son_u16 length
);

/*! \fn son_u16 son_get_word_from_header(son_u8 *p_header)
 *  \brief This is used to get a 2 byte word from a given position
 *  \param p_header Pointer to the header data from where 16 bit word is to be read
 */
son_u16
son_get_word_from_header
(
    son_u8 *p_header
);

/******************************************************************************
*   Timer management functions
******************************************************************************/

/*! \fn extern son_timer_t son_start_timer(son_u32 timer_duration,
 *  son_void_t *p_timer_data, son_u16 timer_data_size, son_bool_et is_repeated)
 *  \brief  This function is used to start the timer.
 *  \param timer_duration
 *  \param *p_timer_data
 *  \param timer_data_size
 *  \param is_repeated
 */

extern son_timer_t
son_start_timer
(
    son_u32 timer_duration,
    son_void_t        *p_timer_data,
    son_u16 timer_data_size,
    son_bool_et is_repeated
);

/*! \fn extern son_void_t son_stop_timer(son_timer_t timer)
 *  \brief This function is used to stop the timer.
 *  \param timer    Timer Id as allocated by the CSPL
 */
extern son_void_t
son_stop_timer
(
    son_timer_t timer
);

/*! \fn extern son_void_t* son_get_timer_data(son_timer_t timer)
 *  \brief This function is used to obtain the timer data.
 *  \param timer
 */

extern son_void_t *
son_get_timer_data
(
    son_timer_t timer
);

/******************************************************************************
*   Timer management functions End
******************************************************************************/

/*! \fn son_u16 son_generate_txn_id()
 *  \brief It is used to generate the transaction Id
 */
/* + SPR 17439 */
son_u16
son_generate_txn_id(void);
/* - SPR 17439 */

/*! \fn son_s32 son_compare_cell_id (const son_void_t *p_val_1,
 *                    const son_void_t *p_val_2);
 *  \brief This function compares the cell ids
 *  \param p_val_1     Pointer to the cell id as void *
 *  \param p_val_2     Pointer to the cell id as void *
 */
son_s32
son_compare_cell_id
(
    const son_void_t *p_val_1,
    const son_void_t *p_val_2
);
/*SPR_19279_START*/
/*! \fn son_s32 son_compare_cell_index (const son_void_t *p_val_1,
 *                    const son_void_t *p_val_2);
 *  \brief This function compares the cell indexea
 *  \param p_val_1     Pointer to the cell idx as void *
 *  \param p_val_2     Pointer to the cell idx as void *
 */
son_s32
son_compare_cell_index
(
    const son_void_t *p_val_1,
    const son_void_t *p_val_2
);
/*SPR_19279_END*/

/*! \fn son_u16 son_get_transaction_id (void *p_api)
 *  \brief This function retreives transaction_id from external API message
 *  \param p_api Pointer to the api
 */
son_u16
son_get_transaction_id
(
    void *p_api
);

/*! \fn void son_construct_interface_api_header(
 *  son_u8              *p_header,
 *  son_u16             transaction_id,
 *  son_module_id_et    src_module_id,
 *  son_module_id_et    dst_module_id,
 *  son_u16             api_id,
 *  son_u16             api_buf_size,
 *  son_cell_index_t    cell_index)
 *  \brief This function constructs the interface header
 *  \param p_header         Pointer to SON interface header
 *  \param transaction_id    Interface transaction identifier
 *  \param src_module_id    Source module identifier
 *  \param dst_module_id    Destination module identifier
 *  \param api_id         API identifier
 *  \param api_buf_size        API buffer size
 *  \param cell_index   Cell Index value
 */

void
son_construct_interface_api_header
(
    son_u8              *p_header,
    son_u16 transaction_id,
    son_module_id_et src_module_id,
    son_module_id_et dst_module_id,
    son_u16 api_id,
    son_u16 api_buf_size,
    son_cell_index_t cell_index
);

/*! \fn son_void_t son_init_log(const son_8 * p_log_file_name);
 *  \brief This function is used to initialize advance logger
 *  \param p_log_file_name  Pointer to the log file name
 */
son_void_t
son_init_log
(
    const son_8 *p_log_file_name
);

/*! \fn son_void_t son_abort();
 *  \brief This function is used to abort the system
 *  \brief This function is used to abort the system
 */
/* + SPR 17439 */
son_void_t
son_abort(void);
/* - SPR 17439 */

/*! \fn son_float convert_meas_bw_in_db(son_u8 meas_bw)
 *  \brief This function is used to convert number of RBs into their DB
 *      equivalent.
 *  \param meas_bw    Index value received
 */
son_float
convert_meas_bw_in_db
(
    son_u8 meas_bw
);

/*! \fn son_bool_et son_is_timer_running(son_timer_t timer)
 *  \brief This function is called to check whether the timer is running or it has already expired. User is recommended to use this function before stopping the timer using son_stop_timer.
 *  \param timer    Timer Id as allocated by the CSPL
 */
son_bool_et
son_is_timer_running
(
    son_timer_t timer
);

extern son_u32
son_convert_char_cell_id_to_int_cell_id
(
    son_u8 *cell_id
);

extern son_u32
son_convert_const_char_cell_id_to_int_cell_id
(
    const son_u8 *cell_id
);

son_return_et
son_send_oam_notification
(
    son_oam_event_class_et event_type,
    son_oam_event_subclass_et event_sub_type,
    son_u16 event_id,
    son_oam_error_info_t error_info
);

/*! \fn son_void_t son_oam_set_thread_status(son_u8 thread_id)
 *  \brief              This function sets the status of the thread id 
 *                      with the current timestamp 
 *  \param thread_id    Thread Id of the thread
 */
son_void_t
son_oam_set_thread_status
(
 son_u8  thread_id
 );

/*! \fn son_return_et son_oam_get_thread_status(son_u8 thread_id)
 *  \brief              This function gets the status of all the threads 
 *  \param time_prd     Health monitoring update timer period
 */
son_return_et
son_oam_get_thread_status
(
 son_u16   time_prd
 );

/*! \fn son_return_et parse_and_store_son_oam_cfg_params()
 *  \brief            Read cfg params from file and store them in 
 *                    global configuration structure
 *  \param            NONE
 */
/* + SPR 17439 */
son_return_et parse_and_store_son_oam_cfg_params(void);
/* - SPR 17439 */

/*! \enum son_app_mode_e
 *  \brief The enum indicates cfg param type
 */
typedef enum son_param_type_et
{
    CHAR_TYPE,
    U32_TYPE,
    U16_TYPE,
    ARR_TYPE,
    NO_TYPE
}son_param_type_et;


/*! \fn son_float son_nearbyintf(son_float value)
 *  \brief This is the SON wrapper function of C library function nearbyintf().
 *  \param value    Argument to be rounded off
 */
son_float
son_nearbyintf
(
    son_float value
);

/*! \fn son_float son_fabsf(son_float value)
 *  \brief This is the SON wrapper function of C library function fabsf().
 *  \param value    Floating-point number whose absolute value is needed
 */
son_float
son_fabsf
(
    son_float value
);

/*! \fn son_float son_roundf(son_float value)
 *  \brief This is the SON wrapper function of C library function roundf().
 *  \param value    Value to be rounded off
 */
son_float
son_roundf
(
    son_float value
);

/*! \fn struct tm * son_localtime(const time_t *p_timer)
 *  \brief This is the SON wrapper function of C library function localtime().
 *  \param p_timer  Calendar time
 */
struct tm *
son_localtime
(
    const time_t *p_timer
);

/*! \fn time_t son_time(time_t *p_value)
 *  \brief This is the SON wrapper function of C library function time().
 *  \param p_value  The value of time in seconds since the Epoch
 */
time_t
son_time
(
    time_t *p_value
);

/*! \fn son_s32 son_gettimeofday(struct timeval *p_time, son_void_t *p_timezone)
 *  \brief This is the SON wrapper function of C library function gettimeofday().
 *  \param p_time       Number of seconds and microseconds since the Epoch
 *  \param p_timezone   timezone structure (obsolete now)
 */
son_s32
son_gettimeofday
(
    struct timeval  *p_time,
    struct timezone *p_timezone
);

/*! \fn son_double son_difftime(time_t time1, time_t time0)
 *  \brief This is the SON wrapper function of C library function difftime();
 *  \param time1    1st calendar  time
 *  \param time0    2nd calendar  time
 */
son_double
son_difftime
(
    time_t time1,
    time_t time0
);

/*! \fn son_s32 son_atoi(const son_8 *p_value)
 *  \brief This is the SON wrapper function of C library function atoi().
 *  \param p_value  Pointer to the input string
 */
son_s32 
son_atoi
(
    const son_8 *p_value
);

/*! \fn son_s32 son_inet_pton(son_s32 af, const son_8 *p_src, son_void_t  *p_dst)
 *  \brief This is the SON wrapper function of C library function inet_pton().
 *  \param af       The family of the address
 *  \param p_src    Pointer to the string being  passed in
 *  \param p_dst    Pointer to a buffer into which the function stores the numeric address
 */
son_s32 
son_inet_pton
(
    son_s32     af, 
    const son_8 *p_src, 
    son_void_t  *p_dst
);

/*! \fn const son_8 * son_inet_ntop(son_s32 af, const son_void_t *p_src, son_8 *p_dst, socklen_t size)
 *  \brief This is the SON wrapper function of C library function inet_ntop().
 *  \param af       The family of the address.
 *  \param p_src    Pointer to the buffer holding an IPv4 address if the af argument is AF_INET, or an IPv6  address if  the  af argument is AF_INET6
 *  \param p_dst    Pointer to a buffer which stores the resulting  text string
 *  \param size     Size of the buffer
 */
const son_8 *
son_inet_ntop
(
    son_s32             af, 
    const son_void_t    *p_src,
    son_8               *p_dst, 
    socklen_t           size
);

/*! \fn son_u32 son_ntohl(son_u32 netlong)
 *  \brief This is the SON wrapper function of C library function ntohl().
 *  \param netlong  Value in network byte order
 */
son_u32
son_ntohl
(
    son_u32 netlong
);

/*! \fn son_s32 son_sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *p_mask) 
 *  \brief This is the SON wrapper function of C library function sched_setaffinity().
 *  \param pid          process ID
 *  \param cpusetsize   length (in bytes) of the data pointed to by mask
 *  \param p_mask       Pointer to the mask value to be set
 */
son_s32
son_sched_setaffinity
(
    pid_t       pid,
    size_t      cpusetsize,
    cpu_set_t   *p_mask
);

/*! \fn son_8 * son_fgets(son_8 *p_out_buf, son_s32 size, FILE *p_stream)
 *  \brief This is the SON wrapper function of C library function fgets().
 *  \param p_out_buf    Pointer to the output buffer    
 *  \param size         1 less then the number of characters to be read
 *  \param p_stream     Pointer to the stream to be read
 */
son_8 *
son_fgets
(
    son_8   *p_out_buf, 
    son_s32 size, 
    FILE    *p_stream
);

/* Rel 3.0 Cell delete support changes Start */

/*! \fn son_void_t son_insert_txn_id_in_temp_txn_id_list(son_u16 txn_id)
 *  \brief This is the helper function to insert transaction ids in temporary transaction id list. It is used to store txn id of de-register request triggered towards rrm due to cell deletion request from oam.
 *  \param txn_id   Transaction Id
 */
son_void_t
son_insert_txn_id_in_temp_txn_id_list
(
    son_u16 txn_id
);

/*! \fn son_return_et son_find_txn_id_in_temp_txn_id_list(son_u16 txn_id) 
 *  \brief This is the helper function to find and delete transactio Ids from temporary transaction Id list (Used to store txn Id of de-register request triggered towards rrm due to cell deletion request from oam.
 *  \param txn_id   Transaction Id
 */
son_return_et
son_find_txn_id_in_temp_txn_id_list
(
    son_u16 txn_id
);
/* Rel 3.0 Cell delete support changes Stop */

/*SPR-11554-Start*/

/*! \fn son_determine_pci_range_end_value
 *  \brief This function is used to calculate the pci range end value
 *  \param pci_range pci range
 */
son_u16
son_determine_pci_range_end_value
(
 son_oam_cell_id_range_et   pci_range
 );

/*SPR-11554-End*/

/*!
 *   \fn son_get_module 
 *   \brief This Function returns module name
 *   \param son_module_id_t  moduleId
 */
const char* son_get_module(son_module_id_t  moduleId); 

/*!
 *   \fn son_get_msg_api_name 
 *   \brief This Function returns api name
 *   \param U16 apiId
 *   \param son_module_id_t moduleId
 */
const char* son_get_msg_api_name(U16 apiId, son_module_id_t moduleId); 


/* SPR-18735 START */
/* Spr 17753 Changes Start */
/*! \fn  son_u32 son_anr_get_random_val(
 *                          son_u32 start_val,
 *                          son_u32 end_val
 *                          );
 *  \brief This function return the random value 
 *         between start_val and end_val value   
 *  \param start_val - starting value  
 *  \param end_val   - end value
 */
son_u32
son_anr_get_random_val
(
 son_u32 start_val,
 son_u32 end_val
 );
/* Spr 17753 Changes End */

#endif /* _SON_UTILS_H_ */
