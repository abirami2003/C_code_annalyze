/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.5, Date: 23-Oct-2013.
 */
#include "sibParsing.h"
#include "rtsrc/rtPrint.h"
#include "rtxsrc/rtxCommon.h"

static const OSEnumItem MasterInformationBlock_dl_Bandwidth_ENUMTAB[] = {
   { OSUTF8("n100"), 5, 4, 4 },
   { OSUTF8("n15"), 1, 3, 1 },
   { OSUTF8("n25"), 2, 3, 2 },
   { OSUTF8("n50"), 3, 3, 3 },
   { OSUTF8("n6"), 0, 2, 5 },
   { OSUTF8("n75"), 4, 3, 0 }
} ;
#define MasterInformationBlock_dl_Bandwidth_ENUMTABSIZE 6

const OSUTF8CHAR* MasterInformationBlock_dl_Bandwidth_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MasterInformationBlock_dl_Bandwidth_ENUMTABSIZE) {
      return MasterInformationBlock_dl_Bandwidth_ENUMTAB
         [MasterInformationBlock_dl_Bandwidth_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MasterInformationBlock_dl_Bandwidth_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, MasterInformationBlock_dl_Bandwidth* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MasterInformationBlock_dl_Bandwidth_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MasterInformationBlock_dl_Bandwidth_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MasterInformationBlock_dl_Bandwidth* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MasterInformationBlock_dl_Bandwidth_ENUMTAB, 
      MasterInformationBlock_dl_Bandwidth_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MasterInformationBlock_dl_Bandwidth)
         MasterInformationBlock_dl_Bandwidth_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MasterInformationBlock_dl_Bandwidth (OSCTXT* pctxt, MasterInformationBlock_dl_Bandwidth value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MasterInformationBlock_dl_Bandwidth"));

   if (value >= 6) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MasterInformationBlock_dl_Bandwidth (OSCTXT* pctxt, MasterInformationBlock_dl_Bandwidth* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem PHICH_Config_phich_Duration_ENUMTAB[] = {
   { OSUTF8("extended"), 1, 8, 1 },
   { OSUTF8("normal"), 0, 6, 0 }
} ;
#define PHICH_Config_phich_Duration_ENUMTABSIZE 2

const OSUTF8CHAR* PHICH_Config_phich_Duration_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PHICH_Config_phich_Duration_ENUMTABSIZE) {
      return PHICH_Config_phich_Duration_ENUMTAB
         [PHICH_Config_phich_Duration_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PHICH_Config_phich_Duration_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PHICH_Config_phich_Duration* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PHICH_Config_phich_Duration_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PHICH_Config_phich_Duration_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PHICH_Config_phich_Duration* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PHICH_Config_phich_Duration_ENUMTAB, 
      PHICH_Config_phich_Duration_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PHICH_Config_phich_Duration)
         PHICH_Config_phich_Duration_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PHICH_Config_phich_Duration (OSCTXT* pctxt, PHICH_Config_phich_Duration value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PHICH_Config_phich_Duration"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PHICH_Config_phich_Duration (OSCTXT* pctxt, PHICH_Config_phich_Duration* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem PHICH_Config_phich_Resource_ENUMTAB[] = {
   { OSUTF8("half"), 1, 4, 2 },
   { OSUTF8("one"), 2, 3, 0 },
   { OSUTF8("oneSixth"), 0, 8, 1 },
   { OSUTF8("two"), 3, 3, 3 }
} ;
#define PHICH_Config_phich_Resource_ENUMTABSIZE 4

const OSUTF8CHAR* PHICH_Config_phich_Resource_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PHICH_Config_phich_Resource_ENUMTABSIZE) {
      return PHICH_Config_phich_Resource_ENUMTAB
         [PHICH_Config_phich_Resource_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PHICH_Config_phich_Resource_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PHICH_Config_phich_Resource* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PHICH_Config_phich_Resource_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PHICH_Config_phich_Resource_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PHICH_Config_phich_Resource* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PHICH_Config_phich_Resource_ENUMTAB, 
      PHICH_Config_phich_Resource_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PHICH_Config_phich_Resource)
         PHICH_Config_phich_Resource_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PHICH_Config_phich_Resource (OSCTXT* pctxt, PHICH_Config_phich_Resource value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PHICH_Config_phich_Resource"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PHICH_Config_phich_Resource (OSCTXT* pctxt, PHICH_Config_phich_Resource* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_PHICH_Config (OSCTXT* pctxt, PHICH_Config* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PHICH-Config");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PHICH_Config"));

   /* encode phich_Duration */

   RTXCTXTPUSHELEMNAME (pctxt, "phich-Duration");

   stat = asn1PE_PHICH_Config_phich_Duration (pctxt, pvalue->phich_Duration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode phich_Resource */

   RTXCTXTPUSHELEMNAME (pctxt, "phich-Resource");

   stat = asn1PE_PHICH_Config_phich_Resource (pctxt, pvalue->phich_Resource);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PHICH_Config (OSCTXT* pctxt, PHICH_Config* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PHICH-Config");

   /* decode root elements */
   /* decode phich_Duration */
   RTXCTXTPUSHELEMNAME (pctxt, "phich-Duration");

   stat = asn1PD_PHICH_Config_phich_Duration (pctxt, &pvalue->phich_Duration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode phich_Resource */
   RTXCTXTPUSHELEMNAME (pctxt, "phich-Resource");

   stat = asn1PD_PHICH_Config_phich_Resource (pctxt, &pvalue->phich_Resource);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_MasterInformationBlock (OSCTXT* pctxt, MasterInformationBlock* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MasterInformationBlock");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MasterInformationBlock"));

   /* encode dl_Bandwidth */

   RTXCTXTPUSHELEMNAME (pctxt, "dl-Bandwidth");

   stat = asn1PE_MasterInformationBlock_dl_Bandwidth (pctxt, pvalue->dl_Bandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode phich_Config */

   RTXCTXTPUSHELEMNAME (pctxt, "phich-Config");

   stat = asn1PE_PHICH_Config (pctxt, &pvalue->phich_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode systemFrameNumber */

   RTXCTXTPUSHELEMNAME (pctxt, "systemFrameNumber");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->systemFrameNumber, OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(10), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->spare, OSUINTCONST(10), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MasterInformationBlock (OSCTXT* pctxt, MasterInformationBlock* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MasterInformationBlock");

   /* decode root elements */
   /* decode dl_Bandwidth */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-Bandwidth");

   stat = asn1PD_MasterInformationBlock_dl_Bandwidth (pctxt, &pvalue->dl_Bandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode phich_Config */
   RTXCTXTPUSHELEMNAME (pctxt, "phich-Config");

   stat = asn1PD_PHICH_Config (pctxt, &pvalue->phich_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode systemFrameNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "systemFrameNumber");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->systemFrameNumber
      , OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode spare */
   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(10), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->spare
      , OSUINTCONST(10), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MasterInformationBlock (MasterInformationBlock* pvalue)
{
   if (0 == pvalue) return;
   pvalue->systemFrameNumber.numbits = 0;
   pvalue->spare.numbits = 0;
}

EXTERN int asn1PE_BCCH_BCH_MessageType (OSCTXT* pctxt, BCCH_BCH_MessageType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BCCH-BCH-MessageType");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BCCH_BCH_MessageType"));

   stat = asn1PE_MasterInformationBlock (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BCCH_BCH_MessageType (OSCTXT* pctxt, BCCH_BCH_MessageType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BCCH-BCH-MessageType");

   stat = asn1PD_MasterInformationBlock (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_BCCH_BCH_MessageType (BCCH_BCH_MessageType* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_MasterInformationBlock (pvalue);
}

EXTERN int asn1PE_IMSI_Digit (OSCTXT* pctxt, IMSI_Digit value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IMSI-Digit");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IMSI_Digit"));

   if ( (value <= OSUINTCONST(9)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(9));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IMSI_Digit (OSCTXT* pctxt, IMSI_Digit* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IMSI-Digit");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(9));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ReestablishmentCause_ENUMTAB[] = {
   { OSUTF8("handoverFailure"), 1, 15, 2 },
   { OSUTF8("otherFailure"), 2, 12, 0 },
   { OSUTF8("reconfigurationFailure"), 0, 22, 1 },
   { OSUTF8("spare1"), 3, 6, 3 }
} ;
#define ReestablishmentCause_ENUMTABSIZE 4

const OSUTF8CHAR* ReestablishmentCause_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ReestablishmentCause_ENUMTABSIZE) {
      return ReestablishmentCause_ENUMTAB
         [ReestablishmentCause_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReestablishmentCause_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ReestablishmentCause* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ReestablishmentCause_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ReestablishmentCause_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ReestablishmentCause* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ReestablishmentCause_ENUMTAB, 
      ReestablishmentCause_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReestablishmentCause)ReestablishmentCause_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ReestablishmentCause (OSCTXT* pctxt, ReestablishmentCause value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReestablishmentCause");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReestablishmentCause"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReestablishmentCause (OSCTXT* pctxt, ReestablishmentCause* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReestablishmentCause");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ReleaseCause_ENUMTAB[] = {
   { OSUTF8("loadBalancingTAUrequired"), 0, 24, 0 },
   { OSUTF8("other"), 1, 5, 1 },
   { OSUTF8("spare1"), 3, 6, 3 },
   { OSUTF8("spare2"), 2, 6, 2 }
} ;
#define ReleaseCause_ENUMTABSIZE 4

const OSUTF8CHAR* ReleaseCause_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ReleaseCause_ENUMTABSIZE) {
      return ReleaseCause_ENUMTAB[ReleaseCause_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReleaseCause_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ReleaseCause* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ReleaseCause_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ReleaseCause_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ReleaseCause* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ReleaseCause_ENUMTAB, 
      ReleaseCause_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReleaseCause)ReleaseCause_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ReleaseCause (OSCTXT* pctxt, ReleaseCause value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReleaseCause");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReleaseCause"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReleaseCause (OSCTXT* pctxt, ReleaseCause* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReleaseCause");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem EstablishmentCause_ENUMTAB[] = {
   { OSUTF8("emergency"), 0, 9, 0 },
   { OSUTF8("highPriorityAccess"), 1, 18, 1 },
   { OSUTF8("mo-Data"), 4, 7, 4 },
   { OSUTF8("mo-Signalling"), 3, 13, 3 },
   { OSUTF8("mt-Access"), 2, 9, 2 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 }
} ;
#define EstablishmentCause_ENUMTABSIZE 8

const OSUTF8CHAR* EstablishmentCause_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < EstablishmentCause_ENUMTABSIZE) {
      return EstablishmentCause_ENUMTAB
         [EstablishmentCause_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int EstablishmentCause_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, EstablishmentCause* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return EstablishmentCause_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int EstablishmentCause_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, EstablishmentCause* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, EstablishmentCause_ENUMTAB, 
      EstablishmentCause_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (EstablishmentCause)EstablishmentCause_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_EstablishmentCause (OSCTXT* pctxt, EstablishmentCause value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EstablishmentCause");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("EstablishmentCause"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_EstablishmentCause (OSCTXT* pctxt, EstablishmentCause* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EstablishmentCause");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem SIB_Type_ENUMTAB[] = {
   { OSUTF8("sibType10"), 7, 9, 4 },
   { OSUTF8("sibType11"), 8, 9, 5 },
   { OSUTF8("sibType12-v920"), 9, 14, 6 },
   { OSUTF8("sibType13-v920"), 10, 14, 7 },
   { OSUTF8("sibType3"), 0, 8, 8 },
   { OSUTF8("sibType4"), 1, 8, 9 },
   { OSUTF8("sibType5"), 2, 8, 10 },
   { OSUTF8("sibType6"), 3, 8, 0 },
   { OSUTF8("sibType7"), 4, 8, 1 },
   { OSUTF8("sibType8"), 5, 8, 2 },
   { OSUTF8("sibType9"), 6, 8, 3 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 }
} ;
#define SIB_Type_ENUMTABSIZE 16

const OSUTF8CHAR* SIB_Type_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SIB_Type_ENUMTABSIZE) {
      return SIB_Type_ENUMTAB[SIB_Type_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SIB_Type_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SIB_Type* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SIB_Type_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SIB_Type_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, SIB_Type* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, SIB_Type_ENUMTAB, 
      SIB_Type_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SIB_Type)SIB_Type_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SIB_Type (OSCTXT* pctxt, SIB_Type value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SIB-Type");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SIB_Type"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SIB_Type (OSCTXT* pctxt, SIB_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SIB-Type");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_DRB_Identity (OSCTXT* pctxt, DRB_Identity value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-Identity");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRB_Identity"));

   if ( (value >= OSUINTCONST(1) && value <= OSUINTCONST(32)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(32));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRB_Identity (OSCTXT* pctxt, DRB_Identity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-Identity");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_P_Max (OSCTXT* pctxt, P_Max value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "P-Max");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("P_Max"));

   if ( (value >= OSINTCONST(-30) && value <= OSINTCONST(33)) ) {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-30), OSINTCONST(33));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_P_Max (OSCTXT* pctxt, P_Max* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "P-Max");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-30), OSINTCONST(33));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PresenceAntennaPort1 (OSCTXT* pctxt, PresenceAntennaPort1 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PresenceAntennaPort1");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PresenceAntennaPort1"));

   stat = rtxEncBit (pctxt, (OSBOOL)value);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PresenceAntennaPort1 (OSCTXT* pctxt, PresenceAntennaPort1* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PresenceAntennaPort1");

   stat = DEC_BIT (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem UL_CyclicPrefixLength_ENUMTAB[] = {
   { OSUTF8("len1"), 0, 4, 0 },
   { OSUTF8("len2"), 1, 4, 1 }
} ;
#define UL_CyclicPrefixLength_ENUMTABSIZE 2

const OSUTF8CHAR* UL_CyclicPrefixLength_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < UL_CyclicPrefixLength_ENUMTABSIZE) {
      return UL_CyclicPrefixLength_ENUMTAB
         [UL_CyclicPrefixLength_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UL_CyclicPrefixLength_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, UL_CyclicPrefixLength* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return UL_CyclicPrefixLength_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int UL_CyclicPrefixLength_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, UL_CyclicPrefixLength* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      UL_CyclicPrefixLength_ENUMTAB, UL_CyclicPrefixLength_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UL_CyclicPrefixLength)
         UL_CyclicPrefixLength_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_UL_CyclicPrefixLength (OSCTXT* pctxt, UL_CyclicPrefixLength value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CyclicPrefixLength");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UL_CyclicPrefixLength"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_CyclicPrefixLength (OSCTXT* pctxt, UL_CyclicPrefixLength* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CyclicPrefixLength");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem SN_FieldLength_ENUMTAB[] = {
   { OSUTF8("size10"), 1, 6, 1 },
   { OSUTF8("size5"), 0, 5, 0 }
} ;
#define SN_FieldLength_ENUMTABSIZE 2

const OSUTF8CHAR* SN_FieldLength_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SN_FieldLength_ENUMTABSIZE) {
      return SN_FieldLength_ENUMTAB
         [SN_FieldLength_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SN_FieldLength_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SN_FieldLength* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SN_FieldLength_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SN_FieldLength_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, SN_FieldLength* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, SN_FieldLength_ENUMTAB, 
      SN_FieldLength_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SN_FieldLength)SN_FieldLength_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SN_FieldLength (OSCTXT* pctxt, SN_FieldLength value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SN-FieldLength");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SN_FieldLength"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SN_FieldLength (OSCTXT* pctxt, SN_FieldLength* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SN-FieldLength");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem T_PollRetransmit_ENUMTAB[] = {
   { OSUTF8("ms10"), 1, 4, 43 },
   { OSUTF8("ms100"), 19, 5, 0 },
   { OSUTF8("ms105"), 20, 5, 11 },
   { OSUTF8("ms110"), 21, 5, 22 },
   { OSUTF8("ms115"), 22, 5, 33 },
   { OSUTF8("ms120"), 23, 5, 35 },
   { OSUTF8("ms125"), 24, 5, 37 },
   { OSUTF8("ms130"), 25, 5, 39 },
   { OSUTF8("ms135"), 26, 5, 41 },
   { OSUTF8("ms140"), 27, 5, 44 },
   { OSUTF8("ms145"), 28, 5, 46 },
   { OSUTF8("ms15"), 2, 4, 47 },
   { OSUTF8("ms150"), 29, 5, 48 },
   { OSUTF8("ms155"), 30, 5, 49 },
   { OSUTF8("ms160"), 31, 5, 50 },
   { OSUTF8("ms165"), 32, 5, 51 },
   { OSUTF8("ms170"), 33, 5, 52 },
   { OSUTF8("ms175"), 34, 5, 53 },
   { OSUTF8("ms180"), 35, 5, 54 },
   { OSUTF8("ms185"), 36, 5, 1 },
   { OSUTF8("ms190"), 37, 5, 2 },
   { OSUTF8("ms195"), 38, 5, 3 },
   { OSUTF8("ms20"), 3, 4, 4 },
   { OSUTF8("ms200"), 39, 5, 5 },
   { OSUTF8("ms205"), 40, 5, 6 },
   { OSUTF8("ms210"), 41, 5, 7 },
   { OSUTF8("ms215"), 42, 5, 8 },
   { OSUTF8("ms220"), 43, 5, 9 },
   { OSUTF8("ms225"), 44, 5, 10 },
   { OSUTF8("ms230"), 45, 5, 12 },
   { OSUTF8("ms235"), 46, 5, 13 },
   { OSUTF8("ms240"), 47, 5, 14 },
   { OSUTF8("ms245"), 48, 5, 15 },
   { OSUTF8("ms25"), 4, 4, 16 },
   { OSUTF8("ms250"), 49, 5, 17 },
   { OSUTF8("ms30"), 5, 4, 18 },
   { OSUTF8("ms300"), 50, 5, 19 },
   { OSUTF8("ms35"), 6, 4, 20 },
   { OSUTF8("ms350"), 51, 5, 21 },
   { OSUTF8("ms40"), 7, 4, 23 },
   { OSUTF8("ms400"), 52, 5, 24 },
   { OSUTF8("ms45"), 8, 4, 25 },
   { OSUTF8("ms450"), 53, 5, 26 },
   { OSUTF8("ms5"), 0, 3, 27 },
   { OSUTF8("ms50"), 9, 4, 28 },
   { OSUTF8("ms500"), 54, 5, 29 },
   { OSUTF8("ms55"), 10, 4, 30 },
   { OSUTF8("ms60"), 11, 4, 31 },
   { OSUTF8("ms65"), 12, 4, 32 },
   { OSUTF8("ms70"), 13, 4, 34 },
   { OSUTF8("ms75"), 14, 4, 36 },
   { OSUTF8("ms80"), 15, 4, 38 },
   { OSUTF8("ms85"), 16, 4, 40 },
   { OSUTF8("ms90"), 17, 4, 42 },
   { OSUTF8("ms95"), 18, 4, 45 },
   { OSUTF8("spare1"), 63, 6, 63 },
   { OSUTF8("spare2"), 62, 6, 62 },
   { OSUTF8("spare3"), 61, 6, 61 },
   { OSUTF8("spare4"), 60, 6, 60 },
   { OSUTF8("spare5"), 59, 6, 59 },
   { OSUTF8("spare6"), 58, 6, 58 },
   { OSUTF8("spare7"), 57, 6, 57 },
   { OSUTF8("spare8"), 56, 6, 56 },
   { OSUTF8("spare9"), 55, 6, 55 }
} ;
#define T_PollRetransmit_ENUMTABSIZE 64

const OSUTF8CHAR* T_PollRetransmit_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < T_PollRetransmit_ENUMTABSIZE) {
      return T_PollRetransmit_ENUMTAB
         [T_PollRetransmit_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int T_PollRetransmit_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, T_PollRetransmit* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return T_PollRetransmit_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int T_PollRetransmit_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, T_PollRetransmit* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, T_PollRetransmit_ENUMTAB, 
      T_PollRetransmit_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (T_PollRetransmit)T_PollRetransmit_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_T_PollRetransmit (OSCTXT* pctxt, T_PollRetransmit value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "T-PollRetransmit");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("T_PollRetransmit"));

   if (value >= 64) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_T_PollRetransmit (OSCTXT* pctxt, T_PollRetransmit* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "T-PollRetransmit");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem PollPDU_ENUMTAB[] = {
   { OSUTF8("p128"), 5, 4, 4 },
   { OSUTF8("p16"), 2, 3, 6 },
   { OSUTF8("p256"), 6, 4, 1 },
   { OSUTF8("p32"), 3, 3, 3 },
   { OSUTF8("p4"), 0, 2, 5 },
   { OSUTF8("p64"), 4, 3, 0 },
   { OSUTF8("p8"), 1, 2, 2 },
   { OSUTF8("pInfinity"), 7, 9, 7 }
} ;
#define PollPDU_ENUMTABSIZE 8

const OSUTF8CHAR* PollPDU_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PollPDU_ENUMTABSIZE) {
      return PollPDU_ENUMTAB[PollPDU_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PollPDU_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PollPDU* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PollPDU_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PollPDU_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, PollPDU* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, PollPDU_ENUMTAB, 
      PollPDU_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PollPDU)PollPDU_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PollPDU (OSCTXT* pctxt, PollPDU value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PollPDU");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PollPDU"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PollPDU (OSCTXT* pctxt, PollPDU* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PollPDU");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem PollByte_ENUMTAB[] = {
   { OSUTF8("kB100"), 3, 5, 6 },
   { OSUTF8("kB1000"), 9, 6, 10 },
   { OSUTF8("kB125"), 4, 5, 12 },
   { OSUTF8("kB1250"), 10, 6, 0 },
   { OSUTF8("kB1500"), 11, 6, 2 },
   { OSUTF8("kB2000"), 12, 6, 7 },
   { OSUTF8("kB25"), 0, 4, 9 },
   { OSUTF8("kB250"), 5, 5, 11 },
   { OSUTF8("kB3000"), 13, 6, 13 },
   { OSUTF8("kB375"), 6, 5, 1 },
   { OSUTF8("kB50"), 1, 4, 3 },
   { OSUTF8("kB500"), 7, 5, 4 },
   { OSUTF8("kB75"), 2, 4, 5 },
   { OSUTF8("kB750"), 8, 5, 8 },
   { OSUTF8("kBinfinity"), 14, 10, 14 },
   { OSUTF8("spare1"), 15, 6, 15 }
} ;
#define PollByte_ENUMTABSIZE 16

const OSUTF8CHAR* PollByte_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PollByte_ENUMTABSIZE) {
      return PollByte_ENUMTAB[PollByte_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PollByte_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PollByte* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PollByte_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PollByte_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, PollByte* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, PollByte_ENUMTAB, 
      PollByte_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PollByte)PollByte_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PollByte (OSCTXT* pctxt, PollByte value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PollByte");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PollByte"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PollByte (OSCTXT* pctxt, PollByte* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PollByte");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem T_Reordering_ENUMTAB[] = {
   { OSUTF8("ms0"), 0, 3, 0 },
   { OSUTF8("ms10"), 2, 4, 20 },
   { OSUTF8("ms100"), 20, 5, 1 },
   { OSUTF8("ms110"), 21, 5, 7 },
   { OSUTF8("ms120"), 22, 5, 13 },
   { OSUTF8("ms130"), 23, 5, 15 },
   { OSUTF8("ms140"), 24, 5, 16 },
   { OSUTF8("ms15"), 3, 4, 17 },
   { OSUTF8("ms150"), 25, 5, 18 },
   { OSUTF8("ms160"), 26, 5, 19 },
   { OSUTF8("ms170"), 27, 5, 21 },
   { OSUTF8("ms180"), 28, 5, 22 },
   { OSUTF8("ms190"), 29, 5, 23 },
   { OSUTF8("ms20"), 4, 4, 24 },
   { OSUTF8("ms200"), 30, 5, 25 },
   { OSUTF8("ms25"), 5, 4, 26 },
   { OSUTF8("ms30"), 6, 4, 27 },
   { OSUTF8("ms35"), 7, 4, 28 },
   { OSUTF8("ms40"), 8, 4, 29 },
   { OSUTF8("ms45"), 9, 4, 30 },
   { OSUTF8("ms5"), 1, 3, 2 },
   { OSUTF8("ms50"), 10, 4, 3 },
   { OSUTF8("ms55"), 11, 4, 4 },
   { OSUTF8("ms60"), 12, 4, 5 },
   { OSUTF8("ms65"), 13, 4, 6 },
   { OSUTF8("ms70"), 14, 4, 8 },
   { OSUTF8("ms75"), 15, 4, 9 },
   { OSUTF8("ms80"), 16, 4, 10 },
   { OSUTF8("ms85"), 17, 4, 11 },
   { OSUTF8("ms90"), 18, 4, 12 },
   { OSUTF8("ms95"), 19, 4, 14 },
   { OSUTF8("spare1"), 31, 6, 31 }
} ;
#define T_Reordering_ENUMTABSIZE 32

const OSUTF8CHAR* T_Reordering_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < T_Reordering_ENUMTABSIZE) {
      return T_Reordering_ENUMTAB[T_Reordering_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int T_Reordering_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, T_Reordering* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return T_Reordering_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int T_Reordering_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, T_Reordering* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, T_Reordering_ENUMTAB, 
      T_Reordering_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (T_Reordering)T_Reordering_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_T_Reordering (OSCTXT* pctxt, T_Reordering value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "T-Reordering");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("T_Reordering"));

   if (value >= 32) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(31));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_T_Reordering (OSCTXT* pctxt, T_Reordering* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "T-Reordering");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(31));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem T_StatusProhibit_ENUMTAB[] = {
   { OSUTF8("ms0"), 0, 3, 0 },
   { OSUTF8("ms10"), 2, 4, 44 },
   { OSUTF8("ms100"), 20, 5, 1 },
   { OSUTF8("ms105"), 21, 5, 12 },
   { OSUTF8("ms110"), 22, 5, 23 },
   { OSUTF8("ms115"), 23, 5, 34 },
   { OSUTF8("ms120"), 24, 5, 36 },
   { OSUTF8("ms125"), 25, 5, 38 },
   { OSUTF8("ms130"), 26, 5, 40 },
   { OSUTF8("ms135"), 27, 5, 42 },
   { OSUTF8("ms140"), 28, 5, 45 },
   { OSUTF8("ms145"), 29, 5, 47 },
   { OSUTF8("ms15"), 3, 4, 48 },
   { OSUTF8("ms150"), 30, 5, 49 },
   { OSUTF8("ms155"), 31, 5, 50 },
   { OSUTF8("ms160"), 32, 5, 51 },
   { OSUTF8("ms165"), 33, 5, 52 },
   { OSUTF8("ms170"), 34, 5, 53 },
   { OSUTF8("ms175"), 35, 5, 54 },
   { OSUTF8("ms180"), 36, 5, 55 },
   { OSUTF8("ms185"), 37, 5, 2 },
   { OSUTF8("ms190"), 38, 5, 3 },
   { OSUTF8("ms195"), 39, 5, 4 },
   { OSUTF8("ms20"), 4, 4, 5 },
   { OSUTF8("ms200"), 40, 5, 6 },
   { OSUTF8("ms205"), 41, 5, 7 },
   { OSUTF8("ms210"), 42, 5, 8 },
   { OSUTF8("ms215"), 43, 5, 9 },
   { OSUTF8("ms220"), 44, 5, 10 },
   { OSUTF8("ms225"), 45, 5, 11 },
   { OSUTF8("ms230"), 46, 5, 13 },
   { OSUTF8("ms235"), 47, 5, 14 },
   { OSUTF8("ms240"), 48, 5, 15 },
   { OSUTF8("ms245"), 49, 5, 16 },
   { OSUTF8("ms25"), 5, 4, 17 },
   { OSUTF8("ms250"), 50, 5, 18 },
   { OSUTF8("ms30"), 6, 4, 19 },
   { OSUTF8("ms300"), 51, 5, 20 },
   { OSUTF8("ms35"), 7, 4, 21 },
   { OSUTF8("ms350"), 52, 5, 22 },
   { OSUTF8("ms40"), 8, 4, 24 },
   { OSUTF8("ms400"), 53, 5, 25 },
   { OSUTF8("ms45"), 9, 4, 26 },
   { OSUTF8("ms450"), 54, 5, 27 },
   { OSUTF8("ms5"), 1, 3, 28 },
   { OSUTF8("ms50"), 10, 4, 29 },
   { OSUTF8("ms500"), 55, 5, 30 },
   { OSUTF8("ms55"), 11, 4, 31 },
   { OSUTF8("ms60"), 12, 4, 32 },
   { OSUTF8("ms65"), 13, 4, 33 },
   { OSUTF8("ms70"), 14, 4, 35 },
   { OSUTF8("ms75"), 15, 4, 37 },
   { OSUTF8("ms80"), 16, 4, 39 },
   { OSUTF8("ms85"), 17, 4, 41 },
   { OSUTF8("ms90"), 18, 4, 43 },
   { OSUTF8("ms95"), 19, 4, 46 },
   { OSUTF8("spare1"), 63, 6, 63 },
   { OSUTF8("spare2"), 62, 6, 62 },
   { OSUTF8("spare3"), 61, 6, 61 },
   { OSUTF8("spare4"), 60, 6, 60 },
   { OSUTF8("spare5"), 59, 6, 59 },
   { OSUTF8("spare6"), 58, 6, 58 },
   { OSUTF8("spare7"), 57, 6, 57 },
   { OSUTF8("spare8"), 56, 6, 56 }
} ;
#define T_StatusProhibit_ENUMTABSIZE 64

const OSUTF8CHAR* T_StatusProhibit_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < T_StatusProhibit_ENUMTABSIZE) {
      return T_StatusProhibit_ENUMTAB
         [T_StatusProhibit_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int T_StatusProhibit_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, T_StatusProhibit* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return T_StatusProhibit_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int T_StatusProhibit_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, T_StatusProhibit* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, T_StatusProhibit_ENUMTAB, 
      T_StatusProhibit_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (T_StatusProhibit)T_StatusProhibit_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_T_StatusProhibit (OSCTXT* pctxt, T_StatusProhibit value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "T-StatusProhibit");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("T_StatusProhibit"));

   if (value >= 64) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_T_StatusProhibit (OSCTXT* pctxt, T_StatusProhibit* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "T-StatusProhibit");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem TimeAlignmentTimer_ENUMTAB[] = {
   { OSUTF8("infinity"), 7, 8, 5 },
   { OSUTF8("sf10240"), 6, 7, 7 },
   { OSUTF8("sf1280"), 2, 6, 2 },
   { OSUTF8("sf1920"), 3, 6, 3 },
   { OSUTF8("sf2560"), 4, 6, 4 },
   { OSUTF8("sf500"), 0, 5, 6 },
   { OSUTF8("sf5120"), 5, 6, 1 },
   { OSUTF8("sf750"), 1, 5, 0 }
} ;
#define TimeAlignmentTimer_ENUMTABSIZE 8

const OSUTF8CHAR* TimeAlignmentTimer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < TimeAlignmentTimer_ENUMTABSIZE) {
      return TimeAlignmentTimer_ENUMTAB
         [TimeAlignmentTimer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int TimeAlignmentTimer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, TimeAlignmentTimer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return TimeAlignmentTimer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int TimeAlignmentTimer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, TimeAlignmentTimer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, TimeAlignmentTimer_ENUMTAB, 
      TimeAlignmentTimer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (TimeAlignmentTimer)TimeAlignmentTimer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_TimeAlignmentTimer (OSCTXT* pctxt, TimeAlignmentTimer value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeAlignmentTimer");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("TimeAlignmentTimer"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_TimeAlignmentTimer (OSCTXT* pctxt, TimeAlignmentTimer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeAlignmentTimer");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_NextHopChainingCount (OSCTXT* pctxt, NextHopChainingCount value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NextHopChainingCount");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("NextHopChainingCount"));

   if ( (value <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_NextHopChainingCount (OSCTXT* pctxt, NextHopChainingCount* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NextHopChainingCount");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ShortMAC_I (OSCTXT* pctxt, ShortMAC_I value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ShortMAC-I");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ShortMAC_I"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ShortMAC_I (OSCTXT* pctxt, ShortMAC_I* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ShortMAC-I");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ShortMAC_I (ShortMAC_I* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

EXTERN int asn1PE_AdditionalSpectrumEmission (OSCTXT* pctxt, AdditionalSpectrumEmission value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AdditionalSpectrumEmission");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("AdditionalSpectrumEmission"));

   if ( (value >= OSUINTCONST(1) && value <= OSUINTCONST(32)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(32));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AdditionalSpectrumEmission (OSCTXT* pctxt, AdditionalSpectrumEmission* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AdditionalSpectrumEmission");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ARFCN_ValueCDMA2000 (OSCTXT* pctxt, ARFCN_ValueCDMA2000 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ARFCN-ValueCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ARFCN_ValueCDMA2000"));

   if ( (value <= OSUINTCONST(2047)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(2047));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ARFCN_ValueCDMA2000 (OSCTXT* pctxt, ARFCN_ValueCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ARFCN-ValueCDMA2000");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(2047));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ARFCN_ValueEUTRA (OSCTXT* pctxt, ARFCN_ValueEUTRA value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ARFCN-ValueEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ARFCN_ValueEUTRA"));

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ARFCN_ValueEUTRA (OSCTXT* pctxt, ARFCN_ValueEUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ARFCN-ValueEUTRA");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ARFCN_ValueGERAN (OSCTXT* pctxt, ARFCN_ValueGERAN value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ARFCN-ValueGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ARFCN_ValueGERAN"));

   if ( (value <= OSUINTCONST(1023)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(1023));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ARFCN_ValueGERAN (OSCTXT* pctxt, ARFCN_ValueGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ARFCN-ValueGERAN");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(1023));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ARFCN_ValueUTRA (OSCTXT* pctxt, ARFCN_ValueUTRA value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ARFCN-ValueUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ARFCN_ValueUTRA"));

   if ( (value <= OSUINTCONST(16383)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(16383));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ARFCN_ValueUTRA (OSCTXT* pctxt, ARFCN_ValueUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ARFCN-ValueUTRA");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(16383));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem BandclassCDMA2000_ENUMTAB[] = {
   { OSUTF8("bc0"), 0, 3, 0 },
   { OSUTF8("bc1"), 1, 3, 1 },
   { OSUTF8("bc10"), 10, 4, 10 },
   { OSUTF8("bc11"), 11, 4, 11 },
   { OSUTF8("bc12"), 12, 4, 12 },
   { OSUTF8("bc13"), 13, 4, 13 },
   { OSUTF8("bc14"), 14, 4, 14 },
   { OSUTF8("bc15"), 15, 4, 15 },
   { OSUTF8("bc16"), 16, 4, 16 },
   { OSUTF8("bc17"), 17, 4, 17 },
   { OSUTF8("bc2"), 2, 3, 2 },
   { OSUTF8("bc3"), 3, 3, 3 },
   { OSUTF8("bc4"), 4, 3, 4 },
   { OSUTF8("bc5"), 5, 3, 5 },
   { OSUTF8("bc6"), 6, 3, 6 },
   { OSUTF8("bc7"), 7, 3, 7 },
   { OSUTF8("bc8"), 8, 3, 8 },
   { OSUTF8("bc9"), 9, 3, 9 },
   { OSUTF8("spare1"), 31, 6, 23 },
   { OSUTF8("spare10"), 22, 7, 22 },
   { OSUTF8("spare11"), 21, 7, 21 },
   { OSUTF8("spare12"), 20, 7, 20 },
   { OSUTF8("spare13"), 19, 7, 19 },
   { OSUTF8("spare14"), 18, 7, 31 },
   { OSUTF8("spare2"), 30, 6, 30 },
   { OSUTF8("spare3"), 29, 6, 29 },
   { OSUTF8("spare4"), 28, 6, 28 },
   { OSUTF8("spare5"), 27, 6, 27 },
   { OSUTF8("spare6"), 26, 6, 26 },
   { OSUTF8("spare7"), 25, 6, 25 },
   { OSUTF8("spare8"), 24, 6, 24 },
   { OSUTF8("spare9"), 23, 6, 18 }
} ;
#define BandclassCDMA2000_ENUMTABSIZE 32

const OSUTF8CHAR* BandclassCDMA2000_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < BandclassCDMA2000_ENUMTABSIZE) {
      return BandclassCDMA2000_ENUMTAB
         [BandclassCDMA2000_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int BandclassCDMA2000_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, BandclassCDMA2000* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return BandclassCDMA2000_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int BandclassCDMA2000_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, BandclassCDMA2000* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, BandclassCDMA2000_ENUMTAB, 
      BandclassCDMA2000_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (BandclassCDMA2000)BandclassCDMA2000_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_BandclassCDMA2000 (OSCTXT* pctxt, BandclassCDMA2000 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BandclassCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BandclassCDMA2000"));

   if (value >= 32) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(31));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BandclassCDMA2000 (OSCTXT* pctxt, BandclassCDMA2000* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "BandclassCDMA2000");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(31));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem BandIndicatorGERAN_ENUMTAB[] = {
   { OSUTF8("dcs1800"), 0, 7, 0 },
   { OSUTF8("pcs1900"), 1, 7, 1 }
} ;
#define BandIndicatorGERAN_ENUMTABSIZE 2

const OSUTF8CHAR* BandIndicatorGERAN_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < BandIndicatorGERAN_ENUMTABSIZE) {
      return BandIndicatorGERAN_ENUMTAB
         [BandIndicatorGERAN_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int BandIndicatorGERAN_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, BandIndicatorGERAN* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return BandIndicatorGERAN_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int BandIndicatorGERAN_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, BandIndicatorGERAN* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, BandIndicatorGERAN_ENUMTAB, 
      BandIndicatorGERAN_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (BandIndicatorGERAN)BandIndicatorGERAN_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_BandIndicatorGERAN (OSCTXT* pctxt, BandIndicatorGERAN value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BandIndicatorGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BandIndicatorGERAN"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BandIndicatorGERAN (OSCTXT* pctxt, BandIndicatorGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BandIndicatorGERAN");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem CDMA2000_Type_ENUMTAB[] = {
   { OSUTF8("type1XRTT"), 0, 9, 0 },
   { OSUTF8("typeHRPD"), 1, 8, 1 }
} ;
#define CDMA2000_Type_ENUMTABSIZE 2

const OSUTF8CHAR* CDMA2000_Type_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < CDMA2000_Type_ENUMTABSIZE) {
      return CDMA2000_Type_ENUMTAB[CDMA2000_Type_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int CDMA2000_Type_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, CDMA2000_Type* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return CDMA2000_Type_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int CDMA2000_Type_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, CDMA2000_Type* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, CDMA2000_Type_ENUMTAB, 
      CDMA2000_Type_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (CDMA2000_Type)CDMA2000_Type_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_CDMA2000_Type (OSCTXT* pctxt, CDMA2000_Type value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CDMA2000-Type");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CDMA2000_Type"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CDMA2000_Type (OSCTXT* pctxt, CDMA2000_Type* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CDMA2000-Type");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_CellIdentity (OSCTXT* pctxt, CellIdentity value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellIdentity");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellIdentity"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(28), OSUINTCONST(28), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(28), OSUINTCONST(28));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellIdentity (OSCTXT* pctxt, CellIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellIdentity");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(28), OSUINTCONST(28), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(28), OSUINTCONST(28));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellIdentity (CellIdentity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

EXTERN int asn1PE_CellIndex (OSCTXT* pctxt, CellIndex value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellIndex");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellIndex"));

   if ( (value >= OSUINTCONST(1) && value <= OSUINTCONST(32)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(32));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellIndex (OSCTXT* pctxt, CellIndex* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellIndex");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_CellReselectionPriority (OSCTXT* pctxt, CellReselectionPriority value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellReselectionPriority");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellReselectionPriority"));

   if ( (value <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellReselectionPriority (OSCTXT* pctxt, CellReselectionPriority* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellReselectionPriority");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_CSG_Identity (OSCTXT* pctxt, CSG_Identity value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSG-Identity");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSG_Identity"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(27), OSUINTCONST(27), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(27), OSUINTCONST(27));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSG_Identity (OSCTXT* pctxt, CSG_Identity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSG-Identity");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(27), OSUINTCONST(27), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(27), OSUINTCONST(27));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CSG_Identity (CSG_Identity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

EXTERN int asn1PE_MobilityParametersCDMA2000 (OSCTXT* pctxt, MobilityParametersCDMA2000 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityParametersCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityParametersCDMA2000"));

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityParametersCDMA2000 (OSCTXT* pctxt, MobilityParametersCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityParametersCDMA2000");

   stat = pd_DynOctetString (pctxt, (OSDynOctStr*)pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MobilityParametersCDMA2000 (MobilityParametersCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
   pvalue->data = 0;
}

EXTERN int asn1PE_PhysCellId (OSCTXT* pctxt, PhysCellId value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellId");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhysCellId"));

   if ( (value <= OSUINTCONST(503)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(503));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhysCellId (OSCTXT* pctxt, PhysCellId* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellId");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(503));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PhysCellIdCDMA2000 (OSCTXT* pctxt, PhysCellIdCDMA2000 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhysCellIdCDMA2000"));

   if ( (value <= OSUINTCONST(511)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(511));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhysCellIdCDMA2000 (OSCTXT* pctxt, PhysCellIdCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdCDMA2000");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(511));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PhysCellIdUTRA_FDD (OSCTXT* pctxt, PhysCellIdUTRA_FDD value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdUTRA-FDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhysCellIdUTRA_FDD"));

   if ( (value <= OSUINTCONST(511)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(511));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhysCellIdUTRA_FDD (OSCTXT* pctxt, PhysCellIdUTRA_FDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdUTRA-FDD");

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(511));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PhysCellIdUTRA_TDD (OSCTXT* pctxt, PhysCellIdUTRA_TDD value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdUTRA-TDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhysCellIdUTRA_TDD"));

   if ( (value <= OSUINTCONST(127)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(127));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhysCellIdUTRA_TDD (OSCTXT* pctxt, PhysCellIdUTRA_TDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdUTRA-TDD");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(127));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_MCC_MNC_Digit (OSCTXT* pctxt, MCC_MNC_Digit value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MCC-MNC-Digit");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MCC_MNC_Digit"));

   if ( (value <= OSUINTCONST(9)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(9));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MCC_MNC_Digit (OSCTXT* pctxt, MCC_MNC_Digit* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MCC-MNC-Digit");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(9));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PreRegistrationZoneIdHRPD (OSCTXT* pctxt, PreRegistrationZoneIdHRPD value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PreRegistrationZoneIdHRPD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PreRegistrationZoneIdHRPD"));

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PreRegistrationZoneIdHRPD (OSCTXT* pctxt, PreRegistrationZoneIdHRPD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PreRegistrationZoneIdHRPD");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_Q_QualMin_r9 (OSCTXT* pctxt, Q_QualMin_r9 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Q-QualMin-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("Q_QualMin_r9"));

   if ( (value >= OSINTCONST(-34) && value <= OSINTCONST(-3)) ) {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-34), OSINTCONST(-3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Q_QualMin_r9 (OSCTXT* pctxt, Q_QualMin_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Q-QualMin-r9");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-34), OSINTCONST(-3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_Q_RxLevMin (OSCTXT* pctxt, Q_RxLevMin value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Q-RxLevMin");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("Q_RxLevMin"));

   if ( (value >= OSINTCONST(-70) && value <= OSINTCONST(-22)) ) {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-70), OSINTCONST(-22));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Q_RxLevMin (OSCTXT* pctxt, Q_RxLevMin* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Q-RxLevMin");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-70), OSINTCONST(-22));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem Q_OffsetRange_ENUMTAB[] = {
   { OSUTF8("dB-1"), 14, 4, 9 },
   { OSUTF8("dB-10"), 7, 5, 8 },
   { OSUTF8("dB-12"), 6, 5, 7 },
   { OSUTF8("dB-14"), 5, 5, 5 },
   { OSUTF8("dB-16"), 4, 5, 4 },
   { OSUTF8("dB-18"), 3, 5, 3 },
   { OSUTF8("dB-2"), 13, 4, 2 },
   { OSUTF8("dB-20"), 2, 5, 1 },
   { OSUTF8("dB-22"), 1, 5, 14 },
   { OSUTF8("dB-24"), 0, 5, 13 },
   { OSUTF8("dB-3"), 12, 4, 12 },
   { OSUTF8("dB-4"), 11, 4, 11 },
   { OSUTF8("dB-5"), 10, 4, 10 },
   { OSUTF8("dB-6"), 9, 4, 6 },
   { OSUTF8("dB-8"), 8, 4, 0 },
   { OSUTF8("dB0"), 15, 3, 15 },
   { OSUTF8("dB1"), 16, 3, 16 },
   { OSUTF8("dB10"), 23, 4, 22 },
   { OSUTF8("dB12"), 24, 4, 26 },
   { OSUTF8("dB14"), 25, 4, 27 },
   { OSUTF8("dB16"), 26, 4, 28 },
   { OSUTF8("dB18"), 27, 4, 29 },
   { OSUTF8("dB2"), 17, 3, 30 },
   { OSUTF8("dB20"), 28, 4, 17 },
   { OSUTF8("dB22"), 29, 4, 18 },
   { OSUTF8("dB24"), 30, 4, 19 },
   { OSUTF8("dB3"), 18, 3, 20 },
   { OSUTF8("dB4"), 19, 3, 21 },
   { OSUTF8("dB5"), 20, 3, 23 },
   { OSUTF8("dB6"), 21, 3, 24 },
   { OSUTF8("dB8"), 22, 3, 25 }
} ;
#define Q_OffsetRange_ENUMTABSIZE 31

const OSUTF8CHAR* Q_OffsetRange_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < Q_OffsetRange_ENUMTABSIZE) {
      return Q_OffsetRange_ENUMTAB[Q_OffsetRange_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int Q_OffsetRange_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, Q_OffsetRange* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return Q_OffsetRange_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int Q_OffsetRange_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, Q_OffsetRange* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, Q_OffsetRange_ENUMTAB, 
      Q_OffsetRange_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (Q_OffsetRange)Q_OffsetRange_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_Q_OffsetRange (OSCTXT* pctxt, Q_OffsetRange value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Q-OffsetRange");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("Q_OffsetRange"));

   if (value >= 31) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(30));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Q_OffsetRange (OSCTXT* pctxt, Q_OffsetRange* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Q-OffsetRange");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(30));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_Q_OffsetRangeInterRAT (OSCTXT* pctxt, Q_OffsetRangeInterRAT value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Q-OffsetRangeInterRAT");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("Q_OffsetRangeInterRAT"));

   if ( (value >= OSINTCONST(-15) && value <= OSINTCONST(15)) ) {
      stat = pe_ConsInteger (pctxt, value, OSINTCONST(-15), OSINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Q_OffsetRangeInterRAT (OSCTXT* pctxt, Q_OffsetRangeInterRAT* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Q-OffsetRangeInterRAT");

   stat = pd_ConsInt8 (pctxt, pvalue, OSINTCONST(-15), OSINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ReselectionThreshold (OSCTXT* pctxt, ReselectionThreshold value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReselectionThreshold");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReselectionThreshold"));

   if ( (value <= OSUINTCONST(31)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(31));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReselectionThreshold (OSCTXT* pctxt, ReselectionThreshold* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReselectionThreshold");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(31));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ReselectionThresholdQ_r9 (OSCTXT* pctxt, ReselectionThresholdQ_r9 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReselectionThresholdQ-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReselectionThresholdQ_r9"));

   if ( (value <= OSUINTCONST(31)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(31));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReselectionThresholdQ_r9 (OSCTXT* pctxt, ReselectionThresholdQ_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReselectionThresholdQ-r9");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(31));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_TrackingAreaCode (OSCTXT* pctxt, TrackingAreaCode value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TrackingAreaCode");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("TrackingAreaCode"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_TrackingAreaCode (OSCTXT* pctxt, TrackingAreaCode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TrackingAreaCode");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_TrackingAreaCode (TrackingAreaCode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

EXTERN int asn1PE_T_Reselection (OSCTXT* pctxt, T_Reselection value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "T-Reselection");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("T_Reselection"));

   if ( (value <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_T_Reselection (OSCTXT* pctxt, T_Reselection* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "T-Reselection");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem AllowedMeasBandwidth_ENUMTAB[] = {
   { OSUTF8("mbw100"), 5, 6, 4 },
   { OSUTF8("mbw15"), 1, 5, 1 },
   { OSUTF8("mbw25"), 2, 5, 2 },
   { OSUTF8("mbw50"), 3, 5, 3 },
   { OSUTF8("mbw6"), 0, 4, 5 },
   { OSUTF8("mbw75"), 4, 5, 0 }
} ;
#define AllowedMeasBandwidth_ENUMTABSIZE 6

const OSUTF8CHAR* AllowedMeasBandwidth_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AllowedMeasBandwidth_ENUMTABSIZE) {
      return AllowedMeasBandwidth_ENUMTAB
         [AllowedMeasBandwidth_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AllowedMeasBandwidth_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AllowedMeasBandwidth* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AllowedMeasBandwidth_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AllowedMeasBandwidth_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, AllowedMeasBandwidth* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, AllowedMeasBandwidth_ENUMTAB, 
      AllowedMeasBandwidth_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AllowedMeasBandwidth)AllowedMeasBandwidth_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_AllowedMeasBandwidth (OSCTXT* pctxt, AllowedMeasBandwidth value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AllowedMeasBandwidth");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("AllowedMeasBandwidth"));

   if (value >= 6) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AllowedMeasBandwidth (OSCTXT* pctxt, AllowedMeasBandwidth* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AllowedMeasBandwidth");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_Hysteresis (OSCTXT* pctxt, Hysteresis value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Hysteresis");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("Hysteresis"));

   if ( (value <= OSUINTCONST(30)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(30));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Hysteresis (OSCTXT* pctxt, Hysteresis* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Hysteresis");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(30));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_MeasId (OSCTXT* pctxt, MeasId value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasId");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasId"));

   if ( (value >= OSUINTCONST(1) && value <= OSUINTCONST(32)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(32));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasId (OSCTXT* pctxt, MeasId* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasId");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_MeasObjectId (OSCTXT* pctxt, MeasObjectId value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectId");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasObjectId"));

   if ( (value >= OSUINTCONST(1) && value <= OSUINTCONST(32)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(32));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasObjectId (OSCTXT* pctxt, MeasObjectId* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectId");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ReportConfigId (OSCTXT* pctxt, ReportConfigId value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportConfigId");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigId"));

   if ( (value >= OSUINTCONST(1) && value <= OSUINTCONST(32)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(1), OSUINTCONST(32));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigId (OSCTXT* pctxt, ReportConfigId* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportConfigId");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ThresholdGERAN (OSCTXT* pctxt, ThresholdGERAN value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ThresholdGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ThresholdGERAN"));

   if ( (value <= OSUINTCONST(63)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ThresholdGERAN (OSCTXT* pctxt, ThresholdGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ThresholdGERAN");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ThresholdCDMA2000 (OSCTXT* pctxt, ThresholdCDMA2000 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ThresholdCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ThresholdCDMA2000"));

   if ( (value <= OSUINTCONST(63)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ThresholdCDMA2000 (OSCTXT* pctxt, ThresholdCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ThresholdCDMA2000");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ReportInterval_ENUMTAB[] = {
   { OSUTF8("min1"), 8, 4, 7 },
   { OSUTF8("min12"), 10, 5, 9 },
   { OSUTF8("min30"), 11, 5, 10 },
   { OSUTF8("min6"), 9, 4, 12 },
   { OSUTF8("min60"), 12, 5, 5 },
   { OSUTF8("ms1024"), 4, 6, 8 },
   { OSUTF8("ms10240"), 7, 7, 11 },
   { OSUTF8("ms120"), 0, 5, 6 },
   { OSUTF8("ms2048"), 5, 6, 0 },
   { OSUTF8("ms240"), 1, 5, 3 },
   { OSUTF8("ms480"), 2, 5, 1 },
   { OSUTF8("ms5120"), 6, 6, 2 },
   { OSUTF8("ms640"), 3, 5, 4 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 }
} ;
#define ReportInterval_ENUMTABSIZE 16

const OSUTF8CHAR* ReportInterval_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ReportInterval_ENUMTABSIZE) {
      return ReportInterval_ENUMTAB
         [ReportInterval_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReportInterval_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ReportInterval* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ReportInterval_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ReportInterval_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ReportInterval* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ReportInterval_ENUMTAB, 
      ReportInterval_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReportInterval)ReportInterval_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ReportInterval (OSCTXT* pctxt, ReportInterval value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportInterval");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportInterval"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportInterval (OSCTXT* pctxt, ReportInterval* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportInterval");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RSRP_Range (OSCTXT* pctxt, RSRP_Range value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RSRP-Range");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RSRP_Range"));

   if ( (value <= OSUINTCONST(97)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(97));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RSRP_Range (OSCTXT* pctxt, RSRP_Range* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RSRP-Range");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(97));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RSRQ_Range (OSCTXT* pctxt, RSRQ_Range value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RSRQ-Range");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RSRQ_Range"));

   if ( (value <= OSUINTCONST(34)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(34));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RSRQ_Range (OSCTXT* pctxt, RSRQ_Range* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RSRQ-Range");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(34));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem TimeToTrigger_ENUMTAB[] = {
   { OSUTF8("ms0"), 0, 3, 0 },
   { OSUTF8("ms100"), 4, 5, 9 },
   { OSUTF8("ms1024"), 12, 6, 13 },
   { OSUTF8("ms128"), 5, 5, 15 },
   { OSUTF8("ms1280"), 13, 6, 1 },
   { OSUTF8("ms160"), 6, 5, 3 },
   { OSUTF8("ms256"), 7, 5, 5 },
   { OSUTF8("ms2560"), 14, 6, 6 },
   { OSUTF8("ms320"), 8, 5, 8 },
   { OSUTF8("ms40"), 1, 4, 10 },
   { OSUTF8("ms480"), 9, 5, 11 },
   { OSUTF8("ms512"), 10, 5, 14 },
   { OSUTF8("ms5120"), 15, 6, 2 },
   { OSUTF8("ms64"), 2, 4, 4 },
   { OSUTF8("ms640"), 11, 5, 7 },
   { OSUTF8("ms80"), 3, 4, 12 }
} ;
#define TimeToTrigger_ENUMTABSIZE 16

const OSUTF8CHAR* TimeToTrigger_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < TimeToTrigger_ENUMTABSIZE) {
      return TimeToTrigger_ENUMTAB[TimeToTrigger_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int TimeToTrigger_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, TimeToTrigger* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return TimeToTrigger_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int TimeToTrigger_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, TimeToTrigger* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, TimeToTrigger_ENUMTAB, 
      TimeToTrigger_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (TimeToTrigger)TimeToTrigger_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_TimeToTrigger (OSCTXT* pctxt, TimeToTrigger value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeToTrigger");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("TimeToTrigger"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_TimeToTrigger (OSCTXT* pctxt, TimeToTrigger* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeToTrigger");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_C_RNTI (OSCTXT* pctxt, C_RNTI value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "C-RNTI");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("C_RNTI"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_C_RNTI (OSCTXT* pctxt, C_RNTI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "C-RNTI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_C_RNTI (C_RNTI* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

EXTERN int asn1PE_DedicatedInfoCDMA2000 (OSCTXT* pctxt, DedicatedInfoCDMA2000 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DedicatedInfoCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DedicatedInfoCDMA2000"));

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DedicatedInfoCDMA2000 (OSCTXT* pctxt, DedicatedInfoCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DedicatedInfoCDMA2000");

   stat = pd_DynOctetString (pctxt, (OSDynOctStr*)pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DedicatedInfoCDMA2000 (DedicatedInfoCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
   pvalue->data = 0;
}

EXTERN int asn1PE_DedicatedInfoNAS (OSCTXT* pctxt, DedicatedInfoNAS value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DedicatedInfoNAS");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DedicatedInfoNAS"));

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DedicatedInfoNAS (OSCTXT* pctxt, DedicatedInfoNAS* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DedicatedInfoNAS");

   stat = pd_DynOctetString (pctxt, (OSDynOctStr*)pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DedicatedInfoNAS (DedicatedInfoNAS* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
   pvalue->data = 0;
}

static const OSEnumItem FilterCoefficient_ENUMTAB[] = {
   { OSUTF8("fc0"), 0, 3, 0 },
   { OSUTF8("fc1"), 1, 3, 1 },
   { OSUTF8("fc11"), 10, 4, 7 },
   { OSUTF8("fc13"), 11, 4, 8 },
   { OSUTF8("fc15"), 12, 4, 9 },
   { OSUTF8("fc17"), 13, 4, 10 },
   { OSUTF8("fc19"), 14, 4, 11 },
   { OSUTF8("fc2"), 2, 3, 12 },
   { OSUTF8("fc3"), 3, 3, 13 },
   { OSUTF8("fc4"), 4, 3, 14 },
   { OSUTF8("fc5"), 5, 3, 2 },
   { OSUTF8("fc6"), 6, 3, 3 },
   { OSUTF8("fc7"), 7, 3, 4 },
   { OSUTF8("fc8"), 8, 3, 5 },
   { OSUTF8("fc9"), 9, 3, 6 },
   { OSUTF8("spare1"), 15, 6, 15 }
} ;
#define FilterCoefficient_ENUMTABSIZE 16

const OSUTF8CHAR* FilterCoefficient_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < FilterCoefficient_ENUMTABSIZE) {
      return FilterCoefficient_ENUMTAB
         [FilterCoefficient_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int FilterCoefficient_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, FilterCoefficient* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return FilterCoefficient_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int FilterCoefficient_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, FilterCoefficient* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, FilterCoefficient_ENUMTAB, 
      FilterCoefficient_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (FilterCoefficient)FilterCoefficient_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_FilterCoefficient (OSCTXT* pctxt, FilterCoefficient value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FilterCoefficient");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("FilterCoefficient"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_FilterCoefficient (OSCTXT* pctxt, FilterCoefficient* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "FilterCoefficient");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_MMEC (OSCTXT* pctxt, MMEC value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MMEC");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MMEC"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MMEC (OSCTXT* pctxt, MMEC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MMEC");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MMEC (MMEC* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

EXTERN int asn1PE_NeighCellConfig (OSCTXT* pctxt, NeighCellConfig value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellConfig");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("NeighCellConfig"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(2), OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_NeighCellConfig (OSCTXT* pctxt, NeighCellConfig* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellConfig");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(2), OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_NeighCellConfig (NeighCellConfig* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

EXTERN int asn1PE_RAND_CDMA2000 (OSCTXT* pctxt, RAND_CDMA2000 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAND-CDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RAND_CDMA2000"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(32), OSUINTCONST(32), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(32), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RAND_CDMA2000 (OSCTXT* pctxt, RAND_CDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAND-CDMA2000");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(32), OSUINTCONST(32), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(32), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RAND_CDMA2000 (RAND_CDMA2000* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

static const OSEnumItem RAT_Type_ENUMTAB[] = {
   { OSUTF8("cdma2000-1XRTT"), 4, 14, 1 },
   { OSUTF8("eutra"), 0, 5, 7 },
   { OSUTF8("geran-cs"), 2, 8, 2 },
   { OSUTF8("geran-ps"), 3, 8, 3 },
   { OSUTF8("spare1"), 7, 6, 0 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 },
   { OSUTF8("utra"), 1, 4, 4 }
} ;
#define RAT_Type_ENUMTABSIZE 8

const OSUTF8CHAR* RAT_Type_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RAT_Type_ENUMTABSIZE) {
      return RAT_Type_ENUMTAB[RAT_Type_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RAT_Type_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, RAT_Type* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RAT_Type_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RAT_Type_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, RAT_Type* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, RAT_Type_ENUMTAB, 
      RAT_Type_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RAT_Type)RAT_Type_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RAT_Type (OSCTXT* pctxt, RAT_Type value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAT-Type");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RAT_Type"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RAT_Type (OSCTXT* pctxt, RAT_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAT-Type");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RRC_TransactionIdentifier (OSCTXT* pctxt, RRC_TransactionIdentifier value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRC-TransactionIdentifier");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRC_TransactionIdentifier"));

   if ( (value <= OSUINTCONST(3)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRC_TransactionIdentifier (OSCTXT* pctxt, RRC_TransactionIdentifier* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRC-TransactionIdentifier");

   stat = pd_ConsUInt8 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem AccessStratumRelease_ENUMTAB[] = {
   { OSUTF8("rel8"), 0, 4, 0 },
   { OSUTF8("rel9"), 1, 4, 1 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 },
   { OSUTF8("spare4"), 4, 6, 4 },
   { OSUTF8("spare5"), 3, 6, 3 },
   { OSUTF8("spare6"), 2, 6, 2 }
} ;
#define AccessStratumRelease_ENUMTABSIZE 8

const OSUTF8CHAR* AccessStratumRelease_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AccessStratumRelease_ENUMTABSIZE) {
      return AccessStratumRelease_ENUMTAB
         [AccessStratumRelease_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AccessStratumRelease_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AccessStratumRelease* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AccessStratumRelease_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AccessStratumRelease_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, AccessStratumRelease* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, AccessStratumRelease_ENUMTAB, 
      AccessStratumRelease_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AccessStratumRelease)AccessStratumRelease_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_AccessStratumRelease (OSCTXT* pctxt, AccessStratumRelease value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AccessStratumRelease");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("AccessStratumRelease"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AccessStratumRelease (OSCTXT* pctxt, AccessStratumRelease* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AccessStratumRelease");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem SupportedBandUTRA_FDD_ENUMTAB[] = {
   { OSUTF8("bandI"), 0, 5, 0 },
   { OSUTF8("bandII"), 1, 6, 1 },
   { OSUTF8("bandIII"), 2, 7, 2 },
   { OSUTF8("bandIV"), 3, 6, 3 },
   { OSUTF8("bandIX"), 8, 6, 5 },
   { OSUTF8("bandV"), 4, 5, 6 },
   { OSUTF8("bandVI"), 5, 6, 7 },
   { OSUTF8("bandVII"), 6, 7, 8 },
   { OSUTF8("bandVIII"), 7, 8, 4 },
   { OSUTF8("bandX"), 9, 5, 9 },
   { OSUTF8("bandXI"), 10, 6, 10 },
   { OSUTF8("bandXII"), 11, 7, 11 },
   { OSUTF8("bandXIII"), 12, 8, 12 },
   { OSUTF8("bandXIV"), 13, 7, 13 },
   { OSUTF8("bandXIX-8a0"), 18, 11, 15 },
   { OSUTF8("bandXV"), 14, 6, 16 },
   { OSUTF8("bandXVI"), 15, 7, 17 },
   { OSUTF8("bandXVII-8a0"), 16, 12, 18 },
   { OSUTF8("bandXVIII-8a0"), 17, 13, 14 },
   { OSUTF8("bandXX-8a0"), 19, 10, 19 },
   { OSUTF8("bandXXI-8a0"), 20, 11, 20 },
   { OSUTF8("bandXXII-8a0"), 21, 12, 21 },
   { OSUTF8("bandXXIII-8a0"), 22, 13, 22 },
   { OSUTF8("bandXXIV-8a0"), 23, 12, 23 },
   { OSUTF8("bandXXIX-8a0"), 28, 12, 25 },
   { OSUTF8("bandXXV-8a0"), 24, 11, 26 },
   { OSUTF8("bandXXVI-8a0"), 25, 12, 27 },
   { OSUTF8("bandXXVII-8a0"), 26, 13, 28 },
   { OSUTF8("bandXXVIII-8a0"), 27, 14, 24 },
   { OSUTF8("bandXXX-8a0"), 29, 11, 29 },
   { OSUTF8("bandXXXI-8a0"), 30, 12, 30 },
   { OSUTF8("bandXXXII-8a0"), 31, 13, 31 }
} ;
#define SupportedBandUTRA_FDD_ENUMTABSIZE 32

const OSUTF8CHAR* SupportedBandUTRA_FDD_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SupportedBandUTRA_FDD_ENUMTABSIZE) {
      return SupportedBandUTRA_FDD_ENUMTAB
         [SupportedBandUTRA_FDD_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SupportedBandUTRA_FDD_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SupportedBandUTRA_FDD* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SupportedBandUTRA_FDD_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SupportedBandUTRA_FDD_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, SupportedBandUTRA_FDD* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SupportedBandUTRA_FDD_ENUMTAB, SupportedBandUTRA_FDD_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SupportedBandUTRA_FDD)
         SupportedBandUTRA_FDD_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SupportedBandUTRA_FDD (OSCTXT* pctxt, SupportedBandUTRA_FDD value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandUTRA-FDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SupportedBandUTRA_FDD"));

   if (value >= 32) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   extbit = (value > OSUINTCONST(15));

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, value - 16);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedBandUTRA_FDD (OSCTXT* pctxt, SupportedBandUTRA_FDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandUTRA-FDD");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = bandXVII_8a0; break;
         case 1: *pvalue = bandXVIII_8a0; break;
         case 2: *pvalue = bandXIX_8a0; break;
         case 3: *pvalue = bandXX_8a0; break;
         case 4: *pvalue = bandXXI_8a0; break;
         case 5: *pvalue = bandXXII_8a0; break;
         case 6: *pvalue = bandXXIII_8a0; break;
         case 7: *pvalue = bandXXIV_8a0; break;
         case 8: *pvalue = bandXXV_8a0; break;
         case 9: *pvalue = bandXXVI_8a0; break;
         case 10: *pvalue = bandXXVII_8a0; break;
         case 11: *pvalue = bandXXVIII_8a0; break;
         case 12: *pvalue = bandXXIX_8a0; break;
         case 13: *pvalue = bandXXX_8a0; break;
         case 14: *pvalue = bandXXXI_8a0; break;
         case 15: *pvalue = bandXXXII_8a0; break;
         default: *pvalue = 0x7fffffff;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem SupportedBandUTRA_TDD128_ENUMTAB[] = {
   { OSUTF8("a"), 0, 1, 0 },
   { OSUTF8("b"), 1, 1, 1 },
   { OSUTF8("c"), 2, 1, 2 },
   { OSUTF8("d"), 3, 1, 3 },
   { OSUTF8("e"), 4, 1, 4 },
   { OSUTF8("f"), 5, 1, 5 },
   { OSUTF8("g"), 6, 1, 6 },
   { OSUTF8("h"), 7, 1, 7 },
   { OSUTF8("i"), 8, 1, 8 },
   { OSUTF8("j"), 9, 1, 9 },
   { OSUTF8("k"), 10, 1, 10 },
   { OSUTF8("l"), 11, 1, 11 },
   { OSUTF8("m"), 12, 1, 12 },
   { OSUTF8("n"), 13, 1, 13 },
   { OSUTF8("o"), 14, 1, 14 },
   { OSUTF8("p"), 15, 1, 15 }
} ;
#define SupportedBandUTRA_TDD128_ENUMTABSIZE 16

const OSUTF8CHAR* SupportedBandUTRA_TDD128_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SupportedBandUTRA_TDD128_ENUMTABSIZE) {
      return SupportedBandUTRA_TDD128_ENUMTAB
         [SupportedBandUTRA_TDD128_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SupportedBandUTRA_TDD128_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SupportedBandUTRA_TDD128* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SupportedBandUTRA_TDD128_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SupportedBandUTRA_TDD128_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, SupportedBandUTRA_TDD128* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SupportedBandUTRA_TDD128_ENUMTAB, SupportedBandUTRA_TDD128_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SupportedBandUTRA_TDD128)
         SupportedBandUTRA_TDD128_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SupportedBandUTRA_TDD128 (OSCTXT* pctxt, SupportedBandUTRA_TDD128 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandUTRA-TDD128");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SupportedBandUTRA_TDD128"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedBandUTRA_TDD128 (OSCTXT* pctxt, SupportedBandUTRA_TDD128* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandUTRA-TDD128");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem SupportedBandUTRA_TDD384_ENUMTAB[] = {
   { OSUTF8("a"), 0, 1, 0 },
   { OSUTF8("b"), 1, 1, 1 },
   { OSUTF8("c"), 2, 1, 2 },
   { OSUTF8("d"), 3, 1, 3 },
   { OSUTF8("e"), 4, 1, 4 },
   { OSUTF8("f"), 5, 1, 5 },
   { OSUTF8("g"), 6, 1, 6 },
   { OSUTF8("h"), 7, 1, 7 },
   { OSUTF8("i"), 8, 1, 8 },
   { OSUTF8("j"), 9, 1, 9 },
   { OSUTF8("k"), 10, 1, 10 },
   { OSUTF8("l"), 11, 1, 11 },
   { OSUTF8("m"), 12, 1, 12 },
   { OSUTF8("n"), 13, 1, 13 },
   { OSUTF8("o"), 14, 1, 14 },
   { OSUTF8("p"), 15, 1, 15 }
} ;
#define SupportedBandUTRA_TDD384_ENUMTABSIZE 16

const OSUTF8CHAR* SupportedBandUTRA_TDD384_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SupportedBandUTRA_TDD384_ENUMTABSIZE) {
      return SupportedBandUTRA_TDD384_ENUMTAB
         [SupportedBandUTRA_TDD384_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SupportedBandUTRA_TDD384_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SupportedBandUTRA_TDD384* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SupportedBandUTRA_TDD384_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SupportedBandUTRA_TDD384_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, SupportedBandUTRA_TDD384* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SupportedBandUTRA_TDD384_ENUMTAB, SupportedBandUTRA_TDD384_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SupportedBandUTRA_TDD384)
         SupportedBandUTRA_TDD384_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SupportedBandUTRA_TDD384 (OSCTXT* pctxt, SupportedBandUTRA_TDD384 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandUTRA-TDD384");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SupportedBandUTRA_TDD384"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedBandUTRA_TDD384 (OSCTXT* pctxt, SupportedBandUTRA_TDD384* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandUTRA-TDD384");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem SupportedBandUTRA_TDD768_ENUMTAB[] = {
   { OSUTF8("a"), 0, 1, 0 },
   { OSUTF8("b"), 1, 1, 1 },
   { OSUTF8("c"), 2, 1, 2 },
   { OSUTF8("d"), 3, 1, 3 },
   { OSUTF8("e"), 4, 1, 4 },
   { OSUTF8("f"), 5, 1, 5 },
   { OSUTF8("g"), 6, 1, 6 },
   { OSUTF8("h"), 7, 1, 7 },
   { OSUTF8("i"), 8, 1, 8 },
   { OSUTF8("j"), 9, 1, 9 },
   { OSUTF8("k"), 10, 1, 10 },
   { OSUTF8("l"), 11, 1, 11 },
   { OSUTF8("m"), 12, 1, 12 },
   { OSUTF8("n"), 13, 1, 13 },
   { OSUTF8("o"), 14, 1, 14 },
   { OSUTF8("p"), 15, 1, 15 }
} ;
#define SupportedBandUTRA_TDD768_ENUMTABSIZE 16

const OSUTF8CHAR* SupportedBandUTRA_TDD768_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SupportedBandUTRA_TDD768_ENUMTABSIZE) {
      return SupportedBandUTRA_TDD768_ENUMTAB
         [SupportedBandUTRA_TDD768_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SupportedBandUTRA_TDD768_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SupportedBandUTRA_TDD768* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SupportedBandUTRA_TDD768_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SupportedBandUTRA_TDD768_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, SupportedBandUTRA_TDD768* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SupportedBandUTRA_TDD768_ENUMTAB, SupportedBandUTRA_TDD768_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SupportedBandUTRA_TDD768)
         SupportedBandUTRA_TDD768_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SupportedBandUTRA_TDD768 (OSCTXT* pctxt, SupportedBandUTRA_TDD768 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandUTRA-TDD768");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SupportedBandUTRA_TDD768"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedBandUTRA_TDD768 (OSCTXT* pctxt, SupportedBandUTRA_TDD768* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandUTRA-TDD768");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem SupportedBandGERAN_ENUMTAB[] = {
   { OSUTF8("gsm1800"), 9, 7, 2 },
   { OSUTF8("gsm1900"), 10, 7, 3 },
   { OSUTF8("gsm450"), 0, 6, 4 },
   { OSUTF8("gsm480"), 1, 6, 5 },
   { OSUTF8("gsm710"), 2, 6, 6 },
   { OSUTF8("gsm750"), 3, 6, 7 },
   { OSUTF8("gsm810"), 4, 6, 9 },
   { OSUTF8("gsm850"), 5, 6, 8 },
   { OSUTF8("gsm900E"), 7, 7, 10 },
   { OSUTF8("gsm900P"), 6, 7, 0 },
   { OSUTF8("gsm900R"), 8, 7, 1 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 }
} ;
#define SupportedBandGERAN_ENUMTABSIZE 16

const OSUTF8CHAR* SupportedBandGERAN_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SupportedBandGERAN_ENUMTABSIZE) {
      return SupportedBandGERAN_ENUMTAB
         [SupportedBandGERAN_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SupportedBandGERAN_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SupportedBandGERAN* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SupportedBandGERAN_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SupportedBandGERAN_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, SupportedBandGERAN* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, SupportedBandGERAN_ENUMTAB, 
      SupportedBandGERAN_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SupportedBandGERAN)SupportedBandGERAN_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SupportedBandGERAN (OSCTXT* pctxt, SupportedBandGERAN value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SupportedBandGERAN"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedBandGERAN (OSCTXT* pctxt, SupportedBandGERAN* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandGERAN");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9_ENUMTAB[] = {
   { OSUTF8("rf128"), 5, 5, 4 },
   { OSUTF8("rf16"), 2, 4, 6 },
   { OSUTF8("rf256"), 6, 5, 1 },
   { OSUTF8("rf32"), 3, 4, 3 },
   { OSUTF8("rf4"), 0, 3, 5 },
   { OSUTF8("rf64"), 4, 4, 0 },
   { OSUTF8("rf8"), 1, 3, 2 }
} ;
#define MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9_ENUMTABSIZE 7

const OSUTF8CHAR* MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9_ENUMTABSIZE) {
      return MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9_ENUMTAB
         [MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9_ENUMTAB, 
      MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9)
         MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9 (OSCTXT* pctxt, MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9"));

   if (value >= 7) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9 (OSCTXT* pctxt, MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem Handover_targetRAT_Type_ENUMTAB[] = {
   { OSUTF8("cdma2000-1XRTT"), 2, 14, 7 },
   { OSUTF8("cdma2000-HRPD"), 3, 13, 2 },
   { OSUTF8("geran"), 1, 5, 0 },
   { OSUTF8("spare1"), 7, 6, 1 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 },
   { OSUTF8("spare4"), 4, 6, 4 },
   { OSUTF8("utra"), 0, 4, 3 }
} ;
#define Handover_targetRAT_Type_ENUMTABSIZE 8

const OSUTF8CHAR* Handover_targetRAT_Type_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < Handover_targetRAT_Type_ENUMTABSIZE) {
      return Handover_targetRAT_Type_ENUMTAB
         [Handover_targetRAT_Type_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int Handover_targetRAT_Type_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, Handover_targetRAT_Type* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return Handover_targetRAT_Type_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int Handover_targetRAT_Type_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, Handover_targetRAT_Type* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      Handover_targetRAT_Type_ENUMTAB, Handover_targetRAT_Type_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (Handover_targetRAT_Type)
         Handover_targetRAT_Type_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_Handover_targetRAT_Type (OSCTXT* pctxt, Handover_targetRAT_Type value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("Handover_targetRAT_Type"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Handover_targetRAT_Type (OSCTXT* pctxt, Handover_targetRAT_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_Handover_nas_SecurityParamFromEUTRA (OSCTXT* pctxt, Handover_nas_SecurityParamFromEUTRA* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("Handover_nas_SecurityParamFromEUTRA"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Handover_nas_SecurityParamFromEUTRA (OSCTXT* pctxt, Handover_nas_SecurityParamFromEUTRA* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_Handover_nas_SecurityParamFromEUTRA (
   Handover_nas_SecurityParamFromEUTRA* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

static const OSEnumItem CellChangeOrder_t304_ENUMTAB[] = {
   { OSUTF8("ms100"), 0, 5, 0 },
   { OSUTF8("ms1000"), 3, 6, 2 },
   { OSUTF8("ms200"), 1, 5, 5 },
   { OSUTF8("ms2000"), 4, 6, 1 },
   { OSUTF8("ms4000"), 5, 6, 3 },
   { OSUTF8("ms500"), 2, 5, 4 },
   { OSUTF8("ms8000"), 6, 6, 6 },
   { OSUTF8("spare1"), 7, 6, 7 }
} ;
#define CellChangeOrder_t304_ENUMTABSIZE 8

const OSUTF8CHAR* CellChangeOrder_t304_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < CellChangeOrder_t304_ENUMTABSIZE) {
      return CellChangeOrder_t304_ENUMTAB
         [CellChangeOrder_t304_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int CellChangeOrder_t304_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, CellChangeOrder_t304* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return CellChangeOrder_t304_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int CellChangeOrder_t304_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, CellChangeOrder_t304* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, CellChangeOrder_t304_ENUMTAB, 
      CellChangeOrder_t304_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (CellChangeOrder_t304)CellChangeOrder_t304_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_CellChangeOrder_t304 (OSCTXT* pctxt, CellChangeOrder_t304 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellChangeOrder_t304"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellChangeOrder_t304 (OSCTXT* pctxt, CellChangeOrder_t304* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem E_CSFB_r9_mobilityCDMA2000_HRPD_r9_ENUMTAB[] = {
   { OSUTF8("handover"), 0, 8, 0 },
   { OSUTF8("redirection"), 1, 11, 1 }
} ;
#define E_CSFB_r9_mobilityCDMA2000_HRPD_r9_ENUMTABSIZE 2

const OSUTF8CHAR* E_CSFB_r9_mobilityCDMA2000_HRPD_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < E_CSFB_r9_mobilityCDMA2000_HRPD_r9_ENUMTABSIZE) {
      return E_CSFB_r9_mobilityCDMA2000_HRPD_r9_ENUMTAB
         [E_CSFB_r9_mobilityCDMA2000_HRPD_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int E_CSFB_r9_mobilityCDMA2000_HRPD_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, E_CSFB_r9_mobilityCDMA2000_HRPD_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return E_CSFB_r9_mobilityCDMA2000_HRPD_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int E_CSFB_r9_mobilityCDMA2000_HRPD_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      E_CSFB_r9_mobilityCDMA2000_HRPD_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      E_CSFB_r9_mobilityCDMA2000_HRPD_r9_ENUMTAB, 
      E_CSFB_r9_mobilityCDMA2000_HRPD_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (E_CSFB_r9_mobilityCDMA2000_HRPD_r9)
         E_CSFB_r9_mobilityCDMA2000_HRPD_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_E_CSFB_r9_mobilityCDMA2000_HRPD_r9 (OSCTXT* pctxt, E_CSFB_r9_mobilityCDMA2000_HRPD_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("E_CSFB_r9_mobilityCDMA2000_HRPD_r9"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_E_CSFB_r9_mobilityCDMA2000_HRPD_r9 (OSCTXT* pctxt, E_CSFB_r9_mobilityCDMA2000_HRPD_r9* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem Paging_systemInfoModification_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define Paging_systemInfoModification_ENUMTABSIZE 1

const OSUTF8CHAR* Paging_systemInfoModification_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      Paging_systemInfoModification_ENUMTAB, 
      Paging_systemInfoModification_ENUMTABSIZE);

   if (idx >= 0 && idx < Paging_systemInfoModification_ENUMTABSIZE) {
      return Paging_systemInfoModification_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int Paging_systemInfoModification_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, Paging_systemInfoModification* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return Paging_systemInfoModification_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int Paging_systemInfoModification_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      Paging_systemInfoModification* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      Paging_systemInfoModification_ENUMTAB, 
      Paging_systemInfoModification_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (Paging_systemInfoModification)
         Paging_systemInfoModification_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_Paging_systemInfoModification (OSCTXT* pctxt, Paging_systemInfoModification value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("Paging_systemInfoModification"));

   switch (value) {
      case true_: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Paging_systemInfoModification (OSCTXT* pctxt, Paging_systemInfoModification* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = true_; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem Paging_etws_Indication_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define Paging_etws_Indication_ENUMTABSIZE 1

const OSUTF8CHAR* Paging_etws_Indication_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, Paging_etws_Indication_ENUMTAB, 
      Paging_etws_Indication_ENUMTABSIZE);

   if (idx >= 0 && idx < Paging_etws_Indication_ENUMTABSIZE) {
      return Paging_etws_Indication_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int Paging_etws_Indication_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, Paging_etws_Indication* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return Paging_etws_Indication_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int Paging_etws_Indication_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, Paging_etws_Indication* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      Paging_etws_Indication_ENUMTAB, Paging_etws_Indication_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (Paging_etws_Indication)
         Paging_etws_Indication_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_Paging_etws_Indication (OSCTXT* pctxt, Paging_etws_Indication value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("Paging_etws_Indication"));

   switch (value) {
      case true__1: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Paging_etws_Indication (OSCTXT* pctxt, Paging_etws_Indication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = true__1; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem Paging_v920_IEs_cmas_Indication_r9_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define Paging_v920_IEs_cmas_Indication_r9_ENUMTABSIZE 1

const OSUTF8CHAR* Paging_v920_IEs_cmas_Indication_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      Paging_v920_IEs_cmas_Indication_r9_ENUMTAB, 
      Paging_v920_IEs_cmas_Indication_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < Paging_v920_IEs_cmas_Indication_r9_ENUMTABSIZE) {
      return Paging_v920_IEs_cmas_Indication_r9_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int Paging_v920_IEs_cmas_Indication_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, Paging_v920_IEs_cmas_Indication_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return Paging_v920_IEs_cmas_Indication_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int Paging_v920_IEs_cmas_Indication_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      Paging_v920_IEs_cmas_Indication_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      Paging_v920_IEs_cmas_Indication_r9_ENUMTAB, 
      Paging_v920_IEs_cmas_Indication_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (Paging_v920_IEs_cmas_Indication_r9)
         Paging_v920_IEs_cmas_Indication_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_Paging_v920_IEs_cmas_Indication_r9 (OSCTXT* pctxt, Paging_v920_IEs_cmas_Indication_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("Paging_v920_IEs_cmas_Indication_r9"));

   switch (value) {
      case true__2: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Paging_v920_IEs_cmas_Indication_r9 (OSCTXT* pctxt, Paging_v920_IEs_cmas_Indication_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = true__2; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem PagingRecord_cn_Domain_ENUMTAB[] = {
   { OSUTF8("cs"), 1, 2, 1 },
   { OSUTF8("ps"), 0, 2, 0 }
} ;
#define PagingRecord_cn_Domain_ENUMTABSIZE 2

const OSUTF8CHAR* PagingRecord_cn_Domain_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PagingRecord_cn_Domain_ENUMTABSIZE) {
      return PagingRecord_cn_Domain_ENUMTAB
         [PagingRecord_cn_Domain_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PagingRecord_cn_Domain_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PagingRecord_cn_Domain* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PagingRecord_cn_Domain_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PagingRecord_cn_Domain_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, PagingRecord_cn_Domain* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PagingRecord_cn_Domain_ENUMTAB, PagingRecord_cn_Domain_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PagingRecord_cn_Domain)
         PagingRecord_cn_Domain_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PagingRecord_cn_Domain (OSCTXT* pctxt, PagingRecord_cn_Domain value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PagingRecord_cn_Domain"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PagingRecord_cn_Domain (OSCTXT* pctxt, PagingRecord_cn_Domain* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem ProximityIndication_r9_IEs_type_r9_ENUMTAB[] = {
   { OSUTF8("entering"), 0, 8, 0 },
   { OSUTF8("leaving"), 1, 7, 1 }
} ;
#define ProximityIndication_r9_IEs_type_r9_ENUMTABSIZE 2

const OSUTF8CHAR* ProximityIndication_r9_IEs_type_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ProximityIndication_r9_IEs_type_r9_ENUMTABSIZE) {
      return ProximityIndication_r9_IEs_type_r9_ENUMTAB
         [ProximityIndication_r9_IEs_type_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ProximityIndication_r9_IEs_type_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ProximityIndication_r9_IEs_type_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ProximityIndication_r9_IEs_type_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ProximityIndication_r9_IEs_type_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ProximityIndication_r9_IEs_type_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ProximityIndication_r9_IEs_type_r9_ENUMTAB, 
      ProximityIndication_r9_IEs_type_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ProximityIndication_r9_IEs_type_r9)
         ProximityIndication_r9_IEs_type_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ProximityIndication_r9_IEs_type_r9 (OSCTXT* pctxt, ProximityIndication_r9_IEs_type_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ProximityIndication_r9_IEs_type_r9"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ProximityIndication_r9_IEs_type_r9 (OSCTXT* pctxt, ProximityIndication_r9_IEs_type_r9* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RRCConnectionReconfiguration_v920_IEs_fullConfig_r9_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define RRCConnectionReconfiguration_v920_IEs_fullConfig_r9_ENUMTABSIZE 1

const OSUTF8CHAR* RRCConnectionReconfiguration_v920_IEs_fullConfig_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      RRCConnectionReconfiguration_v920_IEs_fullConfig_r9_ENUMTAB, 
      RRCConnectionReconfiguration_v920_IEs_fullConfig_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < RRCConnectionReconfiguration_v920_IEs_fullConfig_r9_ENUMTABSIZE) {
      return RRCConnectionReconfiguration_v920_IEs_fullConfig_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RRCConnectionReconfiguration_v920_IEs_fullConfig_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      RRCConnectionReconfiguration_v920_IEs_fullConfig_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RRCConnectionReconfiguration_v920_IEs_fullConfig_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RRCConnectionReconfiguration_v920_IEs_fullConfig_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RRCConnectionReconfiguration_v920_IEs_fullConfig_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RRCConnectionReconfiguration_v920_IEs_fullConfig_r9_ENUMTAB, 
      RRCConnectionReconfiguration_v920_IEs_fullConfig_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RRCConnectionReconfiguration_v920_IEs_fullConfig_r9)
         RRCConnectionReconfiguration_v920_IEs_fullConfig_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RRCConnectionReconfiguration_v920_IEs_fullConfig_r9 (OSCTXT* pctxt, RRCConnectionReconfiguration_v920_IEs_fullConfig_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfiguration_v920_IEs_fullConfig_r9"));

   switch (value) {
      case true__3: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfiguration_v920_IEs_fullConfig_r9 (OSCTXT* pctxt, RRCConnectionReconfiguration_v920_IEs_fullConfig_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = true__3; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PE_SecurityConfigHO_handoverType_interRAT_nas_SecurityParamToEUTRA (OSCTXT* pctxt, SecurityConfigHO_handoverType_interRAT_nas_SecurityParamToEUTRA* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityConfigHO_handoverType_interRAT_nas_SecurityParamToEUTRA"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityConfigHO_handoverType_interRAT_nas_SecurityParamToEUTRA (OSCTXT* pctxt, SecurityConfigHO_handoverType_interRAT_nas_SecurityParamToEUTRA* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_SecurityConfigHO_handoverType_interRAT_nas_SecurityParamToEUTRA (
   SecurityConfigHO_handoverType_interRAT_nas_SecurityParamToEUTRA* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

static const OSEnumItem RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9_ENUMTABSIZE 1

const OSUTF8CHAR* RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9_ENUMTAB, 
      RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9_ENUMTABSIZE) {
      return RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9_ENUMTAB, 
      RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9)
         RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9 (OSCTXT* pctxt, RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9"));

   switch (value) {
      case true__4: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9 (OSCTXT* pctxt, RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = true__4; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem IdleModeMobilityControlInfo_t320_ENUMTAB[] = {
   { OSUTF8("min10"), 1, 5, 5 },
   { OSUTF8("min120"), 5, 6, 0 },
   { OSUTF8("min180"), 6, 6, 3 },
   { OSUTF8("min20"), 2, 5, 4 },
   { OSUTF8("min30"), 3, 5, 6 },
   { OSUTF8("min5"), 0, 4, 1 },
   { OSUTF8("min60"), 4, 5, 2 },
   { OSUTF8("spare1"), 7, 6, 7 }
} ;
#define IdleModeMobilityControlInfo_t320_ENUMTABSIZE 8

const OSUTF8CHAR* IdleModeMobilityControlInfo_t320_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < IdleModeMobilityControlInfo_t320_ENUMTABSIZE) {
      return IdleModeMobilityControlInfo_t320_ENUMTAB
         [IdleModeMobilityControlInfo_t320_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int IdleModeMobilityControlInfo_t320_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, IdleModeMobilityControlInfo_t320* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return IdleModeMobilityControlInfo_t320_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int IdleModeMobilityControlInfo_t320_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      IdleModeMobilityControlInfo_t320* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      IdleModeMobilityControlInfo_t320_ENUMTAB, 
      IdleModeMobilityControlInfo_t320_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (IdleModeMobilityControlInfo_t320)
         IdleModeMobilityControlInfo_t320_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_IdleModeMobilityControlInfo_t320 (OSCTXT* pctxt, IdleModeMobilityControlInfo_t320 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("IdleModeMobilityControlInfo_t320"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IdleModeMobilityControlInfo_t320 (OSCTXT* pctxt, IdleModeMobilityControlInfo_t320* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_InitialUE_Identity_randomValue (OSCTXT* pctxt, InitialUE_Identity_randomValue* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("InitialUE_Identity_randomValue"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(40), OSUINTCONST(40), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_InitialUE_Identity_randomValue (OSCTXT* pctxt, InitialUE_Identity_randomValue* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(40), OSUINTCONST(40), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_InitialUE_Identity_randomValue (
   InitialUE_Identity_randomValue* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

static const OSEnumItem SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred_ENUMTAB[] = {
   { OSUTF8("barred"), 0, 6, 0 },
   { OSUTF8("notBarred"), 1, 9, 1 }
} ;
#define SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred_ENUMTABSIZE 2

const OSUTF8CHAR* SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred_ENUMTABSIZE) {
      return SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred_ENUMTAB
         [SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred_ENUMTAB, 
      SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred)
         SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred (OSCTXT* pctxt, SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred (OSCTXT* pctxt, SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection_ENUMTAB[] = {
   { OSUTF8("allowed"), 0, 7, 0 },
   { OSUTF8("notAllowed"), 1, 10, 1 }
} ;
#define SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection_ENUMTABSIZE 2

const OSUTF8CHAR* SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection_ENUMTABSIZE) {
      return SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection_ENUMTAB
         [SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection_ENUMTAB, 
      SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection)
         SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection (OSCTXT* pctxt, SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection (OSCTXT* pctxt, SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SystemInformationBlockType1_si_WindowLength_ENUMTAB[] = {
   { OSUTF8("ms1"), 0, 3, 0 },
   { OSUTF8("ms10"), 3, 4, 3 },
   { OSUTF8("ms15"), 4, 4, 6 },
   { OSUTF8("ms2"), 1, 3, 1 },
   { OSUTF8("ms20"), 5, 4, 2 },
   { OSUTF8("ms40"), 6, 4, 4 },
   { OSUTF8("ms5"), 2, 3, 5 }
} ;
#define SystemInformationBlockType1_si_WindowLength_ENUMTABSIZE 7

const OSUTF8CHAR* SystemInformationBlockType1_si_WindowLength_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SystemInformationBlockType1_si_WindowLength_ENUMTABSIZE) {
      return SystemInformationBlockType1_si_WindowLength_ENUMTAB
         [SystemInformationBlockType1_si_WindowLength_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SystemInformationBlockType1_si_WindowLength_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SystemInformationBlockType1_si_WindowLength* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SystemInformationBlockType1_si_WindowLength_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SystemInformationBlockType1_si_WindowLength_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SystemInformationBlockType1_si_WindowLength* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SystemInformationBlockType1_si_WindowLength_ENUMTAB, 
      SystemInformationBlockType1_si_WindowLength_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SystemInformationBlockType1_si_WindowLength)
         SystemInformationBlockType1_si_WindowLength_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SystemInformationBlockType1_si_WindowLength (OSCTXT* pctxt, SystemInformationBlockType1_si_WindowLength value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType1_si_WindowLength"));

   if (value >= 7) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType1_si_WindowLength (OSCTXT* pctxt, SystemInformationBlockType1_si_WindowLength* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_ENUMTABSIZE 1

const OSUTF8CHAR* SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_ENUMTAB, 
      SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_ENUMTABSIZE) {
      return SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_ENUMTAB, 
      SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9)
         SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9 (OSCTXT* pctxt, SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9"));

   switch (value) {
      case true__5: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9 (OSCTXT* pctxt, SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = true__5; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem PLMN_IdentityInfo_cellReservedForOperatorUse_ENUMTAB[] = {
   { OSUTF8("notReserved"), 1, 11, 1 },
   { OSUTF8("reserved"), 0, 8, 0 }
} ;
#define PLMN_IdentityInfo_cellReservedForOperatorUse_ENUMTABSIZE 2

const OSUTF8CHAR* PLMN_IdentityInfo_cellReservedForOperatorUse_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PLMN_IdentityInfo_cellReservedForOperatorUse_ENUMTABSIZE) {
      return PLMN_IdentityInfo_cellReservedForOperatorUse_ENUMTAB
         [PLMN_IdentityInfo_cellReservedForOperatorUse_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PLMN_IdentityInfo_cellReservedForOperatorUse_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      PLMN_IdentityInfo_cellReservedForOperatorUse* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PLMN_IdentityInfo_cellReservedForOperatorUse_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PLMN_IdentityInfo_cellReservedForOperatorUse_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PLMN_IdentityInfo_cellReservedForOperatorUse* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PLMN_IdentityInfo_cellReservedForOperatorUse_ENUMTAB, 
      PLMN_IdentityInfo_cellReservedForOperatorUse_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PLMN_IdentityInfo_cellReservedForOperatorUse)
         PLMN_IdentityInfo_cellReservedForOperatorUse_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PLMN_IdentityInfo_cellReservedForOperatorUse (OSCTXT* pctxt, PLMN_IdentityInfo_cellReservedForOperatorUse value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PLMN_IdentityInfo_cellReservedForOperatorUse"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PLMN_IdentityInfo_cellReservedForOperatorUse (OSCTXT* pctxt, PLMN_IdentityInfo_cellReservedForOperatorUse* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SchedulingInfo_si_Periodicity_ENUMTAB[] = {
   { OSUTF8("rf128"), 4, 5, 6 },
   { OSUTF8("rf16"), 1, 4, 1 },
   { OSUTF8("rf256"), 5, 5, 3 },
   { OSUTF8("rf32"), 2, 4, 5 },
   { OSUTF8("rf512"), 6, 5, 0 },
   { OSUTF8("rf64"), 3, 4, 2 },
   { OSUTF8("rf8"), 0, 3, 4 }
} ;
#define SchedulingInfo_si_Periodicity_ENUMTABSIZE 7

const OSUTF8CHAR* SchedulingInfo_si_Periodicity_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SchedulingInfo_si_Periodicity_ENUMTABSIZE) {
      return SchedulingInfo_si_Periodicity_ENUMTAB
         [SchedulingInfo_si_Periodicity_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SchedulingInfo_si_Periodicity_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SchedulingInfo_si_Periodicity* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SchedulingInfo_si_Periodicity_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SchedulingInfo_si_Periodicity_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SchedulingInfo_si_Periodicity* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SchedulingInfo_si_Periodicity_ENUMTAB, 
      SchedulingInfo_si_Periodicity_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SchedulingInfo_si_Periodicity)
         SchedulingInfo_si_Periodicity_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SchedulingInfo_si_Periodicity (OSCTXT* pctxt, SchedulingInfo_si_Periodicity value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SchedulingInfo_si_Periodicity"));

   if (value >= 7) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SchedulingInfo_si_Periodicity (OSCTXT* pctxt, SchedulingInfo_si_Periodicity* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_ULHandoverPreparationTransfer_r8_IEs_meid (OSCTXT* pctxt, ULHandoverPreparationTransfer_r8_IEs_meid* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULHandoverPreparationTransfer_r8_IEs_meid"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(56), OSUINTCONST(56), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULHandoverPreparationTransfer_r8_IEs_meid (OSCTXT* pctxt, ULHandoverPreparationTransfer_r8_IEs_meid* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(56), OSUINTCONST(56), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_ULHandoverPreparationTransfer_r8_IEs_meid (
   ULHandoverPreparationTransfer_r8_IEs_meid* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

static const OSEnumItem SystemInformationBlockType2_freqInfo_ul_Bandwidth_ENUMTAB[] = {
   { OSUTF8("n100"), 5, 4, 4 },
   { OSUTF8("n15"), 1, 3, 1 },
   { OSUTF8("n25"), 2, 3, 2 },
   { OSUTF8("n50"), 3, 3, 3 },
   { OSUTF8("n6"), 0, 2, 5 },
   { OSUTF8("n75"), 4, 3, 0 }
} ;
#define SystemInformationBlockType2_freqInfo_ul_Bandwidth_ENUMTABSIZE 6

const OSUTF8CHAR* SystemInformationBlockType2_freqInfo_ul_Bandwidth_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SystemInformationBlockType2_freqInfo_ul_Bandwidth_ENUMTABSIZE) {
      return SystemInformationBlockType2_freqInfo_ul_Bandwidth_ENUMTAB
         [SystemInformationBlockType2_freqInfo_ul_Bandwidth_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SystemInformationBlockType2_freqInfo_ul_Bandwidth_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SystemInformationBlockType2_freqInfo_ul_Bandwidth* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SystemInformationBlockType2_freqInfo_ul_Bandwidth_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SystemInformationBlockType2_freqInfo_ul_Bandwidth_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SystemInformationBlockType2_freqInfo_ul_Bandwidth* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SystemInformationBlockType2_freqInfo_ul_Bandwidth_ENUMTAB, 
      SystemInformationBlockType2_freqInfo_ul_Bandwidth_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SystemInformationBlockType2_freqInfo_ul_Bandwidth)
         SystemInformationBlockType2_freqInfo_ul_Bandwidth_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SystemInformationBlockType2_freqInfo_ul_Bandwidth (OSCTXT* pctxt, SystemInformationBlockType2_freqInfo_ul_Bandwidth value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType2_freqInfo_ul_Bandwidth"));

   if (value >= 6) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType2_freqInfo_ul_Bandwidth (OSCTXT* pctxt, SystemInformationBlockType2_freqInfo_ul_Bandwidth* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem AC_BarringConfig_ac_BarringFactor_ENUMTAB[] = {
   { OSUTF8("p00"), 0, 3, 0 },
   { OSUTF8("p05"), 1, 3, 1 },
   { OSUTF8("p10"), 2, 3, 2 },
   { OSUTF8("p15"), 3, 3, 3 },
   { OSUTF8("p20"), 4, 3, 4 },
   { OSUTF8("p25"), 5, 3, 5 },
   { OSUTF8("p30"), 6, 3, 6 },
   { OSUTF8("p40"), 7, 3, 7 },
   { OSUTF8("p50"), 8, 3, 8 },
   { OSUTF8("p60"), 9, 3, 9 },
   { OSUTF8("p70"), 10, 3, 10 },
   { OSUTF8("p75"), 11, 3, 11 },
   { OSUTF8("p80"), 12, 3, 12 },
   { OSUTF8("p85"), 13, 3, 13 },
   { OSUTF8("p90"), 14, 3, 14 },
   { OSUTF8("p95"), 15, 3, 15 }
} ;
#define AC_BarringConfig_ac_BarringFactor_ENUMTABSIZE 16

const OSUTF8CHAR* AC_BarringConfig_ac_BarringFactor_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AC_BarringConfig_ac_BarringFactor_ENUMTABSIZE) {
      return AC_BarringConfig_ac_BarringFactor_ENUMTAB
         [AC_BarringConfig_ac_BarringFactor_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AC_BarringConfig_ac_BarringFactor_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AC_BarringConfig_ac_BarringFactor* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AC_BarringConfig_ac_BarringFactor_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AC_BarringConfig_ac_BarringFactor_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      AC_BarringConfig_ac_BarringFactor* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      AC_BarringConfig_ac_BarringFactor_ENUMTAB, 
      AC_BarringConfig_ac_BarringFactor_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AC_BarringConfig_ac_BarringFactor)
         AC_BarringConfig_ac_BarringFactor_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_AC_BarringConfig_ac_BarringFactor (OSCTXT* pctxt, AC_BarringConfig_ac_BarringFactor value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("AC_BarringConfig_ac_BarringFactor"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AC_BarringConfig_ac_BarringFactor (OSCTXT* pctxt, AC_BarringConfig_ac_BarringFactor* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem AC_BarringConfig_ac_BarringTime_ENUMTAB[] = {
   { OSUTF8("s128"), 5, 4, 4 },
   { OSUTF8("s16"), 2, 3, 7 },
   { OSUTF8("s256"), 6, 4, 1 },
   { OSUTF8("s32"), 3, 3, 3 },
   { OSUTF8("s4"), 0, 2, 6 },
   { OSUTF8("s512"), 7, 4, 0 },
   { OSUTF8("s64"), 4, 3, 2 },
   { OSUTF8("s8"), 1, 2, 5 }
} ;
#define AC_BarringConfig_ac_BarringTime_ENUMTABSIZE 8

const OSUTF8CHAR* AC_BarringConfig_ac_BarringTime_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AC_BarringConfig_ac_BarringTime_ENUMTABSIZE) {
      return AC_BarringConfig_ac_BarringTime_ENUMTAB
         [AC_BarringConfig_ac_BarringTime_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AC_BarringConfig_ac_BarringTime_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AC_BarringConfig_ac_BarringTime* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AC_BarringConfig_ac_BarringTime_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AC_BarringConfig_ac_BarringTime_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      AC_BarringConfig_ac_BarringTime* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      AC_BarringConfig_ac_BarringTime_ENUMTAB, 
      AC_BarringConfig_ac_BarringTime_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AC_BarringConfig_ac_BarringTime)
         AC_BarringConfig_ac_BarringTime_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_AC_BarringConfig_ac_BarringTime (OSCTXT* pctxt, AC_BarringConfig_ac_BarringTime value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("AC_BarringConfig_ac_BarringTime"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AC_BarringConfig_ac_BarringTime (OSCTXT* pctxt, AC_BarringConfig_ac_BarringTime* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst_ENUMTAB[] = {
   { OSUTF8("dB0"), 0, 3, 0 },
   { OSUTF8("dB1"), 1, 3, 1 },
   { OSUTF8("dB10"), 8, 4, 7 },
   { OSUTF8("dB12"), 9, 4, 11 },
   { OSUTF8("dB14"), 10, 4, 12 },
   { OSUTF8("dB16"), 11, 4, 13 },
   { OSUTF8("dB18"), 12, 4, 14 },
   { OSUTF8("dB2"), 2, 3, 15 },
   { OSUTF8("dB20"), 13, 4, 2 },
   { OSUTF8("dB22"), 14, 4, 3 },
   { OSUTF8("dB24"), 15, 4, 4 },
   { OSUTF8("dB3"), 3, 3, 5 },
   { OSUTF8("dB4"), 4, 3, 6 },
   { OSUTF8("dB5"), 5, 3, 8 },
   { OSUTF8("dB6"), 6, 3, 9 },
   { OSUTF8("dB8"), 7, 3, 10 }
} ;
#define SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst_ENUMTABSIZE 16

const OSUTF8CHAR* SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst_ENUMTABSIZE) {
      return SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst_ENUMTAB
         [SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst_ENUMTAB, 
      SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst)
         SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst (OSCTXT* pctxt, SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst (OSCTXT* pctxt, SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium_ENUMTAB[] = {
   { OSUTF8("dB-2"), 2, 4, 2 },
   { OSUTF8("dB-4"), 1, 4, 1 },
   { OSUTF8("dB-6"), 0, 4, 0 },
   { OSUTF8("dB0"), 3, 3, 3 }
} ;
#define SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium_ENUMTABSIZE 4

const OSUTF8CHAR* SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium_ENUMTABSIZE) {
      return SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium_ENUMTAB
         [SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium_ENUMTAB, 
      SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium)
         SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium (OSCTXT* pctxt, SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium (OSCTXT* pctxt, SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High_ENUMTAB[] = {
   { OSUTF8("dB-2"), 2, 4, 2 },
   { OSUTF8("dB-4"), 1, 4, 1 },
   { OSUTF8("dB-6"), 0, 4, 0 },
   { OSUTF8("dB0"), 3, 3, 3 }
} ;
#define SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High_ENUMTABSIZE 4

const OSUTF8CHAR* SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High_ENUMTABSIZE) {
      return SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High_ENUMTAB
         [SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High_ENUMTAB, 
      SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High)
         SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High (OSCTXT* pctxt, SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High (OSCTXT* pctxt, SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT (OSCTXT* pctxt, SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(42), OSUINTCONST(42), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT (OSCTXT* pctxt, SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(42), OSUINTCONST(42), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT (
   SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

EXTERN int asn1PE_SystemInformationBlockType9_hnb_Name (OSCTXT* pctxt, SystemInformationBlockType9_hnb_Name* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType9_hnb_Name"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(48), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType9_hnb_Name (OSCTXT* pctxt, SystemInformationBlockType9_hnb_Name* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(48), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_SystemInformationBlockType9_hnb_Name (
   SystemInformationBlockType9_hnb_Name* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

EXTERN int asn1PE_SystemInformationBlockType10_warningType (OSCTXT* pctxt, SystemInformationBlockType10_warningType* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType10_warningType"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType10_warningType (OSCTXT* pctxt, SystemInformationBlockType10_warningType* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_SystemInformationBlockType10_warningType (
   SystemInformationBlockType10_warningType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

EXTERN int asn1PE_SystemInformationBlockType10_warningSecurityInfo (OSCTXT* pctxt, SystemInformationBlockType10_warningSecurityInfo* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType10_warningSecurityInfo"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(50), OSUINTCONST(50), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType10_warningSecurityInfo (OSCTXT* pctxt, SystemInformationBlockType10_warningSecurityInfo* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(50), OSUINTCONST(50), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_SystemInformationBlockType10_warningSecurityInfo (
   SystemInformationBlockType10_warningSecurityInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

static const OSEnumItem SystemInformationBlockType11_warningMessageSegmentType_ENUMTAB[] = {
   { OSUTF8("lastSegment"), 1, 11, 1 },
   { OSUTF8("notLastSegment"), 0, 14, 0 }
} ;
#define SystemInformationBlockType11_warningMessageSegmentType_ENUMTABSIZE 2

const OSUTF8CHAR* SystemInformationBlockType11_warningMessageSegmentType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SystemInformationBlockType11_warningMessageSegmentType_ENUMTABSIZE) {
      return SystemInformationBlockType11_warningMessageSegmentType_ENUMTAB
         [SystemInformationBlockType11_warningMessageSegmentType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SystemInformationBlockType11_warningMessageSegmentType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SystemInformationBlockType11_warningMessageSegmentType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SystemInformationBlockType11_warningMessageSegmentType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SystemInformationBlockType11_warningMessageSegmentType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SystemInformationBlockType11_warningMessageSegmentType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SystemInformationBlockType11_warningMessageSegmentType_ENUMTAB, 
      SystemInformationBlockType11_warningMessageSegmentType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SystemInformationBlockType11_warningMessageSegmentType)
         SystemInformationBlockType11_warningMessageSegmentType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SystemInformationBlockType11_warningMessageSegmentType (OSCTXT* pctxt, SystemInformationBlockType11_warningMessageSegmentType value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType11_warningMessageSegmentType"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType11_warningMessageSegmentType (OSCTXT* pctxt, SystemInformationBlockType11_warningMessageSegmentType* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_SystemInformationBlockType11_dataCodingScheme (OSCTXT* pctxt, SystemInformationBlockType11_dataCodingScheme* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType11_dataCodingScheme"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType11_dataCodingScheme (OSCTXT* pctxt, SystemInformationBlockType11_dataCodingScheme* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_SystemInformationBlockType11_dataCodingScheme (
   SystemInformationBlockType11_dataCodingScheme* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

static const OSEnumItem SystemInformationBlockType12_r9_warningMessageSegmentType_r9_ENUMTAB[] = {
   { OSUTF8("lastSegment"), 1, 11, 1 },
   { OSUTF8("notLastSegment"), 0, 14, 0 }
} ;
#define SystemInformationBlockType12_r9_warningMessageSegmentType_r9_ENUMTABSIZE 2

const OSUTF8CHAR* SystemInformationBlockType12_r9_warningMessageSegmentType_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SystemInformationBlockType12_r9_warningMessageSegmentType_r9_ENUMTABSIZE) {
      return SystemInformationBlockType12_r9_warningMessageSegmentType_r9_ENUMTAB
         [SystemInformationBlockType12_r9_warningMessageSegmentType_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SystemInformationBlockType12_r9_warningMessageSegmentType_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SystemInformationBlockType12_r9_warningMessageSegmentType_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SystemInformationBlockType12_r9_warningMessageSegmentType_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SystemInformationBlockType12_r9_warningMessageSegmentType_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SystemInformationBlockType12_r9_warningMessageSegmentType_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SystemInformationBlockType12_r9_warningMessageSegmentType_r9_ENUMTAB, 
      SystemInformationBlockType12_r9_warningMessageSegmentType_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SystemInformationBlockType12_r9_warningMessageSegmentType_r9)
         SystemInformationBlockType12_r9_warningMessageSegmentType_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SystemInformationBlockType12_r9_warningMessageSegmentType_r9 (OSCTXT* pctxt, SystemInformationBlockType12_r9_warningMessageSegmentType_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType12_r9_warningMessageSegmentType_r9"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType12_r9_warningMessageSegmentType_r9 (OSCTXT* pctxt, SystemInformationBlockType12_r9_warningMessageSegmentType_r9* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_SystemInformationBlockType12_r9_dataCodingScheme_r9 (OSCTXT* pctxt, SystemInformationBlockType12_r9_dataCodingScheme_r9* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType12_r9_dataCodingScheme_r9"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType12_r9_dataCodingScheme_r9 (OSCTXT* pctxt, SystemInformationBlockType12_r9_dataCodingScheme_r9* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_SystemInformationBlockType12_r9_dataCodingScheme_r9 (
   SystemInformationBlockType12_r9_dataCodingScheme_r9* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

static const OSEnumItem AntennaInfoCommon_antennaPortsCount_ENUMTAB[] = {
   { OSUTF8("an1"), 0, 3, 0 },
   { OSUTF8("an2"), 1, 3, 1 },
   { OSUTF8("an4"), 2, 3, 2 },
   { OSUTF8("spare1"), 3, 6, 3 }
} ;
#define AntennaInfoCommon_antennaPortsCount_ENUMTABSIZE 4

const OSUTF8CHAR* AntennaInfoCommon_antennaPortsCount_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AntennaInfoCommon_antennaPortsCount_ENUMTABSIZE) {
      return AntennaInfoCommon_antennaPortsCount_ENUMTAB
         [AntennaInfoCommon_antennaPortsCount_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AntennaInfoCommon_antennaPortsCount_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AntennaInfoCommon_antennaPortsCount* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AntennaInfoCommon_antennaPortsCount_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AntennaInfoCommon_antennaPortsCount_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      AntennaInfoCommon_antennaPortsCount* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      AntennaInfoCommon_antennaPortsCount_ENUMTAB, 
      AntennaInfoCommon_antennaPortsCount_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AntennaInfoCommon_antennaPortsCount)
         AntennaInfoCommon_antennaPortsCount_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_AntennaInfoCommon_antennaPortsCount (OSCTXT* pctxt, AntennaInfoCommon_antennaPortsCount value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("AntennaInfoCommon_antennaPortsCount"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AntennaInfoCommon_antennaPortsCount (OSCTXT* pctxt, AntennaInfoCommon_antennaPortsCount* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem AntennaInfoDedicated_transmissionMode_ENUMTAB[] = {
   { OSUTF8("tm1"), 0, 3, 0 },
   { OSUTF8("tm2"), 1, 3, 1 },
   { OSUTF8("tm3"), 2, 3, 2 },
   { OSUTF8("tm4"), 3, 3, 3 },
   { OSUTF8("tm5"), 4, 3, 4 },
   { OSUTF8("tm6"), 5, 3, 5 },
   { OSUTF8("tm7"), 6, 3, 6 },
   { OSUTF8("tm8-v920"), 7, 8, 7 }
} ;
#define AntennaInfoDedicated_transmissionMode_ENUMTABSIZE 8

const OSUTF8CHAR* AntennaInfoDedicated_transmissionMode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AntennaInfoDedicated_transmissionMode_ENUMTABSIZE) {
      return AntennaInfoDedicated_transmissionMode_ENUMTAB
         [AntennaInfoDedicated_transmissionMode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AntennaInfoDedicated_transmissionMode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AntennaInfoDedicated_transmissionMode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AntennaInfoDedicated_transmissionMode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AntennaInfoDedicated_transmissionMode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      AntennaInfoDedicated_transmissionMode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      AntennaInfoDedicated_transmissionMode_ENUMTAB, 
      AntennaInfoDedicated_transmissionMode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AntennaInfoDedicated_transmissionMode)
         AntennaInfoDedicated_transmissionMode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_AntennaInfoDedicated_transmissionMode (OSCTXT* pctxt, AntennaInfoDedicated_transmissionMode value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("AntennaInfoDedicated_transmissionMode"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AntennaInfoDedicated_transmissionMode (OSCTXT* pctxt, AntennaInfoDedicated_transmissionMode* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4 (OSCTXT* pctxt, AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(64), OSUINTCONST(64), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4 (OSCTXT* pctxt, AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(64), OSUINTCONST(64), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4 (
   AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

static const OSEnumItem AntennaInfoDedicated_ue_TransmitAntennaSelection_setup_ENUMTAB[] = {
   { OSUTF8("closedLoop"), 0, 10, 0 },
   { OSUTF8("openLoop"), 1, 8, 1 }
} ;
#define AntennaInfoDedicated_ue_TransmitAntennaSelection_setup_ENUMTABSIZE 2

const OSUTF8CHAR* AntennaInfoDedicated_ue_TransmitAntennaSelection_setup_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AntennaInfoDedicated_ue_TransmitAntennaSelection_setup_ENUMTABSIZE) {
      return AntennaInfoDedicated_ue_TransmitAntennaSelection_setup_ENUMTAB
         [AntennaInfoDedicated_ue_TransmitAntennaSelection_setup_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AntennaInfoDedicated_ue_TransmitAntennaSelection_setup_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      AntennaInfoDedicated_ue_TransmitAntennaSelection_setup* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AntennaInfoDedicated_ue_TransmitAntennaSelection_setup_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AntennaInfoDedicated_ue_TransmitAntennaSelection_setup_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      AntennaInfoDedicated_ue_TransmitAntennaSelection_setup* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      AntennaInfoDedicated_ue_TransmitAntennaSelection_setup_ENUMTAB, 
      AntennaInfoDedicated_ue_TransmitAntennaSelection_setup_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AntennaInfoDedicated_ue_TransmitAntennaSelection_setup)
         AntennaInfoDedicated_ue_TransmitAntennaSelection_setup_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_AntennaInfoDedicated_ue_TransmitAntennaSelection_setup (OSCTXT* pctxt, AntennaInfoDedicated_ue_TransmitAntennaSelection_setup value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("AntennaInfoDedicated_ue_TransmitAntennaSelection_setup"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AntennaInfoDedicated_ue_TransmitAntennaSelection_setup (OSCTXT* pctxt, AntennaInfoDedicated_ue_TransmitAntennaSelection_setup* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem CQI_ReportConfig_cqi_ReportModeAperiodic_ENUMTAB[] = {
   { OSUTF8("rm12"), 0, 4, 0 },
   { OSUTF8("rm20"), 1, 4, 1 },
   { OSUTF8("rm22"), 2, 4, 2 },
   { OSUTF8("rm30"), 3, 4, 3 },
   { OSUTF8("rm31"), 4, 4, 4 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 }
} ;
#define CQI_ReportConfig_cqi_ReportModeAperiodic_ENUMTABSIZE 8

const OSUTF8CHAR* CQI_ReportConfig_cqi_ReportModeAperiodic_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < CQI_ReportConfig_cqi_ReportModeAperiodic_ENUMTABSIZE) {
      return CQI_ReportConfig_cqi_ReportModeAperiodic_ENUMTAB
         [CQI_ReportConfig_cqi_ReportModeAperiodic_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int CQI_ReportConfig_cqi_ReportModeAperiodic_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, CQI_ReportConfig_cqi_ReportModeAperiodic* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return CQI_ReportConfig_cqi_ReportModeAperiodic_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int CQI_ReportConfig_cqi_ReportModeAperiodic_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      CQI_ReportConfig_cqi_ReportModeAperiodic* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      CQI_ReportConfig_cqi_ReportModeAperiodic_ENUMTAB, 
      CQI_ReportConfig_cqi_ReportModeAperiodic_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (CQI_ReportConfig_cqi_ReportModeAperiodic)
         CQI_ReportConfig_cqi_ReportModeAperiodic_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_CQI_ReportConfig_cqi_ReportModeAperiodic (OSCTXT* pctxt, CQI_ReportConfig_cqi_ReportModeAperiodic value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CQI_ReportConfig_cqi_ReportModeAperiodic"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CQI_ReportConfig_cqi_ReportModeAperiodic (OSCTXT* pctxt, CQI_ReportConfig_cqi_ReportModeAperiodic* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem CQI_ReportConfig_v920_cqi_Mask_r9_ENUMTAB[] = {
   { OSUTF8("setup"), 0, 5, 0 }
} ;
#define CQI_ReportConfig_v920_cqi_Mask_r9_ENUMTABSIZE 1

const OSUTF8CHAR* CQI_ReportConfig_v920_cqi_Mask_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      CQI_ReportConfig_v920_cqi_Mask_r9_ENUMTAB, 
      CQI_ReportConfig_v920_cqi_Mask_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < CQI_ReportConfig_v920_cqi_Mask_r9_ENUMTABSIZE) {
      return CQI_ReportConfig_v920_cqi_Mask_r9_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int CQI_ReportConfig_v920_cqi_Mask_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, CQI_ReportConfig_v920_cqi_Mask_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return CQI_ReportConfig_v920_cqi_Mask_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int CQI_ReportConfig_v920_cqi_Mask_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      CQI_ReportConfig_v920_cqi_Mask_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      CQI_ReportConfig_v920_cqi_Mask_r9_ENUMTAB, 
      CQI_ReportConfig_v920_cqi_Mask_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (CQI_ReportConfig_v920_cqi_Mask_r9)
         CQI_ReportConfig_v920_cqi_Mask_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_CQI_ReportConfig_v920_cqi_Mask_r9 (OSCTXT* pctxt, CQI_ReportConfig_v920_cqi_Mask_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CQI_ReportConfig_v920_cqi_Mask_r9"));

   switch (value) {
      case setup: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CQI_ReportConfig_v920_cqi_Mask_r9 (OSCTXT* pctxt, CQI_ReportConfig_v920_cqi_Mask_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = setup; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem CQI_ReportConfig_v920_pmi_RI_Report_r9_ENUMTAB[] = {
   { OSUTF8("setup"), 0, 5, 0 }
} ;
#define CQI_ReportConfig_v920_pmi_RI_Report_r9_ENUMTABSIZE 1

const OSUTF8CHAR* CQI_ReportConfig_v920_pmi_RI_Report_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      CQI_ReportConfig_v920_pmi_RI_Report_r9_ENUMTAB, 
      CQI_ReportConfig_v920_pmi_RI_Report_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < CQI_ReportConfig_v920_pmi_RI_Report_r9_ENUMTABSIZE) {
      return CQI_ReportConfig_v920_pmi_RI_Report_r9_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int CQI_ReportConfig_v920_pmi_RI_Report_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, CQI_ReportConfig_v920_pmi_RI_Report_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return CQI_ReportConfig_v920_pmi_RI_Report_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int CQI_ReportConfig_v920_pmi_RI_Report_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      CQI_ReportConfig_v920_pmi_RI_Report_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      CQI_ReportConfig_v920_pmi_RI_Report_r9_ENUMTAB, 
      CQI_ReportConfig_v920_pmi_RI_Report_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (CQI_ReportConfig_v920_pmi_RI_Report_r9)
         CQI_ReportConfig_v920_pmi_RI_Report_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_CQI_ReportConfig_v920_pmi_RI_Report_r9 (OSCTXT* pctxt, CQI_ReportConfig_v920_pmi_RI_Report_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CQI_ReportConfig_v920_pmi_RI_Report_r9"));

   switch (value) {
      case setup_1: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CQI_ReportConfig_v920_pmi_RI_Report_r9 (OSCTXT* pctxt, CQI_ReportConfig_v920_pmi_RI_Report_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = setup_1; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate_ENUMTAB[] = {
   { OSUTF8("infinity"), 7, 8, 1 },
   { OSUTF8("kBps0"), 0, 5, 7 },
   { OSUTF8("kBps128"), 5, 7, 3 },
   { OSUTF8("kBps16"), 2, 6, 5 },
   { OSUTF8("kBps256"), 6, 7, 6 },
   { OSUTF8("kBps32"), 3, 6, 2 },
   { OSUTF8("kBps64"), 4, 6, 4 },
   { OSUTF8("kBps8"), 1, 5, 0 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 },
   { OSUTF8("spare6"), 10, 6, 10 },
   { OSUTF8("spare7"), 9, 6, 9 },
   { OSUTF8("spare8"), 8, 6, 8 }
} ;
#define LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate_ENUMTABSIZE 16

const OSUTF8CHAR* LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate_ENUMTABSIZE) {
      return LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate_ENUMTAB
         [LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate_ENUMTAB, 
      LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate)
         LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate (OSCTXT* pctxt, LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate (OSCTXT* pctxt, LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration_ENUMTAB[] = {
   { OSUTF8("ms100"), 1, 5, 4 },
   { OSUTF8("ms1000"), 5, 6, 0 },
   { OSUTF8("ms150"), 2, 5, 2 },
   { OSUTF8("ms300"), 3, 5, 3 },
   { OSUTF8("ms50"), 0, 4, 5 },
   { OSUTF8("ms500"), 4, 5, 1 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 }
} ;
#define LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration_ENUMTABSIZE 8

const OSUTF8CHAR* LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration_ENUMTABSIZE) {
      return LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration_ENUMTAB
         [LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration_ENUMTAB, 
      LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration)
         LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration (OSCTXT* pctxt, LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration (OSCTXT* pctxt, LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem LogicalChannelConfig_logicalChannelSR_Mask_r9_ENUMTAB[] = {
   { OSUTF8("setup"), 0, 5, 0 }
} ;
#define LogicalChannelConfig_logicalChannelSR_Mask_r9_ENUMTABSIZE 1

const OSUTF8CHAR* LogicalChannelConfig_logicalChannelSR_Mask_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      LogicalChannelConfig_logicalChannelSR_Mask_r9_ENUMTAB, 
      LogicalChannelConfig_logicalChannelSR_Mask_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < LogicalChannelConfig_logicalChannelSR_Mask_r9_ENUMTABSIZE) {
      return LogicalChannelConfig_logicalChannelSR_Mask_r9_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int LogicalChannelConfig_logicalChannelSR_Mask_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      LogicalChannelConfig_logicalChannelSR_Mask_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return LogicalChannelConfig_logicalChannelSR_Mask_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int LogicalChannelConfig_logicalChannelSR_Mask_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      LogicalChannelConfig_logicalChannelSR_Mask_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      LogicalChannelConfig_logicalChannelSR_Mask_r9_ENUMTAB, 
      LogicalChannelConfig_logicalChannelSR_Mask_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (LogicalChannelConfig_logicalChannelSR_Mask_r9)
         LogicalChannelConfig_logicalChannelSR_Mask_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_LogicalChannelConfig_logicalChannelSR_Mask_r9 (OSCTXT* pctxt, LogicalChannelConfig_logicalChannelSR_Mask_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("LogicalChannelConfig_logicalChannelSR_Mask_r9"));

   switch (value) {
      case setup_2: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_LogicalChannelConfig_logicalChannelSR_Mask_r9 (OSCTXT* pctxt, LogicalChannelConfig_logicalChannelSR_Mask_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = setup_2; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx_ENUMTAB[] = {
   { OSUTF8("n1"), 0, 2, 0 },
   { OSUTF8("n10"), 8, 3, 4 },
   { OSUTF8("n12"), 9, 3, 8 },
   { OSUTF8("n16"), 10, 3, 9 },
   { OSUTF8("n2"), 1, 2, 10 },
   { OSUTF8("n20"), 11, 3, 11 },
   { OSUTF8("n24"), 12, 3, 12 },
   { OSUTF8("n28"), 13, 3, 13 },
   { OSUTF8("n3"), 2, 2, 1 },
   { OSUTF8("n4"), 3, 2, 2 },
   { OSUTF8("n5"), 4, 2, 3 },
   { OSUTF8("n6"), 5, 2, 5 },
   { OSUTF8("n7"), 6, 2, 6 },
   { OSUTF8("n8"), 7, 2, 7 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 }
} ;
#define MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx_ENUMTABSIZE 16

const OSUTF8CHAR* MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx_ENUMTABSIZE) {
      return MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx_ENUMTAB
         [MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx_ENUMTAB, 
      MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx)
         MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx (OSCTXT* pctxt, MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx (OSCTXT* pctxt, MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer_ENUMTAB[] = {
   { OSUTF8("infinity"), 14, 8, 11 },
   { OSUTF8("sf10"), 1, 4, 1 },
   { OSUTF8("sf128"), 8, 5, 4 },
   { OSUTF8("sf1280"), 12, 6, 6 },
   { OSUTF8("sf16"), 2, 4, 8 },
   { OSUTF8("sf160"), 9, 5, 10 },
   { OSUTF8("sf20"), 3, 4, 12 },
   { OSUTF8("sf2560"), 13, 6, 14 },
   { OSUTF8("sf32"), 4, 4, 2 },
   { OSUTF8("sf320"), 10, 5, 5 },
   { OSUTF8("sf40"), 5, 4, 9 },
   { OSUTF8("sf5"), 0, 3, 13 },
   { OSUTF8("sf64"), 6, 4, 3 },
   { OSUTF8("sf640"), 11, 5, 7 },
   { OSUTF8("sf80"), 7, 4, 0 },
   { OSUTF8("spare1"), 15, 6, 15 }
} ;
#define MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer_ENUMTABSIZE 16

const OSUTF8CHAR* MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer_ENUMTABSIZE) {
      return MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer_ENUMTAB
         [MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer_ENUMTAB, 
      MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer)
         MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer (OSCTXT* pctxt, MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer (OSCTXT* pctxt, MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem MAC_MainConfig_ul_SCH_Config_retxBSR_Timer_ENUMTAB[] = {
   { OSUTF8("sf10240"), 5, 7, 3 },
   { OSUTF8("sf1280"), 2, 6, 5 },
   { OSUTF8("sf2560"), 3, 6, 1 },
   { OSUTF8("sf320"), 0, 5, 2 },
   { OSUTF8("sf5120"), 4, 6, 4 },
   { OSUTF8("sf640"), 1, 5, 0 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 }
} ;
#define MAC_MainConfig_ul_SCH_Config_retxBSR_Timer_ENUMTABSIZE 8

const OSUTF8CHAR* MAC_MainConfig_ul_SCH_Config_retxBSR_Timer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MAC_MainConfig_ul_SCH_Config_retxBSR_Timer_ENUMTABSIZE) {
      return MAC_MainConfig_ul_SCH_Config_retxBSR_Timer_ENUMTAB
         [MAC_MainConfig_ul_SCH_Config_retxBSR_Timer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MAC_MainConfig_ul_SCH_Config_retxBSR_Timer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, MAC_MainConfig_ul_SCH_Config_retxBSR_Timer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MAC_MainConfig_ul_SCH_Config_retxBSR_Timer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MAC_MainConfig_ul_SCH_Config_retxBSR_Timer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MAC_MainConfig_ul_SCH_Config_retxBSR_Timer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MAC_MainConfig_ul_SCH_Config_retxBSR_Timer_ENUMTAB, 
      MAC_MainConfig_ul_SCH_Config_retxBSR_Timer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MAC_MainConfig_ul_SCH_Config_retxBSR_Timer)
         MAC_MainConfig_ul_SCH_Config_retxBSR_Timer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MAC_MainConfig_ul_SCH_Config_retxBSR_Timer (OSCTXT* pctxt, MAC_MainConfig_ul_SCH_Config_retxBSR_Timer value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MAC_MainConfig_ul_SCH_Config_retxBSR_Timer"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MAC_MainConfig_ul_SCH_Config_retxBSR_Timer (OSCTXT* pctxt, MAC_MainConfig_ul_SCH_Config_retxBSR_Timer* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem MAC_MainConfig_phr_Config_setup_periodicPHR_Timer_ENUMTAB[] = {
   { OSUTF8("infinity"), 7, 8, 1 },
   { OSUTF8("sf10"), 0, 4, 4 },
   { OSUTF8("sf100"), 3, 5, 6 },
   { OSUTF8("sf1000"), 6, 6, 2 },
   { OSUTF8("sf20"), 1, 4, 5 },
   { OSUTF8("sf200"), 4, 5, 7 },
   { OSUTF8("sf50"), 2, 4, 3 },
   { OSUTF8("sf500"), 5, 5, 0 }
} ;
#define MAC_MainConfig_phr_Config_setup_periodicPHR_Timer_ENUMTABSIZE 8

const OSUTF8CHAR* MAC_MainConfig_phr_Config_setup_periodicPHR_Timer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MAC_MainConfig_phr_Config_setup_periodicPHR_Timer_ENUMTABSIZE) {
      return MAC_MainConfig_phr_Config_setup_periodicPHR_Timer_ENUMTAB
         [MAC_MainConfig_phr_Config_setup_periodicPHR_Timer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MAC_MainConfig_phr_Config_setup_periodicPHR_Timer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      MAC_MainConfig_phr_Config_setup_periodicPHR_Timer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MAC_MainConfig_phr_Config_setup_periodicPHR_Timer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MAC_MainConfig_phr_Config_setup_periodicPHR_Timer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MAC_MainConfig_phr_Config_setup_periodicPHR_Timer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MAC_MainConfig_phr_Config_setup_periodicPHR_Timer_ENUMTAB, 
      MAC_MainConfig_phr_Config_setup_periodicPHR_Timer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MAC_MainConfig_phr_Config_setup_periodicPHR_Timer)
         MAC_MainConfig_phr_Config_setup_periodicPHR_Timer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MAC_MainConfig_phr_Config_setup_periodicPHR_Timer (OSCTXT* pctxt, MAC_MainConfig_phr_Config_setup_periodicPHR_Timer value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MAC_MainConfig_phr_Config_setup_periodicPHR_Timer"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MAC_MainConfig_phr_Config_setup_periodicPHR_Timer (OSCTXT* pctxt, MAC_MainConfig_phr_Config_setup_periodicPHR_Timer* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer_ENUMTAB[] = {
   { OSUTF8("sf0"), 0, 3, 0 },
   { OSUTF8("sf10"), 1, 4, 1 },
   { OSUTF8("sf100"), 4, 5, 4 },
   { OSUTF8("sf1000"), 7, 6, 6 },
   { OSUTF8("sf20"), 2, 4, 2 },
   { OSUTF8("sf200"), 5, 5, 5 },
   { OSUTF8("sf50"), 3, 4, 7 },
   { OSUTF8("sf500"), 6, 5, 3 }
} ;
#define MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer_ENUMTABSIZE 8

const OSUTF8CHAR* MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer_ENUMTABSIZE) {
      return MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer_ENUMTAB
         [MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer_ENUMTAB, 
      MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer)
         MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer (OSCTXT* pctxt, MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer (OSCTXT* pctxt, MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem MAC_MainConfig_phr_Config_setup_dl_PathlossChange_ENUMTAB[] = {
   { OSUTF8("dB1"), 0, 3, 0 },
   { OSUTF8("dB3"), 1, 3, 1 },
   { OSUTF8("dB6"), 2, 3, 2 },
   { OSUTF8("infinity"), 3, 8, 3 }
} ;
#define MAC_MainConfig_phr_Config_setup_dl_PathlossChange_ENUMTABSIZE 4

const OSUTF8CHAR* MAC_MainConfig_phr_Config_setup_dl_PathlossChange_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MAC_MainConfig_phr_Config_setup_dl_PathlossChange_ENUMTABSIZE) {
      return MAC_MainConfig_phr_Config_setup_dl_PathlossChange_ENUMTAB
         [MAC_MainConfig_phr_Config_setup_dl_PathlossChange_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MAC_MainConfig_phr_Config_setup_dl_PathlossChange_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      MAC_MainConfig_phr_Config_setup_dl_PathlossChange* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MAC_MainConfig_phr_Config_setup_dl_PathlossChange_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MAC_MainConfig_phr_Config_setup_dl_PathlossChange_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MAC_MainConfig_phr_Config_setup_dl_PathlossChange* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MAC_MainConfig_phr_Config_setup_dl_PathlossChange_ENUMTAB, 
      MAC_MainConfig_phr_Config_setup_dl_PathlossChange_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MAC_MainConfig_phr_Config_setup_dl_PathlossChange)
         MAC_MainConfig_phr_Config_setup_dl_PathlossChange_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MAC_MainConfig_phr_Config_setup_dl_PathlossChange (OSCTXT* pctxt, MAC_MainConfig_phr_Config_setup_dl_PathlossChange value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MAC_MainConfig_phr_Config_setup_dl_PathlossChange"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MAC_MainConfig_phr_Config_setup_dl_PathlossChange (OSCTXT* pctxt, MAC_MainConfig_phr_Config_setup_dl_PathlossChange* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem DRX_Config_setup_onDurationTimer_ENUMTAB[] = {
   { OSUTF8("psf1"), 0, 4, 0 },
   { OSUTF8("psf10"), 7, 5, 3 },
   { OSUTF8("psf100"), 14, 6, 6 },
   { OSUTF8("psf2"), 1, 4, 8 },
   { OSUTF8("psf20"), 8, 5, 10 },
   { OSUTF8("psf200"), 15, 6, 12 },
   { OSUTF8("psf3"), 2, 4, 14 },
   { OSUTF8("psf30"), 9, 5, 1 },
   { OSUTF8("psf4"), 3, 4, 4 },
   { OSUTF8("psf40"), 10, 5, 7 },
   { OSUTF8("psf5"), 4, 4, 9 },
   { OSUTF8("psf50"), 11, 5, 11 },
   { OSUTF8("psf6"), 5, 4, 13 },
   { OSUTF8("psf60"), 12, 5, 15 },
   { OSUTF8("psf8"), 6, 4, 2 },
   { OSUTF8("psf80"), 13, 5, 5 }
} ;
#define DRX_Config_setup_onDurationTimer_ENUMTABSIZE 16

const OSUTF8CHAR* DRX_Config_setup_onDurationTimer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < DRX_Config_setup_onDurationTimer_ENUMTABSIZE) {
      return DRX_Config_setup_onDurationTimer_ENUMTAB
         [DRX_Config_setup_onDurationTimer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int DRX_Config_setup_onDurationTimer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, DRX_Config_setup_onDurationTimer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return DRX_Config_setup_onDurationTimer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int DRX_Config_setup_onDurationTimer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      DRX_Config_setup_onDurationTimer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      DRX_Config_setup_onDurationTimer_ENUMTAB, 
      DRX_Config_setup_onDurationTimer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (DRX_Config_setup_onDurationTimer)
         DRX_Config_setup_onDurationTimer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_DRX_Config_setup_onDurationTimer (OSCTXT* pctxt, DRX_Config_setup_onDurationTimer value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRX_Config_setup_onDurationTimer"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRX_Config_setup_onDurationTimer (OSCTXT* pctxt, DRX_Config_setup_onDurationTimer* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem DRX_Config_setup_drx_InactivityTimer_ENUMTAB[] = {
   { OSUTF8("psf1"), 0, 4, 0 },
   { OSUTF8("psf10"), 7, 5, 5 },
   { OSUTF8("psf100"), 14, 6, 9 },
   { OSUTF8("psf1280"), 19, 7, 12 },
   { OSUTF8("psf1920"), 20, 7, 14 },
   { OSUTF8("psf2"), 1, 4, 17 },
   { OSUTF8("psf20"), 8, 5, 20 },
   { OSUTF8("psf200"), 15, 6, 1 },
   { OSUTF8("psf2560"), 21, 7, 6 },
   { OSUTF8("psf3"), 2, 4, 10 },
   { OSUTF8("psf30"), 9, 5, 13 },
   { OSUTF8("psf300"), 16, 6, 15 },
   { OSUTF8("psf4"), 3, 4, 18 },
   { OSUTF8("psf40"), 10, 5, 21 },
   { OSUTF8("psf5"), 4, 4, 2 },
   { OSUTF8("psf50"), 11, 5, 7 },
   { OSUTF8("psf500"), 17, 6, 11 },
   { OSUTF8("psf6"), 5, 4, 16 },
   { OSUTF8("psf60"), 12, 5, 19 },
   { OSUTF8("psf750"), 18, 6, 3 },
   { OSUTF8("psf8"), 6, 4, 4 },
   { OSUTF8("psf80"), 13, 5, 8 },
   { OSUTF8("spare1"), 31, 6, 23 },
   { OSUTF8("spare10"), 22, 7, 31 },
   { OSUTF8("spare2"), 30, 6, 30 },
   { OSUTF8("spare3"), 29, 6, 29 },
   { OSUTF8("spare4"), 28, 6, 28 },
   { OSUTF8("spare5"), 27, 6, 27 },
   { OSUTF8("spare6"), 26, 6, 26 },
   { OSUTF8("spare7"), 25, 6, 25 },
   { OSUTF8("spare8"), 24, 6, 24 },
   { OSUTF8("spare9"), 23, 6, 22 }
} ;
#define DRX_Config_setup_drx_InactivityTimer_ENUMTABSIZE 32

const OSUTF8CHAR* DRX_Config_setup_drx_InactivityTimer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < DRX_Config_setup_drx_InactivityTimer_ENUMTABSIZE) {
      return DRX_Config_setup_drx_InactivityTimer_ENUMTAB
         [DRX_Config_setup_drx_InactivityTimer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int DRX_Config_setup_drx_InactivityTimer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, DRX_Config_setup_drx_InactivityTimer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return DRX_Config_setup_drx_InactivityTimer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int DRX_Config_setup_drx_InactivityTimer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      DRX_Config_setup_drx_InactivityTimer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      DRX_Config_setup_drx_InactivityTimer_ENUMTAB, 
      DRX_Config_setup_drx_InactivityTimer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (DRX_Config_setup_drx_InactivityTimer)
         DRX_Config_setup_drx_InactivityTimer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_DRX_Config_setup_drx_InactivityTimer (OSCTXT* pctxt, DRX_Config_setup_drx_InactivityTimer value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRX_Config_setup_drx_InactivityTimer"));

   if (value >= 32) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(31));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRX_Config_setup_drx_InactivityTimer (OSCTXT* pctxt, DRX_Config_setup_drx_InactivityTimer* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(31));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem DRX_Config_setup_drx_RetransmissionTimer_ENUMTAB[] = {
   { OSUTF8("psf1"), 0, 4, 0 },
   { OSUTF8("psf16"), 5, 5, 2 },
   { OSUTF8("psf2"), 1, 4, 5 },
   { OSUTF8("psf24"), 6, 5, 6 },
   { OSUTF8("psf33"), 7, 5, 7 },
   { OSUTF8("psf4"), 2, 4, 1 },
   { OSUTF8("psf6"), 3, 4, 3 },
   { OSUTF8("psf8"), 4, 4, 4 }
} ;
#define DRX_Config_setup_drx_RetransmissionTimer_ENUMTABSIZE 8

const OSUTF8CHAR* DRX_Config_setup_drx_RetransmissionTimer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < DRX_Config_setup_drx_RetransmissionTimer_ENUMTABSIZE) {
      return DRX_Config_setup_drx_RetransmissionTimer_ENUMTAB
         [DRX_Config_setup_drx_RetransmissionTimer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int DRX_Config_setup_drx_RetransmissionTimer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, DRX_Config_setup_drx_RetransmissionTimer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return DRX_Config_setup_drx_RetransmissionTimer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int DRX_Config_setup_drx_RetransmissionTimer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      DRX_Config_setup_drx_RetransmissionTimer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      DRX_Config_setup_drx_RetransmissionTimer_ENUMTAB, 
      DRX_Config_setup_drx_RetransmissionTimer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (DRX_Config_setup_drx_RetransmissionTimer)
         DRX_Config_setup_drx_RetransmissionTimer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_DRX_Config_setup_drx_RetransmissionTimer (OSCTXT* pctxt, DRX_Config_setup_drx_RetransmissionTimer value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRX_Config_setup_drx_RetransmissionTimer"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRX_Config_setup_drx_RetransmissionTimer (OSCTXT* pctxt, DRX_Config_setup_drx_RetransmissionTimer* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem DRX_Config_setup_shortDRX_shortDRX_Cycle_ENUMTAB[] = {
   { OSUTF8("sf10"), 3, 4, 4 },
   { OSUTF8("sf128"), 10, 5, 10 },
   { OSUTF8("sf16"), 4, 4, 14 },
   { OSUTF8("sf160"), 11, 5, 0 },
   { OSUTF8("sf2"), 0, 3, 2 },
   { OSUTF8("sf20"), 5, 4, 5 },
   { OSUTF8("sf256"), 12, 5, 7 },
   { OSUTF8("sf32"), 6, 4, 9 },
   { OSUTF8("sf320"), 13, 5, 12 },
   { OSUTF8("sf40"), 7, 4, 15 },
   { OSUTF8("sf5"), 1, 3, 1 },
   { OSUTF8("sf512"), 14, 5, 3 },
   { OSUTF8("sf64"), 8, 4, 6 },
   { OSUTF8("sf640"), 15, 5, 8 },
   { OSUTF8("sf8"), 2, 3, 11 },
   { OSUTF8("sf80"), 9, 4, 13 }
} ;
#define DRX_Config_setup_shortDRX_shortDRX_Cycle_ENUMTABSIZE 16

const OSUTF8CHAR* DRX_Config_setup_shortDRX_shortDRX_Cycle_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < DRX_Config_setup_shortDRX_shortDRX_Cycle_ENUMTABSIZE) {
      return DRX_Config_setup_shortDRX_shortDRX_Cycle_ENUMTAB
         [DRX_Config_setup_shortDRX_shortDRX_Cycle_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int DRX_Config_setup_shortDRX_shortDRX_Cycle_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, DRX_Config_setup_shortDRX_shortDRX_Cycle* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return DRX_Config_setup_shortDRX_shortDRX_Cycle_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int DRX_Config_setup_shortDRX_shortDRX_Cycle_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      DRX_Config_setup_shortDRX_shortDRX_Cycle* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      DRX_Config_setup_shortDRX_shortDRX_Cycle_ENUMTAB, 
      DRX_Config_setup_shortDRX_shortDRX_Cycle_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (DRX_Config_setup_shortDRX_shortDRX_Cycle)
         DRX_Config_setup_shortDRX_shortDRX_Cycle_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_DRX_Config_setup_shortDRX_shortDRX_Cycle (OSCTXT* pctxt, DRX_Config_setup_shortDRX_shortDRX_Cycle value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRX_Config_setup_shortDRX_shortDRX_Cycle"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRX_Config_setup_shortDRX_shortDRX_Cycle (OSCTXT* pctxt, DRX_Config_setup_shortDRX_shortDRX_Cycle* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem PDCP_Config_discardTimer_ENUMTAB[] = {
   { OSUTF8("infinity"), 7, 8, 5 },
   { OSUTF8("ms100"), 1, 5, 1 },
   { OSUTF8("ms150"), 2, 5, 2 },
   { OSUTF8("ms1500"), 6, 6, 4 },
   { OSUTF8("ms300"), 3, 5, 6 },
   { OSUTF8("ms50"), 0, 4, 7 },
   { OSUTF8("ms500"), 4, 5, 3 },
   { OSUTF8("ms750"), 5, 5, 0 }
} ;
#define PDCP_Config_discardTimer_ENUMTABSIZE 8

const OSUTF8CHAR* PDCP_Config_discardTimer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PDCP_Config_discardTimer_ENUMTABSIZE) {
      return PDCP_Config_discardTimer_ENUMTAB
         [PDCP_Config_discardTimer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PDCP_Config_discardTimer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PDCP_Config_discardTimer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PDCP_Config_discardTimer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PDCP_Config_discardTimer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, PDCP_Config_discardTimer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PDCP_Config_discardTimer_ENUMTAB, PDCP_Config_discardTimer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PDCP_Config_discardTimer)
         PDCP_Config_discardTimer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PDCP_Config_discardTimer (OSCTXT* pctxt, PDCP_Config_discardTimer value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PDCP_Config_discardTimer"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDCP_Config_discardTimer (OSCTXT* pctxt, PDCP_Config_discardTimer* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem PDCP_Config_rlc_UM_pdcp_SN_Size_ENUMTAB[] = {
   { OSUTF8("len12bits"), 1, 9, 1 },
   { OSUTF8("len7bits"), 0, 8, 0 }
} ;
#define PDCP_Config_rlc_UM_pdcp_SN_Size_ENUMTABSIZE 2

const OSUTF8CHAR* PDCP_Config_rlc_UM_pdcp_SN_Size_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PDCP_Config_rlc_UM_pdcp_SN_Size_ENUMTABSIZE) {
      return PDCP_Config_rlc_UM_pdcp_SN_Size_ENUMTAB
         [PDCP_Config_rlc_UM_pdcp_SN_Size_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PDCP_Config_rlc_UM_pdcp_SN_Size_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PDCP_Config_rlc_UM_pdcp_SN_Size* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PDCP_Config_rlc_UM_pdcp_SN_Size_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PDCP_Config_rlc_UM_pdcp_SN_Size_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PDCP_Config_rlc_UM_pdcp_SN_Size* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PDCP_Config_rlc_UM_pdcp_SN_Size_ENUMTAB, 
      PDCP_Config_rlc_UM_pdcp_SN_Size_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PDCP_Config_rlc_UM_pdcp_SN_Size)
         PDCP_Config_rlc_UM_pdcp_SN_Size_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PDCP_Config_rlc_UM_pdcp_SN_Size (OSCTXT* pctxt, PDCP_Config_rlc_UM_pdcp_SN_Size value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PDCP_Config_rlc_UM_pdcp_SN_Size"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDCP_Config_rlc_UM_pdcp_SN_Size (OSCTXT* pctxt, PDCP_Config_rlc_UM_pdcp_SN_Size* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem PDSCH_ConfigDedicated_p_a_ENUMTAB[] = {
   { OSUTF8("dB-1dot77"), 3, 9, 3 },
   { OSUTF8("dB-3"), 2, 4, 2 },
   { OSUTF8("dB-4dot77"), 1, 9, 1 },
   { OSUTF8("dB-6"), 0, 4, 0 },
   { OSUTF8("dB0"), 4, 3, 4 },
   { OSUTF8("dB1"), 5, 3, 5 },
   { OSUTF8("dB2"), 6, 3, 6 },
   { OSUTF8("dB3"), 7, 3, 7 }
} ;
#define PDSCH_ConfigDedicated_p_a_ENUMTABSIZE 8

const OSUTF8CHAR* PDSCH_ConfigDedicated_p_a_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PDSCH_ConfigDedicated_p_a_ENUMTABSIZE) {
      return PDSCH_ConfigDedicated_p_a_ENUMTAB
         [PDSCH_ConfigDedicated_p_a_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PDSCH_ConfigDedicated_p_a_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PDSCH_ConfigDedicated_p_a* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PDSCH_ConfigDedicated_p_a_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PDSCH_ConfigDedicated_p_a_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, PDSCH_ConfigDedicated_p_a* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PDSCH_ConfigDedicated_p_a_ENUMTAB, 
      PDSCH_ConfigDedicated_p_a_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PDSCH_ConfigDedicated_p_a)
         PDSCH_ConfigDedicated_p_a_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PDSCH_ConfigDedicated_p_a (OSCTXT* pctxt, PDSCH_ConfigDedicated_p_a value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PDSCH_ConfigDedicated_p_a"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDSCH_ConfigDedicated_p_a (OSCTXT* pctxt, PDSCH_ConfigDedicated_p_a* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem PUCCH_ConfigCommon_deltaPUCCH_Shift_ENUMTAB[] = {
   { OSUTF8("ds1"), 0, 3, 0 },
   { OSUTF8("ds2"), 1, 3, 1 },
   { OSUTF8("ds3"), 2, 3, 2 }
} ;
#define PUCCH_ConfigCommon_deltaPUCCH_Shift_ENUMTABSIZE 3

const OSUTF8CHAR* PUCCH_ConfigCommon_deltaPUCCH_Shift_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PUCCH_ConfigCommon_deltaPUCCH_Shift_ENUMTABSIZE) {
      return PUCCH_ConfigCommon_deltaPUCCH_Shift_ENUMTAB
         [PUCCH_ConfigCommon_deltaPUCCH_Shift_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PUCCH_ConfigCommon_deltaPUCCH_Shift_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PUCCH_ConfigCommon_deltaPUCCH_Shift* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PUCCH_ConfigCommon_deltaPUCCH_Shift_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PUCCH_ConfigCommon_deltaPUCCH_Shift_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PUCCH_ConfigCommon_deltaPUCCH_Shift* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PUCCH_ConfigCommon_deltaPUCCH_Shift_ENUMTAB, 
      PUCCH_ConfigCommon_deltaPUCCH_Shift_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PUCCH_ConfigCommon_deltaPUCCH_Shift)
         PUCCH_ConfigCommon_deltaPUCCH_Shift_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PUCCH_ConfigCommon_deltaPUCCH_Shift (OSCTXT* pctxt, PUCCH_ConfigCommon_deltaPUCCH_Shift value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PUCCH_ConfigCommon_deltaPUCCH_Shift"));

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PUCCH_ConfigCommon_deltaPUCCH_Shift (OSCTXT* pctxt, PUCCH_ConfigCommon_deltaPUCCH_Shift* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor_ENUMTAB[] = {
   { OSUTF8("n2"), 0, 2, 0 },
   { OSUTF8("n4"), 1, 2, 1 },
   { OSUTF8("n6"), 2, 2, 2 },
   { OSUTF8("spare1"), 3, 6, 3 }
} ;
#define PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor_ENUMTABSIZE 4

const OSUTF8CHAR* PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor_ENUMTABSIZE) {
      return PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor_ENUMTAB
         [PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor_ENUMTAB, 
      PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor)
         PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor (OSCTXT* pctxt, PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor (OSCTXT* pctxt, PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_ENUMTAB[] = {
   { OSUTF8("bundling"), 0, 8, 0 },
   { OSUTF8("multiplexing"), 1, 12, 1 }
} ;
#define PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_ENUMTABSIZE 2

const OSUTF8CHAR* PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_ENUMTABSIZE) {
      return PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_ENUMTAB
         [PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_ENUMTAB, 
      PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode)
         PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode (OSCTXT* pctxt, PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode (OSCTXT* pctxt, PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode_ENUMTAB[] = {
   { OSUTF8("interSubFrame"), 0, 13, 0 },
   { OSUTF8("intraAndInterSubFrame"), 1, 21, 1 }
} ;
#define PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode_ENUMTABSIZE 2

const OSUTF8CHAR* PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode_ENUMTABSIZE) {
      return PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode_ENUMTAB
         [PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode_ENUMTAB, 
      PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode)
         PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode (OSCTXT* pctxt, PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode (OSCTXT* pctxt, PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles_ENUMTAB[] = {
   { OSUTF8("n12"), 2, 3, 7 },
   { OSUTF8("n16"), 3, 3, 15 },
   { OSUTF8("n20"), 4, 3, 0 },
   { OSUTF8("n24"), 5, 3, 1 },
   { OSUTF8("n28"), 6, 3, 2 },
   { OSUTF8("n32"), 7, 3, 3 },
   { OSUTF8("n36"), 8, 3, 4 },
   { OSUTF8("n4"), 0, 2, 5 },
   { OSUTF8("n40"), 9, 3, 6 },
   { OSUTF8("n44"), 10, 3, 8 },
   { OSUTF8("n48"), 11, 3, 9 },
   { OSUTF8("n52"), 12, 3, 10 },
   { OSUTF8("n56"), 13, 3, 11 },
   { OSUTF8("n60"), 14, 3, 12 },
   { OSUTF8("n64"), 15, 3, 13 },
   { OSUTF8("n8"), 1, 2, 14 }
} ;
#define RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles_ENUMTABSIZE 16

const OSUTF8CHAR* RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles_ENUMTABSIZE) {
      return RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles_ENUMTAB
         [RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles_ENUMTAB, 
      RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles)
         RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles (OSCTXT* pctxt, RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles (OSCTXT* pctxt, RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA_ENUMTAB[] = {
   { OSUTF8("n12"), 2, 3, 7 },
   { OSUTF8("n16"), 3, 3, 14 },
   { OSUTF8("n20"), 4, 3, 0 },
   { OSUTF8("n24"), 5, 3, 1 },
   { OSUTF8("n28"), 6, 3, 2 },
   { OSUTF8("n32"), 7, 3, 3 },
   { OSUTF8("n36"), 8, 3, 4 },
   { OSUTF8("n4"), 0, 2, 5 },
   { OSUTF8("n40"), 9, 3, 6 },
   { OSUTF8("n44"), 10, 3, 8 },
   { OSUTF8("n48"), 11, 3, 9 },
   { OSUTF8("n52"), 12, 3, 10 },
   { OSUTF8("n56"), 13, 3, 11 },
   { OSUTF8("n60"), 14, 3, 12 },
   { OSUTF8("n8"), 1, 2, 13 }
} ;
#define RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA_ENUMTABSIZE 15

const OSUTF8CHAR* RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA_ENUMTABSIZE) {
      return RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA_ENUMTAB
         [RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA_ENUMTAB, 
      RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA)
         RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA (OSCTXT* pctxt, RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA"));

   if (value >= 15) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(14));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA (OSCTXT* pctxt, RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(14));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA_ENUMTAB[] = {
   { OSUTF8("b144"), 1, 4, 3 },
   { OSUTF8("b208"), 2, 4, 0 },
   { OSUTF8("b256"), 3, 4, 1 },
   { OSUTF8("b56"), 0, 3, 2 }
} ;
#define RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA_ENUMTABSIZE 4

const OSUTF8CHAR* RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA_ENUMTABSIZE) {
      return RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA_ENUMTAB
         [RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA_ENUMTAB, 
      RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA)
         RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA (OSCTXT* pctxt, RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA (OSCTXT* pctxt, RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB_ENUMTAB[] = {
   { OSUTF8("dB0"), 1, 3, 7 },
   { OSUTF8("dB10"), 4, 4, 0 },
   { OSUTF8("dB12"), 5, 4, 5 },
   { OSUTF8("dB15"), 6, 4, 6 },
   { OSUTF8("dB18"), 7, 4, 1 },
   { OSUTF8("dB5"), 2, 3, 2 },
   { OSUTF8("dB8"), 3, 3, 3 },
   { OSUTF8("minusinfinity"), 0, 13, 4 }
} ;
#define RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB_ENUMTABSIZE 8

const OSUTF8CHAR* RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB_ENUMTABSIZE) {
      return RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB_ENUMTAB
         [RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB_ENUMTAB, 
      RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB)
         RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB (OSCTXT* pctxt, RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB (OSCTXT* pctxt, RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RACH_ConfigCommon_powerRampingParameters_powerRampingStep_ENUMTAB[] = {
   { OSUTF8("dB0"), 0, 3, 0 },
   { OSUTF8("dB2"), 1, 3, 1 },
   { OSUTF8("dB4"), 2, 3, 2 },
   { OSUTF8("dB6"), 3, 3, 3 }
} ;
#define RACH_ConfigCommon_powerRampingParameters_powerRampingStep_ENUMTABSIZE 4

const OSUTF8CHAR* RACH_ConfigCommon_powerRampingParameters_powerRampingStep_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RACH_ConfigCommon_powerRampingParameters_powerRampingStep_ENUMTABSIZE) {
      return RACH_ConfigCommon_powerRampingParameters_powerRampingStep_ENUMTAB
         [RACH_ConfigCommon_powerRampingParameters_powerRampingStep_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RACH_ConfigCommon_powerRampingParameters_powerRampingStep_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      RACH_ConfigCommon_powerRampingParameters_powerRampingStep* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RACH_ConfigCommon_powerRampingParameters_powerRampingStep_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RACH_ConfigCommon_powerRampingParameters_powerRampingStep_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RACH_ConfigCommon_powerRampingParameters_powerRampingStep* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RACH_ConfigCommon_powerRampingParameters_powerRampingStep_ENUMTAB, 
      RACH_ConfigCommon_powerRampingParameters_powerRampingStep_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RACH_ConfigCommon_powerRampingParameters_powerRampingStep)
         RACH_ConfigCommon_powerRampingParameters_powerRampingStep_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RACH_ConfigCommon_powerRampingParameters_powerRampingStep (OSCTXT* pctxt, RACH_ConfigCommon_powerRampingParameters_powerRampingStep value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigCommon_powerRampingParameters_powerRampingStep"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigCommon_powerRampingParameters_powerRampingStep (OSCTXT* pctxt, RACH_ConfigCommon_powerRampingParameters_powerRampingStep* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower_ENUMTAB[] = {
   { OSUTF8("dBm-100"), 10, 7, 10 },
   { OSUTF8("dBm-102"), 9, 7, 9 },
   { OSUTF8("dBm-104"), 8, 7, 8 },
   { OSUTF8("dBm-106"), 7, 7, 7 },
   { OSUTF8("dBm-108"), 6, 7, 6 },
   { OSUTF8("dBm-110"), 5, 7, 5 },
   { OSUTF8("dBm-112"), 4, 7, 4 },
   { OSUTF8("dBm-114"), 3, 7, 3 },
   { OSUTF8("dBm-116"), 2, 7, 2 },
   { OSUTF8("dBm-118"), 1, 7, 1 },
   { OSUTF8("dBm-120"), 0, 7, 0 },
   { OSUTF8("dBm-90"), 15, 6, 15 },
   { OSUTF8("dBm-92"), 14, 6, 14 },
   { OSUTF8("dBm-94"), 13, 6, 13 },
   { OSUTF8("dBm-96"), 12, 6, 12 },
   { OSUTF8("dBm-98"), 11, 6, 11 }
} ;
#define RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower_ENUMTABSIZE 16

const OSUTF8CHAR* RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower_ENUMTABSIZE) {
      return RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower_ENUMTAB
         [RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower_ENUMTAB, 
      RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower)
         RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower (OSCTXT* pctxt, RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower (OSCTXT* pctxt, RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax_ENUMTAB[] = {
   { OSUTF8("n10"), 6, 3, 4 },
   { OSUTF8("n100"), 9, 4, 5 },
   { OSUTF8("n20"), 7, 3, 6 },
   { OSUTF8("n200"), 10, 4, 8 },
   { OSUTF8("n3"), 0, 2, 9 },
   { OSUTF8("n4"), 1, 2, 10 },
   { OSUTF8("n5"), 2, 2, 0 },
   { OSUTF8("n50"), 8, 3, 2 },
   { OSUTF8("n6"), 3, 2, 7 },
   { OSUTF8("n7"), 4, 2, 1 },
   { OSUTF8("n8"), 5, 2, 3 }
} ;
#define RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax_ENUMTABSIZE 11

const OSUTF8CHAR* RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax_ENUMTABSIZE) {
      return RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax_ENUMTAB
         [RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax_ENUMTAB, 
      RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax)
         RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax (OSCTXT* pctxt, RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax"));

   if (value >= 11) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax (OSCTXT* pctxt, RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize_ENUMTAB[] = {
   { OSUTF8("sf10"), 7, 4, 1 },
   { OSUTF8("sf2"), 0, 3, 2 },
   { OSUTF8("sf3"), 1, 3, 3 },
   { OSUTF8("sf4"), 2, 3, 4 },
   { OSUTF8("sf5"), 3, 3, 5 },
   { OSUTF8("sf6"), 4, 3, 6 },
   { OSUTF8("sf7"), 5, 3, 7 },
   { OSUTF8("sf8"), 6, 3, 0 }
} ;
#define RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize_ENUMTABSIZE 8

const OSUTF8CHAR* RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize_ENUMTABSIZE) {
      return RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize_ENUMTAB
         [RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize_ENUMTAB, 
      RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize)
         RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize (OSCTXT* pctxt, RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize (OSCTXT* pctxt, RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer_ENUMTAB[] = {
   { OSUTF8("sf16"), 1, 4, 7 },
   { OSUTF8("sf24"), 2, 4, 0 },
   { OSUTF8("sf32"), 3, 4, 1 },
   { OSUTF8("sf40"), 4, 4, 2 },
   { OSUTF8("sf48"), 5, 4, 3 },
   { OSUTF8("sf56"), 6, 4, 4 },
   { OSUTF8("sf64"), 7, 4, 5 },
   { OSUTF8("sf8"), 0, 3, 6 }
} ;
#define RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer_ENUMTABSIZE 8

const OSUTF8CHAR* RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer_ENUMTABSIZE) {
      return RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer_ENUMTAB
         [RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer_ENUMTAB, 
      RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer)
         RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer (OSCTXT* pctxt, RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer (OSCTXT* pctxt, RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem BCCH_Config_modificationPeriodCoeff_ENUMTAB[] = {
   { OSUTF8("n16"), 3, 3, 1 },
   { OSUTF8("n2"), 0, 2, 2 },
   { OSUTF8("n4"), 1, 2, 3 },
   { OSUTF8("n8"), 2, 2, 0 }
} ;
#define BCCH_Config_modificationPeriodCoeff_ENUMTABSIZE 4

const OSUTF8CHAR* BCCH_Config_modificationPeriodCoeff_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < BCCH_Config_modificationPeriodCoeff_ENUMTABSIZE) {
      return BCCH_Config_modificationPeriodCoeff_ENUMTAB
         [BCCH_Config_modificationPeriodCoeff_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int BCCH_Config_modificationPeriodCoeff_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, BCCH_Config_modificationPeriodCoeff* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return BCCH_Config_modificationPeriodCoeff_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int BCCH_Config_modificationPeriodCoeff_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      BCCH_Config_modificationPeriodCoeff* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      BCCH_Config_modificationPeriodCoeff_ENUMTAB, 
      BCCH_Config_modificationPeriodCoeff_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (BCCH_Config_modificationPeriodCoeff)
         BCCH_Config_modificationPeriodCoeff_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_BCCH_Config_modificationPeriodCoeff (OSCTXT* pctxt, BCCH_Config_modificationPeriodCoeff value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("BCCH_Config_modificationPeriodCoeff"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BCCH_Config_modificationPeriodCoeff (OSCTXT* pctxt, BCCH_Config_modificationPeriodCoeff* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem PCCH_Config_defaultPagingCycle_ENUMTAB[] = {
   { OSUTF8("rf128"), 2, 5, 2 },
   { OSUTF8("rf256"), 3, 5, 3 },
   { OSUTF8("rf32"), 0, 4, 0 },
   { OSUTF8("rf64"), 1, 4, 1 }
} ;
#define PCCH_Config_defaultPagingCycle_ENUMTABSIZE 4

const OSUTF8CHAR* PCCH_Config_defaultPagingCycle_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PCCH_Config_defaultPagingCycle_ENUMTABSIZE) {
      return PCCH_Config_defaultPagingCycle_ENUMTAB
         [PCCH_Config_defaultPagingCycle_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PCCH_Config_defaultPagingCycle_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PCCH_Config_defaultPagingCycle* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PCCH_Config_defaultPagingCycle_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PCCH_Config_defaultPagingCycle_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PCCH_Config_defaultPagingCycle* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PCCH_Config_defaultPagingCycle_ENUMTAB, 
      PCCH_Config_defaultPagingCycle_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PCCH_Config_defaultPagingCycle)
         PCCH_Config_defaultPagingCycle_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PCCH_Config_defaultPagingCycle (OSCTXT* pctxt, PCCH_Config_defaultPagingCycle value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PCCH_Config_defaultPagingCycle"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PCCH_Config_defaultPagingCycle (OSCTXT* pctxt, PCCH_Config_defaultPagingCycle* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem PCCH_Config_nB_ENUMTAB[] = {
   { OSUTF8("fourT"), 0, 5, 0 },
   { OSUTF8("halfT"), 3, 5, 7 },
   { OSUTF8("oneEighthT"), 5, 10, 4 },
   { OSUTF8("oneSixteenthT"), 6, 13, 1 },
   { OSUTF8("oneT"), 2, 4, 6 },
   { OSUTF8("oneThirtySecondT"), 7, 16, 2 },
   { OSUTF8("quarterT"), 4, 8, 3 },
   { OSUTF8("twoT"), 1, 4, 5 }
} ;
#define PCCH_Config_nB_ENUMTABSIZE 8

const OSUTF8CHAR* PCCH_Config_nB_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PCCH_Config_nB_ENUMTABSIZE) {
      return PCCH_Config_nB_ENUMTAB
         [PCCH_Config_nB_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PCCH_Config_nB_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PCCH_Config_nB* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PCCH_Config_nB_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PCCH_Config_nB_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, PCCH_Config_nB* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, PCCH_Config_nB_ENUMTAB, 
      PCCH_Config_nB_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PCCH_Config_nB)PCCH_Config_nB_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PCCH_Config_nB (OSCTXT* pctxt, PCCH_Config_nB value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PCCH_Config_nB"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PCCH_Config_nB (OSCTXT* pctxt, PCCH_Config_nB* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem UL_AM_RLC_maxRetxThreshold_ENUMTAB[] = {
   { OSUTF8("t1"), 0, 2, 0 },
   { OSUTF8("t16"), 6, 3, 2 },
   { OSUTF8("t2"), 1, 2, 3 },
   { OSUTF8("t3"), 2, 2, 5 },
   { OSUTF8("t32"), 7, 3, 6 },
   { OSUTF8("t4"), 3, 2, 7 },
   { OSUTF8("t6"), 4, 2, 1 },
   { OSUTF8("t8"), 5, 2, 4 }
} ;
#define UL_AM_RLC_maxRetxThreshold_ENUMTABSIZE 8

const OSUTF8CHAR* UL_AM_RLC_maxRetxThreshold_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < UL_AM_RLC_maxRetxThreshold_ENUMTABSIZE) {
      return UL_AM_RLC_maxRetxThreshold_ENUMTAB
         [UL_AM_RLC_maxRetxThreshold_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UL_AM_RLC_maxRetxThreshold_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, UL_AM_RLC_maxRetxThreshold* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return UL_AM_RLC_maxRetxThreshold_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int UL_AM_RLC_maxRetxThreshold_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      UL_AM_RLC_maxRetxThreshold* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      UL_AM_RLC_maxRetxThreshold_ENUMTAB, 
      UL_AM_RLC_maxRetxThreshold_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UL_AM_RLC_maxRetxThreshold)
         UL_AM_RLC_maxRetxThreshold_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_UL_AM_RLC_maxRetxThreshold (OSCTXT* pctxt, UL_AM_RLC_maxRetxThreshold value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UL_AM_RLC_maxRetxThreshold"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_AM_RLC_maxRetxThreshold (OSCTXT* pctxt, UL_AM_RLC_maxRetxThreshold* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RLF_TimersAndConstants_r9_setup_t301_r9_ENUMTAB[] = {
   { OSUTF8("ms100"), 0, 5, 0 },
   { OSUTF8("ms1000"), 5, 6, 3 },
   { OSUTF8("ms1500"), 6, 6, 5 },
   { OSUTF8("ms200"), 1, 5, 6 },
   { OSUTF8("ms2000"), 7, 6, 7 },
   { OSUTF8("ms300"), 2, 5, 1 },
   { OSUTF8("ms400"), 3, 5, 2 },
   { OSUTF8("ms600"), 4, 5, 4 }
} ;
#define RLF_TimersAndConstants_r9_setup_t301_r9_ENUMTABSIZE 8

const OSUTF8CHAR* RLF_TimersAndConstants_r9_setup_t301_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RLF_TimersAndConstants_r9_setup_t301_r9_ENUMTABSIZE) {
      return RLF_TimersAndConstants_r9_setup_t301_r9_ENUMTAB
         [RLF_TimersAndConstants_r9_setup_t301_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RLF_TimersAndConstants_r9_setup_t301_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, RLF_TimersAndConstants_r9_setup_t301_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RLF_TimersAndConstants_r9_setup_t301_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RLF_TimersAndConstants_r9_setup_t301_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RLF_TimersAndConstants_r9_setup_t301_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RLF_TimersAndConstants_r9_setup_t301_r9_ENUMTAB, 
      RLF_TimersAndConstants_r9_setup_t301_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RLF_TimersAndConstants_r9_setup_t301_r9)
         RLF_TimersAndConstants_r9_setup_t301_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RLF_TimersAndConstants_r9_setup_t301_r9 (OSCTXT* pctxt, RLF_TimersAndConstants_r9_setup_t301_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLF_TimersAndConstants_r9_setup_t301_r9"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLF_TimersAndConstants_r9_setup_t301_r9 (OSCTXT* pctxt, RLF_TimersAndConstants_r9_setup_t301_r9* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RLF_TimersAndConstants_r9_setup_t310_r9_ENUMTAB[] = {
   { OSUTF8("ms0"), 0, 3, 0 },
   { OSUTF8("ms100"), 2, 5, 5 },
   { OSUTF8("ms1000"), 5, 6, 1 },
   { OSUTF8("ms200"), 3, 5, 3 },
   { OSUTF8("ms2000"), 6, 6, 6 },
   { OSUTF8("ms50"), 1, 4, 2 },
   { OSUTF8("ms500"), 4, 5, 4 }
} ;
#define RLF_TimersAndConstants_r9_setup_t310_r9_ENUMTABSIZE 7

const OSUTF8CHAR* RLF_TimersAndConstants_r9_setup_t310_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RLF_TimersAndConstants_r9_setup_t310_r9_ENUMTABSIZE) {
      return RLF_TimersAndConstants_r9_setup_t310_r9_ENUMTAB
         [RLF_TimersAndConstants_r9_setup_t310_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RLF_TimersAndConstants_r9_setup_t310_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, RLF_TimersAndConstants_r9_setup_t310_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RLF_TimersAndConstants_r9_setup_t310_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RLF_TimersAndConstants_r9_setup_t310_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RLF_TimersAndConstants_r9_setup_t310_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RLF_TimersAndConstants_r9_setup_t310_r9_ENUMTAB, 
      RLF_TimersAndConstants_r9_setup_t310_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RLF_TimersAndConstants_r9_setup_t310_r9)
         RLF_TimersAndConstants_r9_setup_t310_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RLF_TimersAndConstants_r9_setup_t310_r9 (OSCTXT* pctxt, RLF_TimersAndConstants_r9_setup_t310_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLF_TimersAndConstants_r9_setup_t310_r9"));

   if (value >= 7) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLF_TimersAndConstants_r9_setup_t310_r9 (OSCTXT* pctxt, RLF_TimersAndConstants_r9_setup_t310_r9* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RLF_TimersAndConstants_r9_setup_n310_r9_ENUMTAB[] = {
   { OSUTF8("n1"), 0, 2, 0 },
   { OSUTF8("n10"), 6, 3, 2 },
   { OSUTF8("n2"), 1, 2, 4 },
   { OSUTF8("n20"), 7, 3, 5 },
   { OSUTF8("n3"), 2, 2, 6 },
   { OSUTF8("n4"), 3, 2, 7 },
   { OSUTF8("n6"), 4, 2, 1 },
   { OSUTF8("n8"), 5, 2, 3 }
} ;
#define RLF_TimersAndConstants_r9_setup_n310_r9_ENUMTABSIZE 8

const OSUTF8CHAR* RLF_TimersAndConstants_r9_setup_n310_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RLF_TimersAndConstants_r9_setup_n310_r9_ENUMTABSIZE) {
      return RLF_TimersAndConstants_r9_setup_n310_r9_ENUMTAB
         [RLF_TimersAndConstants_r9_setup_n310_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RLF_TimersAndConstants_r9_setup_n310_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, RLF_TimersAndConstants_r9_setup_n310_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RLF_TimersAndConstants_r9_setup_n310_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RLF_TimersAndConstants_r9_setup_n310_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RLF_TimersAndConstants_r9_setup_n310_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RLF_TimersAndConstants_r9_setup_n310_r9_ENUMTAB, 
      RLF_TimersAndConstants_r9_setup_n310_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RLF_TimersAndConstants_r9_setup_n310_r9)
         RLF_TimersAndConstants_r9_setup_n310_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RLF_TimersAndConstants_r9_setup_n310_r9 (OSCTXT* pctxt, RLF_TimersAndConstants_r9_setup_n310_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLF_TimersAndConstants_r9_setup_n310_r9"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLF_TimersAndConstants_r9_setup_n310_r9 (OSCTXT* pctxt, RLF_TimersAndConstants_r9_setup_n310_r9* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RLF_TimersAndConstants_r9_setup_t311_r9_ENUMTAB[] = {
   { OSUTF8("ms1000"), 0, 6, 0 },
   { OSUTF8("ms10000"), 3, 7, 4 },
   { OSUTF8("ms15000"), 4, 7, 6 },
   { OSUTF8("ms20000"), 5, 7, 1 },
   { OSUTF8("ms3000"), 1, 6, 2 },
   { OSUTF8("ms30000"), 6, 7, 3 },
   { OSUTF8("ms5000"), 2, 6, 5 }
} ;
#define RLF_TimersAndConstants_r9_setup_t311_r9_ENUMTABSIZE 7

const OSUTF8CHAR* RLF_TimersAndConstants_r9_setup_t311_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RLF_TimersAndConstants_r9_setup_t311_r9_ENUMTABSIZE) {
      return RLF_TimersAndConstants_r9_setup_t311_r9_ENUMTAB
         [RLF_TimersAndConstants_r9_setup_t311_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RLF_TimersAndConstants_r9_setup_t311_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, RLF_TimersAndConstants_r9_setup_t311_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RLF_TimersAndConstants_r9_setup_t311_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RLF_TimersAndConstants_r9_setup_t311_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RLF_TimersAndConstants_r9_setup_t311_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RLF_TimersAndConstants_r9_setup_t311_r9_ENUMTAB, 
      RLF_TimersAndConstants_r9_setup_t311_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RLF_TimersAndConstants_r9_setup_t311_r9)
         RLF_TimersAndConstants_r9_setup_t311_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RLF_TimersAndConstants_r9_setup_t311_r9 (OSCTXT* pctxt, RLF_TimersAndConstants_r9_setup_t311_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLF_TimersAndConstants_r9_setup_t311_r9"));

   if (value >= 7) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLF_TimersAndConstants_r9_setup_t311_r9 (OSCTXT* pctxt, RLF_TimersAndConstants_r9_setup_t311_r9* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem RLF_TimersAndConstants_r9_setup_n311_r9_ENUMTAB[] = {
   { OSUTF8("n1"), 0, 2, 0 },
   { OSUTF8("n10"), 7, 3, 2 },
   { OSUTF8("n2"), 1, 2, 3 },
   { OSUTF8("n3"), 2, 2, 4 },
   { OSUTF8("n4"), 3, 2, 5 },
   { OSUTF8("n5"), 4, 2, 6 },
   { OSUTF8("n6"), 5, 2, 7 },
   { OSUTF8("n8"), 6, 2, 1 }
} ;
#define RLF_TimersAndConstants_r9_setup_n311_r9_ENUMTABSIZE 8

const OSUTF8CHAR* RLF_TimersAndConstants_r9_setup_n311_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RLF_TimersAndConstants_r9_setup_n311_r9_ENUMTABSIZE) {
      return RLF_TimersAndConstants_r9_setup_n311_r9_ENUMTAB
         [RLF_TimersAndConstants_r9_setup_n311_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RLF_TimersAndConstants_r9_setup_n311_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, RLF_TimersAndConstants_r9_setup_n311_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RLF_TimersAndConstants_r9_setup_n311_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RLF_TimersAndConstants_r9_setup_n311_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RLF_TimersAndConstants_r9_setup_n311_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RLF_TimersAndConstants_r9_setup_n311_r9_ENUMTAB, 
      RLF_TimersAndConstants_r9_setup_n311_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RLF_TimersAndConstants_r9_setup_n311_r9)
         RLF_TimersAndConstants_r9_setup_n311_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RLF_TimersAndConstants_r9_setup_n311_r9 (OSCTXT* pctxt, RLF_TimersAndConstants_r9_setup_n311_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLF_TimersAndConstants_r9_setup_n311_r9"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLF_TimersAndConstants_r9_setup_n311_r9 (OSCTXT* pctxt, RLF_TimersAndConstants_r9_setup_n311_r9* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SchedulingRequestConfig_setup_dsr_TransMax_ENUMTAB[] = {
   { OSUTF8("n16"), 2, 3, 2 },
   { OSUTF8("n32"), 3, 3, 4 },
   { OSUTF8("n4"), 0, 2, 0 },
   { OSUTF8("n64"), 4, 3, 1 },
   { OSUTF8("n8"), 1, 2, 3 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 }
} ;
#define SchedulingRequestConfig_setup_dsr_TransMax_ENUMTABSIZE 8

const OSUTF8CHAR* SchedulingRequestConfig_setup_dsr_TransMax_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SchedulingRequestConfig_setup_dsr_TransMax_ENUMTABSIZE) {
      return SchedulingRequestConfig_setup_dsr_TransMax_ENUMTAB
         [SchedulingRequestConfig_setup_dsr_TransMax_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SchedulingRequestConfig_setup_dsr_TransMax_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SchedulingRequestConfig_setup_dsr_TransMax* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SchedulingRequestConfig_setup_dsr_TransMax_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SchedulingRequestConfig_setup_dsr_TransMax_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SchedulingRequestConfig_setup_dsr_TransMax* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SchedulingRequestConfig_setup_dsr_TransMax_ENUMTAB, 
      SchedulingRequestConfig_setup_dsr_TransMax_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SchedulingRequestConfig_setup_dsr_TransMax)
         SchedulingRequestConfig_setup_dsr_TransMax_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SchedulingRequestConfig_setup_dsr_TransMax (OSCTXT* pctxt, SchedulingRequestConfig_setup_dsr_TransMax value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SchedulingRequestConfig_setup_dsr_TransMax"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SchedulingRequestConfig_setup_dsr_TransMax (OSCTXT* pctxt, SchedulingRequestConfig_setup_dsr_TransMax* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig_ENUMTAB[] = {
   { OSUTF8("bw0"), 0, 3, 0 },
   { OSUTF8("bw1"), 1, 3, 1 },
   { OSUTF8("bw2"), 2, 3, 2 },
   { OSUTF8("bw3"), 3, 3, 3 },
   { OSUTF8("bw4"), 4, 3, 4 },
   { OSUTF8("bw5"), 5, 3, 5 },
   { OSUTF8("bw6"), 6, 3, 6 },
   { OSUTF8("bw7"), 7, 3, 7 }
} ;
#define SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig_ENUMTABSIZE 8

const OSUTF8CHAR* SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig_ENUMTABSIZE) {
      return SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig_ENUMTAB
         [SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig_ENUMTAB, 
      SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig)
         SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig (OSCTXT* pctxt, SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig (OSCTXT* pctxt, SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig_ENUMTAB[] = {
   { OSUTF8("sc0"), 0, 3, 0 },
   { OSUTF8("sc1"), 1, 3, 1 },
   { OSUTF8("sc10"), 10, 4, 8 },
   { OSUTF8("sc11"), 11, 4, 9 },
   { OSUTF8("sc12"), 12, 4, 10 },
   { OSUTF8("sc13"), 13, 4, 11 },
   { OSUTF8("sc14"), 14, 4, 12 },
   { OSUTF8("sc15"), 15, 4, 13 },
   { OSUTF8("sc2"), 2, 3, 14 },
   { OSUTF8("sc3"), 3, 3, 15 },
   { OSUTF8("sc4"), 4, 3, 2 },
   { OSUTF8("sc5"), 5, 3, 3 },
   { OSUTF8("sc6"), 6, 3, 4 },
   { OSUTF8("sc7"), 7, 3, 5 },
   { OSUTF8("sc8"), 8, 3, 6 },
   { OSUTF8("sc9"), 9, 3, 7 }
} ;
#define SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig_ENUMTABSIZE 16

const OSUTF8CHAR* SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig_ENUMTABSIZE) {
      return SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig_ENUMTAB
         [SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig_ENUMTAB, 
      SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig)
         SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig (OSCTXT* pctxt, SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig (OSCTXT* pctxt, SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_ENUMTABSIZE 1

const OSUTF8CHAR* SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_ENUMTAB, 
      SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_ENUMTABSIZE);

   if (idx >= 0 && idx < SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_ENUMTABSIZE) {
      return SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_ENUMTAB, 
      SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts)
         SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts (OSCTXT* pctxt, SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts"));

   switch (value) {
      case true__6: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts (OSCTXT* pctxt, SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = true__6; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth_ENUMTAB[] = {
   { OSUTF8("bw0"), 0, 3, 0 },
   { OSUTF8("bw1"), 1, 3, 1 },
   { OSUTF8("bw2"), 2, 3, 2 },
   { OSUTF8("bw3"), 3, 3, 3 }
} ;
#define SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth_ENUMTABSIZE 4

const OSUTF8CHAR* SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth_ENUMTABSIZE) {
      return SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth_ENUMTAB
         [SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth_ENUMTAB, 
      SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth)
         SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth (OSCTXT* pctxt, SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth (OSCTXT* pctxt, SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth_ENUMTAB[] = {
   { OSUTF8("hbw0"), 0, 4, 0 },
   { OSUTF8("hbw1"), 1, 4, 1 },
   { OSUTF8("hbw2"), 2, 4, 2 },
   { OSUTF8("hbw3"), 3, 4, 3 }
} ;
#define SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth_ENUMTABSIZE 4

const OSUTF8CHAR* SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth_ENUMTABSIZE) {
      return SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth_ENUMTAB
         [SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth_ENUMTAB, 
      SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth)
         SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth (OSCTXT* pctxt, SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth (OSCTXT* pctxt, SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SoundingRS_UL_ConfigDedicated_setup_cyclicShift_ENUMTAB[] = {
   { OSUTF8("cs0"), 0, 3, 0 },
   { OSUTF8("cs1"), 1, 3, 1 },
   { OSUTF8("cs2"), 2, 3, 2 },
   { OSUTF8("cs3"), 3, 3, 3 },
   { OSUTF8("cs4"), 4, 3, 4 },
   { OSUTF8("cs5"), 5, 3, 5 },
   { OSUTF8("cs6"), 6, 3, 6 },
   { OSUTF8("cs7"), 7, 3, 7 }
} ;
#define SoundingRS_UL_ConfigDedicated_setup_cyclicShift_ENUMTABSIZE 8

const OSUTF8CHAR* SoundingRS_UL_ConfigDedicated_setup_cyclicShift_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SoundingRS_UL_ConfigDedicated_setup_cyclicShift_ENUMTABSIZE) {
      return SoundingRS_UL_ConfigDedicated_setup_cyclicShift_ENUMTAB
         [SoundingRS_UL_ConfigDedicated_setup_cyclicShift_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SoundingRS_UL_ConfigDedicated_setup_cyclicShift_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SoundingRS_UL_ConfigDedicated_setup_cyclicShift* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SoundingRS_UL_ConfigDedicated_setup_cyclicShift_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SoundingRS_UL_ConfigDedicated_setup_cyclicShift_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SoundingRS_UL_ConfigDedicated_setup_cyclicShift* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SoundingRS_UL_ConfigDedicated_setup_cyclicShift_ENUMTAB, 
      SoundingRS_UL_ConfigDedicated_setup_cyclicShift_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SoundingRS_UL_ConfigDedicated_setup_cyclicShift)
         SoundingRS_UL_ConfigDedicated_setup_cyclicShift_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SoundingRS_UL_ConfigDedicated_setup_cyclicShift (OSCTXT* pctxt, SoundingRS_UL_ConfigDedicated_setup_cyclicShift value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SoundingRS_UL_ConfigDedicated_setup_cyclicShift"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SoundingRS_UL_ConfigDedicated_setup_cyclicShift (OSCTXT* pctxt, SoundingRS_UL_ConfigDedicated_setup_cyclicShift* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SPS_ConfigDL_setup_semiPersistSchedIntervalDL_ENUMTAB[] = {
   { OSUTF8("sf10"), 0, 4, 0 },
   { OSUTF8("sf128"), 6, 5, 3 },
   { OSUTF8("sf160"), 7, 5, 4 },
   { OSUTF8("sf20"), 1, 4, 6 },
   { OSUTF8("sf32"), 2, 4, 7 },
   { OSUTF8("sf320"), 8, 5, 9 },
   { OSUTF8("sf40"), 3, 4, 1 },
   { OSUTF8("sf64"), 4, 4, 2 },
   { OSUTF8("sf640"), 9, 5, 5 },
   { OSUTF8("sf80"), 5, 4, 8 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 },
   { OSUTF8("spare6"), 10, 6, 10 }
} ;
#define SPS_ConfigDL_setup_semiPersistSchedIntervalDL_ENUMTABSIZE 16

const OSUTF8CHAR* SPS_ConfigDL_setup_semiPersistSchedIntervalDL_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SPS_ConfigDL_setup_semiPersistSchedIntervalDL_ENUMTABSIZE) {
      return SPS_ConfigDL_setup_semiPersistSchedIntervalDL_ENUMTAB
         [SPS_ConfigDL_setup_semiPersistSchedIntervalDL_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SPS_ConfigDL_setup_semiPersistSchedIntervalDL_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SPS_ConfigDL_setup_semiPersistSchedIntervalDL* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SPS_ConfigDL_setup_semiPersistSchedIntervalDL_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SPS_ConfigDL_setup_semiPersistSchedIntervalDL_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SPS_ConfigDL_setup_semiPersistSchedIntervalDL* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SPS_ConfigDL_setup_semiPersistSchedIntervalDL_ENUMTAB, 
      SPS_ConfigDL_setup_semiPersistSchedIntervalDL_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SPS_ConfigDL_setup_semiPersistSchedIntervalDL)
         SPS_ConfigDL_setup_semiPersistSchedIntervalDL_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SPS_ConfigDL_setup_semiPersistSchedIntervalDL (OSCTXT* pctxt, SPS_ConfigDL_setup_semiPersistSchedIntervalDL value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SPS_ConfigDL_setup_semiPersistSchedIntervalDL"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SPS_ConfigDL_setup_semiPersistSchedIntervalDL (OSCTXT* pctxt, SPS_ConfigDL_setup_semiPersistSchedIntervalDL* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SPS_ConfigUL_setup_semiPersistSchedIntervalUL_ENUMTAB[] = {
   { OSUTF8("sf10"), 0, 4, 0 },
   { OSUTF8("sf128"), 6, 5, 3 },
   { OSUTF8("sf160"), 7, 5, 4 },
   { OSUTF8("sf20"), 1, 4, 6 },
   { OSUTF8("sf32"), 2, 4, 7 },
   { OSUTF8("sf320"), 8, 5, 9 },
   { OSUTF8("sf40"), 3, 4, 1 },
   { OSUTF8("sf64"), 4, 4, 2 },
   { OSUTF8("sf640"), 9, 5, 5 },
   { OSUTF8("sf80"), 5, 4, 8 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 },
   { OSUTF8("spare6"), 10, 6, 10 }
} ;
#define SPS_ConfigUL_setup_semiPersistSchedIntervalUL_ENUMTABSIZE 16

const OSUTF8CHAR* SPS_ConfigUL_setup_semiPersistSchedIntervalUL_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SPS_ConfigUL_setup_semiPersistSchedIntervalUL_ENUMTABSIZE) {
      return SPS_ConfigUL_setup_semiPersistSchedIntervalUL_ENUMTAB
         [SPS_ConfigUL_setup_semiPersistSchedIntervalUL_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SPS_ConfigUL_setup_semiPersistSchedIntervalUL_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SPS_ConfigUL_setup_semiPersistSchedIntervalUL* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SPS_ConfigUL_setup_semiPersistSchedIntervalUL_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SPS_ConfigUL_setup_semiPersistSchedIntervalUL_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SPS_ConfigUL_setup_semiPersistSchedIntervalUL* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SPS_ConfigUL_setup_semiPersistSchedIntervalUL_ENUMTAB, 
      SPS_ConfigUL_setup_semiPersistSchedIntervalUL_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SPS_ConfigUL_setup_semiPersistSchedIntervalUL)
         SPS_ConfigUL_setup_semiPersistSchedIntervalUL_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SPS_ConfigUL_setup_semiPersistSchedIntervalUL (OSCTXT* pctxt, SPS_ConfigUL_setup_semiPersistSchedIntervalUL value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SPS_ConfigUL_setup_semiPersistSchedIntervalUL"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SPS_ConfigUL_setup_semiPersistSchedIntervalUL (OSCTXT* pctxt, SPS_ConfigUL_setup_semiPersistSchedIntervalUL* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SPS_ConfigUL_setup_implicitReleaseAfter_ENUMTAB[] = {
   { OSUTF8("e2"), 0, 2, 0 },
   { OSUTF8("e3"), 1, 2, 1 },
   { OSUTF8("e4"), 2, 2, 2 },
   { OSUTF8("e8"), 3, 2, 3 }
} ;
#define SPS_ConfigUL_setup_implicitReleaseAfter_ENUMTABSIZE 4

const OSUTF8CHAR* SPS_ConfigUL_setup_implicitReleaseAfter_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SPS_ConfigUL_setup_implicitReleaseAfter_ENUMTABSIZE) {
      return SPS_ConfigUL_setup_implicitReleaseAfter_ENUMTAB
         [SPS_ConfigUL_setup_implicitReleaseAfter_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SPS_ConfigUL_setup_implicitReleaseAfter_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SPS_ConfigUL_setup_implicitReleaseAfter* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SPS_ConfigUL_setup_implicitReleaseAfter_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SPS_ConfigUL_setup_implicitReleaseAfter_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SPS_ConfigUL_setup_implicitReleaseAfter* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SPS_ConfigUL_setup_implicitReleaseAfter_ENUMTAB, 
      SPS_ConfigUL_setup_implicitReleaseAfter_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SPS_ConfigUL_setup_implicitReleaseAfter)
         SPS_ConfigUL_setup_implicitReleaseAfter_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SPS_ConfigUL_setup_implicitReleaseAfter (OSCTXT* pctxt, SPS_ConfigUL_setup_implicitReleaseAfter value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SPS_ConfigUL_setup_implicitReleaseAfter"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SPS_ConfigUL_setup_implicitReleaseAfter (OSCTXT* pctxt, SPS_ConfigUL_setup_implicitReleaseAfter* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SPS_ConfigUL_setup_twoIntervalsConfig_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define SPS_ConfigUL_setup_twoIntervalsConfig_ENUMTABSIZE 1

const OSUTF8CHAR* SPS_ConfigUL_setup_twoIntervalsConfig_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      SPS_ConfigUL_setup_twoIntervalsConfig_ENUMTAB, 
      SPS_ConfigUL_setup_twoIntervalsConfig_ENUMTABSIZE);

   if (idx >= 0 && idx < SPS_ConfigUL_setup_twoIntervalsConfig_ENUMTABSIZE) {
      return SPS_ConfigUL_setup_twoIntervalsConfig_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SPS_ConfigUL_setup_twoIntervalsConfig_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SPS_ConfigUL_setup_twoIntervalsConfig* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SPS_ConfigUL_setup_twoIntervalsConfig_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SPS_ConfigUL_setup_twoIntervalsConfig_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SPS_ConfigUL_setup_twoIntervalsConfig* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SPS_ConfigUL_setup_twoIntervalsConfig_ENUMTAB, 
      SPS_ConfigUL_setup_twoIntervalsConfig_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SPS_ConfigUL_setup_twoIntervalsConfig)
         SPS_ConfigUL_setup_twoIntervalsConfig_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SPS_ConfigUL_setup_twoIntervalsConfig (OSCTXT* pctxt, SPS_ConfigUL_setup_twoIntervalsConfig value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SPS_ConfigUL_setup_twoIntervalsConfig"));

   switch (value) {
      case true__7: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SPS_ConfigUL_setup_twoIntervalsConfig (OSCTXT* pctxt, SPS_ConfigUL_setup_twoIntervalsConfig* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = true__7; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem TDD_Config_subframeAssignment_ENUMTAB[] = {
   { OSUTF8("sa0"), 0, 3, 0 },
   { OSUTF8("sa1"), 1, 3, 1 },
   { OSUTF8("sa2"), 2, 3, 2 },
   { OSUTF8("sa3"), 3, 3, 3 },
   { OSUTF8("sa4"), 4, 3, 4 },
   { OSUTF8("sa5"), 5, 3, 5 },
   { OSUTF8("sa6"), 6, 3, 6 }
} ;
#define TDD_Config_subframeAssignment_ENUMTABSIZE 7

const OSUTF8CHAR* TDD_Config_subframeAssignment_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < TDD_Config_subframeAssignment_ENUMTABSIZE) {
      return TDD_Config_subframeAssignment_ENUMTAB
         [TDD_Config_subframeAssignment_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int TDD_Config_subframeAssignment_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, TDD_Config_subframeAssignment* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return TDD_Config_subframeAssignment_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int TDD_Config_subframeAssignment_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      TDD_Config_subframeAssignment* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      TDD_Config_subframeAssignment_ENUMTAB, 
      TDD_Config_subframeAssignment_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (TDD_Config_subframeAssignment)
         TDD_Config_subframeAssignment_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_TDD_Config_subframeAssignment (OSCTXT* pctxt, TDD_Config_subframeAssignment value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("TDD_Config_subframeAssignment"));

   if (value >= 7) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_TDD_Config_subframeAssignment (OSCTXT* pctxt, TDD_Config_subframeAssignment* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem TDD_Config_specialSubframePatterns_ENUMTAB[] = {
   { OSUTF8("ssp0"), 0, 4, 0 },
   { OSUTF8("ssp1"), 1, 4, 1 },
   { OSUTF8("ssp2"), 2, 4, 2 },
   { OSUTF8("ssp3"), 3, 4, 3 },
   { OSUTF8("ssp4"), 4, 4, 4 },
   { OSUTF8("ssp5"), 5, 4, 5 },
   { OSUTF8("ssp6"), 6, 4, 6 },
   { OSUTF8("ssp7"), 7, 4, 7 },
   { OSUTF8("ssp8"), 8, 4, 8 }
} ;
#define TDD_Config_specialSubframePatterns_ENUMTABSIZE 9

const OSUTF8CHAR* TDD_Config_specialSubframePatterns_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < TDD_Config_specialSubframePatterns_ENUMTABSIZE) {
      return TDD_Config_specialSubframePatterns_ENUMTAB
         [TDD_Config_specialSubframePatterns_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int TDD_Config_specialSubframePatterns_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, TDD_Config_specialSubframePatterns* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return TDD_Config_specialSubframePatterns_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int TDD_Config_specialSubframePatterns_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      TDD_Config_specialSubframePatterns* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      TDD_Config_specialSubframePatterns_ENUMTAB, 
      TDD_Config_specialSubframePatterns_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (TDD_Config_specialSubframePatterns)
         TDD_Config_specialSubframePatterns_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_TDD_Config_specialSubframePatterns (OSCTXT* pctxt, TDD_Config_specialSubframePatterns value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("TDD_Config_specialSubframePatterns"));

   if (value >= 9) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_TDD_Config_specialSubframePatterns (OSCTXT* pctxt, TDD_Config_specialSubframePatterns* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem UplinkPowerControlCommon_alpha_ENUMTAB[] = {
   { OSUTF8("al0"), 0, 3, 0 },
   { OSUTF8("al04"), 1, 4, 1 },
   { OSUTF8("al05"), 2, 4, 2 },
   { OSUTF8("al06"), 3, 4, 3 },
   { OSUTF8("al07"), 4, 4, 4 },
   { OSUTF8("al08"), 5, 4, 5 },
   { OSUTF8("al09"), 6, 4, 6 },
   { OSUTF8("al1"), 7, 3, 7 }
} ;
#define UplinkPowerControlCommon_alpha_ENUMTABSIZE 8

const OSUTF8CHAR* UplinkPowerControlCommon_alpha_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < UplinkPowerControlCommon_alpha_ENUMTABSIZE) {
      return UplinkPowerControlCommon_alpha_ENUMTAB
         [UplinkPowerControlCommon_alpha_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UplinkPowerControlCommon_alpha_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, UplinkPowerControlCommon_alpha* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return UplinkPowerControlCommon_alpha_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int UplinkPowerControlCommon_alpha_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      UplinkPowerControlCommon_alpha* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      UplinkPowerControlCommon_alpha_ENUMTAB, 
      UplinkPowerControlCommon_alpha_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UplinkPowerControlCommon_alpha)
         UplinkPowerControlCommon_alpha_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_UplinkPowerControlCommon_alpha (OSCTXT* pctxt, UplinkPowerControlCommon_alpha value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UplinkPowerControlCommon_alpha"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkPowerControlCommon_alpha (OSCTXT* pctxt, UplinkPowerControlCommon_alpha* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem UplinkPowerControlDedicated_deltaMCS_Enabled_ENUMTAB[] = {
   { OSUTF8("en0"), 0, 3, 0 },
   { OSUTF8("en1"), 1, 3, 1 }
} ;
#define UplinkPowerControlDedicated_deltaMCS_Enabled_ENUMTABSIZE 2

const OSUTF8CHAR* UplinkPowerControlDedicated_deltaMCS_Enabled_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < UplinkPowerControlDedicated_deltaMCS_Enabled_ENUMTABSIZE) {
      return UplinkPowerControlDedicated_deltaMCS_Enabled_ENUMTAB
         [UplinkPowerControlDedicated_deltaMCS_Enabled_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UplinkPowerControlDedicated_deltaMCS_Enabled_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      UplinkPowerControlDedicated_deltaMCS_Enabled* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return UplinkPowerControlDedicated_deltaMCS_Enabled_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int UplinkPowerControlDedicated_deltaMCS_Enabled_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      UplinkPowerControlDedicated_deltaMCS_Enabled* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      UplinkPowerControlDedicated_deltaMCS_Enabled_ENUMTAB, 
      UplinkPowerControlDedicated_deltaMCS_Enabled_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UplinkPowerControlDedicated_deltaMCS_Enabled)
         UplinkPowerControlDedicated_deltaMCS_Enabled_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_UplinkPowerControlDedicated_deltaMCS_Enabled (OSCTXT* pctxt, UplinkPowerControlDedicated_deltaMCS_Enabled value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UplinkPowerControlDedicated_deltaMCS_Enabled"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkPowerControlDedicated_deltaMCS_Enabled (OSCTXT* pctxt, UplinkPowerControlDedicated_deltaMCS_Enabled* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem DeltaFList_PUCCH_deltaF_PUCCH_Format1_ENUMTAB[] = {
   { OSUTF8("deltaF-2"), 0, 8, 0 },
   { OSUTF8("deltaF0"), 1, 7, 1 },
   { OSUTF8("deltaF2"), 2, 7, 2 }
} ;
#define DeltaFList_PUCCH_deltaF_PUCCH_Format1_ENUMTABSIZE 3

const OSUTF8CHAR* DeltaFList_PUCCH_deltaF_PUCCH_Format1_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < DeltaFList_PUCCH_deltaF_PUCCH_Format1_ENUMTABSIZE) {
      return DeltaFList_PUCCH_deltaF_PUCCH_Format1_ENUMTAB
         [DeltaFList_PUCCH_deltaF_PUCCH_Format1_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int DeltaFList_PUCCH_deltaF_PUCCH_Format1_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, DeltaFList_PUCCH_deltaF_PUCCH_Format1* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return DeltaFList_PUCCH_deltaF_PUCCH_Format1_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int DeltaFList_PUCCH_deltaF_PUCCH_Format1_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format1* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format1_ENUMTAB, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format1_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (DeltaFList_PUCCH_deltaF_PUCCH_Format1)
         DeltaFList_PUCCH_deltaF_PUCCH_Format1_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_DeltaFList_PUCCH_deltaF_PUCCH_Format1 (OSCTXT* pctxt, DeltaFList_PUCCH_deltaF_PUCCH_Format1 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DeltaFList_PUCCH_deltaF_PUCCH_Format1"));

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DeltaFList_PUCCH_deltaF_PUCCH_Format1 (OSCTXT* pctxt, DeltaFList_PUCCH_deltaF_PUCCH_Format1* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem DeltaFList_PUCCH_deltaF_PUCCH_Format1b_ENUMTAB[] = {
   { OSUTF8("deltaF1"), 0, 7, 0 },
   { OSUTF8("deltaF3"), 1, 7, 1 },
   { OSUTF8("deltaF5"), 2, 7, 2 }
} ;
#define DeltaFList_PUCCH_deltaF_PUCCH_Format1b_ENUMTABSIZE 3

const OSUTF8CHAR* DeltaFList_PUCCH_deltaF_PUCCH_Format1b_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < DeltaFList_PUCCH_deltaF_PUCCH_Format1b_ENUMTABSIZE) {
      return DeltaFList_PUCCH_deltaF_PUCCH_Format1b_ENUMTAB
         [DeltaFList_PUCCH_deltaF_PUCCH_Format1b_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int DeltaFList_PUCCH_deltaF_PUCCH_Format1b_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, DeltaFList_PUCCH_deltaF_PUCCH_Format1b* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return DeltaFList_PUCCH_deltaF_PUCCH_Format1b_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int DeltaFList_PUCCH_deltaF_PUCCH_Format1b_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format1b* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format1b_ENUMTAB, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format1b_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (DeltaFList_PUCCH_deltaF_PUCCH_Format1b)
         DeltaFList_PUCCH_deltaF_PUCCH_Format1b_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_DeltaFList_PUCCH_deltaF_PUCCH_Format1b (OSCTXT* pctxt, DeltaFList_PUCCH_deltaF_PUCCH_Format1b value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DeltaFList_PUCCH_deltaF_PUCCH_Format1b"));

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DeltaFList_PUCCH_deltaF_PUCCH_Format1b (OSCTXT* pctxt, DeltaFList_PUCCH_deltaF_PUCCH_Format1b* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem DeltaFList_PUCCH_deltaF_PUCCH_Format2_ENUMTAB[] = {
   { OSUTF8("deltaF-2"), 0, 8, 0 },
   { OSUTF8("deltaF0"), 1, 7, 1 },
   { OSUTF8("deltaF1"), 2, 7, 2 },
   { OSUTF8("deltaF2"), 3, 7, 3 }
} ;
#define DeltaFList_PUCCH_deltaF_PUCCH_Format2_ENUMTABSIZE 4

const OSUTF8CHAR* DeltaFList_PUCCH_deltaF_PUCCH_Format2_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < DeltaFList_PUCCH_deltaF_PUCCH_Format2_ENUMTABSIZE) {
      return DeltaFList_PUCCH_deltaF_PUCCH_Format2_ENUMTAB
         [DeltaFList_PUCCH_deltaF_PUCCH_Format2_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int DeltaFList_PUCCH_deltaF_PUCCH_Format2_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, DeltaFList_PUCCH_deltaF_PUCCH_Format2* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return DeltaFList_PUCCH_deltaF_PUCCH_Format2_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int DeltaFList_PUCCH_deltaF_PUCCH_Format2_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format2* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format2_ENUMTAB, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format2_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (DeltaFList_PUCCH_deltaF_PUCCH_Format2)
         DeltaFList_PUCCH_deltaF_PUCCH_Format2_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_DeltaFList_PUCCH_deltaF_PUCCH_Format2 (OSCTXT* pctxt, DeltaFList_PUCCH_deltaF_PUCCH_Format2 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DeltaFList_PUCCH_deltaF_PUCCH_Format2"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DeltaFList_PUCCH_deltaF_PUCCH_Format2 (OSCTXT* pctxt, DeltaFList_PUCCH_deltaF_PUCCH_Format2* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem DeltaFList_PUCCH_deltaF_PUCCH_Format2a_ENUMTAB[] = {
   { OSUTF8("deltaF-2"), 0, 8, 0 },
   { OSUTF8("deltaF0"), 1, 7, 1 },
   { OSUTF8("deltaF2"), 2, 7, 2 }
} ;
#define DeltaFList_PUCCH_deltaF_PUCCH_Format2a_ENUMTABSIZE 3

const OSUTF8CHAR* DeltaFList_PUCCH_deltaF_PUCCH_Format2a_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < DeltaFList_PUCCH_deltaF_PUCCH_Format2a_ENUMTABSIZE) {
      return DeltaFList_PUCCH_deltaF_PUCCH_Format2a_ENUMTAB
         [DeltaFList_PUCCH_deltaF_PUCCH_Format2a_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int DeltaFList_PUCCH_deltaF_PUCCH_Format2a_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, DeltaFList_PUCCH_deltaF_PUCCH_Format2a* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return DeltaFList_PUCCH_deltaF_PUCCH_Format2a_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int DeltaFList_PUCCH_deltaF_PUCCH_Format2a_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format2a* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format2a_ENUMTAB, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format2a_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (DeltaFList_PUCCH_deltaF_PUCCH_Format2a)
         DeltaFList_PUCCH_deltaF_PUCCH_Format2a_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_DeltaFList_PUCCH_deltaF_PUCCH_Format2a (OSCTXT* pctxt, DeltaFList_PUCCH_deltaF_PUCCH_Format2a value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DeltaFList_PUCCH_deltaF_PUCCH_Format2a"));

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DeltaFList_PUCCH_deltaF_PUCCH_Format2a (OSCTXT* pctxt, DeltaFList_PUCCH_deltaF_PUCCH_Format2a* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem DeltaFList_PUCCH_deltaF_PUCCH_Format2b_ENUMTAB[] = {
   { OSUTF8("deltaF-2"), 0, 8, 0 },
   { OSUTF8("deltaF0"), 1, 7, 1 },
   { OSUTF8("deltaF2"), 2, 7, 2 }
} ;
#define DeltaFList_PUCCH_deltaF_PUCCH_Format2b_ENUMTABSIZE 3

const OSUTF8CHAR* DeltaFList_PUCCH_deltaF_PUCCH_Format2b_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < DeltaFList_PUCCH_deltaF_PUCCH_Format2b_ENUMTABSIZE) {
      return DeltaFList_PUCCH_deltaF_PUCCH_Format2b_ENUMTAB
         [DeltaFList_PUCCH_deltaF_PUCCH_Format2b_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int DeltaFList_PUCCH_deltaF_PUCCH_Format2b_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, DeltaFList_PUCCH_deltaF_PUCCH_Format2b* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return DeltaFList_PUCCH_deltaF_PUCCH_Format2b_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int DeltaFList_PUCCH_deltaF_PUCCH_Format2b_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format2b* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format2b_ENUMTAB, 
      DeltaFList_PUCCH_deltaF_PUCCH_Format2b_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (DeltaFList_PUCCH_deltaF_PUCCH_Format2b)
         DeltaFList_PUCCH_deltaF_PUCCH_Format2b_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_DeltaFList_PUCCH_deltaF_PUCCH_Format2b (OSCTXT* pctxt, DeltaFList_PUCCH_deltaF_PUCCH_Format2b value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DeltaFList_PUCCH_deltaF_PUCCH_Format2b"));

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DeltaFList_PUCCH_deltaF_PUCCH_Format2b (OSCTXT* pctxt, DeltaFList_PUCCH_deltaF_PUCCH_Format2b* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SecurityAlgorithmConfig_cipheringAlgorithm_ENUMTAB[] = {
   { OSUTF8("eea0"), 0, 4, 0 },
   { OSUTF8("eea1"), 1, 4, 1 },
   { OSUTF8("eea2"), 2, 4, 2 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 },
   { OSUTF8("spare4"), 4, 6, 4 },
   { OSUTF8("spare5"), 3, 6, 3 }
} ;
#define SecurityAlgorithmConfig_cipheringAlgorithm_ENUMTABSIZE 8

const OSUTF8CHAR* SecurityAlgorithmConfig_cipheringAlgorithm_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SecurityAlgorithmConfig_cipheringAlgorithm_ENUMTABSIZE) {
      return SecurityAlgorithmConfig_cipheringAlgorithm_ENUMTAB
         [SecurityAlgorithmConfig_cipheringAlgorithm_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SecurityAlgorithmConfig_cipheringAlgorithm_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SecurityAlgorithmConfig_cipheringAlgorithm* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SecurityAlgorithmConfig_cipheringAlgorithm_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SecurityAlgorithmConfig_cipheringAlgorithm_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SecurityAlgorithmConfig_cipheringAlgorithm* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SecurityAlgorithmConfig_cipheringAlgorithm_ENUMTAB, 
      SecurityAlgorithmConfig_cipheringAlgorithm_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SecurityAlgorithmConfig_cipheringAlgorithm)
         SecurityAlgorithmConfig_cipheringAlgorithm_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SecurityAlgorithmConfig_cipheringAlgorithm (OSCTXT* pctxt, SecurityAlgorithmConfig_cipheringAlgorithm value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityAlgorithmConfig_cipheringAlgorithm"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityAlgorithmConfig_cipheringAlgorithm (OSCTXT* pctxt, SecurityAlgorithmConfig_cipheringAlgorithm* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

static const OSEnumItem SecurityAlgorithmConfig_integrityProtAlgorithm_ENUMTAB[] = {
   { OSUTF8("eia0-v920"), 0, 9, 0 },
   { OSUTF8("eia1"), 1, 4, 1 },
   { OSUTF8("eia2"), 2, 4, 2 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 },
   { OSUTF8("spare4"), 4, 6, 4 },
   { OSUTF8("spare5"), 3, 6, 3 }
} ;
#define SecurityAlgorithmConfig_integrityProtAlgorithm_ENUMTABSIZE 8

const OSUTF8CHAR* SecurityAlgorithmConfig_integrityProtAlgorithm_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SecurityAlgorithmConfig_integrityProtAlgorithm_ENUMTABSIZE) {
      return SecurityAlgorithmConfig_integrityProtAlgorithm_ENUMTAB
         [SecurityAlgorithmConfig_integrityProtAlgorithm_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SecurityAlgorithmConfig_integrityProtAlgorithm_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      SecurityAlgorithmConfig_integrityProtAlgorithm* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SecurityAlgorithmConfig_integrityProtAlgorithm_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SecurityAlgorithmConfig_integrityProtAlgorithm_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SecurityAlgorithmConfig_integrityProtAlgorithm* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SecurityAlgorithmConfig_integrityProtAlgorithm_ENUMTAB, 
      SecurityAlgorithmConfig_integrityProtAlgorithm_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SecurityAlgorithmConfig_integrityProtAlgorithm)
         SecurityAlgorithmConfig_integrityProtAlgorithm_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SecurityAlgorithmConfig_integrityProtAlgorithm (OSCTXT* pctxt, SecurityAlgorithmConfig_integrityProtAlgorithm value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityAlgorithmConfig_integrityProtAlgorithm"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityAlgorithmConfig_integrityProtAlgorithm (OSCTXT* pctxt, SecurityAlgorithmConfig_integrityProtAlgorithm* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs (OSCTXT* pctxt, CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs (OSCTXT* pctxt, CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs (
   CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

static const OSEnumItem CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9_ENUMTABSIZE 1

const OSUTF8CHAR* CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9_ENUMTAB, 
      CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9_ENUMTABSIZE) {
      return CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9_ENUMTAB, 
      CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9)
         CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9 (OSCTXT* pctxt, CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9"));

   switch (value) {
      case true__8: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9 (OSCTXT* pctxt, CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = true__8; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PE_CellGlobalIdCDMA2000_cellGlobalId1XRTT (OSCTXT* pctxt, CellGlobalIdCDMA2000_cellGlobalId1XRTT* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellGlobalIdCDMA2000_cellGlobalId1XRTT"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(47), OSUINTCONST(47), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellGlobalIdCDMA2000_cellGlobalId1XRTT (OSCTXT* pctxt, CellGlobalIdCDMA2000_cellGlobalId1XRTT* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(47), OSUINTCONST(47), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_CellGlobalIdCDMA2000_cellGlobalId1XRTT (
   CellGlobalIdCDMA2000_cellGlobalId1XRTT* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

EXTERN int asn1PE_CellGlobalIdCDMA2000_cellGlobalIdHRPD (OSCTXT* pctxt, CellGlobalIdCDMA2000_cellGlobalIdHRPD* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellGlobalIdCDMA2000_cellGlobalIdHRPD"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(128), OSUINTCONST(128), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellGlobalIdCDMA2000_cellGlobalIdHRPD (OSCTXT* pctxt, CellGlobalIdCDMA2000_cellGlobalIdHRPD* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(128), OSUINTCONST(128), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_CellGlobalIdCDMA2000_cellGlobalIdHRPD (
   CellGlobalIdCDMA2000_cellGlobalIdHRPD* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

static const OSEnumItem MobilityControlInfo_t304_ENUMTAB[] = {
   { OSUTF8("ms100"), 1, 5, 5 },
   { OSUTF8("ms1000"), 5, 6, 0 },
   { OSUTF8("ms150"), 2, 5, 2 },
   { OSUTF8("ms200"), 3, 5, 3 },
   { OSUTF8("ms2000"), 6, 6, 6 },
   { OSUTF8("ms50"), 0, 4, 1 },
   { OSUTF8("ms500"), 4, 5, 4 },
   { OSUTF8("spare1"), 7, 6, 7 }
} ;
#define MobilityControlInfo_t304_ENUMTABSIZE 8

const OSUTF8CHAR* MobilityControlInfo_t304_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MobilityControlInfo_t304_ENUMTABSIZE) {
      return MobilityControlInfo_t304_ENUMTAB
         [MobilityControlInfo_t304_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MobilityControlInfo_t304_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, MobilityControlInfo_t304* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MobilityControlInfo_t304_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MobilityControlInfo_t304_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, MobilityControlInfo_t304* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MobilityControlInfo_t304_ENUMTAB, MobilityControlInfo_t304_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MobilityControlInfo_t304)
         MobilityControlInfo_t304_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MobilityControlInfo_t304 (OSCTXT* pctxt, MobilityControlInfo_t304 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityControlInfo_t304"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityControlInfo_t304 (OSCTXT* pctxt, MobilityControlInfo_t304* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem CarrierBandwidthEUTRA_dl_Bandwidth_ENUMTAB[] = {
   { OSUTF8("n100"), 5, 4, 4 },
   { OSUTF8("n15"), 1, 3, 1 },
   { OSUTF8("n25"), 2, 3, 2 },
   { OSUTF8("n50"), 3, 3, 3 },
   { OSUTF8("n6"), 0, 2, 5 },
   { OSUTF8("n75"), 4, 3, 0 },
   { OSUTF8("spare1"), 15, 6, 7 },
   { OSUTF8("spare10"), 6, 7, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 },
   { OSUTF8("spare6"), 10, 6, 10 },
   { OSUTF8("spare7"), 9, 6, 9 },
   { OSUTF8("spare8"), 8, 6, 8 },
   { OSUTF8("spare9"), 7, 6, 6 }
} ;
#define CarrierBandwidthEUTRA_dl_Bandwidth_ENUMTABSIZE 16

const OSUTF8CHAR* CarrierBandwidthEUTRA_dl_Bandwidth_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < CarrierBandwidthEUTRA_dl_Bandwidth_ENUMTABSIZE) {
      return CarrierBandwidthEUTRA_dl_Bandwidth_ENUMTAB
         [CarrierBandwidthEUTRA_dl_Bandwidth_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int CarrierBandwidthEUTRA_dl_Bandwidth_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, CarrierBandwidthEUTRA_dl_Bandwidth* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return CarrierBandwidthEUTRA_dl_Bandwidth_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int CarrierBandwidthEUTRA_dl_Bandwidth_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      CarrierBandwidthEUTRA_dl_Bandwidth* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      CarrierBandwidthEUTRA_dl_Bandwidth_ENUMTAB, 
      CarrierBandwidthEUTRA_dl_Bandwidth_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (CarrierBandwidthEUTRA_dl_Bandwidth)
         CarrierBandwidthEUTRA_dl_Bandwidth_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_CarrierBandwidthEUTRA_dl_Bandwidth (OSCTXT* pctxt, CarrierBandwidthEUTRA_dl_Bandwidth value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierBandwidthEUTRA_dl_Bandwidth"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierBandwidthEUTRA_dl_Bandwidth (OSCTXT* pctxt, CarrierBandwidthEUTRA_dl_Bandwidth* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem CarrierBandwidthEUTRA_ul_Bandwidth_ENUMTAB[] = {
   { OSUTF8("n100"), 5, 4, 4 },
   { OSUTF8("n15"), 1, 3, 1 },
   { OSUTF8("n25"), 2, 3, 2 },
   { OSUTF8("n50"), 3, 3, 3 },
   { OSUTF8("n6"), 0, 2, 5 },
   { OSUTF8("n75"), 4, 3, 0 },
   { OSUTF8("spare1"), 15, 6, 7 },
   { OSUTF8("spare10"), 6, 7, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 },
   { OSUTF8("spare6"), 10, 6, 10 },
   { OSUTF8("spare7"), 9, 6, 9 },
   { OSUTF8("spare8"), 8, 6, 8 },
   { OSUTF8("spare9"), 7, 6, 6 }
} ;
#define CarrierBandwidthEUTRA_ul_Bandwidth_ENUMTABSIZE 16

const OSUTF8CHAR* CarrierBandwidthEUTRA_ul_Bandwidth_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < CarrierBandwidthEUTRA_ul_Bandwidth_ENUMTABSIZE) {
      return CarrierBandwidthEUTRA_ul_Bandwidth_ENUMTAB
         [CarrierBandwidthEUTRA_ul_Bandwidth_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int CarrierBandwidthEUTRA_ul_Bandwidth_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, CarrierBandwidthEUTRA_ul_Bandwidth* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return CarrierBandwidthEUTRA_ul_Bandwidth_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int CarrierBandwidthEUTRA_ul_Bandwidth_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      CarrierBandwidthEUTRA_ul_Bandwidth* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      CarrierBandwidthEUTRA_ul_Bandwidth_ENUMTAB, 
      CarrierBandwidthEUTRA_ul_Bandwidth_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (CarrierBandwidthEUTRA_ul_Bandwidth)
         CarrierBandwidthEUTRA_ul_Bandwidth_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_CarrierBandwidthEUTRA_ul_Bandwidth (OSCTXT* pctxt, CarrierBandwidthEUTRA_ul_Bandwidth value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierBandwidthEUTRA_ul_Bandwidth"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierBandwidthEUTRA_ul_Bandwidth (OSCTXT* pctxt, CarrierBandwidthEUTRA_ul_Bandwidth* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem MobilityStateParameters_t_Evaluation_ENUMTAB[] = {
   { OSUTF8("s120"), 2, 4, 3 },
   { OSUTF8("s180"), 3, 4, 4 },
   { OSUTF8("s240"), 4, 4, 0 },
   { OSUTF8("s30"), 0, 3, 1 },
   { OSUTF8("s60"), 1, 3, 2 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 }
} ;
#define MobilityStateParameters_t_Evaluation_ENUMTABSIZE 8

const OSUTF8CHAR* MobilityStateParameters_t_Evaluation_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MobilityStateParameters_t_Evaluation_ENUMTABSIZE) {
      return MobilityStateParameters_t_Evaluation_ENUMTAB
         [MobilityStateParameters_t_Evaluation_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MobilityStateParameters_t_Evaluation_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, MobilityStateParameters_t_Evaluation* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MobilityStateParameters_t_Evaluation_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MobilityStateParameters_t_Evaluation_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MobilityStateParameters_t_Evaluation* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MobilityStateParameters_t_Evaluation_ENUMTAB, 
      MobilityStateParameters_t_Evaluation_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MobilityStateParameters_t_Evaluation)
         MobilityStateParameters_t_Evaluation_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MobilityStateParameters_t_Evaluation (OSCTXT* pctxt, MobilityStateParameters_t_Evaluation value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityStateParameters_t_Evaluation"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityStateParameters_t_Evaluation (OSCTXT* pctxt, MobilityStateParameters_t_Evaluation* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem MobilityStateParameters_t_HystNormal_ENUMTAB[] = {
   { OSUTF8("s120"), 2, 4, 3 },
   { OSUTF8("s180"), 3, 4, 4 },
   { OSUTF8("s240"), 4, 4, 0 },
   { OSUTF8("s30"), 0, 3, 1 },
   { OSUTF8("s60"), 1, 3, 2 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 }
} ;
#define MobilityStateParameters_t_HystNormal_ENUMTABSIZE 8

const OSUTF8CHAR* MobilityStateParameters_t_HystNormal_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MobilityStateParameters_t_HystNormal_ENUMTABSIZE) {
      return MobilityStateParameters_t_HystNormal_ENUMTAB
         [MobilityStateParameters_t_HystNormal_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MobilityStateParameters_t_HystNormal_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, MobilityStateParameters_t_HystNormal* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MobilityStateParameters_t_HystNormal_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MobilityStateParameters_t_HystNormal_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MobilityStateParameters_t_HystNormal* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MobilityStateParameters_t_HystNormal_ENUMTAB, 
      MobilityStateParameters_t_HystNormal_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MobilityStateParameters_t_HystNormal)
         MobilityStateParameters_t_HystNormal_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MobilityStateParameters_t_HystNormal (OSCTXT* pctxt, MobilityStateParameters_t_HystNormal value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityStateParameters_t_HystNormal"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityStateParameters_t_HystNormal (OSCTXT* pctxt, MobilityStateParameters_t_HystNormal* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem PhysCellIdRange_range_ENUMTAB[] = {
   { OSUTF8("n12"), 2, 3, 7 },
   { OSUTF8("n128"), 10, 4, 11 },
   { OSUTF8("n16"), 3, 3, 0 },
   { OSUTF8("n168"), 11, 4, 2 },
   { OSUTF8("n24"), 4, 3, 4 },
   { OSUTF8("n252"), 12, 4, 6 },
   { OSUTF8("n32"), 5, 3, 8 },
   { OSUTF8("n4"), 0, 2, 10 },
   { OSUTF8("n48"), 6, 3, 12 },
   { OSUTF8("n504"), 13, 4, 13 },
   { OSUTF8("n64"), 7, 3, 1 },
   { OSUTF8("n8"), 1, 2, 3 },
   { OSUTF8("n84"), 8, 3, 5 },
   { OSUTF8("n96"), 9, 3, 9 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 }
} ;
#define PhysCellIdRange_range_ENUMTABSIZE 16

const OSUTF8CHAR* PhysCellIdRange_range_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PhysCellIdRange_range_ENUMTABSIZE) {
      return PhysCellIdRange_range_ENUMTAB
         [PhysCellIdRange_range_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PhysCellIdRange_range_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PhysCellIdRange_range* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PhysCellIdRange_range_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PhysCellIdRange_range_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, PhysCellIdRange_range* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PhysCellIdRange_range_ENUMTAB, PhysCellIdRange_range_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PhysCellIdRange_range)
         PhysCellIdRange_range_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PhysCellIdRange_range (OSCTXT* pctxt, PhysCellIdRange_range value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhysCellIdRange_range"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhysCellIdRange_range (OSCTXT* pctxt, PhysCellIdRange_range* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SpeedStateScaleFactors_sf_Medium_ENUMTAB[] = {
   { OSUTF8("lDot0"), 3, 5, 1 },
   { OSUTF8("oDot25"), 0, 6, 2 },
   { OSUTF8("oDot5"), 1, 5, 3 },
   { OSUTF8("oDot75"), 2, 6, 0 }
} ;
#define SpeedStateScaleFactors_sf_Medium_ENUMTABSIZE 4

const OSUTF8CHAR* SpeedStateScaleFactors_sf_Medium_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SpeedStateScaleFactors_sf_Medium_ENUMTABSIZE) {
      return SpeedStateScaleFactors_sf_Medium_ENUMTAB
         [SpeedStateScaleFactors_sf_Medium_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SpeedStateScaleFactors_sf_Medium_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SpeedStateScaleFactors_sf_Medium* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SpeedStateScaleFactors_sf_Medium_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SpeedStateScaleFactors_sf_Medium_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SpeedStateScaleFactors_sf_Medium* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SpeedStateScaleFactors_sf_Medium_ENUMTAB, 
      SpeedStateScaleFactors_sf_Medium_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SpeedStateScaleFactors_sf_Medium)
         SpeedStateScaleFactors_sf_Medium_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SpeedStateScaleFactors_sf_Medium (OSCTXT* pctxt, SpeedStateScaleFactors_sf_Medium value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SpeedStateScaleFactors_sf_Medium"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SpeedStateScaleFactors_sf_Medium (OSCTXT* pctxt, SpeedStateScaleFactors_sf_Medium* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem SpeedStateScaleFactors_sf_High_ENUMTAB[] = {
   { OSUTF8("lDot0"), 3, 5, 1 },
   { OSUTF8("oDot25"), 0, 6, 2 },
   { OSUTF8("oDot5"), 1, 5, 3 },
   { OSUTF8("oDot75"), 2, 6, 0 }
} ;
#define SpeedStateScaleFactors_sf_High_ENUMTABSIZE 4

const OSUTF8CHAR* SpeedStateScaleFactors_sf_High_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SpeedStateScaleFactors_sf_High_ENUMTABSIZE) {
      return SpeedStateScaleFactors_sf_High_ENUMTAB
         [SpeedStateScaleFactors_sf_High_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SpeedStateScaleFactors_sf_High_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SpeedStateScaleFactors_sf_High* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SpeedStateScaleFactors_sf_High_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SpeedStateScaleFactors_sf_High_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SpeedStateScaleFactors_sf_High* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SpeedStateScaleFactors_sf_High_ENUMTAB, 
      SpeedStateScaleFactors_sf_High_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SpeedStateScaleFactors_sf_High)
         SpeedStateScaleFactors_sf_High_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SpeedStateScaleFactors_sf_High (OSCTXT* pctxt, SpeedStateScaleFactors_sf_High value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SpeedStateScaleFactors_sf_High"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SpeedStateScaleFactors_sf_High (OSCTXT* pctxt, SpeedStateScaleFactors_sf_High* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_SystemInfoListGERAN_element (OSCTXT* pctxt, SystemInfoListGERAN_element* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInfoListGERAN_element"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(23), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInfoListGERAN_element (OSCTXT* pctxt, SystemInfoListGERAN_element* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(23), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_SystemInfoListGERAN_element (SystemInfoListGERAN_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

EXTERN int asn1PE_SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime (OSCTXT* pctxt, SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(39), OSUINTCONST(39), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime (OSCTXT* pctxt, SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(39), OSUINTCONST(39), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime (
   SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

EXTERN int asn1PE_SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime (OSCTXT* pctxt, SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(49), OSUINTCONST(49), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime (OSCTXT* pctxt, SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(49), OSUINTCONST(49), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime (
   SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

static const OSEnumItem AdditionalSI_Info_r9_csg_MemberStatus_r9_ENUMTAB[] = {
   { OSUTF8("member"), 0, 6, 0 }
} ;
#define AdditionalSI_Info_r9_csg_MemberStatus_r9_ENUMTABSIZE 1

const OSUTF8CHAR* AdditionalSI_Info_r9_csg_MemberStatus_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      AdditionalSI_Info_r9_csg_MemberStatus_r9_ENUMTAB, 
      AdditionalSI_Info_r9_csg_MemberStatus_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < AdditionalSI_Info_r9_csg_MemberStatus_r9_ENUMTABSIZE) {
      return AdditionalSI_Info_r9_csg_MemberStatus_r9_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AdditionalSI_Info_r9_csg_MemberStatus_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AdditionalSI_Info_r9_csg_MemberStatus_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AdditionalSI_Info_r9_csg_MemberStatus_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AdditionalSI_Info_r9_csg_MemberStatus_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      AdditionalSI_Info_r9_csg_MemberStatus_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      AdditionalSI_Info_r9_csg_MemberStatus_r9_ENUMTAB, 
      AdditionalSI_Info_r9_csg_MemberStatus_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AdditionalSI_Info_r9_csg_MemberStatus_r9)
         AdditionalSI_Info_r9_csg_MemberStatus_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_AdditionalSI_Info_r9_csg_MemberStatus_r9 (OSCTXT* pctxt, AdditionalSI_Info_r9_csg_MemberStatus_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("AdditionalSI_Info_r9_csg_MemberStatus_r9"));

   switch (value) {
      case member: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AdditionalSI_Info_r9_csg_MemberStatus_r9 (OSCTXT* pctxt, AdditionalSI_Info_r9_csg_MemberStatus_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = member; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem QuantityConfigUTRA_measQuantityUTRA_FDD_ENUMTAB[] = {
   { OSUTF8("cpich-EcN0"), 1, 10, 1 },
   { OSUTF8("cpich-RSCP"), 0, 10, 0 }
} ;
#define QuantityConfigUTRA_measQuantityUTRA_FDD_ENUMTABSIZE 2

const OSUTF8CHAR* QuantityConfigUTRA_measQuantityUTRA_FDD_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < QuantityConfigUTRA_measQuantityUTRA_FDD_ENUMTABSIZE) {
      return QuantityConfigUTRA_measQuantityUTRA_FDD_ENUMTAB
         [QuantityConfigUTRA_measQuantityUTRA_FDD_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int QuantityConfigUTRA_measQuantityUTRA_FDD_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, QuantityConfigUTRA_measQuantityUTRA_FDD* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return QuantityConfigUTRA_measQuantityUTRA_FDD_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int QuantityConfigUTRA_measQuantityUTRA_FDD_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      QuantityConfigUTRA_measQuantityUTRA_FDD* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      QuantityConfigUTRA_measQuantityUTRA_FDD_ENUMTAB, 
      QuantityConfigUTRA_measQuantityUTRA_FDD_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (QuantityConfigUTRA_measQuantityUTRA_FDD)
         QuantityConfigUTRA_measQuantityUTRA_FDD_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_QuantityConfigUTRA_measQuantityUTRA_FDD (OSCTXT* pctxt, QuantityConfigUTRA_measQuantityUTRA_FDD value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("QuantityConfigUTRA_measQuantityUTRA_FDD"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_QuantityConfigUTRA_measQuantityUTRA_FDD (OSCTXT* pctxt, QuantityConfigUTRA_measQuantityUTRA_FDD* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem QuantityConfigUTRA_measQuantityUTRA_TDD_ENUMTAB[] = {
   { OSUTF8("pccpch-RSCP"), 0, 11, 0 }
} ;
#define QuantityConfigUTRA_measQuantityUTRA_TDD_ENUMTABSIZE 1

const OSUTF8CHAR* QuantityConfigUTRA_measQuantityUTRA_TDD_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      QuantityConfigUTRA_measQuantityUTRA_TDD_ENUMTAB, 
      QuantityConfigUTRA_measQuantityUTRA_TDD_ENUMTABSIZE);

   if (idx >= 0 && idx < QuantityConfigUTRA_measQuantityUTRA_TDD_ENUMTABSIZE) {
      return QuantityConfigUTRA_measQuantityUTRA_TDD_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int QuantityConfigUTRA_measQuantityUTRA_TDD_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, QuantityConfigUTRA_measQuantityUTRA_TDD* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return QuantityConfigUTRA_measQuantityUTRA_TDD_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int QuantityConfigUTRA_measQuantityUTRA_TDD_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      QuantityConfigUTRA_measQuantityUTRA_TDD* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      QuantityConfigUTRA_measQuantityUTRA_TDD_ENUMTAB, 
      QuantityConfigUTRA_measQuantityUTRA_TDD_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (QuantityConfigUTRA_measQuantityUTRA_TDD)
         QuantityConfigUTRA_measQuantityUTRA_TDD_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_QuantityConfigUTRA_measQuantityUTRA_TDD (OSCTXT* pctxt, QuantityConfigUTRA_measQuantityUTRA_TDD value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("QuantityConfigUTRA_measQuantityUTRA_TDD"));

   switch (value) {
      case pccpch_RSCP: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_QuantityConfigUTRA_measQuantityUTRA_TDD (OSCTXT* pctxt, QuantityConfigUTRA_measQuantityUTRA_TDD* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = pccpch_RSCP; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem QuantityConfigGERAN_measQuantityGERAN_ENUMTAB[] = {
   { OSUTF8("rssi"), 0, 4, 0 }
} ;
#define QuantityConfigGERAN_measQuantityGERAN_ENUMTABSIZE 1

const OSUTF8CHAR* QuantityConfigGERAN_measQuantityGERAN_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      QuantityConfigGERAN_measQuantityGERAN_ENUMTAB, 
      QuantityConfigGERAN_measQuantityGERAN_ENUMTABSIZE);

   if (idx >= 0 && idx < QuantityConfigGERAN_measQuantityGERAN_ENUMTABSIZE) {
      return QuantityConfigGERAN_measQuantityGERAN_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int QuantityConfigGERAN_measQuantityGERAN_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, QuantityConfigGERAN_measQuantityGERAN* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return QuantityConfigGERAN_measQuantityGERAN_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int QuantityConfigGERAN_measQuantityGERAN_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      QuantityConfigGERAN_measQuantityGERAN* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      QuantityConfigGERAN_measQuantityGERAN_ENUMTAB, 
      QuantityConfigGERAN_measQuantityGERAN_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (QuantityConfigGERAN_measQuantityGERAN)
         QuantityConfigGERAN_measQuantityGERAN_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_QuantityConfigGERAN_measQuantityGERAN (OSCTXT* pctxt, QuantityConfigGERAN_measQuantityGERAN value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("QuantityConfigGERAN_measQuantityGERAN"));

   switch (value) {
      case rssi: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_QuantityConfigGERAN_measQuantityGERAN (OSCTXT* pctxt, QuantityConfigGERAN_measQuantityGERAN* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = rssi; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem QuantityConfigCDMA2000_measQuantityCDMA2000_ENUMTAB[] = {
   { OSUTF8("pilotPnPhaseAndPilotStrength"), 1, 28, 1 },
   { OSUTF8("pilotStrength"), 0, 13, 0 }
} ;
#define QuantityConfigCDMA2000_measQuantityCDMA2000_ENUMTABSIZE 2

const OSUTF8CHAR* QuantityConfigCDMA2000_measQuantityCDMA2000_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < QuantityConfigCDMA2000_measQuantityCDMA2000_ENUMTABSIZE) {
      return QuantityConfigCDMA2000_measQuantityCDMA2000_ENUMTAB
         [QuantityConfigCDMA2000_measQuantityCDMA2000_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int QuantityConfigCDMA2000_measQuantityCDMA2000_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      QuantityConfigCDMA2000_measQuantityCDMA2000* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return QuantityConfigCDMA2000_measQuantityCDMA2000_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int QuantityConfigCDMA2000_measQuantityCDMA2000_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      QuantityConfigCDMA2000_measQuantityCDMA2000* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      QuantityConfigCDMA2000_measQuantityCDMA2000_ENUMTAB, 
      QuantityConfigCDMA2000_measQuantityCDMA2000_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (QuantityConfigCDMA2000_measQuantityCDMA2000)
         QuantityConfigCDMA2000_measQuantityCDMA2000_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_QuantityConfigCDMA2000_measQuantityCDMA2000 (OSCTXT* pctxt, QuantityConfigCDMA2000_measQuantityCDMA2000 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("QuantityConfigCDMA2000_measQuantityCDMA2000"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_QuantityConfigCDMA2000_measQuantityCDMA2000 (OSCTXT* pctxt, QuantityConfigCDMA2000_measQuantityCDMA2000* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem ReportConfigEUTRA_triggerType_periodical_purpose_ENUMTAB[] = {
   { OSUTF8("reportCGI"), 1, 9, 1 },
   { OSUTF8("reportStrongestCells"), 0, 20, 0 }
} ;
#define ReportConfigEUTRA_triggerType_periodical_purpose_ENUMTABSIZE 2

const OSUTF8CHAR* ReportConfigEUTRA_triggerType_periodical_purpose_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ReportConfigEUTRA_triggerType_periodical_purpose_ENUMTABSIZE) {
      return ReportConfigEUTRA_triggerType_periodical_purpose_ENUMTAB
         [ReportConfigEUTRA_triggerType_periodical_purpose_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReportConfigEUTRA_triggerType_periodical_purpose_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      ReportConfigEUTRA_triggerType_periodical_purpose* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ReportConfigEUTRA_triggerType_periodical_purpose_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ReportConfigEUTRA_triggerType_periodical_purpose_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ReportConfigEUTRA_triggerType_periodical_purpose* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ReportConfigEUTRA_triggerType_periodical_purpose_ENUMTAB, 
      ReportConfigEUTRA_triggerType_periodical_purpose_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReportConfigEUTRA_triggerType_periodical_purpose)
         ReportConfigEUTRA_triggerType_periodical_purpose_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ReportConfigEUTRA_triggerType_periodical_purpose (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_periodical_purpose value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_triggerType_periodical_purpose"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_triggerType_periodical_purpose (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_periodical_purpose* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem ReportConfigEUTRA_triggerQuantity_ENUMTAB[] = {
   { OSUTF8("rsrp"), 0, 4, 0 },
   { OSUTF8("rsrq"), 1, 4, 1 }
} ;
#define ReportConfigEUTRA_triggerQuantity_ENUMTABSIZE 2

const OSUTF8CHAR* ReportConfigEUTRA_triggerQuantity_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ReportConfigEUTRA_triggerQuantity_ENUMTABSIZE) {
      return ReportConfigEUTRA_triggerQuantity_ENUMTAB
         [ReportConfigEUTRA_triggerQuantity_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReportConfigEUTRA_triggerQuantity_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ReportConfigEUTRA_triggerQuantity* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ReportConfigEUTRA_triggerQuantity_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ReportConfigEUTRA_triggerQuantity_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ReportConfigEUTRA_triggerQuantity* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ReportConfigEUTRA_triggerQuantity_ENUMTAB, 
      ReportConfigEUTRA_triggerQuantity_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReportConfigEUTRA_triggerQuantity)
         ReportConfigEUTRA_triggerQuantity_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ReportConfigEUTRA_triggerQuantity (OSCTXT* pctxt, ReportConfigEUTRA_triggerQuantity value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_triggerQuantity"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_triggerQuantity (OSCTXT* pctxt, ReportConfigEUTRA_triggerQuantity* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem ReportConfigEUTRA_reportQuantity_ENUMTAB[] = {
   { OSUTF8("both"), 1, 4, 1 },
   { OSUTF8("sameAsTriggerQuantity"), 0, 21, 0 }
} ;
#define ReportConfigEUTRA_reportQuantity_ENUMTABSIZE 2

const OSUTF8CHAR* ReportConfigEUTRA_reportQuantity_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ReportConfigEUTRA_reportQuantity_ENUMTABSIZE) {
      return ReportConfigEUTRA_reportQuantity_ENUMTAB
         [ReportConfigEUTRA_reportQuantity_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReportConfigEUTRA_reportQuantity_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ReportConfigEUTRA_reportQuantity* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ReportConfigEUTRA_reportQuantity_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ReportConfigEUTRA_reportQuantity_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ReportConfigEUTRA_reportQuantity* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ReportConfigEUTRA_reportQuantity_ENUMTAB, 
      ReportConfigEUTRA_reportQuantity_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReportConfigEUTRA_reportQuantity)
         ReportConfigEUTRA_reportQuantity_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ReportConfigEUTRA_reportQuantity (OSCTXT* pctxt, ReportConfigEUTRA_reportQuantity value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_reportQuantity"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_reportQuantity (OSCTXT* pctxt, ReportConfigEUTRA_reportQuantity* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem ReportConfigEUTRA_reportAmount_ENUMTAB[] = {
   { OSUTF8("infinity"), 7, 8, 1 },
   { OSUTF8("r1"), 0, 2, 3 },
   { OSUTF8("r16"), 4, 3, 5 },
   { OSUTF8("r2"), 1, 2, 7 },
   { OSUTF8("r32"), 5, 3, 2 },
   { OSUTF8("r4"), 2, 2, 4 },
   { OSUTF8("r64"), 6, 3, 6 },
   { OSUTF8("r8"), 3, 2, 0 }
} ;
#define ReportConfigEUTRA_reportAmount_ENUMTABSIZE 8

const OSUTF8CHAR* ReportConfigEUTRA_reportAmount_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ReportConfigEUTRA_reportAmount_ENUMTABSIZE) {
      return ReportConfigEUTRA_reportAmount_ENUMTAB
         [ReportConfigEUTRA_reportAmount_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReportConfigEUTRA_reportAmount_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ReportConfigEUTRA_reportAmount* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ReportConfigEUTRA_reportAmount_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ReportConfigEUTRA_reportAmount_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ReportConfigEUTRA_reportAmount* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ReportConfigEUTRA_reportAmount_ENUMTAB, 
      ReportConfigEUTRA_reportAmount_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReportConfigEUTRA_reportAmount)
         ReportConfigEUTRA_reportAmount_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ReportConfigEUTRA_reportAmount (OSCTXT* pctxt, ReportConfigEUTRA_reportAmount value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_reportAmount"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_reportAmount (OSCTXT* pctxt, ReportConfigEUTRA_reportAmount* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem ReportConfigEUTRA_si_RequestForHO_r9_ENUMTAB[] = {
   { OSUTF8("setup"), 0, 5, 0 }
} ;
#define ReportConfigEUTRA_si_RequestForHO_r9_ENUMTABSIZE 1

const OSUTF8CHAR* ReportConfigEUTRA_si_RequestForHO_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ReportConfigEUTRA_si_RequestForHO_r9_ENUMTAB, 
      ReportConfigEUTRA_si_RequestForHO_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < ReportConfigEUTRA_si_RequestForHO_r9_ENUMTABSIZE) {
      return ReportConfigEUTRA_si_RequestForHO_r9_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReportConfigEUTRA_si_RequestForHO_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ReportConfigEUTRA_si_RequestForHO_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ReportConfigEUTRA_si_RequestForHO_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ReportConfigEUTRA_si_RequestForHO_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ReportConfigEUTRA_si_RequestForHO_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ReportConfigEUTRA_si_RequestForHO_r9_ENUMTAB, 
      ReportConfigEUTRA_si_RequestForHO_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReportConfigEUTRA_si_RequestForHO_r9)
         ReportConfigEUTRA_si_RequestForHO_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ReportConfigEUTRA_si_RequestForHO_r9 (OSCTXT* pctxt, ReportConfigEUTRA_si_RequestForHO_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_si_RequestForHO_r9"));

   switch (value) {
      case setup_3: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_si_RequestForHO_r9 (OSCTXT* pctxt, ReportConfigEUTRA_si_RequestForHO_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = setup_3; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9_ENUMTAB[] = {
   { OSUTF8("setup"), 0, 5, 0 }
} ;
#define ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9_ENUMTABSIZE 1

const OSUTF8CHAR* ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9_ENUMTAB, 
      ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9_ENUMTABSIZE) {
      return ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9_ENUMTAB, 
      ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9)
         ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9 (OSCTXT* pctxt, ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9"));

   switch (value) {
      case setup_4: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9 (OSCTXT* pctxt, ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = setup_4; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem ReportConfigInterRAT_triggerType_periodical_purpose_ENUMTAB[] = {
   { OSUTF8("reportCGI"), 2, 9, 1 },
   { OSUTF8("reportStrongestCells"), 0, 20, 2 },
   { OSUTF8("reportStrongestCellsForSON"), 1, 26, 0 }
} ;
#define ReportConfigInterRAT_triggerType_periodical_purpose_ENUMTABSIZE 3

const OSUTF8CHAR* ReportConfigInterRAT_triggerType_periodical_purpose_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ReportConfigInterRAT_triggerType_periodical_purpose_ENUMTABSIZE) {
      return ReportConfigInterRAT_triggerType_periodical_purpose_ENUMTAB
         [ReportConfigInterRAT_triggerType_periodical_purpose_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReportConfigInterRAT_triggerType_periodical_purpose_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      ReportConfigInterRAT_triggerType_periodical_purpose* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ReportConfigInterRAT_triggerType_periodical_purpose_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ReportConfigInterRAT_triggerType_periodical_purpose_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ReportConfigInterRAT_triggerType_periodical_purpose* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ReportConfigInterRAT_triggerType_periodical_purpose_ENUMTAB, 
      ReportConfigInterRAT_triggerType_periodical_purpose_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReportConfigInterRAT_triggerType_periodical_purpose)
         ReportConfigInterRAT_triggerType_periodical_purpose_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ReportConfigInterRAT_triggerType_periodical_purpose (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_periodical_purpose value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigInterRAT_triggerType_periodical_purpose"));

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigInterRAT_triggerType_periodical_purpose (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_periodical_purpose* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem ReportConfigInterRAT_reportAmount_ENUMTAB[] = {
   { OSUTF8("infinity"), 7, 8, 1 },
   { OSUTF8("r1"), 0, 2, 3 },
   { OSUTF8("r16"), 4, 3, 5 },
   { OSUTF8("r2"), 1, 2, 7 },
   { OSUTF8("r32"), 5, 3, 2 },
   { OSUTF8("r4"), 2, 2, 4 },
   { OSUTF8("r64"), 6, 3, 6 },
   { OSUTF8("r8"), 3, 2, 0 }
} ;
#define ReportConfigInterRAT_reportAmount_ENUMTABSIZE 8

const OSUTF8CHAR* ReportConfigInterRAT_reportAmount_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ReportConfigInterRAT_reportAmount_ENUMTABSIZE) {
      return ReportConfigInterRAT_reportAmount_ENUMTAB
         [ReportConfigInterRAT_reportAmount_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReportConfigInterRAT_reportAmount_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ReportConfigInterRAT_reportAmount* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ReportConfigInterRAT_reportAmount_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ReportConfigInterRAT_reportAmount_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ReportConfigInterRAT_reportAmount* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ReportConfigInterRAT_reportAmount_ENUMTAB, 
      ReportConfigInterRAT_reportAmount_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReportConfigInterRAT_reportAmount)
         ReportConfigInterRAT_reportAmount_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ReportConfigInterRAT_reportAmount (OSCTXT* pctxt, ReportConfigInterRAT_reportAmount value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigInterRAT_reportAmount"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigInterRAT_reportAmount (OSCTXT* pctxt, ReportConfigInterRAT_reportAmount* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem ReportConfigInterRAT_si_RequestForHO_r9_ENUMTAB[] = {
   { OSUTF8("setup"), 0, 5, 0 }
} ;
#define ReportConfigInterRAT_si_RequestForHO_r9_ENUMTABSIZE 1

const OSUTF8CHAR* ReportConfigInterRAT_si_RequestForHO_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ReportConfigInterRAT_si_RequestForHO_r9_ENUMTAB, 
      ReportConfigInterRAT_si_RequestForHO_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < ReportConfigInterRAT_si_RequestForHO_r9_ENUMTABSIZE) {
      return ReportConfigInterRAT_si_RequestForHO_r9_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReportConfigInterRAT_si_RequestForHO_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ReportConfigInterRAT_si_RequestForHO_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ReportConfigInterRAT_si_RequestForHO_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ReportConfigInterRAT_si_RequestForHO_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ReportConfigInterRAT_si_RequestForHO_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ReportConfigInterRAT_si_RequestForHO_r9_ENUMTAB, 
      ReportConfigInterRAT_si_RequestForHO_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReportConfigInterRAT_si_RequestForHO_r9)
         ReportConfigInterRAT_si_RequestForHO_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ReportConfigInterRAT_si_RequestForHO_r9 (OSCTXT* pctxt, ReportConfigInterRAT_si_RequestForHO_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigInterRAT_si_RequestForHO_r9"));

   switch (value) {
      case setup_5: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigInterRAT_si_RequestForHO_r9 (OSCTXT* pctxt, ReportConfigInterRAT_si_RequestForHO_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = setup_5; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem ReportProximityConfig_r9_proximityIndicationEUTRA_r9_ENUMTAB[] = {
   { OSUTF8("enabled"), 0, 7, 0 }
} ;
#define ReportProximityConfig_r9_proximityIndicationEUTRA_r9_ENUMTABSIZE 1

const OSUTF8CHAR* ReportProximityConfig_r9_proximityIndicationEUTRA_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ReportProximityConfig_r9_proximityIndicationEUTRA_r9_ENUMTAB, 
      ReportProximityConfig_r9_proximityIndicationEUTRA_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < ReportProximityConfig_r9_proximityIndicationEUTRA_r9_ENUMTABSIZE) {
      return ReportProximityConfig_r9_proximityIndicationEUTRA_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReportProximityConfig_r9_proximityIndicationEUTRA_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      ReportProximityConfig_r9_proximityIndicationEUTRA_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ReportProximityConfig_r9_proximityIndicationEUTRA_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ReportProximityConfig_r9_proximityIndicationEUTRA_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ReportProximityConfig_r9_proximityIndicationEUTRA_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ReportProximityConfig_r9_proximityIndicationEUTRA_r9_ENUMTAB, 
      ReportProximityConfig_r9_proximityIndicationEUTRA_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReportProximityConfig_r9_proximityIndicationEUTRA_r9)
         ReportProximityConfig_r9_proximityIndicationEUTRA_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ReportProximityConfig_r9_proximityIndicationEUTRA_r9 (OSCTXT* pctxt, ReportProximityConfig_r9_proximityIndicationEUTRA_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportProximityConfig_r9_proximityIndicationEUTRA_r9"));

   switch (value) {
      case enabled: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportProximityConfig_r9_proximityIndicationEUTRA_r9 (OSCTXT* pctxt, ReportProximityConfig_r9_proximityIndicationEUTRA_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = enabled; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem ReportProximityConfig_r9_proximityIndicationUTRA_r9_ENUMTAB[] = {
   { OSUTF8("enabled"), 0, 7, 0 }
} ;
#define ReportProximityConfig_r9_proximityIndicationUTRA_r9_ENUMTABSIZE 1

const OSUTF8CHAR* ReportProximityConfig_r9_proximityIndicationUTRA_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ReportProximityConfig_r9_proximityIndicationUTRA_r9_ENUMTAB, 
      ReportProximityConfig_r9_proximityIndicationUTRA_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < ReportProximityConfig_r9_proximityIndicationUTRA_r9_ENUMTABSIZE) {
      return ReportProximityConfig_r9_proximityIndicationUTRA_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReportProximityConfig_r9_proximityIndicationUTRA_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      ReportProximityConfig_r9_proximityIndicationUTRA_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ReportProximityConfig_r9_proximityIndicationUTRA_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ReportProximityConfig_r9_proximityIndicationUTRA_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ReportProximityConfig_r9_proximityIndicationUTRA_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ReportProximityConfig_r9_proximityIndicationUTRA_r9_ENUMTAB, 
      ReportProximityConfig_r9_proximityIndicationUTRA_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReportProximityConfig_r9_proximityIndicationUTRA_r9)
         ReportProximityConfig_r9_proximityIndicationUTRA_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ReportProximityConfig_r9_proximityIndicationUTRA_r9 (OSCTXT* pctxt, ReportProximityConfig_r9_proximityIndicationUTRA_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportProximityConfig_r9_proximityIndicationUTRA_r9"));

   switch (value) {
      case enabled_1: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportProximityConfig_r9_proximityIndicationUTRA_r9 (OSCTXT* pctxt, ReportProximityConfig_r9_proximityIndicationUTRA_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = enabled_1; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem UE_EUTRA_Capability_v920_IEs_deviceType_r9_ENUMTAB[] = {
   { OSUTF8("noBenFromBatConsumpOpt"), 0, 22, 0 }
} ;
#define UE_EUTRA_Capability_v920_IEs_deviceType_r9_ENUMTABSIZE 1

const OSUTF8CHAR* UE_EUTRA_Capability_v920_IEs_deviceType_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      UE_EUTRA_Capability_v920_IEs_deviceType_r9_ENUMTAB, 
      UE_EUTRA_Capability_v920_IEs_deviceType_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < UE_EUTRA_Capability_v920_IEs_deviceType_r9_ENUMTABSIZE) {
      return UE_EUTRA_Capability_v920_IEs_deviceType_r9_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UE_EUTRA_Capability_v920_IEs_deviceType_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, UE_EUTRA_Capability_v920_IEs_deviceType_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return UE_EUTRA_Capability_v920_IEs_deviceType_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int UE_EUTRA_Capability_v920_IEs_deviceType_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      UE_EUTRA_Capability_v920_IEs_deviceType_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      UE_EUTRA_Capability_v920_IEs_deviceType_r9_ENUMTAB, 
      UE_EUTRA_Capability_v920_IEs_deviceType_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UE_EUTRA_Capability_v920_IEs_deviceType_r9)
         UE_EUTRA_Capability_v920_IEs_deviceType_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_UE_EUTRA_Capability_v920_IEs_deviceType_r9 (OSCTXT* pctxt, UE_EUTRA_Capability_v920_IEs_deviceType_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_EUTRA_Capability_v920_IEs_deviceType_r9"));

   switch (value) {
      case noBenFromBatConsumpOpt: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_EUTRA_Capability_v920_IEs_deviceType_r9 (OSCTXT* pctxt, UE_EUTRA_Capability_v920_IEs_deviceType_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = noBenFromBatConsumpOpt; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem PDCP_Parameters_maxNumberROHC_ContextSessions_ENUMTAB[] = {
   { OSUTF8("cs1024"), 12, 6, 5 },
   { OSUTF8("cs12"), 3, 4, 9 },
   { OSUTF8("cs128"), 9, 5, 13 },
   { OSUTF8("cs16"), 4, 4, 1 },
   { OSUTF8("cs16384"), 13, 7, 3 },
   { OSUTF8("cs2"), 0, 3, 6 },
   { OSUTF8("cs24"), 5, 4, 8 },
   { OSUTF8("cs256"), 10, 5, 10 },
   { OSUTF8("cs32"), 6, 4, 12 },
   { OSUTF8("cs4"), 1, 3, 2 },
   { OSUTF8("cs48"), 7, 4, 7 },
   { OSUTF8("cs512"), 11, 5, 11 },
   { OSUTF8("cs64"), 8, 4, 0 },
   { OSUTF8("cs8"), 2, 3, 4 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 }
} ;
#define PDCP_Parameters_maxNumberROHC_ContextSessions_ENUMTABSIZE 16

const OSUTF8CHAR* PDCP_Parameters_maxNumberROHC_ContextSessions_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PDCP_Parameters_maxNumberROHC_ContextSessions_ENUMTABSIZE) {
      return PDCP_Parameters_maxNumberROHC_ContextSessions_ENUMTAB
         [PDCP_Parameters_maxNumberROHC_ContextSessions_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PDCP_Parameters_maxNumberROHC_ContextSessions_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      PDCP_Parameters_maxNumberROHC_ContextSessions* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PDCP_Parameters_maxNumberROHC_ContextSessions_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PDCP_Parameters_maxNumberROHC_ContextSessions_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PDCP_Parameters_maxNumberROHC_ContextSessions* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PDCP_Parameters_maxNumberROHC_ContextSessions_ENUMTAB, 
      PDCP_Parameters_maxNumberROHC_ContextSessions_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PDCP_Parameters_maxNumberROHC_ContextSessions)
         PDCP_Parameters_maxNumberROHC_ContextSessions_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PDCP_Parameters_maxNumberROHC_ContextSessions (OSCTXT* pctxt, PDCP_Parameters_maxNumberROHC_ContextSessions value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PDCP_Parameters_maxNumberROHC_ContextSessions"));

   if (value >= 16) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDCP_Parameters_maxNumberROHC_ContextSessions (OSCTXT* pctxt, PDCP_Parameters_maxNumberROHC_ContextSessions* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem PhyLayerParameters_v920_enhancedDualLayerFDD_r9_ENUMTAB[] = {
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define PhyLayerParameters_v920_enhancedDualLayerFDD_r9_ENUMTABSIZE 1

const OSUTF8CHAR* PhyLayerParameters_v920_enhancedDualLayerFDD_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      PhyLayerParameters_v920_enhancedDualLayerFDD_r9_ENUMTAB, 
      PhyLayerParameters_v920_enhancedDualLayerFDD_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < PhyLayerParameters_v920_enhancedDualLayerFDD_r9_ENUMTABSIZE) {
      return PhyLayerParameters_v920_enhancedDualLayerFDD_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PhyLayerParameters_v920_enhancedDualLayerFDD_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      PhyLayerParameters_v920_enhancedDualLayerFDD_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PhyLayerParameters_v920_enhancedDualLayerFDD_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PhyLayerParameters_v920_enhancedDualLayerFDD_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PhyLayerParameters_v920_enhancedDualLayerFDD_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PhyLayerParameters_v920_enhancedDualLayerFDD_r9_ENUMTAB, 
      PhyLayerParameters_v920_enhancedDualLayerFDD_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PhyLayerParameters_v920_enhancedDualLayerFDD_r9)
         PhyLayerParameters_v920_enhancedDualLayerFDD_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PhyLayerParameters_v920_enhancedDualLayerFDD_r9 (OSCTXT* pctxt, PhyLayerParameters_v920_enhancedDualLayerFDD_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhyLayerParameters_v920_enhancedDualLayerFDD_r9"));

   switch (value) {
      case supported: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhyLayerParameters_v920_enhancedDualLayerFDD_r9 (OSCTXT* pctxt, PhyLayerParameters_v920_enhancedDualLayerFDD_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = supported; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem PhyLayerParameters_v920_enhancedDualLayerTDD_r9_ENUMTAB[] = {
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define PhyLayerParameters_v920_enhancedDualLayerTDD_r9_ENUMTABSIZE 1

const OSUTF8CHAR* PhyLayerParameters_v920_enhancedDualLayerTDD_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      PhyLayerParameters_v920_enhancedDualLayerTDD_r9_ENUMTAB, 
      PhyLayerParameters_v920_enhancedDualLayerTDD_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < PhyLayerParameters_v920_enhancedDualLayerTDD_r9_ENUMTABSIZE) {
      return PhyLayerParameters_v920_enhancedDualLayerTDD_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PhyLayerParameters_v920_enhancedDualLayerTDD_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      PhyLayerParameters_v920_enhancedDualLayerTDD_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PhyLayerParameters_v920_enhancedDualLayerTDD_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PhyLayerParameters_v920_enhancedDualLayerTDD_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PhyLayerParameters_v920_enhancedDualLayerTDD_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PhyLayerParameters_v920_enhancedDualLayerTDD_r9_ENUMTAB, 
      PhyLayerParameters_v920_enhancedDualLayerTDD_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PhyLayerParameters_v920_enhancedDualLayerTDD_r9)
         PhyLayerParameters_v920_enhancedDualLayerTDD_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PhyLayerParameters_v920_enhancedDualLayerTDD_r9 (OSCTXT* pctxt, PhyLayerParameters_v920_enhancedDualLayerTDD_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhyLayerParameters_v920_enhancedDualLayerTDD_r9"));

   switch (value) {
      case supported_1: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhyLayerParameters_v920_enhancedDualLayerTDD_r9 (OSCTXT* pctxt, PhyLayerParameters_v920_enhancedDualLayerTDD_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = supported_1; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9_ENUMTAB[] = {
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9_ENUMTABSIZE 1

const OSUTF8CHAR* IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9_ENUMTAB, 
      IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9_ENUMTABSIZE) {
      return IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9_ENUMTAB, 
      IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9)
         IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9 (OSCTXT* pctxt, IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9"));

   switch (value) {
      case supported_2: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9 (OSCTXT* pctxt, IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = supported_2; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem IRAT_ParametersGERAN_v920_dtm_r9_ENUMTAB[] = {
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define IRAT_ParametersGERAN_v920_dtm_r9_ENUMTABSIZE 1

const OSUTF8CHAR* IRAT_ParametersGERAN_v920_dtm_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      IRAT_ParametersGERAN_v920_dtm_r9_ENUMTAB, 
      IRAT_ParametersGERAN_v920_dtm_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < IRAT_ParametersGERAN_v920_dtm_r9_ENUMTABSIZE) {
      return IRAT_ParametersGERAN_v920_dtm_r9_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int IRAT_ParametersGERAN_v920_dtm_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, IRAT_ParametersGERAN_v920_dtm_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return IRAT_ParametersGERAN_v920_dtm_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int IRAT_ParametersGERAN_v920_dtm_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      IRAT_ParametersGERAN_v920_dtm_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      IRAT_ParametersGERAN_v920_dtm_r9_ENUMTAB, 
      IRAT_ParametersGERAN_v920_dtm_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (IRAT_ParametersGERAN_v920_dtm_r9)
         IRAT_ParametersGERAN_v920_dtm_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_IRAT_ParametersGERAN_v920_dtm_r9 (OSCTXT* pctxt, IRAT_ParametersGERAN_v920_dtm_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersGERAN_v920_dtm_r9"));

   switch (value) {
      case supported_3: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersGERAN_v920_dtm_r9 (OSCTXT* pctxt, IRAT_ParametersGERAN_v920_dtm_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = supported_3; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9_ENUMTAB[] = {
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9_ENUMTABSIZE 1

const OSUTF8CHAR* IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9_ENUMTAB, 
      IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9_ENUMTABSIZE) {
      return IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9_ENUMTAB, 
      IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9)
         IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9 (OSCTXT* pctxt, IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9"));

   switch (value) {
      case supported_4: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9 (OSCTXT* pctxt, IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = supported_4; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD_ENUMTAB[] = {
   { OSUTF8("dual"), 1, 4, 1 },
   { OSUTF8("single"), 0, 6, 0 }
} ;
#define IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD_ENUMTABSIZE 2

const OSUTF8CHAR* IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD_ENUMTABSIZE) {
      return IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD_ENUMTAB
         [IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD_ENUMTAB, 
      IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD)
         IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD (OSCTXT* pctxt, IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD (OSCTXT* pctxt, IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD_ENUMTAB[] = {
   { OSUTF8("dual"), 1, 4, 1 },
   { OSUTF8("single"), 0, 6, 0 }
} ;
#define IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD_ENUMTABSIZE 2

const OSUTF8CHAR* IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD_ENUMTABSIZE) {
      return IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD_ENUMTAB
         [IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD_ENUMTAB, 
      IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD)
         IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD (OSCTXT* pctxt, IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD (OSCTXT* pctxt, IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT_ENUMTAB[] = {
   { OSUTF8("dual"), 1, 4, 1 },
   { OSUTF8("single"), 0, 6, 0 }
} ;
#define IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT_ENUMTABSIZE 2

const OSUTF8CHAR* IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT_ENUMTABSIZE) {
      return IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT_ENUMTAB
         [IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT_ENUMTAB, 
      IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT)
         IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT (OSCTXT* pctxt, IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT (OSCTXT* pctxt, IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT_ENUMTAB[] = {
   { OSUTF8("dual"), 1, 4, 1 },
   { OSUTF8("single"), 0, 6, 0 }
} ;
#define IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT_ENUMTABSIZE 2

const OSUTF8CHAR* IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT_ENUMTABSIZE) {
      return IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT_ENUMTAB
         [IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT_ENUMTAB, 
      IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT)
         IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT (OSCTXT* pctxt, IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT (OSCTXT* pctxt, IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9_ENUMTAB[] = {
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9_ENUMTABSIZE 1

const OSUTF8CHAR* IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9_ENUMTAB, 
      IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9_ENUMTABSIZE) {
      return IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9_ENUMTAB, 
      IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9)
         IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9 (OSCTXT* pctxt, IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9"));

   switch (value) {
      case supported_5: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9 (OSCTXT* pctxt, IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = supported_5; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9_ENUMTAB[] = {
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9_ENUMTABSIZE 1

const OSUTF8CHAR* IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9_ENUMTAB, 
      IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9_ENUMTABSIZE) {
      return IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9_ENUMTAB, 
      IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9)
         IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9 (OSCTXT* pctxt, IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9"));

   switch (value) {
      case supported_6: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9 (OSCTXT* pctxt, IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = supported_6; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9_ENUMTAB[] = {
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9_ENUMTABSIZE 1

const OSUTF8CHAR* CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9_ENUMTAB, 
      CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9_ENUMTABSIZE) {
      return CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9_ENUMTAB, 
      CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9)
         CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9 (OSCTXT* pctxt, CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9"));

   switch (value) {
      case supported_7: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9 (OSCTXT* pctxt, CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = supported_7; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9_ENUMTAB[] = {
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9_ENUMTABSIZE 1

const OSUTF8CHAR* CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9_ENUMTAB, 
      CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9_ENUMTABSIZE) {
      return CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9_ENUMTAB, 
      CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9)
         CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9 (OSCTXT* pctxt, CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9"));

   switch (value) {
      case supported_8: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9 (OSCTXT* pctxt, CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = supported_8; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9_ENUMTAB[] = {
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9_ENUMTABSIZE 1

const OSUTF8CHAR* CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9_ENUMTAB, 
      CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9_ENUMTABSIZE) {
      return CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9_ENUMTAB, 
      CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9)
         CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9 (OSCTXT* pctxt, CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9"));

   switch (value) {
      case supported_9: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9 (OSCTXT* pctxt, CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = supported_9; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9_ENUMTAB[] = {
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9_ENUMTABSIZE 1

const OSUTF8CHAR* NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9_ENUMTAB, 
      NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9_ENUMTABSIZE) {
      return NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9_ENUMTAB, 
      NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9)
         NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9 (OSCTXT* pctxt, NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9"));

   switch (value) {
      case supported_10: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9 (OSCTXT* pctxt, NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = supported_10; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9_ENUMTAB[] = {
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9_ENUMTABSIZE 1

const OSUTF8CHAR* NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9_ENUMTAB, 
      NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9_ENUMTABSIZE) {
      return NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9_ENUMTAB, 
      NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9)
         NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9 (OSCTXT* pctxt, NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9"));

   switch (value) {
      case supported_11: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9 (OSCTXT* pctxt, NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = supported_11; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9_ENUMTAB[] = {
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9_ENUMTABSIZE 1

const OSUTF8CHAR* NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9_ENUMTAB, 
      NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9_ENUMTABSIZE) {
      return NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9_ENUMTAB, 
      NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9)
         NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9 (OSCTXT* pctxt, NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9"));

   switch (value) {
      case supported_12: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9 (OSCTXT* pctxt, NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = supported_12; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem SON_Parameters_r9_rach_Report_r9_ENUMTAB[] = {
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define SON_Parameters_r9_rach_Report_r9_ENUMTABSIZE 1

const OSUTF8CHAR* SON_Parameters_r9_rach_Report_r9_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      SON_Parameters_r9_rach_Report_r9_ENUMTAB, 
      SON_Parameters_r9_rach_Report_r9_ENUMTABSIZE);

   if (idx >= 0 && idx < SON_Parameters_r9_rach_Report_r9_ENUMTABSIZE) {
      return SON_Parameters_r9_rach_Report_r9_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SON_Parameters_r9_rach_Report_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SON_Parameters_r9_rach_Report_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SON_Parameters_r9_rach_Report_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SON_Parameters_r9_rach_Report_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SON_Parameters_r9_rach_Report_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SON_Parameters_r9_rach_Report_r9_ENUMTAB, 
      SON_Parameters_r9_rach_Report_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SON_Parameters_r9_rach_Report_r9)
         SON_Parameters_r9_rach_Report_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_SON_Parameters_r9_rach_Report_r9 (OSCTXT* pctxt, SON_Parameters_r9_rach_Report_r9 value)
{
   int stat = 0;
   OSUINT32 ui;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SON_Parameters_r9_rach_Report_r9"));

   switch (value) {
      case supported_13: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SON_Parameters_r9_rach_Report_r9 (OSCTXT* pctxt, SON_Parameters_r9_rach_Report_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = supported_13; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

static const OSEnumItem UE_TimersAndConstants_t300_ENUMTAB[] = {
   { OSUTF8("ms100"), 0, 5, 0 },
   { OSUTF8("ms1000"), 5, 6, 3 },
   { OSUTF8("ms1500"), 6, 6, 5 },
   { OSUTF8("ms200"), 1, 5, 6 },
   { OSUTF8("ms2000"), 7, 6, 7 },
   { OSUTF8("ms300"), 2, 5, 1 },
   { OSUTF8("ms400"), 3, 5, 2 },
   { OSUTF8("ms600"), 4, 5, 4 }
} ;
#define UE_TimersAndConstants_t300_ENUMTABSIZE 8

const OSUTF8CHAR* UE_TimersAndConstants_t300_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < UE_TimersAndConstants_t300_ENUMTABSIZE) {
      return UE_TimersAndConstants_t300_ENUMTAB
         [UE_TimersAndConstants_t300_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UE_TimersAndConstants_t300_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, UE_TimersAndConstants_t300* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return UE_TimersAndConstants_t300_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int UE_TimersAndConstants_t300_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      UE_TimersAndConstants_t300* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      UE_TimersAndConstants_t300_ENUMTAB, 
      UE_TimersAndConstants_t300_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UE_TimersAndConstants_t300)
         UE_TimersAndConstants_t300_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_UE_TimersAndConstants_t300 (OSCTXT* pctxt, UE_TimersAndConstants_t300 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_TimersAndConstants_t300"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_TimersAndConstants_t300 (OSCTXT* pctxt, UE_TimersAndConstants_t300* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem UE_TimersAndConstants_t301_ENUMTAB[] = {
   { OSUTF8("ms100"), 0, 5, 0 },
   { OSUTF8("ms1000"), 5, 6, 3 },
   { OSUTF8("ms1500"), 6, 6, 5 },
   { OSUTF8("ms200"), 1, 5, 6 },
   { OSUTF8("ms2000"), 7, 6, 7 },
   { OSUTF8("ms300"), 2, 5, 1 },
   { OSUTF8("ms400"), 3, 5, 2 },
   { OSUTF8("ms600"), 4, 5, 4 }
} ;
#define UE_TimersAndConstants_t301_ENUMTABSIZE 8

const OSUTF8CHAR* UE_TimersAndConstants_t301_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < UE_TimersAndConstants_t301_ENUMTABSIZE) {
      return UE_TimersAndConstants_t301_ENUMTAB
         [UE_TimersAndConstants_t301_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UE_TimersAndConstants_t301_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, UE_TimersAndConstants_t301* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return UE_TimersAndConstants_t301_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int UE_TimersAndConstants_t301_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      UE_TimersAndConstants_t301* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      UE_TimersAndConstants_t301_ENUMTAB, 
      UE_TimersAndConstants_t301_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UE_TimersAndConstants_t301)
         UE_TimersAndConstants_t301_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_UE_TimersAndConstants_t301 (OSCTXT* pctxt, UE_TimersAndConstants_t301 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_TimersAndConstants_t301"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_TimersAndConstants_t301 (OSCTXT* pctxt, UE_TimersAndConstants_t301* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem UE_TimersAndConstants_t310_ENUMTAB[] = {
   { OSUTF8("ms0"), 0, 3, 0 },
   { OSUTF8("ms100"), 2, 5, 5 },
   { OSUTF8("ms1000"), 5, 6, 1 },
   { OSUTF8("ms200"), 3, 5, 3 },
   { OSUTF8("ms2000"), 6, 6, 6 },
   { OSUTF8("ms50"), 1, 4, 2 },
   { OSUTF8("ms500"), 4, 5, 4 }
} ;
#define UE_TimersAndConstants_t310_ENUMTABSIZE 7

const OSUTF8CHAR* UE_TimersAndConstants_t310_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < UE_TimersAndConstants_t310_ENUMTABSIZE) {
      return UE_TimersAndConstants_t310_ENUMTAB
         [UE_TimersAndConstants_t310_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UE_TimersAndConstants_t310_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, UE_TimersAndConstants_t310* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return UE_TimersAndConstants_t310_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int UE_TimersAndConstants_t310_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      UE_TimersAndConstants_t310* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      UE_TimersAndConstants_t310_ENUMTAB, 
      UE_TimersAndConstants_t310_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UE_TimersAndConstants_t310)
         UE_TimersAndConstants_t310_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_UE_TimersAndConstants_t310 (OSCTXT* pctxt, UE_TimersAndConstants_t310 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_TimersAndConstants_t310"));

   if (value >= 7) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_TimersAndConstants_t310 (OSCTXT* pctxt, UE_TimersAndConstants_t310* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem UE_TimersAndConstants_n310_ENUMTAB[] = {
   { OSUTF8("n1"), 0, 2, 0 },
   { OSUTF8("n10"), 6, 3, 2 },
   { OSUTF8("n2"), 1, 2, 4 },
   { OSUTF8("n20"), 7, 3, 5 },
   { OSUTF8("n3"), 2, 2, 6 },
   { OSUTF8("n4"), 3, 2, 7 },
   { OSUTF8("n6"), 4, 2, 1 },
   { OSUTF8("n8"), 5, 2, 3 }
} ;
#define UE_TimersAndConstants_n310_ENUMTABSIZE 8

const OSUTF8CHAR* UE_TimersAndConstants_n310_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < UE_TimersAndConstants_n310_ENUMTABSIZE) {
      return UE_TimersAndConstants_n310_ENUMTAB
         [UE_TimersAndConstants_n310_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UE_TimersAndConstants_n310_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, UE_TimersAndConstants_n310* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return UE_TimersAndConstants_n310_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int UE_TimersAndConstants_n310_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      UE_TimersAndConstants_n310* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      UE_TimersAndConstants_n310_ENUMTAB, 
      UE_TimersAndConstants_n310_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UE_TimersAndConstants_n310)
         UE_TimersAndConstants_n310_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_UE_TimersAndConstants_n310 (OSCTXT* pctxt, UE_TimersAndConstants_n310 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_TimersAndConstants_n310"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_TimersAndConstants_n310 (OSCTXT* pctxt, UE_TimersAndConstants_n310* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem UE_TimersAndConstants_t311_ENUMTAB[] = {
   { OSUTF8("ms1000"), 0, 6, 0 },
   { OSUTF8("ms10000"), 3, 7, 4 },
   { OSUTF8("ms15000"), 4, 7, 6 },
   { OSUTF8("ms20000"), 5, 7, 1 },
   { OSUTF8("ms3000"), 1, 6, 2 },
   { OSUTF8("ms30000"), 6, 7, 3 },
   { OSUTF8("ms5000"), 2, 6, 5 }
} ;
#define UE_TimersAndConstants_t311_ENUMTABSIZE 7

const OSUTF8CHAR* UE_TimersAndConstants_t311_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < UE_TimersAndConstants_t311_ENUMTABSIZE) {
      return UE_TimersAndConstants_t311_ENUMTAB
         [UE_TimersAndConstants_t311_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UE_TimersAndConstants_t311_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, UE_TimersAndConstants_t311* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return UE_TimersAndConstants_t311_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int UE_TimersAndConstants_t311_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      UE_TimersAndConstants_t311* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      UE_TimersAndConstants_t311_ENUMTAB, 
      UE_TimersAndConstants_t311_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UE_TimersAndConstants_t311)
         UE_TimersAndConstants_t311_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_UE_TimersAndConstants_t311 (OSCTXT* pctxt, UE_TimersAndConstants_t311 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_TimersAndConstants_t311"));

   if (value >= 7) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_TimersAndConstants_t311 (OSCTXT* pctxt, UE_TimersAndConstants_t311* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem UE_TimersAndConstants_n311_ENUMTAB[] = {
   { OSUTF8("n1"), 0, 2, 0 },
   { OSUTF8("n10"), 7, 3, 2 },
   { OSUTF8("n2"), 1, 2, 3 },
   { OSUTF8("n3"), 2, 2, 4 },
   { OSUTF8("n4"), 3, 2, 5 },
   { OSUTF8("n5"), 4, 2, 6 },
   { OSUTF8("n6"), 5, 2, 7 },
   { OSUTF8("n8"), 6, 2, 1 }
} ;
#define UE_TimersAndConstants_n311_ENUMTABSIZE 8

const OSUTF8CHAR* UE_TimersAndConstants_n311_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < UE_TimersAndConstants_n311_ENUMTABSIZE) {
      return UE_TimersAndConstants_n311_ENUMTAB
         [UE_TimersAndConstants_n311_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UE_TimersAndConstants_n311_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, UE_TimersAndConstants_n311* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return UE_TimersAndConstants_n311_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int UE_TimersAndConstants_n311_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      UE_TimersAndConstants_n311* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      UE_TimersAndConstants_n311_ENUMTAB, 
      UE_TimersAndConstants_n311_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UE_TimersAndConstants_n311)
         UE_TimersAndConstants_n311_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_UE_TimersAndConstants_n311 (OSCTXT* pctxt, UE_TimersAndConstants_n311 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_TimersAndConstants_n311"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_TimersAndConstants_n311 (OSCTXT* pctxt, UE_TimersAndConstants_n311* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9_ENUMTAB[] = {
   { OSUTF8("n2"), 0, 2, 0 },
   { OSUTF8("n4"), 1, 2, 1 }
} ;
#define MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9_ENUMTABSIZE 2

const OSUTF8CHAR* MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9_ENUMTABSIZE) {
      return MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9_ENUMTAB
         [MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9_ENUMTAB, 
      MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9)
         MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9 (OSCTXT* pctxt, MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9 (OSCTXT* pctxt, MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem MBSFN_AreaInfo_r9_non_MBSFNregionLength_ENUMTAB[] = {
   { OSUTF8("s1"), 0, 2, 0 },
   { OSUTF8("s2"), 1, 2, 1 }
} ;
#define MBSFN_AreaInfo_r9_non_MBSFNregionLength_ENUMTABSIZE 2

const OSUTF8CHAR* MBSFN_AreaInfo_r9_non_MBSFNregionLength_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MBSFN_AreaInfo_r9_non_MBSFNregionLength_ENUMTABSIZE) {
      return MBSFN_AreaInfo_r9_non_MBSFNregionLength_ENUMTAB
         [MBSFN_AreaInfo_r9_non_MBSFNregionLength_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MBSFN_AreaInfo_r9_non_MBSFNregionLength_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, MBSFN_AreaInfo_r9_non_MBSFNregionLength* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MBSFN_AreaInfo_r9_non_MBSFNregionLength_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MBSFN_AreaInfo_r9_non_MBSFNregionLength_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MBSFN_AreaInfo_r9_non_MBSFNregionLength* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MBSFN_AreaInfo_r9_non_MBSFNregionLength_ENUMTAB, 
      MBSFN_AreaInfo_r9_non_MBSFNregionLength_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MBSFN_AreaInfo_r9_non_MBSFNregionLength)
         MBSFN_AreaInfo_r9_non_MBSFNregionLength_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MBSFN_AreaInfo_r9_non_MBSFNregionLength (OSCTXT* pctxt, MBSFN_AreaInfo_r9_non_MBSFNregionLength value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFN_AreaInfo_r9_non_MBSFNregionLength"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFN_AreaInfo_r9_non_MBSFNregionLength (OSCTXT* pctxt, MBSFN_AreaInfo_r9_non_MBSFNregionLength* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9_ENUMTAB[] = {
   { OSUTF8("rf128"), 2, 5, 2 },
   { OSUTF8("rf256"), 3, 5, 3 },
   { OSUTF8("rf32"), 0, 4, 0 },
   { OSUTF8("rf64"), 1, 4, 1 }
} ;
#define MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9_ENUMTABSIZE 4

const OSUTF8CHAR* MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9_ENUMTABSIZE) {
      return MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9_ENUMTAB
         [MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9_ENUMTAB, 
      MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9)
         MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9 (OSCTXT* pctxt, MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9 (OSCTXT* pctxt, MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9_ENUMTAB[] = {
   { OSUTF8("rf1024"), 1, 6, 1 },
   { OSUTF8("rf512"), 0, 5, 0 }
} ;
#define MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9_ENUMTABSIZE 2

const OSUTF8CHAR* MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9_ENUMTABSIZE) {
      return MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9_ENUMTAB
         [MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9_ENUMTAB, 
      MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9)
         MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9 (OSCTXT* pctxt, MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9"));

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9 (OSCTXT* pctxt, MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9_ENUMTAB[] = {
   { OSUTF8("n13"), 2, 3, 2 },
   { OSUTF8("n19"), 3, 3, 3 },
   { OSUTF8("n2"), 0, 2, 0 },
   { OSUTF8("n7"), 1, 2, 1 }
} ;
#define MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9_ENUMTABSIZE 4

const OSUTF8CHAR* MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9_ENUMTABSIZE) {
      return MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9_ENUMTAB
         [MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9_ENUMTAB, 
      MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9)
         MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9 (OSCTXT* pctxt, MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9"));

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9 (OSCTXT* pctxt, MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem MBSFN_SubframeConfig_radioframeAllocationPeriod_ENUMTAB[] = {
   { OSUTF8("n1"), 0, 2, 0 },
   { OSUTF8("n16"), 4, 3, 2 },
   { OSUTF8("n2"), 1, 2, 4 },
   { OSUTF8("n32"), 5, 3, 5 },
   { OSUTF8("n4"), 2, 2, 1 },
   { OSUTF8("n8"), 3, 2, 3 }
} ;
#define MBSFN_SubframeConfig_radioframeAllocationPeriod_ENUMTABSIZE 6

const OSUTF8CHAR* MBSFN_SubframeConfig_radioframeAllocationPeriod_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MBSFN_SubframeConfig_radioframeAllocationPeriod_ENUMTABSIZE) {
      return MBSFN_SubframeConfig_radioframeAllocationPeriod_ENUMTAB
         [MBSFN_SubframeConfig_radioframeAllocationPeriod_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MBSFN_SubframeConfig_radioframeAllocationPeriod_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      MBSFN_SubframeConfig_radioframeAllocationPeriod* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MBSFN_SubframeConfig_radioframeAllocationPeriod_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MBSFN_SubframeConfig_radioframeAllocationPeriod_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      MBSFN_SubframeConfig_radioframeAllocationPeriod* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MBSFN_SubframeConfig_radioframeAllocationPeriod_ENUMTAB, 
      MBSFN_SubframeConfig_radioframeAllocationPeriod_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MBSFN_SubframeConfig_radioframeAllocationPeriod)
         MBSFN_SubframeConfig_radioframeAllocationPeriod_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_MBSFN_SubframeConfig_radioframeAllocationPeriod (OSCTXT* pctxt, MBSFN_SubframeConfig_radioframeAllocationPeriod value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFN_SubframeConfig_radioframeAllocationPeriod"));

   if (value >= 6) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFN_SubframeConfig_radioframeAllocationPeriod (OSCTXT* pctxt, MBSFN_SubframeConfig_radioframeAllocationPeriod* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_MBMS_SessionInfo_r9_sessionId_r9 (OSCTXT* pctxt, MBMS_SessionInfo_r9_sessionId_r9* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBMS_SessionInfo_r9_sessionId_r9"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBMS_SessionInfo_r9_sessionId_r9 (OSCTXT* pctxt, MBMS_SessionInfo_r9_sessionId_r9* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_MBMS_SessionInfo_r9_sessionId_r9 (
   MBMS_SessionInfo_r9_sessionId_r9* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

static const OSEnumItem PMCH_Config_r9_mch_SchedulingPeriod_r9_ENUMTAB[] = {
   { OSUTF8("rf1024"), 7, 6, 7 },
   { OSUTF8("rf128"), 4, 5, 2 },
   { OSUTF8("rf16"), 1, 4, 4 },
   { OSUTF8("rf256"), 5, 5, 6 },
   { OSUTF8("rf32"), 2, 4, 1 },
   { OSUTF8("rf512"), 6, 5, 3 },
   { OSUTF8("rf64"), 3, 4, 5 },
   { OSUTF8("rf8"), 0, 3, 0 }
} ;
#define PMCH_Config_r9_mch_SchedulingPeriod_r9_ENUMTABSIZE 8

const OSUTF8CHAR* PMCH_Config_r9_mch_SchedulingPeriod_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PMCH_Config_r9_mch_SchedulingPeriod_r9_ENUMTABSIZE) {
      return PMCH_Config_r9_mch_SchedulingPeriod_r9_ENUMTAB
         [PMCH_Config_r9_mch_SchedulingPeriod_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PMCH_Config_r9_mch_SchedulingPeriod_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PMCH_Config_r9_mch_SchedulingPeriod_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PMCH_Config_r9_mch_SchedulingPeriod_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PMCH_Config_r9_mch_SchedulingPeriod_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PMCH_Config_r9_mch_SchedulingPeriod_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PMCH_Config_r9_mch_SchedulingPeriod_r9_ENUMTAB, 
      PMCH_Config_r9_mch_SchedulingPeriod_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PMCH_Config_r9_mch_SchedulingPeriod_r9)
         PMCH_Config_r9_mch_SchedulingPeriod_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_PMCH_Config_r9_mch_SchedulingPeriod_r9 (OSCTXT* pctxt, PMCH_Config_r9_mch_SchedulingPeriod_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PMCH_Config_r9_mch_SchedulingPeriod_r9"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PMCH_Config_r9_mch_SchedulingPeriod_r9 (OSCTXT* pctxt, PMCH_Config_r9_mch_SchedulingPeriod_r9* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_TMGI_r9_serviceId_r9 (OSCTXT* pctxt, TMGI_r9_serviceId_r9* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("TMGI_r9_serviceId_r9"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_TMGI_r9_serviceId_r9 (OSCTXT* pctxt, TMGI_r9_serviceId_r9* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

void asn1Init_TMGI_r9_serviceId_r9 (TMGI_r9_serviceId_r9* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

EXTERN int asn1PE_BCCH_BCH_Message (OSCTXT* pctxt, BCCH_BCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BCCH-BCH-Message");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BCCH_BCH_Message"));

   /* encode message */

   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PE_BCCH_BCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BCCH_BCH_Message (OSCTXT* pctxt, BCCH_BCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BCCH-BCH-Message");

   /* decode root elements */
   /* decode message */
   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PD_BCCH_BCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_BCCH_BCH_Message (BCCH_BCH_Message* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_BCCH_BCH_MessageType (&pvalue->message);
}

EXTERN int asn1PE_AC_BarringConfig (OSCTXT* pctxt, AC_BarringConfig* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AC-BarringConfig");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("AC_BarringConfig"));

   /* encode ac_BarringFactor */

   RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringFactor");

   stat = asn1PE_AC_BarringConfig_ac_BarringFactor (pctxt, pvalue->ac_BarringFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ac_BarringTime */

   RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringTime");

   stat = asn1PE_AC_BarringConfig_ac_BarringTime (pctxt, pvalue->ac_BarringTime);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ac_BarringForSpecialAC */

   RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringForSpecialAC");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->ac_BarringForSpecialAC, OSUINTCONST(5), OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AC_BarringConfig (OSCTXT* pctxt, AC_BarringConfig* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AC-BarringConfig");

   /* decode root elements */
   /* decode ac_BarringFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringFactor");

   stat = asn1PD_AC_BarringConfig_ac_BarringFactor (pctxt, &pvalue->ac_BarringFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ac_BarringTime */
   RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringTime");

   stat = asn1PD_AC_BarringConfig_ac_BarringTime (pctxt, &pvalue->ac_BarringTime);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ac_BarringForSpecialAC */
   RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringForSpecialAC");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->ac_BarringForSpecialAC
      , OSUINTCONST(5), OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_AC_BarringConfig (AC_BarringConfig* pvalue)
{
   if (0 == pvalue) return;
   pvalue->ac_BarringForSpecialAC.numbits = 0;
}

EXTERN int asn1PE_SystemInformationBlockType2_ac_BarringInfo (OSCTXT* pctxt, SystemInformationBlockType2_ac_BarringInfo* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType2_ac_BarringInfo"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ac_BarringForMO_SignallingPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ac_BarringForMO_DataPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ac_BarringForEmergency */

   RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringForEmergency");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->ac_BarringForEmergency);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ac_BarringForMO_Signalling */

   if (pvalue->m.ac_BarringForMO_SignallingPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringForMO-Signalling");

      stat = asn1PE_AC_BarringConfig (pctxt, &pvalue->ac_BarringForMO_Signalling);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode ac_BarringForMO_Data */

   if (pvalue->m.ac_BarringForMO_DataPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringForMO-Data");

      stat = asn1PE_AC_BarringConfig (pctxt, &pvalue->ac_BarringForMO_Data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType2_ac_BarringInfo (OSCTXT* pctxt, SystemInformationBlockType2_ac_BarringInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ac_BarringForEmergency */
   RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringForEmergency");

   stat = DEC_BIT (pctxt, &pvalue->ac_BarringForEmergency);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ac_BarringForMO_Signalling */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringForMO-Signalling");

      pvalue->m.ac_BarringForMO_SignallingPresent = 1;

      stat = asn1PD_AC_BarringConfig (pctxt, &pvalue->ac_BarringForMO_Signalling);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ac_BarringForMO_Data */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringForMO-Data");

      pvalue->m.ac_BarringForMO_DataPresent = 1;

      stat = asn1PD_AC_BarringConfig (pctxt, &pvalue->ac_BarringForMO_Data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_SystemInformationBlockType2_ac_BarringInfo (
   SystemInformationBlockType2_ac_BarringInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_AC_BarringConfig (&pvalue->ac_BarringForMO_Signalling);
   asn1Init_AC_BarringConfig (&pvalue->ac_BarringForMO_Data);
}

EXTERN int asn1PE_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig (OSCTXT* pctxt, RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sizeOfRA_PreamblesGroupA */

   RTXCTXTPUSHELEMNAME (pctxt, "sizeOfRA-PreamblesGroupA");

   stat = asn1PE_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA (pctxt, pvalue->sizeOfRA_PreamblesGroupA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode messageSizeGroupA */

   RTXCTXTPUSHELEMNAME (pctxt, "messageSizeGroupA");

   stat = asn1PE_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA (pctxt, pvalue->messageSizeGroupA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode messagePowerOffsetGroupB */

   RTXCTXTPUSHELEMNAME (pctxt, "messagePowerOffsetGroupB");

   stat = asn1PE_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB (pctxt, pvalue->messagePowerOffsetGroupB);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig (OSCTXT* pctxt, RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode sizeOfRA_PreamblesGroupA */
   RTXCTXTPUSHELEMNAME (pctxt, "sizeOfRA-PreamblesGroupA");

   stat = asn1PD_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA (pctxt, &pvalue->sizeOfRA_PreamblesGroupA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode messageSizeGroupA */
   RTXCTXTPUSHELEMNAME (pctxt, "messageSizeGroupA");

   stat = asn1PD_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA (pctxt, &pvalue->messageSizeGroupA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode messagePowerOffsetGroupB */
   RTXCTXTPUSHELEMNAME (pctxt, "messagePowerOffsetGroupB");

   stat = asn1PD_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB (pctxt, &pvalue->messagePowerOffsetGroupB);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

void asn1Init_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig (
   RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_RACH_ConfigCommon_preambleInfo (OSCTXT* pctxt, RACH_ConfigCommon_preambleInfo* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigCommon_preambleInfo"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.preamblesGroupAConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode numberOfRA_Preambles */

   RTXCTXTPUSHELEMNAME (pctxt, "numberOfRA-Preambles");

   stat = asn1PE_RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles (pctxt, pvalue->numberOfRA_Preambles);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode preamblesGroupAConfig */

   if (pvalue->m.preamblesGroupAConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "preamblesGroupAConfig");

      stat = asn1PE_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig (pctxt, &pvalue->preamblesGroupAConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigCommon_preambleInfo (OSCTXT* pctxt, RACH_ConfigCommon_preambleInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode numberOfRA_Preambles */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfRA-Preambles");

   stat = asn1PD_RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles (pctxt, &pvalue->numberOfRA_Preambles);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode preamblesGroupAConfig */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "preamblesGroupAConfig");

      pvalue->m.preamblesGroupAConfigPresent = 1;

      stat = asn1PD_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig (pctxt, &pvalue->preamblesGroupAConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_RACH_ConfigCommon_preambleInfo (
   RACH_ConfigCommon_preambleInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig (&pvalue->preamblesGroupAConfig);
}

EXTERN int asn1PE_RACH_ConfigCommon_powerRampingParameters (OSCTXT* pctxt, RACH_ConfigCommon_powerRampingParameters* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigCommon_powerRampingParameters"));

   /* encode powerRampingStep */

   RTXCTXTPUSHELEMNAME (pctxt, "powerRampingStep");

   stat = asn1PE_RACH_ConfigCommon_powerRampingParameters_powerRampingStep (pctxt, pvalue->powerRampingStep);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode preambleInitialReceivedTargetPower */

   RTXCTXTPUSHELEMNAME (pctxt, "preambleInitialReceivedTargetPower");

   stat = asn1PE_RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower (pctxt, pvalue->preambleInitialReceivedTargetPower);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigCommon_powerRampingParameters (OSCTXT* pctxt, RACH_ConfigCommon_powerRampingParameters* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode powerRampingStep */
   RTXCTXTPUSHELEMNAME (pctxt, "powerRampingStep");

   stat = asn1PD_RACH_ConfigCommon_powerRampingParameters_powerRampingStep (pctxt, &pvalue->powerRampingStep);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode preambleInitialReceivedTargetPower */
   RTXCTXTPUSHELEMNAME (pctxt, "preambleInitialReceivedTargetPower");

   stat = asn1PD_RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower (pctxt, &pvalue->preambleInitialReceivedTargetPower);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RACH_ConfigCommon_ra_SupervisionInfo (OSCTXT* pctxt, RACH_ConfigCommon_ra_SupervisionInfo* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigCommon_ra_SupervisionInfo"));

   /* encode preambleTransMax */

   RTXCTXTPUSHELEMNAME (pctxt, "preambleTransMax");

   stat = asn1PE_RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax (pctxt, pvalue->preambleTransMax);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ra_ResponseWindowSize */

   RTXCTXTPUSHELEMNAME (pctxt, "ra-ResponseWindowSize");

   stat = asn1PE_RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize (pctxt, pvalue->ra_ResponseWindowSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode mac_ContentionResolutionTimer */

   RTXCTXTPUSHELEMNAME (pctxt, "mac-ContentionResolutionTimer");

   stat = asn1PE_RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer (pctxt, pvalue->mac_ContentionResolutionTimer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigCommon_ra_SupervisionInfo (OSCTXT* pctxt, RACH_ConfigCommon_ra_SupervisionInfo* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode preambleTransMax */
   RTXCTXTPUSHELEMNAME (pctxt, "preambleTransMax");

   stat = asn1PD_RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax (pctxt, &pvalue->preambleTransMax);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ra_ResponseWindowSize */
   RTXCTXTPUSHELEMNAME (pctxt, "ra-ResponseWindowSize");

   stat = asn1PD_RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize (pctxt, &pvalue->ra_ResponseWindowSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mac_ContentionResolutionTimer */
   RTXCTXTPUSHELEMNAME (pctxt, "mac-ContentionResolutionTimer");

   stat = asn1PD_RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer (pctxt, &pvalue->mac_ContentionResolutionTimer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RACH_ConfigCommon (OSCTXT* pctxt, RACH_ConfigCommon* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RACH-ConfigCommon");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigCommon"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode preambleInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "preambleInfo");

   stat = asn1PE_RACH_ConfigCommon_preambleInfo (pctxt, &pvalue->preambleInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode powerRampingParameters */

   RTXCTXTPUSHELEMNAME (pctxt, "powerRampingParameters");

   stat = asn1PE_RACH_ConfigCommon_powerRampingParameters (pctxt, &pvalue->powerRampingParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ra_SupervisionInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "ra-SupervisionInfo");

   stat = asn1PE_RACH_ConfigCommon_ra_SupervisionInfo (pctxt, &pvalue->ra_SupervisionInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode maxHARQ_Msg3Tx */

   RTXCTXTPUSHELEMNAME (pctxt, "maxHARQ-Msg3Tx");

   if ( (pvalue->maxHARQ_Msg3Tx >= OSUINTCONST(1) && pvalue->maxHARQ_Msg3Tx
       <= OSUINTCONST(8)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->maxHARQ_Msg3Tx, OSUINTCONST(1), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->maxHARQ_Msg3Tx);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigCommon (OSCTXT* pctxt, RACH_ConfigCommon* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RACH-ConfigCommon");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode preambleInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "preambleInfo");

   stat = asn1PD_RACH_ConfigCommon_preambleInfo (pctxt, &pvalue->preambleInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerRampingParameters */
   RTXCTXTPUSHELEMNAME (pctxt, "powerRampingParameters");

   stat = asn1PD_RACH_ConfigCommon_powerRampingParameters (pctxt, &pvalue->powerRampingParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ra_SupervisionInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "ra-SupervisionInfo");

   stat = asn1PD_RACH_ConfigCommon_ra_SupervisionInfo (pctxt, &pvalue->ra_SupervisionInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maxHARQ_Msg3Tx */
   RTXCTXTPUSHELEMNAME (pctxt, "maxHARQ-Msg3Tx");

   stat = pd_ConsUInt8 (pctxt, &pvalue->maxHARQ_Msg3Tx, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RACH_ConfigCommon (RACH_ConfigCommon* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_RACH_ConfigCommon_preambleInfo (&pvalue->preambleInfo);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_BCCH_Config (OSCTXT* pctxt, BCCH_Config* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BCCH-Config");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BCCH_Config"));

   /* encode modificationPeriodCoeff */

   RTXCTXTPUSHELEMNAME (pctxt, "modificationPeriodCoeff");

   stat = asn1PE_BCCH_Config_modificationPeriodCoeff (pctxt, pvalue->modificationPeriodCoeff);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BCCH_Config (OSCTXT* pctxt, BCCH_Config* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BCCH-Config");

   /* decode root elements */
   /* decode modificationPeriodCoeff */
   RTXCTXTPUSHELEMNAME (pctxt, "modificationPeriodCoeff");

   stat = asn1PD_BCCH_Config_modificationPeriodCoeff (pctxt, &pvalue->modificationPeriodCoeff);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PCCH_Config (OSCTXT* pctxt, PCCH_Config* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PCCH-Config");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PCCH_Config"));

   /* encode defaultPagingCycle */

   RTXCTXTPUSHELEMNAME (pctxt, "defaultPagingCycle");

   stat = asn1PE_PCCH_Config_defaultPagingCycle (pctxt, pvalue->defaultPagingCycle);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nB */

   RTXCTXTPUSHELEMNAME (pctxt, "nB");

   stat = asn1PE_PCCH_Config_nB (pctxt, pvalue->nB);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PCCH_Config (OSCTXT* pctxt, PCCH_Config* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PCCH-Config");

   /* decode root elements */
   /* decode defaultPagingCycle */
   RTXCTXTPUSHELEMNAME (pctxt, "defaultPagingCycle");

   stat = asn1PD_PCCH_Config_defaultPagingCycle (pctxt, &pvalue->defaultPagingCycle);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nB */
   RTXCTXTPUSHELEMNAME (pctxt, "nB");

   stat = asn1PD_PCCH_Config_nB (pctxt, &pvalue->nB);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PRACH_ConfigInfo (OSCTXT* pctxt, PRACH_ConfigInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PRACH-ConfigInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PRACH_ConfigInfo"));

   /* encode prach_ConfigIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "prach-ConfigIndex");

   if ( (pvalue->prach_ConfigIndex <= OSUINTCONST(63)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->prach_ConfigIndex, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->prach_ConfigIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode highSpeedFlag */

   RTXCTXTPUSHELEMNAME (pctxt, "highSpeedFlag");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->highSpeedFlag);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode zeroCorrelationZoneConfig */

   RTXCTXTPUSHELEMNAME (pctxt, "zeroCorrelationZoneConfig");

   if ( (pvalue->zeroCorrelationZoneConfig <= OSUINTCONST(15)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->zeroCorrelationZoneConfig, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->zeroCorrelationZoneConfig);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode prach_FreqOffset */

   RTXCTXTPUSHELEMNAME (pctxt, "prach-FreqOffset");

   if ( (pvalue->prach_FreqOffset <= OSUINTCONST(94)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->prach_FreqOffset, OSUINTCONST(0), OSUINTCONST(94));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->prach_FreqOffset);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PRACH_ConfigInfo (OSCTXT* pctxt, PRACH_ConfigInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PRACH-ConfigInfo");

   /* decode root elements */
   /* decode prach_ConfigIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "prach-ConfigIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->prach_ConfigIndex, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode highSpeedFlag */
   RTXCTXTPUSHELEMNAME (pctxt, "highSpeedFlag");

   stat = DEC_BIT (pctxt, &pvalue->highSpeedFlag);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode zeroCorrelationZoneConfig */
   RTXCTXTPUSHELEMNAME (pctxt, "zeroCorrelationZoneConfig");

   stat = pd_ConsUInt8 (pctxt, &pvalue->zeroCorrelationZoneConfig, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode prach_FreqOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "prach-FreqOffset");

   stat = pd_ConsUInt8 (pctxt, &pvalue->prach_FreqOffset, OSUINTCONST(0), OSUINTCONST(94));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PRACH_ConfigSIB (OSCTXT* pctxt, PRACH_ConfigSIB* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PRACH-ConfigSIB");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PRACH_ConfigSIB"));

   /* encode rootSequenceIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "rootSequenceIndex");

   if ( (pvalue->rootSequenceIndex <= OSUINTCONST(837)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->rootSequenceIndex, OSUINTCONST(0), OSUINTCONST(837));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->rootSequenceIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode prach_ConfigInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "prach-ConfigInfo");

   stat = asn1PE_PRACH_ConfigInfo (pctxt, &pvalue->prach_ConfigInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PRACH_ConfigSIB (OSCTXT* pctxt, PRACH_ConfigSIB* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PRACH-ConfigSIB");

   /* decode root elements */
   /* decode rootSequenceIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "rootSequenceIndex");

   stat = pd_ConsUInt16 (pctxt, &pvalue->rootSequenceIndex, OSUINTCONST(0), OSUINTCONST(837));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode prach_ConfigInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "prach-ConfigInfo");

   stat = asn1PD_PRACH_ConfigInfo (pctxt, &pvalue->prach_ConfigInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PDSCH_ConfigCommon (OSCTXT* pctxt, PDSCH_ConfigCommon* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDSCH-ConfigCommon");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PDSCH_ConfigCommon"));

   /* encode referenceSignalPower */

   RTXCTXTPUSHELEMNAME (pctxt, "referenceSignalPower");

   if ( (pvalue->referenceSignalPower >= OSINTCONST(-60) && pvalue->
      referenceSignalPower <= OSINTCONST(50)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->referenceSignalPower, OSINTCONST(-60), OSINTCONST(50));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->referenceSignalPower);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode p_b */

   RTXCTXTPUSHELEMNAME (pctxt, "p-b");

   if ( (pvalue->p_b <= OSUINTCONST(3)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->p_b, OSUINTCONST(0), OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->p_b);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDSCH_ConfigCommon (OSCTXT* pctxt, PDSCH_ConfigCommon* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDSCH-ConfigCommon");

   /* decode root elements */
   /* decode referenceSignalPower */
   RTXCTXTPUSHELEMNAME (pctxt, "referenceSignalPower");

   stat = pd_ConsInt8 (pctxt, &pvalue->referenceSignalPower, OSINTCONST(-60), OSINTCONST(50));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode p_b */
   RTXCTXTPUSHELEMNAME (pctxt, "p-b");

   stat = pd_ConsUInt8 (pctxt, &pvalue->p_b, OSUINTCONST(0), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PUSCH_ConfigCommon_pusch_ConfigBasic (OSCTXT* pctxt, PUSCH_ConfigCommon_pusch_ConfigBasic* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PUSCH_ConfigCommon_pusch_ConfigBasic"));

   /* encode n_SB */

   RTXCTXTPUSHELEMNAME (pctxt, "n-SB");

   if ( (pvalue->n_SB >= OSUINTCONST(1) && pvalue->n_SB <= OSUINTCONST(4)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->n_SB, OSUINTCONST(1), OSUINTCONST(4));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->n_SB);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode hoppingMode */

   RTXCTXTPUSHELEMNAME (pctxt, "hoppingMode");

   stat = asn1PE_PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode (pctxt, pvalue->hoppingMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pusch_HoppingOffset */

   RTXCTXTPUSHELEMNAME (pctxt, "pusch-HoppingOffset");

   if ( (pvalue->pusch_HoppingOffset <= OSUINTCONST(98)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->pusch_HoppingOffset, OSUINTCONST(0), OSUINTCONST(98));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->pusch_HoppingOffset);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode enable64QAM */

   RTXCTXTPUSHELEMNAME (pctxt, "enable64QAM");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->enable64QAM);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PUSCH_ConfigCommon_pusch_ConfigBasic (OSCTXT* pctxt, PUSCH_ConfigCommon_pusch_ConfigBasic* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode n_SB */
   RTXCTXTPUSHELEMNAME (pctxt, "n-SB");

   stat = pd_ConsUInt8 (pctxt, &pvalue->n_SB, OSUINTCONST(1), OSUINTCONST(4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode hoppingMode */
   RTXCTXTPUSHELEMNAME (pctxt, "hoppingMode");

   stat = asn1PD_PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode (pctxt, &pvalue->hoppingMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pusch_HoppingOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "pusch-HoppingOffset");

   stat = pd_ConsUInt8 (pctxt, &pvalue->pusch_HoppingOffset, OSUINTCONST(0), OSUINTCONST(98));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode enable64QAM */
   RTXCTXTPUSHELEMNAME (pctxt, "enable64QAM");

   stat = DEC_BIT (pctxt, &pvalue->enable64QAM);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UL_ReferenceSignalsPUSCH (OSCTXT* pctxt, UL_ReferenceSignalsPUSCH* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-ReferenceSignalsPUSCH");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UL_ReferenceSignalsPUSCH"));

   /* encode groupHoppingEnabled */

   RTXCTXTPUSHELEMNAME (pctxt, "groupHoppingEnabled");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->groupHoppingEnabled);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode groupAssignmentPUSCH */

   RTXCTXTPUSHELEMNAME (pctxt, "groupAssignmentPUSCH");

   if ( (pvalue->groupAssignmentPUSCH <= OSUINTCONST(29)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->groupAssignmentPUSCH, OSUINTCONST(0), OSUINTCONST(29));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->groupAssignmentPUSCH);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sequenceHoppingEnabled */

   RTXCTXTPUSHELEMNAME (pctxt, "sequenceHoppingEnabled");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->sequenceHoppingEnabled);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cyclicShift */

   RTXCTXTPUSHELEMNAME (pctxt, "cyclicShift");

   if ( (pvalue->cyclicShift <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->cyclicShift, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->cyclicShift);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_ReferenceSignalsPUSCH (OSCTXT* pctxt, UL_ReferenceSignalsPUSCH* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-ReferenceSignalsPUSCH");

   /* decode root elements */
   /* decode groupHoppingEnabled */
   RTXCTXTPUSHELEMNAME (pctxt, "groupHoppingEnabled");

   stat = DEC_BIT (pctxt, &pvalue->groupHoppingEnabled);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode groupAssignmentPUSCH */
   RTXCTXTPUSHELEMNAME (pctxt, "groupAssignmentPUSCH");

   stat = pd_ConsUInt8 (pctxt, &pvalue->groupAssignmentPUSCH, OSUINTCONST(0), OSUINTCONST(29));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sequenceHoppingEnabled */
   RTXCTXTPUSHELEMNAME (pctxt, "sequenceHoppingEnabled");

   stat = DEC_BIT (pctxt, &pvalue->sequenceHoppingEnabled);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cyclicShift */
   RTXCTXTPUSHELEMNAME (pctxt, "cyclicShift");

   stat = pd_ConsUInt8 (pctxt, &pvalue->cyclicShift, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PUSCH_ConfigCommon (OSCTXT* pctxt, PUSCH_ConfigCommon* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PUSCH-ConfigCommon");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PUSCH_ConfigCommon"));

   /* encode pusch_ConfigBasic */

   RTXCTXTPUSHELEMNAME (pctxt, "pusch-ConfigBasic");

   stat = asn1PE_PUSCH_ConfigCommon_pusch_ConfigBasic (pctxt, &pvalue->pusch_ConfigBasic);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ul_ReferenceSignalsPUSCH */

   RTXCTXTPUSHELEMNAME (pctxt, "ul-ReferenceSignalsPUSCH");

   stat = asn1PE_UL_ReferenceSignalsPUSCH (pctxt, &pvalue->ul_ReferenceSignalsPUSCH);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PUSCH_ConfigCommon (OSCTXT* pctxt, PUSCH_ConfigCommon* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PUSCH-ConfigCommon");

   /* decode root elements */
   /* decode pusch_ConfigBasic */
   RTXCTXTPUSHELEMNAME (pctxt, "pusch-ConfigBasic");

   stat = asn1PD_PUSCH_ConfigCommon_pusch_ConfigBasic (pctxt, &pvalue->pusch_ConfigBasic);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_ReferenceSignalsPUSCH */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-ReferenceSignalsPUSCH");

   stat = asn1PD_UL_ReferenceSignalsPUSCH (pctxt, &pvalue->ul_ReferenceSignalsPUSCH);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PUCCH_ConfigCommon (OSCTXT* pctxt, PUCCH_ConfigCommon* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PUCCH-ConfigCommon");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PUCCH_ConfigCommon"));

   /* encode deltaPUCCH_Shift */

   RTXCTXTPUSHELEMNAME (pctxt, "deltaPUCCH-Shift");

   stat = asn1PE_PUCCH_ConfigCommon_deltaPUCCH_Shift (pctxt, pvalue->deltaPUCCH_Shift);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nRB_CQI */

   RTXCTXTPUSHELEMNAME (pctxt, "nRB-CQI");

   if ( (pvalue->nRB_CQI <= OSUINTCONST(98)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->nRB_CQI, OSUINTCONST(0), OSUINTCONST(98));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->nRB_CQI);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nCS_AN */

   RTXCTXTPUSHELEMNAME (pctxt, "nCS-AN");

   if ( (pvalue->nCS_AN <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->nCS_AN, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->nCS_AN);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode n1PUCCH_AN */

   RTXCTXTPUSHELEMNAME (pctxt, "n1PUCCH-AN");

   if ( (pvalue->n1PUCCH_AN <= OSUINTCONST(2047)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->n1PUCCH_AN, OSUINTCONST(0), OSUINTCONST(2047));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->n1PUCCH_AN);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PUCCH_ConfigCommon (OSCTXT* pctxt, PUCCH_ConfigCommon* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PUCCH-ConfigCommon");

   /* decode root elements */
   /* decode deltaPUCCH_Shift */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaPUCCH-Shift");

   stat = asn1PD_PUCCH_ConfigCommon_deltaPUCCH_Shift (pctxt, &pvalue->deltaPUCCH_Shift);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nRB_CQI */
   RTXCTXTPUSHELEMNAME (pctxt, "nRB-CQI");

   stat = pd_ConsUInt8 (pctxt, &pvalue->nRB_CQI, OSUINTCONST(0), OSUINTCONST(98));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nCS_AN */
   RTXCTXTPUSHELEMNAME (pctxt, "nCS-AN");

   stat = pd_ConsUInt8 (pctxt, &pvalue->nCS_AN, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode n1PUCCH_AN */
   RTXCTXTPUSHELEMNAME (pctxt, "n1PUCCH-AN");

   stat = pd_ConsUInt16 (pctxt, &pvalue->n1PUCCH_AN, OSUINTCONST(0), OSUINTCONST(2047));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SoundingRS_UL_ConfigCommon_setup (OSCTXT* pctxt, SoundingRS_UL_ConfigCommon_setup* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SoundingRS_UL_ConfigCommon_setup"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.srs_MaxUpPtsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode srs_BandwidthConfig */

   RTXCTXTPUSHELEMNAME (pctxt, "srs-BandwidthConfig");

   stat = asn1PE_SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig (pctxt, pvalue->srs_BandwidthConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode srs_SubframeConfig */

   RTXCTXTPUSHELEMNAME (pctxt, "srs-SubframeConfig");

   stat = asn1PE_SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig (pctxt, pvalue->srs_SubframeConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ackNackSRS_SimultaneousTransmission */

   RTXCTXTPUSHELEMNAME (pctxt, "ackNackSRS-SimultaneousTransmission");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->ackNackSRS_SimultaneousTransmission);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode srs_MaxUpPts */

   if (pvalue->m.srs_MaxUpPtsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "srs-MaxUpPts");

      stat = asn1PE_SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts (pctxt, pvalue->srs_MaxUpPts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SoundingRS_UL_ConfigCommon_setup (OSCTXT* pctxt, SoundingRS_UL_ConfigCommon_setup* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode srs_BandwidthConfig */
   RTXCTXTPUSHELEMNAME (pctxt, "srs-BandwidthConfig");

   stat = asn1PD_SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig (pctxt, &pvalue->srs_BandwidthConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode srs_SubframeConfig */
   RTXCTXTPUSHELEMNAME (pctxt, "srs-SubframeConfig");

   stat = asn1PD_SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig (pctxt, &pvalue->srs_SubframeConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ackNackSRS_SimultaneousTransmission */
   RTXCTXTPUSHELEMNAME (pctxt, "ackNackSRS-SimultaneousTransmission");

   stat = DEC_BIT (pctxt, &pvalue->ackNackSRS_SimultaneousTransmission);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode srs_MaxUpPts */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "srs-MaxUpPts");

      pvalue->m.srs_MaxUpPtsPresent = 1;

      stat = asn1PD_SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts (pctxt, &pvalue->srs_MaxUpPts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_SoundingRS_UL_ConfigCommon_setup (
   SoundingRS_UL_ConfigCommon_setup* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_SoundingRS_UL_ConfigCommon (OSCTXT* pctxt, SoundingRS_UL_ConfigCommon* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SoundingRS-UL-ConfigCommon");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SoundingRS_UL_ConfigCommon"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_SoundingRS_UL_ConfigCommon_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SoundingRS_UL_ConfigCommon (OSCTXT* pctxt, SoundingRS_UL_ConfigCommon* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "SoundingRS-UL-ConfigCommon");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         pvalue->u.setup = rtxMemAllocType (pctxt, 
            SoundingRS_UL_ConfigCommon_setup);

         if (pvalue->u.setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SoundingRS_UL_ConfigCommon_setup (pvalue->u.setup);

         stat = asn1PD_SoundingRS_UL_ConfigCommon_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SoundingRS_UL_ConfigCommon (SoundingRS_UL_ConfigCommon* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_DeltaFList_PUCCH (OSCTXT* pctxt, DeltaFList_PUCCH* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeltaFList-PUCCH");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DeltaFList_PUCCH"));

   /* encode deltaF_PUCCH_Format1 */

   RTXCTXTPUSHELEMNAME (pctxt, "deltaF-PUCCH-Format1");

   stat = asn1PE_DeltaFList_PUCCH_deltaF_PUCCH_Format1 (pctxt, pvalue->deltaF_PUCCH_Format1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode deltaF_PUCCH_Format1b */

   RTXCTXTPUSHELEMNAME (pctxt, "deltaF-PUCCH-Format1b");

   stat = asn1PE_DeltaFList_PUCCH_deltaF_PUCCH_Format1b (pctxt, pvalue->deltaF_PUCCH_Format1b);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode deltaF_PUCCH_Format2 */

   RTXCTXTPUSHELEMNAME (pctxt, "deltaF-PUCCH-Format2");

   stat = asn1PE_DeltaFList_PUCCH_deltaF_PUCCH_Format2 (pctxt, pvalue->deltaF_PUCCH_Format2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode deltaF_PUCCH_Format2a */

   RTXCTXTPUSHELEMNAME (pctxt, "deltaF-PUCCH-Format2a");

   stat = asn1PE_DeltaFList_PUCCH_deltaF_PUCCH_Format2a (pctxt, pvalue->deltaF_PUCCH_Format2a);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode deltaF_PUCCH_Format2b */

   RTXCTXTPUSHELEMNAME (pctxt, "deltaF-PUCCH-Format2b");

   stat = asn1PE_DeltaFList_PUCCH_deltaF_PUCCH_Format2b (pctxt, pvalue->deltaF_PUCCH_Format2b);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DeltaFList_PUCCH (OSCTXT* pctxt, DeltaFList_PUCCH* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeltaFList-PUCCH");

   /* decode root elements */
   /* decode deltaF_PUCCH_Format1 */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaF-PUCCH-Format1");

   stat = asn1PD_DeltaFList_PUCCH_deltaF_PUCCH_Format1 (pctxt, &pvalue->deltaF_PUCCH_Format1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaF_PUCCH_Format1b */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaF-PUCCH-Format1b");

   stat = asn1PD_DeltaFList_PUCCH_deltaF_PUCCH_Format1b (pctxt, &pvalue->deltaF_PUCCH_Format1b);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaF_PUCCH_Format2 */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaF-PUCCH-Format2");

   stat = asn1PD_DeltaFList_PUCCH_deltaF_PUCCH_Format2 (pctxt, &pvalue->deltaF_PUCCH_Format2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaF_PUCCH_Format2a */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaF-PUCCH-Format2a");

   stat = asn1PD_DeltaFList_PUCCH_deltaF_PUCCH_Format2a (pctxt, &pvalue->deltaF_PUCCH_Format2a);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaF_PUCCH_Format2b */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaF-PUCCH-Format2b");

   stat = asn1PD_DeltaFList_PUCCH_deltaF_PUCCH_Format2b (pctxt, &pvalue->deltaF_PUCCH_Format2b);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UplinkPowerControlCommon (OSCTXT* pctxt, UplinkPowerControlCommon* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkPowerControlCommon");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UplinkPowerControlCommon"));

   /* encode p0_NominalPUSCH */

   RTXCTXTPUSHELEMNAME (pctxt, "p0-NominalPUSCH");

   if ( (pvalue->p0_NominalPUSCH >= OSINTCONST(-126) && pvalue->p0_NominalPUSCH
       <= OSINTCONST(24)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->p0_NominalPUSCH, OSINTCONST(-126), OSINTCONST(24));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->p0_NominalPUSCH);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode alpha */

   RTXCTXTPUSHELEMNAME (pctxt, "alpha");

   stat = asn1PE_UplinkPowerControlCommon_alpha (pctxt, pvalue->alpha);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode p0_NominalPUCCH */

   RTXCTXTPUSHELEMNAME (pctxt, "p0-NominalPUCCH");

   if ( (pvalue->p0_NominalPUCCH >= OSINTCONST(-127) && pvalue->p0_NominalPUCCH
       <= OSINTCONST(-96)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->p0_NominalPUCCH, OSINTCONST(-127), OSINTCONST(-96));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->p0_NominalPUCCH);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode deltaFList_PUCCH */

   RTXCTXTPUSHELEMNAME (pctxt, "deltaFList-PUCCH");

   stat = asn1PE_DeltaFList_PUCCH (pctxt, &pvalue->deltaFList_PUCCH);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode deltaPreambleMsg3 */

   RTXCTXTPUSHELEMNAME (pctxt, "deltaPreambleMsg3");

   if ( (pvalue->deltaPreambleMsg3 >= OSINTCONST(-1) && pvalue->deltaPreambleMsg3
       <= OSINTCONST(6)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->deltaPreambleMsg3, OSINTCONST(-1), OSINTCONST(6));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->deltaPreambleMsg3);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkPowerControlCommon (OSCTXT* pctxt, UplinkPowerControlCommon* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkPowerControlCommon");

   /* decode root elements */
   /* decode p0_NominalPUSCH */
   RTXCTXTPUSHELEMNAME (pctxt, "p0-NominalPUSCH");

   stat = pd_ConsInt8 (pctxt, &pvalue->p0_NominalPUSCH, OSINTCONST(-126), OSINTCONST(24));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode alpha */
   RTXCTXTPUSHELEMNAME (pctxt, "alpha");

   stat = asn1PD_UplinkPowerControlCommon_alpha (pctxt, &pvalue->alpha);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode p0_NominalPUCCH */
   RTXCTXTPUSHELEMNAME (pctxt, "p0-NominalPUCCH");

   stat = pd_ConsInt8 (pctxt, &pvalue->p0_NominalPUCCH, OSINTCONST(-127), OSINTCONST(-96));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaFList_PUCCH */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaFList-PUCCH");

   stat = asn1PD_DeltaFList_PUCCH (pctxt, &pvalue->deltaFList_PUCCH);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaPreambleMsg3 */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaPreambleMsg3");

   stat = pd_ConsInt8 (pctxt, &pvalue->deltaPreambleMsg3, OSINTCONST(-1), OSINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RadioResourceConfigCommonSIB (OSCTXT* pctxt, RadioResourceConfigCommonSIB* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RadioResourceConfigCommonSIB");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RadioResourceConfigCommonSIB"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rach_ConfigCommon */

   RTXCTXTPUSHELEMNAME (pctxt, "rach-ConfigCommon");

   stat = asn1PE_RACH_ConfigCommon (pctxt, &pvalue->rach_ConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode bcch_Config */

   RTXCTXTPUSHELEMNAME (pctxt, "bcch-Config");

   stat = asn1PE_BCCH_Config (pctxt, &pvalue->bcch_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pcch_Config */

   RTXCTXTPUSHELEMNAME (pctxt, "pcch-Config");

   stat = asn1PE_PCCH_Config (pctxt, &pvalue->pcch_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode prach_Config */

   RTXCTXTPUSHELEMNAME (pctxt, "prach-Config");

   stat = asn1PE_PRACH_ConfigSIB (pctxt, &pvalue->prach_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pdsch_ConfigCommon */

   RTXCTXTPUSHELEMNAME (pctxt, "pdsch-ConfigCommon");

   stat = asn1PE_PDSCH_ConfigCommon (pctxt, &pvalue->pdsch_ConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pusch_ConfigCommon */

   RTXCTXTPUSHELEMNAME (pctxt, "pusch-ConfigCommon");

   stat = asn1PE_PUSCH_ConfigCommon (pctxt, &pvalue->pusch_ConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pucch_ConfigCommon */

   RTXCTXTPUSHELEMNAME (pctxt, "pucch-ConfigCommon");

   stat = asn1PE_PUCCH_ConfigCommon (pctxt, &pvalue->pucch_ConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode soundingRS_UL_ConfigCommon */

   RTXCTXTPUSHELEMNAME (pctxt, "soundingRS-UL-ConfigCommon");

   stat = asn1PE_SoundingRS_UL_ConfigCommon (pctxt, &pvalue->soundingRS_UL_ConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uplinkPowerControlCommon */

   RTXCTXTPUSHELEMNAME (pctxt, "uplinkPowerControlCommon");

   stat = asn1PE_UplinkPowerControlCommon (pctxt, &pvalue->uplinkPowerControlCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ul_CyclicPrefixLength */

   RTXCTXTPUSHELEMNAME (pctxt, "ul-CyclicPrefixLength");

   stat = asn1PE_UL_CyclicPrefixLength (pctxt, pvalue->ul_CyclicPrefixLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RadioResourceConfigCommonSIB (OSCTXT* pctxt, RadioResourceConfigCommonSIB* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RadioResourceConfigCommonSIB");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode rach_ConfigCommon */
   RTXCTXTPUSHELEMNAME (pctxt, "rach-ConfigCommon");

   stat = asn1PD_RACH_ConfigCommon (pctxt, &pvalue->rach_ConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode bcch_Config */
   RTXCTXTPUSHELEMNAME (pctxt, "bcch-Config");

   stat = asn1PD_BCCH_Config (pctxt, &pvalue->bcch_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pcch_Config */
   RTXCTXTPUSHELEMNAME (pctxt, "pcch-Config");

   stat = asn1PD_PCCH_Config (pctxt, &pvalue->pcch_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode prach_Config */
   RTXCTXTPUSHELEMNAME (pctxt, "prach-Config");

   stat = asn1PD_PRACH_ConfigSIB (pctxt, &pvalue->prach_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdsch_ConfigCommon */
   RTXCTXTPUSHELEMNAME (pctxt, "pdsch-ConfigCommon");

   stat = asn1PD_PDSCH_ConfigCommon (pctxt, &pvalue->pdsch_ConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pusch_ConfigCommon */
   RTXCTXTPUSHELEMNAME (pctxt, "pusch-ConfigCommon");

   stat = asn1PD_PUSCH_ConfigCommon (pctxt, &pvalue->pusch_ConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pucch_ConfigCommon */
   RTXCTXTPUSHELEMNAME (pctxt, "pucch-ConfigCommon");

   stat = asn1PD_PUCCH_ConfigCommon (pctxt, &pvalue->pucch_ConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode soundingRS_UL_ConfigCommon */
   RTXCTXTPUSHELEMNAME (pctxt, "soundingRS-UL-ConfigCommon");

   stat = asn1PD_SoundingRS_UL_ConfigCommon (pctxt, &pvalue->soundingRS_UL_ConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uplinkPowerControlCommon */
   RTXCTXTPUSHELEMNAME (pctxt, "uplinkPowerControlCommon");

   stat = asn1PD_UplinkPowerControlCommon (pctxt, &pvalue->uplinkPowerControlCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_CyclicPrefixLength */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-CyclicPrefixLength");

   stat = asn1PD_UL_CyclicPrefixLength (pctxt, &pvalue->ul_CyclicPrefixLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RadioResourceConfigCommonSIB (
   RadioResourceConfigCommonSIB* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_RACH_ConfigCommon (&pvalue->rach_ConfigCommon);
   asn1Init_SoundingRS_UL_ConfigCommon (&pvalue->soundingRS_UL_ConfigCommon);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_UE_TimersAndConstants (OSCTXT* pctxt, UE_TimersAndConstants* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-TimersAndConstants");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_TimersAndConstants"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode t300 */

   RTXCTXTPUSHELEMNAME (pctxt, "t300");

   stat = asn1PE_UE_TimersAndConstants_t300 (pctxt, pvalue->t300);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t301 */

   RTXCTXTPUSHELEMNAME (pctxt, "t301");

   stat = asn1PE_UE_TimersAndConstants_t301 (pctxt, pvalue->t301);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t310 */

   RTXCTXTPUSHELEMNAME (pctxt, "t310");

   stat = asn1PE_UE_TimersAndConstants_t310 (pctxt, pvalue->t310);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode n310 */

   RTXCTXTPUSHELEMNAME (pctxt, "n310");

   stat = asn1PE_UE_TimersAndConstants_n310 (pctxt, pvalue->n310);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t311 */

   RTXCTXTPUSHELEMNAME (pctxt, "t311");

   stat = asn1PE_UE_TimersAndConstants_t311 (pctxt, pvalue->t311);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode n311 */

   RTXCTXTPUSHELEMNAME (pctxt, "n311");

   stat = asn1PE_UE_TimersAndConstants_n311 (pctxt, pvalue->n311);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_TimersAndConstants (OSCTXT* pctxt, UE_TimersAndConstants* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-TimersAndConstants");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode t300 */
   RTXCTXTPUSHELEMNAME (pctxt, "t300");

   stat = asn1PD_UE_TimersAndConstants_t300 (pctxt, &pvalue->t300);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t301 */
   RTXCTXTPUSHELEMNAME (pctxt, "t301");

   stat = asn1PD_UE_TimersAndConstants_t301 (pctxt, &pvalue->t301);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t310 */
   RTXCTXTPUSHELEMNAME (pctxt, "t310");

   stat = asn1PD_UE_TimersAndConstants_t310 (pctxt, &pvalue->t310);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode n310 */
   RTXCTXTPUSHELEMNAME (pctxt, "n310");

   stat = asn1PD_UE_TimersAndConstants_n310 (pctxt, &pvalue->n310);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t311 */
   RTXCTXTPUSHELEMNAME (pctxt, "t311");

   stat = asn1PD_UE_TimersAndConstants_t311 (pctxt, &pvalue->t311);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode n311 */
   RTXCTXTPUSHELEMNAME (pctxt, "n311");

   stat = asn1PD_UE_TimersAndConstants_n311 (pctxt, &pvalue->n311);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UE_TimersAndConstants (UE_TimersAndConstants* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_SystemInformationBlockType2_freqInfo (OSCTXT* pctxt, SystemInformationBlockType2_freqInfo* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType2_freqInfo"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ul_CarrierFreqPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ul_BandwidthPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ul_CarrierFreq */

   if (pvalue->m.ul_CarrierFreqPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CarrierFreq");

      stat = asn1PE_ARFCN_ValueEUTRA (pctxt, pvalue->ul_CarrierFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode ul_Bandwidth */

   if (pvalue->m.ul_BandwidthPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-Bandwidth");

      stat = asn1PE_SystemInformationBlockType2_freqInfo_ul_Bandwidth (pctxt, pvalue->ul_Bandwidth);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode additionalSpectrumEmission */

   RTXCTXTPUSHELEMNAME (pctxt, "additionalSpectrumEmission");

   stat = asn1PE_AdditionalSpectrumEmission (pctxt, pvalue->additionalSpectrumEmission);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType2_freqInfo (OSCTXT* pctxt, SystemInformationBlockType2_freqInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_CarrierFreq */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CarrierFreq");

      pvalue->m.ul_CarrierFreqPresent = 1;

      stat = asn1PD_ARFCN_ValueEUTRA (pctxt, &pvalue->ul_CarrierFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_Bandwidth */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-Bandwidth");

      pvalue->m.ul_BandwidthPresent = 1;

      stat = asn1PD_SystemInformationBlockType2_freqInfo_ul_Bandwidth (pctxt, &pvalue->ul_Bandwidth);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode additionalSpectrumEmission */
   RTXCTXTPUSHELEMNAME (pctxt, "additionalSpectrumEmission");

   stat = asn1PD_AdditionalSpectrumEmission (pctxt, &pvalue->additionalSpectrumEmission);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType2_freqInfo (
   SystemInformationBlockType2_freqInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_MBSFN_SubframeConfig_subframeAllocation (OSCTXT* pctxt, MBSFN_SubframeConfig_subframeAllocation* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFN_SubframeConfig_subframeAllocation"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* oneFrame */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "oneFrame");

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

         stat = pe_BitString32 (pctxt, pvalue->u.oneFrame, OSUINTCONST(6), OSUINTCONST(6));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* fourFrames */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "fourFrames");

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(24), OSUINTCONST(24), 0, 0);

         stat = pe_BitString32 (pctxt, pvalue->u.fourFrames, OSUINTCONST(24), OSUINTCONST(24));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFN_SubframeConfig_subframeAllocation (OSCTXT* pctxt, MBSFN_SubframeConfig_subframeAllocation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* oneFrame */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "oneFrame");

         pvalue->u.oneFrame = rtxMemAllocType (pctxt, ASN1BitStr32);

         if (pvalue->u.oneFrame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.oneFrame->numbits = 0;

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

         stat = pd_BitString32 (pctxt, pvalue->u.oneFrame
            , OSUINTCONST(6), OSUINTCONST(6));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* fourFrames */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "fourFrames");

         pvalue->u.fourFrames = rtxMemAllocType (pctxt, ASN1BitStr32);

         if (pvalue->u.fourFrames == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.fourFrames->numbits = 0;

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(24), OSUINTCONST(24), 0, 0);

         stat = pd_BitString32 (pctxt, pvalue->u.fourFrames
            , OSUINTCONST(24), OSUINTCONST(24));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_MBSFN_SubframeConfig_subframeAllocation (
   MBSFN_SubframeConfig_subframeAllocation* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MBSFN_SubframeConfig (OSCTXT* pctxt, MBSFN_SubframeConfig* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBSFN-SubframeConfig");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFN_SubframeConfig"));

   /* encode radioframeAllocationPeriod */

   RTXCTXTPUSHELEMNAME (pctxt, "radioframeAllocationPeriod");

   stat = asn1PE_MBSFN_SubframeConfig_radioframeAllocationPeriod (pctxt, pvalue->radioframeAllocationPeriod);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode radioframeAllocationOffset */

   RTXCTXTPUSHELEMNAME (pctxt, "radioframeAllocationOffset");

   if ( (pvalue->radioframeAllocationOffset <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->radioframeAllocationOffset, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->radioframeAllocationOffset);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode subframeAllocation */

   RTXCTXTPUSHELEMNAME (pctxt, "subframeAllocation");

   stat = asn1PE_MBSFN_SubframeConfig_subframeAllocation (pctxt, &pvalue->subframeAllocation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFN_SubframeConfig (OSCTXT* pctxt, MBSFN_SubframeConfig* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBSFN-SubframeConfig");

   /* decode root elements */
   /* decode radioframeAllocationPeriod */
   RTXCTXTPUSHELEMNAME (pctxt, "radioframeAllocationPeriod");

   stat = asn1PD_MBSFN_SubframeConfig_radioframeAllocationPeriod (pctxt, &pvalue->radioframeAllocationPeriod);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode radioframeAllocationOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "radioframeAllocationOffset");

   stat = pd_ConsUInt8 (pctxt, &pvalue->radioframeAllocationOffset, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode subframeAllocation */
   RTXCTXTPUSHELEMNAME (pctxt, "subframeAllocation");

   stat = asn1PD_MBSFN_SubframeConfig_subframeAllocation (pctxt, &pvalue->subframeAllocation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MBSFN_SubframeConfig (MBSFN_SubframeConfig* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_MBSFN_SubframeConfig_subframeAllocation (&pvalue->subframeAllocation);
}

EXTERN int asn1PE_MBSFN_SubframeConfigList (OSCTXT* pctxt, MBSFN_SubframeConfigList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MBSFN-SubframeConfigList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFN_SubframeConfigList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MBSFN-SubframeConfig", xx1);

      stat = asn1PE_MBSFN_SubframeConfig (pctxt, ((MBSFN_SubframeConfig*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFN_SubframeConfigList (OSCTXT* pctxt, MBSFN_SubframeConfigList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBSFN-SubframeConfigList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MBSFN_SubframeConfig* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MBSFN-SubframeConfig", xx1);

      rtxDListAllocNodeAndData (pctxt, MBSFN_SubframeConfig, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MBSFN_SubframeConfig (pdata);

      stat = asn1PD_MBSFN_SubframeConfig (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MBSFN_SubframeConfigList (MBSFN_SubframeConfigList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_SystemInformationBlockType2 (OSCTXT* pctxt, SystemInformationBlockType2* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType2");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType2"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m.lateNonCriticalExtensionPresent ||
   pvalue->m._v3ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ac_BarringInfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.mbsfn_SubframeConfigListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ac_BarringInfo */

   if (pvalue->m.ac_BarringInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringInfo");

      stat = asn1PE_SystemInformationBlockType2_ac_BarringInfo (pctxt, &pvalue->ac_BarringInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode radioResourceConfigCommon */

   RTXCTXTPUSHELEMNAME (pctxt, "radioResourceConfigCommon");

   stat = asn1PE_RadioResourceConfigCommonSIB (pctxt, &pvalue->radioResourceConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ue_TimersAndConstants */

   RTXCTXTPUSHELEMNAME (pctxt, "ue-TimersAndConstants");

   stat = asn1PE_UE_TimersAndConstants (pctxt, &pvalue->ue_TimersAndConstants);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode freqInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "freqInfo");

   stat = asn1PE_SystemInformationBlockType2_freqInfo (pctxt, &pvalue->freqInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode mbsfn_SubframeConfigList */

   if (pvalue->m.mbsfn_SubframeConfigListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "mbsfn-SubframeConfigList");

      stat = asn1PE_MBSFN_SubframeConfigList (pctxt, &pvalue->mbsfn_SubframeConfigList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode timeAlignmentTimerCommon */

   RTXCTXTPUSHELEMNAME (pctxt, "timeAlignmentTimerCommon");

   stat = asn1PE_TimeAlignmentTimer (pctxt, pvalue->timeAlignmentTimerCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v3ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m.lateNonCriticalExtensionPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->m._v3ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ssac_BarringForMMTEL_Voice_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ssac_BarringForMMTEL_Video_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode ssac_BarringForMMTEL_Voice_r9 */

         if (pvalue->m.ssac_BarringForMMTEL_Voice_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "ssac-BarringForMMTEL-Voice-r9");

            stat = asn1PE_AC_BarringConfig (pctxt, &pvalue->ssac_BarringForMMTEL_Voice_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         /* encode ssac_BarringForMMTEL_Video_r9 */

         if (pvalue->m.ssac_BarringForMMTEL_Video_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "ssac-BarringForMMTEL-Video-r9");

            stat = asn1PE_AC_BarringConfig (pctxt, &pvalue->ssac_BarringForMMTEL_Video_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType2 (OSCTXT* pctxt, SystemInformationBlockType2* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType2");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ac_BarringInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringInfo");

      pvalue->m.ac_BarringInfoPresent = 1;

      stat = asn1PD_SystemInformationBlockType2_ac_BarringInfo (pctxt, &pvalue->ac_BarringInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode radioResourceConfigCommon */
   RTXCTXTPUSHELEMNAME (pctxt, "radioResourceConfigCommon");

   stat = asn1PD_RadioResourceConfigCommonSIB (pctxt, &pvalue->radioResourceConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ue_TimersAndConstants */
   RTXCTXTPUSHELEMNAME (pctxt, "ue-TimersAndConstants");

   stat = asn1PD_UE_TimersAndConstants (pctxt, &pvalue->ue_TimersAndConstants);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode freqInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "freqInfo");

   stat = asn1PD_SystemInformationBlockType2_freqInfo (pctxt, &pvalue->freqInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mbsfn_SubframeConfigList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mbsfn-SubframeConfigList");

      pvalue->m.mbsfn_SubframeConfigListPresent = 1;

      stat = asn1PD_MBSFN_SubframeConfigList (pctxt, &pvalue->mbsfn_SubframeConfigList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode timeAlignmentTimerCommon */
   RTXCTXTPUSHELEMNAME (pctxt, "timeAlignmentTimerCommon");

   stat = asn1PD_TimeAlignmentTimer (pctxt, &pvalue->timeAlignmentTimerCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 2) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.lateNonCriticalExtensionPresent = 1;
                        RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

                        stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
                        if (stat != 0) {
                           rtxMemFreePtr (pctxt, openType.data);
                           break;
                        }

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                     case 1:
                        pvalue->m._v3ExtPresent = 1;
                        {
                           OSOCTET extoptbits[2];
                           OSUINT32 _i;

                           for (_i = 0; _i < 2; _i++) {
                              stat = DEC_BIT (pctxt, &extoptbits[_i]);
                              if (stat != 0)  {
                                 rtxMemFreePtr (pctxt, poptbits);
                                 return LOG_RTERR (pctxt, stat);
                              }
                           }
                           if (extoptbits[0]) {
                              pvalue->m.ssac_BarringForMMTEL_Voice_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "ssac-BarringForMMTEL-Voice-r9");

                              stat = asn1PD_AC_BarringConfig (pctxt, &pvalue->ssac_BarringForMMTEL_Voice_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                           if (extoptbits[1]) {
                              pvalue->m.ssac_BarringForMMTEL_Video_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "ssac-BarringForMMTEL-Video-r9");

                              stat = asn1PD_AC_BarringConfig (pctxt, &pvalue->ssac_BarringForMMTEL_Video_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;

                        /* Coverity 55351 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 2 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 2) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType2 (SystemInformationBlockType2* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SystemInformationBlockType2_ac_BarringInfo (&pvalue->ac_BarringInfo);
   asn1Init_RadioResourceConfigCommonSIB (&pvalue->radioResourceConfigCommon);
   asn1Init_UE_TimersAndConstants (&pvalue->ue_TimersAndConstants);
   asn1Init_SystemInformationBlockType2_freqInfo (&pvalue->freqInfo);
   asn1Init_MBSFN_SubframeConfigList (&pvalue->mbsfn_SubframeConfigList);
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   asn1Init_AC_BarringConfig (&pvalue->ssac_BarringForMMTEL_Voice_r9);
   asn1Init_AC_BarringConfig (&pvalue->ssac_BarringForMMTEL_Video_r9);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_MobilityStateParameters (OSCTXT* pctxt, MobilityStateParameters* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityStateParameters");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityStateParameters"));

   /* encode t_Evaluation */

   RTXCTXTPUSHELEMNAME (pctxt, "t-Evaluation");

   stat = asn1PE_MobilityStateParameters_t_Evaluation (pctxt, pvalue->t_Evaluation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t_HystNormal */

   RTXCTXTPUSHELEMNAME (pctxt, "t-HystNormal");

   stat = asn1PE_MobilityStateParameters_t_HystNormal (pctxt, pvalue->t_HystNormal);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode n_CellChangeMedium */

   RTXCTXTPUSHELEMNAME (pctxt, "n-CellChangeMedium");

   if ( (pvalue->n_CellChangeMedium >= OSUINTCONST(1) && pvalue->n_CellChangeMedium
       <= OSUINTCONST(16)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->n_CellChangeMedium, OSUINTCONST(1), OSUINTCONST(16));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->n_CellChangeMedium);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode n_CellChangeHigh */

   RTXCTXTPUSHELEMNAME (pctxt, "n-CellChangeHigh");

   if ( (pvalue->n_CellChangeHigh >= OSUINTCONST(1) && pvalue->n_CellChangeHigh
       <= OSUINTCONST(16)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->n_CellChangeHigh, OSUINTCONST(1), OSUINTCONST(16));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->n_CellChangeHigh);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityStateParameters (OSCTXT* pctxt, MobilityStateParameters* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityStateParameters");

   /* decode root elements */
   /* decode t_Evaluation */
   RTXCTXTPUSHELEMNAME (pctxt, "t-Evaluation");

   stat = asn1PD_MobilityStateParameters_t_Evaluation (pctxt, &pvalue->t_Evaluation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t_HystNormal */
   RTXCTXTPUSHELEMNAME (pctxt, "t-HystNormal");

   stat = asn1PD_MobilityStateParameters_t_HystNormal (pctxt, &pvalue->t_HystNormal);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode n_CellChangeMedium */
   RTXCTXTPUSHELEMNAME (pctxt, "n-CellChangeMedium");

   stat = pd_ConsUInt8 (pctxt, &pvalue->n_CellChangeMedium, OSUINTCONST(1), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode n_CellChangeHigh */
   RTXCTXTPUSHELEMNAME (pctxt, "n-CellChangeHigh");

   stat = pd_ConsUInt8 (pctxt, &pvalue->n_CellChangeHigh, OSUINTCONST(1), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF (OSCTXT* pctxt, SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF"));

   /* encode sf_Medium */

   RTXCTXTPUSHELEMNAME (pctxt, "sf-Medium");

   stat = asn1PE_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium (pctxt, pvalue->sf_Medium);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sf_High */

   RTXCTXTPUSHELEMNAME (pctxt, "sf-High");

   stat = asn1PE_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High (pctxt, pvalue->sf_High);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF (OSCTXT* pctxt, SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode sf_Medium */
   RTXCTXTPUSHELEMNAME (pctxt, "sf-Medium");

   stat = asn1PD_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium (pctxt, &pvalue->sf_Medium);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sf_High */
   RTXCTXTPUSHELEMNAME (pctxt, "sf-High");

   stat = asn1PD_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High (pctxt, &pvalue->sf_High);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars (OSCTXT* pctxt, SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars"));

   /* encode mobilityStateParameters */

   RTXCTXTPUSHELEMNAME (pctxt, "mobilityStateParameters");

   stat = asn1PE_MobilityStateParameters (pctxt, &pvalue->mobilityStateParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode q_HystSF */

   RTXCTXTPUSHELEMNAME (pctxt, "q-HystSF");

   stat = asn1PE_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF (pctxt, &pvalue->q_HystSF);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars (OSCTXT* pctxt, SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode mobilityStateParameters */
   RTXCTXTPUSHELEMNAME (pctxt, "mobilityStateParameters");

   stat = asn1PD_MobilityStateParameters (pctxt, &pvalue->mobilityStateParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode q_HystSF */
   RTXCTXTPUSHELEMNAME (pctxt, "q-HystSF");

   stat = asn1PD_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF (pctxt, &pvalue->q_HystSF);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SystemInformationBlockType3_cellReselectionInfoCommon (OSCTXT* pctxt, SystemInformationBlockType3_cellReselectionInfoCommon* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType3_cellReselectionInfoCommon"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedStateReselectionParsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode q_Hyst */

   RTXCTXTPUSHELEMNAME (pctxt, "q-Hyst");

   stat = asn1PE_SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst (pctxt, pvalue->q_Hyst);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode speedStateReselectionPars */

   if (pvalue->m.speedStateReselectionParsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "speedStateReselectionPars");

      stat = asn1PE_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars (pctxt, &pvalue->speedStateReselectionPars);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType3_cellReselectionInfoCommon (OSCTXT* pctxt, SystemInformationBlockType3_cellReselectionInfoCommon* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode q_Hyst */
   RTXCTXTPUSHELEMNAME (pctxt, "q-Hyst");

   stat = asn1PD_SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst (pctxt, &pvalue->q_Hyst);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode speedStateReselectionPars */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "speedStateReselectionPars");

      pvalue->m.speedStateReselectionParsPresent = 1;

      stat = asn1PD_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars (pctxt, &pvalue->speedStateReselectionPars);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_SystemInformationBlockType3_cellReselectionInfoCommon (
   SystemInformationBlockType3_cellReselectionInfoCommon* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_SystemInformationBlockType3_cellReselectionServingFreqInfo (OSCTXT* pctxt, SystemInformationBlockType3_cellReselectionServingFreqInfo* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType3_cellReselectionServingFreqInfo"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.s_NonIntraSearchPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode s_NonIntraSearch */

   if (pvalue->m.s_NonIntraSearchPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "s-NonIntraSearch");

      stat = asn1PE_ReselectionThreshold (pctxt, pvalue->s_NonIntraSearch);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode threshServingLow */

   RTXCTXTPUSHELEMNAME (pctxt, "threshServingLow");

   stat = asn1PE_ReselectionThreshold (pctxt, pvalue->threshServingLow);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellReselectionPriority */

   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

   stat = asn1PE_CellReselectionPriority (pctxt, pvalue->cellReselectionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType3_cellReselectionServingFreqInfo (OSCTXT* pctxt, SystemInformationBlockType3_cellReselectionServingFreqInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode s_NonIntraSearch */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "s-NonIntraSearch");

      pvalue->m.s_NonIntraSearchPresent = 1;

      stat = asn1PD_ReselectionThreshold (pctxt, &pvalue->s_NonIntraSearch);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode threshServingLow */
   RTXCTXTPUSHELEMNAME (pctxt, "threshServingLow");

   stat = asn1PD_ReselectionThreshold (pctxt, &pvalue->threshServingLow);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellReselectionPriority */
   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

   stat = asn1PD_CellReselectionPriority (pctxt, &pvalue->cellReselectionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType3_cellReselectionServingFreqInfo (
   SystemInformationBlockType3_cellReselectionServingFreqInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_SpeedStateScaleFactors (OSCTXT* pctxt, SpeedStateScaleFactors* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SpeedStateScaleFactors");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SpeedStateScaleFactors"));

   /* encode sf_Medium */

   RTXCTXTPUSHELEMNAME (pctxt, "sf-Medium");

   stat = asn1PE_SpeedStateScaleFactors_sf_Medium (pctxt, pvalue->sf_Medium);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sf_High */

   RTXCTXTPUSHELEMNAME (pctxt, "sf-High");

   stat = asn1PE_SpeedStateScaleFactors_sf_High (pctxt, pvalue->sf_High);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SpeedStateScaleFactors (OSCTXT* pctxt, SpeedStateScaleFactors* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SpeedStateScaleFactors");

   /* decode root elements */
   /* decode sf_Medium */
   RTXCTXTPUSHELEMNAME (pctxt, "sf-Medium");

   stat = asn1PD_SpeedStateScaleFactors_sf_Medium (pctxt, &pvalue->sf_Medium);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sf_High */
   RTXCTXTPUSHELEMNAME (pctxt, "sf-High");

   stat = asn1PD_SpeedStateScaleFactors_sf_High (pctxt, &pvalue->sf_High);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SystemInformationBlockType3_intraFreqCellReselectionInfo (OSCTXT* pctxt, SystemInformationBlockType3_intraFreqCellReselectionInfo* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType3_intraFreqCellReselectionInfo"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.p_MaxPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.s_IntraSearchPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.allowedMeasBandwidthPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.t_ReselectionEUTRA_SFPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode q_RxLevMin */

   RTXCTXTPUSHELEMNAME (pctxt, "q-RxLevMin");

   stat = asn1PE_Q_RxLevMin (pctxt, pvalue->q_RxLevMin);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode p_Max */

   if (pvalue->m.p_MaxPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "p-Max");

      stat = asn1PE_P_Max (pctxt, pvalue->p_Max);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode s_IntraSearch */

   if (pvalue->m.s_IntraSearchPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "s-IntraSearch");

      stat = asn1PE_ReselectionThreshold (pctxt, pvalue->s_IntraSearch);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode allowedMeasBandwidth */

   if (pvalue->m.allowedMeasBandwidthPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "allowedMeasBandwidth");

      stat = asn1PE_AllowedMeasBandwidth (pctxt, pvalue->allowedMeasBandwidth);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode presenceAntennaPort1 */

   RTXCTXTPUSHELEMNAME (pctxt, "presenceAntennaPort1");

   stat = asn1PE_PresenceAntennaPort1 (pctxt, pvalue->presenceAntennaPort1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode neighCellConfig */

   RTXCTXTPUSHELEMNAME (pctxt, "neighCellConfig");

   stat = asn1PE_NeighCellConfig (pctxt, pvalue->neighCellConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t_ReselectionEUTRA */

   RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionEUTRA");

   stat = asn1PE_T_Reselection (pctxt, pvalue->t_ReselectionEUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t_ReselectionEUTRA_SF */

   if (pvalue->m.t_ReselectionEUTRA_SFPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionEUTRA-SF");

      stat = asn1PE_SpeedStateScaleFactors (pctxt, &pvalue->t_ReselectionEUTRA_SF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType3_intraFreqCellReselectionInfo (OSCTXT* pctxt, SystemInformationBlockType3_intraFreqCellReselectionInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode q_RxLevMin */
   RTXCTXTPUSHELEMNAME (pctxt, "q-RxLevMin");

   stat = asn1PD_Q_RxLevMin (pctxt, &pvalue->q_RxLevMin);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode p_Max */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "p-Max");

      pvalue->m.p_MaxPresent = 1;

      stat = asn1PD_P_Max (pctxt, &pvalue->p_Max);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode s_IntraSearch */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "s-IntraSearch");

      pvalue->m.s_IntraSearchPresent = 1;

      stat = asn1PD_ReselectionThreshold (pctxt, &pvalue->s_IntraSearch);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode allowedMeasBandwidth */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "allowedMeasBandwidth");

      pvalue->m.allowedMeasBandwidthPresent = 1;

      stat = asn1PD_AllowedMeasBandwidth (pctxt, &pvalue->allowedMeasBandwidth);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode presenceAntennaPort1 */
   RTXCTXTPUSHELEMNAME (pctxt, "presenceAntennaPort1");

   stat = asn1PD_PresenceAntennaPort1 (pctxt, &pvalue->presenceAntennaPort1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode neighCellConfig */
   RTXCTXTPUSHELEMNAME (pctxt, "neighCellConfig");

   stat = asn1PD_NeighCellConfig (pctxt, &pvalue->neighCellConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t_ReselectionEUTRA */
   RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionEUTRA");

   stat = asn1PD_T_Reselection (pctxt, &pvalue->t_ReselectionEUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t_ReselectionEUTRA_SF */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionEUTRA-SF");

      pvalue->m.t_ReselectionEUTRA_SFPresent = 1;

      stat = asn1PD_SpeedStateScaleFactors (pctxt, &pvalue->t_ReselectionEUTRA_SF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_SystemInformationBlockType3_intraFreqCellReselectionInfo (
   SystemInformationBlockType3_intraFreqCellReselectionInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_NeighCellConfig (&pvalue->neighCellConfig);
}

EXTERN int asn1PE_SystemInformationBlockType3_s_IntraSearch_v920 (OSCTXT* pctxt, SystemInformationBlockType3_s_IntraSearch_v920* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType3_s_IntraSearch_v920"));

   /* encode s_IntraSearchP_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "s-IntraSearchP-r9");

   stat = asn1PE_ReselectionThreshold (pctxt, pvalue->s_IntraSearchP_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode s_IntraSearchQ_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "s-IntraSearchQ-r9");

   stat = asn1PE_ReselectionThresholdQ_r9 (pctxt, pvalue->s_IntraSearchQ_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType3_s_IntraSearch_v920 (OSCTXT* pctxt, SystemInformationBlockType3_s_IntraSearch_v920* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode s_IntraSearchP_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "s-IntraSearchP-r9");

   stat = asn1PD_ReselectionThreshold (pctxt, &pvalue->s_IntraSearchP_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode s_IntraSearchQ_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "s-IntraSearchQ-r9");

   stat = asn1PD_ReselectionThresholdQ_r9 (pctxt, &pvalue->s_IntraSearchQ_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SystemInformationBlockType3_s_NonIntraSearch_v920 (OSCTXT* pctxt, SystemInformationBlockType3_s_NonIntraSearch_v920* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType3_s_NonIntraSearch_v920"));

   /* encode s_NonIntraSearchP_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "s-NonIntraSearchP-r9");

   stat = asn1PE_ReselectionThreshold (pctxt, pvalue->s_NonIntraSearchP_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode s_NonIntraSearchQ_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "s-NonIntraSearchQ-r9");

   stat = asn1PE_ReselectionThresholdQ_r9 (pctxt, pvalue->s_NonIntraSearchQ_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType3_s_NonIntraSearch_v920 (OSCTXT* pctxt, SystemInformationBlockType3_s_NonIntraSearch_v920* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode s_NonIntraSearchP_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "s-NonIntraSearchP-r9");

   stat = asn1PD_ReselectionThreshold (pctxt, &pvalue->s_NonIntraSearchP_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode s_NonIntraSearchQ_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "s-NonIntraSearchQ-r9");

   stat = asn1PD_ReselectionThresholdQ_r9 (pctxt, &pvalue->s_NonIntraSearchQ_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SystemInformationBlockType3 (OSCTXT* pctxt, SystemInformationBlockType3* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType3");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType3"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m.lateNonCriticalExtensionPresent ||
   pvalue->m._v3ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cellReselectionInfoCommon */

   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionInfoCommon");

   stat = asn1PE_SystemInformationBlockType3_cellReselectionInfoCommon (pctxt, &pvalue->cellReselectionInfoCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellReselectionServingFreqInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionServingFreqInfo");

   stat = asn1PE_SystemInformationBlockType3_cellReselectionServingFreqInfo (pctxt, &pvalue->cellReselectionServingFreqInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode intraFreqCellReselectionInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "intraFreqCellReselectionInfo");

   stat = asn1PE_SystemInformationBlockType3_intraFreqCellReselectionInfo (pctxt, &pvalue->intraFreqCellReselectionInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v3ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m.lateNonCriticalExtensionPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->m._v3ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.s_IntraSearch_v920Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.s_NonIntraSearch_v920Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.q_QualMin_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.threshServingLowQ_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode s_IntraSearch_v920 */

         if (pvalue->m.s_IntraSearch_v920Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "s-IntraSearch-v920");

            stat = asn1PE_SystemInformationBlockType3_s_IntraSearch_v920 (pctxt, &pvalue->s_IntraSearch_v920);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         /* encode s_NonIntraSearch_v920 */

         if (pvalue->m.s_NonIntraSearch_v920Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "s-NonIntraSearch-v920");

            stat = asn1PE_SystemInformationBlockType3_s_NonIntraSearch_v920 (pctxt, &pvalue->s_NonIntraSearch_v920);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         /* encode q_QualMin_r9 */

         if (pvalue->m.q_QualMin_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "q-QualMin-r9");

            stat = asn1PE_Q_QualMin_r9 (pctxt, pvalue->q_QualMin_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         /* encode threshServingLowQ_r9 */

         if (pvalue->m.threshServingLowQ_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "threshServingLowQ-r9");

            stat = asn1PE_ReselectionThresholdQ_r9 (pctxt, pvalue->threshServingLowQ_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType3 (OSCTXT* pctxt, SystemInformationBlockType3* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType3");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode cellReselectionInfoCommon */
   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionInfoCommon");

   stat = asn1PD_SystemInformationBlockType3_cellReselectionInfoCommon (pctxt, &pvalue->cellReselectionInfoCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellReselectionServingFreqInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionServingFreqInfo");

   stat = asn1PD_SystemInformationBlockType3_cellReselectionServingFreqInfo (pctxt, &pvalue->cellReselectionServingFreqInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode intraFreqCellReselectionInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "intraFreqCellReselectionInfo");

   stat = asn1PD_SystemInformationBlockType3_intraFreqCellReselectionInfo (pctxt, &pvalue->intraFreqCellReselectionInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 2) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.lateNonCriticalExtensionPresent = 1;
                        RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

                        stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
                        if (stat != 0) {
                           rtxMemFreePtr (pctxt, openType.data);
                           break;
                        }

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                     case 1:
                        pvalue->m._v3ExtPresent = 1;
                        {
                           OSOCTET extoptbits[4];
                           OSUINT32 _i;

                           for (_i = 0; _i < 4; _i++) {
                              stat = DEC_BIT (pctxt, &extoptbits[_i]);
                              if (stat != 0)  {
                                 rtxMemFreePtr (pctxt, poptbits);
                                 return LOG_RTERR (pctxt, stat);
                              }
                           }
                           if (extoptbits[0]) {
                              pvalue->m.s_IntraSearch_v920Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "s-IntraSearch-v920");

                              stat = asn1PD_SystemInformationBlockType3_s_IntraSearch_v920 (pctxt, &pvalue->s_IntraSearch_v920);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                           if (extoptbits[1]) {
                              pvalue->m.s_NonIntraSearch_v920Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "s-NonIntraSearch-v920");

                              stat = asn1PD_SystemInformationBlockType3_s_NonIntraSearch_v920 (pctxt, &pvalue->s_NonIntraSearch_v920);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                           if (extoptbits[2]) {
                              pvalue->m.q_QualMin_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "q-QualMin-r9");

                              stat = asn1PD_Q_QualMin_r9 (pctxt, &pvalue->q_QualMin_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                           if (extoptbits[3]) {
                              pvalue->m.threshServingLowQ_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "threshServingLowQ-r9");

                              stat = asn1PD_ReselectionThresholdQ_r9 (pctxt, &pvalue->threshServingLowQ_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;

                        /* Coverity 55348 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 2 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 2) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType3 (SystemInformationBlockType3* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SystemInformationBlockType3_cellReselectionInfoCommon (&pvalue->cellReselectionInfoCommon);
   asn1Init_SystemInformationBlockType3_cellReselectionServingFreqInfo (&pvalue->cellReselectionServingFreqInfo);
   asn1Init_SystemInformationBlockType3_intraFreqCellReselectionInfo (&pvalue->intraFreqCellReselectionInfo);
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_IntraFreqNeighCellInfo (OSCTXT* pctxt, IntraFreqNeighCellInfo* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "IntraFreqNeighCellInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IntraFreqNeighCellInfo"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode physCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PE_PhysCellId (pctxt, pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode q_OffsetCell */

   RTXCTXTPUSHELEMNAME (pctxt, "q-OffsetCell");

   stat = asn1PE_Q_OffsetRange (pctxt, pvalue->q_OffsetCell);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IntraFreqNeighCellInfo (OSCTXT* pctxt, IntraFreqNeighCellInfo* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "IntraFreqNeighCellInfo");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode physCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PD_PhysCellId (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode q_OffsetCell */
   RTXCTXTPUSHELEMNAME (pctxt, "q-OffsetCell");

   stat = asn1PD_Q_OffsetRange (pctxt, &pvalue->q_OffsetCell);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_IntraFreqNeighCellInfo (IntraFreqNeighCellInfo* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_IntraFreqNeighCellList (OSCTXT* pctxt, IntraFreqNeighCellList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "IntraFreqNeighCellList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IntraFreqNeighCellList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "IntraFreqNeighCellInfo", xx1);

      stat = asn1PE_IntraFreqNeighCellInfo (pctxt, ((IntraFreqNeighCellInfo*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IntraFreqNeighCellList (OSCTXT* pctxt, IntraFreqNeighCellList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IntraFreqNeighCellList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      IntraFreqNeighCellInfo* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "IntraFreqNeighCellInfo", xx1);

      rtxDListAllocNodeAndData (pctxt, IntraFreqNeighCellInfo, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_IntraFreqNeighCellInfo (pdata);

      stat = asn1PD_IntraFreqNeighCellInfo (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_IntraFreqNeighCellList (IntraFreqNeighCellList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_PhysCellIdRange (OSCTXT* pctxt, PhysCellIdRange* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdRange");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhysCellIdRange"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rangePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode start */

   RTXCTXTPUSHELEMNAME (pctxt, "start");

   stat = asn1PE_PhysCellId (pctxt, pvalue->start);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode range */

   if (pvalue->m.rangePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "range");

      stat = asn1PE_PhysCellIdRange_range (pctxt, pvalue->range);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhysCellIdRange (OSCTXT* pctxt, PhysCellIdRange* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdRange");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode start */
   RTXCTXTPUSHELEMNAME (pctxt, "start");

   stat = asn1PD_PhysCellId (pctxt, &pvalue->start);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode range */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "range");

      pvalue->m.rangePresent = 1;

      stat = asn1PD_PhysCellIdRange_range (pctxt, &pvalue->range);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PhysCellIdRange (PhysCellIdRange* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_IntraFreqBlackCellList (OSCTXT* pctxt, IntraFreqBlackCellList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "IntraFreqBlackCellList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IntraFreqBlackCellList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PhysCellIdRange", xx1);

      stat = asn1PE_PhysCellIdRange (pctxt, ((PhysCellIdRange*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IntraFreqBlackCellList (OSCTXT* pctxt, IntraFreqBlackCellList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IntraFreqBlackCellList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PhysCellIdRange* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PhysCellIdRange", xx1);

      rtxDListAllocNodeAndData (pctxt, PhysCellIdRange, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PhysCellIdRange (pdata);

      stat = asn1PD_PhysCellIdRange (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_IntraFreqBlackCellList (IntraFreqBlackCellList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_SystemInformationBlockType4 (OSCTXT* pctxt, SystemInformationBlockType4* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType4");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType4"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m.lateNonCriticalExtensionPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.intraFreqNeighCellListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.intraFreqBlackCellListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.csg_PhysCellIdRangePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode intraFreqNeighCellList */

   if (pvalue->m.intraFreqNeighCellListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "intraFreqNeighCellList");

      stat = asn1PE_IntraFreqNeighCellList (pctxt, &pvalue->intraFreqNeighCellList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode intraFreqBlackCellList */

   if (pvalue->m.intraFreqBlackCellListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "intraFreqBlackCellList");

      stat = asn1PE_IntraFreqBlackCellList (pctxt, &pvalue->intraFreqBlackCellList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode csg_PhysCellIdRange */

   if (pvalue->m.csg_PhysCellIdRangePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "csg-PhysCellIdRange");

      stat = asn1PE_PhysCellIdRange (pctxt, &pvalue->csg_PhysCellIdRange);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m.lateNonCriticalExtensionPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType4 (OSCTXT* pctxt, SystemInformationBlockType4* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType4");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode intraFreqNeighCellList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "intraFreqNeighCellList");

      pvalue->m.intraFreqNeighCellListPresent = 1;

      stat = asn1PD_IntraFreqNeighCellList (pctxt, &pvalue->intraFreqNeighCellList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode intraFreqBlackCellList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "intraFreqBlackCellList");

      pvalue->m.intraFreqBlackCellListPresent = 1;

      stat = asn1PD_IntraFreqBlackCellList (pctxt, &pvalue->intraFreqBlackCellList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode csg_PhysCellIdRange */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "csg-PhysCellIdRange");

      pvalue->m.csg_PhysCellIdRangePresent = 1;

      stat = asn1PD_PhysCellIdRange (pctxt, &pvalue->csg_PhysCellIdRange);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.lateNonCriticalExtensionPresent = 1;
                        RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

                        stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
                        if (stat != 0) {
                           rtxMemFreePtr (pctxt, openType.data);
                           break;
                        }

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                        /* Coverity 55342 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType4 (SystemInformationBlockType4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_IntraFreqNeighCellList (&pvalue->intraFreqNeighCellList);
   asn1Init_IntraFreqBlackCellList (&pvalue->intraFreqBlackCellList);
   asn1Init_PhysCellIdRange (&pvalue->csg_PhysCellIdRange);
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_InterFreqNeighCellInfo (OSCTXT* pctxt, InterFreqNeighCellInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterFreqNeighCellInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("InterFreqNeighCellInfo"));

   /* encode physCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PE_PhysCellId (pctxt, pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode q_OffsetCell */

   RTXCTXTPUSHELEMNAME (pctxt, "q-OffsetCell");

   stat = asn1PE_Q_OffsetRange (pctxt, pvalue->q_OffsetCell);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_InterFreqNeighCellInfo (OSCTXT* pctxt, InterFreqNeighCellInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterFreqNeighCellInfo");

   /* decode root elements */
   /* decode physCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PD_PhysCellId (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode q_OffsetCell */
   RTXCTXTPUSHELEMNAME (pctxt, "q-OffsetCell");

   stat = asn1PD_Q_OffsetRange (pctxt, &pvalue->q_OffsetCell);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_InterFreqNeighCellList (OSCTXT* pctxt, InterFreqNeighCellList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "InterFreqNeighCellList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("InterFreqNeighCellList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InterFreqNeighCellInfo", xx1);

      stat = asn1PE_InterFreqNeighCellInfo (pctxt, ((InterFreqNeighCellInfo*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_InterFreqNeighCellList (OSCTXT* pctxt, InterFreqNeighCellList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterFreqNeighCellList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      InterFreqNeighCellInfo* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InterFreqNeighCellInfo", xx1);

      rtxDListAllocNodeAndData (pctxt, InterFreqNeighCellInfo, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_InterFreqNeighCellInfo (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_InterFreqNeighCellList (InterFreqNeighCellList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_InterFreqBlackCellList (OSCTXT* pctxt, InterFreqBlackCellList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "InterFreqBlackCellList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("InterFreqBlackCellList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PhysCellIdRange", xx1);

      stat = asn1PE_PhysCellIdRange (pctxt, ((PhysCellIdRange*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_InterFreqBlackCellList (OSCTXT* pctxt, InterFreqBlackCellList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterFreqBlackCellList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PhysCellIdRange* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PhysCellIdRange", xx1);

      rtxDListAllocNodeAndData (pctxt, PhysCellIdRange, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PhysCellIdRange (pdata);

      stat = asn1PD_PhysCellIdRange (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_InterFreqBlackCellList (InterFreqBlackCellList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_InterFreqCarrierFreqInfo_threshX_Q_r9 (OSCTXT* pctxt, InterFreqCarrierFreqInfo_threshX_Q_r9* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("InterFreqCarrierFreqInfo_threshX_Q_r9"));

   /* encode threshX_HighQ_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "threshX-HighQ-r9");

   stat = asn1PE_ReselectionThresholdQ_r9 (pctxt, pvalue->threshX_HighQ_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode threshX_LowQ_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "threshX-LowQ-r9");

   stat = asn1PE_ReselectionThresholdQ_r9 (pctxt, pvalue->threshX_LowQ_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_InterFreqCarrierFreqInfo_threshX_Q_r9 (OSCTXT* pctxt, InterFreqCarrierFreqInfo_threshX_Q_r9* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode threshX_HighQ_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "threshX-HighQ-r9");

   stat = asn1PD_ReselectionThresholdQ_r9 (pctxt, &pvalue->threshX_HighQ_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshX_LowQ_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "threshX-LowQ-r9");

   stat = asn1PD_ReselectionThresholdQ_r9 (pctxt, &pvalue->threshX_LowQ_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_InterFreqCarrierFreqInfo (OSCTXT* pctxt, InterFreqCarrierFreqInfo* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "InterFreqCarrierFreqInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("InterFreqCarrierFreqInfo"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m._v2ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.p_MaxPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.t_ReselectionEUTRA_SFPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellReselectionPriorityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)(pvalue->q_OffsetFreq != dB0_6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.interFreqNeighCellListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.interFreqBlackCellListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dl_CarrierFreq */

   RTXCTXTPUSHELEMNAME (pctxt, "dl-CarrierFreq");

   stat = asn1PE_ARFCN_ValueEUTRA (pctxt, pvalue->dl_CarrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode q_RxLevMin */

   RTXCTXTPUSHELEMNAME (pctxt, "q-RxLevMin");

   stat = asn1PE_Q_RxLevMin (pctxt, pvalue->q_RxLevMin);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode p_Max */

   if (pvalue->m.p_MaxPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "p-Max");

      stat = asn1PE_P_Max (pctxt, pvalue->p_Max);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode t_ReselectionEUTRA */

   RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionEUTRA");

   stat = asn1PE_T_Reselection (pctxt, pvalue->t_ReselectionEUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t_ReselectionEUTRA_SF */

   if (pvalue->m.t_ReselectionEUTRA_SFPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionEUTRA-SF");

      stat = asn1PE_SpeedStateScaleFactors (pctxt, &pvalue->t_ReselectionEUTRA_SF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode threshX_High */

   RTXCTXTPUSHELEMNAME (pctxt, "threshX-High");

   stat = asn1PE_ReselectionThreshold (pctxt, pvalue->threshX_High);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode threshX_Low */

   RTXCTXTPUSHELEMNAME (pctxt, "threshX-Low");

   stat = asn1PE_ReselectionThreshold (pctxt, pvalue->threshX_Low);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode allowedMeasBandwidth */

   RTXCTXTPUSHELEMNAME (pctxt, "allowedMeasBandwidth");

   stat = asn1PE_AllowedMeasBandwidth (pctxt, pvalue->allowedMeasBandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode presenceAntennaPort1 */

   RTXCTXTPUSHELEMNAME (pctxt, "presenceAntennaPort1");

   stat = asn1PE_PresenceAntennaPort1 (pctxt, pvalue->presenceAntennaPort1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellReselectionPriority */

   if (pvalue->m.cellReselectionPriorityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

      stat = asn1PE_CellReselectionPriority (pctxt, pvalue->cellReselectionPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode neighCellConfig */

   RTXCTXTPUSHELEMNAME (pctxt, "neighCellConfig");

   stat = asn1PE_NeighCellConfig (pctxt, pvalue->neighCellConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode q_OffsetFreq */

   if (pvalue->q_OffsetFreq != dB0_6) {
      RTXCTXTPUSHELEMNAME (pctxt, "q-OffsetFreq");

      stat = asn1PE_Q_OffsetRange (pctxt, pvalue->q_OffsetFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode interFreqNeighCellList */

   if (pvalue->m.interFreqNeighCellListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "interFreqNeighCellList");

      stat = asn1PE_InterFreqNeighCellList (pctxt, &pvalue->interFreqNeighCellList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode interFreqBlackCellList */

   if (pvalue->m.interFreqBlackCellListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "interFreqBlackCellList");

      stat = asn1PE_InterFreqBlackCellList (pctxt, &pvalue->interFreqBlackCellList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v2ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m._v2ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.q_QualMin_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.threshX_Q_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode q_QualMin_r9 */

         if (pvalue->m.q_QualMin_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "q-QualMin-r9");

            stat = asn1PE_Q_QualMin_r9 (pctxt, pvalue->q_QualMin_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         /* encode threshX_Q_r9 */

         if (pvalue->m.threshX_Q_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "threshX-Q-r9");

            stat = asn1PE_InterFreqCarrierFreqInfo_threshX_Q_r9 (pctxt, &pvalue->threshX_Q_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_InterFreqCarrierFreqInfo (OSCTXT* pctxt, InterFreqCarrierFreqInfo* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[6];

   RTXCTXTPUSHTYPENAME (pctxt, "InterFreqCarrierFreqInfo");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_CarrierFreq */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-CarrierFreq");

   stat = asn1PD_ARFCN_ValueEUTRA (pctxt, &pvalue->dl_CarrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode q_RxLevMin */
   RTXCTXTPUSHELEMNAME (pctxt, "q-RxLevMin");

   stat = asn1PD_Q_RxLevMin (pctxt, &pvalue->q_RxLevMin);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode p_Max */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "p-Max");

      pvalue->m.p_MaxPresent = 1;

      stat = asn1PD_P_Max (pctxt, &pvalue->p_Max);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode t_ReselectionEUTRA */
   RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionEUTRA");

   stat = asn1PD_T_Reselection (pctxt, &pvalue->t_ReselectionEUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t_ReselectionEUTRA_SF */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionEUTRA-SF");

      pvalue->m.t_ReselectionEUTRA_SFPresent = 1;

      stat = asn1PD_SpeedStateScaleFactors (pctxt, &pvalue->t_ReselectionEUTRA_SF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode threshX_High */
   RTXCTXTPUSHELEMNAME (pctxt, "threshX-High");

   stat = asn1PD_ReselectionThreshold (pctxt, &pvalue->threshX_High);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshX_Low */
   RTXCTXTPUSHELEMNAME (pctxt, "threshX-Low");

   stat = asn1PD_ReselectionThreshold (pctxt, &pvalue->threshX_Low);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode allowedMeasBandwidth */
   RTXCTXTPUSHELEMNAME (pctxt, "allowedMeasBandwidth");

   stat = asn1PD_AllowedMeasBandwidth (pctxt, &pvalue->allowedMeasBandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode presenceAntennaPort1 */
   RTXCTXTPUSHELEMNAME (pctxt, "presenceAntennaPort1");

   stat = asn1PD_PresenceAntennaPort1 (pctxt, &pvalue->presenceAntennaPort1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellReselectionPriority */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

      pvalue->m.cellReselectionPriorityPresent = 1;

      stat = asn1PD_CellReselectionPriority (pctxt, &pvalue->cellReselectionPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode neighCellConfig */
   RTXCTXTPUSHELEMNAME (pctxt, "neighCellConfig");

   stat = asn1PD_NeighCellConfig (pctxt, &pvalue->neighCellConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode q_OffsetFreq */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "q-OffsetFreq");

      stat = asn1PD_Q_OffsetRange (pctxt, &pvalue->q_OffsetFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->q_OffsetFreq = dB0_6;
   }

   /* decode interFreqNeighCellList */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "interFreqNeighCellList");

      pvalue->m.interFreqNeighCellListPresent = 1;

      stat = asn1PD_InterFreqNeighCellList (pctxt, &pvalue->interFreqNeighCellList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode interFreqBlackCellList */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "interFreqBlackCellList");

      pvalue->m.interFreqBlackCellListPresent = 1;

      stat = asn1PD_InterFreqBlackCellList (pctxt, &pvalue->interFreqBlackCellList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m._v2ExtPresent = 1;
                        {
                           OSOCTET extoptbits[2];
                           OSUINT32 _i;

                           for (_i = 0; _i < 2; _i++) {
                              stat = DEC_BIT (pctxt, &extoptbits[_i]);
                              if (stat != 0)  {
                                 rtxMemFreePtr (pctxt, poptbits);
                                 return LOG_RTERR (pctxt, stat);
                              }
                           }
                           if (extoptbits[0]) {
                              pvalue->m.q_QualMin_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "q-QualMin-r9");

                              stat = asn1PD_Q_QualMin_r9 (pctxt, &pvalue->q_QualMin_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                           if (extoptbits[1]) {
                              pvalue->m.threshX_Q_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "threshX-Q-r9");

                              stat = asn1PD_InterFreqCarrierFreqInfo_threshX_Q_r9 (pctxt, &pvalue->threshX_Q_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;

                        /* Coverity 55343 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_InterFreqCarrierFreqInfo (InterFreqCarrierFreqInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_NeighCellConfig (&pvalue->neighCellConfig);
   pvalue->q_OffsetFreq = dB0_6;
   asn1Init_InterFreqNeighCellList (&pvalue->interFreqNeighCellList);
   asn1Init_InterFreqBlackCellList (&pvalue->interFreqBlackCellList);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_InterFreqCarrierFreqList (OSCTXT* pctxt, InterFreqCarrierFreqList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "InterFreqCarrierFreqList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("InterFreqCarrierFreqList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InterFreqCarrierFreqInfo", xx1);

      stat = asn1PE_InterFreqCarrierFreqInfo (pctxt, ((InterFreqCarrierFreqInfo*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_InterFreqCarrierFreqList (OSCTXT* pctxt, InterFreqCarrierFreqList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterFreqCarrierFreqList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      InterFreqCarrierFreqInfo* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InterFreqCarrierFreqInfo", xx1);

      rtxDListAllocNodeAndData (pctxt, InterFreqCarrierFreqInfo, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_InterFreqCarrierFreqInfo (pdata);

      stat = asn1PD_InterFreqCarrierFreqInfo (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_InterFreqCarrierFreqList (InterFreqCarrierFreqList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_SystemInformationBlockType5 (OSCTXT* pctxt, SystemInformationBlockType5* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType5");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType5"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m.lateNonCriticalExtensionPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode interFreqCarrierFreqList */

   RTXCTXTPUSHELEMNAME (pctxt, "interFreqCarrierFreqList");

   stat = asn1PE_InterFreqCarrierFreqList (pctxt, &pvalue->interFreqCarrierFreqList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m.lateNonCriticalExtensionPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType5 (OSCTXT* pctxt, SystemInformationBlockType5* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType5");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode interFreqCarrierFreqList */
   RTXCTXTPUSHELEMNAME (pctxt, "interFreqCarrierFreqList");

   stat = asn1PD_InterFreqCarrierFreqList (pctxt, &pvalue->interFreqCarrierFreqList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.lateNonCriticalExtensionPresent = 1;
                        RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

                        stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
                        if (stat != 0) {
                           rtxMemFreePtr (pctxt, openType.data);
                           break;
                        }

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                        /* Coverity 55344 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType5 (SystemInformationBlockType5* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_InterFreqCarrierFreqList (&pvalue->interFreqCarrierFreqList);
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_CarrierFreqUTRA_FDD_threshX_Q_r9 (OSCTXT* pctxt, CarrierFreqUTRA_FDD_threshX_Q_r9* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqUTRA_FDD_threshX_Q_r9"));

   /* encode threshX_HighQ_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "threshX-HighQ-r9");

   stat = asn1PE_ReselectionThresholdQ_r9 (pctxt, pvalue->threshX_HighQ_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode threshX_LowQ_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "threshX-LowQ-r9");

   stat = asn1PE_ReselectionThresholdQ_r9 (pctxt, pvalue->threshX_LowQ_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqUTRA_FDD_threshX_Q_r9 (OSCTXT* pctxt, CarrierFreqUTRA_FDD_threshX_Q_r9* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode threshX_HighQ_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "threshX-HighQ-r9");

   stat = asn1PD_ReselectionThresholdQ_r9 (pctxt, &pvalue->threshX_HighQ_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshX_LowQ_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "threshX-LowQ-r9");

   stat = asn1PD_ReselectionThresholdQ_r9 (pctxt, &pvalue->threshX_LowQ_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_CarrierFreqUTRA_FDD (OSCTXT* pctxt, CarrierFreqUTRA_FDD* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqUTRA-FDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqUTRA_FDD"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m._v2ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellReselectionPriorityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode carrierFreq */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PE_ARFCN_ValueUTRA (pctxt, pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellReselectionPriority */

   if (pvalue->m.cellReselectionPriorityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

      stat = asn1PE_CellReselectionPriority (pctxt, pvalue->cellReselectionPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode threshX_High */

   RTXCTXTPUSHELEMNAME (pctxt, "threshX-High");

   stat = asn1PE_ReselectionThreshold (pctxt, pvalue->threshX_High);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode threshX_Low */

   RTXCTXTPUSHELEMNAME (pctxt, "threshX-Low");

   stat = asn1PE_ReselectionThreshold (pctxt, pvalue->threshX_Low);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode q_RxLevMin */

   RTXCTXTPUSHELEMNAME (pctxt, "q-RxLevMin");

   if ( (pvalue->q_RxLevMin >= OSINTCONST(-60) && pvalue->q_RxLevMin
       <= OSINTCONST(-13)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->q_RxLevMin, OSINTCONST(-60), OSINTCONST(-13));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->q_RxLevMin);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode p_MaxUTRA */

   RTXCTXTPUSHELEMNAME (pctxt, "p-MaxUTRA");

   if ( (pvalue->p_MaxUTRA >= OSINTCONST(-50) && pvalue->p_MaxUTRA <= OSINTCONST(33)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->p_MaxUTRA, OSINTCONST(-50), OSINTCONST(33));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->p_MaxUTRA);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode q_QualMin */

   RTXCTXTPUSHELEMNAME (pctxt, "q-QualMin");

   if ( (pvalue->q_QualMin >= OSINTCONST(-24) && pvalue->q_QualMin <= OSINTCONST(0)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->q_QualMin, OSINTCONST(-24), OSINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->q_QualMin);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v2ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m._v2ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.threshX_Q_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode threshX_Q_r9 */

         if (pvalue->m.threshX_Q_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "threshX-Q-r9");

            stat = asn1PE_CarrierFreqUTRA_FDD_threshX_Q_r9 (pctxt, &pvalue->threshX_Q_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqUTRA_FDD (OSCTXT* pctxt, CarrierFreqUTRA_FDD* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqUTRA-FDD");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode carrierFreq */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PD_ARFCN_ValueUTRA (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellReselectionPriority */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

      pvalue->m.cellReselectionPriorityPresent = 1;

      stat = asn1PD_CellReselectionPriority (pctxt, &pvalue->cellReselectionPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode threshX_High */
   RTXCTXTPUSHELEMNAME (pctxt, "threshX-High");

   stat = asn1PD_ReselectionThreshold (pctxt, &pvalue->threshX_High);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshX_Low */
   RTXCTXTPUSHELEMNAME (pctxt, "threshX-Low");

   stat = asn1PD_ReselectionThreshold (pctxt, &pvalue->threshX_Low);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode q_RxLevMin */
   RTXCTXTPUSHELEMNAME (pctxt, "q-RxLevMin");

   stat = pd_ConsInt8 (pctxt, &pvalue->q_RxLevMin, OSINTCONST(-60), OSINTCONST(-13));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode p_MaxUTRA */
   RTXCTXTPUSHELEMNAME (pctxt, "p-MaxUTRA");

   stat = pd_ConsInt8 (pctxt, &pvalue->p_MaxUTRA, OSINTCONST(-50), OSINTCONST(33));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode q_QualMin */
   RTXCTXTPUSHELEMNAME (pctxt, "q-QualMin");

   stat = pd_ConsInt8 (pctxt, &pvalue->q_QualMin, OSINTCONST(-24), OSINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m._v2ExtPresent = 1;
                        {
                           OSOCTET extoptbits[1];

                           stat = DEC_BIT (pctxt, &extoptbits[0]);
                           if (stat != 0)  {
                              rtxMemFreePtr (pctxt, poptbits);
                           }
                           if (extoptbits[0]) {
                              pvalue->m.threshX_Q_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "threshX-Q-r9");

                              stat = asn1PD_CarrierFreqUTRA_FDD_threshX_Q_r9 (pctxt, &pvalue->threshX_Q_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;

                        /* Coverity 55345 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CarrierFreqUTRA_FDD (CarrierFreqUTRA_FDD* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_CarrierFreqListUTRA_FDD (OSCTXT* pctxt, CarrierFreqListUTRA_FDD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqListUTRA-FDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqListUTRA_FDD"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CarrierFreqUTRA-FDD", xx1);

      stat = asn1PE_CarrierFreqUTRA_FDD (pctxt, ((CarrierFreqUTRA_FDD*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqListUTRA_FDD (OSCTXT* pctxt, CarrierFreqListUTRA_FDD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqListUTRA-FDD");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CarrierFreqUTRA_FDD* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CarrierFreqUTRA-FDD", xx1);

      rtxDListAllocNodeAndData (pctxt, CarrierFreqUTRA_FDD, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CarrierFreqUTRA_FDD (pdata);

      stat = asn1PD_CarrierFreqUTRA_FDD (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CarrierFreqListUTRA_FDD (CarrierFreqListUTRA_FDD* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_CarrierFreqUTRA_TDD (OSCTXT* pctxt, CarrierFreqUTRA_TDD* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqUTRA-TDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqUTRA_TDD"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellReselectionPriorityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode carrierFreq */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PE_ARFCN_ValueUTRA (pctxt, pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellReselectionPriority */

   if (pvalue->m.cellReselectionPriorityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

      stat = asn1PE_CellReselectionPriority (pctxt, pvalue->cellReselectionPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode threshX_High */

   RTXCTXTPUSHELEMNAME (pctxt, "threshX-High");

   stat = asn1PE_ReselectionThreshold (pctxt, pvalue->threshX_High);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode threshX_Low */

   RTXCTXTPUSHELEMNAME (pctxt, "threshX-Low");

   stat = asn1PE_ReselectionThreshold (pctxt, pvalue->threshX_Low);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode q_RxLevMin */

   RTXCTXTPUSHELEMNAME (pctxt, "q-RxLevMin");

   if ( (pvalue->q_RxLevMin >= OSINTCONST(-60) && pvalue->q_RxLevMin
       <= OSINTCONST(-13)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->q_RxLevMin, OSINTCONST(-60), OSINTCONST(-13));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->q_RxLevMin);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode p_MaxUTRA */

   RTXCTXTPUSHELEMNAME (pctxt, "p-MaxUTRA");

   if ( (pvalue->p_MaxUTRA >= OSINTCONST(-50) && pvalue->p_MaxUTRA <= OSINTCONST(33)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->p_MaxUTRA, OSINTCONST(-50), OSINTCONST(33));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->p_MaxUTRA);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqUTRA_TDD (OSCTXT* pctxt, CarrierFreqUTRA_TDD* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqUTRA-TDD");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode carrierFreq */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PD_ARFCN_ValueUTRA (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellReselectionPriority */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

      pvalue->m.cellReselectionPriorityPresent = 1;

      stat = asn1PD_CellReselectionPriority (pctxt, &pvalue->cellReselectionPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode threshX_High */
   RTXCTXTPUSHELEMNAME (pctxt, "threshX-High");

   stat = asn1PD_ReselectionThreshold (pctxt, &pvalue->threshX_High);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshX_Low */
   RTXCTXTPUSHELEMNAME (pctxt, "threshX-Low");

   stat = asn1PD_ReselectionThreshold (pctxt, &pvalue->threshX_Low);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode q_RxLevMin */
   RTXCTXTPUSHELEMNAME (pctxt, "q-RxLevMin");

   stat = pd_ConsInt8 (pctxt, &pvalue->q_RxLevMin, OSINTCONST(-60), OSINTCONST(-13));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode p_MaxUTRA */
   RTXCTXTPUSHELEMNAME (pctxt, "p-MaxUTRA");

   stat = pd_ConsInt8 (pctxt, &pvalue->p_MaxUTRA, OSINTCONST(-50), OSINTCONST(33));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CarrierFreqUTRA_TDD (CarrierFreqUTRA_TDD* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_CarrierFreqListUTRA_TDD (OSCTXT* pctxt, CarrierFreqListUTRA_TDD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqListUTRA-TDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqListUTRA_TDD"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CarrierFreqUTRA-TDD", xx1);

      stat = asn1PE_CarrierFreqUTRA_TDD (pctxt, ((CarrierFreqUTRA_TDD*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqListUTRA_TDD (OSCTXT* pctxt, CarrierFreqListUTRA_TDD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqListUTRA-TDD");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CarrierFreqUTRA_TDD* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CarrierFreqUTRA-TDD", xx1);

      rtxDListAllocNodeAndData (pctxt, CarrierFreqUTRA_TDD, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CarrierFreqUTRA_TDD (pdata);

      stat = asn1PD_CarrierFreqUTRA_TDD (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CarrierFreqListUTRA_TDD (CarrierFreqListUTRA_TDD* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_SystemInformationBlockType6 (OSCTXT* pctxt, SystemInformationBlockType6* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType6");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType6"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m.lateNonCriticalExtensionPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.carrierFreqListUTRA_FDDPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.carrierFreqListUTRA_TDDPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.t_ReselectionUTRA_SFPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode carrierFreqListUTRA_FDD */

   if (pvalue->m.carrierFreqListUTRA_FDDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "carrierFreqListUTRA-FDD");

      stat = asn1PE_CarrierFreqListUTRA_FDD (pctxt, &pvalue->carrierFreqListUTRA_FDD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode carrierFreqListUTRA_TDD */

   if (pvalue->m.carrierFreqListUTRA_TDDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "carrierFreqListUTRA-TDD");

      stat = asn1PE_CarrierFreqListUTRA_TDD (pctxt, &pvalue->carrierFreqListUTRA_TDD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode t_ReselectionUTRA */

   RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionUTRA");

   stat = asn1PE_T_Reselection (pctxt, pvalue->t_ReselectionUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t_ReselectionUTRA_SF */

   if (pvalue->m.t_ReselectionUTRA_SFPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionUTRA-SF");

      stat = asn1PE_SpeedStateScaleFactors (pctxt, &pvalue->t_ReselectionUTRA_SF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m.lateNonCriticalExtensionPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType6 (OSCTXT* pctxt, SystemInformationBlockType6* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType6");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode carrierFreqListUTRA_FDD */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "carrierFreqListUTRA-FDD");

      pvalue->m.carrierFreqListUTRA_FDDPresent = 1;

      stat = asn1PD_CarrierFreqListUTRA_FDD (pctxt, &pvalue->carrierFreqListUTRA_FDD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode carrierFreqListUTRA_TDD */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "carrierFreqListUTRA-TDD");

      pvalue->m.carrierFreqListUTRA_TDDPresent = 1;

      stat = asn1PD_CarrierFreqListUTRA_TDD (pctxt, &pvalue->carrierFreqListUTRA_TDD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode t_ReselectionUTRA */
   RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionUTRA");

   stat = asn1PD_T_Reselection (pctxt, &pvalue->t_ReselectionUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t_ReselectionUTRA_SF */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionUTRA-SF");

      pvalue->m.t_ReselectionUTRA_SFPresent = 1;

      stat = asn1PD_SpeedStateScaleFactors (pctxt, &pvalue->t_ReselectionUTRA_SF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.lateNonCriticalExtensionPresent = 1;
                        RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

                        stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
                        if (stat != 0) {
                           rtxMemFreePtr (pctxt, openType.data);
                           break;
                        }

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                        /* Coverity 55346 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType6 (SystemInformationBlockType6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CarrierFreqListUTRA_FDD (&pvalue->carrierFreqListUTRA_FDD);
   asn1Init_CarrierFreqListUTRA_TDD (&pvalue->carrierFreqListUTRA_TDD);
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_ExplicitListOfARFCNs (OSCTXT* pctxt, ExplicitListOfARFCNs* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "ExplicitListOfARFCNs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ExplicitListOfARFCNs"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(31), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ARFCN-ValueGERAN", xx1);

      stat = asn1PE_ARFCN_ValueGERAN (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ExplicitListOfARFCNs (OSCTXT* pctxt, ExplicitListOfARFCNs* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ExplicitListOfARFCNs");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 5);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   if (pvalue->n > 31) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ARFCN-ValueGERAN", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (ARFCN_ValueGERAN));
      stat = asn1PD_ARFCN_ValueGERAN (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ExplicitListOfARFCNs (ExplicitListOfARFCNs* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs (OSCTXT* pctxt, CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs"));

   /* encode arfcn_Spacing */

   RTXCTXTPUSHELEMNAME (pctxt, "arfcn-Spacing");

   if ( (pvalue->arfcn_Spacing >= OSUINTCONST(1) && pvalue->arfcn_Spacing
       <= OSUINTCONST(8)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->arfcn_Spacing, OSUINTCONST(1), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->arfcn_Spacing);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode numberOfFollowingARFCNs */

   RTXCTXTPUSHELEMNAME (pctxt, "numberOfFollowingARFCNs");

   if ( (pvalue->numberOfFollowingARFCNs <= OSUINTCONST(31)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->numberOfFollowingARFCNs, OSUINTCONST(0), OSUINTCONST(31));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->numberOfFollowingARFCNs);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs (OSCTXT* pctxt, CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode arfcn_Spacing */
   RTXCTXTPUSHELEMNAME (pctxt, "arfcn-Spacing");

   stat = pd_ConsUInt8 (pctxt, &pvalue->arfcn_Spacing, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfFollowingARFCNs */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfFollowingARFCNs");

   stat = pd_ConsUInt8 (pctxt, &pvalue->numberOfFollowingARFCNs, OSUINTCONST(0), OSUINTCONST(31));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_CarrierFreqsGERAN_followingARFCNs (OSCTXT* pctxt, CarrierFreqsGERAN_followingARFCNs* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqsGERAN_followingARFCNs"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* explicitListOfARFCNs */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "explicitListOfARFCNs");

         stat = asn1PE_ExplicitListOfARFCNs (pctxt, pvalue->u.explicitListOfARFCNs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* equallySpacedARFCNs */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "equallySpacedARFCNs");

         stat = asn1PE_CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs (pctxt, pvalue->u.equallySpacedARFCNs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* variableBitMapOfARFCNs */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "variableBitMapOfARFCNs");

         stat = asn1PE_CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs (pctxt, pvalue->u.variableBitMapOfARFCNs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqsGERAN_followingARFCNs (OSCTXT* pctxt, CarrierFreqsGERAN_followingARFCNs* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* explicitListOfARFCNs */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "explicitListOfARFCNs");

         pvalue->u.explicitListOfARFCNs = rtxMemAllocType (pctxt, 
            ExplicitListOfARFCNs);

         if (pvalue->u.explicitListOfARFCNs == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ExplicitListOfARFCNs (pvalue->u.explicitListOfARFCNs);

         stat = asn1PD_ExplicitListOfARFCNs (pctxt, pvalue->u.explicitListOfARFCNs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* equallySpacedARFCNs */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "equallySpacedARFCNs");

         pvalue->u.equallySpacedARFCNs = rtxMemAllocTypeZ (pctxt, 
            CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs);

         if (pvalue->u.equallySpacedARFCNs == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs (pctxt, pvalue->u.equallySpacedARFCNs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* variableBitMapOfARFCNs */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "variableBitMapOfARFCNs");

         pvalue->u.variableBitMapOfARFCNs = rtxMemAllocType (pctxt, 
            CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs);

         if (pvalue->u.variableBitMapOfARFCNs == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs (pvalue->u.variableBitMapOfARFCNs);

         stat = asn1PD_CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs (pctxt, pvalue->u.variableBitMapOfARFCNs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_CarrierFreqsGERAN_followingARFCNs (
   CarrierFreqsGERAN_followingARFCNs* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_CarrierFreqsGERAN (OSCTXT* pctxt, CarrierFreqsGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqsGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqsGERAN"));

   /* encode startingARFCN */

   RTXCTXTPUSHELEMNAME (pctxt, "startingARFCN");

   stat = asn1PE_ARFCN_ValueGERAN (pctxt, pvalue->startingARFCN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode bandIndicator */

   RTXCTXTPUSHELEMNAME (pctxt, "bandIndicator");

   stat = asn1PE_BandIndicatorGERAN (pctxt, pvalue->bandIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode followingARFCNs */

   RTXCTXTPUSHELEMNAME (pctxt, "followingARFCNs");

   stat = asn1PE_CarrierFreqsGERAN_followingARFCNs (pctxt, &pvalue->followingARFCNs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqsGERAN (OSCTXT* pctxt, CarrierFreqsGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqsGERAN");

   /* decode root elements */
   /* decode startingARFCN */
   RTXCTXTPUSHELEMNAME (pctxt, "startingARFCN");

   stat = asn1PD_ARFCN_ValueGERAN (pctxt, &pvalue->startingARFCN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode bandIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "bandIndicator");

   stat = asn1PD_BandIndicatorGERAN (pctxt, &pvalue->bandIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode followingARFCNs */
   RTXCTXTPUSHELEMNAME (pctxt, "followingARFCNs");

   stat = asn1PD_CarrierFreqsGERAN_followingARFCNs (pctxt, &pvalue->followingARFCNs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CarrierFreqsGERAN (CarrierFreqsGERAN* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_CarrierFreqsGERAN_followingARFCNs (&pvalue->followingARFCNs);
}

EXTERN int asn1PE_CarrierFreqsInfoGERAN_commonInfo (OSCTXT* pctxt, CarrierFreqsInfoGERAN_commonInfo* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqsInfoGERAN_commonInfo"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellReselectionPriorityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.p_MaxGERANPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cellReselectionPriority */

   if (pvalue->m.cellReselectionPriorityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

      stat = asn1PE_CellReselectionPriority (pctxt, pvalue->cellReselectionPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode ncc_Permitted */

   RTXCTXTPUSHELEMNAME (pctxt, "ncc-Permitted");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->ncc_Permitted, OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode q_RxLevMin */

   RTXCTXTPUSHELEMNAME (pctxt, "q-RxLevMin");

   if ( (pvalue->q_RxLevMin <= OSUINTCONST(45)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->q_RxLevMin, OSUINTCONST(0), OSUINTCONST(45));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->q_RxLevMin);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode p_MaxGERAN */

   if (pvalue->m.p_MaxGERANPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "p-MaxGERAN");

      if ( (pvalue->p_MaxGERAN <= OSUINTCONST(39)) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->p_MaxGERAN, OSUINTCONST(0), OSUINTCONST(39));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->p_MaxGERAN);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode threshX_High */

   RTXCTXTPUSHELEMNAME (pctxt, "threshX-High");

   stat = asn1PE_ReselectionThreshold (pctxt, pvalue->threshX_High);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode threshX_Low */

   RTXCTXTPUSHELEMNAME (pctxt, "threshX-Low");

   stat = asn1PE_ReselectionThreshold (pctxt, pvalue->threshX_Low);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqsInfoGERAN_commonInfo (OSCTXT* pctxt, CarrierFreqsInfoGERAN_commonInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cellReselectionPriority */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

      pvalue->m.cellReselectionPriorityPresent = 1;

      stat = asn1PD_CellReselectionPriority (pctxt, &pvalue->cellReselectionPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ncc_Permitted */
   RTXCTXTPUSHELEMNAME (pctxt, "ncc-Permitted");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->ncc_Permitted
      , OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode q_RxLevMin */
   RTXCTXTPUSHELEMNAME (pctxt, "q-RxLevMin");

   stat = pd_ConsUInt8 (pctxt, &pvalue->q_RxLevMin, OSUINTCONST(0), OSUINTCONST(45));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode p_MaxGERAN */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "p-MaxGERAN");

      pvalue->m.p_MaxGERANPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->p_MaxGERAN, OSUINTCONST(0), OSUINTCONST(39));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode threshX_High */
   RTXCTXTPUSHELEMNAME (pctxt, "threshX-High");

   stat = asn1PD_ReselectionThreshold (pctxt, &pvalue->threshX_High);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshX_Low */
   RTXCTXTPUSHELEMNAME (pctxt, "threshX-Low");

   stat = asn1PD_ReselectionThreshold (pctxt, &pvalue->threshX_Low);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_CarrierFreqsInfoGERAN_commonInfo (
   CarrierFreqsInfoGERAN_commonInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->ncc_Permitted.numbits = 0;
}

EXTERN int asn1PE_CarrierFreqsInfoGERAN (OSCTXT* pctxt, CarrierFreqsInfoGERAN* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqsInfoGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqsInfoGERAN"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode carrierFreqs */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreqs");

   stat = asn1PE_CarrierFreqsGERAN (pctxt, &pvalue->carrierFreqs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode commonInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "commonInfo");

   stat = asn1PE_CarrierFreqsInfoGERAN_commonInfo (pctxt, &pvalue->commonInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqsInfoGERAN (OSCTXT* pctxt, CarrierFreqsInfoGERAN* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqsInfoGERAN");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode carrierFreqs */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreqs");

   stat = asn1PD_CarrierFreqsGERAN (pctxt, &pvalue->carrierFreqs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode commonInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "commonInfo");

   stat = asn1PD_CarrierFreqsInfoGERAN_commonInfo (pctxt, &pvalue->commonInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CarrierFreqsInfoGERAN (CarrierFreqsInfoGERAN* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_CarrierFreqsGERAN (&pvalue->carrierFreqs);
   asn1Init_CarrierFreqsInfoGERAN_commonInfo (&pvalue->commonInfo);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_CarrierFreqsInfoListGERAN (OSCTXT* pctxt, CarrierFreqsInfoListGERAN* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqsInfoListGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqsInfoListGERAN"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CarrierFreqsInfoGERAN", xx1);

      stat = asn1PE_CarrierFreqsInfoGERAN (pctxt, ((CarrierFreqsInfoGERAN*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqsInfoListGERAN (OSCTXT* pctxt, CarrierFreqsInfoListGERAN* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqsInfoListGERAN");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CarrierFreqsInfoGERAN* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CarrierFreqsInfoGERAN", xx1);

      rtxDListAllocNodeAndData (pctxt, CarrierFreqsInfoGERAN, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CarrierFreqsInfoGERAN (pdata);

      stat = asn1PD_CarrierFreqsInfoGERAN (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CarrierFreqsInfoListGERAN (CarrierFreqsInfoListGERAN* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_SystemInformationBlockType7 (OSCTXT* pctxt, SystemInformationBlockType7* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType7");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType7"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m.lateNonCriticalExtensionPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.t_ReselectionGERAN_SFPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.carrierFreqsInfoListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode t_ReselectionGERAN */

   RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionGERAN");

   stat = asn1PE_T_Reselection (pctxt, pvalue->t_ReselectionGERAN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t_ReselectionGERAN_SF */

   if (pvalue->m.t_ReselectionGERAN_SFPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionGERAN-SF");

      stat = asn1PE_SpeedStateScaleFactors (pctxt, &pvalue->t_ReselectionGERAN_SF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode carrierFreqsInfoList */

   if (pvalue->m.carrierFreqsInfoListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "carrierFreqsInfoList");

      stat = asn1PE_CarrierFreqsInfoListGERAN (pctxt, &pvalue->carrierFreqsInfoList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m.lateNonCriticalExtensionPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType7 (OSCTXT* pctxt, SystemInformationBlockType7* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType7");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode t_ReselectionGERAN */
   RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionGERAN");

   stat = asn1PD_T_Reselection (pctxt, &pvalue->t_ReselectionGERAN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t_ReselectionGERAN_SF */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionGERAN-SF");

      pvalue->m.t_ReselectionGERAN_SFPresent = 1;

      stat = asn1PD_SpeedStateScaleFactors (pctxt, &pvalue->t_ReselectionGERAN_SF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode carrierFreqsInfoList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "carrierFreqsInfoList");

      pvalue->m.carrierFreqsInfoListPresent = 1;

      stat = asn1PD_CarrierFreqsInfoListGERAN (pctxt, &pvalue->carrierFreqsInfoList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.lateNonCriticalExtensionPresent = 1;
                        RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

                        stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
                        if (stat != 0) {
                           rtxMemFreePtr (pctxt, openType.data);
                           break;
                        }

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                        /* Coverity 55347 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType7 (SystemInformationBlockType7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CarrierFreqsInfoListGERAN (&pvalue->carrierFreqsInfoList);
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_SystemTimeInfoCDMA2000_cdma_SystemTime (OSCTXT* pctxt, SystemTimeInfoCDMA2000_cdma_SystemTime* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemTimeInfoCDMA2000_cdma_SystemTime"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* synchronousSystemTime */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "synchronousSystemTime");

         stat = asn1PE_SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime (pctxt, pvalue->u.synchronousSystemTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* asynchronousSystemTime */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "asynchronousSystemTime");

         stat = asn1PE_SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime (pctxt, pvalue->u.asynchronousSystemTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemTimeInfoCDMA2000_cdma_SystemTime (OSCTXT* pctxt, SystemTimeInfoCDMA2000_cdma_SystemTime* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* synchronousSystemTime */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "synchronousSystemTime");

         pvalue->u.synchronousSystemTime = rtxMemAllocType (pctxt, 
            SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime);

         if (pvalue->u.synchronousSystemTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime (pvalue->u.synchronousSystemTime);

         stat = asn1PD_SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime (pctxt, pvalue->u.synchronousSystemTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* asynchronousSystemTime */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "asynchronousSystemTime");

         pvalue->u.asynchronousSystemTime = rtxMemAllocType (pctxt, 
            SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime);

         if (pvalue->u.asynchronousSystemTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime (pvalue->u.asynchronousSystemTime);

         stat = asn1PD_SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime (pctxt, pvalue->u.asynchronousSystemTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_SystemTimeInfoCDMA2000_cdma_SystemTime (
   SystemTimeInfoCDMA2000_cdma_SystemTime* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_SystemTimeInfoCDMA2000 (OSCTXT* pctxt, SystemTimeInfoCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemTimeInfoCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemTimeInfoCDMA2000"));

   /* encode cdma_EUTRA_Synchronisation */

   RTXCTXTPUSHELEMNAME (pctxt, "cdma-EUTRA-Synchronisation");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->cdma_EUTRA_Synchronisation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cdma_SystemTime */

   RTXCTXTPUSHELEMNAME (pctxt, "cdma-SystemTime");

   stat = asn1PE_SystemTimeInfoCDMA2000_cdma_SystemTime (pctxt, &pvalue->cdma_SystemTime);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemTimeInfoCDMA2000 (OSCTXT* pctxt, SystemTimeInfoCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemTimeInfoCDMA2000");

   /* decode root elements */
   /* decode cdma_EUTRA_Synchronisation */
   RTXCTXTPUSHELEMNAME (pctxt, "cdma-EUTRA-Synchronisation");

   stat = DEC_BIT (pctxt, &pvalue->cdma_EUTRA_Synchronisation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cdma_SystemTime */
   RTXCTXTPUSHELEMNAME (pctxt, "cdma-SystemTime");

   stat = asn1PD_SystemTimeInfoCDMA2000_cdma_SystemTime (pctxt, &pvalue->cdma_SystemTime);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemTimeInfoCDMA2000 (SystemTimeInfoCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SystemTimeInfoCDMA2000_cdma_SystemTime (&pvalue->cdma_SystemTime);
}

EXTERN int asn1PE_SecondaryPreRegistrationZoneIdListHRPD (OSCTXT* pctxt, SecondaryPreRegistrationZoneIdListHRPD* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SecondaryPreRegistrationZoneIdListHRPD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecondaryPreRegistrationZoneIdListHRPD"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PreRegistrationZoneIdHRPD", xx1);

      stat = asn1PE_PreRegistrationZoneIdHRPD (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecondaryPreRegistrationZoneIdListHRPD (OSCTXT* pctxt, SecondaryPreRegistrationZoneIdListHRPD* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecondaryPreRegistrationZoneIdListHRPD");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 2) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PreRegistrationZoneIdHRPD", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (PreRegistrationZoneIdHRPD));
      stat = asn1PD_PreRegistrationZoneIdHRPD (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SecondaryPreRegistrationZoneIdListHRPD (
   SecondaryPreRegistrationZoneIdListHRPD* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_PreRegistrationInfoHRPD (OSCTXT* pctxt, PreRegistrationInfoHRPD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PreRegistrationInfoHRPD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PreRegistrationInfoHRPD"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.preRegistrationZoneIdPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.secondaryPreRegistrationZoneIdListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode preRegistrationAllowed */

   RTXCTXTPUSHELEMNAME (pctxt, "preRegistrationAllowed");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->preRegistrationAllowed);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode preRegistrationZoneId */

   if (pvalue->m.preRegistrationZoneIdPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "preRegistrationZoneId");

      stat = asn1PE_PreRegistrationZoneIdHRPD (pctxt, pvalue->preRegistrationZoneId);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode secondaryPreRegistrationZoneIdList */

   if (pvalue->m.secondaryPreRegistrationZoneIdListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "secondaryPreRegistrationZoneIdList");

      stat = asn1PE_SecondaryPreRegistrationZoneIdListHRPD (pctxt, &pvalue->secondaryPreRegistrationZoneIdList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PreRegistrationInfoHRPD (OSCTXT* pctxt, PreRegistrationInfoHRPD* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "PreRegistrationInfoHRPD");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode preRegistrationAllowed */
   RTXCTXTPUSHELEMNAME (pctxt, "preRegistrationAllowed");

   stat = DEC_BIT (pctxt, &pvalue->preRegistrationAllowed);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode preRegistrationZoneId */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "preRegistrationZoneId");

      pvalue->m.preRegistrationZoneIdPresent = 1;

      stat = asn1PD_PreRegistrationZoneIdHRPD (pctxt, &pvalue->preRegistrationZoneId);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode secondaryPreRegistrationZoneIdList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "secondaryPreRegistrationZoneIdList");

      pvalue->m.secondaryPreRegistrationZoneIdListPresent = 1;

      stat = asn1PD_SecondaryPreRegistrationZoneIdListHRPD (pctxt, &pvalue->secondaryPreRegistrationZoneIdList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PreRegistrationInfoHRPD (PreRegistrationInfoHRPD* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SecondaryPreRegistrationZoneIdListHRPD (&pvalue->secondaryPreRegistrationZoneIdList);
}

EXTERN int asn1PE_BandClassInfoCDMA2000 (OSCTXT* pctxt, BandClassInfoCDMA2000* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "BandClassInfoCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BandClassInfoCDMA2000"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellReselectionPriorityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bandClass */

   RTXCTXTPUSHELEMNAME (pctxt, "bandClass");

   stat = asn1PE_BandclassCDMA2000 (pctxt, pvalue->bandClass);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellReselectionPriority */

   if (pvalue->m.cellReselectionPriorityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

      stat = asn1PE_CellReselectionPriority (pctxt, pvalue->cellReselectionPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode threshX_High */

   RTXCTXTPUSHELEMNAME (pctxt, "threshX-High");

   if ( (pvalue->threshX_High <= OSUINTCONST(63)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->threshX_High, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->threshX_High);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode threshX_Low */

   RTXCTXTPUSHELEMNAME (pctxt, "threshX-Low");

   if ( (pvalue->threshX_Low <= OSUINTCONST(63)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->threshX_Low, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->threshX_Low);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BandClassInfoCDMA2000 (OSCTXT* pctxt, BandClassInfoCDMA2000* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "BandClassInfoCDMA2000");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode bandClass */
   RTXCTXTPUSHELEMNAME (pctxt, "bandClass");

   stat = asn1PD_BandclassCDMA2000 (pctxt, &pvalue->bandClass);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellReselectionPriority */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

      pvalue->m.cellReselectionPriorityPresent = 1;

      stat = asn1PD_CellReselectionPriority (pctxt, &pvalue->cellReselectionPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode threshX_High */
   RTXCTXTPUSHELEMNAME (pctxt, "threshX-High");

   stat = pd_ConsUInt8 (pctxt, &pvalue->threshX_High, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshX_Low */
   RTXCTXTPUSHELEMNAME (pctxt, "threshX-Low");

   stat = pd_ConsUInt8 (pctxt, &pvalue->threshX_Low, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_BandClassInfoCDMA2000 (BandClassInfoCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_BandClassListCDMA2000 (OSCTXT* pctxt, BandClassListCDMA2000* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "BandClassListCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BandClassListCDMA2000"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BandClassInfoCDMA2000", xx1);

      stat = asn1PE_BandClassInfoCDMA2000 (pctxt, ((BandClassInfoCDMA2000*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BandClassListCDMA2000 (OSCTXT* pctxt, BandClassListCDMA2000* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BandClassListCDMA2000");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      BandClassInfoCDMA2000* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BandClassInfoCDMA2000", xx1);

      rtxDListAllocNodeAndData (pctxt, BandClassInfoCDMA2000, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BandClassInfoCDMA2000 (pdata);

      stat = asn1PD_BandClassInfoCDMA2000 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_BandClassListCDMA2000 (BandClassListCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_PhysCellIdListCDMA2000 (OSCTXT* pctxt, PhysCellIdListCDMA2000* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdListCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhysCellIdListCDMA2000"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PhysCellIdCDMA2000", xx1);

      stat = asn1PE_PhysCellIdCDMA2000 (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhysCellIdListCDMA2000 (OSCTXT* pctxt, PhysCellIdListCDMA2000* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdListCDMA2000");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 16) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PhysCellIdCDMA2000", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (PhysCellIdCDMA2000));
      stat = asn1PD_PhysCellIdCDMA2000 (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PhysCellIdListCDMA2000 (PhysCellIdListCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_NeighCellsPerBandclassCDMA2000 (OSCTXT* pctxt, NeighCellsPerBandclassCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellsPerBandclassCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("NeighCellsPerBandclassCDMA2000"));

   /* encode arfcn */

   RTXCTXTPUSHELEMNAME (pctxt, "arfcn");

   stat = asn1PE_ARFCN_ValueCDMA2000 (pctxt, pvalue->arfcn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode physCellIdList */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellIdList");

   stat = asn1PE_PhysCellIdListCDMA2000 (pctxt, &pvalue->physCellIdList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_NeighCellsPerBandclassCDMA2000 (OSCTXT* pctxt, NeighCellsPerBandclassCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellsPerBandclassCDMA2000");

   /* decode root elements */
   /* decode arfcn */
   RTXCTXTPUSHELEMNAME (pctxt, "arfcn");

   stat = asn1PD_ARFCN_ValueCDMA2000 (pctxt, &pvalue->arfcn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode physCellIdList */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellIdList");

   stat = asn1PD_PhysCellIdListCDMA2000 (pctxt, &pvalue->physCellIdList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_NeighCellsPerBandclassCDMA2000 (
   NeighCellsPerBandclassCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_PhysCellIdListCDMA2000 (&pvalue->physCellIdList);
}

EXTERN int asn1PE_NeighCellsPerBandclassListCDMA2000 (OSCTXT* pctxt, NeighCellsPerBandclassListCDMA2000* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellsPerBandclassListCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("NeighCellsPerBandclassListCDMA2000"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "NeighCellsPerBandclassCDMA2000", xx1);

      stat = asn1PE_NeighCellsPerBandclassCDMA2000 (pctxt, ((NeighCellsPerBandclassCDMA2000*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_NeighCellsPerBandclassListCDMA2000 (OSCTXT* pctxt, NeighCellsPerBandclassListCDMA2000* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellsPerBandclassListCDMA2000");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NeighCellsPerBandclassCDMA2000* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "NeighCellsPerBandclassCDMA2000", xx1);

      rtxDListAllocNodeAndData (pctxt, NeighCellsPerBandclassCDMA2000, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NeighCellsPerBandclassCDMA2000 (pdata);

      stat = asn1PD_NeighCellsPerBandclassCDMA2000 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_NeighCellsPerBandclassListCDMA2000 (
   NeighCellsPerBandclassListCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_NeighCellCDMA2000 (OSCTXT* pctxt, NeighCellCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("NeighCellCDMA2000"));

   /* encode bandClass */

   RTXCTXTPUSHELEMNAME (pctxt, "bandClass");

   stat = asn1PE_BandclassCDMA2000 (pctxt, pvalue->bandClass);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode neighCellsPerFreqList */

   RTXCTXTPUSHELEMNAME (pctxt, "neighCellsPerFreqList");

   stat = asn1PE_NeighCellsPerBandclassListCDMA2000 (pctxt, &pvalue->neighCellsPerFreqList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_NeighCellCDMA2000 (OSCTXT* pctxt, NeighCellCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellCDMA2000");

   /* decode root elements */
   /* decode bandClass */
   RTXCTXTPUSHELEMNAME (pctxt, "bandClass");

   stat = asn1PD_BandclassCDMA2000 (pctxt, &pvalue->bandClass);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode neighCellsPerFreqList */
   RTXCTXTPUSHELEMNAME (pctxt, "neighCellsPerFreqList");

   stat = asn1PD_NeighCellsPerBandclassListCDMA2000 (pctxt, &pvalue->neighCellsPerFreqList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_NeighCellCDMA2000 (NeighCellCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_NeighCellsPerBandclassListCDMA2000 (&pvalue->neighCellsPerFreqList);
}

EXTERN int asn1PE_NeighCellListCDMA2000 (OSCTXT* pctxt, NeighCellListCDMA2000* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellListCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("NeighCellListCDMA2000"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "NeighCellCDMA2000", xx1);

      stat = asn1PE_NeighCellCDMA2000 (pctxt, ((NeighCellCDMA2000*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_NeighCellListCDMA2000 (OSCTXT* pctxt, NeighCellListCDMA2000* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellListCDMA2000");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NeighCellCDMA2000* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "NeighCellCDMA2000", xx1);

      rtxDListAllocNodeAndData (pctxt, NeighCellCDMA2000, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NeighCellCDMA2000 (pdata);

      stat = asn1PD_NeighCellCDMA2000 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_NeighCellListCDMA2000 (NeighCellListCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_CellReselectionParametersCDMA2000 (OSCTXT* pctxt, CellReselectionParametersCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellReselectionParametersCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellReselectionParametersCDMA2000"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.t_ReselectionCDMA2000_SFPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bandClassList */

   RTXCTXTPUSHELEMNAME (pctxt, "bandClassList");

   stat = asn1PE_BandClassListCDMA2000 (pctxt, &pvalue->bandClassList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode neighCellList */

   RTXCTXTPUSHELEMNAME (pctxt, "neighCellList");

   stat = asn1PE_NeighCellListCDMA2000 (pctxt, &pvalue->neighCellList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t_ReselectionCDMA2000 */

   RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionCDMA2000");

   stat = asn1PE_T_Reselection (pctxt, pvalue->t_ReselectionCDMA2000);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t_ReselectionCDMA2000_SF */

   if (pvalue->m.t_ReselectionCDMA2000_SFPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionCDMA2000-SF");

      stat = asn1PE_SpeedStateScaleFactors (pctxt, &pvalue->t_ReselectionCDMA2000_SF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellReselectionParametersCDMA2000 (OSCTXT* pctxt, CellReselectionParametersCDMA2000* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CellReselectionParametersCDMA2000");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode bandClassList */
   RTXCTXTPUSHELEMNAME (pctxt, "bandClassList");

   stat = asn1PD_BandClassListCDMA2000 (pctxt, &pvalue->bandClassList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode neighCellList */
   RTXCTXTPUSHELEMNAME (pctxt, "neighCellList");

   stat = asn1PD_NeighCellListCDMA2000 (pctxt, &pvalue->neighCellList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t_ReselectionCDMA2000 */
   RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionCDMA2000");

   stat = asn1PD_T_Reselection (pctxt, &pvalue->t_ReselectionCDMA2000);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t_ReselectionCDMA2000_SF */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t-ReselectionCDMA2000-SF");

      pvalue->m.t_ReselectionCDMA2000_SFPresent = 1;

      stat = asn1PD_SpeedStateScaleFactors (pctxt, &pvalue->t_ReselectionCDMA2000_SF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellReselectionParametersCDMA2000 (
   CellReselectionParametersCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_BandClassListCDMA2000 (&pvalue->bandClassList);
   asn1Init_NeighCellListCDMA2000 (&pvalue->neighCellList);
}

EXTERN int asn1PE_SystemInformationBlockType8_parametersHRPD (OSCTXT* pctxt, SystemInformationBlockType8_parametersHRPD* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType8_parametersHRPD"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellReselectionParametersHRPDPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode preRegistrationInfoHRPD */

   RTXCTXTPUSHELEMNAME (pctxt, "preRegistrationInfoHRPD");

   stat = asn1PE_PreRegistrationInfoHRPD (pctxt, &pvalue->preRegistrationInfoHRPD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellReselectionParametersHRPD */

   if (pvalue->m.cellReselectionParametersHRPDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionParametersHRPD");

      stat = asn1PE_CellReselectionParametersCDMA2000 (pctxt, &pvalue->cellReselectionParametersHRPD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType8_parametersHRPD (OSCTXT* pctxt, SystemInformationBlockType8_parametersHRPD* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode preRegistrationInfoHRPD */
   RTXCTXTPUSHELEMNAME (pctxt, "preRegistrationInfoHRPD");

   stat = asn1PD_PreRegistrationInfoHRPD (pctxt, &pvalue->preRegistrationInfoHRPD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellReselectionParametersHRPD */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionParametersHRPD");

      pvalue->m.cellReselectionParametersHRPDPresent = 1;

      stat = asn1PD_CellReselectionParametersCDMA2000 (pctxt, &pvalue->cellReselectionParametersHRPD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_SystemInformationBlockType8_parametersHRPD (
   SystemInformationBlockType8_parametersHRPD* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PreRegistrationInfoHRPD (&pvalue->preRegistrationInfoHRPD);
   asn1Init_CellReselectionParametersCDMA2000 (&pvalue->cellReselectionParametersHRPD);
}

EXTERN int asn1PE_CSFB_RegistrationParam1XRTT (OSCTXT* pctxt, CSFB_RegistrationParam1XRTT* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSFB-RegistrationParam1XRTT");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFB_RegistrationParam1XRTT"));

   /* encode sid */

   RTXCTXTPUSHELEMNAME (pctxt, "sid");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(15), OSUINTCONST(15), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->sid, OSUINTCONST(15), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nid */

   RTXCTXTPUSHELEMNAME (pctxt, "nid");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->nid, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode multipleSID */

   RTXCTXTPUSHELEMNAME (pctxt, "multipleSID");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->multipleSID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode multipleNID */

   RTXCTXTPUSHELEMNAME (pctxt, "multipleNID");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->multipleNID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode homeReg */

   RTXCTXTPUSHELEMNAME (pctxt, "homeReg");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->homeReg);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode foreignSIDReg */

   RTXCTXTPUSHELEMNAME (pctxt, "foreignSIDReg");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->foreignSIDReg);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode foreignNIDReg */

   RTXCTXTPUSHELEMNAME (pctxt, "foreignNIDReg");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->foreignNIDReg);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode parameterReg */

   RTXCTXTPUSHELEMNAME (pctxt, "parameterReg");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->parameterReg);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode powerUpReg */

   RTXCTXTPUSHELEMNAME (pctxt, "powerUpReg");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->powerUpReg);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode registrationPeriod */

   RTXCTXTPUSHELEMNAME (pctxt, "registrationPeriod");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(7), OSUINTCONST(7), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->registrationPeriod, OSUINTCONST(7), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode registrationZone */

   RTXCTXTPUSHELEMNAME (pctxt, "registrationZone");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(12), OSUINTCONST(12), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->registrationZone, OSUINTCONST(12), OSUINTCONST(12));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode totalZone */

   RTXCTXTPUSHELEMNAME (pctxt, "totalZone");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->totalZone, OSUINTCONST(3), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode zoneTimer */

   RTXCTXTPUSHELEMNAME (pctxt, "zoneTimer");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->zoneTimer, OSUINTCONST(3), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFB_RegistrationParam1XRTT (OSCTXT* pctxt, CSFB_RegistrationParam1XRTT* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSFB-RegistrationParam1XRTT");

   /* decode root elements */
   /* decode sid */
   RTXCTXTPUSHELEMNAME (pctxt, "sid");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(15), OSUINTCONST(15), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->sid
      , OSUINTCONST(15), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nid */
   RTXCTXTPUSHELEMNAME (pctxt, "nid");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->nid
      , OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode multipleSID */
   RTXCTXTPUSHELEMNAME (pctxt, "multipleSID");

   stat = DEC_BIT (pctxt, &pvalue->multipleSID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode multipleNID */
   RTXCTXTPUSHELEMNAME (pctxt, "multipleNID");

   stat = DEC_BIT (pctxt, &pvalue->multipleNID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode homeReg */
   RTXCTXTPUSHELEMNAME (pctxt, "homeReg");

   stat = DEC_BIT (pctxt, &pvalue->homeReg);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode foreignSIDReg */
   RTXCTXTPUSHELEMNAME (pctxt, "foreignSIDReg");

   stat = DEC_BIT (pctxt, &pvalue->foreignSIDReg);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode foreignNIDReg */
   RTXCTXTPUSHELEMNAME (pctxt, "foreignNIDReg");

   stat = DEC_BIT (pctxt, &pvalue->foreignNIDReg);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode parameterReg */
   RTXCTXTPUSHELEMNAME (pctxt, "parameterReg");

   stat = DEC_BIT (pctxt, &pvalue->parameterReg);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode powerUpReg */
   RTXCTXTPUSHELEMNAME (pctxt, "powerUpReg");

   stat = DEC_BIT (pctxt, &pvalue->powerUpReg);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode registrationPeriod */
   RTXCTXTPUSHELEMNAME (pctxt, "registrationPeriod");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(7), OSUINTCONST(7), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->registrationPeriod
      , OSUINTCONST(7), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode registrationZone */
   RTXCTXTPUSHELEMNAME (pctxt, "registrationZone");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(12), OSUINTCONST(12), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->registrationZone
      , OSUINTCONST(12), OSUINTCONST(12));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode totalZone */
   RTXCTXTPUSHELEMNAME (pctxt, "totalZone");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->totalZone
      , OSUINTCONST(3), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode zoneTimer */
   RTXCTXTPUSHELEMNAME (pctxt, "zoneTimer");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->zoneTimer
      , OSUINTCONST(3), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CSFB_RegistrationParam1XRTT (CSFB_RegistrationParam1XRTT* pvalue)
{
   if (0 == pvalue) return;
   pvalue->sid.numbits = 0;
   pvalue->nid.numbits = 0;
   pvalue->registrationPeriod.numbits = 0;
   pvalue->registrationZone.numbits = 0;
   pvalue->totalZone.numbits = 0;
   pvalue->zoneTimer.numbits = 0;
}

EXTERN int asn1PE_SystemInformationBlockType8_parameters1XRTT (OSCTXT* pctxt, SystemInformationBlockType8_parameters1XRTT* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType8_parameters1XRTT"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.csfb_RegistrationParam1XRTTPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.longCodeState1XRTTPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellReselectionParameters1XRTTPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode csfb_RegistrationParam1XRTT */

   if (pvalue->m.csfb_RegistrationParam1XRTTPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "csfb-RegistrationParam1XRTT");

      stat = asn1PE_CSFB_RegistrationParam1XRTT (pctxt, &pvalue->csfb_RegistrationParam1XRTT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode longCodeState1XRTT */

   if (pvalue->m.longCodeState1XRTTPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "longCodeState1XRTT");

      stat = asn1PE_SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT (pctxt, &pvalue->longCodeState1XRTT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cellReselectionParameters1XRTT */

   if (pvalue->m.cellReselectionParameters1XRTTPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionParameters1XRTT");

      stat = asn1PE_CellReselectionParametersCDMA2000 (pctxt, &pvalue->cellReselectionParameters1XRTT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType8_parameters1XRTT (OSCTXT* pctxt, SystemInformationBlockType8_parameters1XRTT* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode csfb_RegistrationParam1XRTT */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "csfb-RegistrationParam1XRTT");

      pvalue->m.csfb_RegistrationParam1XRTTPresent = 1;

      stat = asn1PD_CSFB_RegistrationParam1XRTT (pctxt, &pvalue->csfb_RegistrationParam1XRTT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode longCodeState1XRTT */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "longCodeState1XRTT");

      pvalue->m.longCodeState1XRTTPresent = 1;

      stat = asn1PD_SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT (pctxt, &pvalue->longCodeState1XRTT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cellReselectionParameters1XRTT */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionParameters1XRTT");

      pvalue->m.cellReselectionParameters1XRTTPresent = 1;

      stat = asn1PD_CellReselectionParametersCDMA2000 (pctxt, &pvalue->cellReselectionParameters1XRTT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_SystemInformationBlockType8_parameters1XRTT (
   SystemInformationBlockType8_parameters1XRTT* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CSFB_RegistrationParam1XRTT (&pvalue->csfb_RegistrationParam1XRTT);
   asn1Init_SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT (&pvalue->longCodeState1XRTT);
   asn1Init_CellReselectionParametersCDMA2000 (&pvalue->cellReselectionParameters1XRTT);
}

EXTERN int asn1PE_PhysCellIdListCDMA2000_v920 (OSCTXT* pctxt, PhysCellIdListCDMA2000_v920* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdListCDMA2000-v920");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhysCellIdListCDMA2000_v920"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(24), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PhysCellIdCDMA2000", xx1);

      stat = asn1PE_PhysCellIdCDMA2000 (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhysCellIdListCDMA2000_v920 (OSCTXT* pctxt, PhysCellIdListCDMA2000_v920* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdListCDMA2000-v920");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 5);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   if (pvalue->n > 24) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PhysCellIdCDMA2000", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (PhysCellIdCDMA2000));
      stat = asn1PD_PhysCellIdCDMA2000 (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PhysCellIdListCDMA2000_v920 (PhysCellIdListCDMA2000_v920* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_NeighCellsPerBandclassCDMA2000_v920 (OSCTXT* pctxt, NeighCellsPerBandclassCDMA2000_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellsPerBandclassCDMA2000-v920");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("NeighCellsPerBandclassCDMA2000_v920"));

   /* encode physCellIdList_v920 */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellIdList-v920");

   stat = asn1PE_PhysCellIdListCDMA2000_v920 (pctxt, &pvalue->physCellIdList_v920);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_NeighCellsPerBandclassCDMA2000_v920 (OSCTXT* pctxt, NeighCellsPerBandclassCDMA2000_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellsPerBandclassCDMA2000-v920");

   /* decode root elements */
   /* decode physCellIdList_v920 */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellIdList-v920");

   stat = asn1PD_PhysCellIdListCDMA2000_v920 (pctxt, &pvalue->physCellIdList_v920);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_NeighCellsPerBandclassCDMA2000_v920 (
   NeighCellsPerBandclassCDMA2000_v920* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_PhysCellIdListCDMA2000_v920 (&pvalue->physCellIdList_v920);
}

EXTERN int asn1PE_NeighCellsPerBandclassListCDMA2000_v920 (OSCTXT* pctxt, NeighCellsPerBandclassListCDMA2000_v920* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellsPerBandclassListCDMA2000-v920");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("NeighCellsPerBandclassListCDMA2000_v920"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "NeighCellsPerBandclassCDMA2000-v920", xx1);

      stat = asn1PE_NeighCellsPerBandclassCDMA2000_v920 (pctxt, ((NeighCellsPerBandclassCDMA2000_v920*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_NeighCellsPerBandclassListCDMA2000_v920 (OSCTXT* pctxt, NeighCellsPerBandclassListCDMA2000_v920* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellsPerBandclassListCDMA2000-v920");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NeighCellsPerBandclassCDMA2000_v920* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "NeighCellsPerBandclassCDMA2000-v920", xx1);

      rtxDListAllocNodeAndData (pctxt, NeighCellsPerBandclassCDMA2000_v920, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NeighCellsPerBandclassCDMA2000_v920 (pdata);

      stat = asn1PD_NeighCellsPerBandclassCDMA2000_v920 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_NeighCellsPerBandclassListCDMA2000_v920 (
   NeighCellsPerBandclassListCDMA2000_v920* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_NeighCellCDMA2000_v920 (OSCTXT* pctxt, NeighCellCDMA2000_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellCDMA2000-v920");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("NeighCellCDMA2000_v920"));

   /* encode neighCellsPerFreqList_v920 */

   RTXCTXTPUSHELEMNAME (pctxt, "neighCellsPerFreqList-v920");

   stat = asn1PE_NeighCellsPerBandclassListCDMA2000_v920 (pctxt, &pvalue->neighCellsPerFreqList_v920);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_NeighCellCDMA2000_v920 (OSCTXT* pctxt, NeighCellCDMA2000_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellCDMA2000-v920");

   /* decode root elements */
   /* decode neighCellsPerFreqList_v920 */
   RTXCTXTPUSHELEMNAME (pctxt, "neighCellsPerFreqList-v920");

   stat = asn1PD_NeighCellsPerBandclassListCDMA2000_v920 (pctxt, &pvalue->neighCellsPerFreqList_v920);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_NeighCellCDMA2000_v920 (NeighCellCDMA2000_v920* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_NeighCellsPerBandclassListCDMA2000_v920 (&pvalue->neighCellsPerFreqList_v920);
}

EXTERN int asn1PE_NeighCellListCDMA2000_v920 (OSCTXT* pctxt, NeighCellListCDMA2000_v920* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellListCDMA2000-v920");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("NeighCellListCDMA2000_v920"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "NeighCellCDMA2000-v920", xx1);

      stat = asn1PE_NeighCellCDMA2000_v920 (pctxt, ((NeighCellCDMA2000_v920*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_NeighCellListCDMA2000_v920 (OSCTXT* pctxt, NeighCellListCDMA2000_v920* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellListCDMA2000-v920");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NeighCellCDMA2000_v920* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "NeighCellCDMA2000-v920", xx1);

      rtxDListAllocNodeAndData (pctxt, NeighCellCDMA2000_v920, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NeighCellCDMA2000_v920 (pdata);

      stat = asn1PD_NeighCellCDMA2000_v920 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_NeighCellListCDMA2000_v920 (NeighCellListCDMA2000_v920* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_CellReselectionParametersCDMA2000_v920 (OSCTXT* pctxt, CellReselectionParametersCDMA2000_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellReselectionParametersCDMA2000-v920");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellReselectionParametersCDMA2000_v920"));

   /* encode neighCellList_v920 */

   RTXCTXTPUSHELEMNAME (pctxt, "neighCellList-v920");

   stat = asn1PE_NeighCellListCDMA2000_v920 (pctxt, &pvalue->neighCellList_v920);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellReselectionParametersCDMA2000_v920 (OSCTXT* pctxt, CellReselectionParametersCDMA2000_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellReselectionParametersCDMA2000-v920");

   /* decode root elements */
   /* decode neighCellList_v920 */
   RTXCTXTPUSHELEMNAME (pctxt, "neighCellList-v920");

   stat = asn1PD_NeighCellListCDMA2000_v920 (pctxt, &pvalue->neighCellList_v920);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellReselectionParametersCDMA2000_v920 (
   CellReselectionParametersCDMA2000_v920* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_NeighCellListCDMA2000_v920 (&pvalue->neighCellList_v920);
}

EXTERN int asn1PE_CSFB_RegistrationParam1XRTT_v920 (OSCTXT* pctxt, CSFB_RegistrationParam1XRTT_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSFB-RegistrationParam1XRTT-v920");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFB_RegistrationParam1XRTT_v920"));

   /* encode powerDownReg_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "powerDownReg-r9");

   stat = asn1PE_CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9 (pctxt, pvalue->powerDownReg_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFB_RegistrationParam1XRTT_v920 (OSCTXT* pctxt, CSFB_RegistrationParam1XRTT_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSFB-RegistrationParam1XRTT-v920");

   /* decode root elements */
   /* decode powerDownReg_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "powerDownReg-r9");

   stat = asn1PD_CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9 (pctxt, &pvalue->powerDownReg_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_AC_BarringConfig1XRTT_r9 (OSCTXT* pctxt, AC_BarringConfig1XRTT_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AC-BarringConfig1XRTT-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("AC_BarringConfig1XRTT_r9"));

   /* encode ac_Barring0to9_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "ac-Barring0to9-r9");

   if ( (pvalue->ac_Barring0to9_r9 <= OSUINTCONST(63)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ac_Barring0to9_r9, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ac_Barring0to9_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ac_Barring10_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "ac-Barring10-r9");

   if ( (pvalue->ac_Barring10_r9 <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ac_Barring10_r9, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ac_Barring10_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ac_Barring11_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "ac-Barring11-r9");

   if ( (pvalue->ac_Barring11_r9 <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ac_Barring11_r9, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ac_Barring11_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ac_Barring12_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "ac-Barring12-r9");

   if ( (pvalue->ac_Barring12_r9 <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ac_Barring12_r9, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ac_Barring12_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ac_Barring13_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "ac-Barring13-r9");

   if ( (pvalue->ac_Barring13_r9 <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ac_Barring13_r9, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ac_Barring13_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ac_Barring14_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "ac-Barring14-r9");

   if ( (pvalue->ac_Barring14_r9 <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ac_Barring14_r9, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ac_Barring14_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ac_Barring15_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "ac-Barring15-r9");

   if ( (pvalue->ac_Barring15_r9 <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ac_Barring15_r9, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ac_Barring15_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ac_BarringMsg_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringMsg-r9");

   if ( (pvalue->ac_BarringMsg_r9 <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ac_BarringMsg_r9, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ac_BarringMsg_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ac_BarringReg_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringReg-r9");

   if ( (pvalue->ac_BarringReg_r9 <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ac_BarringReg_r9, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ac_BarringReg_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ac_BarringEmg_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringEmg-r9");

   if ( (pvalue->ac_BarringEmg_r9 <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ac_BarringEmg_r9, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ac_BarringEmg_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AC_BarringConfig1XRTT_r9 (OSCTXT* pctxt, AC_BarringConfig1XRTT_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AC-BarringConfig1XRTT-r9");

   /* decode root elements */
   /* decode ac_Barring0to9_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "ac-Barring0to9-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ac_Barring0to9_r9, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ac_Barring10_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "ac-Barring10-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ac_Barring10_r9, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ac_Barring11_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "ac-Barring11-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ac_Barring11_r9, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ac_Barring12_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "ac-Barring12-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ac_Barring12_r9, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ac_Barring13_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "ac-Barring13-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ac_Barring13_r9, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ac_Barring14_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "ac-Barring14-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ac_Barring14_r9, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ac_Barring15_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "ac-Barring15-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ac_Barring15_r9, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ac_BarringMsg_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringMsg-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ac_BarringMsg_r9, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ac_BarringReg_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringReg-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ac_BarringReg_r9, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ac_BarringEmg_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringEmg-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ac_BarringEmg_r9, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SystemInformationBlockType8 (OSCTXT* pctxt, SystemInformationBlockType8* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType8");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType8"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m.lateNonCriticalExtensionPresent ||
   pvalue->m._v3ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.systemTimeInfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.searchWindowSizePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.parametersHRPDPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.parameters1XRTTPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode systemTimeInfo */

   if (pvalue->m.systemTimeInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "systemTimeInfo");

      stat = asn1PE_SystemTimeInfoCDMA2000 (pctxt, &pvalue->systemTimeInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode searchWindowSize */

   if (pvalue->m.searchWindowSizePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "searchWindowSize");

      if ( (pvalue->searchWindowSize <= OSUINTCONST(15)) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->searchWindowSize, OSUINTCONST(0), OSUINTCONST(15));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->searchWindowSize);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode parametersHRPD */

   if (pvalue->m.parametersHRPDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "parametersHRPD");

      stat = asn1PE_SystemInformationBlockType8_parametersHRPD (pctxt, &pvalue->parametersHRPD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode parameters1XRTT */

   if (pvalue->m.parameters1XRTTPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "parameters1XRTT");

      stat = asn1PE_SystemInformationBlockType8_parameters1XRTT (pctxt, &pvalue->parameters1XRTT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v3ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m.lateNonCriticalExtensionPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->m._v3ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.csfb_SupportForDualRxUEs_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellReselectionParametersHRPD_v920Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellReselectionParameters1XRTT_v920Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.csfb_RegistrationParam1XRTT_v920Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ac_BarringConfig1XRTT_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode csfb_SupportForDualRxUEs_r9 */

         if (pvalue->m.csfb_SupportForDualRxUEs_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "csfb-SupportForDualRxUEs-r9");

            stat = rtxEncBit (pctxt, (OSBOOL)pvalue->csfb_SupportForDualRxUEs_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         /* encode cellReselectionParametersHRPD_v920 */

         if (pvalue->m.cellReselectionParametersHRPD_v920Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionParametersHRPD-v920");

            stat = asn1PE_CellReselectionParametersCDMA2000_v920 (pctxt, &pvalue->cellReselectionParametersHRPD_v920);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         /* encode cellReselectionParameters1XRTT_v920 */

         if (pvalue->m.cellReselectionParameters1XRTT_v920Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionParameters1XRTT-v920");

            stat = asn1PE_CellReselectionParametersCDMA2000_v920 (pctxt, &pvalue->cellReselectionParameters1XRTT_v920);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         /* encode csfb_RegistrationParam1XRTT_v920 */

         if (pvalue->m.csfb_RegistrationParam1XRTT_v920Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "csfb-RegistrationParam1XRTT-v920");

            stat = asn1PE_CSFB_RegistrationParam1XRTT_v920 (pctxt, &pvalue->csfb_RegistrationParam1XRTT_v920);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         /* encode ac_BarringConfig1XRTT_r9 */

         if (pvalue->m.ac_BarringConfig1XRTT_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringConfig1XRTT-r9");

            stat = asn1PE_AC_BarringConfig1XRTT_r9 (pctxt, &pvalue->ac_BarringConfig1XRTT_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType8 (OSCTXT* pctxt, SystemInformationBlockType8* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType8");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode systemTimeInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "systemTimeInfo");

      pvalue->m.systemTimeInfoPresent = 1;

      stat = asn1PD_SystemTimeInfoCDMA2000 (pctxt, &pvalue->systemTimeInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode searchWindowSize */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "searchWindowSize");

      pvalue->m.searchWindowSizePresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->searchWindowSize, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode parametersHRPD */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "parametersHRPD");

      pvalue->m.parametersHRPDPresent = 1;

      stat = asn1PD_SystemInformationBlockType8_parametersHRPD (pctxt, &pvalue->parametersHRPD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode parameters1XRTT */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "parameters1XRTT");

      pvalue->m.parameters1XRTTPresent = 1;

      stat = asn1PD_SystemInformationBlockType8_parameters1XRTT (pctxt, &pvalue->parameters1XRTT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 2) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.lateNonCriticalExtensionPresent = 1;
                        RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

                        stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
                        if (stat != 0) {
                           rtxMemFreePtr (pctxt, openType.data);
                           break;
                        }

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                     case 1:
                        pvalue->m._v3ExtPresent = 1;
                        {
                           OSOCTET extoptbits[5];
                           OSUINT32 _i;

                           for (_i = 0; _i < 5; _i++) {
                              stat = DEC_BIT (pctxt, &extoptbits[_i]);
                              if (stat != 0)  {
                                 rtxMemFreePtr (pctxt, poptbits);
                                 return LOG_RTERR (pctxt, stat);
                              }
                           }
                           if (extoptbits[0]) {
                              pvalue->m.csfb_SupportForDualRxUEs_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "csfb-SupportForDualRxUEs-r9");

                              stat = DEC_BIT (pctxt, &pvalue->csfb_SupportForDualRxUEs_r9);
                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                           if (extoptbits[1]) {
                              pvalue->m.cellReselectionParametersHRPD_v920Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionParametersHRPD-v920");

                              stat = asn1PD_CellReselectionParametersCDMA2000_v920 (pctxt, &pvalue->cellReselectionParametersHRPD_v920);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                           if (extoptbits[2]) {
                              pvalue->m.cellReselectionParameters1XRTT_v920Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionParameters1XRTT-v920");

                              stat = asn1PD_CellReselectionParametersCDMA2000_v920 (pctxt, &pvalue->cellReselectionParameters1XRTT_v920);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                           if (extoptbits[3]) {
                              pvalue->m.csfb_RegistrationParam1XRTT_v920Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "csfb-RegistrationParam1XRTT-v920");

                              stat = asn1PD_CSFB_RegistrationParam1XRTT_v920 (pctxt, &pvalue->csfb_RegistrationParam1XRTT_v920);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                           if (extoptbits[4]) {
                              pvalue->m.ac_BarringConfig1XRTT_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "ac-BarringConfig1XRTT-r9");

                              stat = asn1PD_AC_BarringConfig1XRTT_r9 (pctxt, &pvalue->ac_BarringConfig1XRTT_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;

                        /* Coverity 55340 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 2 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 2) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType8 (SystemInformationBlockType8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SystemTimeInfoCDMA2000 (&pvalue->systemTimeInfo);
   asn1Init_SystemInformationBlockType8_parametersHRPD (&pvalue->parametersHRPD);
   asn1Init_SystemInformationBlockType8_parameters1XRTT (&pvalue->parameters1XRTT);
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   asn1Init_CellReselectionParametersCDMA2000_v920 (&pvalue->cellReselectionParametersHRPD_v920);
   asn1Init_CellReselectionParametersCDMA2000_v920 (&pvalue->cellReselectionParameters1XRTT_v920);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_SystemInformationBlockType9 (OSCTXT* pctxt, SystemInformationBlockType9* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType9"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m.lateNonCriticalExtensionPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.hnb_NamePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode hnb_Name */

   if (pvalue->m.hnb_NamePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "hnb-Name");

      stat = asn1PE_SystemInformationBlockType9_hnb_Name (pctxt, &pvalue->hnb_Name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m.lateNonCriticalExtensionPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType9 (OSCTXT* pctxt, SystemInformationBlockType9* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType9");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode hnb_Name */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hnb-Name");

      pvalue->m.hnb_NamePresent = 1;

      stat = asn1PD_SystemInformationBlockType9_hnb_Name (pctxt, &pvalue->hnb_Name);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.lateNonCriticalExtensionPresent = 1;
                        RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

                        stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
                        if (stat != 0) {
                           rtxMemFreePtr (pctxt, openType.data);
                           break;
                        }

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                        /* Coverity 55341 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType9 (SystemInformationBlockType9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SystemInformationBlockType9_hnb_Name (&pvalue->hnb_Name);
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_SystemInformationBlockType10 (OSCTXT* pctxt, SystemInformationBlockType10* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType10");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType10"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m.lateNonCriticalExtensionPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.warningSecurityInfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode messageIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "messageIdentifier");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->messageIdentifier, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode serialNumber */

   RTXCTXTPUSHELEMNAME (pctxt, "serialNumber");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->serialNumber, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode warningType */

   RTXCTXTPUSHELEMNAME (pctxt, "warningType");

   stat = asn1PE_SystemInformationBlockType10_warningType (pctxt, &pvalue->warningType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode warningSecurityInfo */

   if (pvalue->m.warningSecurityInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "warningSecurityInfo");

      stat = asn1PE_SystemInformationBlockType10_warningSecurityInfo (pctxt, &pvalue->warningSecurityInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m.lateNonCriticalExtensionPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType10 (OSCTXT* pctxt, SystemInformationBlockType10* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType10");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode messageIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "messageIdentifier");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->messageIdentifier
      , OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode serialNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "serialNumber");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->serialNumber
      , OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode warningType */
   RTXCTXTPUSHELEMNAME (pctxt, "warningType");

   stat = asn1PD_SystemInformationBlockType10_warningType (pctxt, &pvalue->warningType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode warningSecurityInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "warningSecurityInfo");

      pvalue->m.warningSecurityInfoPresent = 1;

      stat = asn1PD_SystemInformationBlockType10_warningSecurityInfo (pctxt, &pvalue->warningSecurityInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.lateNonCriticalExtensionPresent = 1;
                        RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

                        stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
                        if (stat != 0) {
                           rtxMemFreePtr (pctxt, openType.data);
                           break;
                        }

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                        /* Coverity 55349 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType10 (
   SystemInformationBlockType10* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->messageIdentifier.numbits = 0;
   pvalue->serialNumber.numbits = 0;
   asn1Init_SystemInformationBlockType10_warningType (&pvalue->warningType);
   asn1Init_SystemInformationBlockType10_warningSecurityInfo (&pvalue->warningSecurityInfo);
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_SystemInformationBlockType11 (OSCTXT* pctxt, SystemInformationBlockType11* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType11");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType11"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m.lateNonCriticalExtensionPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataCodingSchemePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode messageIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "messageIdentifier");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->messageIdentifier, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode serialNumber */

   RTXCTXTPUSHELEMNAME (pctxt, "serialNumber");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->serialNumber, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode warningMessageSegmentType */

   RTXCTXTPUSHELEMNAME (pctxt, "warningMessageSegmentType");

   stat = asn1PE_SystemInformationBlockType11_warningMessageSegmentType (pctxt, pvalue->warningMessageSegmentType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode warningMessageSegmentNumber */

   RTXCTXTPUSHELEMNAME (pctxt, "warningMessageSegmentNumber");

   if ( (pvalue->warningMessageSegmentNumber <= OSUINTCONST(63)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->warningMessageSegmentNumber, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->warningMessageSegmentNumber);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode warningMessageSegment */

   RTXCTXTPUSHELEMNAME (pctxt, "warningMessageSegment");

   stat = pe_OctetString (pctxt, pvalue->warningMessageSegment.numocts, pvalue->warningMessageSegment.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dataCodingScheme */

   if (pvalue->m.dataCodingSchemePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataCodingScheme");

      stat = asn1PE_SystemInformationBlockType11_dataCodingScheme (pctxt, &pvalue->dataCodingScheme);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m.lateNonCriticalExtensionPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType11 (OSCTXT* pctxt, SystemInformationBlockType11* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType11");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode messageIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "messageIdentifier");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->messageIdentifier
      , OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode serialNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "serialNumber");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->serialNumber
      , OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode warningMessageSegmentType */
   RTXCTXTPUSHELEMNAME (pctxt, "warningMessageSegmentType");

   stat = asn1PD_SystemInformationBlockType11_warningMessageSegmentType (pctxt, &pvalue->warningMessageSegmentType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode warningMessageSegmentNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "warningMessageSegmentNumber");

   stat = pd_ConsUInt8 (pctxt, &pvalue->warningMessageSegmentNumber, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode warningMessageSegment */
   RTXCTXTPUSHELEMNAME (pctxt, "warningMessageSegment");

   stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->warningMessageSegment);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dataCodingScheme */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataCodingScheme");

      pvalue->m.dataCodingSchemePresent = 1;

      stat = asn1PD_SystemInformationBlockType11_dataCodingScheme (pctxt, &pvalue->dataCodingScheme);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.lateNonCriticalExtensionPresent = 1;
                        RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

                        stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
                        if (stat != 0) {
                           rtxMemFreePtr (pctxt, openType.data);
                           break;
                        }

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                        /* Coverity 55350 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType11 (
   SystemInformationBlockType11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->messageIdentifier.numbits = 0;
   pvalue->serialNumber.numbits = 0;
   pvalue->warningMessageSegment.numocts = 0;
   pvalue->warningMessageSegment.data = 0;
   asn1Init_SystemInformationBlockType11_dataCodingScheme (&pvalue->dataCodingScheme);
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_SystemInformationBlockType12_r9 (OSCTXT* pctxt, SystemInformationBlockType12_r9* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType12-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType12_r9"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataCodingScheme_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode messageIdentifier_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "messageIdentifier-r9");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->messageIdentifier_r9, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode serialNumber_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "serialNumber-r9");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->serialNumber_r9, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode warningMessageSegmentType_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "warningMessageSegmentType-r9");

   stat = asn1PE_SystemInformationBlockType12_r9_warningMessageSegmentType_r9 (pctxt, pvalue->warningMessageSegmentType_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode warningMessageSegmentNumber_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "warningMessageSegmentNumber-r9");

   if ( (pvalue->warningMessageSegmentNumber_r9 <= OSUINTCONST(63)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->warningMessageSegmentNumber_r9, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->warningMessageSegmentNumber_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode warningMessageSegment_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "warningMessageSegment-r9");

   stat = pe_OctetString (pctxt, pvalue->warningMessageSegment_r9.numocts, pvalue->warningMessageSegment_r9.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dataCodingScheme_r9 */

   if (pvalue->m.dataCodingScheme_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataCodingScheme-r9");

      stat = asn1PE_SystemInformationBlockType12_r9_dataCodingScheme_r9 (pctxt, &pvalue->dataCodingScheme_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType12_r9 (OSCTXT* pctxt, SystemInformationBlockType12_r9* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType12-r9");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode messageIdentifier_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "messageIdentifier-r9");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->messageIdentifier_r9
      , OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode serialNumber_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "serialNumber-r9");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->serialNumber_r9
      , OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode warningMessageSegmentType_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "warningMessageSegmentType-r9");

   stat = asn1PD_SystemInformationBlockType12_r9_warningMessageSegmentType_r9 (pctxt, &pvalue->warningMessageSegmentType_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode warningMessageSegmentNumber_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "warningMessageSegmentNumber-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->warningMessageSegmentNumber_r9, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode warningMessageSegment_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "warningMessageSegment-r9");

   stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->warningMessageSegment_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dataCodingScheme_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataCodingScheme-r9");

      pvalue->m.dataCodingScheme_r9Present = 1;

      stat = asn1PD_SystemInformationBlockType12_r9_dataCodingScheme_r9 (pctxt, &pvalue->dataCodingScheme_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode lateNonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType12_r9 (
   SystemInformationBlockType12_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->messageIdentifier_r9.numbits = 0;
   pvalue->serialNumber_r9.numbits = 0;
   pvalue->warningMessageSegment_r9.numocts = 0;
   pvalue->warningMessageSegment_r9.data = 0;
   asn1Init_SystemInformationBlockType12_r9_dataCodingScheme_r9 (&pvalue->dataCodingScheme_r9);
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_MBMS_NotificationConfig_r9 (OSCTXT* pctxt, MBMS_NotificationConfig_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMS-NotificationConfig-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBMS_NotificationConfig_r9"));

   /* encode notificationRepetitionCoeff_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "notificationRepetitionCoeff-r9");

   stat = asn1PE_MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9 (pctxt, pvalue->notificationRepetitionCoeff_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode notificationOffset_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "notificationOffset-r9");

   if ( (pvalue->notificationOffset_r9 <= OSUINTCONST(10)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->notificationOffset_r9, OSUINTCONST(0), OSUINTCONST(10));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->notificationOffset_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode notificationSF_Index_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "notificationSF-Index-r9");

   if ( (pvalue->notificationSF_Index_r9 >= OSUINTCONST(1) && pvalue->
      notificationSF_Index_r9 <= OSUINTCONST(6)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->notificationSF_Index_r9, OSUINTCONST(1), OSUINTCONST(6));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->notificationSF_Index_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBMS_NotificationConfig_r9 (OSCTXT* pctxt, MBMS_NotificationConfig_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMS-NotificationConfig-r9");

   /* decode root elements */
   /* decode notificationRepetitionCoeff_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "notificationRepetitionCoeff-r9");

   stat = asn1PD_MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9 (pctxt, &pvalue->notificationRepetitionCoeff_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode notificationOffset_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "notificationOffset-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->notificationOffset_r9, OSUINTCONST(0), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode notificationSF_Index_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "notificationSF-Index-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->notificationSF_Index_r9, OSUINTCONST(1), OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SystemInformationBlockType13_r9 (OSCTXT* pctxt, SystemInformationBlockType13_r9* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType13-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType13_r9"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode notificationConfig_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "notificationConfig-r9");

   stat = asn1PE_MBMS_NotificationConfig_r9 (pctxt, &pvalue->notificationConfig_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType13_r9 (OSCTXT* pctxt, SystemInformationBlockType13_r9* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType13-r9");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode notificationConfig_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "notificationConfig-r9");

   stat = asn1PD_MBMS_NotificationConfig_r9 (pctxt, &pvalue->notificationConfig_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType13_r9 (
   SystemInformationBlockType13_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_SystemInformation_r8_IEs_sib_TypeAndInfo_element (OSCTXT* pctxt, SystemInformation_r8_IEs_sib_TypeAndInfo_element* pvalue)
{
	int stat = 0;
	OSUINT32 pos;
	void* pPerField;
	OSBOOL extbit = FALSE;

	rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformation_r8_IEs_sib_TypeAndInfo_element"));

	/* extension bit */

	extbit = (OSBOOL)(pvalue->t > 10);

	stat = rtxEncBit (pctxt, extbit);
	if (stat != 0) return LOG_RTERR (pctxt, stat);

	if (!extbit) {

		/* Encode choice index value */

		stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 9);
		if (stat != 0) return LOG_RTERR (pctxt, stat);

		/* Encode root element data value */

		switch (pvalue->t)
		{
			/* sib2 */
			case 1:
				RTXCTXTPUSHELEMNAME (pctxt, "sib2");

				stat = asn1PE_SystemInformationBlockType2 (pctxt, pvalue->u.sib2);
				if (stat != 0) return LOG_RTERR (pctxt, stat);

				RTXCTXTPOPELEMNAME (pctxt);
				break;

				/* sib3 */
			case 2:
				RTXCTXTPUSHELEMNAME (pctxt, "sib3");

				stat = asn1PE_SystemInformationBlockType3 (pctxt, pvalue->u.sib3);
				if (stat != 0) return LOG_RTERR (pctxt, stat);

				RTXCTXTPOPELEMNAME (pctxt);
				break;

				/* sib4 */
			case 3:
				RTXCTXTPUSHELEMNAME (pctxt, "sib4");

				stat = asn1PE_SystemInformationBlockType4 (pctxt, pvalue->u.sib4);
				if (stat != 0) return LOG_RTERR (pctxt, stat);

				RTXCTXTPOPELEMNAME (pctxt);
				break;

				/* sib5 */
			case 4:
				RTXCTXTPUSHELEMNAME (pctxt, "sib5");

				stat = asn1PE_SystemInformationBlockType5 (pctxt, pvalue->u.sib5);
				if (stat != 0) return LOG_RTERR (pctxt, stat);

				RTXCTXTPOPELEMNAME (pctxt);
				break;

				/* sib6 */
			case 5:
				RTXCTXTPUSHELEMNAME (pctxt, "sib6");

				stat = asn1PE_SystemInformationBlockType6 (pctxt, pvalue->u.sib6);
				if (stat != 0) return LOG_RTERR (pctxt, stat);

				RTXCTXTPOPELEMNAME (pctxt);
				break;

				/* sib7 */
			case 6:
				RTXCTXTPUSHELEMNAME (pctxt, "sib7");

				stat = asn1PE_SystemInformationBlockType7 (pctxt, pvalue->u.sib7);
				if (stat != 0) return LOG_RTERR (pctxt, stat);

				RTXCTXTPOPELEMNAME (pctxt);
				break;

				/* sib8 */
			case 7:
				RTXCTXTPUSHELEMNAME (pctxt, "sib8");

				stat = asn1PE_SystemInformationBlockType8 (pctxt, pvalue->u.sib8);
				if (stat != 0) return LOG_RTERR (pctxt, stat);

				RTXCTXTPOPELEMNAME (pctxt);
				break;

				/* sib9 */
			case 8:
				RTXCTXTPUSHELEMNAME (pctxt, "sib9");

				stat = asn1PE_SystemInformationBlockType9 (pctxt, pvalue->u.sib9);
				if (stat != 0) return LOG_RTERR (pctxt, stat);

				RTXCTXTPOPELEMNAME (pctxt);
				break;

				/* sib10 */
			case 9:
				RTXCTXTPUSHELEMNAME (pctxt, "sib10");

				stat = asn1PE_SystemInformationBlockType10 (pctxt, pvalue->u.sib10);
				if (stat != 0) return LOG_RTERR (pctxt, stat);

				RTXCTXTPOPELEMNAME (pctxt);
				break;

				/* sib11 */
			case 10:
				RTXCTXTPUSHELEMNAME (pctxt, "sib11");

				stat = asn1PE_SystemInformationBlockType11 (pctxt, pvalue->u.sib11);
				if (stat != 0) return LOG_RTERR (pctxt, stat);

				RTXCTXTPOPELEMNAME (pctxt);
				break;

			default:
				return LOG_RTERR (pctxt, RTERR_INVOPT);
		}
	}
	else {
		/* Encode extension choice index value */

		stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 11);
		if (stat != 0) return LOG_RTERR (pctxt, stat);

		/* Encode extension element data value */

		stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
		if (stat != 0) return LOG_RTERR (pctxt, stat);

		switch (pvalue->t)
		{
			/* sib12_v920 */
			case 11:
				stat = asn1PE_SystemInformationBlockType12_r9 (pctxt, pvalue->u.sib12_v920);
				if (stat != 0) return LOG_RTERR (pctxt, stat);
				break;

				/* sib13_v920 */
			case 12:
				stat = asn1PE_SystemInformationBlockType13_r9 (pctxt, pvalue->u.sib13_v920);
				if (stat != 0) return LOG_RTERR (pctxt, stat);
				break;

			default:
				rtxEncBitsFromByteArray (pctxt, pvalue->u.extElem1->data, pvalue->u.extElem1->numocts * 8);
		}

		stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
		if (stat != 0) return LOG_RTERR (pctxt, stat);
	}

	rtxCtxtPopTypeName (pctxt);

	return (stat);
}

EXTERN int asn1PD_SystemInformation_r8_IEs_sib_TypeAndInfo_element (OSCTXT* pctxt, SystemInformation_r8_IEs_sib_TypeAndInfo_element* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;
   OSINT16 savedBitOffset = 0;
   OSBOOL fragmented = FALSE;
   OSCTXT lctxt;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(9));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sib2 */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "sib2");

            pvalue->u.sib2 = rtxMemAllocType (pctxt, 
               SystemInformationBlockType2);

            if (pvalue->u.sib2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SystemInformationBlockType2 (pvalue->u.sib2);

            stat = asn1PD_SystemInformationBlockType2 (pctxt, pvalue->u.sib2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* sib3 */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "sib3");

            pvalue->u.sib3 = rtxMemAllocType (pctxt, 
               SystemInformationBlockType3);

            if (pvalue->u.sib3 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SystemInformationBlockType3 (pvalue->u.sib3);

            stat = asn1PD_SystemInformationBlockType3 (pctxt, pvalue->u.sib3);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* sib4 */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "sib4");

            pvalue->u.sib4 = rtxMemAllocType (pctxt, 
               SystemInformationBlockType4);

            if (pvalue->u.sib4 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SystemInformationBlockType4 (pvalue->u.sib4);

            stat = asn1PD_SystemInformationBlockType4 (pctxt, pvalue->u.sib4);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* sib5 */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "sib5");

            pvalue->u.sib5 = rtxMemAllocType (pctxt, 
               SystemInformationBlockType5);

            if (pvalue->u.sib5 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SystemInformationBlockType5 (pvalue->u.sib5);

            stat = asn1PD_SystemInformationBlockType5 (pctxt, pvalue->u.sib5);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* sib6 */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "sib6");

            pvalue->u.sib6 = rtxMemAllocType (pctxt, 
               SystemInformationBlockType6);

            if (pvalue->u.sib6 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SystemInformationBlockType6 (pvalue->u.sib6);

            stat = asn1PD_SystemInformationBlockType6 (pctxt, pvalue->u.sib6);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* sib7 */
         case 5:
            RTXCTXTPUSHELEMNAME (pctxt, "sib7");

            pvalue->u.sib7 = rtxMemAllocType (pctxt, 
               SystemInformationBlockType7);

            if (pvalue->u.sib7 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SystemInformationBlockType7 (pvalue->u.sib7);

            stat = asn1PD_SystemInformationBlockType7 (pctxt, pvalue->u.sib7);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* sib8 */
         case 6:
            RTXCTXTPUSHELEMNAME (pctxt, "sib8");

            pvalue->u.sib8 = rtxMemAllocType (pctxt, 
               SystemInformationBlockType8);

            if (pvalue->u.sib8 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SystemInformationBlockType8 (pvalue->u.sib8);

            stat = asn1PD_SystemInformationBlockType8 (pctxt, pvalue->u.sib8);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* sib9 */
         case 7:
            RTXCTXTPUSHELEMNAME (pctxt, "sib9");

            pvalue->u.sib9 = rtxMemAllocType (pctxt, 
               SystemInformationBlockType9);

            if (pvalue->u.sib9 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SystemInformationBlockType9 (pvalue->u.sib9);

            stat = asn1PD_SystemInformationBlockType9 (pctxt, pvalue->u.sib9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* sib10 */
         case 8:
            RTXCTXTPUSHELEMNAME (pctxt, "sib10");

            pvalue->u.sib10 = rtxMemAllocType (pctxt, 
               SystemInformationBlockType10);

            if (pvalue->u.sib10 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SystemInformationBlockType10 (pvalue->u.sib10);

            stat = asn1PD_SystemInformationBlockType10 (pctxt, pvalue->u.sib10);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* sib11 */
         case 9:
            RTXCTXTPUSHELEMNAME (pctxt, "sib11");

            pvalue->u.sib11 = rtxMemAllocType (pctxt, 
               SystemInformationBlockType11);

            if (pvalue->u.sib11 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SystemInformationBlockType11 (pvalue->u.sib11);

            stat = asn1PD_SystemInformationBlockType11 (pctxt, pvalue->u.sib11);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 11;

      if (pvalue->t < 11) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      if (pd_isFragmented (pctxt)) {
         fragmented = TRUE;
         stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxCopyContext (&lctxt, pctxt);
         rtxCtxtSetFlag (pctxt, OSDISSTRM);
         stat = rtxInitContextBuffer (pctxt,
            (OSOCTET*)openType.data, openType.numocts);
      }
      else if (pvalue->t < 13) {
         stat = pd_Length (pctxt, &openType.numocts);
         if (stat != 0 && stat != ASN_OK_FRAG) return LOG_RTERR (pctxt, stat);

         pd_OpenTypeStart(pctxt, &openType.numocts, &savedBitOffset);
      }
      else openType.numocts = 0;

      switch (pvalue->t) {
         /* sib12_v920 */
         case 11:
            RTXCTXTPUSHELEMNAME (pctxt, "sib12-v920");

            pvalue->u.sib12_v920 = rtxMemAllocType (pctxt, 
               SystemInformationBlockType12_r9);

            if (pvalue->u.sib12_v920 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SystemInformationBlockType12_r9 (pvalue->u.sib12_v920);

            stat = asn1PD_SystemInformationBlockType12_r9 (pctxt, pvalue->u.sib12_v920);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* sib13_v920 */
         case 12:
            RTXCTXTPUSHELEMNAME (pctxt, "sib13-v920");

            pvalue->u.sib13_v920 = rtxMemAllocType (pctxt, 
               SystemInformationBlockType13_r9);

            if (pvalue->u.sib13_v920 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SystemInformationBlockType13_r9 (pvalue->u.sib13_v920);

            stat = asn1PD_SystemInformationBlockType13_r9 (pctxt, pvalue->u.sib13_v920);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            pvalue->u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
            if (fragmented) {
               openType.data = 0; /* protect from release */
            }
            else {
               stat = pd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
               if (stat != 0) return LOG_RTERR (pctxt, stat);
            }

      }

      if (fragmented) {
         rtxCopyContext (pctxt, &lctxt);
         rtxMemFreePtr (pctxt, openType.data);
      }
      else if (pvalue->t < 13) {
         stat = pd_OpenTypeEnd (pctxt, openType.numocts, savedBitOffset);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

void asn1Init_SystemInformation_r8_IEs_sib_TypeAndInfo_element (
   SystemInformation_r8_IEs_sib_TypeAndInfo_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_SystemInformation_r8_IEs_sib_TypeAndInfo (OSCTXT* pctxt, SystemInformation_r8_IEs_sib_TypeAndInfo* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformation_r8_IEs_sib_TypeAndInfo"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CHOICE", xx1);

      stat = asn1PE_SystemInformation_r8_IEs_sib_TypeAndInfo_element (pctxt, ((SystemInformation_r8_IEs_sib_TypeAndInfo_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformation_r8_IEs_sib_TypeAndInfo (OSCTXT* pctxt, SystemInformation_r8_IEs_sib_TypeAndInfo* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SystemInformation_r8_IEs_sib_TypeAndInfo_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CHOICE", xx1);

      rtxDListAllocNodeAndData (pctxt, SystemInformation_r8_IEs_sib_TypeAndInfo_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SystemInformation_r8_IEs_sib_TypeAndInfo_element (pdata);

      stat = asn1PD_SystemInformation_r8_IEs_sib_TypeAndInfo_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

void asn1Init_SystemInformation_r8_IEs_sib_TypeAndInfo (
   SystemInformation_r8_IEs_sib_TypeAndInfo* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_SystemInformation_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, SystemInformation_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformation_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformation_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, SystemInformation_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_SystemInformation_v8a0_IEs (OSCTXT* pctxt, SystemInformation_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformation-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformation_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_SystemInformation_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformation_v8a0_IEs (OSCTXT* pctxt, SystemInformation_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformation-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_SystemInformation_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformation_v8a0_IEs (SystemInformation_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_SystemInformation_r8_IEs (OSCTXT* pctxt, SystemInformation_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformation-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformation_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sib_TypeAndInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "sib-TypeAndInfo");

   stat = asn1PE_SystemInformation_r8_IEs_sib_TypeAndInfo (pctxt, &pvalue->sib_TypeAndInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_SystemInformation_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformation_r8_IEs (OSCTXT* pctxt, SystemInformation_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformation-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode sib_TypeAndInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "sib-TypeAndInfo");

   stat = asn1PD_SystemInformation_r8_IEs_sib_TypeAndInfo (pctxt, &pvalue->sib_TypeAndInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_SystemInformation_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformation_r8_IEs (SystemInformation_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SystemInformation_r8_IEs_sib_TypeAndInfo (&pvalue->sib_TypeAndInfo);
   asn1Init_SystemInformation_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_SystemInformation_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, SystemInformation_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformation_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformation_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, SystemInformation_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_SystemInformation_criticalExtensions (OSCTXT* pctxt, SystemInformation_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformation_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* systemInformation_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "systemInformation-r8");

         stat = asn1PE_SystemInformation_r8_IEs (pctxt, pvalue->u.systemInformation_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_SystemInformation_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformation_criticalExtensions (OSCTXT* pctxt, SystemInformation_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* systemInformation_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "systemInformation-r8");

         pvalue->u.systemInformation_r8 = rtxMemAllocType (pctxt, 
            SystemInformation_r8_IEs);

         if (pvalue->u.systemInformation_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SystemInformation_r8_IEs (pvalue->u.systemInformation_r8);

         stat = asn1PD_SystemInformation_r8_IEs (pctxt, pvalue->u.systemInformation_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            SystemInformation_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_SystemInformation_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_SystemInformation_criticalExtensions (
   SystemInformation_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_SystemInformation (OSCTXT* pctxt, SystemInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformation");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformation"));

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_SystemInformation_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformation (OSCTXT* pctxt, SystemInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformation");

   /* decode root elements */
   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_SystemInformation_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformation (SystemInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SystemInformation_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_MCC (OSCTXT* pctxt, MCC* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MCC");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MCC"));

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MCC-MNC-Digit", xx1);

      stat = asn1PE_MCC_MNC_Digit (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MCC (OSCTXT* pctxt, MCC* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MCC");

   pvalue->n = 3;
   /* decode elements */

   if (pvalue->n > 3) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MCC-MNC-Digit", xx1);

      stat = asn1PD_MCC_MNC_Digit (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MCC (MCC* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_MNC (OSCTXT* pctxt, MNC* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MNC");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MNC"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(3), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MCC-MNC-Digit", xx1);

      stat = asn1PE_MCC_MNC_Digit (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MNC (OSCTXT* pctxt, MNC* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MNC");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 2;

   /* decode elements */

   if (pvalue->n > 3) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MCC-MNC-Digit", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (MCC_MNC_Digit));
      stat = asn1PD_MCC_MNC_Digit (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MNC (MNC* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_PLMN_Identity (OSCTXT* pctxt, PLMN_Identity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMN-Identity");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PLMN_Identity"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.mccPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode mcc */

   if (pvalue->m.mccPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "mcc");

      stat = asn1PE_MCC (pctxt, &pvalue->mcc);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode mnc */

   RTXCTXTPUSHELEMNAME (pctxt, "mnc");

   stat = asn1PE_MNC (pctxt, &pvalue->mnc);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PLMN_Identity (OSCTXT* pctxt, PLMN_Identity* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PLMN-Identity");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mcc */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mcc");

      pvalue->m.mccPresent = 1;

      stat = asn1PD_MCC (pctxt, &pvalue->mcc);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mnc */
   RTXCTXTPUSHELEMNAME (pctxt, "mnc");

   stat = asn1PD_MNC (pctxt, &pvalue->mnc);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PLMN_Identity (PLMN_Identity* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_MCC (&pvalue->mcc);
   asn1Init_MNC (&pvalue->mnc);
}

EXTERN int asn1PE_PLMN_IdentityInfo (OSCTXT* pctxt, PLMN_IdentityInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMN-IdentityInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PLMN_IdentityInfo"));

   /* encode plmn_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "plmn-Identity");

   stat = asn1PE_PLMN_Identity (pctxt, &pvalue->plmn_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellReservedForOperatorUse */

   RTXCTXTPUSHELEMNAME (pctxt, "cellReservedForOperatorUse");

   stat = asn1PE_PLMN_IdentityInfo_cellReservedForOperatorUse (pctxt, pvalue->cellReservedForOperatorUse);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PLMN_IdentityInfo (OSCTXT* pctxt, PLMN_IdentityInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMN-IdentityInfo");

   /* decode root elements */
   /* decode plmn_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "plmn-Identity");

   stat = asn1PD_PLMN_Identity (pctxt, &pvalue->plmn_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellReservedForOperatorUse */
   RTXCTXTPUSHELEMNAME (pctxt, "cellReservedForOperatorUse");

   stat = asn1PD_PLMN_IdentityInfo_cellReservedForOperatorUse (pctxt, &pvalue->cellReservedForOperatorUse);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PLMN_IdentityInfo (PLMN_IdentityInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_PLMN_Identity (&pvalue->plmn_Identity);
}

EXTERN int asn1PE_PLMN_IdentityList (OSCTXT* pctxt, PLMN_IdentityList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMN-IdentityList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PLMN_IdentityList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(6), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PLMN-IdentityInfo", xx1);

      stat = asn1PE_PLMN_IdentityInfo (pctxt, ((PLMN_IdentityInfo*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PLMN_IdentityList (OSCTXT* pctxt, PLMN_IdentityList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMN-IdentityList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(6), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PLMN_IdentityInfo* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PLMN-IdentityInfo", xx1);

      rtxDListAllocNodeAndData (pctxt, PLMN_IdentityInfo, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PLMN_IdentityInfo (pdata);

      stat = asn1PD_PLMN_IdentityInfo (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PLMN_IdentityList (PLMN_IdentityList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_SystemInformationBlockType1_cellAccessRelatedInfo (OSCTXT* pctxt, SystemInformationBlockType1_cellAccessRelatedInfo* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType1_cellAccessRelatedInfo"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.csg_IdentityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode plmn_IdentityList */

   RTXCTXTPUSHELEMNAME (pctxt, "plmn-IdentityList");

   stat = asn1PE_PLMN_IdentityList (pctxt, &pvalue->plmn_IdentityList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode trackingAreaCode */

   RTXCTXTPUSHELEMNAME (pctxt, "trackingAreaCode");

   stat = asn1PE_TrackingAreaCode (pctxt, pvalue->trackingAreaCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "cellIdentity");

   stat = asn1PE_CellIdentity (pctxt, pvalue->cellIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellBarred */

   RTXCTXTPUSHELEMNAME (pctxt, "cellBarred");

   stat = asn1PE_SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred (pctxt, pvalue->cellBarred);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode intraFreqReselection */

   RTXCTXTPUSHELEMNAME (pctxt, "intraFreqReselection");

   stat = asn1PE_SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection (pctxt, pvalue->intraFreqReselection);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode csg_Indication */

   RTXCTXTPUSHELEMNAME (pctxt, "csg-Indication");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->csg_Indication);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode csg_Identity */

   if (pvalue->m.csg_IdentityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "csg-Identity");

      stat = asn1PE_CSG_Identity (pctxt, pvalue->csg_Identity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType1_cellAccessRelatedInfo (OSCTXT* pctxt, SystemInformationBlockType1_cellAccessRelatedInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode plmn_IdentityList */
   RTXCTXTPUSHELEMNAME (pctxt, "plmn-IdentityList");

   stat = asn1PD_PLMN_IdentityList (pctxt, &pvalue->plmn_IdentityList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode trackingAreaCode */
   RTXCTXTPUSHELEMNAME (pctxt, "trackingAreaCode");

   stat = asn1PD_TrackingAreaCode (pctxt, &pvalue->trackingAreaCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "cellIdentity");

   stat = asn1PD_CellIdentity (pctxt, &pvalue->cellIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellBarred */
   RTXCTXTPUSHELEMNAME (pctxt, "cellBarred");

   stat = asn1PD_SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred (pctxt, &pvalue->cellBarred);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode intraFreqReselection */
   RTXCTXTPUSHELEMNAME (pctxt, "intraFreqReselection");

   stat = asn1PD_SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection (pctxt, &pvalue->intraFreqReselection);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode csg_Indication */
   RTXCTXTPUSHELEMNAME (pctxt, "csg-Indication");

   stat = DEC_BIT (pctxt, &pvalue->csg_Indication);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode csg_Identity */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "csg-Identity");

      pvalue->m.csg_IdentityPresent = 1;

      stat = asn1PD_CSG_Identity (pctxt, &pvalue->csg_Identity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_SystemInformationBlockType1_cellAccessRelatedInfo (
   SystemInformationBlockType1_cellAccessRelatedInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PLMN_IdentityList (&pvalue->plmn_IdentityList);
   asn1Init_TrackingAreaCode (&pvalue->trackingAreaCode);
   asn1Init_CellIdentity (&pvalue->cellIdentity);
   asn1Init_CSG_Identity (&pvalue->csg_Identity);
}

EXTERN int asn1PE_SystemInformationBlockType1_cellSelectionInfo (OSCTXT* pctxt, SystemInformationBlockType1_cellSelectionInfo* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType1_cellSelectionInfo"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.q_RxLevMinOffsetPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode q_RxLevMin */

   RTXCTXTPUSHELEMNAME (pctxt, "q-RxLevMin");

   stat = asn1PE_Q_RxLevMin (pctxt, pvalue->q_RxLevMin);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode q_RxLevMinOffset */

   if (pvalue->m.q_RxLevMinOffsetPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "q-RxLevMinOffset");

      if ( (pvalue->q_RxLevMinOffset >= OSUINTCONST(1) && pvalue->q_RxLevMinOffset
          <= OSUINTCONST(8)) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->q_RxLevMinOffset, OSUINTCONST(1), OSUINTCONST(8));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->q_RxLevMinOffset);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType1_cellSelectionInfo (OSCTXT* pctxt, SystemInformationBlockType1_cellSelectionInfo* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode q_RxLevMin */
   RTXCTXTPUSHELEMNAME (pctxt, "q-RxLevMin");

   stat = asn1PD_Q_RxLevMin (pctxt, &pvalue->q_RxLevMin);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode q_RxLevMinOffset */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "q-RxLevMinOffset");

      pvalue->m.q_RxLevMinOffsetPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->q_RxLevMinOffset, OSUINTCONST(1), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_SystemInformationBlockType1_cellSelectionInfo (
   SystemInformationBlockType1_cellSelectionInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_SIB_MappingInfo (OSCTXT* pctxt, SIB_MappingInfo* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SIB-MappingInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SIB_MappingInfo"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(31), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SIB-Type", xx1);

      stat = asn1PE_SIB_Type (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SIB_MappingInfo (OSCTXT* pctxt, SIB_MappingInfo* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SIB-MappingInfo");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 5);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   if (pvalue->n > 31) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SIB-Type", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (SIB_Type));
      stat = asn1PD_SIB_Type (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SIB_MappingInfo (SIB_MappingInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_SchedulingInfo (OSCTXT* pctxt, SchedulingInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SchedulingInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SchedulingInfo"));

   /* encode si_Periodicity */

   RTXCTXTPUSHELEMNAME (pctxt, "si-Periodicity");

   stat = asn1PE_SchedulingInfo_si_Periodicity (pctxt, pvalue->si_Periodicity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sib_MappingInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "sib-MappingInfo");

   stat = asn1PE_SIB_MappingInfo (pctxt, &pvalue->sib_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SchedulingInfo (OSCTXT* pctxt, SchedulingInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SchedulingInfo");

   /* decode root elements */
   /* decode si_Periodicity */
   RTXCTXTPUSHELEMNAME (pctxt, "si-Periodicity");

   stat = asn1PD_SchedulingInfo_si_Periodicity (pctxt, &pvalue->si_Periodicity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sib_MappingInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "sib-MappingInfo");

   stat = asn1PD_SIB_MappingInfo (pctxt, &pvalue->sib_MappingInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SchedulingInfo (SchedulingInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SIB_MappingInfo (&pvalue->sib_MappingInfo);
}

EXTERN int asn1PE_SchedulingInfoList (OSCTXT* pctxt, SchedulingInfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SchedulingInfoList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SchedulingInfoList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SchedulingInfo", xx1);

      stat = asn1PE_SchedulingInfo (pctxt, ((SchedulingInfo*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SchedulingInfoList (OSCTXT* pctxt, SchedulingInfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SchedulingInfoList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SchedulingInfo* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SchedulingInfo", xx1);

      rtxDListAllocNodeAndData (pctxt, SchedulingInfo, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SchedulingInfo (pdata);

      stat = asn1PD_SchedulingInfo (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SchedulingInfoList (SchedulingInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_TDD_Config (OSCTXT* pctxt, TDD_Config* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TDD-Config");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("TDD_Config"));

   /* encode subframeAssignment */

   RTXCTXTPUSHELEMNAME (pctxt, "subframeAssignment");

   stat = asn1PE_TDD_Config_subframeAssignment (pctxt, pvalue->subframeAssignment);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode specialSubframePatterns */

   RTXCTXTPUSHELEMNAME (pctxt, "specialSubframePatterns");

   stat = asn1PE_TDD_Config_specialSubframePatterns (pctxt, pvalue->specialSubframePatterns);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_TDD_Config (OSCTXT* pctxt, TDD_Config* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TDD-Config");

   /* decode root elements */
   /* decode subframeAssignment */
   RTXCTXTPUSHELEMNAME (pctxt, "subframeAssignment");

   stat = asn1PD_TDD_Config_subframeAssignment (pctxt, &pvalue->subframeAssignment);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode specialSubframePatterns */
   RTXCTXTPUSHELEMNAME (pctxt, "specialSubframePatterns");

   stat = asn1PD_TDD_Config_specialSubframePatterns (pctxt, &pvalue->specialSubframePatterns);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_CellSelectionInfo_v920 (OSCTXT* pctxt, CellSelectionInfo_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellSelectionInfo-v920");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellSelectionInfo_v920"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.q_QualMinOffset_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode q_QualMin_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "q-QualMin-r9");

   stat = asn1PE_Q_QualMin_r9 (pctxt, pvalue->q_QualMin_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode q_QualMinOffset_r9 */

   if (pvalue->m.q_QualMinOffset_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "q-QualMinOffset-r9");

      if ( (pvalue->q_QualMinOffset_r9 >= OSUINTCONST(1) && pvalue->
         q_QualMinOffset_r9 <= OSUINTCONST(8)) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->q_QualMinOffset_r9, OSUINTCONST(1), OSUINTCONST(8));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->q_QualMinOffset_r9);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellSelectionInfo_v920 (OSCTXT* pctxt, CellSelectionInfo_v920* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CellSelectionInfo-v920");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode q_QualMin_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "q-QualMin-r9");

   stat = asn1PD_Q_QualMin_r9 (pctxt, &pvalue->q_QualMin_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode q_QualMinOffset_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "q-QualMinOffset-r9");

      pvalue->m.q_QualMinOffset_r9Present = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->q_QualMinOffset_r9, OSUINTCONST(1), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellSelectionInfo_v920 (CellSelectionInfo_v920* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_SystemInformationBlockType1_v920_IEs_nonCriticalExtension (OSCTXT* pctxt, SystemInformationBlockType1_v920_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType1_v920_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType1_v920_IEs_nonCriticalExtension (OSCTXT* pctxt, SystemInformationBlockType1_v920_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_SystemInformationBlockType1_v920_IEs (OSCTXT* pctxt, SystemInformationBlockType1_v920_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType1-v920-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType1_v920_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ims_EmergencySupport_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellSelectionInfo_v920Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ims_EmergencySupport_r9 */

   if (pvalue->m.ims_EmergencySupport_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "ims-EmergencySupport-r9");

      stat = asn1PE_SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9 (pctxt, pvalue->ims_EmergencySupport_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cellSelectionInfo_v920 */

   if (pvalue->m.cellSelectionInfo_v920Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellSelectionInfo-v920");

      stat = asn1PE_CellSelectionInfo_v920 (pctxt, &pvalue->cellSelectionInfo_v920);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_SystemInformationBlockType1_v920_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType1_v920_IEs (OSCTXT* pctxt, SystemInformationBlockType1_v920_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType1-v920-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ims_EmergencySupport_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ims-EmergencySupport-r9");

      pvalue->m.ims_EmergencySupport_r9Present = 1;

      stat = asn1PD_SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9 (pctxt, &pvalue->ims_EmergencySupport_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cellSelectionInfo_v920 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellSelectionInfo-v920");

      pvalue->m.cellSelectionInfo_v920Present = 1;

      stat = asn1PD_CellSelectionInfo_v920 (pctxt, &pvalue->cellSelectionInfo_v920);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_SystemInformationBlockType1_v920_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType1_v920_IEs (
   SystemInformationBlockType1_v920_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CellSelectionInfo_v920 (&pvalue->cellSelectionInfo_v920);
}

EXTERN int asn1PE_SystemInformationBlockType1_v890_IEs (OSCTXT* pctxt, SystemInformationBlockType1_v890_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType1-v890-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType1_v890_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_SystemInformationBlockType1_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType1_v890_IEs (OSCTXT* pctxt, SystemInformationBlockType1_v890_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType1-v890-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_SystemInformationBlockType1_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType1_v890_IEs (
   SystemInformationBlockType1_v890_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   asn1Init_SystemInformationBlockType1_v920_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_SystemInformationBlockType1 (OSCTXT* pctxt, SystemInformationBlockType1* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType1");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInformationBlockType1"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.p_MaxPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.tdd_ConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cellAccessRelatedInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "cellAccessRelatedInfo");

   stat = asn1PE_SystemInformationBlockType1_cellAccessRelatedInfo (pctxt, &pvalue->cellAccessRelatedInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellSelectionInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "cellSelectionInfo");

   stat = asn1PE_SystemInformationBlockType1_cellSelectionInfo (pctxt, &pvalue->cellSelectionInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode p_Max */

   if (pvalue->m.p_MaxPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "p-Max");

      stat = asn1PE_P_Max (pctxt, pvalue->p_Max);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode freqBandIndicator */

   RTXCTXTPUSHELEMNAME (pctxt, "freqBandIndicator");

   if ( (pvalue->freqBandIndicator >= OSUINTCONST(1) && pvalue->freqBandIndicator
       <= OSUINTCONST(64)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->freqBandIndicator, OSUINTCONST(1), OSUINTCONST(64));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->freqBandIndicator);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode schedulingInfoList */

   RTXCTXTPUSHELEMNAME (pctxt, "schedulingInfoList");

   stat = asn1PE_SchedulingInfoList (pctxt, &pvalue->schedulingInfoList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode tdd_Config */

   if (pvalue->m.tdd_ConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "tdd-Config");

      stat = asn1PE_TDD_Config (pctxt, &pvalue->tdd_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode si_WindowLength */

   RTXCTXTPUSHELEMNAME (pctxt, "si-WindowLength");

   stat = asn1PE_SystemInformationBlockType1_si_WindowLength (pctxt, pvalue->si_WindowLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode systemInfoValueTag */

   RTXCTXTPUSHELEMNAME (pctxt, "systemInfoValueTag");

   if ( (pvalue->systemInfoValueTag <= OSUINTCONST(31)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->systemInfoValueTag, OSUINTCONST(0), OSUINTCONST(31));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->systemInfoValueTag);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_SystemInformationBlockType1_v890_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInformationBlockType1 (OSCTXT* pctxt, SystemInformationBlockType1* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInformationBlockType1");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cellAccessRelatedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "cellAccessRelatedInfo");

   stat = asn1PD_SystemInformationBlockType1_cellAccessRelatedInfo (pctxt, &pvalue->cellAccessRelatedInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellSelectionInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "cellSelectionInfo");

   stat = asn1PD_SystemInformationBlockType1_cellSelectionInfo (pctxt, &pvalue->cellSelectionInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode p_Max */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "p-Max");

      pvalue->m.p_MaxPresent = 1;

      stat = asn1PD_P_Max (pctxt, &pvalue->p_Max);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode freqBandIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "freqBandIndicator");

   stat = pd_ConsUInt8 (pctxt, &pvalue->freqBandIndicator, OSUINTCONST(1), OSUINTCONST(64));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode schedulingInfoList */
   RTXCTXTPUSHELEMNAME (pctxt, "schedulingInfoList");

   stat = asn1PD_SchedulingInfoList (pctxt, &pvalue->schedulingInfoList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tdd_Config */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tdd-Config");

      pvalue->m.tdd_ConfigPresent = 1;

      stat = asn1PD_TDD_Config (pctxt, &pvalue->tdd_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode si_WindowLength */
   RTXCTXTPUSHELEMNAME (pctxt, "si-WindowLength");

   stat = asn1PD_SystemInformationBlockType1_si_WindowLength (pctxt, &pvalue->si_WindowLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode systemInfoValueTag */
   RTXCTXTPUSHELEMNAME (pctxt, "systemInfoValueTag");

   stat = pd_ConsUInt8 (pctxt, &pvalue->systemInfoValueTag, OSUINTCONST(0), OSUINTCONST(31));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_SystemInformationBlockType1_v890_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInformationBlockType1 (SystemInformationBlockType1* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SystemInformationBlockType1_cellAccessRelatedInfo (&pvalue->cellAccessRelatedInfo);
   asn1Init_SystemInformationBlockType1_cellSelectionInfo (&pvalue->cellSelectionInfo);
   asn1Init_SchedulingInfoList (&pvalue->schedulingInfoList);
   asn1Init_SystemInformationBlockType1_v890_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_BCCH_DL_SCH_MessageType_c1 (OSCTXT* pctxt, BCCH_DL_SCH_MessageType_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("BCCH_DL_SCH_MessageType_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* systemInformation */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "systemInformation");

         stat = asn1PE_SystemInformation (pctxt, pvalue->u.systemInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* systemInformationBlockType1 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "systemInformationBlockType1");

         stat = asn1PE_SystemInformationBlockType1 (pctxt, pvalue->u.systemInformationBlockType1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BCCH_DL_SCH_MessageType_c1 (OSCTXT* pctxt, BCCH_DL_SCH_MessageType_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* systemInformation */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "systemInformation");

         pvalue->u.systemInformation = rtxMemAllocType (pctxt, 
            SystemInformation);

         if (pvalue->u.systemInformation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SystemInformation (pvalue->u.systemInformation);

         stat = asn1PD_SystemInformation (pctxt, pvalue->u.systemInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* systemInformationBlockType1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "systemInformationBlockType1");

         pvalue->u.systemInformationBlockType1 = rtxMemAllocType (pctxt, 
            SystemInformationBlockType1);

         if (pvalue->u.systemInformationBlockType1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SystemInformationBlockType1 (pvalue->u.systemInformationBlockType1);

         stat = asn1PD_SystemInformationBlockType1 (pctxt, pvalue->u.systemInformationBlockType1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_BCCH_DL_SCH_MessageType_c1 (BCCH_DL_SCH_MessageType_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_BCCH_DL_SCH_MessageType_messageClassExtension (OSCTXT* pctxt, BCCH_DL_SCH_MessageType_messageClassExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("BCCH_DL_SCH_MessageType_messageClassExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BCCH_DL_SCH_MessageType_messageClassExtension (OSCTXT* pctxt, BCCH_DL_SCH_MessageType_messageClassExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_BCCH_DL_SCH_MessageType (OSCTXT* pctxt, BCCH_DL_SCH_MessageType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BCCH-DL-SCH-MessageType");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BCCH_DL_SCH_MessageType"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_BCCH_DL_SCH_MessageType_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* messageClassExtension */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "messageClassExtension");

         stat = asn1PE_BCCH_DL_SCH_MessageType_messageClassExtension (pctxt, pvalue->u.messageClassExtension);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BCCH_DL_SCH_MessageType (OSCTXT* pctxt, BCCH_DL_SCH_MessageType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "BCCH-DL-SCH-MessageType");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, BCCH_DL_SCH_MessageType_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BCCH_DL_SCH_MessageType_c1 (pvalue->u.c1);

         stat = asn1PD_BCCH_DL_SCH_MessageType_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* messageClassExtension */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "messageClassExtension");

         pvalue->u.messageClassExtension = rtxMemAllocTypeZ (pctxt, 
            BCCH_DL_SCH_MessageType_messageClassExtension);

         if (pvalue->u.messageClassExtension == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_BCCH_DL_SCH_MessageType_messageClassExtension (pctxt, pvalue->u.messageClassExtension);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_BCCH_DL_SCH_MessageType (BCCH_DL_SCH_MessageType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_BCCH_DL_SCH_Message (OSCTXT* pctxt, BCCH_DL_SCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BCCH-DL-SCH-Message");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BCCH_DL_SCH_Message"));

   /* encode message */

   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PE_BCCH_DL_SCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BCCH_DL_SCH_Message (OSCTXT* pctxt, BCCH_DL_SCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BCCH-DL-SCH-Message");

   /* decode root elements */
   /* decode message */
   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PD_BCCH_DL_SCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_BCCH_DL_SCH_Message (BCCH_DL_SCH_Message* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_BCCH_DL_SCH_MessageType (&pvalue->message);
}

EXTERN int asn1PE_CommonSF_AllocPatternList_r9 (OSCTXT* pctxt, CommonSF_AllocPatternList_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CommonSF-AllocPatternList-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CommonSF_AllocPatternList_r9"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MBSFN-SubframeConfig", xx1);

      stat = asn1PE_MBSFN_SubframeConfig (pctxt, ((MBSFN_SubframeConfig*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CommonSF_AllocPatternList_r9 (OSCTXT* pctxt, CommonSF_AllocPatternList_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CommonSF-AllocPatternList-r9");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MBSFN_SubframeConfig* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MBSFN-SubframeConfig", xx1);

      rtxDListAllocNodeAndData (pctxt, MBSFN_SubframeConfig, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MBSFN_SubframeConfig (pdata);

      stat = asn1PD_MBSFN_SubframeConfig (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CommonSF_AllocPatternList_r9 (
   CommonSF_AllocPatternList_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_PMCH_Config_r9 (OSCTXT* pctxt, PMCH_Config_r9* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PMCH-Config-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PMCH_Config_r9"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sf_AllocEnd_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "sf-AllocEnd-r9");

   if ( (pvalue->sf_AllocEnd_r9 <= OSUINTCONST(1535)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->sf_AllocEnd_r9, OSUINTCONST(0), OSUINTCONST(1535));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->sf_AllocEnd_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dataMCS_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "dataMCS-r9");

   if ( (pvalue->dataMCS_r9 <= OSUINTCONST(28)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->dataMCS_r9, OSUINTCONST(0), OSUINTCONST(28));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->dataMCS_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode mch_SchedulingPeriod_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "mch-SchedulingPeriod-r9");

   stat = asn1PE_PMCH_Config_r9_mch_SchedulingPeriod_r9 (pctxt, pvalue->mch_SchedulingPeriod_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PMCH_Config_r9 (OSCTXT* pctxt, PMCH_Config_r9* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PMCH-Config-r9");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode sf_AllocEnd_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "sf-AllocEnd-r9");

   stat = pd_ConsUInt16 (pctxt, &pvalue->sf_AllocEnd_r9, OSUINTCONST(0), OSUINTCONST(1535));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dataMCS_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "dataMCS-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->dataMCS_r9, OSUINTCONST(0), OSUINTCONST(28));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mch_SchedulingPeriod_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "mch-SchedulingPeriod-r9");

   stat = asn1PD_PMCH_Config_r9_mch_SchedulingPeriod_r9 (pctxt, &pvalue->mch_SchedulingPeriod_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PMCH_Config_r9 (PMCH_Config_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_TMGI_r9_plmn_Id_r9 (OSCTXT* pctxt, TMGI_r9_plmn_Id_r9* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("TMGI_r9_plmn_Id_r9"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* plmn_Index_r9 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "plmn-Index-r9");

         if ( (pvalue->u.plmn_Index_r9 >= OSUINTCONST(1) && pvalue->u.plmn_Index_r9
             <= OSUINTCONST(6)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.plmn_Index_r9, OSUINTCONST(1), OSUINTCONST(6));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.plmn_Index_r9);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* explicitValue_r9 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "explicitValue-r9");

         stat = asn1PE_PLMN_Identity (pctxt, pvalue->u.explicitValue_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_TMGI_r9_plmn_Id_r9 (OSCTXT* pctxt, TMGI_r9_plmn_Id_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* plmn_Index_r9 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "plmn-Index-r9");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.plmn_Index_r9, OSUINTCONST(1), OSUINTCONST(6));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* explicitValue_r9 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "explicitValue-r9");

         pvalue->u.explicitValue_r9 = rtxMemAllocType (pctxt, PLMN_Identity);

         if (pvalue->u.explicitValue_r9 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PLMN_Identity (pvalue->u.explicitValue_r9);

         stat = asn1PD_PLMN_Identity (pctxt, pvalue->u.explicitValue_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_TMGI_r9_plmn_Id_r9 (TMGI_r9_plmn_Id_r9* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_TMGI_r9 (OSCTXT* pctxt, TMGI_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TMGI-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("TMGI_r9"));

   /* encode plmn_Id_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "plmn-Id-r9");

   stat = asn1PE_TMGI_r9_plmn_Id_r9 (pctxt, &pvalue->plmn_Id_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode serviceId_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "serviceId-r9");

   stat = asn1PE_TMGI_r9_serviceId_r9 (pctxt, &pvalue->serviceId_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_TMGI_r9 (OSCTXT* pctxt, TMGI_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TMGI-r9");

   /* decode root elements */
   /* decode plmn_Id_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "plmn-Id-r9");

   stat = asn1PD_TMGI_r9_plmn_Id_r9 (pctxt, &pvalue->plmn_Id_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode serviceId_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "serviceId-r9");

   stat = asn1PD_TMGI_r9_serviceId_r9 (pctxt, &pvalue->serviceId_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_TMGI_r9 (TMGI_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_TMGI_r9_plmn_Id_r9 (&pvalue->plmn_Id_r9);
   asn1Init_TMGI_r9_serviceId_r9 (&pvalue->serviceId_r9);
}

EXTERN int asn1PE_MBMS_SessionInfo_r9 (OSCTXT* pctxt, MBMS_SessionInfo_r9* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMS-SessionInfo-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBMS_SessionInfo_r9"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.sessionId_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode tmgi_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "tmgi-r9");

   stat = asn1PE_TMGI_r9 (pctxt, &pvalue->tmgi_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sessionId_r9 */

   if (pvalue->m.sessionId_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "sessionId-r9");

      stat = asn1PE_MBMS_SessionInfo_r9_sessionId_r9 (pctxt, &pvalue->sessionId_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode logicalChannelIdentity_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelIdentity-r9");

   if ( (pvalue->logicalChannelIdentity_r9 <= OSUINTCONST(28)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->logicalChannelIdentity_r9, OSUINTCONST(0), OSUINTCONST(28));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->logicalChannelIdentity_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBMS_SessionInfo_r9 (OSCTXT* pctxt, MBMS_SessionInfo_r9* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMS-SessionInfo-r9");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tmgi_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "tmgi-r9");

   stat = asn1PD_TMGI_r9 (pctxt, &pvalue->tmgi_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sessionId_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sessionId-r9");

      pvalue->m.sessionId_r9Present = 1;

      stat = asn1PD_MBMS_SessionInfo_r9_sessionId_r9 (pctxt, &pvalue->sessionId_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode logicalChannelIdentity_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelIdentity-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->logicalChannelIdentity_r9, OSUINTCONST(0), OSUINTCONST(28));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MBMS_SessionInfo_r9 (MBMS_SessionInfo_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_TMGI_r9 (&pvalue->tmgi_r9);
   asn1Init_MBMS_SessionInfo_r9_sessionId_r9 (&pvalue->sessionId_r9);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_MBMS_SessionInfoList_r9 (OSCTXT* pctxt, MBMS_SessionInfoList_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMS-SessionInfoList-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBMS_SessionInfoList_r9"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(29), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MBMS-SessionInfo-r9", xx1);

      stat = asn1PE_MBMS_SessionInfo_r9 (pctxt, ((MBMS_SessionInfo_r9*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBMS_SessionInfoList_r9 (OSCTXT* pctxt, MBMS_SessionInfoList_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMS-SessionInfoList-r9");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(29), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MBMS_SessionInfo_r9* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MBMS-SessionInfo-r9", xx1);

      rtxDListAllocNodeAndData (pctxt, MBMS_SessionInfo_r9, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MBMS_SessionInfo_r9 (pdata);

      stat = asn1PD_MBMS_SessionInfo_r9 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MBMS_SessionInfoList_r9 (MBMS_SessionInfoList_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_PMCH_Info_r9 (OSCTXT* pctxt, PMCH_Info_r9* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PMCH-Info-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PMCH_Info_r9"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pmch_Config_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "pmch-Config-r9");

   stat = asn1PE_PMCH_Config_r9 (pctxt, &pvalue->pmch_Config_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode mbms_SessionInfoList_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "mbms-SessionInfoList-r9");

   stat = asn1PE_MBMS_SessionInfoList_r9 (pctxt, &pvalue->mbms_SessionInfoList_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PMCH_Info_r9 (OSCTXT* pctxt, PMCH_Info_r9* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PMCH-Info-r9");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode pmch_Config_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "pmch-Config-r9");

   stat = asn1PD_PMCH_Config_r9 (pctxt, &pvalue->pmch_Config_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mbms_SessionInfoList_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "mbms-SessionInfoList-r9");

   stat = asn1PD_MBMS_SessionInfoList_r9 (pctxt, &pvalue->mbms_SessionInfoList_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PMCH_Info_r9 (PMCH_Info_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_PMCH_Config_r9 (&pvalue->pmch_Config_r9);
   asn1Init_MBMS_SessionInfoList_r9 (&pvalue->mbms_SessionInfoList_r9);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_PMCH_InfoList_r9 (OSCTXT* pctxt, PMCH_InfoList_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "PMCH-InfoList-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PMCH_InfoList_r9"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(15), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PMCH-Info-r9", xx1);

      stat = asn1PE_PMCH_Info_r9 (pctxt, ((PMCH_Info_r9*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PMCH_InfoList_r9 (OSCTXT* pctxt, PMCH_InfoList_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PMCH-InfoList-r9");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(15), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PMCH_Info_r9* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PMCH-Info-r9", xx1);

      rtxDListAllocNodeAndData (pctxt, PMCH_Info_r9, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PMCH_Info_r9 (pdata);

      stat = asn1PD_PMCH_Info_r9 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PMCH_InfoList_r9 (PMCH_InfoList_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_MBSFNAreaConfiguration_v930_IEs_nonCriticalExtension (OSCTXT* pctxt, MBSFNAreaConfiguration_v930_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFNAreaConfiguration_v930_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFNAreaConfiguration_v930_IEs_nonCriticalExtension (OSCTXT* pctxt, MBSFNAreaConfiguration_v930_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_MBSFNAreaConfiguration_v930_IEs (OSCTXT* pctxt, MBSFNAreaConfiguration_v930_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBSFNAreaConfiguration-v930-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFNAreaConfiguration_v930_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_MBSFNAreaConfiguration_v930_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFNAreaConfiguration_v930_IEs (OSCTXT* pctxt, MBSFNAreaConfiguration_v930_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "MBSFNAreaConfiguration-v930-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_MBSFNAreaConfiguration_v930_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MBSFNAreaConfiguration_v930_IEs (
   MBSFNAreaConfiguration_v930_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_MBSFNAreaConfiguration_r9 (OSCTXT* pctxt, MBSFNAreaConfiguration_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBSFNAreaConfiguration-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFNAreaConfiguration_r9"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode commonSF_Alloc_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "commonSF-Alloc-r9");

   stat = asn1PE_CommonSF_AllocPatternList_r9 (pctxt, &pvalue->commonSF_Alloc_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode commonSF_AllocPeriod_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "commonSF-AllocPeriod-r9");

   stat = asn1PE_MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9 (pctxt, pvalue->commonSF_AllocPeriod_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pmch_InfoList_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "pmch-InfoList-r9");

   stat = asn1PE_PMCH_InfoList_r9 (pctxt, &pvalue->pmch_InfoList_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_MBSFNAreaConfiguration_v930_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFNAreaConfiguration_r9 (OSCTXT* pctxt, MBSFNAreaConfiguration_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBSFNAreaConfiguration-r9");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode commonSF_Alloc_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "commonSF-Alloc-r9");

   stat = asn1PD_CommonSF_AllocPatternList_r9 (pctxt, &pvalue->commonSF_Alloc_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode commonSF_AllocPeriod_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "commonSF-AllocPeriod-r9");

   stat = asn1PD_MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9 (pctxt, &pvalue->commonSF_AllocPeriod_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pmch_InfoList_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "pmch-InfoList-r9");

   stat = asn1PD_PMCH_InfoList_r9 (pctxt, &pvalue->pmch_InfoList_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_MBSFNAreaConfiguration_v930_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MBSFNAreaConfiguration_r9 (MBSFNAreaConfiguration_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CommonSF_AllocPatternList_r9 (&pvalue->commonSF_Alloc_r9);
   asn1Init_PMCH_InfoList_r9 (&pvalue->pmch_InfoList_r9);
   asn1Init_MBSFNAreaConfiguration_v930_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_MCCH_MessageType_c1 (OSCTXT* pctxt, MCCH_MessageType_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MCCH_MessageType_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* mbsfnAreaConfiguration_r9 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "mbsfnAreaConfiguration-r9");

         stat = asn1PE_MBSFNAreaConfiguration_r9 (pctxt, pvalue->u.mbsfnAreaConfiguration_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MCCH_MessageType_c1 (OSCTXT* pctxt, MCCH_MessageType_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* mbsfnAreaConfiguration_r9 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "mbsfnAreaConfiguration-r9");

         pvalue->u.mbsfnAreaConfiguration_r9 = rtxMemAllocType (pctxt, 
            MBSFNAreaConfiguration_r9);

         if (pvalue->u.mbsfnAreaConfiguration_r9 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MBSFNAreaConfiguration_r9 (pvalue->u.mbsfnAreaConfiguration_r9);

         stat = asn1PD_MBSFNAreaConfiguration_r9 (pctxt, pvalue->u.mbsfnAreaConfiguration_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_MCCH_MessageType_c1 (MCCH_MessageType_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MCCH_MessageType_messageClassExtension (OSCTXT* pctxt, MCCH_MessageType_messageClassExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MCCH_MessageType_messageClassExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MCCH_MessageType_messageClassExtension (OSCTXT* pctxt, MCCH_MessageType_messageClassExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_MCCH_MessageType (OSCTXT* pctxt, MCCH_MessageType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MCCH-MessageType");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MCCH_MessageType"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_MCCH_MessageType_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* messageClassExtension */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "messageClassExtension");

         stat = asn1PE_MCCH_MessageType_messageClassExtension (pctxt, pvalue->u.messageClassExtension);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MCCH_MessageType (OSCTXT* pctxt, MCCH_MessageType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "MCCH-MessageType");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, MCCH_MessageType_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MCCH_MessageType_c1 (pvalue->u.c1);

         stat = asn1PD_MCCH_MessageType_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* messageClassExtension */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "messageClassExtension");

         pvalue->u.messageClassExtension = rtxMemAllocTypeZ (pctxt, 
            MCCH_MessageType_messageClassExtension);

         if (pvalue->u.messageClassExtension == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_MCCH_MessageType_messageClassExtension (pctxt, pvalue->u.messageClassExtension);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MCCH_MessageType (MCCH_MessageType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MCCH_Message (OSCTXT* pctxt, MCCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MCCH-Message");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MCCH_Message"));

   /* encode message */

   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PE_MCCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MCCH_Message (OSCTXT* pctxt, MCCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MCCH-Message");

   /* decode root elements */
   /* decode message */
   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PD_MCCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MCCH_Message (MCCH_Message* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_MCCH_MessageType (&pvalue->message);
}

EXTERN int asn1PE_S_TMSI (OSCTXT* pctxt, S_TMSI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "S-TMSI");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("S_TMSI"));

   /* encode mmec */

   RTXCTXTPUSHELEMNAME (pctxt, "mmec");

   stat = asn1PE_MMEC (pctxt, pvalue->mmec);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode m_TMSI */

   RTXCTXTPUSHELEMNAME (pctxt, "m-TMSI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(32), OSUINTCONST(32), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->m_TMSI, OSUINTCONST(32), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_S_TMSI (OSCTXT* pctxt, S_TMSI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "S-TMSI");

   /* decode root elements */
   /* decode mmec */
   RTXCTXTPUSHELEMNAME (pctxt, "mmec");

   stat = asn1PD_MMEC (pctxt, &pvalue->mmec);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode m_TMSI */
   RTXCTXTPUSHELEMNAME (pctxt, "m-TMSI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(32), OSUINTCONST(32), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->m_TMSI
      , OSUINTCONST(32), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_S_TMSI (S_TMSI* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_MMEC (&pvalue->mmec);
   pvalue->m_TMSI.numbits = 0;
}

EXTERN int asn1PE_IMSI (OSCTXT* pctxt, IMSI* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "IMSI");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IMSI"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(21), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "IMSI-Digit", xx1);

      stat = asn1PE_IMSI_Digit (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IMSI (OSCTXT* pctxt, IMSI* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IMSI");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 6;

   /* decode elements */

   if (pvalue->n > 21) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "IMSI-Digit", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (IMSI_Digit));
      stat = asn1PD_IMSI_Digit (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_IMSI (IMSI* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_PagingUE_Identity (OSCTXT* pctxt, PagingUE_Identity* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PagingUE-Identity");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PagingUE_Identity"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* s_TMSI */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "s-TMSI");

            stat = asn1PE_S_TMSI (pctxt, pvalue->u.s_TMSI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* imsi */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "imsi");

            stat = asn1PE_IMSI (pctxt, pvalue->u.imsi);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PagingUE_Identity (OSCTXT* pctxt, PagingUE_Identity* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "PagingUE-Identity");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* s_TMSI */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "s-TMSI");

            pvalue->u.s_TMSI = rtxMemAllocType (pctxt, S_TMSI);

            if (pvalue->u.s_TMSI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_S_TMSI (pvalue->u.s_TMSI);

            stat = asn1PD_S_TMSI (pctxt, pvalue->u.s_TMSI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* imsi */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "imsi");

            pvalue->u.imsi = rtxMemAllocType (pctxt, IMSI);

            if (pvalue->u.imsi == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_IMSI (pvalue->u.imsi);

            stat = asn1PD_IMSI (pctxt, pvalue->u.imsi);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PagingUE_Identity (PagingUE_Identity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_PagingRecord (OSCTXT* pctxt, PagingRecord* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PagingRecord");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PagingRecord"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ue_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "ue-Identity");

   stat = asn1PE_PagingUE_Identity (pctxt, &pvalue->ue_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cn_Domain */

   RTXCTXTPUSHELEMNAME (pctxt, "cn-Domain");

   stat = asn1PE_PagingRecord_cn_Domain (pctxt, pvalue->cn_Domain);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PagingRecord (OSCTXT* pctxt, PagingRecord* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PagingRecord");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode ue_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "ue-Identity");

   stat = asn1PD_PagingUE_Identity (pctxt, &pvalue->ue_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cn_Domain */
   RTXCTXTPUSHELEMNAME (pctxt, "cn-Domain");

   stat = asn1PD_PagingRecord_cn_Domain (pctxt, &pvalue->cn_Domain);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PagingRecord (PagingRecord* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_PagingUE_Identity (&pvalue->ue_Identity);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_PagingRecordList (OSCTXT* pctxt, PagingRecordList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "PagingRecordList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PagingRecordList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PagingRecord", xx1);

      stat = asn1PE_PagingRecord (pctxt, ((PagingRecord*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PagingRecordList (OSCTXT* pctxt, PagingRecordList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PagingRecordList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PagingRecord* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PagingRecord", xx1);

      rtxDListAllocNodeAndData (pctxt, PagingRecord, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PagingRecord (pdata);

      stat = asn1PD_PagingRecord (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PagingRecordList (PagingRecordList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_Paging_v920_IEs_nonCriticalExtension (OSCTXT* pctxt, Paging_v920_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("Paging_v920_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Paging_v920_IEs_nonCriticalExtension (OSCTXT* pctxt, Paging_v920_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_Paging_v920_IEs (OSCTXT* pctxt, Paging_v920_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Paging-v920-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("Paging_v920_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cmas_Indication_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cmas_Indication_r9 */

   if (pvalue->m.cmas_Indication_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "cmas-Indication-r9");

      stat = asn1PE_Paging_v920_IEs_cmas_Indication_r9 (pctxt, pvalue->cmas_Indication_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_Paging_v920_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Paging_v920_IEs (OSCTXT* pctxt, Paging_v920_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "Paging-v920-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cmas_Indication_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cmas-Indication-r9");

      pvalue->m.cmas_Indication_r9Present = 1;

      stat = asn1PD_Paging_v920_IEs_cmas_Indication_r9 (pctxt, &pvalue->cmas_Indication_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_Paging_v920_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_Paging_v920_IEs (Paging_v920_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_Paging_v890_IEs (OSCTXT* pctxt, Paging_v890_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Paging-v890-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("Paging_v890_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_Paging_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Paging_v890_IEs (OSCTXT* pctxt, Paging_v890_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "Paging-v890-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_Paging_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_Paging_v890_IEs (Paging_v890_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   asn1Init_Paging_v920_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_Paging (OSCTXT* pctxt, Paging* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Paging");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("Paging"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.pagingRecordListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.systemInfoModificationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.etws_IndicationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pagingRecordList */

   if (pvalue->m.pagingRecordListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pagingRecordList");

      stat = asn1PE_PagingRecordList (pctxt, &pvalue->pagingRecordList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode systemInfoModification */

   if (pvalue->m.systemInfoModificationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "systemInfoModification");

      stat = asn1PE_Paging_systemInfoModification (pctxt, pvalue->systemInfoModification);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode etws_Indication */

   if (pvalue->m.etws_IndicationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "etws-Indication");

      stat = asn1PE_Paging_etws_Indication (pctxt, pvalue->etws_Indication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_Paging_v890_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Paging (OSCTXT* pctxt, Paging* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "Paging");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pagingRecordList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pagingRecordList");

      pvalue->m.pagingRecordListPresent = 1;

      stat = asn1PD_PagingRecordList (pctxt, &pvalue->pagingRecordList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode systemInfoModification */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "systemInfoModification");

      pvalue->m.systemInfoModificationPresent = 1;

      stat = asn1PD_Paging_systemInfoModification (pctxt, &pvalue->systemInfoModification);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode etws_Indication */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "etws-Indication");

      pvalue->m.etws_IndicationPresent = 1;

      stat = asn1PD_Paging_etws_Indication (pctxt, &pvalue->etws_Indication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_Paging_v890_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_Paging (Paging* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PagingRecordList (&pvalue->pagingRecordList);
   asn1Init_Paging_v890_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_PCCH_MessageType_c1 (OSCTXT* pctxt, PCCH_MessageType_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PCCH_MessageType_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* paging */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "paging");

         stat = asn1PE_Paging (pctxt, pvalue->u.paging);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PCCH_MessageType_c1 (OSCTXT* pctxt, PCCH_MessageType_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* paging */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "paging");

         pvalue->u.paging = rtxMemAllocType (pctxt, Paging);

         if (pvalue->u.paging == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Paging (pvalue->u.paging);

         stat = asn1PD_Paging (pctxt, pvalue->u.paging);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_PCCH_MessageType_c1 (PCCH_MessageType_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_PCCH_MessageType_messageClassExtension (OSCTXT* pctxt, PCCH_MessageType_messageClassExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PCCH_MessageType_messageClassExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PCCH_MessageType_messageClassExtension (OSCTXT* pctxt, PCCH_MessageType_messageClassExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_PCCH_MessageType (OSCTXT* pctxt, PCCH_MessageType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PCCH-MessageType");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PCCH_MessageType"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_PCCH_MessageType_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* messageClassExtension */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "messageClassExtension");

         stat = asn1PE_PCCH_MessageType_messageClassExtension (pctxt, pvalue->u.messageClassExtension);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PCCH_MessageType (OSCTXT* pctxt, PCCH_MessageType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "PCCH-MessageType");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, PCCH_MessageType_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PCCH_MessageType_c1 (pvalue->u.c1);

         stat = asn1PD_PCCH_MessageType_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* messageClassExtension */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "messageClassExtension");

         pvalue->u.messageClassExtension = rtxMemAllocTypeZ (pctxt, 
            PCCH_MessageType_messageClassExtension);

         if (pvalue->u.messageClassExtension == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_PCCH_MessageType_messageClassExtension (pctxt, pvalue->u.messageClassExtension);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PCCH_MessageType (PCCH_MessageType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_PCCH_Message (OSCTXT* pctxt, PCCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PCCH-Message");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PCCH_Message"));

   /* encode message */

   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PE_PCCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PCCH_Message (OSCTXT* pctxt, PCCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PCCH-Message");

   /* decode root elements */
   /* decode message */
   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PD_PCCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PCCH_Message (PCCH_Message* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_PCCH_MessageType (&pvalue->message);
}

EXTERN int asn1PE_UL_AM_RLC (OSCTXT* pctxt, UL_AM_RLC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-AM-RLC");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UL_AM_RLC"));

   /* encode t_PollRetransmit */

   RTXCTXTPUSHELEMNAME (pctxt, "t-PollRetransmit");

   stat = asn1PE_T_PollRetransmit (pctxt, pvalue->t_PollRetransmit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pollPDU */

   RTXCTXTPUSHELEMNAME (pctxt, "pollPDU");

   stat = asn1PE_PollPDU (pctxt, pvalue->pollPDU);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pollByte */

   RTXCTXTPUSHELEMNAME (pctxt, "pollByte");

   stat = asn1PE_PollByte (pctxt, pvalue->pollByte);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode maxRetxThreshold */

   RTXCTXTPUSHELEMNAME (pctxt, "maxRetxThreshold");

   stat = asn1PE_UL_AM_RLC_maxRetxThreshold (pctxt, pvalue->maxRetxThreshold);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_AM_RLC (OSCTXT* pctxt, UL_AM_RLC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-AM-RLC");

   /* decode root elements */
   /* decode t_PollRetransmit */
   RTXCTXTPUSHELEMNAME (pctxt, "t-PollRetransmit");

   stat = asn1PD_T_PollRetransmit (pctxt, &pvalue->t_PollRetransmit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pollPDU */
   RTXCTXTPUSHELEMNAME (pctxt, "pollPDU");

   stat = asn1PD_PollPDU (pctxt, &pvalue->pollPDU);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pollByte */
   RTXCTXTPUSHELEMNAME (pctxt, "pollByte");

   stat = asn1PD_PollByte (pctxt, &pvalue->pollByte);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maxRetxThreshold */
   RTXCTXTPUSHELEMNAME (pctxt, "maxRetxThreshold");

   stat = asn1PD_UL_AM_RLC_maxRetxThreshold (pctxt, &pvalue->maxRetxThreshold);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_DL_AM_RLC (OSCTXT* pctxt, DL_AM_RLC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AM-RLC");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DL_AM_RLC"));

   /* encode t_Reordering */

   RTXCTXTPUSHELEMNAME (pctxt, "t-Reordering");

   stat = asn1PE_T_Reordering (pctxt, pvalue->t_Reordering);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t_StatusProhibit */

   RTXCTXTPUSHELEMNAME (pctxt, "t-StatusProhibit");

   stat = asn1PE_T_StatusProhibit (pctxt, pvalue->t_StatusProhibit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DL_AM_RLC (OSCTXT* pctxt, DL_AM_RLC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-AM-RLC");

   /* decode root elements */
   /* decode t_Reordering */
   RTXCTXTPUSHELEMNAME (pctxt, "t-Reordering");

   stat = asn1PD_T_Reordering (pctxt, &pvalue->t_Reordering);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t_StatusProhibit */
   RTXCTXTPUSHELEMNAME (pctxt, "t-StatusProhibit");

   stat = asn1PD_T_StatusProhibit (pctxt, &pvalue->t_StatusProhibit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RLC_Config_am (OSCTXT* pctxt, RLC_Config_am* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLC_Config_am"));

   /* encode ul_AM_RLC */

   RTXCTXTPUSHELEMNAME (pctxt, "ul-AM-RLC");

   stat = asn1PE_UL_AM_RLC (pctxt, &pvalue->ul_AM_RLC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dl_AM_RLC */

   RTXCTXTPUSHELEMNAME (pctxt, "dl-AM-RLC");

   stat = asn1PE_DL_AM_RLC (pctxt, &pvalue->dl_AM_RLC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLC_Config_am (OSCTXT* pctxt, RLC_Config_am* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ul_AM_RLC */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-AM-RLC");

   stat = asn1PD_UL_AM_RLC (pctxt, &pvalue->ul_AM_RLC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_AM_RLC */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-AM-RLC");

   stat = asn1PD_DL_AM_RLC (pctxt, &pvalue->dl_AM_RLC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UL_UM_RLC (OSCTXT* pctxt, UL_UM_RLC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-UM-RLC");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UL_UM_RLC"));

   /* encode sn_FieldLength */

   RTXCTXTPUSHELEMNAME (pctxt, "sn-FieldLength");

   stat = asn1PE_SN_FieldLength (pctxt, pvalue->sn_FieldLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_UM_RLC (OSCTXT* pctxt, UL_UM_RLC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-UM-RLC");

   /* decode root elements */
   /* decode sn_FieldLength */
   RTXCTXTPUSHELEMNAME (pctxt, "sn-FieldLength");

   stat = asn1PD_SN_FieldLength (pctxt, &pvalue->sn_FieldLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_DL_UM_RLC (OSCTXT* pctxt, DL_UM_RLC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-UM-RLC");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DL_UM_RLC"));

   /* encode sn_FieldLength */

   RTXCTXTPUSHELEMNAME (pctxt, "sn-FieldLength");

   stat = asn1PE_SN_FieldLength (pctxt, pvalue->sn_FieldLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t_Reordering */

   RTXCTXTPUSHELEMNAME (pctxt, "t-Reordering");

   stat = asn1PE_T_Reordering (pctxt, pvalue->t_Reordering);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DL_UM_RLC (OSCTXT* pctxt, DL_UM_RLC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-UM-RLC");

   /* decode root elements */
   /* decode sn_FieldLength */
   RTXCTXTPUSHELEMNAME (pctxt, "sn-FieldLength");

   stat = asn1PD_SN_FieldLength (pctxt, &pvalue->sn_FieldLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t_Reordering */
   RTXCTXTPUSHELEMNAME (pctxt, "t-Reordering");

   stat = asn1PD_T_Reordering (pctxt, &pvalue->t_Reordering);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RLC_Config_um_Bi_Directional (OSCTXT* pctxt, RLC_Config_um_Bi_Directional* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLC_Config_um_Bi_Directional"));

   /* encode ul_UM_RLC */

   RTXCTXTPUSHELEMNAME (pctxt, "ul-UM-RLC");

   stat = asn1PE_UL_UM_RLC (pctxt, &pvalue->ul_UM_RLC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dl_UM_RLC */

   RTXCTXTPUSHELEMNAME (pctxt, "dl-UM-RLC");

   stat = asn1PE_DL_UM_RLC (pctxt, &pvalue->dl_UM_RLC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLC_Config_um_Bi_Directional (OSCTXT* pctxt, RLC_Config_um_Bi_Directional* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ul_UM_RLC */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-UM-RLC");

   stat = asn1PD_UL_UM_RLC (pctxt, &pvalue->ul_UM_RLC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_UM_RLC */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-UM-RLC");

   stat = asn1PD_DL_UM_RLC (pctxt, &pvalue->dl_UM_RLC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RLC_Config_um_Uni_Directional_UL (OSCTXT* pctxt, RLC_Config_um_Uni_Directional_UL* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLC_Config_um_Uni_Directional_UL"));

   /* encode ul_UM_RLC */

   RTXCTXTPUSHELEMNAME (pctxt, "ul-UM-RLC");

   stat = asn1PE_UL_UM_RLC (pctxt, &pvalue->ul_UM_RLC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLC_Config_um_Uni_Directional_UL (OSCTXT* pctxt, RLC_Config_um_Uni_Directional_UL* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode ul_UM_RLC */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-UM-RLC");

   stat = asn1PD_UL_UM_RLC (pctxt, &pvalue->ul_UM_RLC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RLC_Config_um_Uni_Directional_DL (OSCTXT* pctxt, RLC_Config_um_Uni_Directional_DL* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLC_Config_um_Uni_Directional_DL"));

   /* encode dl_UM_RLC */

   RTXCTXTPUSHELEMNAME (pctxt, "dl-UM-RLC");

   stat = asn1PE_DL_UM_RLC (pctxt, &pvalue->dl_UM_RLC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLC_Config_um_Uni_Directional_DL (OSCTXT* pctxt, RLC_Config_um_Uni_Directional_DL* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode dl_UM_RLC */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-UM-RLC");

   stat = asn1PD_DL_UM_RLC (pctxt, &pvalue->dl_UM_RLC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RLC_Config (OSCTXT* pctxt, RLC_Config* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RLC-Config");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLC_Config"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 4);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* am */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "am");

            stat = asn1PE_RLC_Config_am (pctxt, pvalue->u.am);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* um_Bi_Directional */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "um-Bi-Directional");

            stat = asn1PE_RLC_Config_um_Bi_Directional (pctxt, pvalue->u.um_Bi_Directional);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* um_Uni_Directional_UL */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "um-Uni-Directional-UL");

            stat = asn1PE_RLC_Config_um_Uni_Directional_UL (pctxt, pvalue->u.um_Uni_Directional_UL);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* um_Uni_Directional_DL */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "um-Uni-Directional-DL");

            stat = asn1PE_RLC_Config_um_Uni_Directional_DL (pctxt, pvalue->u.um_Uni_Directional_DL);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLC_Config (OSCTXT* pctxt, RLC_Config* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "RLC-Config");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* am */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "am");

            pvalue->u.am = rtxMemAllocTypeZ (pctxt, RLC_Config_am);

            if (pvalue->u.am == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            stat = asn1PD_RLC_Config_am (pctxt, pvalue->u.am);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* um_Bi_Directional */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "um-Bi-Directional");

            pvalue->u.um_Bi_Directional = rtxMemAllocTypeZ (pctxt, 
               RLC_Config_um_Bi_Directional);

            if (pvalue->u.um_Bi_Directional == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            stat = asn1PD_RLC_Config_um_Bi_Directional (pctxt, pvalue->u.um_Bi_Directional);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* um_Uni_Directional_UL */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "um-Uni-Directional-UL");

            pvalue->u.um_Uni_Directional_UL = rtxMemAllocTypeZ (pctxt, 
               RLC_Config_um_Uni_Directional_UL);

            if (pvalue->u.um_Uni_Directional_UL == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            stat = asn1PD_RLC_Config_um_Uni_Directional_UL (pctxt, pvalue->u.um_Uni_Directional_UL);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* um_Uni_Directional_DL */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "um-Uni-Directional-DL");

            pvalue->u.um_Uni_Directional_DL = rtxMemAllocTypeZ (pctxt, 
               RLC_Config_um_Uni_Directional_DL);

            if (pvalue->u.um_Uni_Directional_DL == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            stat = asn1PD_RLC_Config_um_Uni_Directional_DL (pctxt, pvalue->u.um_Uni_Directional_DL);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RLC_Config (RLC_Config* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_SRB_ToAddMod_rlc_Config (OSCTXT* pctxt, SRB_ToAddMod_rlc_Config* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SRB_ToAddMod_rlc_Config"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* explicitValue */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "explicitValue");

         stat = asn1PE_RLC_Config (pctxt, pvalue->u.explicitValue);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* defaultValue */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultValue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SRB_ToAddMod_rlc_Config (OSCTXT* pctxt, SRB_ToAddMod_rlc_Config* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* explicitValue */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "explicitValue");

         pvalue->u.explicitValue = rtxMemAllocType (pctxt, RLC_Config);

         if (pvalue->u.explicitValue == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RLC_Config (pvalue->u.explicitValue);

         stat = asn1PD_RLC_Config (pctxt, pvalue->u.explicitValue);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* defaultValue */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultValue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_SRB_ToAddMod_rlc_Config (SRB_ToAddMod_rlc_Config* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_LogicalChannelConfig_ul_SpecificParameters (OSCTXT* pctxt, LogicalChannelConfig_ul_SpecificParameters* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("LogicalChannelConfig_ul_SpecificParameters"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.logicalChannelGroupPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode priority */

   RTXCTXTPUSHELEMNAME (pctxt, "priority");

   if ( (pvalue->priority >= OSUINTCONST(1) && pvalue->priority <= OSUINTCONST(16)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->priority, OSUINTCONST(1), OSUINTCONST(16));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->priority);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode prioritisedBitRate */

   RTXCTXTPUSHELEMNAME (pctxt, "prioritisedBitRate");

   stat = asn1PE_LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate (pctxt, pvalue->prioritisedBitRate);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode bucketSizeDuration */

   RTXCTXTPUSHELEMNAME (pctxt, "bucketSizeDuration");

   stat = asn1PE_LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration (pctxt, pvalue->bucketSizeDuration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode logicalChannelGroup */

   if (pvalue->m.logicalChannelGroupPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelGroup");

      if ( (pvalue->logicalChannelGroup <= OSUINTCONST(3)) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->logicalChannelGroup, OSUINTCONST(0), OSUINTCONST(3));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->logicalChannelGroup);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_LogicalChannelConfig_ul_SpecificParameters (OSCTXT* pctxt, LogicalChannelConfig_ul_SpecificParameters* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode priority */
   RTXCTXTPUSHELEMNAME (pctxt, "priority");

   stat = pd_ConsUInt8 (pctxt, &pvalue->priority, OSUINTCONST(1), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode prioritisedBitRate */
   RTXCTXTPUSHELEMNAME (pctxt, "prioritisedBitRate");

   stat = asn1PD_LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate (pctxt, &pvalue->prioritisedBitRate);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode bucketSizeDuration */
   RTXCTXTPUSHELEMNAME (pctxt, "bucketSizeDuration");

   stat = asn1PD_LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration (pctxt, &pvalue->bucketSizeDuration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode logicalChannelGroup */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelGroup");

      pvalue->m.logicalChannelGroupPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->logicalChannelGroup, OSUINTCONST(0), OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_LogicalChannelConfig_ul_SpecificParameters (
   LogicalChannelConfig_ul_SpecificParameters* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_LogicalChannelConfig (OSCTXT* pctxt, LogicalChannelConfig* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "LogicalChannelConfig");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("LogicalChannelConfig"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m._v2ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ul_SpecificParametersPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ul_SpecificParameters */

   if (pvalue->m.ul_SpecificParametersPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-SpecificParameters");

      stat = asn1PE_LogicalChannelConfig_ul_SpecificParameters (pctxt, &pvalue->ul_SpecificParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v2ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m._v2ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.logicalChannelSR_Mask_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode logicalChannelSR_Mask_r9 */

         if (pvalue->m.logicalChannelSR_Mask_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelSR-Mask-r9");

            stat = asn1PE_LogicalChannelConfig_logicalChannelSR_Mask_r9 (pctxt, pvalue->logicalChannelSR_Mask_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_LogicalChannelConfig (OSCTXT* pctxt, LogicalChannelConfig* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "LogicalChannelConfig");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_SpecificParameters */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-SpecificParameters");

      pvalue->m.ul_SpecificParametersPresent = 1;

      stat = asn1PD_LogicalChannelConfig_ul_SpecificParameters (pctxt, &pvalue->ul_SpecificParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m._v2ExtPresent = 1;
                        {
                           OSOCTET extoptbits[1];

                           stat = DEC_BIT (pctxt, &extoptbits[0]);
                           if (stat != 0)  {
                              rtxMemFreePtr (pctxt, poptbits);
                           }
                           if (extoptbits[0]) {
                              pvalue->m.logicalChannelSR_Mask_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelSR-Mask-r9");

                              stat = asn1PD_LogicalChannelConfig_logicalChannelSR_Mask_r9 (pctxt, &pvalue->logicalChannelSR_Mask_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;

                        /* Coverity 55358 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_LogicalChannelConfig (LogicalChannelConfig* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_LogicalChannelConfig_ul_SpecificParameters (&pvalue->ul_SpecificParameters);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_SRB_ToAddMod_logicalChannelConfig (OSCTXT* pctxt, SRB_ToAddMod_logicalChannelConfig* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SRB_ToAddMod_logicalChannelConfig"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* explicitValue */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "explicitValue");

         stat = asn1PE_LogicalChannelConfig (pctxt, pvalue->u.explicitValue);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* defaultValue */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultValue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SRB_ToAddMod_logicalChannelConfig (OSCTXT* pctxt, SRB_ToAddMod_logicalChannelConfig* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* explicitValue */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "explicitValue");

         pvalue->u.explicitValue = rtxMemAllocType (pctxt, 
            LogicalChannelConfig);

         if (pvalue->u.explicitValue == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LogicalChannelConfig (pvalue->u.explicitValue);

         stat = asn1PD_LogicalChannelConfig (pctxt, pvalue->u.explicitValue);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* defaultValue */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultValue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_SRB_ToAddMod_logicalChannelConfig (
   SRB_ToAddMod_logicalChannelConfig* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_SRB_ToAddMod (OSCTXT* pctxt, SRB_ToAddMod* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-ToAddMod");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SRB_ToAddMod"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rlc_ConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.logicalChannelConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode srb_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "srb-Identity");

   if ( (pvalue->srb_Identity >= OSUINTCONST(1) && pvalue->srb_Identity
       <= OSUINTCONST(2)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->srb_Identity, OSUINTCONST(1), OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->srb_Identity);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rlc_Config */

   if (pvalue->m.rlc_ConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlc-Config");

      stat = asn1PE_SRB_ToAddMod_rlc_Config (pctxt, &pvalue->rlc_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode logicalChannelConfig */

   if (pvalue->m.logicalChannelConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelConfig");

      stat = asn1PE_SRB_ToAddMod_logicalChannelConfig (pctxt, &pvalue->logicalChannelConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SRB_ToAddMod (OSCTXT* pctxt, SRB_ToAddMod* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-ToAddMod");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode srb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "srb-Identity");

   stat = pd_ConsUInt8 (pctxt, &pvalue->srb_Identity, OSUINTCONST(1), OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rlc_Config */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlc-Config");

      pvalue->m.rlc_ConfigPresent = 1;

      stat = asn1PD_SRB_ToAddMod_rlc_Config (pctxt, &pvalue->rlc_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode logicalChannelConfig */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelConfig");

      pvalue->m.logicalChannelConfigPresent = 1;

      stat = asn1PD_SRB_ToAddMod_logicalChannelConfig (pctxt, &pvalue->logicalChannelConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SRB_ToAddMod (SRB_ToAddMod* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SRB_ToAddMod_rlc_Config (&pvalue->rlc_Config);
   asn1Init_SRB_ToAddMod_logicalChannelConfig (&pvalue->logicalChannelConfig);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_SRB_ToAddModList (OSCTXT* pctxt, SRB_ToAddModList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-ToAddModList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SRB_ToAddModList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SRB-ToAddMod", xx1);

      stat = asn1PE_SRB_ToAddMod (pctxt, ((SRB_ToAddMod*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SRB_ToAddModList (OSCTXT* pctxt, SRB_ToAddModList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-ToAddModList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SRB_ToAddMod* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SRB-ToAddMod", xx1);

      rtxDListAllocNodeAndData (pctxt, SRB_ToAddMod, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SRB_ToAddMod (pdata);

      stat = asn1PD_SRB_ToAddMod (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SRB_ToAddModList (SRB_ToAddModList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_PDCP_Config_rlc_AM (OSCTXT* pctxt, PDCP_Config_rlc_AM* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PDCP_Config_rlc_AM"));

   /* encode statusReportRequired */

   RTXCTXTPUSHELEMNAME (pctxt, "statusReportRequired");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->statusReportRequired);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDCP_Config_rlc_AM (OSCTXT* pctxt, PDCP_Config_rlc_AM* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode statusReportRequired */
   RTXCTXTPUSHELEMNAME (pctxt, "statusReportRequired");

   stat = DEC_BIT (pctxt, &pvalue->statusReportRequired);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PDCP_Config_rlc_UM (OSCTXT* pctxt, PDCP_Config_rlc_UM* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PDCP_Config_rlc_UM"));

   /* encode pdcp_SN_Size */

   RTXCTXTPUSHELEMNAME (pctxt, "pdcp-SN-Size");

   stat = asn1PE_PDCP_Config_rlc_UM_pdcp_SN_Size (pctxt, pvalue->pdcp_SN_Size);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDCP_Config_rlc_UM (OSCTXT* pctxt, PDCP_Config_rlc_UM* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode pdcp_SN_Size */
   RTXCTXTPUSHELEMNAME (pctxt, "pdcp-SN-Size");

   stat = asn1PD_PDCP_Config_rlc_UM_pdcp_SN_Size (pctxt, &pvalue->pdcp_SN_Size);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PDCP_Config_headerCompression_rohc_profiles (OSCTXT* pctxt, PDCP_Config_headerCompression_rohc_profiles* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PDCP_Config_headerCompression_rohc_profiles"));

   /* encode profile0x0001 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0001");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0001);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0002 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0002");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0002);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0003 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0003");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0003);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0004 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0004");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0004);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0006 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0006");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0006);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0101 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0101");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0101);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0102 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0102");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0102);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0103 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0103");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0103);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0104 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0104");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0104);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDCP_Config_headerCompression_rohc_profiles (OSCTXT* pctxt, PDCP_Config_headerCompression_rohc_profiles* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode profile0x0001 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0001");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0001);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0002 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0002");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0002);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0003 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0003");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0003);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0004 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0004");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0004);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0006 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0006");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0006);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0101 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0101");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0101);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0102 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0102");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0102);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0103 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0103");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0103);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0104 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0104");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0104);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PDCP_Config_headerCompression_rohc (OSCTXT* pctxt, PDCP_Config_headerCompression_rohc* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PDCP_Config_headerCompression_rohc"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)(pvalue->maxCID != 15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode maxCID */

   if (pvalue->maxCID != 15) {
      RTXCTXTPUSHELEMNAME (pctxt, "maxCID");

      if ( (pvalue->maxCID >= OSUINTCONST(1) && pvalue->maxCID <= OSUINTCONST(16383)) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->maxCID, OSUINTCONST(1), OSUINTCONST(16383));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->maxCID);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode profiles */

   RTXCTXTPUSHELEMNAME (pctxt, "profiles");

   stat = asn1PE_PDCP_Config_headerCompression_rohc_profiles (pctxt, &pvalue->profiles);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDCP_Config_headerCompression_rohc (OSCTXT* pctxt, PDCP_Config_headerCompression_rohc* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode maxCID */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "maxCID");

      stat = pd_ConsUInt16 (pctxt, &pvalue->maxCID, OSUINTCONST(1), OSUINTCONST(16383));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->maxCID = 15;
   }

   /* decode profiles */
   RTXCTXTPUSHELEMNAME (pctxt, "profiles");

   stat = asn1PD_PDCP_Config_headerCompression_rohc_profiles (pctxt, &pvalue->profiles);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

void asn1Init_PDCP_Config_headerCompression_rohc (
   PDCP_Config_headerCompression_rohc* pvalue)
{
   if (0 == pvalue) return;
   pvalue->maxCID = 15;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_PDCP_Config_headerCompression (OSCTXT* pctxt, PDCP_Config_headerCompression* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PDCP_Config_headerCompression"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* notUsed */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "notUsed");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* rohc */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "rohc");

         stat = asn1PE_PDCP_Config_headerCompression_rohc (pctxt, pvalue->u.rohc);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDCP_Config_headerCompression (OSCTXT* pctxt, PDCP_Config_headerCompression* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* notUsed */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "notUsed");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* rohc */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rohc");

         pvalue->u.rohc = rtxMemAllocType (pctxt, 
            PDCP_Config_headerCompression_rohc);

         if (pvalue->u.rohc == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDCP_Config_headerCompression_rohc (pvalue->u.rohc);

         stat = asn1PD_PDCP_Config_headerCompression_rohc (pctxt, pvalue->u.rohc);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_PDCP_Config_headerCompression (
   PDCP_Config_headerCompression* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_PDCP_Config (OSCTXT* pctxt, PDCP_Config* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDCP-Config");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PDCP_Config"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.discardTimerPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rlc_AMPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rlc_UMPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode discardTimer */

   if (pvalue->m.discardTimerPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "discardTimer");

      stat = asn1PE_PDCP_Config_discardTimer (pctxt, pvalue->discardTimer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode rlc_AM */

   if (pvalue->m.rlc_AMPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlc-AM");

      stat = asn1PE_PDCP_Config_rlc_AM (pctxt, &pvalue->rlc_AM);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode rlc_UM */

   if (pvalue->m.rlc_UMPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlc-UM");

      stat = asn1PE_PDCP_Config_rlc_UM (pctxt, &pvalue->rlc_UM);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode headerCompression */

   RTXCTXTPUSHELEMNAME (pctxt, "headerCompression");

   stat = asn1PE_PDCP_Config_headerCompression (pctxt, &pvalue->headerCompression);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDCP_Config (OSCTXT* pctxt, PDCP_Config* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "PDCP-Config");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode discardTimer */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "discardTimer");

      pvalue->m.discardTimerPresent = 1;

      stat = asn1PD_PDCP_Config_discardTimer (pctxt, &pvalue->discardTimer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_AM */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlc-AM");

      pvalue->m.rlc_AMPresent = 1;

      stat = asn1PD_PDCP_Config_rlc_AM (pctxt, &pvalue->rlc_AM);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_UM */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlc-UM");

      pvalue->m.rlc_UMPresent = 1;

      stat = asn1PD_PDCP_Config_rlc_UM (pctxt, &pvalue->rlc_UM);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode headerCompression */
   RTXCTXTPUSHELEMNAME (pctxt, "headerCompression");

   stat = asn1PD_PDCP_Config_headerCompression (pctxt, &pvalue->headerCompression);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PDCP_Config (PDCP_Config* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PDCP_Config_headerCompression (&pvalue->headerCompression);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_DRB_ToAddMod (OSCTXT* pctxt, DRB_ToAddMod* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-ToAddMod");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRB_ToAddMod"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.eps_BearerIdentityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.pdcp_ConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rlc_ConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.logicalChannelIdentityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.logicalChannelConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode eps_BearerIdentity */

   if (pvalue->m.eps_BearerIdentityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "eps-BearerIdentity");

      if ( (pvalue->eps_BearerIdentity <= OSUINTCONST(15)) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->eps_BearerIdentity, OSUINTCONST(0), OSUINTCONST(15));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->eps_BearerIdentity);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode drb_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "drb-Identity");

   stat = asn1PE_DRB_Identity (pctxt, pvalue->drb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pdcp_Config */

   if (pvalue->m.pdcp_ConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Config");

      stat = asn1PE_PDCP_Config (pctxt, &pvalue->pdcp_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode rlc_Config */

   if (pvalue->m.rlc_ConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlc-Config");

      stat = asn1PE_RLC_Config (pctxt, &pvalue->rlc_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode logicalChannelIdentity */

   if (pvalue->m.logicalChannelIdentityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelIdentity");

      if ( (pvalue->logicalChannelIdentity >= OSUINTCONST(3) && pvalue->
         logicalChannelIdentity <= OSUINTCONST(10)) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->logicalChannelIdentity, OSUINTCONST(3), OSUINTCONST(10));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->logicalChannelIdentity);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode logicalChannelConfig */

   if (pvalue->m.logicalChannelConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelConfig");

      stat = asn1PE_LogicalChannelConfig (pctxt, &pvalue->logicalChannelConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRB_ToAddMod (OSCTXT* pctxt, DRB_ToAddMod* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-ToAddMod");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode eps_BearerIdentity */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "eps-BearerIdentity");

      pvalue->m.eps_BearerIdentityPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->eps_BearerIdentity, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode drb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "drb-Identity");

   stat = asn1PD_DRB_Identity (pctxt, &pvalue->drb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdcp_Config */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Config");

      pvalue->m.pdcp_ConfigPresent = 1;

      stat = asn1PD_PDCP_Config (pctxt, &pvalue->pdcp_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlc_Config */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlc-Config");

      pvalue->m.rlc_ConfigPresent = 1;

      stat = asn1PD_RLC_Config (pctxt, &pvalue->rlc_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode logicalChannelIdentity */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelIdentity");

      pvalue->m.logicalChannelIdentityPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->logicalChannelIdentity, OSUINTCONST(3), OSUINTCONST(10));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode logicalChannelConfig */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "logicalChannelConfig");

      pvalue->m.logicalChannelConfigPresent = 1;

      stat = asn1PD_LogicalChannelConfig (pctxt, &pvalue->logicalChannelConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DRB_ToAddMod (DRB_ToAddMod* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PDCP_Config (&pvalue->pdcp_Config);
   asn1Init_RLC_Config (&pvalue->rlc_Config);
   asn1Init_LogicalChannelConfig (&pvalue->logicalChannelConfig);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_DRB_ToAddModList (OSCTXT* pctxt, DRB_ToAddModList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-ToAddModList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRB_ToAddModList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(11), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DRB-ToAddMod", xx1);

      stat = asn1PE_DRB_ToAddMod (pctxt, ((DRB_ToAddMod*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRB_ToAddModList (OSCTXT* pctxt, DRB_ToAddModList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-ToAddModList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(11), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DRB_ToAddMod* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DRB-ToAddMod", xx1);

      rtxDListAllocNodeAndData (pctxt, DRB_ToAddMod, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DRB_ToAddMod (pdata);

      stat = asn1PD_DRB_ToAddMod (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DRB_ToAddModList (DRB_ToAddModList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_DRB_ToReleaseList (OSCTXT* pctxt, DRB_ToReleaseList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-ToReleaseList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRB_ToReleaseList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(11), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DRB-Identity", xx1);

      stat = asn1PE_DRB_Identity (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRB_ToReleaseList (OSCTXT* pctxt, DRB_ToReleaseList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-ToReleaseList");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 11) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DRB-Identity", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (DRB_Identity));
      stat = asn1PD_DRB_Identity (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DRB_ToReleaseList (DRB_ToReleaseList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_MAC_MainConfig_ul_SCH_Config (OSCTXT* pctxt, MAC_MainConfig_ul_SCH_Config* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MAC_MainConfig_ul_SCH_Config"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.maxHARQ_TxPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.periodicBSR_TimerPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode maxHARQ_Tx */

   if (pvalue->m.maxHARQ_TxPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "maxHARQ-Tx");

      stat = asn1PE_MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx (pctxt, pvalue->maxHARQ_Tx);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode periodicBSR_Timer */

   if (pvalue->m.periodicBSR_TimerPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "periodicBSR-Timer");

      stat = asn1PE_MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer (pctxt, pvalue->periodicBSR_Timer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode retxBSR_Timer */

   RTXCTXTPUSHELEMNAME (pctxt, "retxBSR-Timer");

   stat = asn1PE_MAC_MainConfig_ul_SCH_Config_retxBSR_Timer (pctxt, pvalue->retxBSR_Timer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ttiBundling */

   RTXCTXTPUSHELEMNAME (pctxt, "ttiBundling");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->ttiBundling);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MAC_MainConfig_ul_SCH_Config (OSCTXT* pctxt, MAC_MainConfig_ul_SCH_Config* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode maxHARQ_Tx */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "maxHARQ-Tx");

      pvalue->m.maxHARQ_TxPresent = 1;

      stat = asn1PD_MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx (pctxt, &pvalue->maxHARQ_Tx);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode periodicBSR_Timer */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "periodicBSR-Timer");

      pvalue->m.periodicBSR_TimerPresent = 1;

      stat = asn1PD_MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer (pctxt, &pvalue->periodicBSR_Timer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode retxBSR_Timer */
   RTXCTXTPUSHELEMNAME (pctxt, "retxBSR-Timer");

   stat = asn1PD_MAC_MainConfig_ul_SCH_Config_retxBSR_Timer (pctxt, &pvalue->retxBSR_Timer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ttiBundling */
   RTXCTXTPUSHELEMNAME (pctxt, "ttiBundling");

   stat = DEC_BIT (pctxt, &pvalue->ttiBundling);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_MAC_MainConfig_ul_SCH_Config (
   MAC_MainConfig_ul_SCH_Config* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_DRX_Config_setup_longDRX_CycleStartOffset (OSCTXT* pctxt, DRX_Config_setup_longDRX_CycleStartOffset* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRX_Config_setup_longDRX_CycleStartOffset"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 15);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* sf10 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sf10");

         if ( (pvalue->u.sf10 <= OSUINTCONST(9)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf10, OSUINTCONST(0), OSUINTCONST(9));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf10);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf20 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "sf20");

         if ( (pvalue->u.sf20 <= OSUINTCONST(19)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf20, OSUINTCONST(0), OSUINTCONST(19));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf20);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf32 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "sf32");

         if ( (pvalue->u.sf32 <= OSUINTCONST(31)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf32, OSUINTCONST(0), OSUINTCONST(31));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf32);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf40 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "sf40");

         if ( (pvalue->u.sf40 <= OSUINTCONST(39)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf40, OSUINTCONST(0), OSUINTCONST(39));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf40);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf64 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "sf64");

         if ( (pvalue->u.sf64 <= OSUINTCONST(63)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf64, OSUINTCONST(0), OSUINTCONST(63));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf64);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf80 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "sf80");

         if ( (pvalue->u.sf80 <= OSUINTCONST(79)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf80, OSUINTCONST(0), OSUINTCONST(79));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf80);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf128 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "sf128");

         if ( (pvalue->u.sf128 <= OSUINTCONST(127)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf128, OSUINTCONST(0), OSUINTCONST(127));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf128);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf160 */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "sf160");

         if ( (pvalue->u.sf160 <= OSUINTCONST(159)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf160, OSUINTCONST(0), OSUINTCONST(159));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf160);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf256 */
      case 9:
         RTXCTXTPUSHELEMNAME (pctxt, "sf256");

         stat = pe_ConsUnsigned (pctxt, pvalue->u.sf256, OSUINTCONST(0), OSUINTCONST(255));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf320 */
      case 10:
         RTXCTXTPUSHELEMNAME (pctxt, "sf320");

         if ( (pvalue->u.sf320 <= OSUINTCONST(319)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf320, OSUINTCONST(0), OSUINTCONST(319));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf320);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf512 */
      case 11:
         RTXCTXTPUSHELEMNAME (pctxt, "sf512");

         if ( (pvalue->u.sf512 <= OSUINTCONST(511)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf512, OSUINTCONST(0), OSUINTCONST(511));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf512);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf640 */
      case 12:
         RTXCTXTPUSHELEMNAME (pctxt, "sf640");

         if ( (pvalue->u.sf640 <= OSUINTCONST(639)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf640, OSUINTCONST(0), OSUINTCONST(639));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf640);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf1024 */
      case 13:
         RTXCTXTPUSHELEMNAME (pctxt, "sf1024");

         if ( (pvalue->u.sf1024 <= OSUINTCONST(1023)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf1024, OSUINTCONST(0), OSUINTCONST(1023));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf1024);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf1280 */
      case 14:
         RTXCTXTPUSHELEMNAME (pctxt, "sf1280");

         if ( (pvalue->u.sf1280 <= OSUINTCONST(1279)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf1280, OSUINTCONST(0), OSUINTCONST(1279));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf1280);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf2048 */
      case 15:
         RTXCTXTPUSHELEMNAME (pctxt, "sf2048");

         if ( (pvalue->u.sf2048 <= OSUINTCONST(2047)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf2048, OSUINTCONST(0), OSUINTCONST(2047));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf2048);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sf2560 */
      case 16:
         RTXCTXTPUSHELEMNAME (pctxt, "sf2560");

         if ( (pvalue->u.sf2560 <= OSUINTCONST(2559)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.sf2560, OSUINTCONST(0), OSUINTCONST(2559));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.sf2560);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRX_Config_setup_longDRX_CycleStartOffset (OSCTXT* pctxt, DRX_Config_setup_longDRX_CycleStartOffset* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* sf10 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "sf10");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.sf10, OSUINTCONST(0), OSUINTCONST(9));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf20 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sf20");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.sf20, OSUINTCONST(0), OSUINTCONST(19));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf32 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "sf32");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.sf32, OSUINTCONST(0), OSUINTCONST(31));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf40 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "sf40");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.sf40, OSUINTCONST(0), OSUINTCONST(39));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf64 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "sf64");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.sf64, OSUINTCONST(0), OSUINTCONST(63));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf80 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "sf80");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.sf80, OSUINTCONST(0), OSUINTCONST(79));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf128 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "sf128");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.sf128, OSUINTCONST(0), OSUINTCONST(127));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf160 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "sf160");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.sf160, OSUINTCONST(0), OSUINTCONST(159));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf256 */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "sf256");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.sf256, OSUINTCONST(0), OSUINTCONST(255));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf320 */
      case 9:
         RTXCTXTPUSHELEMNAME (pctxt, "sf320");

         stat = pd_ConsUInt16 (pctxt, &pvalue->u.sf320, OSUINTCONST(0), OSUINTCONST(319));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf512 */
      case 10:
         RTXCTXTPUSHELEMNAME (pctxt, "sf512");

         stat = pd_ConsUInt16 (pctxt, &pvalue->u.sf512, OSUINTCONST(0), OSUINTCONST(511));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf640 */
      case 11:
         RTXCTXTPUSHELEMNAME (pctxt, "sf640");

         stat = pd_ConsUInt16 (pctxt, &pvalue->u.sf640, OSUINTCONST(0), OSUINTCONST(639));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf1024 */
      case 12:
         RTXCTXTPUSHELEMNAME (pctxt, "sf1024");

         stat = pd_ConsUInt16 (pctxt, &pvalue->u.sf1024, OSUINTCONST(0), OSUINTCONST(1023));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf1280 */
      case 13:
         RTXCTXTPUSHELEMNAME (pctxt, "sf1280");

         stat = pd_ConsUInt16 (pctxt, &pvalue->u.sf1280, OSUINTCONST(0), OSUINTCONST(1279));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf2048 */
      case 14:
         RTXCTXTPUSHELEMNAME (pctxt, "sf2048");

         stat = pd_ConsUInt16 (pctxt, &pvalue->u.sf2048, OSUINTCONST(0), OSUINTCONST(2047));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sf2560 */
      case 15:
         RTXCTXTPUSHELEMNAME (pctxt, "sf2560");

         stat = pd_ConsUInt16 (pctxt, &pvalue->u.sf2560, OSUINTCONST(0), OSUINTCONST(2559));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_DRX_Config_setup_longDRX_CycleStartOffset (
   DRX_Config_setup_longDRX_CycleStartOffset* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_DRX_Config_setup_shortDRX (OSCTXT* pctxt, DRX_Config_setup_shortDRX* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRX_Config_setup_shortDRX"));

   /* encode shortDRX_Cycle */

   RTXCTXTPUSHELEMNAME (pctxt, "shortDRX-Cycle");

   stat = asn1PE_DRX_Config_setup_shortDRX_shortDRX_Cycle (pctxt, pvalue->shortDRX_Cycle);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode drxShortCycleTimer */

   RTXCTXTPUSHELEMNAME (pctxt, "drxShortCycleTimer");

   if ( (pvalue->drxShortCycleTimer >= OSUINTCONST(1) && pvalue->drxShortCycleTimer
       <= OSUINTCONST(16)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->drxShortCycleTimer, OSUINTCONST(1), OSUINTCONST(16));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->drxShortCycleTimer);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRX_Config_setup_shortDRX (OSCTXT* pctxt, DRX_Config_setup_shortDRX* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode shortDRX_Cycle */
   RTXCTXTPUSHELEMNAME (pctxt, "shortDRX-Cycle");

   stat = asn1PD_DRX_Config_setup_shortDRX_shortDRX_Cycle (pctxt, &pvalue->shortDRX_Cycle);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode drxShortCycleTimer */
   RTXCTXTPUSHELEMNAME (pctxt, "drxShortCycleTimer");

   stat = pd_ConsUInt8 (pctxt, &pvalue->drxShortCycleTimer, OSUINTCONST(1), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_DRX_Config_setup (OSCTXT* pctxt, DRX_Config_setup* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRX_Config_setup"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.shortDRXPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode onDurationTimer */

   RTXCTXTPUSHELEMNAME (pctxt, "onDurationTimer");

   stat = asn1PE_DRX_Config_setup_onDurationTimer (pctxt, pvalue->onDurationTimer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode drx_InactivityTimer */

   RTXCTXTPUSHELEMNAME (pctxt, "drx-InactivityTimer");

   stat = asn1PE_DRX_Config_setup_drx_InactivityTimer (pctxt, pvalue->drx_InactivityTimer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode drx_RetransmissionTimer */

   RTXCTXTPUSHELEMNAME (pctxt, "drx-RetransmissionTimer");

   stat = asn1PE_DRX_Config_setup_drx_RetransmissionTimer (pctxt, pvalue->drx_RetransmissionTimer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode longDRX_CycleStartOffset */

   RTXCTXTPUSHELEMNAME (pctxt, "longDRX-CycleStartOffset");

   stat = asn1PE_DRX_Config_setup_longDRX_CycleStartOffset (pctxt, &pvalue->longDRX_CycleStartOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode shortDRX */

   if (pvalue->m.shortDRXPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "shortDRX");

      stat = asn1PE_DRX_Config_setup_shortDRX (pctxt, &pvalue->shortDRX);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRX_Config_setup (OSCTXT* pctxt, DRX_Config_setup* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode onDurationTimer */
   RTXCTXTPUSHELEMNAME (pctxt, "onDurationTimer");

   stat = asn1PD_DRX_Config_setup_onDurationTimer (pctxt, &pvalue->onDurationTimer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode drx_InactivityTimer */
   RTXCTXTPUSHELEMNAME (pctxt, "drx-InactivityTimer");

   stat = asn1PD_DRX_Config_setup_drx_InactivityTimer (pctxt, &pvalue->drx_InactivityTimer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode drx_RetransmissionTimer */
   RTXCTXTPUSHELEMNAME (pctxt, "drx-RetransmissionTimer");

   stat = asn1PD_DRX_Config_setup_drx_RetransmissionTimer (pctxt, &pvalue->drx_RetransmissionTimer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode longDRX_CycleStartOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "longDRX-CycleStartOffset");

   stat = asn1PD_DRX_Config_setup_longDRX_CycleStartOffset (pctxt, &pvalue->longDRX_CycleStartOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode shortDRX */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "shortDRX");

      pvalue->m.shortDRXPresent = 1;

      stat = asn1PD_DRX_Config_setup_shortDRX (pctxt, &pvalue->shortDRX);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_DRX_Config_setup (DRX_Config_setup* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_DRX_Config_setup_longDRX_CycleStartOffset (&pvalue->longDRX_CycleStartOffset);
}

EXTERN int asn1PE_DRX_Config (OSCTXT* pctxt, DRX_Config* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRX-Config");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRX_Config"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_DRX_Config_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRX_Config (OSCTXT* pctxt, DRX_Config* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DRX-Config");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         pvalue->u.setup = rtxMemAllocType (pctxt, DRX_Config_setup);

         if (pvalue->u.setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DRX_Config_setup (pvalue->u.setup);

         stat = asn1PD_DRX_Config_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DRX_Config (DRX_Config* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MAC_MainConfig_phr_Config_setup (OSCTXT* pctxt, MAC_MainConfig_phr_Config_setup* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MAC_MainConfig_phr_Config_setup"));

   /* encode periodicPHR_Timer */

   RTXCTXTPUSHELEMNAME (pctxt, "periodicPHR-Timer");

   stat = asn1PE_MAC_MainConfig_phr_Config_setup_periodicPHR_Timer (pctxt, pvalue->periodicPHR_Timer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode prohibitPHR_Timer */

   RTXCTXTPUSHELEMNAME (pctxt, "prohibitPHR-Timer");

   stat = asn1PE_MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer (pctxt, pvalue->prohibitPHR_Timer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dl_PathlossChange */

   RTXCTXTPUSHELEMNAME (pctxt, "dl-PathlossChange");

   stat = asn1PE_MAC_MainConfig_phr_Config_setup_dl_PathlossChange (pctxt, pvalue->dl_PathlossChange);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MAC_MainConfig_phr_Config_setup (OSCTXT* pctxt, MAC_MainConfig_phr_Config_setup* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode periodicPHR_Timer */
   RTXCTXTPUSHELEMNAME (pctxt, "periodicPHR-Timer");

   stat = asn1PD_MAC_MainConfig_phr_Config_setup_periodicPHR_Timer (pctxt, &pvalue->periodicPHR_Timer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode prohibitPHR_Timer */
   RTXCTXTPUSHELEMNAME (pctxt, "prohibitPHR-Timer");

   stat = asn1PD_MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer (pctxt, &pvalue->prohibitPHR_Timer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_PathlossChange */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-PathlossChange");

   stat = asn1PD_MAC_MainConfig_phr_Config_setup_dl_PathlossChange (pctxt, &pvalue->dl_PathlossChange);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_MAC_MainConfig_phr_Config (OSCTXT* pctxt, MAC_MainConfig_phr_Config* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MAC_MainConfig_phr_Config"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_MAC_MainConfig_phr_Config_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MAC_MainConfig_phr_Config (OSCTXT* pctxt, MAC_MainConfig_phr_Config* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         pvalue->u.setup = rtxMemAllocTypeZ (pctxt, 
            MAC_MainConfig_phr_Config_setup);

         if (pvalue->u.setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_MAC_MainConfig_phr_Config_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_MAC_MainConfig_phr_Config (MAC_MainConfig_phr_Config* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MAC_MainConfig (OSCTXT* pctxt, MAC_MainConfig* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-MainConfig");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MAC_MainConfig"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m._v2ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ul_SCH_ConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.drx_ConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.phr_ConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ul_SCH_Config */

   if (pvalue->m.ul_SCH_ConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-SCH-Config");

      stat = asn1PE_MAC_MainConfig_ul_SCH_Config (pctxt, &pvalue->ul_SCH_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode drx_Config */

   if (pvalue->m.drx_ConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "drx-Config");

      stat = asn1PE_DRX_Config (pctxt, &pvalue->drx_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode timeAlignmentTimerDedicated */

   RTXCTXTPUSHELEMNAME (pctxt, "timeAlignmentTimerDedicated");

   stat = asn1PE_TimeAlignmentTimer (pctxt, pvalue->timeAlignmentTimerDedicated);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode phr_Config */

   if (pvalue->m.phr_ConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "phr-Config");

      stat = asn1PE_MAC_MainConfig_phr_Config (pctxt, &pvalue->phr_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v2ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m._v2ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.sr_ProhibitTimer_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode sr_ProhibitTimer_r9 */

         if (pvalue->m.sr_ProhibitTimer_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "sr-ProhibitTimer-r9");

            if ( (pvalue->sr_ProhibitTimer_r9 <= OSUINTCONST(7)) ) {
               stat = pe_ConsUnsigned (pctxt, pvalue->sr_ProhibitTimer_r9, OSUINTCONST(0), OSUINTCONST(7));
               if (stat != 0) return LOG_RTERR (pctxt, stat);
            }
            else {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddUIntParm (pctxt, pvalue->sr_ProhibitTimer_r9);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MAC_MainConfig (OSCTXT* pctxt, MAC_MainConfig* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "MAC-MainConfig");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ul_SCH_Config */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-SCH-Config");

      pvalue->m.ul_SCH_ConfigPresent = 1;

      stat = asn1PD_MAC_MainConfig_ul_SCH_Config (pctxt, &pvalue->ul_SCH_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode drx_Config */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "drx-Config");

      pvalue->m.drx_ConfigPresent = 1;

      stat = asn1PD_DRX_Config (pctxt, &pvalue->drx_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode timeAlignmentTimerDedicated */
   RTXCTXTPUSHELEMNAME (pctxt, "timeAlignmentTimerDedicated");

   stat = asn1PD_TimeAlignmentTimer (pctxt, &pvalue->timeAlignmentTimerDedicated);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode phr_Config */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "phr-Config");

      pvalue->m.phr_ConfigPresent = 1;

      stat = asn1PD_MAC_MainConfig_phr_Config (pctxt, &pvalue->phr_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m._v2ExtPresent = 1;
                        {
                           OSOCTET extoptbits[1];

                           stat = DEC_BIT (pctxt, &extoptbits[0]);
                           if (stat != 0)  {
                              rtxMemFreePtr (pctxt, poptbits);
                           }
                           if (extoptbits[0]) {
                              pvalue->m.sr_ProhibitTimer_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "sr-ProhibitTimer-r9");

                              stat = pd_ConsUInt8 (pctxt, &pvalue->sr_ProhibitTimer_r9, OSUINTCONST(0), OSUINTCONST(7));
                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;

                        /* Coverity 55356 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MAC_MainConfig (MAC_MainConfig* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_MAC_MainConfig_ul_SCH_Config (&pvalue->ul_SCH_Config);
   asn1Init_DRX_Config (&pvalue->drx_Config);
   asn1Init_MAC_MainConfig_phr_Config (&pvalue->phr_Config);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_RadioResourceConfigDedicated_mac_MainConfig (OSCTXT* pctxt, RadioResourceConfigDedicated_mac_MainConfig* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RadioResourceConfigDedicated_mac_MainConfig"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* explicitValue */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "explicitValue");

         stat = asn1PE_MAC_MainConfig (pctxt, pvalue->u.explicitValue);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* defaultValue */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultValue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RadioResourceConfigDedicated_mac_MainConfig (OSCTXT* pctxt, RadioResourceConfigDedicated_mac_MainConfig* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* explicitValue */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "explicitValue");

         pvalue->u.explicitValue = rtxMemAllocType (pctxt, MAC_MainConfig);

         if (pvalue->u.explicitValue == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MAC_MainConfig (pvalue->u.explicitValue);

         stat = asn1PD_MAC_MainConfig (pctxt, pvalue->u.explicitValue);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* defaultValue */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultValue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RadioResourceConfigDedicated_mac_MainConfig (
   RadioResourceConfigDedicated_mac_MainConfig* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_N1_PUCCH_AN_PersistentList (OSCTXT* pctxt, N1_PUCCH_AN_PersistentList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "N1-PUCCH-AN-PersistentList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("N1_PUCCH_AN_PersistentList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "INTEGER", xx1);

      if ( (pvalue->elem[xx1] <= OSUINTCONST(2047)) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->elem[xx1], OSUINTCONST(0), OSUINTCONST(2047));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->elem[xx1]);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_N1_PUCCH_AN_PersistentList (OSCTXT* pctxt, N1_PUCCH_AN_PersistentList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "N1-PUCCH-AN-PersistentList");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 4) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "INTEGER", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (OSUINT16));
      stat = pd_ConsUInt16 (pctxt, &pvalue->elem[xx1], OSUINTCONST(0), OSUINTCONST(2047));
      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_N1_PUCCH_AN_PersistentList (N1_PUCCH_AN_PersistentList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_SPS_ConfigDL_setup (OSCTXT* pctxt, SPS_ConfigDL_setup* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SPS_ConfigDL_setup"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode semiPersistSchedIntervalDL */

   RTXCTXTPUSHELEMNAME (pctxt, "semiPersistSchedIntervalDL");

   stat = asn1PE_SPS_ConfigDL_setup_semiPersistSchedIntervalDL (pctxt, pvalue->semiPersistSchedIntervalDL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode numberOfConfSPS_Processes */

   RTXCTXTPUSHELEMNAME (pctxt, "numberOfConfSPS-Processes");

   if ( (pvalue->numberOfConfSPS_Processes >= OSUINTCONST(1) && pvalue->
      numberOfConfSPS_Processes <= OSUINTCONST(8)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->numberOfConfSPS_Processes, OSUINTCONST(1), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->numberOfConfSPS_Processes);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode n1_PUCCH_AN_PersistentList */

   RTXCTXTPUSHELEMNAME (pctxt, "n1-PUCCH-AN-PersistentList");

   stat = asn1PE_N1_PUCCH_AN_PersistentList (pctxt, &pvalue->n1_PUCCH_AN_PersistentList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SPS_ConfigDL_setup (OSCTXT* pctxt, SPS_ConfigDL_setup* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode semiPersistSchedIntervalDL */
   RTXCTXTPUSHELEMNAME (pctxt, "semiPersistSchedIntervalDL");

   stat = asn1PD_SPS_ConfigDL_setup_semiPersistSchedIntervalDL (pctxt, &pvalue->semiPersistSchedIntervalDL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfConfSPS_Processes */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfConfSPS-Processes");

   stat = pd_ConsUInt8 (pctxt, &pvalue->numberOfConfSPS_Processes, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode n1_PUCCH_AN_PersistentList */
   RTXCTXTPUSHELEMNAME (pctxt, "n1-PUCCH-AN-PersistentList");

   stat = asn1PD_N1_PUCCH_AN_PersistentList (pctxt, &pvalue->n1_PUCCH_AN_PersistentList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

void asn1Init_SPS_ConfigDL_setup (SPS_ConfigDL_setup* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_N1_PUCCH_AN_PersistentList (&pvalue->n1_PUCCH_AN_PersistentList);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_SPS_ConfigDL (OSCTXT* pctxt, SPS_ConfigDL* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SPS-ConfigDL");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SPS_ConfigDL"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_SPS_ConfigDL_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SPS_ConfigDL (OSCTXT* pctxt, SPS_ConfigDL* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "SPS-ConfigDL");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         pvalue->u.setup = rtxMemAllocType (pctxt, SPS_ConfigDL_setup);

         if (pvalue->u.setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SPS_ConfigDL_setup (pvalue->u.setup);

         stat = asn1PD_SPS_ConfigDL_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SPS_ConfigDL (SPS_ConfigDL* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_SPS_ConfigUL_setup_p0_Persistent (OSCTXT* pctxt, SPS_ConfigUL_setup_p0_Persistent* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SPS_ConfigUL_setup_p0_Persistent"));

   /* encode p0_NominalPUSCH_Persistent */

   RTXCTXTPUSHELEMNAME (pctxt, "p0-NominalPUSCH-Persistent");

   if ( (pvalue->p0_NominalPUSCH_Persistent >= OSINTCONST(-126) && pvalue->
      p0_NominalPUSCH_Persistent <= OSINTCONST(24)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->p0_NominalPUSCH_Persistent, OSINTCONST(-126), OSINTCONST(24));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->p0_NominalPUSCH_Persistent);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode p0_UE_PUSCH_Persistent */

   RTXCTXTPUSHELEMNAME (pctxt, "p0-UE-PUSCH-Persistent");

   if ( (pvalue->p0_UE_PUSCH_Persistent >= OSINTCONST(-8) && pvalue->
      p0_UE_PUSCH_Persistent <= OSINTCONST(7)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->p0_UE_PUSCH_Persistent, OSINTCONST(-8), OSINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->p0_UE_PUSCH_Persistent);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SPS_ConfigUL_setup_p0_Persistent (OSCTXT* pctxt, SPS_ConfigUL_setup_p0_Persistent* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode p0_NominalPUSCH_Persistent */
   RTXCTXTPUSHELEMNAME (pctxt, "p0-NominalPUSCH-Persistent");

   stat = pd_ConsInt8 (pctxt, &pvalue->p0_NominalPUSCH_Persistent, OSINTCONST(-126), OSINTCONST(24));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode p0_UE_PUSCH_Persistent */
   RTXCTXTPUSHELEMNAME (pctxt, "p0-UE-PUSCH-Persistent");

   stat = pd_ConsInt8 (pctxt, &pvalue->p0_UE_PUSCH_Persistent, OSINTCONST(-8), OSINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SPS_ConfigUL_setup (OSCTXT* pctxt, SPS_ConfigUL_setup* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SPS_ConfigUL_setup"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.p0_PersistentPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.twoIntervalsConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode semiPersistSchedIntervalUL */

   RTXCTXTPUSHELEMNAME (pctxt, "semiPersistSchedIntervalUL");

   stat = asn1PE_SPS_ConfigUL_setup_semiPersistSchedIntervalUL (pctxt, pvalue->semiPersistSchedIntervalUL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode implicitReleaseAfter */

   RTXCTXTPUSHELEMNAME (pctxt, "implicitReleaseAfter");

   stat = asn1PE_SPS_ConfigUL_setup_implicitReleaseAfter (pctxt, pvalue->implicitReleaseAfter);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode p0_Persistent */

   if (pvalue->m.p0_PersistentPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "p0-Persistent");

      stat = asn1PE_SPS_ConfigUL_setup_p0_Persistent (pctxt, &pvalue->p0_Persistent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode twoIntervalsConfig */

   if (pvalue->m.twoIntervalsConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "twoIntervalsConfig");

      stat = asn1PE_SPS_ConfigUL_setup_twoIntervalsConfig (pctxt, pvalue->twoIntervalsConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SPS_ConfigUL_setup (OSCTXT* pctxt, SPS_ConfigUL_setup* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode semiPersistSchedIntervalUL */
   RTXCTXTPUSHELEMNAME (pctxt, "semiPersistSchedIntervalUL");

   stat = asn1PD_SPS_ConfigUL_setup_semiPersistSchedIntervalUL (pctxt, &pvalue->semiPersistSchedIntervalUL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode implicitReleaseAfter */
   RTXCTXTPUSHELEMNAME (pctxt, "implicitReleaseAfter");

   stat = asn1PD_SPS_ConfigUL_setup_implicitReleaseAfter (pctxt, &pvalue->implicitReleaseAfter);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode p0_Persistent */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "p0-Persistent");

      pvalue->m.p0_PersistentPresent = 1;

      stat = asn1PD_SPS_ConfigUL_setup_p0_Persistent (pctxt, &pvalue->p0_Persistent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode twoIntervalsConfig */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "twoIntervalsConfig");

      pvalue->m.twoIntervalsConfigPresent = 1;

      stat = asn1PD_SPS_ConfigUL_setup_twoIntervalsConfig (pctxt, &pvalue->twoIntervalsConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

void asn1Init_SPS_ConfigUL_setup (SPS_ConfigUL_setup* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_SPS_ConfigUL (OSCTXT* pctxt, SPS_ConfigUL* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SPS-ConfigUL");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SPS_ConfigUL"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_SPS_ConfigUL_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SPS_ConfigUL (OSCTXT* pctxt, SPS_ConfigUL* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "SPS-ConfigUL");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         pvalue->u.setup = rtxMemAllocType (pctxt, SPS_ConfigUL_setup);

         if (pvalue->u.setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SPS_ConfigUL_setup (pvalue->u.setup);

         stat = asn1PD_SPS_ConfigUL_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SPS_ConfigUL (SPS_ConfigUL* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_SPS_Config (OSCTXT* pctxt, SPS_Config* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SPS-Config");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SPS_Config"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.semiPersistSchedC_RNTIPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.sps_ConfigDLPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.sps_ConfigULPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode semiPersistSchedC_RNTI */

   if (pvalue->m.semiPersistSchedC_RNTIPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "semiPersistSchedC-RNTI");

      stat = asn1PE_C_RNTI (pctxt, pvalue->semiPersistSchedC_RNTI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode sps_ConfigDL */

   if (pvalue->m.sps_ConfigDLPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "sps-ConfigDL");

      stat = asn1PE_SPS_ConfigDL (pctxt, &pvalue->sps_ConfigDL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode sps_ConfigUL */

   if (pvalue->m.sps_ConfigULPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "sps-ConfigUL");

      stat = asn1PE_SPS_ConfigUL (pctxt, &pvalue->sps_ConfigUL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SPS_Config (OSCTXT* pctxt, SPS_Config* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "SPS-Config");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode semiPersistSchedC_RNTI */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "semiPersistSchedC-RNTI");

      pvalue->m.semiPersistSchedC_RNTIPresent = 1;

      stat = asn1PD_C_RNTI (pctxt, &pvalue->semiPersistSchedC_RNTI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode sps_ConfigDL */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sps-ConfigDL");

      pvalue->m.sps_ConfigDLPresent = 1;

      stat = asn1PD_SPS_ConfigDL (pctxt, &pvalue->sps_ConfigDL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode sps_ConfigUL */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sps-ConfigUL");

      pvalue->m.sps_ConfigULPresent = 1;

      stat = asn1PD_SPS_ConfigUL (pctxt, &pvalue->sps_ConfigUL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SPS_Config (SPS_Config* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_C_RNTI (&pvalue->semiPersistSchedC_RNTI);
   asn1Init_SPS_ConfigDL (&pvalue->sps_ConfigDL);
   asn1Init_SPS_ConfigUL (&pvalue->sps_ConfigUL);
}

EXTERN int asn1PE_PDSCH_ConfigDedicated (OSCTXT* pctxt, PDSCH_ConfigDedicated* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDSCH-ConfigDedicated");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PDSCH_ConfigDedicated"));

   /* encode p_a */

   RTXCTXTPUSHELEMNAME (pctxt, "p-a");

   stat = asn1PE_PDSCH_ConfigDedicated_p_a (pctxt, pvalue->p_a);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDSCH_ConfigDedicated (OSCTXT* pctxt, PDSCH_ConfigDedicated* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDSCH-ConfigDedicated");

   /* decode root elements */
   /* decode p_a */
   RTXCTXTPUSHELEMNAME (pctxt, "p-a");

   stat = asn1PD_PDSCH_ConfigDedicated_p_a (pctxt, &pvalue->p_a);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PUCCH_ConfigDedicated_ackNackRepetition_setup (OSCTXT* pctxt, PUCCH_ConfigDedicated_ackNackRepetition_setup* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PUCCH_ConfigDedicated_ackNackRepetition_setup"));

   /* encode repetitionFactor */

   RTXCTXTPUSHELEMNAME (pctxt, "repetitionFactor");

   stat = asn1PE_PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor (pctxt, pvalue->repetitionFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode n1PUCCH_AN_Rep */

   RTXCTXTPUSHELEMNAME (pctxt, "n1PUCCH-AN-Rep");

   if ( (pvalue->n1PUCCH_AN_Rep <= OSUINTCONST(2047)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->n1PUCCH_AN_Rep, OSUINTCONST(0), OSUINTCONST(2047));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->n1PUCCH_AN_Rep);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PUCCH_ConfigDedicated_ackNackRepetition_setup (OSCTXT* pctxt, PUCCH_ConfigDedicated_ackNackRepetition_setup* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode repetitionFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "repetitionFactor");

   stat = asn1PD_PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor (pctxt, &pvalue->repetitionFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode n1PUCCH_AN_Rep */
   RTXCTXTPUSHELEMNAME (pctxt, "n1PUCCH-AN-Rep");

   stat = pd_ConsUInt16 (pctxt, &pvalue->n1PUCCH_AN_Rep, OSUINTCONST(0), OSUINTCONST(2047));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PUCCH_ConfigDedicated_ackNackRepetition (OSCTXT* pctxt, PUCCH_ConfigDedicated_ackNackRepetition* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PUCCH_ConfigDedicated_ackNackRepetition"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_PUCCH_ConfigDedicated_ackNackRepetition_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PUCCH_ConfigDedicated_ackNackRepetition (OSCTXT* pctxt, PUCCH_ConfigDedicated_ackNackRepetition* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         pvalue->u.setup = rtxMemAllocTypeZ (pctxt, 
            PUCCH_ConfigDedicated_ackNackRepetition_setup);

         if (pvalue->u.setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_PUCCH_ConfigDedicated_ackNackRepetition_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_PUCCH_ConfigDedicated_ackNackRepetition (
   PUCCH_ConfigDedicated_ackNackRepetition* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_PUCCH_ConfigDedicated (OSCTXT* pctxt, PUCCH_ConfigDedicated* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PUCCH-ConfigDedicated");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PUCCH_ConfigDedicated"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.tdd_AckNackFeedbackModePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ackNackRepetition */

   RTXCTXTPUSHELEMNAME (pctxt, "ackNackRepetition");

   stat = asn1PE_PUCCH_ConfigDedicated_ackNackRepetition (pctxt, &pvalue->ackNackRepetition);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode tdd_AckNackFeedbackMode */

   if (pvalue->m.tdd_AckNackFeedbackModePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "tdd-AckNackFeedbackMode");

      stat = asn1PE_PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode (pctxt, pvalue->tdd_AckNackFeedbackMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PUCCH_ConfigDedicated (OSCTXT* pctxt, PUCCH_ConfigDedicated* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PUCCH-ConfigDedicated");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ackNackRepetition */
   RTXCTXTPUSHELEMNAME (pctxt, "ackNackRepetition");

   stat = asn1PD_PUCCH_ConfigDedicated_ackNackRepetition (pctxt, &pvalue->ackNackRepetition);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tdd_AckNackFeedbackMode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tdd-AckNackFeedbackMode");

      pvalue->m.tdd_AckNackFeedbackModePresent = 1;

      stat = asn1PD_PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode (pctxt, &pvalue->tdd_AckNackFeedbackMode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PUCCH_ConfigDedicated (PUCCH_ConfigDedicated* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PUCCH_ConfigDedicated_ackNackRepetition (&pvalue->ackNackRepetition);
}

EXTERN int asn1PE_PUSCH_ConfigDedicated (OSCTXT* pctxt, PUSCH_ConfigDedicated* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PUSCH-ConfigDedicated");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PUSCH_ConfigDedicated"));

   /* encode betaOffset_ACK_Index */

   RTXCTXTPUSHELEMNAME (pctxt, "betaOffset-ACK-Index");

   if ( (pvalue->betaOffset_ACK_Index <= OSUINTCONST(15)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->betaOffset_ACK_Index, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->betaOffset_ACK_Index);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode betaOffset_RI_Index */

   RTXCTXTPUSHELEMNAME (pctxt, "betaOffset-RI-Index");

   if ( (pvalue->betaOffset_RI_Index <= OSUINTCONST(15)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->betaOffset_RI_Index, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->betaOffset_RI_Index);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode betaOffset_CQI_Index */

   RTXCTXTPUSHELEMNAME (pctxt, "betaOffset-CQI-Index");

   if ( (pvalue->betaOffset_CQI_Index <= OSUINTCONST(15)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->betaOffset_CQI_Index, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->betaOffset_CQI_Index);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PUSCH_ConfigDedicated (OSCTXT* pctxt, PUSCH_ConfigDedicated* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PUSCH-ConfigDedicated");

   /* decode root elements */
   /* decode betaOffset_ACK_Index */
   RTXCTXTPUSHELEMNAME (pctxt, "betaOffset-ACK-Index");

   stat = pd_ConsUInt8 (pctxt, &pvalue->betaOffset_ACK_Index, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode betaOffset_RI_Index */
   RTXCTXTPUSHELEMNAME (pctxt, "betaOffset-RI-Index");

   stat = pd_ConsUInt8 (pctxt, &pvalue->betaOffset_RI_Index, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode betaOffset_CQI_Index */
   RTXCTXTPUSHELEMNAME (pctxt, "betaOffset-CQI-Index");

   stat = pd_ConsUInt8 (pctxt, &pvalue->betaOffset_CQI_Index, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UplinkPowerControlDedicated (OSCTXT* pctxt, UplinkPowerControlDedicated* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkPowerControlDedicated");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UplinkPowerControlDedicated"));

   stat = rtxEncBit (pctxt, (OSBOOL)(pvalue->filterCoefficient != fc4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode p0_UE_PUSCH */

   RTXCTXTPUSHELEMNAME (pctxt, "p0-UE-PUSCH");

   if ( (pvalue->p0_UE_PUSCH >= OSINTCONST(-8) && pvalue->p0_UE_PUSCH
       <= OSINTCONST(7)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->p0_UE_PUSCH, OSINTCONST(-8), OSINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->p0_UE_PUSCH);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode deltaMCS_Enabled */

   RTXCTXTPUSHELEMNAME (pctxt, "deltaMCS-Enabled");

   stat = asn1PE_UplinkPowerControlDedicated_deltaMCS_Enabled (pctxt, pvalue->deltaMCS_Enabled);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode accumulationEnabled */

   RTXCTXTPUSHELEMNAME (pctxt, "accumulationEnabled");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->accumulationEnabled);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode p0_UE_PUCCH */

   RTXCTXTPUSHELEMNAME (pctxt, "p0-UE-PUCCH");

   if ( (pvalue->p0_UE_PUCCH >= OSINTCONST(-8) && pvalue->p0_UE_PUCCH
       <= OSINTCONST(7)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->p0_UE_PUCCH, OSINTCONST(-8), OSINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->p0_UE_PUCCH);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pSRS_Offset */

   RTXCTXTPUSHELEMNAME (pctxt, "pSRS-Offset");

   if ( (pvalue->pSRS_Offset <= OSUINTCONST(15)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->pSRS_Offset, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->pSRS_Offset);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode filterCoefficient */

   if (pvalue->filterCoefficient != fc4) {
      RTXCTXTPUSHELEMNAME (pctxt, "filterCoefficient");

      stat = asn1PE_FilterCoefficient (pctxt, pvalue->filterCoefficient);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkPowerControlDedicated (OSCTXT* pctxt, UplinkPowerControlDedicated* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkPowerControlDedicated");

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode p0_UE_PUSCH */
   RTXCTXTPUSHELEMNAME (pctxt, "p0-UE-PUSCH");

   stat = pd_ConsInt8 (pctxt, &pvalue->p0_UE_PUSCH, OSINTCONST(-8), OSINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deltaMCS_Enabled */
   RTXCTXTPUSHELEMNAME (pctxt, "deltaMCS-Enabled");

   stat = asn1PD_UplinkPowerControlDedicated_deltaMCS_Enabled (pctxt, &pvalue->deltaMCS_Enabled);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode accumulationEnabled */
   RTXCTXTPUSHELEMNAME (pctxt, "accumulationEnabled");

   stat = DEC_BIT (pctxt, &pvalue->accumulationEnabled);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode p0_UE_PUCCH */
   RTXCTXTPUSHELEMNAME (pctxt, "p0-UE-PUCCH");

   stat = pd_ConsInt8 (pctxt, &pvalue->p0_UE_PUCCH, OSINTCONST(-8), OSINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pSRS_Offset */
   RTXCTXTPUSHELEMNAME (pctxt, "pSRS-Offset");

   stat = pd_ConsUInt8 (pctxt, &pvalue->pSRS_Offset, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode filterCoefficient */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "filterCoefficient");

      stat = asn1PD_FilterCoefficient (pctxt, &pvalue->filterCoefficient);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->filterCoefficient = fc4;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UplinkPowerControlDedicated (UplinkPowerControlDedicated* pvalue)
{
   if (0 == pvalue) return;
   pvalue->filterCoefficient = fc4;
}

EXTERN int asn1PE_TPC_Index (OSCTXT* pctxt, TPC_Index* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TPC-Index");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("TPC_Index"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* indexOfFormat3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "indexOfFormat3");

         if ( (pvalue->u.indexOfFormat3 >= OSUINTCONST(1) && pvalue->u.indexOfFormat3
             <= OSUINTCONST(15)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.indexOfFormat3, OSUINTCONST(1), OSUINTCONST(15));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.indexOfFormat3);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* indexOfFormat3A */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "indexOfFormat3A");

         if ( (pvalue->u.indexOfFormat3A >= OSUINTCONST(1) && pvalue->
            u.indexOfFormat3A <= OSUINTCONST(31)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.indexOfFormat3A, OSUINTCONST(1), OSUINTCONST(31));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.indexOfFormat3A);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_TPC_Index (OSCTXT* pctxt, TPC_Index* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "TPC-Index");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* indexOfFormat3 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "indexOfFormat3");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.indexOfFormat3, OSUINTCONST(1), OSUINTCONST(15));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* indexOfFormat3A */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "indexOfFormat3A");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.indexOfFormat3A, OSUINTCONST(1), OSUINTCONST(31));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_TPC_Index (TPC_Index* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_TPC_PDCCH_Config_setup (OSCTXT* pctxt, TPC_PDCCH_Config_setup* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("TPC_PDCCH_Config_setup"));

   /* encode tpc_RNTI */

   RTXCTXTPUSHELEMNAME (pctxt, "tpc-RNTI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->tpc_RNTI, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode tpc_Index */

   RTXCTXTPUSHELEMNAME (pctxt, "tpc-Index");

   stat = asn1PE_TPC_Index (pctxt, &pvalue->tpc_Index);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_TPC_PDCCH_Config_setup (OSCTXT* pctxt, TPC_PDCCH_Config_setup* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode tpc_RNTI */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-RNTI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->tpc_RNTI
      , OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tpc_Index */
   RTXCTXTPUSHELEMNAME (pctxt, "tpc-Index");

   stat = asn1PD_TPC_Index (pctxt, &pvalue->tpc_Index);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_TPC_PDCCH_Config_setup (TPC_PDCCH_Config_setup* pvalue)
{
   if (0 == pvalue) return;
   pvalue->tpc_RNTI.numbits = 0;
   asn1Init_TPC_Index (&pvalue->tpc_Index);
}

EXTERN int asn1PE_TPC_PDCCH_Config (OSCTXT* pctxt, TPC_PDCCH_Config* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TPC-PDCCH-Config");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("TPC_PDCCH_Config"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_TPC_PDCCH_Config_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_TPC_PDCCH_Config (OSCTXT* pctxt, TPC_PDCCH_Config* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "TPC-PDCCH-Config");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         pvalue->u.setup = rtxMemAllocType (pctxt, TPC_PDCCH_Config_setup);

         if (pvalue->u.setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TPC_PDCCH_Config_setup (pvalue->u.setup);

         stat = asn1PD_TPC_PDCCH_Config_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_TPC_PDCCH_Config (TPC_PDCCH_Config* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI (OSCTXT* pctxt, CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI"));

   /* encode k */

   RTXCTXTPUSHELEMNAME (pctxt, "k");

   if ( (pvalue->k >= OSUINTCONST(1) && pvalue->k <= OSUINTCONST(4)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->k, OSUINTCONST(1), OSUINTCONST(4));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->k);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI (OSCTXT* pctxt, CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode k */
   RTXCTXTPUSHELEMNAME (pctxt, "k");

   stat = pd_ConsUInt8 (pctxt, &pvalue->k, OSUINTCONST(1), OSUINTCONST(4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic (OSCTXT* pctxt, CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* widebandCQI */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "widebandCQI");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* subbandCQI */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "subbandCQI");

         stat = asn1PE_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI (pctxt, pvalue->u.subbandCQI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic (OSCTXT* pctxt, CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* widebandCQI */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "widebandCQI");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* subbandCQI */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "subbandCQI");

         pvalue->u.subbandCQI = rtxMemAllocTypeZ (pctxt, 
            CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI);

         if (pvalue->u.subbandCQI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI (pctxt, pvalue->u.subbandCQI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic (
   CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_CQI_ReportPeriodic_setup (OSCTXT* pctxt, CQI_ReportPeriodic_setup* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CQI_ReportPeriodic_setup"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ri_ConfigIndexPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cqi_PUCCH_ResourceIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "cqi-PUCCH-ResourceIndex");

   if ( (pvalue->cqi_PUCCH_ResourceIndex <= OSUINTCONST(1185)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->cqi_PUCCH_ResourceIndex, OSUINTCONST(0), OSUINTCONST(1185));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->cqi_PUCCH_ResourceIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cqi_pmi_ConfigIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "cqi-pmi-ConfigIndex");

   if ( (pvalue->cqi_pmi_ConfigIndex <= OSUINTCONST(1023)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->cqi_pmi_ConfigIndex, OSUINTCONST(0), OSUINTCONST(1023));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->cqi_pmi_ConfigIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cqi_FormatIndicatorPeriodic */

   RTXCTXTPUSHELEMNAME (pctxt, "cqi-FormatIndicatorPeriodic");

   stat = asn1PE_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic (pctxt, &pvalue->cqi_FormatIndicatorPeriodic);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ri_ConfigIndex */

   if (pvalue->m.ri_ConfigIndexPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ri-ConfigIndex");

      if ( (pvalue->ri_ConfigIndex <= OSUINTCONST(1023)) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->ri_ConfigIndex, OSUINTCONST(0), OSUINTCONST(1023));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->ri_ConfigIndex);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode simultaneousAckNackAndCQI */

   RTXCTXTPUSHELEMNAME (pctxt, "simultaneousAckNackAndCQI");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->simultaneousAckNackAndCQI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CQI_ReportPeriodic_setup (OSCTXT* pctxt, CQI_ReportPeriodic_setup* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cqi_PUCCH_ResourceIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "cqi-PUCCH-ResourceIndex");

   stat = pd_ConsUInt16 (pctxt, &pvalue->cqi_PUCCH_ResourceIndex, OSUINTCONST(0), OSUINTCONST(1185));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cqi_pmi_ConfigIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "cqi-pmi-ConfigIndex");

   stat = pd_ConsUInt16 (pctxt, &pvalue->cqi_pmi_ConfigIndex, OSUINTCONST(0), OSUINTCONST(1023));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cqi_FormatIndicatorPeriodic */
   RTXCTXTPUSHELEMNAME (pctxt, "cqi-FormatIndicatorPeriodic");

   stat = asn1PD_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic (pctxt, &pvalue->cqi_FormatIndicatorPeriodic);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ri_ConfigIndex */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ri-ConfigIndex");

      pvalue->m.ri_ConfigIndexPresent = 1;

      stat = pd_ConsUInt16 (pctxt, &pvalue->ri_ConfigIndex, OSUINTCONST(0), OSUINTCONST(1023));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode simultaneousAckNackAndCQI */
   RTXCTXTPUSHELEMNAME (pctxt, "simultaneousAckNackAndCQI");

   stat = DEC_BIT (pctxt, &pvalue->simultaneousAckNackAndCQI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_CQI_ReportPeriodic_setup (CQI_ReportPeriodic_setup* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic (&pvalue->cqi_FormatIndicatorPeriodic);
}

EXTERN int asn1PE_CQI_ReportPeriodic (OSCTXT* pctxt, CQI_ReportPeriodic* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CQI-ReportPeriodic");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CQI_ReportPeriodic"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_CQI_ReportPeriodic_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CQI_ReportPeriodic (OSCTXT* pctxt, CQI_ReportPeriodic* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "CQI-ReportPeriodic");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         pvalue->u.setup = rtxMemAllocType (pctxt, CQI_ReportPeriodic_setup);

         if (pvalue->u.setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CQI_ReportPeriodic_setup (pvalue->u.setup);

         stat = asn1PD_CQI_ReportPeriodic_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CQI_ReportPeriodic (CQI_ReportPeriodic* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_CQI_ReportConfig (OSCTXT* pctxt, CQI_ReportConfig* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CQI-ReportConfig");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CQI_ReportConfig"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cqi_ReportModeAperiodicPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cqi_ReportPeriodicPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cqi_ReportModeAperiodic */

   if (pvalue->m.cqi_ReportModeAperiodicPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cqi-ReportModeAperiodic");

      stat = asn1PE_CQI_ReportConfig_cqi_ReportModeAperiodic (pctxt, pvalue->cqi_ReportModeAperiodic);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nomPDSCH_RS_EPRE_Offset */

   RTXCTXTPUSHELEMNAME (pctxt, "nomPDSCH-RS-EPRE-Offset");

   if ( (pvalue->nomPDSCH_RS_EPRE_Offset >= OSINTCONST(-1) && pvalue->
      nomPDSCH_RS_EPRE_Offset <= OSINTCONST(6)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->nomPDSCH_RS_EPRE_Offset, OSINTCONST(-1), OSINTCONST(6));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->nomPDSCH_RS_EPRE_Offset);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cqi_ReportPeriodic */

   if (pvalue->m.cqi_ReportPeriodicPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cqi-ReportPeriodic");

      stat = asn1PE_CQI_ReportPeriodic (pctxt, &pvalue->cqi_ReportPeriodic);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CQI_ReportConfig (OSCTXT* pctxt, CQI_ReportConfig* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "CQI-ReportConfig");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cqi_ReportModeAperiodic */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cqi-ReportModeAperiodic");

      pvalue->m.cqi_ReportModeAperiodicPresent = 1;

      stat = asn1PD_CQI_ReportConfig_cqi_ReportModeAperiodic (pctxt, &pvalue->cqi_ReportModeAperiodic);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nomPDSCH_RS_EPRE_Offset */
   RTXCTXTPUSHELEMNAME (pctxt, "nomPDSCH-RS-EPRE-Offset");

   stat = pd_ConsInt8 (pctxt, &pvalue->nomPDSCH_RS_EPRE_Offset, OSINTCONST(-1), OSINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cqi_ReportPeriodic */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cqi-ReportPeriodic");

      pvalue->m.cqi_ReportPeriodicPresent = 1;

      stat = asn1PD_CQI_ReportPeriodic (pctxt, &pvalue->cqi_ReportPeriodic);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CQI_ReportConfig (CQI_ReportConfig* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CQI_ReportPeriodic (&pvalue->cqi_ReportPeriodic);
}

EXTERN int asn1PE_SoundingRS_UL_ConfigDedicated_setup (OSCTXT* pctxt, SoundingRS_UL_ConfigDedicated_setup* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SoundingRS_UL_ConfigDedicated_setup"));

   /* encode srs_Bandwidth */

   RTXCTXTPUSHELEMNAME (pctxt, "srs-Bandwidth");

   stat = asn1PE_SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth (pctxt, pvalue->srs_Bandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode srs_HoppingBandwidth */

   RTXCTXTPUSHELEMNAME (pctxt, "srs-HoppingBandwidth");

   stat = asn1PE_SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth (pctxt, pvalue->srs_HoppingBandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode freqDomainPosition */

   RTXCTXTPUSHELEMNAME (pctxt, "freqDomainPosition");

   if ( (pvalue->freqDomainPosition <= OSUINTCONST(23)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->freqDomainPosition, OSUINTCONST(0), OSUINTCONST(23));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->freqDomainPosition);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode duration */

   RTXCTXTPUSHELEMNAME (pctxt, "duration");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->duration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode srs_ConfigIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "srs-ConfigIndex");

   if ( (pvalue->srs_ConfigIndex <= OSUINTCONST(1023)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->srs_ConfigIndex, OSUINTCONST(0), OSUINTCONST(1023));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->srs_ConfigIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode transmissionComb */

   RTXCTXTPUSHELEMNAME (pctxt, "transmissionComb");

   if ( (pvalue->transmissionComb <= OSUINTCONST(1)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->transmissionComb, OSUINTCONST(0), OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->transmissionComb);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cyclicShift */

   RTXCTXTPUSHELEMNAME (pctxt, "cyclicShift");

   stat = asn1PE_SoundingRS_UL_ConfigDedicated_setup_cyclicShift (pctxt, pvalue->cyclicShift);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SoundingRS_UL_ConfigDedicated_setup (OSCTXT* pctxt, SoundingRS_UL_ConfigDedicated_setup* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode srs_Bandwidth */
   RTXCTXTPUSHELEMNAME (pctxt, "srs-Bandwidth");

   stat = asn1PD_SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth (pctxt, &pvalue->srs_Bandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode srs_HoppingBandwidth */
   RTXCTXTPUSHELEMNAME (pctxt, "srs-HoppingBandwidth");

   stat = asn1PD_SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth (pctxt, &pvalue->srs_HoppingBandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode freqDomainPosition */
   RTXCTXTPUSHELEMNAME (pctxt, "freqDomainPosition");

   stat = pd_ConsUInt8 (pctxt, &pvalue->freqDomainPosition, OSUINTCONST(0), OSUINTCONST(23));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode duration */
   RTXCTXTPUSHELEMNAME (pctxt, "duration");

   stat = DEC_BIT (pctxt, &pvalue->duration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode srs_ConfigIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "srs-ConfigIndex");

   stat = pd_ConsUInt16 (pctxt, &pvalue->srs_ConfigIndex, OSUINTCONST(0), OSUINTCONST(1023));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transmissionComb */
   RTXCTXTPUSHELEMNAME (pctxt, "transmissionComb");

   stat = pd_ConsUInt8 (pctxt, &pvalue->transmissionComb, OSUINTCONST(0), OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cyclicShift */
   RTXCTXTPUSHELEMNAME (pctxt, "cyclicShift");

   stat = asn1PD_SoundingRS_UL_ConfigDedicated_setup_cyclicShift (pctxt, &pvalue->cyclicShift);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SoundingRS_UL_ConfigDedicated (OSCTXT* pctxt, SoundingRS_UL_ConfigDedicated* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SoundingRS-UL-ConfigDedicated");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SoundingRS_UL_ConfigDedicated"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_SoundingRS_UL_ConfigDedicated_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SoundingRS_UL_ConfigDedicated (OSCTXT* pctxt, SoundingRS_UL_ConfigDedicated* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "SoundingRS-UL-ConfigDedicated");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         pvalue->u.setup = rtxMemAllocTypeZ (pctxt, 
            SoundingRS_UL_ConfigDedicated_setup);

         if (pvalue->u.setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_SoundingRS_UL_ConfigDedicated_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SoundingRS_UL_ConfigDedicated (
   SoundingRS_UL_ConfigDedicated* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_AntennaInfoDedicated_codebookSubsetRestriction (OSCTXT* pctxt, AntennaInfoDedicated_codebookSubsetRestriction* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("AntennaInfoDedicated_codebookSubsetRestriction"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* n2TxAntenna_tm3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "n2TxAntenna-tm3");

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

         stat = pe_BitString32 (pctxt, pvalue->u.n2TxAntenna_tm3, OSUINTCONST(2), OSUINTCONST(2));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* n4TxAntenna_tm3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "n4TxAntenna-tm3");

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

         stat = pe_BitString32 (pctxt, pvalue->u.n4TxAntenna_tm3, OSUINTCONST(4), OSUINTCONST(4));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* n2TxAntenna_tm4 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "n2TxAntenna-tm4");

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

         stat = pe_BitString32 (pctxt, pvalue->u.n2TxAntenna_tm4, OSUINTCONST(6), OSUINTCONST(6));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* n4TxAntenna_tm4 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "n4TxAntenna-tm4");

         stat = asn1PE_AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4 (pctxt, pvalue->u.n4TxAntenna_tm4);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* n2TxAntenna_tm5 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "n2TxAntenna-tm5");

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

         stat = pe_BitString32 (pctxt, pvalue->u.n2TxAntenna_tm5, OSUINTCONST(4), OSUINTCONST(4));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* n4TxAntenna_tm5 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "n4TxAntenna-tm5");

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

         stat = pe_BitString32 (pctxt, pvalue->u.n4TxAntenna_tm5, OSUINTCONST(16), OSUINTCONST(16));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* n2TxAntenna_tm6 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "n2TxAntenna-tm6");

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

         stat = pe_BitString32 (pctxt, pvalue->u.n2TxAntenna_tm6, OSUINTCONST(4), OSUINTCONST(4));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* n4TxAntenna_tm6 */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "n4TxAntenna-tm6");

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

         stat = pe_BitString32 (pctxt, pvalue->u.n4TxAntenna_tm6, OSUINTCONST(16), OSUINTCONST(16));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AntennaInfoDedicated_codebookSubsetRestriction (OSCTXT* pctxt, AntennaInfoDedicated_codebookSubsetRestriction* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* n2TxAntenna_tm3 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "n2TxAntenna-tm3");

         pvalue->u.n2TxAntenna_tm3 = rtxMemAllocType (pctxt, ASN1BitStr32);

         if (pvalue->u.n2TxAntenna_tm3 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.n2TxAntenna_tm3->numbits = 0;

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

         stat = pd_BitString32 (pctxt, pvalue->u.n2TxAntenna_tm3
            , OSUINTCONST(2), OSUINTCONST(2));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* n4TxAntenna_tm3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "n4TxAntenna-tm3");

         pvalue->u.n4TxAntenna_tm3 = rtxMemAllocType (pctxt, ASN1BitStr32);

         if (pvalue->u.n4TxAntenna_tm3 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.n4TxAntenna_tm3->numbits = 0;

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

         stat = pd_BitString32 (pctxt, pvalue->u.n4TxAntenna_tm3
            , OSUINTCONST(4), OSUINTCONST(4));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* n2TxAntenna_tm4 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "n2TxAntenna-tm4");

         pvalue->u.n2TxAntenna_tm4 = rtxMemAllocType (pctxt, ASN1BitStr32);

         if (pvalue->u.n2TxAntenna_tm4 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.n2TxAntenna_tm4->numbits = 0;

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

         stat = pd_BitString32 (pctxt, pvalue->u.n2TxAntenna_tm4
            , OSUINTCONST(6), OSUINTCONST(6));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* n4TxAntenna_tm4 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "n4TxAntenna-tm4");

         pvalue->u.n4TxAntenna_tm4 = rtxMemAllocType (pctxt, 
            AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4);

         if (pvalue->u.n4TxAntenna_tm4 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4 (pvalue->u.n4TxAntenna_tm4);

         stat = asn1PD_AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4 (pctxt, pvalue->u.n4TxAntenna_tm4);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* n2TxAntenna_tm5 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "n2TxAntenna-tm5");

         pvalue->u.n2TxAntenna_tm5 = rtxMemAllocType (pctxt, ASN1BitStr32);

         if (pvalue->u.n2TxAntenna_tm5 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.n2TxAntenna_tm5->numbits = 0;

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

         stat = pd_BitString32 (pctxt, pvalue->u.n2TxAntenna_tm5
            , OSUINTCONST(4), OSUINTCONST(4));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* n4TxAntenna_tm5 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "n4TxAntenna-tm5");

         pvalue->u.n4TxAntenna_tm5 = rtxMemAllocType (pctxt, ASN1BitStr32);

         if (pvalue->u.n4TxAntenna_tm5 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.n4TxAntenna_tm5->numbits = 0;

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

         stat = pd_BitString32 (pctxt, pvalue->u.n4TxAntenna_tm5
            , OSUINTCONST(16), OSUINTCONST(16));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* n2TxAntenna_tm6 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "n2TxAntenna-tm6");

         pvalue->u.n2TxAntenna_tm6 = rtxMemAllocType (pctxt, ASN1BitStr32);

         if (pvalue->u.n2TxAntenna_tm6 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.n2TxAntenna_tm6->numbits = 0;

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

         stat = pd_BitString32 (pctxt, pvalue->u.n2TxAntenna_tm6
            , OSUINTCONST(4), OSUINTCONST(4));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* n4TxAntenna_tm6 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "n4TxAntenna-tm6");

         pvalue->u.n4TxAntenna_tm6 = rtxMemAllocType (pctxt, ASN1BitStr32);

         if (pvalue->u.n4TxAntenna_tm6 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.n4TxAntenna_tm6->numbits = 0;

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

         stat = pd_BitString32 (pctxt, pvalue->u.n4TxAntenna_tm6
            , OSUINTCONST(16), OSUINTCONST(16));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_AntennaInfoDedicated_codebookSubsetRestriction (
   AntennaInfoDedicated_codebookSubsetRestriction* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_AntennaInfoDedicated_ue_TransmitAntennaSelection (OSCTXT* pctxt, AntennaInfoDedicated_ue_TransmitAntennaSelection* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("AntennaInfoDedicated_ue_TransmitAntennaSelection"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_AntennaInfoDedicated_ue_TransmitAntennaSelection_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AntennaInfoDedicated_ue_TransmitAntennaSelection (OSCTXT* pctxt, AntennaInfoDedicated_ue_TransmitAntennaSelection* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PD_AntennaInfoDedicated_ue_TransmitAntennaSelection_setup (pctxt, &pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_AntennaInfoDedicated_ue_TransmitAntennaSelection (
   AntennaInfoDedicated_ue_TransmitAntennaSelection* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_AntennaInfoDedicated (OSCTXT* pctxt, AntennaInfoDedicated* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AntennaInfoDedicated");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("AntennaInfoDedicated"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.codebookSubsetRestrictionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode transmissionMode */

   RTXCTXTPUSHELEMNAME (pctxt, "transmissionMode");

   stat = asn1PE_AntennaInfoDedicated_transmissionMode (pctxt, pvalue->transmissionMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode codebookSubsetRestriction */

   if (pvalue->m.codebookSubsetRestrictionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "codebookSubsetRestriction");

      stat = asn1PE_AntennaInfoDedicated_codebookSubsetRestriction (pctxt, &pvalue->codebookSubsetRestriction);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode ue_TransmitAntennaSelection */

   RTXCTXTPUSHELEMNAME (pctxt, "ue-TransmitAntennaSelection");

   stat = asn1PE_AntennaInfoDedicated_ue_TransmitAntennaSelection (pctxt, &pvalue->ue_TransmitAntennaSelection);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AntennaInfoDedicated (OSCTXT* pctxt, AntennaInfoDedicated* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AntennaInfoDedicated");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode transmissionMode */
   RTXCTXTPUSHELEMNAME (pctxt, "transmissionMode");

   stat = asn1PD_AntennaInfoDedicated_transmissionMode (pctxt, &pvalue->transmissionMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode codebookSubsetRestriction */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "codebookSubsetRestriction");

      pvalue->m.codebookSubsetRestrictionPresent = 1;

      stat = asn1PD_AntennaInfoDedicated_codebookSubsetRestriction (pctxt, &pvalue->codebookSubsetRestriction);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ue_TransmitAntennaSelection */
   RTXCTXTPUSHELEMNAME (pctxt, "ue-TransmitAntennaSelection");

   stat = asn1PD_AntennaInfoDedicated_ue_TransmitAntennaSelection (pctxt, &pvalue->ue_TransmitAntennaSelection);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_AntennaInfoDedicated (AntennaInfoDedicated* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_AntennaInfoDedicated_codebookSubsetRestriction (&pvalue->codebookSubsetRestriction);
   asn1Init_AntennaInfoDedicated_ue_TransmitAntennaSelection (&pvalue->ue_TransmitAntennaSelection);
}

EXTERN int asn1PE_PhysicalConfigDedicated_antennaInfo (OSCTXT* pctxt, PhysicalConfigDedicated_antennaInfo* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhysicalConfigDedicated_antennaInfo"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* explicitValue */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "explicitValue");

         stat = asn1PE_AntennaInfoDedicated (pctxt, pvalue->u.explicitValue);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* defaultValue */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultValue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhysicalConfigDedicated_antennaInfo (OSCTXT* pctxt, PhysicalConfigDedicated_antennaInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* explicitValue */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "explicitValue");

         pvalue->u.explicitValue = rtxMemAllocType (pctxt, 
            AntennaInfoDedicated);

         if (pvalue->u.explicitValue == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AntennaInfoDedicated (pvalue->u.explicitValue);

         stat = asn1PD_AntennaInfoDedicated (pctxt, pvalue->u.explicitValue);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* defaultValue */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "defaultValue");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_PhysicalConfigDedicated_antennaInfo (
   PhysicalConfigDedicated_antennaInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_SchedulingRequestConfig_setup (OSCTXT* pctxt, SchedulingRequestConfig_setup* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SchedulingRequestConfig_setup"));

   /* encode sr_PUCCH_ResourceIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "sr-PUCCH-ResourceIndex");

   if ( (pvalue->sr_PUCCH_ResourceIndex <= OSUINTCONST(2047)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->sr_PUCCH_ResourceIndex, OSUINTCONST(0), OSUINTCONST(2047));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->sr_PUCCH_ResourceIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sr_ConfigIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "sr-ConfigIndex");

   if ( (pvalue->sr_ConfigIndex <= OSUINTCONST(157)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->sr_ConfigIndex, OSUINTCONST(0), OSUINTCONST(157));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->sr_ConfigIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dsr_TransMax */

   RTXCTXTPUSHELEMNAME (pctxt, "dsr-TransMax");

   stat = asn1PE_SchedulingRequestConfig_setup_dsr_TransMax (pctxt, pvalue->dsr_TransMax);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SchedulingRequestConfig_setup (OSCTXT* pctxt, SchedulingRequestConfig_setup* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode sr_PUCCH_ResourceIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "sr-PUCCH-ResourceIndex");

   stat = pd_ConsUInt16 (pctxt, &pvalue->sr_PUCCH_ResourceIndex, OSUINTCONST(0), OSUINTCONST(2047));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sr_ConfigIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "sr-ConfigIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->sr_ConfigIndex, OSUINTCONST(0), OSUINTCONST(157));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dsr_TransMax */
   RTXCTXTPUSHELEMNAME (pctxt, "dsr-TransMax");

   stat = asn1PD_SchedulingRequestConfig_setup_dsr_TransMax (pctxt, &pvalue->dsr_TransMax);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SchedulingRequestConfig (OSCTXT* pctxt, SchedulingRequestConfig* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SchedulingRequestConfig");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SchedulingRequestConfig"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_SchedulingRequestConfig_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SchedulingRequestConfig (OSCTXT* pctxt, SchedulingRequestConfig* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "SchedulingRequestConfig");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         pvalue->u.setup = rtxMemAllocTypeZ (pctxt, 
            SchedulingRequestConfig_setup);

         if (pvalue->u.setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_SchedulingRequestConfig_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SchedulingRequestConfig (SchedulingRequestConfig* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_CQI_ReportConfig_v920 (OSCTXT* pctxt, CQI_ReportConfig_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CQI-ReportConfig-v920");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CQI_ReportConfig_v920"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cqi_Mask_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.pmi_RI_Report_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cqi_Mask_r9 */

   if (pvalue->m.cqi_Mask_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "cqi-Mask-r9");

      stat = asn1PE_CQI_ReportConfig_v920_cqi_Mask_r9 (pctxt, pvalue->cqi_Mask_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode pmi_RI_Report_r9 */

   if (pvalue->m.pmi_RI_Report_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "pmi-RI-Report-r9");

      stat = asn1PE_CQI_ReportConfig_v920_pmi_RI_Report_r9 (pctxt, pvalue->pmi_RI_Report_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CQI_ReportConfig_v920 (OSCTXT* pctxt, CQI_ReportConfig_v920* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "CQI-ReportConfig-v920");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cqi_Mask_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cqi-Mask-r9");

      pvalue->m.cqi_Mask_r9Present = 1;

      stat = asn1PD_CQI_ReportConfig_v920_cqi_Mask_r9 (pctxt, &pvalue->cqi_Mask_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pmi_RI_Report_r9 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pmi-RI-Report-r9");

      pvalue->m.pmi_RI_Report_r9Present = 1;

      stat = asn1PD_CQI_ReportConfig_v920_pmi_RI_Report_r9 (pctxt, &pvalue->pmi_RI_Report_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CQI_ReportConfig_v920 (CQI_ReportConfig_v920* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_AntennaInfoDedicated_v920_codebookSubsetRestriction_v920 (OSCTXT* pctxt, AntennaInfoDedicated_v920_codebookSubsetRestriction_v920* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("AntennaInfoDedicated_v920_codebookSubsetRestriction_v920"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* n2TxAntenna_tm8_r9 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "n2TxAntenna-tm8-r9");

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

         stat = pe_BitString32 (pctxt, pvalue->u.n2TxAntenna_tm8_r9, OSUINTCONST(6), OSUINTCONST(6));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* n4TxAntenna_tm8_r9 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "n4TxAntenna-tm8-r9");

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(32), OSUINTCONST(32), 0, 0);

         stat = pe_BitString32 (pctxt, pvalue->u.n4TxAntenna_tm8_r9, OSUINTCONST(32), OSUINTCONST(32));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AntennaInfoDedicated_v920_codebookSubsetRestriction_v920 (OSCTXT* pctxt, AntennaInfoDedicated_v920_codebookSubsetRestriction_v920* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* n2TxAntenna_tm8_r9 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "n2TxAntenna-tm8-r9");

         pvalue->u.n2TxAntenna_tm8_r9 = rtxMemAllocType (pctxt, ASN1BitStr32);

         if (pvalue->u.n2TxAntenna_tm8_r9 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.n2TxAntenna_tm8_r9->numbits = 0;

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

         stat = pd_BitString32 (pctxt, pvalue->u.n2TxAntenna_tm8_r9
            , OSUINTCONST(6), OSUINTCONST(6));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* n4TxAntenna_tm8_r9 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "n4TxAntenna-tm8-r9");

         pvalue->u.n4TxAntenna_tm8_r9 = rtxMemAllocType (pctxt, ASN1BitStr32);

         if (pvalue->u.n4TxAntenna_tm8_r9 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.n4TxAntenna_tm8_r9->numbits = 0;

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(32), OSUINTCONST(32), 0, 0);

         stat = pd_BitString32 (pctxt, pvalue->u.n4TxAntenna_tm8_r9
            , OSUINTCONST(32), OSUINTCONST(32));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_AntennaInfoDedicated_v920_codebookSubsetRestriction_v920 (
   AntennaInfoDedicated_v920_codebookSubsetRestriction_v920* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_AntennaInfoDedicated_v920 (OSCTXT* pctxt, AntennaInfoDedicated_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AntennaInfoDedicated-v920");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("AntennaInfoDedicated_v920"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.codebookSubsetRestriction_v920Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode codebookSubsetRestriction_v920 */

   if (pvalue->m.codebookSubsetRestriction_v920Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "codebookSubsetRestriction-v920");

      stat = asn1PE_AntennaInfoDedicated_v920_codebookSubsetRestriction_v920 (pctxt, &pvalue->codebookSubsetRestriction_v920);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AntennaInfoDedicated_v920 (OSCTXT* pctxt, AntennaInfoDedicated_v920* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AntennaInfoDedicated-v920");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode codebookSubsetRestriction_v920 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "codebookSubsetRestriction-v920");

      pvalue->m.codebookSubsetRestriction_v920Present = 1;

      stat = asn1PD_AntennaInfoDedicated_v920_codebookSubsetRestriction_v920 (pctxt, &pvalue->codebookSubsetRestriction_v920);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_AntennaInfoDedicated_v920 (AntennaInfoDedicated_v920* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_AntennaInfoDedicated_v920_codebookSubsetRestriction_v920 (&pvalue->codebookSubsetRestriction_v920);
}

EXTERN int asn1PE_PhysicalConfigDedicated (OSCTXT* pctxt, PhysicalConfigDedicated* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysicalConfigDedicated");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhysicalConfigDedicated"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m._v2ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.pdsch_ConfigDedicatedPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.pucch_ConfigDedicatedPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.pusch_ConfigDedicatedPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uplinkPowerControlDedicatedPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.tpc_PDCCH_ConfigPUCCHPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.tpc_PDCCH_ConfigPUSCHPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cqi_ReportConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.soundingRS_UL_ConfigDedicatedPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.antennaInfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.schedulingRequestConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pdsch_ConfigDedicated */

   if (pvalue->m.pdsch_ConfigDedicatedPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdsch-ConfigDedicated");

      stat = asn1PE_PDSCH_ConfigDedicated (pctxt, &pvalue->pdsch_ConfigDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode pucch_ConfigDedicated */

   if (pvalue->m.pucch_ConfigDedicatedPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pucch-ConfigDedicated");

      stat = asn1PE_PUCCH_ConfigDedicated (pctxt, &pvalue->pucch_ConfigDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode pusch_ConfigDedicated */

   if (pvalue->m.pusch_ConfigDedicatedPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pusch-ConfigDedicated");

      stat = asn1PE_PUSCH_ConfigDedicated (pctxt, &pvalue->pusch_ConfigDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode uplinkPowerControlDedicated */

   if (pvalue->m.uplinkPowerControlDedicatedPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "uplinkPowerControlDedicated");

      stat = asn1PE_UplinkPowerControlDedicated (pctxt, &pvalue->uplinkPowerControlDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode tpc_PDCCH_ConfigPUCCH */

   if (pvalue->m.tpc_PDCCH_ConfigPUCCHPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "tpc-PDCCH-ConfigPUCCH");

      stat = asn1PE_TPC_PDCCH_Config (pctxt, &pvalue->tpc_PDCCH_ConfigPUCCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode tpc_PDCCH_ConfigPUSCH */

   if (pvalue->m.tpc_PDCCH_ConfigPUSCHPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "tpc-PDCCH-ConfigPUSCH");

      stat = asn1PE_TPC_PDCCH_Config (pctxt, &pvalue->tpc_PDCCH_ConfigPUSCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cqi_ReportConfig */

   if (pvalue->m.cqi_ReportConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cqi-ReportConfig");

      stat = asn1PE_CQI_ReportConfig (pctxt, &pvalue->cqi_ReportConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode soundingRS_UL_ConfigDedicated */

   if (pvalue->m.soundingRS_UL_ConfigDedicatedPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "soundingRS-UL-ConfigDedicated");

      stat = asn1PE_SoundingRS_UL_ConfigDedicated (pctxt, &pvalue->soundingRS_UL_ConfigDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode antennaInfo */

   if (pvalue->m.antennaInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "antennaInfo");

      stat = asn1PE_PhysicalConfigDedicated_antennaInfo (pctxt, &pvalue->antennaInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode schedulingRequestConfig */

   if (pvalue->m.schedulingRequestConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "schedulingRequestConfig");

      stat = asn1PE_SchedulingRequestConfig (pctxt, &pvalue->schedulingRequestConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v2ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m._v2ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cqi_ReportConfig_v920Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.antennaInfo_v920Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode cqi_ReportConfig_v920 */

         if (pvalue->m.cqi_ReportConfig_v920Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "cqi-ReportConfig-v920");

            stat = asn1PE_CQI_ReportConfig_v920 (pctxt, &pvalue->cqi_ReportConfig_v920);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         /* encode antennaInfo_v920 */

         if (pvalue->m.antennaInfo_v920Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "antennaInfo-v920");

            stat = asn1PE_AntennaInfoDedicated_v920 (pctxt, &pvalue->antennaInfo_v920);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhysicalConfigDedicated (OSCTXT* pctxt, PhysicalConfigDedicated* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[10];

   RTXCTXTPUSHTYPENAME (pctxt, "PhysicalConfigDedicated");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 10; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pdsch_ConfigDedicated */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdsch-ConfigDedicated");

      pvalue->m.pdsch_ConfigDedicatedPresent = 1;

      stat = asn1PD_PDSCH_ConfigDedicated (pctxt, &pvalue->pdsch_ConfigDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pucch_ConfigDedicated */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pucch-ConfigDedicated");

      pvalue->m.pucch_ConfigDedicatedPresent = 1;

      stat = asn1PD_PUCCH_ConfigDedicated (pctxt, &pvalue->pucch_ConfigDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pusch_ConfigDedicated */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pusch-ConfigDedicated");

      pvalue->m.pusch_ConfigDedicatedPresent = 1;

      stat = asn1PD_PUSCH_ConfigDedicated (pctxt, &pvalue->pusch_ConfigDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uplinkPowerControlDedicated */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uplinkPowerControlDedicated");

      pvalue->m.uplinkPowerControlDedicatedPresent = 1;

      stat = asn1PD_UplinkPowerControlDedicated (pctxt, &pvalue->uplinkPowerControlDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tpc_PDCCH_ConfigPUCCH */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tpc-PDCCH-ConfigPUCCH");

      pvalue->m.tpc_PDCCH_ConfigPUCCHPresent = 1;

      stat = asn1PD_TPC_PDCCH_Config (pctxt, &pvalue->tpc_PDCCH_ConfigPUCCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tpc_PDCCH_ConfigPUSCH */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tpc-PDCCH-ConfigPUSCH");

      pvalue->m.tpc_PDCCH_ConfigPUSCHPresent = 1;

      stat = asn1PD_TPC_PDCCH_Config (pctxt, &pvalue->tpc_PDCCH_ConfigPUSCH);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cqi_ReportConfig */
   if (optbits[6]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cqi-ReportConfig");

      pvalue->m.cqi_ReportConfigPresent = 1;

      stat = asn1PD_CQI_ReportConfig (pctxt, &pvalue->cqi_ReportConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode soundingRS_UL_ConfigDedicated */
   if (optbits[7]) {
      RTXCTXTPUSHELEMNAME (pctxt, "soundingRS-UL-ConfigDedicated");

      pvalue->m.soundingRS_UL_ConfigDedicatedPresent = 1;

      stat = asn1PD_SoundingRS_UL_ConfigDedicated (pctxt, &pvalue->soundingRS_UL_ConfigDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode antennaInfo */
   if (optbits[8]) {
      RTXCTXTPUSHELEMNAME (pctxt, "antennaInfo");

      pvalue->m.antennaInfoPresent = 1;

      stat = asn1PD_PhysicalConfigDedicated_antennaInfo (pctxt, &pvalue->antennaInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode schedulingRequestConfig */
   if (optbits[9]) {
      RTXCTXTPUSHELEMNAME (pctxt, "schedulingRequestConfig");

      pvalue->m.schedulingRequestConfigPresent = 1;

      stat = asn1PD_SchedulingRequestConfig (pctxt, &pvalue->schedulingRequestConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m._v2ExtPresent = 1;
                        {
                           OSOCTET extoptbits[2];
                           OSUINT32 _i;

                           for (_i = 0; _i < 2; _i++) {
                              stat = DEC_BIT (pctxt, &extoptbits[_i]);
                              if (stat != 0)  {
                                 rtxMemFreePtr (pctxt, poptbits);
                                 return LOG_RTERR (pctxt, stat);
                              }
                           }
                           if (extoptbits[0]) {
                              pvalue->m.cqi_ReportConfig_v920Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "cqi-ReportConfig-v920");

                              stat = asn1PD_CQI_ReportConfig_v920 (pctxt, &pvalue->cqi_ReportConfig_v920);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                           if (extoptbits[1]) {
                              pvalue->m.antennaInfo_v920Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "antennaInfo-v920");

                              stat = asn1PD_AntennaInfoDedicated_v920 (pctxt, &pvalue->antennaInfo_v920);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;

                        /* Coverity 55357 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PhysicalConfigDedicated (PhysicalConfigDedicated* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PUCCH_ConfigDedicated (&pvalue->pucch_ConfigDedicated);
   asn1Init_UplinkPowerControlDedicated (&pvalue->uplinkPowerControlDedicated);
   asn1Init_TPC_PDCCH_Config (&pvalue->tpc_PDCCH_ConfigPUCCH);
   asn1Init_TPC_PDCCH_Config (&pvalue->tpc_PDCCH_ConfigPUSCH);
   asn1Init_CQI_ReportConfig (&pvalue->cqi_ReportConfig);
   asn1Init_SoundingRS_UL_ConfigDedicated (&pvalue->soundingRS_UL_ConfigDedicated);
   asn1Init_PhysicalConfigDedicated_antennaInfo (&pvalue->antennaInfo);
   asn1Init_SchedulingRequestConfig (&pvalue->schedulingRequestConfig);
   asn1Init_CQI_ReportConfig_v920 (&pvalue->cqi_ReportConfig_v920);
   asn1Init_AntennaInfoDedicated_v920 (&pvalue->antennaInfo_v920);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_RLF_TimersAndConstants_r9_setup (OSCTXT* pctxt, RLF_TimersAndConstants_r9_setup* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLF_TimersAndConstants_r9_setup"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode t301_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "t301-r9");

   stat = asn1PE_RLF_TimersAndConstants_r9_setup_t301_r9 (pctxt, pvalue->t301_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t310_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "t310-r9");

   stat = asn1PE_RLF_TimersAndConstants_r9_setup_t310_r9 (pctxt, pvalue->t310_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode n310_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "n310-r9");

   stat = asn1PE_RLF_TimersAndConstants_r9_setup_n310_r9 (pctxt, pvalue->n310_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode t311_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "t311-r9");

   stat = asn1PE_RLF_TimersAndConstants_r9_setup_t311_r9 (pctxt, pvalue->t311_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode n311_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "n311-r9");

   stat = asn1PE_RLF_TimersAndConstants_r9_setup_n311_r9 (pctxt, pvalue->n311_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLF_TimersAndConstants_r9_setup (OSCTXT* pctxt, RLF_TimersAndConstants_r9_setup* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode t301_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "t301-r9");

   stat = asn1PD_RLF_TimersAndConstants_r9_setup_t301_r9 (pctxt, &pvalue->t301_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t310_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "t310-r9");

   stat = asn1PD_RLF_TimersAndConstants_r9_setup_t310_r9 (pctxt, &pvalue->t310_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode n310_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "n310-r9");

   stat = asn1PD_RLF_TimersAndConstants_r9_setup_n310_r9 (pctxt, &pvalue->n310_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t311_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "t311-r9");

   stat = asn1PD_RLF_TimersAndConstants_r9_setup_t311_r9 (pctxt, &pvalue->t311_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode n311_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "n311-r9");

   stat = asn1PD_RLF_TimersAndConstants_r9_setup_n311_r9 (pctxt, &pvalue->n311_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

void asn1Init_RLF_TimersAndConstants_r9_setup (
   RLF_TimersAndConstants_r9_setup* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_RLF_TimersAndConstants_r9 (OSCTXT* pctxt, RLF_TimersAndConstants_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RLF-TimersAndConstants-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLF_TimersAndConstants_r9"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_RLF_TimersAndConstants_r9_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLF_TimersAndConstants_r9 (OSCTXT* pctxt, RLF_TimersAndConstants_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "RLF-TimersAndConstants-r9");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         pvalue->u.setup = rtxMemAllocType (pctxt, 
            RLF_TimersAndConstants_r9_setup);

         if (pvalue->u.setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RLF_TimersAndConstants_r9_setup (pvalue->u.setup);

         stat = asn1PD_RLF_TimersAndConstants_r9_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RLF_TimersAndConstants_r9 (RLF_TimersAndConstants_r9* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RadioResourceConfigDedicated (OSCTXT* pctxt, RadioResourceConfigDedicated* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "RadioResourceConfigDedicated");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RadioResourceConfigDedicated"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m._v2ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.srb_ToAddModListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.drb_ToAddModListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.drb_ToReleaseListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.mac_MainConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.sps_ConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.physicalConfigDedicatedPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode srb_ToAddModList */

   if (pvalue->m.srb_ToAddModListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "srb-ToAddModList");

      stat = asn1PE_SRB_ToAddModList (pctxt, &pvalue->srb_ToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode drb_ToAddModList */

   if (pvalue->m.drb_ToAddModListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "drb-ToAddModList");

      stat = asn1PE_DRB_ToAddModList (pctxt, &pvalue->drb_ToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode drb_ToReleaseList */

   if (pvalue->m.drb_ToReleaseListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "drb-ToReleaseList");

      stat = asn1PE_DRB_ToReleaseList (pctxt, &pvalue->drb_ToReleaseList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode mac_MainConfig */

   if (pvalue->m.mac_MainConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-MainConfig");

      stat = asn1PE_RadioResourceConfigDedicated_mac_MainConfig (pctxt, &pvalue->mac_MainConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode sps_Config */

   if (pvalue->m.sps_ConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "sps-Config");

      stat = asn1PE_SPS_Config (pctxt, &pvalue->sps_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode physicalConfigDedicated */

   if (pvalue->m.physicalConfigDedicatedPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "physicalConfigDedicated");

      stat = asn1PE_PhysicalConfigDedicated (pctxt, &pvalue->physicalConfigDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v2ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m._v2ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rlf_TimersAndConstants_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode rlf_TimersAndConstants_r9 */

         if (pvalue->m.rlf_TimersAndConstants_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "rlf-TimersAndConstants-r9");

            stat = asn1PE_RLF_TimersAndConstants_r9 (pctxt, &pvalue->rlf_TimersAndConstants_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RadioResourceConfigDedicated (OSCTXT* pctxt, RadioResourceConfigDedicated* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[6];

   RTXCTXTPUSHTYPENAME (pctxt, "RadioResourceConfigDedicated");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode srb_ToAddModList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "srb-ToAddModList");

      pvalue->m.srb_ToAddModListPresent = 1;

      stat = asn1PD_SRB_ToAddModList (pctxt, &pvalue->srb_ToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode drb_ToAddModList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "drb-ToAddModList");

      pvalue->m.drb_ToAddModListPresent = 1;

      stat = asn1PD_DRB_ToAddModList (pctxt, &pvalue->drb_ToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode drb_ToReleaseList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "drb-ToReleaseList");

      pvalue->m.drb_ToReleaseListPresent = 1;

      stat = asn1PD_DRB_ToReleaseList (pctxt, &pvalue->drb_ToReleaseList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mac_MainConfig */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mac-MainConfig");

      pvalue->m.mac_MainConfigPresent = 1;

      stat = asn1PD_RadioResourceConfigDedicated_mac_MainConfig (pctxt, &pvalue->mac_MainConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode sps_Config */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sps-Config");

      pvalue->m.sps_ConfigPresent = 1;

      stat = asn1PD_SPS_Config (pctxt, &pvalue->sps_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode physicalConfigDedicated */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "physicalConfigDedicated");

      pvalue->m.physicalConfigDedicatedPresent = 1;

      stat = asn1PD_PhysicalConfigDedicated (pctxt, &pvalue->physicalConfigDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m._v2ExtPresent = 1;
                        {
                           OSOCTET extoptbits[1];

                           stat = DEC_BIT (pctxt, &extoptbits[0]);
                           if (stat != 0)  {
                              rtxMemFreePtr (pctxt, poptbits);
                           }
                           if (extoptbits[0]) {
                              pvalue->m.rlf_TimersAndConstants_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "rlf-TimersAndConstants-r9");

                              stat = asn1PD_RLF_TimersAndConstants_r9 (pctxt, &pvalue->rlf_TimersAndConstants_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;

                        /* Coverity 55355 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RadioResourceConfigDedicated (
   RadioResourceConfigDedicated* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SRB_ToAddModList (&pvalue->srb_ToAddModList);
   asn1Init_DRB_ToAddModList (&pvalue->drb_ToAddModList);
   asn1Init_DRB_ToReleaseList (&pvalue->drb_ToReleaseList);
   asn1Init_RadioResourceConfigDedicated_mac_MainConfig (&pvalue->mac_MainConfig);
   asn1Init_SPS_Config (&pvalue->sps_Config);
   asn1Init_PhysicalConfigDedicated (&pvalue->physicalConfigDedicated);
   asn1Init_RLF_TimersAndConstants_r9 (&pvalue->rlf_TimersAndConstants_r9);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_RRCConnectionReestablishment_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionReestablishment_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishment_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishment_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionReestablishment_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionReestablishment_v8a0_IEs (OSCTXT* pctxt, RRCConnectionReestablishment_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishment-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishment_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionReestablishment_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishment_v8a0_IEs (OSCTXT* pctxt, RRCConnectionReestablishment_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishment-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionReestablishment_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReestablishment_v8a0_IEs (
   RRCConnectionReestablishment_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_RRCConnectionReestablishment_r8_IEs (OSCTXT* pctxt, RRCConnectionReestablishment_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishment-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishment_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode radioResourceConfigDedicated */

   RTXCTXTPUSHELEMNAME (pctxt, "radioResourceConfigDedicated");

   stat = asn1PE_RadioResourceConfigDedicated (pctxt, &pvalue->radioResourceConfigDedicated);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nextHopChainingCount */

   RTXCTXTPUSHELEMNAME (pctxt, "nextHopChainingCount");

   stat = asn1PE_NextHopChainingCount (pctxt, pvalue->nextHopChainingCount);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionReestablishment_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishment_r8_IEs (OSCTXT* pctxt, RRCConnectionReestablishment_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishment-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode radioResourceConfigDedicated */
   RTXCTXTPUSHELEMNAME (pctxt, "radioResourceConfigDedicated");

   stat = asn1PD_RadioResourceConfigDedicated (pctxt, &pvalue->radioResourceConfigDedicated);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nextHopChainingCount */
   RTXCTXTPUSHELEMNAME (pctxt, "nextHopChainingCount");

   stat = asn1PD_NextHopChainingCount (pctxt, &pvalue->nextHopChainingCount);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionReestablishment_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReestablishment_r8_IEs (
   RRCConnectionReestablishment_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RadioResourceConfigDedicated (&pvalue->radioResourceConfigDedicated);
   asn1Init_RRCConnectionReestablishment_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_RRCConnectionReestablishment_criticalExtensions_c1 (OSCTXT* pctxt, RRCConnectionReestablishment_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishment_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* rrcConnectionReestablishment_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishment-r8");

         stat = asn1PE_RRCConnectionReestablishment_r8_IEs (pctxt, pvalue->u.rrcConnectionReestablishment_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare7 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare6 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare5 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare4 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishment_criticalExtensions_c1 (OSCTXT* pctxt, RRCConnectionReestablishment_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rrcConnectionReestablishment_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishment-r8");

         pvalue->u.rrcConnectionReestablishment_r8 = rtxMemAllocType (pctxt, 
            RRCConnectionReestablishment_r8_IEs);

         if (pvalue->u.rrcConnectionReestablishment_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReestablishment_r8_IEs (pvalue->u.rrcConnectionReestablishment_r8);

         stat = asn1PD_RRCConnectionReestablishment_r8_IEs (pctxt, pvalue->u.rrcConnectionReestablishment_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare7 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare6 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare5 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare4 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionReestablishment_criticalExtensions_c1 (
   RRCConnectionReestablishment_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionReestablishment_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionReestablishment_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishment_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishment_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionReestablishment_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionReestablishment_criticalExtensions (OSCTXT* pctxt, RRCConnectionReestablishment_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishment_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_RRCConnectionReestablishment_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_RRCConnectionReestablishment_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishment_criticalExtensions (OSCTXT* pctxt, RRCConnectionReestablishment_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            RRCConnectionReestablishment_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReestablishment_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_RRCConnectionReestablishment_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            RRCConnectionReestablishment_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_RRCConnectionReestablishment_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionReestablishment_criticalExtensions (
   RRCConnectionReestablishment_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionReestablishment (OSCTXT* pctxt, RRCConnectionReestablishment* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishment");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishment"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_RRCConnectionReestablishment_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishment (OSCTXT* pctxt, RRCConnectionReestablishment* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishment");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_RRCConnectionReestablishment_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReestablishment (
   RRCConnectionReestablishment* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_RRCConnectionReestablishment_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_RRCConnectionReestablishmentReject_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionReestablishmentReject_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentReject_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentReject_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionReestablishmentReject_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionReestablishmentReject_v8a0_IEs (OSCTXT* pctxt, RRCConnectionReestablishmentReject_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentReject-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentReject_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionReestablishmentReject_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentReject_v8a0_IEs (OSCTXT* pctxt, RRCConnectionReestablishmentReject_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentReject-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionReestablishmentReject_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReestablishmentReject_v8a0_IEs (
   RRCConnectionReestablishmentReject_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_RRCConnectionReestablishmentReject_r8_IEs (OSCTXT* pctxt, RRCConnectionReestablishmentReject_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentReject-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentReject_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionReestablishmentReject_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentReject_r8_IEs (OSCTXT* pctxt, RRCConnectionReestablishmentReject_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentReject-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionReestablishmentReject_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReestablishmentReject_r8_IEs (
   RRCConnectionReestablishmentReject_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RRCConnectionReestablishmentReject_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_RRCConnectionReestablishmentReject_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionReestablishmentReject_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentReject_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentReject_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionReestablishmentReject_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionReestablishmentReject_criticalExtensions (OSCTXT* pctxt, RRCConnectionReestablishmentReject_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentReject_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* rrcConnectionReestablishmentReject_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishmentReject-r8");

         stat = asn1PE_RRCConnectionReestablishmentReject_r8_IEs (pctxt, pvalue->u.rrcConnectionReestablishmentReject_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_RRCConnectionReestablishmentReject_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentReject_criticalExtensions (OSCTXT* pctxt, RRCConnectionReestablishmentReject_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rrcConnectionReestablishmentReject_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishmentReject-r8");

         pvalue->u.rrcConnectionReestablishmentReject_r8
             = rtxMemAllocType (pctxt, 
            RRCConnectionReestablishmentReject_r8_IEs);

         if (pvalue->u.rrcConnectionReestablishmentReject_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReestablishmentReject_r8_IEs (pvalue->u.rrcConnectionReestablishmentReject_r8);

         stat = asn1PD_RRCConnectionReestablishmentReject_r8_IEs (pctxt, pvalue->u.rrcConnectionReestablishmentReject_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            RRCConnectionReestablishmentReject_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_RRCConnectionReestablishmentReject_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionReestablishmentReject_criticalExtensions (
   RRCConnectionReestablishmentReject_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionReestablishmentReject (OSCTXT* pctxt, RRCConnectionReestablishmentReject* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentReject");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentReject"));

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_RRCConnectionReestablishmentReject_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentReject (OSCTXT* pctxt, RRCConnectionReestablishmentReject* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentReject");

   /* decode root elements */
   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_RRCConnectionReestablishmentReject_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReestablishmentReject (
   RRCConnectionReestablishmentReject* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_RRCConnectionReestablishmentReject_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_RRCConnectionReject_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionReject_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReject_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReject_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionReject_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionReject_v8a0_IEs (OSCTXT* pctxt, RRCConnectionReject_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReject-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReject_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionReject_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReject_v8a0_IEs (OSCTXT* pctxt, RRCConnectionReject_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReject-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionReject_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReject_v8a0_IEs (
   RRCConnectionReject_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_RRCConnectionReject_r8_IEs (OSCTXT* pctxt, RRCConnectionReject_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReject-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReject_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode waitTime */

   RTXCTXTPUSHELEMNAME (pctxt, "waitTime");

   if ( (pvalue->waitTime >= OSUINTCONST(1) && pvalue->waitTime <= OSUINTCONST(16)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->waitTime, OSUINTCONST(1), OSUINTCONST(16));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->waitTime);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionReject_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReject_r8_IEs (OSCTXT* pctxt, RRCConnectionReject_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReject-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode waitTime */
   RTXCTXTPUSHELEMNAME (pctxt, "waitTime");

   stat = pd_ConsUInt8 (pctxt, &pvalue->waitTime, OSUINTCONST(1), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionReject_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReject_r8_IEs (RRCConnectionReject_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RRCConnectionReject_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_RRCConnectionReject_criticalExtensions_c1 (OSCTXT* pctxt, RRCConnectionReject_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReject_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* rrcConnectionReject_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReject-r8");

         stat = asn1PE_RRCConnectionReject_r8_IEs (pctxt, pvalue->u.rrcConnectionReject_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReject_criticalExtensions_c1 (OSCTXT* pctxt, RRCConnectionReject_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rrcConnectionReject_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReject-r8");

         pvalue->u.rrcConnectionReject_r8 = rtxMemAllocType (pctxt, 
            RRCConnectionReject_r8_IEs);

         if (pvalue->u.rrcConnectionReject_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReject_r8_IEs (pvalue->u.rrcConnectionReject_r8);

         stat = asn1PD_RRCConnectionReject_r8_IEs (pctxt, pvalue->u.rrcConnectionReject_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionReject_criticalExtensions_c1 (
   RRCConnectionReject_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionReject_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionReject_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReject_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReject_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionReject_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionReject_criticalExtensions (OSCTXT* pctxt, RRCConnectionReject_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReject_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_RRCConnectionReject_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_RRCConnectionReject_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReject_criticalExtensions (OSCTXT* pctxt, RRCConnectionReject_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            RRCConnectionReject_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReject_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_RRCConnectionReject_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            RRCConnectionReject_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_RRCConnectionReject_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionReject_criticalExtensions (
   RRCConnectionReject_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionReject (OSCTXT* pctxt, RRCConnectionReject* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReject");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReject"));

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_RRCConnectionReject_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReject (OSCTXT* pctxt, RRCConnectionReject* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReject");

   /* decode root elements */
   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_RRCConnectionReject_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReject (RRCConnectionReject* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_RRCConnectionReject_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_RRCConnectionSetup_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionSetup_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionSetup_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionSetup_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionSetup_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionSetup_v8a0_IEs (OSCTXT* pctxt, RRCConnectionSetup_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionSetup-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionSetup_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionSetup_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionSetup_v8a0_IEs (OSCTXT* pctxt, RRCConnectionSetup_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionSetup-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionSetup_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionSetup_v8a0_IEs (RRCConnectionSetup_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_RRCConnectionSetup_r8_IEs (OSCTXT* pctxt, RRCConnectionSetup_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionSetup-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionSetup_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode radioResourceConfigDedicated */

   RTXCTXTPUSHELEMNAME (pctxt, "radioResourceConfigDedicated");

   stat = asn1PE_RadioResourceConfigDedicated (pctxt, &pvalue->radioResourceConfigDedicated);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionSetup_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionSetup_r8_IEs (OSCTXT* pctxt, RRCConnectionSetup_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionSetup-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode radioResourceConfigDedicated */
   RTXCTXTPUSHELEMNAME (pctxt, "radioResourceConfigDedicated");

   stat = asn1PD_RadioResourceConfigDedicated (pctxt, &pvalue->radioResourceConfigDedicated);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionSetup_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionSetup_r8_IEs (RRCConnectionSetup_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RadioResourceConfigDedicated (&pvalue->radioResourceConfigDedicated);
   asn1Init_RRCConnectionSetup_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_RRCConnectionSetup_criticalExtensions_c1 (OSCTXT* pctxt, RRCConnectionSetup_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionSetup_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* rrcConnectionSetup_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionSetup-r8");

         stat = asn1PE_RRCConnectionSetup_r8_IEs (pctxt, pvalue->u.rrcConnectionSetup_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare7 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare6 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare5 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare4 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionSetup_criticalExtensions_c1 (OSCTXT* pctxt, RRCConnectionSetup_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rrcConnectionSetup_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionSetup-r8");

         pvalue->u.rrcConnectionSetup_r8 = rtxMemAllocType (pctxt, 
            RRCConnectionSetup_r8_IEs);

         if (pvalue->u.rrcConnectionSetup_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionSetup_r8_IEs (pvalue->u.rrcConnectionSetup_r8);

         stat = asn1PD_RRCConnectionSetup_r8_IEs (pctxt, pvalue->u.rrcConnectionSetup_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare7 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare6 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare5 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare4 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionSetup_criticalExtensions_c1 (
   RRCConnectionSetup_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionSetup_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionSetup_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionSetup_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionSetup_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionSetup_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionSetup_criticalExtensions (OSCTXT* pctxt, RRCConnectionSetup_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionSetup_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_RRCConnectionSetup_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_RRCConnectionSetup_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionSetup_criticalExtensions (OSCTXT* pctxt, RRCConnectionSetup_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            RRCConnectionSetup_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionSetup_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_RRCConnectionSetup_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            RRCConnectionSetup_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_RRCConnectionSetup_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionSetup_criticalExtensions (
   RRCConnectionSetup_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionSetup (OSCTXT* pctxt, RRCConnectionSetup* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionSetup");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionSetup"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_RRCConnectionSetup_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionSetup (OSCTXT* pctxt, RRCConnectionSetup* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionSetup");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_RRCConnectionSetup_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionSetup (RRCConnectionSetup* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_RRCConnectionSetup_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_DL_CCCH_MessageType_c1 (OSCTXT* pctxt, DL_CCCH_MessageType_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DL_CCCH_MessageType_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* rrcConnectionReestablishment */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishment");

         stat = asn1PE_RRCConnectionReestablishment (pctxt, pvalue->u.rrcConnectionReestablishment);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* rrcConnectionReestablishmentReject */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishmentReject");

         stat = asn1PE_RRCConnectionReestablishmentReject (pctxt, pvalue->u.rrcConnectionReestablishmentReject);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* rrcConnectionReject */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReject");

         stat = asn1PE_RRCConnectionReject (pctxt, pvalue->u.rrcConnectionReject);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* rrcConnectionSetup */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionSetup");

         stat = asn1PE_RRCConnectionSetup (pctxt, pvalue->u.rrcConnectionSetup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DL_CCCH_MessageType_c1 (OSCTXT* pctxt, DL_CCCH_MessageType_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rrcConnectionReestablishment */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishment");

         pvalue->u.rrcConnectionReestablishment = rtxMemAllocType (pctxt, 
            RRCConnectionReestablishment);

         if (pvalue->u.rrcConnectionReestablishment == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReestablishment (pvalue->u.rrcConnectionReestablishment);

         stat = asn1PD_RRCConnectionReestablishment (pctxt, pvalue->u.rrcConnectionReestablishment);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* rrcConnectionReestablishmentReject */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishmentReject");

         pvalue->u.rrcConnectionReestablishmentReject
             = rtxMemAllocType (pctxt, RRCConnectionReestablishmentReject);

         if (pvalue->u.rrcConnectionReestablishmentReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReestablishmentReject (pvalue->u.rrcConnectionReestablishmentReject);

         stat = asn1PD_RRCConnectionReestablishmentReject (pctxt, pvalue->u.rrcConnectionReestablishmentReject);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* rrcConnectionReject */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReject");

         pvalue->u.rrcConnectionReject = rtxMemAllocType (pctxt, 
            RRCConnectionReject);

         if (pvalue->u.rrcConnectionReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReject (pvalue->u.rrcConnectionReject);

         stat = asn1PD_RRCConnectionReject (pctxt, pvalue->u.rrcConnectionReject);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* rrcConnectionSetup */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionSetup");

         pvalue->u.rrcConnectionSetup = rtxMemAllocType (pctxt, 
            RRCConnectionSetup);

         if (pvalue->u.rrcConnectionSetup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionSetup (pvalue->u.rrcConnectionSetup);

         stat = asn1PD_RRCConnectionSetup (pctxt, pvalue->u.rrcConnectionSetup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_DL_CCCH_MessageType_c1 (DL_CCCH_MessageType_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_DL_CCCH_MessageType_messageClassExtension (OSCTXT* pctxt, DL_CCCH_MessageType_messageClassExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DL_CCCH_MessageType_messageClassExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DL_CCCH_MessageType_messageClassExtension (OSCTXT* pctxt, DL_CCCH_MessageType_messageClassExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_DL_CCCH_MessageType (OSCTXT* pctxt, DL_CCCH_MessageType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CCCH-MessageType");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DL_CCCH_MessageType"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_DL_CCCH_MessageType_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* messageClassExtension */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "messageClassExtension");

         stat = asn1PE_DL_CCCH_MessageType_messageClassExtension (pctxt, pvalue->u.messageClassExtension);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DL_CCCH_MessageType (OSCTXT* pctxt, DL_CCCH_MessageType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CCCH-MessageType");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, DL_CCCH_MessageType_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DL_CCCH_MessageType_c1 (pvalue->u.c1);

         stat = asn1PD_DL_CCCH_MessageType_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* messageClassExtension */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "messageClassExtension");

         pvalue->u.messageClassExtension = rtxMemAllocTypeZ (pctxt, 
            DL_CCCH_MessageType_messageClassExtension);

         if (pvalue->u.messageClassExtension == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_DL_CCCH_MessageType_messageClassExtension (pctxt, pvalue->u.messageClassExtension);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DL_CCCH_MessageType (DL_CCCH_MessageType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_DL_CCCH_Message (OSCTXT* pctxt, DL_CCCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CCCH-Message");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DL_CCCH_Message"));

   /* encode message */

   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PE_DL_CCCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DL_CCCH_Message (OSCTXT* pctxt, DL_CCCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-CCCH-Message");

   /* decode root elements */
   /* decode message */
   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PD_DL_CCCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DL_CCCH_Message (DL_CCCH_Message* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_DL_CCCH_MessageType (&pvalue->message);
}

EXTERN int asn1PE_CSFBParametersResponseCDMA2000_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, CSFBParametersResponseCDMA2000_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFBParametersResponseCDMA2000_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFBParametersResponseCDMA2000_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, CSFBParametersResponseCDMA2000_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_CSFBParametersResponseCDMA2000_v8a0_IEs (OSCTXT* pctxt, CSFBParametersResponseCDMA2000_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSFBParametersResponseCDMA2000-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFBParametersResponseCDMA2000_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_CSFBParametersResponseCDMA2000_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFBParametersResponseCDMA2000_v8a0_IEs (OSCTXT* pctxt, CSFBParametersResponseCDMA2000_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "CSFBParametersResponseCDMA2000-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_CSFBParametersResponseCDMA2000_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CSFBParametersResponseCDMA2000_v8a0_IEs (
   CSFBParametersResponseCDMA2000_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_CSFBParametersResponseCDMA2000_r8_IEs (OSCTXT* pctxt, CSFBParametersResponseCDMA2000_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSFBParametersResponseCDMA2000-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFBParametersResponseCDMA2000_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rand_ */

   RTXCTXTPUSHELEMNAME (pctxt, "rand");

   stat = asn1PE_RAND_CDMA2000 (pctxt, pvalue->rand_);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode mobilityParameters */

   RTXCTXTPUSHELEMNAME (pctxt, "mobilityParameters");

   stat = asn1PE_MobilityParametersCDMA2000 (pctxt, pvalue->mobilityParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_CSFBParametersResponseCDMA2000_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFBParametersResponseCDMA2000_r8_IEs (OSCTXT* pctxt, CSFBParametersResponseCDMA2000_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CSFBParametersResponseCDMA2000-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rand_ */
   RTXCTXTPUSHELEMNAME (pctxt, "rand");

   stat = asn1PD_RAND_CDMA2000 (pctxt, &pvalue->rand_);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mobilityParameters */
   RTXCTXTPUSHELEMNAME (pctxt, "mobilityParameters");

   stat = asn1PD_MobilityParametersCDMA2000 (pctxt, &pvalue->mobilityParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_CSFBParametersResponseCDMA2000_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CSFBParametersResponseCDMA2000_r8_IEs (
   CSFBParametersResponseCDMA2000_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RAND_CDMA2000 (&pvalue->rand_);
   asn1Init_MobilityParametersCDMA2000 (&pvalue->mobilityParameters);
   asn1Init_CSFBParametersResponseCDMA2000_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_CSFBParametersResponseCDMA2000_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, CSFBParametersResponseCDMA2000_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFBParametersResponseCDMA2000_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFBParametersResponseCDMA2000_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, CSFBParametersResponseCDMA2000_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_CSFBParametersResponseCDMA2000_criticalExtensions (OSCTXT* pctxt, CSFBParametersResponseCDMA2000_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFBParametersResponseCDMA2000_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* csfbParametersResponseCDMA2000_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "csfbParametersResponseCDMA2000-r8");

         stat = asn1PE_CSFBParametersResponseCDMA2000_r8_IEs (pctxt, pvalue->u.csfbParametersResponseCDMA2000_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_CSFBParametersResponseCDMA2000_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFBParametersResponseCDMA2000_criticalExtensions (OSCTXT* pctxt, CSFBParametersResponseCDMA2000_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* csfbParametersResponseCDMA2000_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "csfbParametersResponseCDMA2000-r8");

         pvalue->u.csfbParametersResponseCDMA2000_r8 = rtxMemAllocType (pctxt, 
            CSFBParametersResponseCDMA2000_r8_IEs);

         if (pvalue->u.csfbParametersResponseCDMA2000_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CSFBParametersResponseCDMA2000_r8_IEs (pvalue->u.csfbParametersResponseCDMA2000_r8);

         stat = asn1PD_CSFBParametersResponseCDMA2000_r8_IEs (pctxt, pvalue->u.csfbParametersResponseCDMA2000_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            CSFBParametersResponseCDMA2000_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_CSFBParametersResponseCDMA2000_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_CSFBParametersResponseCDMA2000_criticalExtensions (
   CSFBParametersResponseCDMA2000_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_CSFBParametersResponseCDMA2000 (OSCTXT* pctxt, CSFBParametersResponseCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSFBParametersResponseCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFBParametersResponseCDMA2000"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_CSFBParametersResponseCDMA2000_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFBParametersResponseCDMA2000 (OSCTXT* pctxt, CSFBParametersResponseCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSFBParametersResponseCDMA2000");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_CSFBParametersResponseCDMA2000_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CSFBParametersResponseCDMA2000 (
   CSFBParametersResponseCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_CSFBParametersResponseCDMA2000_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_DLInformationTransfer_r8_IEs_dedicatedInfoType (OSCTXT* pctxt, DLInformationTransfer_r8_IEs_dedicatedInfoType* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DLInformationTransfer_r8_IEs_dedicatedInfoType"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* dedicatedInfoNAS */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoNAS");

         stat = asn1PE_DedicatedInfoNAS (pctxt, *pvalue->u.dedicatedInfoNAS);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* dedicatedInfoCDMA2000_1XRTT */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoCDMA2000-1XRTT");

         stat = asn1PE_DedicatedInfoCDMA2000 (pctxt, *pvalue->u.dedicatedInfoCDMA2000_1XRTT);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* dedicatedInfoCDMA2000_HRPD */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoCDMA2000-HRPD");

         stat = asn1PE_DedicatedInfoCDMA2000 (pctxt, *pvalue->u.dedicatedInfoCDMA2000_HRPD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DLInformationTransfer_r8_IEs_dedicatedInfoType (OSCTXT* pctxt, DLInformationTransfer_r8_IEs_dedicatedInfoType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dedicatedInfoNAS */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoNAS");

         pvalue->u.dedicatedInfoNAS = rtxMemAllocType (pctxt, 
            DedicatedInfoNAS);

         if (pvalue->u.dedicatedInfoNAS == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DedicatedInfoNAS (pvalue->u.dedicatedInfoNAS);

         stat = asn1PD_DedicatedInfoNAS (pctxt, pvalue->u.dedicatedInfoNAS);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dedicatedInfoCDMA2000_1XRTT */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoCDMA2000-1XRTT");

         pvalue->u.dedicatedInfoCDMA2000_1XRTT = rtxMemAllocType (pctxt, 
            DedicatedInfoCDMA2000);

         if (pvalue->u.dedicatedInfoCDMA2000_1XRTT == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DedicatedInfoCDMA2000 (pvalue->u.dedicatedInfoCDMA2000_1XRTT);

         stat = asn1PD_DedicatedInfoCDMA2000 (pctxt, pvalue->u.dedicatedInfoCDMA2000_1XRTT);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dedicatedInfoCDMA2000_HRPD */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoCDMA2000-HRPD");

         pvalue->u.dedicatedInfoCDMA2000_HRPD = rtxMemAllocType (pctxt, 
            DedicatedInfoCDMA2000);

         if (pvalue->u.dedicatedInfoCDMA2000_HRPD == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DedicatedInfoCDMA2000 (pvalue->u.dedicatedInfoCDMA2000_HRPD);

         stat = asn1PD_DedicatedInfoCDMA2000 (pctxt, pvalue->u.dedicatedInfoCDMA2000_HRPD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_DLInformationTransfer_r8_IEs_dedicatedInfoType (
   DLInformationTransfer_r8_IEs_dedicatedInfoType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_DLInformationTransfer_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, DLInformationTransfer_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DLInformationTransfer_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DLInformationTransfer_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, DLInformationTransfer_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_DLInformationTransfer_v8a0_IEs (OSCTXT* pctxt, DLInformationTransfer_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DLInformationTransfer-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DLInformationTransfer_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_DLInformationTransfer_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DLInformationTransfer_v8a0_IEs (OSCTXT* pctxt, DLInformationTransfer_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "DLInformationTransfer-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_DLInformationTransfer_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DLInformationTransfer_v8a0_IEs (
   DLInformationTransfer_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_DLInformationTransfer_r8_IEs (OSCTXT* pctxt, DLInformationTransfer_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DLInformationTransfer-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DLInformationTransfer_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dedicatedInfoType */

   RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoType");

   stat = asn1PE_DLInformationTransfer_r8_IEs_dedicatedInfoType (pctxt, &pvalue->dedicatedInfoType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_DLInformationTransfer_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DLInformationTransfer_r8_IEs (OSCTXT* pctxt, DLInformationTransfer_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DLInformationTransfer-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dedicatedInfoType */
   RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoType");

   stat = asn1PD_DLInformationTransfer_r8_IEs_dedicatedInfoType (pctxt, &pvalue->dedicatedInfoType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_DLInformationTransfer_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DLInformationTransfer_r8_IEs (
   DLInformationTransfer_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_DLInformationTransfer_r8_IEs_dedicatedInfoType (&pvalue->dedicatedInfoType);
   asn1Init_DLInformationTransfer_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_DLInformationTransfer_criticalExtensions_c1 (OSCTXT* pctxt, DLInformationTransfer_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DLInformationTransfer_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* dlInformationTransfer_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dlInformationTransfer-r8");

         stat = asn1PE_DLInformationTransfer_r8_IEs (pctxt, pvalue->u.dlInformationTransfer_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DLInformationTransfer_criticalExtensions_c1 (OSCTXT* pctxt, DLInformationTransfer_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dlInformationTransfer_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dlInformationTransfer-r8");

         pvalue->u.dlInformationTransfer_r8 = rtxMemAllocType (pctxt, 
            DLInformationTransfer_r8_IEs);

         if (pvalue->u.dlInformationTransfer_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DLInformationTransfer_r8_IEs (pvalue->u.dlInformationTransfer_r8);

         stat = asn1PD_DLInformationTransfer_r8_IEs (pctxt, pvalue->u.dlInformationTransfer_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_DLInformationTransfer_criticalExtensions_c1 (
   DLInformationTransfer_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_DLInformationTransfer_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, DLInformationTransfer_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DLInformationTransfer_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DLInformationTransfer_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, DLInformationTransfer_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_DLInformationTransfer_criticalExtensions (OSCTXT* pctxt, DLInformationTransfer_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DLInformationTransfer_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_DLInformationTransfer_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_DLInformationTransfer_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DLInformationTransfer_criticalExtensions (OSCTXT* pctxt, DLInformationTransfer_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            DLInformationTransfer_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DLInformationTransfer_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_DLInformationTransfer_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            DLInformationTransfer_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_DLInformationTransfer_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_DLInformationTransfer_criticalExtensions (
   DLInformationTransfer_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_DLInformationTransfer (OSCTXT* pctxt, DLInformationTransfer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DLInformationTransfer");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DLInformationTransfer"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_DLInformationTransfer_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DLInformationTransfer (OSCTXT* pctxt, DLInformationTransfer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DLInformationTransfer");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_DLInformationTransfer_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DLInformationTransfer (DLInformationTransfer* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_DLInformationTransfer_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_HandoverFromEUTRAPreparationRequest_v920_IEs_nonCriticalExtension (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest_v920_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverFromEUTRAPreparationRequest_v920_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverFromEUTRAPreparationRequest_v920_IEs_nonCriticalExtension (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest_v920_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_HandoverFromEUTRAPreparationRequest_v920_IEs (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest_v920_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverFromEUTRAPreparationRequest-v920-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverFromEUTRAPreparationRequest_v920_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.concurrPrepCDMA2000_HRPD_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode concurrPrepCDMA2000_HRPD_r9 */

   if (pvalue->m.concurrPrepCDMA2000_HRPD_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "concurrPrepCDMA2000-HRPD-r9");

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->concurrPrepCDMA2000_HRPD_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_HandoverFromEUTRAPreparationRequest_v920_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverFromEUTRAPreparationRequest_v920_IEs (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest_v920_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverFromEUTRAPreparationRequest-v920-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode concurrPrepCDMA2000_HRPD_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "concurrPrepCDMA2000-HRPD-r9");

      pvalue->m.concurrPrepCDMA2000_HRPD_r9Present = 1;

      stat = DEC_BIT (pctxt, &pvalue->concurrPrepCDMA2000_HRPD_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_HandoverFromEUTRAPreparationRequest_v920_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_HandoverFromEUTRAPreparationRequest_v920_IEs (
   HandoverFromEUTRAPreparationRequest_v920_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_HandoverFromEUTRAPreparationRequest_v890_IEs (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest_v890_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverFromEUTRAPreparationRequest-v890-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverFromEUTRAPreparationRequest_v890_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_HandoverFromEUTRAPreparationRequest_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverFromEUTRAPreparationRequest_v890_IEs (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest_v890_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverFromEUTRAPreparationRequest-v890-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_HandoverFromEUTRAPreparationRequest_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_HandoverFromEUTRAPreparationRequest_v890_IEs (
   HandoverFromEUTRAPreparationRequest_v890_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   asn1Init_HandoverFromEUTRAPreparationRequest_v920_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_HandoverFromEUTRAPreparationRequest_r8_IEs (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverFromEUTRAPreparationRequest-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverFromEUTRAPreparationRequest_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rand_Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.mobilityParametersPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cdma2000_Type */

   RTXCTXTPUSHELEMNAME (pctxt, "cdma2000-Type");

   stat = asn1PE_CDMA2000_Type (pctxt, pvalue->cdma2000_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rand_ */

   if (pvalue->m.rand_Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "rand");

      stat = asn1PE_RAND_CDMA2000 (pctxt, pvalue->rand_);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode mobilityParameters */

   if (pvalue->m.mobilityParametersPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "mobilityParameters");

      stat = asn1PE_MobilityParametersCDMA2000 (pctxt, pvalue->mobilityParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_HandoverFromEUTRAPreparationRequest_v890_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverFromEUTRAPreparationRequest_r8_IEs (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverFromEUTRAPreparationRequest-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cdma2000_Type */
   RTXCTXTPUSHELEMNAME (pctxt, "cdma2000-Type");

   stat = asn1PD_CDMA2000_Type (pctxt, &pvalue->cdma2000_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rand_ */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rand");

      pvalue->m.rand_Present = 1;

      stat = asn1PD_RAND_CDMA2000 (pctxt, &pvalue->rand_);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mobilityParameters */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mobilityParameters");

      pvalue->m.mobilityParametersPresent = 1;

      stat = asn1PD_MobilityParametersCDMA2000 (pctxt, &pvalue->mobilityParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_HandoverFromEUTRAPreparationRequest_v890_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_HandoverFromEUTRAPreparationRequest_r8_IEs (
   HandoverFromEUTRAPreparationRequest_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RAND_CDMA2000 (&pvalue->rand_);
   asn1Init_MobilityParametersCDMA2000 (&pvalue->mobilityParameters);
   asn1Init_HandoverFromEUTRAPreparationRequest_v890_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_HandoverFromEUTRAPreparationRequest_criticalExtensions_c1 (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverFromEUTRAPreparationRequest_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* handoverFromEUTRAPreparationRequest_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "handoverFromEUTRAPreparationRequest-r8");

         stat = asn1PE_HandoverFromEUTRAPreparationRequest_r8_IEs (pctxt, pvalue->u.handoverFromEUTRAPreparationRequest_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverFromEUTRAPreparationRequest_criticalExtensions_c1 (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* handoverFromEUTRAPreparationRequest_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "handoverFromEUTRAPreparationRequest-r8");

         pvalue->u.handoverFromEUTRAPreparationRequest_r8
             = rtxMemAllocType (pctxt, 
            HandoverFromEUTRAPreparationRequest_r8_IEs);

         if (pvalue->u.handoverFromEUTRAPreparationRequest_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HandoverFromEUTRAPreparationRequest_r8_IEs (pvalue->u.handoverFromEUTRAPreparationRequest_r8);

         stat = asn1PD_HandoverFromEUTRAPreparationRequest_r8_IEs (pctxt, pvalue->u.handoverFromEUTRAPreparationRequest_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_HandoverFromEUTRAPreparationRequest_criticalExtensions_c1 (
   HandoverFromEUTRAPreparationRequest_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_HandoverFromEUTRAPreparationRequest_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverFromEUTRAPreparationRequest_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverFromEUTRAPreparationRequest_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_HandoverFromEUTRAPreparationRequest_criticalExtensions (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverFromEUTRAPreparationRequest_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_HandoverFromEUTRAPreparationRequest_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_HandoverFromEUTRAPreparationRequest_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverFromEUTRAPreparationRequest_criticalExtensions (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            HandoverFromEUTRAPreparationRequest_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HandoverFromEUTRAPreparationRequest_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_HandoverFromEUTRAPreparationRequest_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            HandoverFromEUTRAPreparationRequest_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_HandoverFromEUTRAPreparationRequest_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_HandoverFromEUTRAPreparationRequest_criticalExtensions (
   HandoverFromEUTRAPreparationRequest_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_HandoverFromEUTRAPreparationRequest (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverFromEUTRAPreparationRequest");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverFromEUTRAPreparationRequest"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_HandoverFromEUTRAPreparationRequest_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverFromEUTRAPreparationRequest (OSCTXT* pctxt, HandoverFromEUTRAPreparationRequest* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverFromEUTRAPreparationRequest");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_HandoverFromEUTRAPreparationRequest_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_HandoverFromEUTRAPreparationRequest (
   HandoverFromEUTRAPreparationRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_HandoverFromEUTRAPreparationRequest_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_SystemInfoListGERAN (OSCTXT* pctxt, SystemInfoListGERAN* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInfoListGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SystemInfoListGERAN"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(10), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OCTET_STRING", xx1);

      stat = asn1PE_SystemInfoListGERAN_element (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SystemInfoListGERAN (OSCTXT* pctxt, SystemInfoListGERAN* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SystemInfoListGERAN");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 10) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OCTET_STRING", xx1);

      asn1Init_SystemInfoListGERAN_element (&pvalue->elem[xx1]);

      stat = asn1PD_SystemInfoListGERAN_element (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SystemInfoListGERAN (SystemInfoListGERAN* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_SI_OrPSI_GERAN (OSCTXT* pctxt, SI_OrPSI_GERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SI-OrPSI-GERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SI_OrPSI_GERAN"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* si */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "si");

         stat = asn1PE_SystemInfoListGERAN (pctxt, pvalue->u.si);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* psi */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "psi");

         stat = asn1PE_SystemInfoListGERAN (pctxt, pvalue->u.psi);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SI_OrPSI_GERAN (OSCTXT* pctxt, SI_OrPSI_GERAN* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "SI-OrPSI-GERAN");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* si */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "si");

         pvalue->u.si = rtxMemAllocType (pctxt, SystemInfoListGERAN);

         if (pvalue->u.si == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SystemInfoListGERAN (pvalue->u.si);

         stat = asn1PD_SystemInfoListGERAN (pctxt, pvalue->u.si);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* psi */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "psi");

         pvalue->u.psi = rtxMemAllocType (pctxt, SystemInfoListGERAN);

         if (pvalue->u.psi == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SystemInfoListGERAN (pvalue->u.psi);

         stat = asn1PD_SystemInfoListGERAN (pctxt, pvalue->u.psi);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SI_OrPSI_GERAN (SI_OrPSI_GERAN* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_Handover (OSCTXT* pctxt, Handover* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Handover");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("Handover"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nas_SecurityParamFromEUTRAPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.systemInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode targetRAT_Type */

   RTXCTXTPUSHELEMNAME (pctxt, "targetRAT-Type");

   stat = asn1PE_Handover_targetRAT_Type (pctxt, pvalue->targetRAT_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode targetRAT_MessageContainer */

   RTXCTXTPUSHELEMNAME (pctxt, "targetRAT-MessageContainer");

   stat = pe_OctetString (pctxt, pvalue->targetRAT_MessageContainer.numocts, pvalue->targetRAT_MessageContainer.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nas_SecurityParamFromEUTRA */

   if (pvalue->m.nas_SecurityParamFromEUTRAPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nas-SecurityParamFromEUTRA");

      stat = asn1PE_Handover_nas_SecurityParamFromEUTRA (pctxt, &pvalue->nas_SecurityParamFromEUTRA);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode systemInformation */

   if (pvalue->m.systemInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "systemInformation");

      stat = asn1PE_SI_OrPSI_GERAN (pctxt, &pvalue->systemInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Handover (OSCTXT* pctxt, Handover* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "Handover");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode targetRAT_Type */
   RTXCTXTPUSHELEMNAME (pctxt, "targetRAT-Type");

   stat = asn1PD_Handover_targetRAT_Type (pctxt, &pvalue->targetRAT_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode targetRAT_MessageContainer */
   RTXCTXTPUSHELEMNAME (pctxt, "targetRAT-MessageContainer");

   stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->targetRAT_MessageContainer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nas_SecurityParamFromEUTRA */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nas-SecurityParamFromEUTRA");

      pvalue->m.nas_SecurityParamFromEUTRAPresent = 1;

      stat = asn1PD_Handover_nas_SecurityParamFromEUTRA (pctxt, &pvalue->nas_SecurityParamFromEUTRA);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode systemInformation */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "systemInformation");

      pvalue->m.systemInformationPresent = 1;

      stat = asn1PD_SI_OrPSI_GERAN (pctxt, &pvalue->systemInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_Handover (Handover* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->targetRAT_MessageContainer.numocts = 0;
   pvalue->targetRAT_MessageContainer.data = 0;
   asn1Init_Handover_nas_SecurityParamFromEUTRA (&pvalue->nas_SecurityParamFromEUTRA);
   asn1Init_SI_OrPSI_GERAN (&pvalue->systemInformation);
}

EXTERN int asn1PE_PhysCellIdGERAN (OSCTXT* pctxt, PhysCellIdGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhysCellIdGERAN"));

   /* encode networkColourCode */

   RTXCTXTPUSHELEMNAME (pctxt, "networkColourCode");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->networkColourCode, OSUINTCONST(3), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode baseStationColourCode */

   RTXCTXTPUSHELEMNAME (pctxt, "baseStationColourCode");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->baseStationColourCode, OSUINTCONST(3), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhysCellIdGERAN (OSCTXT* pctxt, PhysCellIdGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdGERAN");

   /* decode root elements */
   /* decode networkColourCode */
   RTXCTXTPUSHELEMNAME (pctxt, "networkColourCode");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->networkColourCode
      , OSUINTCONST(3), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode baseStationColourCode */
   RTXCTXTPUSHELEMNAME (pctxt, "baseStationColourCode");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->baseStationColourCode
      , OSUINTCONST(3), OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PhysCellIdGERAN (PhysCellIdGERAN* pvalue)
{
   if (0 == pvalue) return;
   pvalue->networkColourCode.numbits = 0;
   pvalue->baseStationColourCode.numbits = 0;
}

EXTERN int asn1PE_CarrierFreqGERAN (OSCTXT* pctxt, CarrierFreqGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqGERAN"));

   /* encode arfcn */

   RTXCTXTPUSHELEMNAME (pctxt, "arfcn");

   stat = asn1PE_ARFCN_ValueGERAN (pctxt, pvalue->arfcn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode bandIndicator */

   RTXCTXTPUSHELEMNAME (pctxt, "bandIndicator");

   stat = asn1PE_BandIndicatorGERAN (pctxt, pvalue->bandIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqGERAN (OSCTXT* pctxt, CarrierFreqGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqGERAN");

   /* decode root elements */
   /* decode arfcn */
   RTXCTXTPUSHELEMNAME (pctxt, "arfcn");

   stat = asn1PD_ARFCN_ValueGERAN (pctxt, &pvalue->arfcn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode bandIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "bandIndicator");

   stat = asn1PD_BandIndicatorGERAN (pctxt, &pvalue->bandIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_CellChangeOrder_targetRAT_Type_geran (OSCTXT* pctxt, CellChangeOrder_targetRAT_Type_geran* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellChangeOrder_targetRAT_Type_geran"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.networkControlOrderPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.systemInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode physCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PE_PhysCellIdGERAN (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode carrierFreq */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PE_CarrierFreqGERAN (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode networkControlOrder */

   if (pvalue->m.networkControlOrderPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "networkControlOrder");

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

      stat = pe_BitString32 (pctxt, &pvalue->networkControlOrder, OSUINTCONST(2), OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode systemInformation */

   if (pvalue->m.systemInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "systemInformation");

      stat = asn1PE_SI_OrPSI_GERAN (pctxt, &pvalue->systemInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellChangeOrder_targetRAT_Type_geran (OSCTXT* pctxt, CellChangeOrder_targetRAT_Type_geran* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode physCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PD_PhysCellIdGERAN (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode carrierFreq */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PD_CarrierFreqGERAN (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode networkControlOrder */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "networkControlOrder");

      pvalue->m.networkControlOrderPresent = 1;

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

      stat = pd_BitString32 (pctxt, &pvalue->networkControlOrder
         , OSUINTCONST(2), OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode systemInformation */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "systemInformation");

      pvalue->m.systemInformationPresent = 1;

      stat = asn1PD_SI_OrPSI_GERAN (pctxt, &pvalue->systemInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_CellChangeOrder_targetRAT_Type_geran (
   CellChangeOrder_targetRAT_Type_geran* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PhysCellIdGERAN (&pvalue->physCellId);
   pvalue->networkControlOrder.numbits = 0;
   asn1Init_SI_OrPSI_GERAN (&pvalue->systemInformation);
}

EXTERN int asn1PE_CellChangeOrder_targetRAT_Type (OSCTXT* pctxt, CellChangeOrder_targetRAT_Type* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellChangeOrder_targetRAT_Type"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 1);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* geran */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "geran");

            stat = asn1PE_CellChangeOrder_targetRAT_Type_geran (pctxt, pvalue->u.geran);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellChangeOrder_targetRAT_Type (OSCTXT* pctxt, CellChangeOrder_targetRAT_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* geran */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "geran");

            pvalue->u.geran = rtxMemAllocType (pctxt, 
               CellChangeOrder_targetRAT_Type_geran);

            if (pvalue->u.geran == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CellChangeOrder_targetRAT_Type_geran (pvalue->u.geran);

            stat = asn1PD_CellChangeOrder_targetRAT_Type_geran (pctxt, pvalue->u.geran);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

void asn1Init_CellChangeOrder_targetRAT_Type (
   CellChangeOrder_targetRAT_Type* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_CellChangeOrder (OSCTXT* pctxt, CellChangeOrder* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellChangeOrder");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellChangeOrder"));

   /* encode t304 */

   RTXCTXTPUSHELEMNAME (pctxt, "t304");

   stat = asn1PE_CellChangeOrder_t304 (pctxt, pvalue->t304);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode targetRAT_Type */

   RTXCTXTPUSHELEMNAME (pctxt, "targetRAT-Type");

   stat = asn1PE_CellChangeOrder_targetRAT_Type (pctxt, &pvalue->targetRAT_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellChangeOrder (OSCTXT* pctxt, CellChangeOrder* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellChangeOrder");

   /* decode root elements */
   /* decode t304 */
   RTXCTXTPUSHELEMNAME (pctxt, "t304");

   stat = asn1PD_CellChangeOrder_t304 (pctxt, &pvalue->t304);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode targetRAT_Type */
   RTXCTXTPUSHELEMNAME (pctxt, "targetRAT-Type");

   stat = asn1PD_CellChangeOrder_targetRAT_Type (pctxt, &pvalue->targetRAT_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellChangeOrder (CellChangeOrder* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_CellChangeOrder_targetRAT_Type (&pvalue->targetRAT_Type);
}

EXTERN int asn1PE_MobilityFromEUTRACommand_r8_IEs_purpose (OSCTXT* pctxt, MobilityFromEUTRACommand_r8_IEs_purpose* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityFromEUTRACommand_r8_IEs_purpose"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* handover */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "handover");

         stat = asn1PE_Handover (pctxt, pvalue->u.handover);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* cellChangeOrder */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "cellChangeOrder");

         stat = asn1PE_CellChangeOrder (pctxt, pvalue->u.cellChangeOrder);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityFromEUTRACommand_r8_IEs_purpose (OSCTXT* pctxt, MobilityFromEUTRACommand_r8_IEs_purpose* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* handover */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "handover");

         pvalue->u.handover = rtxMemAllocType (pctxt, Handover);

         if (pvalue->u.handover == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Handover (pvalue->u.handover);

         stat = asn1PD_Handover (pctxt, pvalue->u.handover);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* cellChangeOrder */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "cellChangeOrder");

         pvalue->u.cellChangeOrder = rtxMemAllocType (pctxt, CellChangeOrder);

         if (pvalue->u.cellChangeOrder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CellChangeOrder (pvalue->u.cellChangeOrder);

         stat = asn1PD_CellChangeOrder (pctxt, pvalue->u.cellChangeOrder);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_MobilityFromEUTRACommand_r8_IEs_purpose (
   MobilityFromEUTRACommand_r8_IEs_purpose* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MobilityFromEUTRACommand_v8d0_IEs_nonCriticalExtension (OSCTXT* pctxt, MobilityFromEUTRACommand_v8d0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityFromEUTRACommand_v8d0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityFromEUTRACommand_v8d0_IEs_nonCriticalExtension (OSCTXT* pctxt, MobilityFromEUTRACommand_v8d0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_MobilityFromEUTRACommand_v8d0_IEs (OSCTXT* pctxt, MobilityFromEUTRACommand_v8d0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityFromEUTRACommand-v8d0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityFromEUTRACommand_v8d0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.bandIndicatorPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bandIndicator */

   if (pvalue->m.bandIndicatorPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "bandIndicator");

      stat = asn1PE_BandIndicatorGERAN (pctxt, pvalue->bandIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_MobilityFromEUTRACommand_v8d0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityFromEUTRACommand_v8d0_IEs (OSCTXT* pctxt, MobilityFromEUTRACommand_v8d0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityFromEUTRACommand-v8d0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode bandIndicator */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "bandIndicator");

      pvalue->m.bandIndicatorPresent = 1;

      stat = asn1PD_BandIndicatorGERAN (pctxt, &pvalue->bandIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_MobilityFromEUTRACommand_v8d0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MobilityFromEUTRACommand_v8d0_IEs (
   MobilityFromEUTRACommand_v8d0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_MobilityFromEUTRACommand_v8a0_IEs (OSCTXT* pctxt, MobilityFromEUTRACommand_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityFromEUTRACommand-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityFromEUTRACommand_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_MobilityFromEUTRACommand_v8d0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityFromEUTRACommand_v8a0_IEs (OSCTXT* pctxt, MobilityFromEUTRACommand_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityFromEUTRACommand-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_MobilityFromEUTRACommand_v8d0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MobilityFromEUTRACommand_v8a0_IEs (
   MobilityFromEUTRACommand_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   asn1Init_MobilityFromEUTRACommand_v8d0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_MobilityFromEUTRACommand_r8_IEs (OSCTXT* pctxt, MobilityFromEUTRACommand_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityFromEUTRACommand-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityFromEUTRACommand_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cs_FallbackIndicator */

   RTXCTXTPUSHELEMNAME (pctxt, "cs-FallbackIndicator");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->cs_FallbackIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode purpose */

   RTXCTXTPUSHELEMNAME (pctxt, "purpose");

   stat = asn1PE_MobilityFromEUTRACommand_r8_IEs_purpose (pctxt, &pvalue->purpose);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_MobilityFromEUTRACommand_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityFromEUTRACommand_r8_IEs (OSCTXT* pctxt, MobilityFromEUTRACommand_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityFromEUTRACommand-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cs_FallbackIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "cs-FallbackIndicator");

   stat = DEC_BIT (pctxt, &pvalue->cs_FallbackIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode purpose */
   RTXCTXTPUSHELEMNAME (pctxt, "purpose");

   stat = asn1PD_MobilityFromEUTRACommand_r8_IEs_purpose (pctxt, &pvalue->purpose);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_MobilityFromEUTRACommand_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MobilityFromEUTRACommand_r8_IEs (
   MobilityFromEUTRACommand_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_MobilityFromEUTRACommand_r8_IEs_purpose (&pvalue->purpose);
   asn1Init_MobilityFromEUTRACommand_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_CarrierFreqCDMA2000 (OSCTXT* pctxt, CarrierFreqCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqCDMA2000"));

   /* encode bandClass */

   RTXCTXTPUSHELEMNAME (pctxt, "bandClass");

   stat = asn1PE_BandclassCDMA2000 (pctxt, pvalue->bandClass);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode arfcn */

   RTXCTXTPUSHELEMNAME (pctxt, "arfcn");

   stat = asn1PE_ARFCN_ValueCDMA2000 (pctxt, pvalue->arfcn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqCDMA2000 (OSCTXT* pctxt, CarrierFreqCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqCDMA2000");

   /* decode root elements */
   /* decode bandClass */
   RTXCTXTPUSHELEMNAME (pctxt, "bandClass");

   stat = asn1PD_BandclassCDMA2000 (pctxt, &pvalue->bandClass);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode arfcn */
   RTXCTXTPUSHELEMNAME (pctxt, "arfcn");

   stat = asn1PD_ARFCN_ValueCDMA2000 (pctxt, &pvalue->arfcn);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_E_CSFB_r9 (OSCTXT* pctxt, E_CSFB_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-CSFB-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("E_CSFB_r9"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.messageContCDMA2000_1XRTT_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.mobilityCDMA2000_HRPD_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.messageContCDMA2000_HRPD_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.redirectCarrierCDMA2000_HRPD_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode messageContCDMA2000_1XRTT_r9 */

   if (pvalue->m.messageContCDMA2000_1XRTT_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "messageContCDMA2000-1XRTT-r9");

      stat = pe_OctetString (pctxt, pvalue->messageContCDMA2000_1XRTT_r9.numocts, pvalue->messageContCDMA2000_1XRTT_r9.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode mobilityCDMA2000_HRPD_r9 */

   if (pvalue->m.mobilityCDMA2000_HRPD_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "mobilityCDMA2000-HRPD-r9");

      stat = asn1PE_E_CSFB_r9_mobilityCDMA2000_HRPD_r9 (pctxt, pvalue->mobilityCDMA2000_HRPD_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode messageContCDMA2000_HRPD_r9 */

   if (pvalue->m.messageContCDMA2000_HRPD_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "messageContCDMA2000-HRPD-r9");

      stat = pe_OctetString (pctxt, pvalue->messageContCDMA2000_HRPD_r9.numocts, pvalue->messageContCDMA2000_HRPD_r9.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode redirectCarrierCDMA2000_HRPD_r9 */

   if (pvalue->m.redirectCarrierCDMA2000_HRPD_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "redirectCarrierCDMA2000-HRPD-r9");

      stat = asn1PE_CarrierFreqCDMA2000 (pctxt, &pvalue->redirectCarrierCDMA2000_HRPD_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_E_CSFB_r9 (OSCTXT* pctxt, E_CSFB_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "E-CSFB-r9");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode messageContCDMA2000_1XRTT_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "messageContCDMA2000-1XRTT-r9");

      pvalue->m.messageContCDMA2000_1XRTT_r9Present = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->messageContCDMA2000_1XRTT_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mobilityCDMA2000_HRPD_r9 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mobilityCDMA2000-HRPD-r9");

      pvalue->m.mobilityCDMA2000_HRPD_r9Present = 1;

      stat = asn1PD_E_CSFB_r9_mobilityCDMA2000_HRPD_r9 (pctxt, &pvalue->mobilityCDMA2000_HRPD_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode messageContCDMA2000_HRPD_r9 */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "messageContCDMA2000-HRPD-r9");

      pvalue->m.messageContCDMA2000_HRPD_r9Present = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->messageContCDMA2000_HRPD_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode redirectCarrierCDMA2000_HRPD_r9 */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "redirectCarrierCDMA2000-HRPD-r9");

      pvalue->m.redirectCarrierCDMA2000_HRPD_r9Present = 1;

      stat = asn1PD_CarrierFreqCDMA2000 (pctxt, &pvalue->redirectCarrierCDMA2000_HRPD_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_E_CSFB_r9 (E_CSFB_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->messageContCDMA2000_1XRTT_r9.numocts = 0;
   pvalue->messageContCDMA2000_1XRTT_r9.data = 0;
   pvalue->messageContCDMA2000_HRPD_r9.numocts = 0;
   pvalue->messageContCDMA2000_HRPD_r9.data = 0;
}

EXTERN int asn1PE_MobilityFromEUTRACommand_r9_IEs_purpose (OSCTXT* pctxt, MobilityFromEUTRACommand_r9_IEs_purpose* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityFromEUTRACommand_r9_IEs_purpose"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 3);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* handover */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "handover");

            stat = asn1PE_Handover (pctxt, pvalue->u.handover);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* cellChangeOrder */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "cellChangeOrder");

            stat = asn1PE_CellChangeOrder (pctxt, pvalue->u.cellChangeOrder);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* e_CSFB_r9 */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "e-CSFB-r9");

            stat = asn1PE_E_CSFB_r9 (pctxt, pvalue->u.e_CSFB_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityFromEUTRACommand_r9_IEs_purpose (OSCTXT* pctxt, MobilityFromEUTRACommand_r9_IEs_purpose* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* handover */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "handover");

            pvalue->u.handover = rtxMemAllocType (pctxt, Handover);

            if (pvalue->u.handover == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Handover (pvalue->u.handover);

            stat = asn1PD_Handover (pctxt, pvalue->u.handover);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* cellChangeOrder */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "cellChangeOrder");

            pvalue->u.cellChangeOrder = rtxMemAllocType (pctxt, 
               CellChangeOrder);

            if (pvalue->u.cellChangeOrder == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CellChangeOrder (pvalue->u.cellChangeOrder);

            stat = asn1PD_CellChangeOrder (pctxt, pvalue->u.cellChangeOrder);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* e_CSFB_r9 */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "e-CSFB-r9");

            pvalue->u.e_CSFB_r9 = rtxMemAllocType (pctxt, E_CSFB_r9);

            if (pvalue->u.e_CSFB_r9 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_E_CSFB_r9 (pvalue->u.e_CSFB_r9);

            stat = asn1PD_E_CSFB_r9 (pctxt, pvalue->u.e_CSFB_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

void asn1Init_MobilityFromEUTRACommand_r9_IEs_purpose (
   MobilityFromEUTRACommand_r9_IEs_purpose* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MobilityFromEUTRACommand_v960_IEs_nonCriticalExtension (OSCTXT* pctxt, MobilityFromEUTRACommand_v960_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityFromEUTRACommand_v960_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityFromEUTRACommand_v960_IEs_nonCriticalExtension (OSCTXT* pctxt, MobilityFromEUTRACommand_v960_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_MobilityFromEUTRACommand_v960_IEs (OSCTXT* pctxt, MobilityFromEUTRACommand_v960_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityFromEUTRACommand-v960-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityFromEUTRACommand_v960_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.bandIndicatorPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bandIndicator */

   if (pvalue->m.bandIndicatorPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "bandIndicator");

      stat = asn1PE_BandIndicatorGERAN (pctxt, pvalue->bandIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_MobilityFromEUTRACommand_v960_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityFromEUTRACommand_v960_IEs (OSCTXT* pctxt, MobilityFromEUTRACommand_v960_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityFromEUTRACommand-v960-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode bandIndicator */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "bandIndicator");

      pvalue->m.bandIndicatorPresent = 1;

      stat = asn1PD_BandIndicatorGERAN (pctxt, &pvalue->bandIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_MobilityFromEUTRACommand_v960_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MobilityFromEUTRACommand_v960_IEs (
   MobilityFromEUTRACommand_v960_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_MobilityFromEUTRACommand_v930_IEs (OSCTXT* pctxt, MobilityFromEUTRACommand_v930_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityFromEUTRACommand-v930-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityFromEUTRACommand_v930_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_MobilityFromEUTRACommand_v960_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityFromEUTRACommand_v930_IEs (OSCTXT* pctxt, MobilityFromEUTRACommand_v930_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityFromEUTRACommand-v930-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_MobilityFromEUTRACommand_v960_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MobilityFromEUTRACommand_v930_IEs (
   MobilityFromEUTRACommand_v930_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   asn1Init_MobilityFromEUTRACommand_v960_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_MobilityFromEUTRACommand_r9_IEs (OSCTXT* pctxt, MobilityFromEUTRACommand_r9_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityFromEUTRACommand-r9-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityFromEUTRACommand_r9_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cs_FallbackIndicator */

   RTXCTXTPUSHELEMNAME (pctxt, "cs-FallbackIndicator");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->cs_FallbackIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode purpose */

   RTXCTXTPUSHELEMNAME (pctxt, "purpose");

   stat = asn1PE_MobilityFromEUTRACommand_r9_IEs_purpose (pctxt, &pvalue->purpose);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_MobilityFromEUTRACommand_v930_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityFromEUTRACommand_r9_IEs (OSCTXT* pctxt, MobilityFromEUTRACommand_r9_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityFromEUTRACommand-r9-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cs_FallbackIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "cs-FallbackIndicator");

   stat = DEC_BIT (pctxt, &pvalue->cs_FallbackIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode purpose */
   RTXCTXTPUSHELEMNAME (pctxt, "purpose");

   stat = asn1PD_MobilityFromEUTRACommand_r9_IEs_purpose (pctxt, &pvalue->purpose);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_MobilityFromEUTRACommand_v930_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MobilityFromEUTRACommand_r9_IEs (
   MobilityFromEUTRACommand_r9_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_MobilityFromEUTRACommand_r9_IEs_purpose (&pvalue->purpose);
   asn1Init_MobilityFromEUTRACommand_v930_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_MobilityFromEUTRACommand_criticalExtensions_c1 (OSCTXT* pctxt, MobilityFromEUTRACommand_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityFromEUTRACommand_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* mobilityFromEUTRACommand_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "mobilityFromEUTRACommand-r8");

         stat = asn1PE_MobilityFromEUTRACommand_r8_IEs (pctxt, pvalue->u.mobilityFromEUTRACommand_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* mobilityFromEUTRACommand_r9 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "mobilityFromEUTRACommand-r9");

         stat = asn1PE_MobilityFromEUTRACommand_r9_IEs (pctxt, pvalue->u.mobilityFromEUTRACommand_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityFromEUTRACommand_criticalExtensions_c1 (OSCTXT* pctxt, MobilityFromEUTRACommand_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* mobilityFromEUTRACommand_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "mobilityFromEUTRACommand-r8");

         pvalue->u.mobilityFromEUTRACommand_r8 = rtxMemAllocType (pctxt, 
            MobilityFromEUTRACommand_r8_IEs);

         if (pvalue->u.mobilityFromEUTRACommand_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MobilityFromEUTRACommand_r8_IEs (pvalue->u.mobilityFromEUTRACommand_r8);

         stat = asn1PD_MobilityFromEUTRACommand_r8_IEs (pctxt, pvalue->u.mobilityFromEUTRACommand_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* mobilityFromEUTRACommand_r9 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "mobilityFromEUTRACommand-r9");

         pvalue->u.mobilityFromEUTRACommand_r9 = rtxMemAllocType (pctxt, 
            MobilityFromEUTRACommand_r9_IEs);

         if (pvalue->u.mobilityFromEUTRACommand_r9 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MobilityFromEUTRACommand_r9_IEs (pvalue->u.mobilityFromEUTRACommand_r9);

         stat = asn1PD_MobilityFromEUTRACommand_r9_IEs (pctxt, pvalue->u.mobilityFromEUTRACommand_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_MobilityFromEUTRACommand_criticalExtensions_c1 (
   MobilityFromEUTRACommand_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MobilityFromEUTRACommand_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, MobilityFromEUTRACommand_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityFromEUTRACommand_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityFromEUTRACommand_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, MobilityFromEUTRACommand_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_MobilityFromEUTRACommand_criticalExtensions (OSCTXT* pctxt, MobilityFromEUTRACommand_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityFromEUTRACommand_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_MobilityFromEUTRACommand_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_MobilityFromEUTRACommand_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityFromEUTRACommand_criticalExtensions (OSCTXT* pctxt, MobilityFromEUTRACommand_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            MobilityFromEUTRACommand_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MobilityFromEUTRACommand_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_MobilityFromEUTRACommand_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            MobilityFromEUTRACommand_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_MobilityFromEUTRACommand_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_MobilityFromEUTRACommand_criticalExtensions (
   MobilityFromEUTRACommand_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MobilityFromEUTRACommand (OSCTXT* pctxt, MobilityFromEUTRACommand* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityFromEUTRACommand");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityFromEUTRACommand"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_MobilityFromEUTRACommand_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityFromEUTRACommand (OSCTXT* pctxt, MobilityFromEUTRACommand* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityFromEUTRACommand");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_MobilityFromEUTRACommand_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MobilityFromEUTRACommand (MobilityFromEUTRACommand* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_MobilityFromEUTRACommand_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_MeasObjectToRemoveList (OSCTXT* pctxt, MeasObjectToRemoveList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectToRemoveList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasObjectToRemoveList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasObjectId", xx1);

      stat = asn1PE_MeasObjectId (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasObjectToRemoveList (OSCTXT* pctxt, MeasObjectToRemoveList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectToRemoveList");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 5);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 32) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasObjectId", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (MeasObjectId));
      stat = asn1PD_MeasObjectId (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasObjectToRemoveList (MeasObjectToRemoveList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_CellIndexList (OSCTXT* pctxt, CellIndexList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CellIndexList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellIndexList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellIndex", xx1);

      stat = asn1PE_CellIndex (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellIndexList (OSCTXT* pctxt, CellIndexList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellIndexList");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 5);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 32) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellIndex", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (CellIndex));
      stat = asn1PD_CellIndex (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellIndexList (CellIndexList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_CellsToAddMod (OSCTXT* pctxt, CellsToAddMod* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddMod");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellsToAddMod"));

   /* encode cellIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "cellIndex");

   if ( (pvalue->cellIndex >= OSUINTCONST(1) && pvalue->cellIndex <= OSUINTCONST(32)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->cellIndex, OSUINTCONST(1), OSUINTCONST(32));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->cellIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode physCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PE_PhysCellId (pctxt, pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellIndividualOffset */

   RTXCTXTPUSHELEMNAME (pctxt, "cellIndividualOffset");

   stat = asn1PE_Q_OffsetRange (pctxt, pvalue->cellIndividualOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellsToAddMod (OSCTXT* pctxt, CellsToAddMod* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddMod");

   /* decode root elements */
   /* decode cellIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "cellIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->cellIndex, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode physCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PD_PhysCellId (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellIndividualOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "cellIndividualOffset");

   stat = asn1PD_Q_OffsetRange (pctxt, &pvalue->cellIndividualOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_CellsToAddModList (OSCTXT* pctxt, CellsToAddModList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddModList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellsToAddModList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellsToAddMod", xx1);

      stat = asn1PE_CellsToAddMod (pctxt, ((CellsToAddMod*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellsToAddModList (OSCTXT* pctxt, CellsToAddModList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddModList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellsToAddMod* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellsToAddMod", xx1);

      rtxDListAllocNodeAndData (pctxt, CellsToAddMod, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_CellsToAddMod (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellsToAddModList (CellsToAddModList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_BlackCellsToAddMod (OSCTXT* pctxt, BlackCellsToAddMod* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BlackCellsToAddMod");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BlackCellsToAddMod"));

   /* encode cellIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "cellIndex");

   if ( (pvalue->cellIndex >= OSUINTCONST(1) && pvalue->cellIndex <= OSUINTCONST(32)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->cellIndex, OSUINTCONST(1), OSUINTCONST(32));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->cellIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode physCellIdRange */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellIdRange");

   stat = asn1PE_PhysCellIdRange (pctxt, &pvalue->physCellIdRange);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BlackCellsToAddMod (OSCTXT* pctxt, BlackCellsToAddMod* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BlackCellsToAddMod");

   /* decode root elements */
   /* decode cellIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "cellIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->cellIndex, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode physCellIdRange */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellIdRange");

   stat = asn1PD_PhysCellIdRange (pctxt, &pvalue->physCellIdRange);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_BlackCellsToAddMod (BlackCellsToAddMod* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_PhysCellIdRange (&pvalue->physCellIdRange);
}

EXTERN int asn1PE_BlackCellsToAddModList (OSCTXT* pctxt, BlackCellsToAddModList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "BlackCellsToAddModList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BlackCellsToAddModList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BlackCellsToAddMod", xx1);

      stat = asn1PE_BlackCellsToAddMod (pctxt, ((BlackCellsToAddMod*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BlackCellsToAddModList (OSCTXT* pctxt, BlackCellsToAddModList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BlackCellsToAddModList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      BlackCellsToAddMod* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BlackCellsToAddMod", xx1);

      rtxDListAllocNodeAndData (pctxt, BlackCellsToAddMod, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BlackCellsToAddMod (pdata);

      stat = asn1PD_BlackCellsToAddMod (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_BlackCellsToAddModList (BlackCellsToAddModList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_MeasObjectEUTRA (OSCTXT* pctxt, MeasObjectEUTRA* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasObjectEUTRA"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)(pvalue->offsetFreq != dB0_6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellsToRemoveListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellsToAddModListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.blackCellsToRemoveListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.blackCellsToAddModListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellForWhichToReportCGIPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode carrierFreq */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PE_ARFCN_ValueEUTRA (pctxt, pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode allowedMeasBandwidth */

   RTXCTXTPUSHELEMNAME (pctxt, "allowedMeasBandwidth");

   stat = asn1PE_AllowedMeasBandwidth (pctxt, pvalue->allowedMeasBandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode presenceAntennaPort1 */

   RTXCTXTPUSHELEMNAME (pctxt, "presenceAntennaPort1");

   stat = asn1PE_PresenceAntennaPort1 (pctxt, pvalue->presenceAntennaPort1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode neighCellConfig */

   RTXCTXTPUSHELEMNAME (pctxt, "neighCellConfig");

   stat = asn1PE_NeighCellConfig (pctxt, pvalue->neighCellConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode offsetFreq */

   if (pvalue->offsetFreq != dB0_6) {
      RTXCTXTPUSHELEMNAME (pctxt, "offsetFreq");

      stat = asn1PE_Q_OffsetRange (pctxt, pvalue->offsetFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cellsToRemoveList */

   if (pvalue->m.cellsToRemoveListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellsToRemoveList");

      stat = asn1PE_CellIndexList (pctxt, &pvalue->cellsToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cellsToAddModList */

   if (pvalue->m.cellsToAddModListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellsToAddModList");

      stat = asn1PE_CellsToAddModList (pctxt, &pvalue->cellsToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode blackCellsToRemoveList */

   if (pvalue->m.blackCellsToRemoveListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "blackCellsToRemoveList");

      stat = asn1PE_CellIndexList (pctxt, &pvalue->blackCellsToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode blackCellsToAddModList */

   if (pvalue->m.blackCellsToAddModListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "blackCellsToAddModList");

      stat = asn1PE_BlackCellsToAddModList (pctxt, &pvalue->blackCellsToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cellForWhichToReportCGI */

   if (pvalue->m.cellForWhichToReportCGIPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellForWhichToReportCGI");

      stat = asn1PE_PhysCellId (pctxt, pvalue->cellForWhichToReportCGI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasObjectEUTRA (OSCTXT* pctxt, MeasObjectEUTRA* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[6];

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectEUTRA");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode carrierFreq */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PD_ARFCN_ValueEUTRA (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode allowedMeasBandwidth */
   RTXCTXTPUSHELEMNAME (pctxt, "allowedMeasBandwidth");

   stat = asn1PD_AllowedMeasBandwidth (pctxt, &pvalue->allowedMeasBandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode presenceAntennaPort1 */
   RTXCTXTPUSHELEMNAME (pctxt, "presenceAntennaPort1");

   stat = asn1PD_PresenceAntennaPort1 (pctxt, &pvalue->presenceAntennaPort1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode neighCellConfig */
   RTXCTXTPUSHELEMNAME (pctxt, "neighCellConfig");

   stat = asn1PD_NeighCellConfig (pctxt, &pvalue->neighCellConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode offsetFreq */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "offsetFreq");

      stat = asn1PD_Q_OffsetRange (pctxt, &pvalue->offsetFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->offsetFreq = dB0_6;
   }

   /* decode cellsToRemoveList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellsToRemoveList");

      pvalue->m.cellsToRemoveListPresent = 1;

      stat = asn1PD_CellIndexList (pctxt, &pvalue->cellsToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cellsToAddModList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellsToAddModList");

      pvalue->m.cellsToAddModListPresent = 1;

      stat = asn1PD_CellsToAddModList (pctxt, &pvalue->cellsToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode blackCellsToRemoveList */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "blackCellsToRemoveList");

      pvalue->m.blackCellsToRemoveListPresent = 1;

      stat = asn1PD_CellIndexList (pctxt, &pvalue->blackCellsToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode blackCellsToAddModList */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "blackCellsToAddModList");

      pvalue->m.blackCellsToAddModListPresent = 1;

      stat = asn1PD_BlackCellsToAddModList (pctxt, &pvalue->blackCellsToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cellForWhichToReportCGI */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellForWhichToReportCGI");

      pvalue->m.cellForWhichToReportCGIPresent = 1;

      stat = asn1PD_PhysCellId (pctxt, &pvalue->cellForWhichToReportCGI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasObjectEUTRA (MeasObjectEUTRA* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_NeighCellConfig (&pvalue->neighCellConfig);
   pvalue->offsetFreq = dB0_6;
   asn1Init_CellIndexList (&pvalue->cellsToRemoveList);
   asn1Init_CellsToAddModList (&pvalue->cellsToAddModList);
   asn1Init_CellIndexList (&pvalue->blackCellsToRemoveList);
   asn1Init_BlackCellsToAddModList (&pvalue->blackCellsToAddModList);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_CellsToAddModUTRA_FDD (OSCTXT* pctxt, CellsToAddModUTRA_FDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddModUTRA-FDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellsToAddModUTRA_FDD"));

   /* encode cellIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "cellIndex");

   if ( (pvalue->cellIndex >= OSUINTCONST(1) && pvalue->cellIndex <= OSUINTCONST(32)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->cellIndex, OSUINTCONST(1), OSUINTCONST(32));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->cellIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode physCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PE_PhysCellIdUTRA_FDD (pctxt, pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellsToAddModUTRA_FDD (OSCTXT* pctxt, CellsToAddModUTRA_FDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddModUTRA-FDD");

   /* decode root elements */
   /* decode cellIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "cellIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->cellIndex, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode physCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PD_PhysCellIdUTRA_FDD (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_CellsToAddModListUTRA_FDD (OSCTXT* pctxt, CellsToAddModListUTRA_FDD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddModListUTRA-FDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellsToAddModListUTRA_FDD"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellsToAddModUTRA-FDD", xx1);

      stat = asn1PE_CellsToAddModUTRA_FDD (pctxt, ((CellsToAddModUTRA_FDD*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellsToAddModListUTRA_FDD (OSCTXT* pctxt, CellsToAddModListUTRA_FDD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddModListUTRA-FDD");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellsToAddModUTRA_FDD* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellsToAddModUTRA-FDD", xx1);

      rtxDListAllocNodeAndData (pctxt, CellsToAddModUTRA_FDD, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_CellsToAddModUTRA_FDD (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellsToAddModListUTRA_FDD (CellsToAddModListUTRA_FDD* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_CellsToAddModUTRA_TDD (OSCTXT* pctxt, CellsToAddModUTRA_TDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddModUTRA-TDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellsToAddModUTRA_TDD"));

   /* encode cellIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "cellIndex");

   if ( (pvalue->cellIndex >= OSUINTCONST(1) && pvalue->cellIndex <= OSUINTCONST(32)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->cellIndex, OSUINTCONST(1), OSUINTCONST(32));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->cellIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode physCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PE_PhysCellIdUTRA_TDD (pctxt, pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellsToAddModUTRA_TDD (OSCTXT* pctxt, CellsToAddModUTRA_TDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddModUTRA-TDD");

   /* decode root elements */
   /* decode cellIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "cellIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->cellIndex, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode physCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PD_PhysCellIdUTRA_TDD (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_CellsToAddModListUTRA_TDD (OSCTXT* pctxt, CellsToAddModListUTRA_TDD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddModListUTRA-TDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellsToAddModListUTRA_TDD"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellsToAddModUTRA-TDD", xx1);

      stat = asn1PE_CellsToAddModUTRA_TDD (pctxt, ((CellsToAddModUTRA_TDD*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellsToAddModListUTRA_TDD (OSCTXT* pctxt, CellsToAddModListUTRA_TDD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddModListUTRA-TDD");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellsToAddModUTRA_TDD* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellsToAddModUTRA-TDD", xx1);

      rtxDListAllocNodeAndData (pctxt, CellsToAddModUTRA_TDD, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_CellsToAddModUTRA_TDD (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellsToAddModListUTRA_TDD (CellsToAddModListUTRA_TDD* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_MeasObjectUTRA_cellsToAddModList (OSCTXT* pctxt, MeasObjectUTRA_cellsToAddModList* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasObjectUTRA_cellsToAddModList"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* cellsToAddModListUTRA_FDD */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "cellsToAddModListUTRA-FDD");

         stat = asn1PE_CellsToAddModListUTRA_FDD (pctxt, pvalue->u.cellsToAddModListUTRA_FDD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* cellsToAddModListUTRA_TDD */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "cellsToAddModListUTRA-TDD");

         stat = asn1PE_CellsToAddModListUTRA_TDD (pctxt, pvalue->u.cellsToAddModListUTRA_TDD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasObjectUTRA_cellsToAddModList (OSCTXT* pctxt, MeasObjectUTRA_cellsToAddModList* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* cellsToAddModListUTRA_FDD */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "cellsToAddModListUTRA-FDD");

         pvalue->u.cellsToAddModListUTRA_FDD = rtxMemAllocType (pctxt, 
            CellsToAddModListUTRA_FDD);

         if (pvalue->u.cellsToAddModListUTRA_FDD == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CellsToAddModListUTRA_FDD (pvalue->u.cellsToAddModListUTRA_FDD);

         stat = asn1PD_CellsToAddModListUTRA_FDD (pctxt, pvalue->u.cellsToAddModListUTRA_FDD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* cellsToAddModListUTRA_TDD */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "cellsToAddModListUTRA-TDD");

         pvalue->u.cellsToAddModListUTRA_TDD = rtxMemAllocType (pctxt, 
            CellsToAddModListUTRA_TDD);

         if (pvalue->u.cellsToAddModListUTRA_TDD == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CellsToAddModListUTRA_TDD (pvalue->u.cellsToAddModListUTRA_TDD);

         stat = asn1PD_CellsToAddModListUTRA_TDD (pctxt, pvalue->u.cellsToAddModListUTRA_TDD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_MeasObjectUTRA_cellsToAddModList (
   MeasObjectUTRA_cellsToAddModList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MeasObjectUTRA_cellForWhichToReportCGI (OSCTXT* pctxt, MeasObjectUTRA_cellForWhichToReportCGI* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasObjectUTRA_cellForWhichToReportCGI"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* utra_FDD */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "utra-FDD");

         stat = asn1PE_PhysCellIdUTRA_FDD (pctxt, pvalue->u.utra_FDD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* utra_TDD */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "utra-TDD");

         stat = asn1PE_PhysCellIdUTRA_TDD (pctxt, pvalue->u.utra_TDD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasObjectUTRA_cellForWhichToReportCGI (OSCTXT* pctxt, MeasObjectUTRA_cellForWhichToReportCGI* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* utra_FDD */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "utra-FDD");

         stat = asn1PD_PhysCellIdUTRA_FDD (pctxt, &pvalue->u.utra_FDD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* utra_TDD */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "utra-TDD");

         stat = asn1PD_PhysCellIdUTRA_TDD (pctxt, &pvalue->u.utra_TDD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_MeasObjectUTRA_cellForWhichToReportCGI (
   MeasObjectUTRA_cellForWhichToReportCGI* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_PhysCellIdRangeUTRA_FDD_r9 (OSCTXT* pctxt, PhysCellIdRangeUTRA_FDD_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdRangeUTRA-FDD-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhysCellIdRangeUTRA_FDD_r9"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.range_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode start_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "start-r9");

   stat = asn1PE_PhysCellIdUTRA_FDD (pctxt, pvalue->start_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode range_r9 */

   if (pvalue->m.range_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "range-r9");

      if ( (pvalue->range_r9 >= OSUINTCONST(2) && pvalue->range_r9
          <= OSUINTCONST(512)) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->range_r9, OSUINTCONST(2), OSUINTCONST(512));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->range_r9);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhysCellIdRangeUTRA_FDD_r9 (OSCTXT* pctxt, PhysCellIdRangeUTRA_FDD_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdRangeUTRA-FDD-r9");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode start_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "start-r9");

   stat = asn1PD_PhysCellIdUTRA_FDD (pctxt, &pvalue->start_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode range_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "range-r9");

      pvalue->m.range_r9Present = 1;

      stat = pd_ConsUInt16 (pctxt, &pvalue->range_r9, OSUINTCONST(2), OSUINTCONST(512));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PhysCellIdRangeUTRA_FDD_r9 (PhysCellIdRangeUTRA_FDD_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_PhysCellIdRangeUTRA_FDDList_r9 (OSCTXT* pctxt, PhysCellIdRangeUTRA_FDDList_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdRangeUTRA-FDDList-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhysCellIdRangeUTRA_FDDList_r9"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PhysCellIdRangeUTRA-FDD-r9", xx1);

      stat = asn1PE_PhysCellIdRangeUTRA_FDD_r9 (pctxt, ((PhysCellIdRangeUTRA_FDD_r9*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhysCellIdRangeUTRA_FDDList_r9 (OSCTXT* pctxt, PhysCellIdRangeUTRA_FDDList_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysCellIdRangeUTRA-FDDList-r9");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PhysCellIdRangeUTRA_FDD_r9* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PhysCellIdRangeUTRA-FDD-r9", xx1);

      rtxDListAllocNodeAndData (pctxt, PhysCellIdRangeUTRA_FDD_r9, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PhysCellIdRangeUTRA_FDD_r9 (pdata);

      stat = asn1PD_PhysCellIdRangeUTRA_FDD_r9 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PhysCellIdRangeUTRA_FDDList_r9 (
   PhysCellIdRangeUTRA_FDDList_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_CSG_AllowedReportingCells_r9 (OSCTXT* pctxt, CSG_AllowedReportingCells_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSG-AllowedReportingCells-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSG_AllowedReportingCells_r9"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.physCellIdRangeUTRA_FDDList_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode physCellIdRangeUTRA_FDDList_r9 */

   if (pvalue->m.physCellIdRangeUTRA_FDDList_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "physCellIdRangeUTRA-FDDList-r9");

      stat = asn1PE_PhysCellIdRangeUTRA_FDDList_r9 (pctxt, &pvalue->physCellIdRangeUTRA_FDDList_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSG_AllowedReportingCells_r9 (OSCTXT* pctxt, CSG_AllowedReportingCells_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CSG-AllowedReportingCells-r9");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode physCellIdRangeUTRA_FDDList_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "physCellIdRangeUTRA-FDDList-r9");

      pvalue->m.physCellIdRangeUTRA_FDDList_r9Present = 1;

      stat = asn1PD_PhysCellIdRangeUTRA_FDDList_r9 (pctxt, &pvalue->physCellIdRangeUTRA_FDDList_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CSG_AllowedReportingCells_r9 (
   CSG_AllowedReportingCells_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PhysCellIdRangeUTRA_FDDList_r9 (&pvalue->physCellIdRangeUTRA_FDDList_r9);
}

EXTERN int asn1PE_MeasObjectUTRA (OSCTXT* pctxt, MeasObjectUTRA* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasObjectUTRA"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m._v2ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)(pvalue->offsetFreq != 0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellsToRemoveListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellsToAddModListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellForWhichToReportCGIPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode carrierFreq */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PE_ARFCN_ValueUTRA (pctxt, pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode offsetFreq */

   if (pvalue->offsetFreq != 0) {
      RTXCTXTPUSHELEMNAME (pctxt, "offsetFreq");

      stat = asn1PE_Q_OffsetRangeInterRAT (pctxt, pvalue->offsetFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cellsToRemoveList */

   if (pvalue->m.cellsToRemoveListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellsToRemoveList");

      stat = asn1PE_CellIndexList (pctxt, &pvalue->cellsToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cellsToAddModList */

   if (pvalue->m.cellsToAddModListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellsToAddModList");

      stat = asn1PE_MeasObjectUTRA_cellsToAddModList (pctxt, &pvalue->cellsToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cellForWhichToReportCGI */

   if (pvalue->m.cellForWhichToReportCGIPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellForWhichToReportCGI");

      stat = asn1PE_MeasObjectUTRA_cellForWhichToReportCGI (pctxt, &pvalue->cellForWhichToReportCGI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v2ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m._v2ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.csg_allowedReportingCells_v930Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode csg_allowedReportingCells_v930 */

         if (pvalue->m.csg_allowedReportingCells_v930Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "csg-allowedReportingCells-v930");

            stat = asn1PE_CSG_AllowedReportingCells_r9 (pctxt, &pvalue->csg_allowedReportingCells_v930);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasObjectUTRA (OSCTXT* pctxt, MeasObjectUTRA* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectUTRA");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode carrierFreq */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PD_ARFCN_ValueUTRA (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode offsetFreq */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "offsetFreq");

      stat = asn1PD_Q_OffsetRangeInterRAT (pctxt, &pvalue->offsetFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->offsetFreq = 0;
   }

   /* decode cellsToRemoveList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellsToRemoveList");

      pvalue->m.cellsToRemoveListPresent = 1;

      stat = asn1PD_CellIndexList (pctxt, &pvalue->cellsToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cellsToAddModList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellsToAddModList");

      pvalue->m.cellsToAddModListPresent = 1;

      stat = asn1PD_MeasObjectUTRA_cellsToAddModList (pctxt, &pvalue->cellsToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cellForWhichToReportCGI */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellForWhichToReportCGI");

      pvalue->m.cellForWhichToReportCGIPresent = 1;

      stat = asn1PD_MeasObjectUTRA_cellForWhichToReportCGI (pctxt, &pvalue->cellForWhichToReportCGI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m._v2ExtPresent = 1;
                        {
                           OSOCTET extoptbits[1];

                           stat = DEC_BIT (pctxt, &extoptbits[0]);
                           if (stat != 0)  {
                              rtxMemFreePtr (pctxt, poptbits);
                           }
                           if (extoptbits[0]) {
                              pvalue->m.csg_allowedReportingCells_v930Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "csg-allowedReportingCells-v930");

                              stat = asn1PD_CSG_AllowedReportingCells_r9 (pctxt, &pvalue->csg_allowedReportingCells_v930);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;

                        /* Coverity 55362 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasObjectUTRA (MeasObjectUTRA* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->offsetFreq = 0;
   asn1Init_CellIndexList (&pvalue->cellsToRemoveList);
   asn1Init_MeasObjectUTRA_cellsToAddModList (&pvalue->cellsToAddModList);
   asn1Init_MeasObjectUTRA_cellForWhichToReportCGI (&pvalue->cellForWhichToReportCGI);
   asn1Init_CSG_AllowedReportingCells_r9 (&pvalue->csg_allowedReportingCells_v930);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_MeasObjectGERAN (OSCTXT* pctxt, MeasObjectGERAN* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasObjectGERAN"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)(pvalue->offsetFreq != 0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ncc_PermittedPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellForWhichToReportCGIPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode carrierFreqs */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreqs");

   stat = asn1PE_CarrierFreqsGERAN (pctxt, &pvalue->carrierFreqs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode offsetFreq */

   if (pvalue->offsetFreq != 0) {
      RTXCTXTPUSHELEMNAME (pctxt, "offsetFreq");

      stat = asn1PE_Q_OffsetRangeInterRAT (pctxt, pvalue->offsetFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode ncc_Permitted */

   if (pvalue->m.ncc_PermittedPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ncc-Permitted");

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

      stat = pe_BitString32 (pctxt, &pvalue->ncc_Permitted, OSUINTCONST(8), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cellForWhichToReportCGI */

   if (pvalue->m.cellForWhichToReportCGIPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellForWhichToReportCGI");

      stat = asn1PE_PhysCellIdGERAN (pctxt, &pvalue->cellForWhichToReportCGI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasObjectGERAN (OSCTXT* pctxt, MeasObjectGERAN* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectGERAN");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode carrierFreqs */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreqs");

   stat = asn1PD_CarrierFreqsGERAN (pctxt, &pvalue->carrierFreqs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode offsetFreq */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "offsetFreq");

      stat = asn1PD_Q_OffsetRangeInterRAT (pctxt, &pvalue->offsetFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->offsetFreq = 0;
   }

   /* decode ncc_Permitted */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ncc-Permitted");

      pvalue->m.ncc_PermittedPresent = 1;

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

      stat = pd_BitString32 (pctxt, &pvalue->ncc_Permitted
         , OSUINTCONST(8), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->ncc_Permitted.data[0] = 0xFF;
      pvalue->ncc_Permitted.numbits = 8;
   }

   /* decode cellForWhichToReportCGI */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellForWhichToReportCGI");

      pvalue->m.cellForWhichToReportCGIPresent = 1;

      stat = asn1PD_PhysCellIdGERAN (pctxt, &pvalue->cellForWhichToReportCGI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasObjectGERAN (MeasObjectGERAN* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CarrierFreqsGERAN (&pvalue->carrierFreqs);
   pvalue->offsetFreq = 0;
   pvalue->ncc_Permitted.data[0] = 0xFF;
   pvalue->ncc_Permitted.numbits = 8;
   asn1Init_PhysCellIdGERAN (&pvalue->cellForWhichToReportCGI);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_CellsToAddModCDMA2000 (OSCTXT* pctxt, CellsToAddModCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddModCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellsToAddModCDMA2000"));

   /* encode cellIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "cellIndex");

   if ( (pvalue->cellIndex >= OSUINTCONST(1) && pvalue->cellIndex <= OSUINTCONST(32)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->cellIndex, OSUINTCONST(1), OSUINTCONST(32));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->cellIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode physCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PE_PhysCellIdCDMA2000 (pctxt, pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellsToAddModCDMA2000 (OSCTXT* pctxt, CellsToAddModCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddModCDMA2000");

   /* decode root elements */
   /* decode cellIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "cellIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->cellIndex, OSUINTCONST(1), OSUINTCONST(32));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode physCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PD_PhysCellIdCDMA2000 (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_CellsToAddModListCDMA2000 (OSCTXT* pctxt, CellsToAddModListCDMA2000* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddModListCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellsToAddModListCDMA2000"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellsToAddModCDMA2000", xx1);

      stat = asn1PE_CellsToAddModCDMA2000 (pctxt, ((CellsToAddModCDMA2000*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellsToAddModListCDMA2000 (OSCTXT* pctxt, CellsToAddModListCDMA2000* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsToAddModListCDMA2000");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellsToAddModCDMA2000* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellsToAddModCDMA2000", xx1);

      rtxDListAllocNodeAndData (pctxt, CellsToAddModCDMA2000, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_CellsToAddModCDMA2000 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellsToAddModListCDMA2000 (CellsToAddModListCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_MeasObjectCDMA2000 (OSCTXT* pctxt, MeasObjectCDMA2000* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasObjectCDMA2000"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.searchWindowSizePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)(pvalue->offsetFreq != 0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellsToRemoveListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellsToAddModListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellForWhichToReportCGIPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cdma2000_Type */

   RTXCTXTPUSHELEMNAME (pctxt, "cdma2000-Type");

   stat = asn1PE_CDMA2000_Type (pctxt, pvalue->cdma2000_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode carrierFreq */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PE_CarrierFreqCDMA2000 (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode searchWindowSize */

   if (pvalue->m.searchWindowSizePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "searchWindowSize");

      if ( (pvalue->searchWindowSize <= OSUINTCONST(15)) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->searchWindowSize, OSUINTCONST(0), OSUINTCONST(15));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->searchWindowSize);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode offsetFreq */

   if (pvalue->offsetFreq != 0) {
      RTXCTXTPUSHELEMNAME (pctxt, "offsetFreq");

      stat = asn1PE_Q_OffsetRangeInterRAT (pctxt, pvalue->offsetFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cellsToRemoveList */

   if (pvalue->m.cellsToRemoveListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellsToRemoveList");

      stat = asn1PE_CellIndexList (pctxt, &pvalue->cellsToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cellsToAddModList */

   if (pvalue->m.cellsToAddModListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellsToAddModList");

      stat = asn1PE_CellsToAddModListCDMA2000 (pctxt, &pvalue->cellsToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cellForWhichToReportCGI */

   if (pvalue->m.cellForWhichToReportCGIPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellForWhichToReportCGI");

      stat = asn1PE_PhysCellIdCDMA2000 (pctxt, pvalue->cellForWhichToReportCGI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasObjectCDMA2000 (OSCTXT* pctxt, MeasObjectCDMA2000* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectCDMA2000");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cdma2000_Type */
   RTXCTXTPUSHELEMNAME (pctxt, "cdma2000-Type");

   stat = asn1PD_CDMA2000_Type (pctxt, &pvalue->cdma2000_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode carrierFreq */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PD_CarrierFreqCDMA2000 (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode searchWindowSize */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "searchWindowSize");

      pvalue->m.searchWindowSizePresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->searchWindowSize, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode offsetFreq */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "offsetFreq");

      stat = asn1PD_Q_OffsetRangeInterRAT (pctxt, &pvalue->offsetFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->offsetFreq = 0;
   }

   /* decode cellsToRemoveList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellsToRemoveList");

      pvalue->m.cellsToRemoveListPresent = 1;

      stat = asn1PD_CellIndexList (pctxt, &pvalue->cellsToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cellsToAddModList */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellsToAddModList");

      pvalue->m.cellsToAddModListPresent = 1;

      stat = asn1PD_CellsToAddModListCDMA2000 (pctxt, &pvalue->cellsToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cellForWhichToReportCGI */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellForWhichToReportCGI");

      pvalue->m.cellForWhichToReportCGIPresent = 1;

      stat = asn1PD_PhysCellIdCDMA2000 (pctxt, &pvalue->cellForWhichToReportCGI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasObjectCDMA2000 (MeasObjectCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->offsetFreq = 0;
   asn1Init_CellIndexList (&pvalue->cellsToRemoveList);
   asn1Init_CellsToAddModListCDMA2000 (&pvalue->cellsToAddModList);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_MeasObjectToAddMod_measObject (OSCTXT* pctxt, MeasObjectToAddMod_measObject* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasObjectToAddMod_measObject"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 4);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* measObjectEUTRA */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "measObjectEUTRA");

            stat = asn1PE_MeasObjectEUTRA (pctxt, pvalue->u.measObjectEUTRA);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* measObjectUTRA */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "measObjectUTRA");

            stat = asn1PE_MeasObjectUTRA (pctxt, pvalue->u.measObjectUTRA);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* measObjectGERAN */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "measObjectGERAN");

            stat = asn1PE_MeasObjectGERAN (pctxt, pvalue->u.measObjectGERAN);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* measObjectCDMA2000 */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "measObjectCDMA2000");

            stat = asn1PE_MeasObjectCDMA2000 (pctxt, pvalue->u.measObjectCDMA2000);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasObjectToAddMod_measObject (OSCTXT* pctxt, MeasObjectToAddMod_measObject* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* measObjectEUTRA */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "measObjectEUTRA");

            pvalue->u.measObjectEUTRA = rtxMemAllocType (pctxt, 
               MeasObjectEUTRA);

            if (pvalue->u.measObjectEUTRA == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MeasObjectEUTRA (pvalue->u.measObjectEUTRA);

            stat = asn1PD_MeasObjectEUTRA (pctxt, pvalue->u.measObjectEUTRA);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* measObjectUTRA */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "measObjectUTRA");

            pvalue->u.measObjectUTRA = rtxMemAllocType (pctxt, 
               MeasObjectUTRA);

            if (pvalue->u.measObjectUTRA == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MeasObjectUTRA (pvalue->u.measObjectUTRA);

            stat = asn1PD_MeasObjectUTRA (pctxt, pvalue->u.measObjectUTRA);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* measObjectGERAN */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "measObjectGERAN");

            pvalue->u.measObjectGERAN = rtxMemAllocType (pctxt, 
               MeasObjectGERAN);

            if (pvalue->u.measObjectGERAN == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MeasObjectGERAN (pvalue->u.measObjectGERAN);

            stat = asn1PD_MeasObjectGERAN (pctxt, pvalue->u.measObjectGERAN);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* measObjectCDMA2000 */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "measObjectCDMA2000");

            pvalue->u.measObjectCDMA2000 = rtxMemAllocType (pctxt, 
               MeasObjectCDMA2000);

            if (pvalue->u.measObjectCDMA2000 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MeasObjectCDMA2000 (pvalue->u.measObjectCDMA2000);

            stat = asn1PD_MeasObjectCDMA2000 (pctxt, pvalue->u.measObjectCDMA2000);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

void asn1Init_MeasObjectToAddMod_measObject (
   MeasObjectToAddMod_measObject* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MeasObjectToAddMod (OSCTXT* pctxt, MeasObjectToAddMod* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectToAddMod");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasObjectToAddMod"));

   /* encode measObjectId */

   RTXCTXTPUSHELEMNAME (pctxt, "measObjectId");

   stat = asn1PE_MeasObjectId (pctxt, pvalue->measObjectId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode measObject */

   RTXCTXTPUSHELEMNAME (pctxt, "measObject");

   stat = asn1PE_MeasObjectToAddMod_measObject (pctxt, &pvalue->measObject);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasObjectToAddMod (OSCTXT* pctxt, MeasObjectToAddMod* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectToAddMod");

   /* decode root elements */
   /* decode measObjectId */
   RTXCTXTPUSHELEMNAME (pctxt, "measObjectId");

   stat = asn1PD_MeasObjectId (pctxt, &pvalue->measObjectId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measObject */
   RTXCTXTPUSHELEMNAME (pctxt, "measObject");

   stat = asn1PD_MeasObjectToAddMod_measObject (pctxt, &pvalue->measObject);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasObjectToAddMod (MeasObjectToAddMod* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_MeasObjectToAddMod_measObject (&pvalue->measObject);
}

EXTERN int asn1PE_MeasObjectToAddModList (OSCTXT* pctxt, MeasObjectToAddModList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectToAddModList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasObjectToAddModList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasObjectToAddMod", xx1);

      stat = asn1PE_MeasObjectToAddMod (pctxt, ((MeasObjectToAddMod*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasObjectToAddModList (OSCTXT* pctxt, MeasObjectToAddModList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasObjectToAddModList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MeasObjectToAddMod* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasObjectToAddMod", xx1);

      rtxDListAllocNodeAndData (pctxt, MeasObjectToAddMod, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MeasObjectToAddMod (pdata);

      stat = asn1PD_MeasObjectToAddMod (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasObjectToAddModList (MeasObjectToAddModList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_ReportConfigToRemoveList (OSCTXT* pctxt, ReportConfigToRemoveList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportConfigToRemoveList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigToRemoveList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ReportConfigId", xx1);

      stat = asn1PE_ReportConfigId (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigToRemoveList (OSCTXT* pctxt, ReportConfigToRemoveList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportConfigToRemoveList");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 5);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 32) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ReportConfigId", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (ReportConfigId));
      stat = asn1PD_ReportConfigId (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ReportConfigToRemoveList (ReportConfigToRemoveList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_ThresholdEUTRA (OSCTXT* pctxt, ThresholdEUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ThresholdEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ThresholdEUTRA"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* threshold_RSRP */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "threshold-RSRP");

         stat = asn1PE_RSRP_Range (pctxt, pvalue->u.threshold_RSRP);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* threshold_RSRQ */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "threshold-RSRQ");

         stat = asn1PE_RSRQ_Range (pctxt, pvalue->u.threshold_RSRQ);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ThresholdEUTRA (OSCTXT* pctxt, ThresholdEUTRA* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "ThresholdEUTRA");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* threshold_RSRP */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "threshold-RSRP");

         stat = asn1PD_RSRP_Range (pctxt, &pvalue->u.threshold_RSRP);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* threshold_RSRQ */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "threshold-RSRQ");

         stat = asn1PD_RSRQ_Range (pctxt, &pvalue->u.threshold_RSRQ);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ThresholdEUTRA (ThresholdEUTRA* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ReportConfigEUTRA_triggerType_event_eventId_eventA1 (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_event_eventId_eventA1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_triggerType_event_eventId_eventA1"));

   /* encode a1_Threshold */

   RTXCTXTPUSHELEMNAME (pctxt, "a1-Threshold");

   stat = asn1PE_ThresholdEUTRA (pctxt, &pvalue->a1_Threshold);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_triggerType_event_eventId_eventA1 (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_event_eventId_eventA1* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode a1_Threshold */
   RTXCTXTPUSHELEMNAME (pctxt, "a1-Threshold");

   stat = asn1PD_ThresholdEUTRA (pctxt, &pvalue->a1_Threshold);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_ReportConfigEUTRA_triggerType_event_eventId_eventA1 (
   ReportConfigEUTRA_triggerType_event_eventId_eventA1* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_ThresholdEUTRA (&pvalue->a1_Threshold);
}

EXTERN int asn1PE_ReportConfigEUTRA_triggerType_event_eventId_eventA2 (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_event_eventId_eventA2* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_triggerType_event_eventId_eventA2"));

   /* encode a2_Threshold */

   RTXCTXTPUSHELEMNAME (pctxt, "a2-Threshold");

   stat = asn1PE_ThresholdEUTRA (pctxt, &pvalue->a2_Threshold);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_triggerType_event_eventId_eventA2 (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_event_eventId_eventA2* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode a2_Threshold */
   RTXCTXTPUSHELEMNAME (pctxt, "a2-Threshold");

   stat = asn1PD_ThresholdEUTRA (pctxt, &pvalue->a2_Threshold);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_ReportConfigEUTRA_triggerType_event_eventId_eventA2 (
   ReportConfigEUTRA_triggerType_event_eventId_eventA2* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_ThresholdEUTRA (&pvalue->a2_Threshold);
}

EXTERN int asn1PE_ReportConfigEUTRA_triggerType_event_eventId_eventA3 (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_event_eventId_eventA3* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_triggerType_event_eventId_eventA3"));

   /* encode a3_Offset */

   RTXCTXTPUSHELEMNAME (pctxt, "a3-Offset");

   if ( (pvalue->a3_Offset >= OSINTCONST(-30) && pvalue->a3_Offset <= OSINTCONST(30)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->a3_Offset, OSINTCONST(-30), OSINTCONST(30));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->a3_Offset);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode reportOnLeave */

   RTXCTXTPUSHELEMNAME (pctxt, "reportOnLeave");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->reportOnLeave);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_triggerType_event_eventId_eventA3 (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_event_eventId_eventA3* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode a3_Offset */
   RTXCTXTPUSHELEMNAME (pctxt, "a3-Offset");

   stat = pd_ConsInt8 (pctxt, &pvalue->a3_Offset, OSINTCONST(-30), OSINTCONST(30));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reportOnLeave */
   RTXCTXTPUSHELEMNAME (pctxt, "reportOnLeave");

   stat = DEC_BIT (pctxt, &pvalue->reportOnLeave);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ReportConfigEUTRA_triggerType_event_eventId_eventA4 (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_event_eventId_eventA4* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_triggerType_event_eventId_eventA4"));

   /* encode a4_Threshold */

   RTXCTXTPUSHELEMNAME (pctxt, "a4-Threshold");

   stat = asn1PE_ThresholdEUTRA (pctxt, &pvalue->a4_Threshold);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_triggerType_event_eventId_eventA4 (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_event_eventId_eventA4* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode a4_Threshold */
   RTXCTXTPUSHELEMNAME (pctxt, "a4-Threshold");

   stat = asn1PD_ThresholdEUTRA (pctxt, &pvalue->a4_Threshold);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_ReportConfigEUTRA_triggerType_event_eventId_eventA4 (
   ReportConfigEUTRA_triggerType_event_eventId_eventA4* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_ThresholdEUTRA (&pvalue->a4_Threshold);
}

EXTERN int asn1PE_ReportConfigEUTRA_triggerType_event_eventId_eventA5 (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_event_eventId_eventA5* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_triggerType_event_eventId_eventA5"));

   /* encode a5_Threshold1 */

   RTXCTXTPUSHELEMNAME (pctxt, "a5-Threshold1");

   stat = asn1PE_ThresholdEUTRA (pctxt, &pvalue->a5_Threshold1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode a5_Threshold2 */

   RTXCTXTPUSHELEMNAME (pctxt, "a5-Threshold2");

   stat = asn1PE_ThresholdEUTRA (pctxt, &pvalue->a5_Threshold2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_triggerType_event_eventId_eventA5 (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_event_eventId_eventA5* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode a5_Threshold1 */
   RTXCTXTPUSHELEMNAME (pctxt, "a5-Threshold1");

   stat = asn1PD_ThresholdEUTRA (pctxt, &pvalue->a5_Threshold1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode a5_Threshold2 */
   RTXCTXTPUSHELEMNAME (pctxt, "a5-Threshold2");

   stat = asn1PD_ThresholdEUTRA (pctxt, &pvalue->a5_Threshold2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_ReportConfigEUTRA_triggerType_event_eventId_eventA5 (
   ReportConfigEUTRA_triggerType_event_eventId_eventA5* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_ThresholdEUTRA (&pvalue->a5_Threshold1);
   asn1Init_ThresholdEUTRA (&pvalue->a5_Threshold2);
}

EXTERN int asn1PE_ReportConfigEUTRA_triggerType_event_eventId (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_event_eventId* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_triggerType_event_eventId"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 5);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 4);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* eventA1 */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "eventA1");

            stat = asn1PE_ReportConfigEUTRA_triggerType_event_eventId_eventA1 (pctxt, pvalue->u.eventA1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* eventA2 */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "eventA2");

            stat = asn1PE_ReportConfigEUTRA_triggerType_event_eventId_eventA2 (pctxt, pvalue->u.eventA2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* eventA3 */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "eventA3");

            stat = asn1PE_ReportConfigEUTRA_triggerType_event_eventId_eventA3 (pctxt, pvalue->u.eventA3);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* eventA4 */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "eventA4");

            stat = asn1PE_ReportConfigEUTRA_triggerType_event_eventId_eventA4 (pctxt, pvalue->u.eventA4);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* eventA5 */
         case 5:
            RTXCTXTPUSHELEMNAME (pctxt, "eventA5");

            stat = asn1PE_ReportConfigEUTRA_triggerType_event_eventId_eventA5 (pctxt, pvalue->u.eventA5);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 6);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_triggerType_event_eventId (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_event_eventId* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* eventA1 */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "eventA1");

            pvalue->u.eventA1 = rtxMemAllocType (pctxt, 
               ReportConfigEUTRA_triggerType_event_eventId_eventA1);

            if (pvalue->u.eventA1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ReportConfigEUTRA_triggerType_event_eventId_eventA1 (pvalue->u.eventA1);

            stat = asn1PD_ReportConfigEUTRA_triggerType_event_eventId_eventA1 (pctxt, pvalue->u.eventA1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* eventA2 */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "eventA2");

            pvalue->u.eventA2 = rtxMemAllocType (pctxt, 
               ReportConfigEUTRA_triggerType_event_eventId_eventA2);

            if (pvalue->u.eventA2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ReportConfigEUTRA_triggerType_event_eventId_eventA2 (pvalue->u.eventA2);

            stat = asn1PD_ReportConfigEUTRA_triggerType_event_eventId_eventA2 (pctxt, pvalue->u.eventA2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* eventA3 */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "eventA3");

            pvalue->u.eventA3 = rtxMemAllocTypeZ (pctxt, 
               ReportConfigEUTRA_triggerType_event_eventId_eventA3);

            if (pvalue->u.eventA3 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            stat = asn1PD_ReportConfigEUTRA_triggerType_event_eventId_eventA3 (pctxt, pvalue->u.eventA3);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* eventA4 */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "eventA4");

            pvalue->u.eventA4 = rtxMemAllocType (pctxt, 
               ReportConfigEUTRA_triggerType_event_eventId_eventA4);

            if (pvalue->u.eventA4 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ReportConfigEUTRA_triggerType_event_eventId_eventA4 (pvalue->u.eventA4);

            stat = asn1PD_ReportConfigEUTRA_triggerType_event_eventId_eventA4 (pctxt, pvalue->u.eventA4);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* eventA5 */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "eventA5");

            pvalue->u.eventA5 = rtxMemAllocType (pctxt, 
               ReportConfigEUTRA_triggerType_event_eventId_eventA5);

            if (pvalue->u.eventA5 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ReportConfigEUTRA_triggerType_event_eventId_eventA5 (pvalue->u.eventA5);

            stat = asn1PD_ReportConfigEUTRA_triggerType_event_eventId_eventA5 (pctxt, pvalue->u.eventA5);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 6;

      if (pvalue->t < 6) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

void asn1Init_ReportConfigEUTRA_triggerType_event_eventId (
   ReportConfigEUTRA_triggerType_event_eventId* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ReportConfigEUTRA_triggerType_event (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_event* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_triggerType_event"));

   /* encode eventId */

   RTXCTXTPUSHELEMNAME (pctxt, "eventId");

   stat = asn1PE_ReportConfigEUTRA_triggerType_event_eventId (pctxt, &pvalue->eventId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode hysteresis */

   RTXCTXTPUSHELEMNAME (pctxt, "hysteresis");

   stat = asn1PE_Hysteresis (pctxt, pvalue->hysteresis);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode timeToTrigger */

   RTXCTXTPUSHELEMNAME (pctxt, "timeToTrigger");

   stat = asn1PE_TimeToTrigger (pctxt, pvalue->timeToTrigger);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_triggerType_event (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_event* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode eventId */
   RTXCTXTPUSHELEMNAME (pctxt, "eventId");

   stat = asn1PD_ReportConfigEUTRA_triggerType_event_eventId (pctxt, &pvalue->eventId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode hysteresis */
   RTXCTXTPUSHELEMNAME (pctxt, "hysteresis");

   stat = asn1PD_Hysteresis (pctxt, &pvalue->hysteresis);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeToTrigger */
   RTXCTXTPUSHELEMNAME (pctxt, "timeToTrigger");

   stat = asn1PD_TimeToTrigger (pctxt, &pvalue->timeToTrigger);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_ReportConfigEUTRA_triggerType_event (
   ReportConfigEUTRA_triggerType_event* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_ReportConfigEUTRA_triggerType_event_eventId (&pvalue->eventId);
}

EXTERN int asn1PE_ReportConfigEUTRA_triggerType_periodical (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_periodical* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_triggerType_periodical"));

   /* encode purpose */

   RTXCTXTPUSHELEMNAME (pctxt, "purpose");

   stat = asn1PE_ReportConfigEUTRA_triggerType_periodical_purpose (pctxt, pvalue->purpose);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_triggerType_periodical (OSCTXT* pctxt, ReportConfigEUTRA_triggerType_periodical* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode purpose */
   RTXCTXTPUSHELEMNAME (pctxt, "purpose");

   stat = asn1PD_ReportConfigEUTRA_triggerType_periodical_purpose (pctxt, &pvalue->purpose);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ReportConfigEUTRA_triggerType (OSCTXT* pctxt, ReportConfigEUTRA_triggerType* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA_triggerType"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* event */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "event");

         stat = asn1PE_ReportConfigEUTRA_triggerType_event (pctxt, pvalue->u.event);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* periodical */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "periodical");

         stat = asn1PE_ReportConfigEUTRA_triggerType_periodical (pctxt, pvalue->u.periodical);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA_triggerType (OSCTXT* pctxt, ReportConfigEUTRA_triggerType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* event */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "event");

         pvalue->u.event = rtxMemAllocType (pctxt, 
            ReportConfigEUTRA_triggerType_event);

         if (pvalue->u.event == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ReportConfigEUTRA_triggerType_event (pvalue->u.event);

         stat = asn1PD_ReportConfigEUTRA_triggerType_event (pctxt, pvalue->u.event);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* periodical */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "periodical");

         pvalue->u.periodical = rtxMemAllocTypeZ (pctxt, 
            ReportConfigEUTRA_triggerType_periodical);

         if (pvalue->u.periodical == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_ReportConfigEUTRA_triggerType_periodical (pctxt, pvalue->u.periodical);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_ReportConfigEUTRA_triggerType (
   ReportConfigEUTRA_triggerType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ReportConfigEUTRA (OSCTXT* pctxt, ReportConfigEUTRA* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportConfigEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigEUTRA"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m._v2ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode triggerType */

   RTXCTXTPUSHELEMNAME (pctxt, "triggerType");

   stat = asn1PE_ReportConfigEUTRA_triggerType (pctxt, &pvalue->triggerType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode triggerQuantity */

   RTXCTXTPUSHELEMNAME (pctxt, "triggerQuantity");

   stat = asn1PE_ReportConfigEUTRA_triggerQuantity (pctxt, pvalue->triggerQuantity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode reportQuantity */

   RTXCTXTPUSHELEMNAME (pctxt, "reportQuantity");

   stat = asn1PE_ReportConfigEUTRA_reportQuantity (pctxt, pvalue->reportQuantity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode maxReportCells */

   RTXCTXTPUSHELEMNAME (pctxt, "maxReportCells");

   if ( (pvalue->maxReportCells >= OSUINTCONST(1) && pvalue->maxReportCells
       <= OSUINTCONST(8)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->maxReportCells, OSUINTCONST(1), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->maxReportCells);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode reportInterval */

   RTXCTXTPUSHELEMNAME (pctxt, "reportInterval");

   stat = asn1PE_ReportInterval (pctxt, pvalue->reportInterval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode reportAmount */

   RTXCTXTPUSHELEMNAME (pctxt, "reportAmount");

   stat = asn1PE_ReportConfigEUTRA_reportAmount (pctxt, pvalue->reportAmount);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v2ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m._v2ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.si_RequestForHO_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ue_RxTxTimeDiffPeriodical_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode si_RequestForHO_r9 */

         if (pvalue->m.si_RequestForHO_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "si-RequestForHO-r9");

            stat = asn1PE_ReportConfigEUTRA_si_RequestForHO_r9 (pctxt, pvalue->si_RequestForHO_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         /* encode ue_RxTxTimeDiffPeriodical_r9 */

         if (pvalue->m.ue_RxTxTimeDiffPeriodical_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "ue-RxTxTimeDiffPeriodical-r9");

            stat = asn1PE_ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9 (pctxt, pvalue->ue_RxTxTimeDiffPeriodical_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigEUTRA (OSCTXT* pctxt, ReportConfigEUTRA* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportConfigEUTRA");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode triggerType */
   RTXCTXTPUSHELEMNAME (pctxt, "triggerType");

   stat = asn1PD_ReportConfigEUTRA_triggerType (pctxt, &pvalue->triggerType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode triggerQuantity */
   RTXCTXTPUSHELEMNAME (pctxt, "triggerQuantity");

   stat = asn1PD_ReportConfigEUTRA_triggerQuantity (pctxt, &pvalue->triggerQuantity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reportQuantity */
   RTXCTXTPUSHELEMNAME (pctxt, "reportQuantity");

   stat = asn1PD_ReportConfigEUTRA_reportQuantity (pctxt, &pvalue->reportQuantity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maxReportCells */
   RTXCTXTPUSHELEMNAME (pctxt, "maxReportCells");

   stat = pd_ConsUInt8 (pctxt, &pvalue->maxReportCells, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reportInterval */
   RTXCTXTPUSHELEMNAME (pctxt, "reportInterval");

   stat = asn1PD_ReportInterval (pctxt, &pvalue->reportInterval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reportAmount */
   RTXCTXTPUSHELEMNAME (pctxt, "reportAmount");

   stat = asn1PD_ReportConfigEUTRA_reportAmount (pctxt, &pvalue->reportAmount);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m._v2ExtPresent = 1;
                        {
                           OSOCTET extoptbits[2];
                           OSUINT32 _i;

                           for (_i = 0; _i < 2; _i++) {
                              stat = DEC_BIT (pctxt, &extoptbits[_i]);
                              if (stat != 0)  {
                                 rtxMemFreePtr (pctxt, poptbits);
                                 return LOG_RTERR (pctxt, stat);
                              }
                           }
                           if (extoptbits[0]) {
                              pvalue->m.si_RequestForHO_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "si-RequestForHO-r9");

                              stat = asn1PD_ReportConfigEUTRA_si_RequestForHO_r9 (pctxt, &pvalue->si_RequestForHO_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                           if (extoptbits[1]) {
                              pvalue->m.ue_RxTxTimeDiffPeriodical_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "ue-RxTxTimeDiffPeriodical-r9");

                              stat = asn1PD_ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9 (pctxt, &pvalue->ue_RxTxTimeDiffPeriodical_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;

                        /* Coverity 55360 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ReportConfigEUTRA (ReportConfigEUTRA* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ReportConfigEUTRA_triggerType (&pvalue->triggerType);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_ThresholdUTRA (OSCTXT* pctxt, ThresholdUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ThresholdUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ThresholdUTRA"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* utra_RSCP */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "utra-RSCP");

         if ( (pvalue->u.utra_RSCP >= OSINTCONST(-5) && pvalue->u.utra_RSCP
             <= OSINTCONST(91)) ) {
            stat = pe_ConsInteger (pctxt, pvalue->u.utra_RSCP, OSINTCONST(-5), OSINTCONST(91));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, pvalue->u.utra_RSCP);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* utra_EcN0 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "utra-EcN0");

         if ( (pvalue->u.utra_EcN0 <= OSUINTCONST(49)) ) {
            stat = pe_ConsUnsigned (pctxt, pvalue->u.utra_EcN0, OSUINTCONST(0), OSUINTCONST(49));
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddUIntParm (pctxt, pvalue->u.utra_EcN0);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ThresholdUTRA (OSCTXT* pctxt, ThresholdUTRA* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "ThresholdUTRA");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* utra_RSCP */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "utra-RSCP");

         stat = pd_ConsInt8 (pctxt, &pvalue->u.utra_RSCP, OSINTCONST(-5), OSINTCONST(91));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* utra_EcN0 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "utra-EcN0");

         stat = pd_ConsUInt8 (pctxt, &pvalue->u.utra_EcN0, OSUINTCONST(0), OSUINTCONST(49));
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ThresholdUTRA (ThresholdUTRA* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* b1_ThresholdUTRA */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "b1-ThresholdUTRA");

         stat = asn1PE_ThresholdUTRA (pctxt, pvalue->u.b1_ThresholdUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* b1_ThresholdGERAN */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "b1-ThresholdGERAN");

         stat = asn1PE_ThresholdGERAN (pctxt, pvalue->u.b1_ThresholdGERAN);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* b1_ThresholdCDMA2000 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "b1-ThresholdCDMA2000");

         stat = asn1PE_ThresholdCDMA2000 (pctxt, pvalue->u.b1_ThresholdCDMA2000);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* b1_ThresholdUTRA */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "b1-ThresholdUTRA");

         pvalue->u.b1_ThresholdUTRA = rtxMemAllocType (pctxt, ThresholdUTRA);

         if (pvalue->u.b1_ThresholdUTRA == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ThresholdUTRA (pvalue->u.b1_ThresholdUTRA);

         stat = asn1PD_ThresholdUTRA (pctxt, pvalue->u.b1_ThresholdUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* b1_ThresholdGERAN */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "b1-ThresholdGERAN");

         stat = asn1PD_ThresholdGERAN (pctxt, &pvalue->u.b1_ThresholdGERAN);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* b1_ThresholdCDMA2000 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "b1-ThresholdCDMA2000");

         stat = asn1PD_ThresholdCDMA2000 (pctxt, &pvalue->u.b1_ThresholdCDMA2000);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold (
   ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ReportConfigInterRAT_triggerType_event_eventId_eventB1 (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_event_eventId_eventB1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigInterRAT_triggerType_event_eventId_eventB1"));

   /* encode b1_Threshold */

   RTXCTXTPUSHELEMNAME (pctxt, "b1-Threshold");

   stat = asn1PE_ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold (pctxt, &pvalue->b1_Threshold);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigInterRAT_triggerType_event_eventId_eventB1 (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_event_eventId_eventB1* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode b1_Threshold */
   RTXCTXTPUSHELEMNAME (pctxt, "b1-Threshold");

   stat = asn1PD_ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold (pctxt, &pvalue->b1_Threshold);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_ReportConfigInterRAT_triggerType_event_eventId_eventB1 (
   ReportConfigInterRAT_triggerType_event_eventId_eventB1* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold (&pvalue->b1_Threshold);
}

EXTERN int asn1PE_ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2 (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* b2_Threshold2UTRA */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "b2-Threshold2UTRA");

         stat = asn1PE_ThresholdUTRA (pctxt, pvalue->u.b2_Threshold2UTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* b2_Threshold2GERAN */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "b2-Threshold2GERAN");

         stat = asn1PE_ThresholdGERAN (pctxt, pvalue->u.b2_Threshold2GERAN);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* b2_Threshold2CDMA2000 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "b2-Threshold2CDMA2000");

         stat = asn1PE_ThresholdCDMA2000 (pctxt, pvalue->u.b2_Threshold2CDMA2000);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2 (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* b2_Threshold2UTRA */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "b2-Threshold2UTRA");

         pvalue->u.b2_Threshold2UTRA = rtxMemAllocType (pctxt, ThresholdUTRA);

         if (pvalue->u.b2_Threshold2UTRA == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ThresholdUTRA (pvalue->u.b2_Threshold2UTRA);

         stat = asn1PD_ThresholdUTRA (pctxt, pvalue->u.b2_Threshold2UTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* b2_Threshold2GERAN */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "b2-Threshold2GERAN");

         stat = asn1PD_ThresholdGERAN (pctxt, &pvalue->u.b2_Threshold2GERAN);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* b2_Threshold2CDMA2000 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "b2-Threshold2CDMA2000");

         stat = asn1PD_ThresholdCDMA2000 (pctxt, &pvalue->u.b2_Threshold2CDMA2000);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2 (
   ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ReportConfigInterRAT_triggerType_event_eventId_eventB2 (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_event_eventId_eventB2* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigInterRAT_triggerType_event_eventId_eventB2"));

   /* encode b2_Threshold1 */

   RTXCTXTPUSHELEMNAME (pctxt, "b2-Threshold1");

   stat = asn1PE_ThresholdEUTRA (pctxt, &pvalue->b2_Threshold1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode b2_Threshold2 */

   RTXCTXTPUSHELEMNAME (pctxt, "b2-Threshold2");

   stat = asn1PE_ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2 (pctxt, &pvalue->b2_Threshold2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigInterRAT_triggerType_event_eventId_eventB2 (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_event_eventId_eventB2* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode b2_Threshold1 */
   RTXCTXTPUSHELEMNAME (pctxt, "b2-Threshold1");

   stat = asn1PD_ThresholdEUTRA (pctxt, &pvalue->b2_Threshold1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode b2_Threshold2 */
   RTXCTXTPUSHELEMNAME (pctxt, "b2-Threshold2");

   stat = asn1PD_ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2 (pctxt, &pvalue->b2_Threshold2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_ReportConfigInterRAT_triggerType_event_eventId_eventB2 (
   ReportConfigInterRAT_triggerType_event_eventId_eventB2* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_ThresholdEUTRA (&pvalue->b2_Threshold1);
   asn1Init_ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2 (&pvalue->b2_Threshold2);
}

EXTERN int asn1PE_ReportConfigInterRAT_triggerType_event_eventId (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_event_eventId* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigInterRAT_triggerType_event_eventId"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* eventB1 */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "eventB1");

            stat = asn1PE_ReportConfigInterRAT_triggerType_event_eventId_eventB1 (pctxt, pvalue->u.eventB1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* eventB2 */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "eventB2");

            stat = asn1PE_ReportConfigInterRAT_triggerType_event_eventId_eventB2 (pctxt, pvalue->u.eventB2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigInterRAT_triggerType_event_eventId (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_event_eventId* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* eventB1 */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "eventB1");

            pvalue->u.eventB1 = rtxMemAllocType (pctxt, 
               ReportConfigInterRAT_triggerType_event_eventId_eventB1);

            if (pvalue->u.eventB1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ReportConfigInterRAT_triggerType_event_eventId_eventB1 (pvalue->u.eventB1);

            stat = asn1PD_ReportConfigInterRAT_triggerType_event_eventId_eventB1 (pctxt, pvalue->u.eventB1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* eventB2 */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "eventB2");

            pvalue->u.eventB2 = rtxMemAllocType (pctxt, 
               ReportConfigInterRAT_triggerType_event_eventId_eventB2);

            if (pvalue->u.eventB2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ReportConfigInterRAT_triggerType_event_eventId_eventB2 (pvalue->u.eventB2);

            stat = asn1PD_ReportConfigInterRAT_triggerType_event_eventId_eventB2 (pctxt, pvalue->u.eventB2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

void asn1Init_ReportConfigInterRAT_triggerType_event_eventId (
   ReportConfigInterRAT_triggerType_event_eventId* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ReportConfigInterRAT_triggerType_event (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_event* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigInterRAT_triggerType_event"));

   /* encode eventId */

   RTXCTXTPUSHELEMNAME (pctxt, "eventId");

   stat = asn1PE_ReportConfigInterRAT_triggerType_event_eventId (pctxt, &pvalue->eventId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode hysteresis */

   RTXCTXTPUSHELEMNAME (pctxt, "hysteresis");

   stat = asn1PE_Hysteresis (pctxt, pvalue->hysteresis);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode timeToTrigger */

   RTXCTXTPUSHELEMNAME (pctxt, "timeToTrigger");

   stat = asn1PE_TimeToTrigger (pctxt, pvalue->timeToTrigger);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigInterRAT_triggerType_event (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_event* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode eventId */
   RTXCTXTPUSHELEMNAME (pctxt, "eventId");

   stat = asn1PD_ReportConfigInterRAT_triggerType_event_eventId (pctxt, &pvalue->eventId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode hysteresis */
   RTXCTXTPUSHELEMNAME (pctxt, "hysteresis");

   stat = asn1PD_Hysteresis (pctxt, &pvalue->hysteresis);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeToTrigger */
   RTXCTXTPUSHELEMNAME (pctxt, "timeToTrigger");

   stat = asn1PD_TimeToTrigger (pctxt, &pvalue->timeToTrigger);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_ReportConfigInterRAT_triggerType_event (
   ReportConfigInterRAT_triggerType_event* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_ReportConfigInterRAT_triggerType_event_eventId (&pvalue->eventId);
}

EXTERN int asn1PE_ReportConfigInterRAT_triggerType_periodical (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_periodical* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigInterRAT_triggerType_periodical"));

   /* encode purpose */

   RTXCTXTPUSHELEMNAME (pctxt, "purpose");

   stat = asn1PE_ReportConfigInterRAT_triggerType_periodical_purpose (pctxt, pvalue->purpose);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigInterRAT_triggerType_periodical (OSCTXT* pctxt, ReportConfigInterRAT_triggerType_periodical* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode purpose */
   RTXCTXTPUSHELEMNAME (pctxt, "purpose");

   stat = asn1PD_ReportConfigInterRAT_triggerType_periodical_purpose (pctxt, &pvalue->purpose);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ReportConfigInterRAT_triggerType (OSCTXT* pctxt, ReportConfigInterRAT_triggerType* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigInterRAT_triggerType"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* event */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "event");

         stat = asn1PE_ReportConfigInterRAT_triggerType_event (pctxt, pvalue->u.event);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* periodical */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "periodical");

         stat = asn1PE_ReportConfigInterRAT_triggerType_periodical (pctxt, pvalue->u.periodical);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigInterRAT_triggerType (OSCTXT* pctxt, ReportConfigInterRAT_triggerType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* event */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "event");

         pvalue->u.event = rtxMemAllocType (pctxt, 
            ReportConfigInterRAT_triggerType_event);

         if (pvalue->u.event == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ReportConfigInterRAT_triggerType_event (pvalue->u.event);

         stat = asn1PD_ReportConfigInterRAT_triggerType_event (pctxt, pvalue->u.event);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* periodical */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "periodical");

         pvalue->u.periodical = rtxMemAllocTypeZ (pctxt, 
            ReportConfigInterRAT_triggerType_periodical);

         if (pvalue->u.periodical == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_ReportConfigInterRAT_triggerType_periodical (pctxt, pvalue->u.periodical);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_ReportConfigInterRAT_triggerType (
   ReportConfigInterRAT_triggerType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ReportConfigInterRAT (OSCTXT* pctxt, ReportConfigInterRAT* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportConfigInterRAT");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigInterRAT"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m._v2ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode triggerType */

   RTXCTXTPUSHELEMNAME (pctxt, "triggerType");

   stat = asn1PE_ReportConfigInterRAT_triggerType (pctxt, &pvalue->triggerType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode maxReportCells */

   RTXCTXTPUSHELEMNAME (pctxt, "maxReportCells");

   if ( (pvalue->maxReportCells >= OSUINTCONST(1) && pvalue->maxReportCells
       <= OSUINTCONST(8)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->maxReportCells, OSUINTCONST(1), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->maxReportCells);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode reportInterval */

   RTXCTXTPUSHELEMNAME (pctxt, "reportInterval");

   stat = asn1PE_ReportInterval (pctxt, pvalue->reportInterval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode reportAmount */

   RTXCTXTPUSHELEMNAME (pctxt, "reportAmount");

   stat = asn1PE_ReportConfigInterRAT_reportAmount (pctxt, pvalue->reportAmount);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v2ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m._v2ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.si_RequestForHO_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode si_RequestForHO_r9 */

         if (pvalue->m.si_RequestForHO_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "si-RequestForHO-r9");

            stat = asn1PE_ReportConfigInterRAT_si_RequestForHO_r9 (pctxt, pvalue->si_RequestForHO_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigInterRAT (OSCTXT* pctxt, ReportConfigInterRAT* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportConfigInterRAT");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode triggerType */
   RTXCTXTPUSHELEMNAME (pctxt, "triggerType");

   stat = asn1PD_ReportConfigInterRAT_triggerType (pctxt, &pvalue->triggerType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maxReportCells */
   RTXCTXTPUSHELEMNAME (pctxt, "maxReportCells");

   stat = pd_ConsUInt8 (pctxt, &pvalue->maxReportCells, OSUINTCONST(1), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reportInterval */
   RTXCTXTPUSHELEMNAME (pctxt, "reportInterval");

   stat = asn1PD_ReportInterval (pctxt, &pvalue->reportInterval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reportAmount */
   RTXCTXTPUSHELEMNAME (pctxt, "reportAmount");

   stat = asn1PD_ReportConfigInterRAT_reportAmount (pctxt, &pvalue->reportAmount);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m._v2ExtPresent = 1;
                        {
                           OSOCTET extoptbits[1];

                           stat = DEC_BIT (pctxt, &extoptbits[0]);
                           if (stat != 0)  {
                              rtxMemFreePtr (pctxt, poptbits);
                           }
                           if (extoptbits[0]) {
                              pvalue->m.si_RequestForHO_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "si-RequestForHO-r9");

                              stat = asn1PD_ReportConfigInterRAT_si_RequestForHO_r9 (pctxt, &pvalue->si_RequestForHO_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;

                        /* Coverity 55361 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ReportConfigInterRAT (ReportConfigInterRAT* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ReportConfigInterRAT_triggerType (&pvalue->triggerType);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_ReportConfigToAddMod_reportConfig (OSCTXT* pctxt, ReportConfigToAddMod_reportConfig* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigToAddMod_reportConfig"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* reportConfigEUTRA */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "reportConfigEUTRA");

         stat = asn1PE_ReportConfigEUTRA (pctxt, pvalue->u.reportConfigEUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* reportConfigInterRAT */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "reportConfigInterRAT");

         stat = asn1PE_ReportConfigInterRAT (pctxt, pvalue->u.reportConfigInterRAT);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigToAddMod_reportConfig (OSCTXT* pctxt, ReportConfigToAddMod_reportConfig* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* reportConfigEUTRA */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "reportConfigEUTRA");

         pvalue->u.reportConfigEUTRA = rtxMemAllocType (pctxt, 
            ReportConfigEUTRA);

         if (pvalue->u.reportConfigEUTRA == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ReportConfigEUTRA (pvalue->u.reportConfigEUTRA);

         stat = asn1PD_ReportConfigEUTRA (pctxt, pvalue->u.reportConfigEUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* reportConfigInterRAT */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "reportConfigInterRAT");

         pvalue->u.reportConfigInterRAT = rtxMemAllocType (pctxt, 
            ReportConfigInterRAT);

         if (pvalue->u.reportConfigInterRAT == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ReportConfigInterRAT (pvalue->u.reportConfigInterRAT);

         stat = asn1PD_ReportConfigInterRAT (pctxt, pvalue->u.reportConfigInterRAT);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_ReportConfigToAddMod_reportConfig (
   ReportConfigToAddMod_reportConfig* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ReportConfigToAddMod (OSCTXT* pctxt, ReportConfigToAddMod* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportConfigToAddMod");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigToAddMod"));

   /* encode reportConfigId */

   RTXCTXTPUSHELEMNAME (pctxt, "reportConfigId");

   stat = asn1PE_ReportConfigId (pctxt, pvalue->reportConfigId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode reportConfig */

   RTXCTXTPUSHELEMNAME (pctxt, "reportConfig");

   stat = asn1PE_ReportConfigToAddMod_reportConfig (pctxt, &pvalue->reportConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigToAddMod (OSCTXT* pctxt, ReportConfigToAddMod* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportConfigToAddMod");

   /* decode root elements */
   /* decode reportConfigId */
   RTXCTXTPUSHELEMNAME (pctxt, "reportConfigId");

   stat = asn1PD_ReportConfigId (pctxt, &pvalue->reportConfigId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reportConfig */
   RTXCTXTPUSHELEMNAME (pctxt, "reportConfig");

   stat = asn1PD_ReportConfigToAddMod_reportConfig (pctxt, &pvalue->reportConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ReportConfigToAddMod (ReportConfigToAddMod* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_ReportConfigToAddMod_reportConfig (&pvalue->reportConfig);
}

EXTERN int asn1PE_ReportConfigToAddModList (OSCTXT* pctxt, ReportConfigToAddModList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportConfigToAddModList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportConfigToAddModList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ReportConfigToAddMod", xx1);

      stat = asn1PE_ReportConfigToAddMod (pctxt, ((ReportConfigToAddMod*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportConfigToAddModList (OSCTXT* pctxt, ReportConfigToAddModList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportConfigToAddModList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ReportConfigToAddMod* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ReportConfigToAddMod", xx1);

      rtxDListAllocNodeAndData (pctxt, ReportConfigToAddMod, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ReportConfigToAddMod (pdata);

      stat = asn1PD_ReportConfigToAddMod (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ReportConfigToAddModList (ReportConfigToAddModList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_MeasIdToRemoveList (OSCTXT* pctxt, MeasIdToRemoveList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasIdToRemoveList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasIdToRemoveList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasId", xx1);

      stat = asn1PE_MeasId (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasIdToRemoveList (OSCTXT* pctxt, MeasIdToRemoveList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasIdToRemoveList");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 5);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 32) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasId", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (MeasId));
      stat = asn1PD_MeasId (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasIdToRemoveList (MeasIdToRemoveList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_MeasIdToAddMod (OSCTXT* pctxt, MeasIdToAddMod* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasIdToAddMod");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasIdToAddMod"));

   /* encode measId */

   RTXCTXTPUSHELEMNAME (pctxt, "measId");

   stat = asn1PE_MeasId (pctxt, pvalue->measId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode measObjectId */

   RTXCTXTPUSHELEMNAME (pctxt, "measObjectId");

   stat = asn1PE_MeasObjectId (pctxt, pvalue->measObjectId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode reportConfigId */

   RTXCTXTPUSHELEMNAME (pctxt, "reportConfigId");

   stat = asn1PE_ReportConfigId (pctxt, pvalue->reportConfigId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasIdToAddMod (OSCTXT* pctxt, MeasIdToAddMod* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasIdToAddMod");

   /* decode root elements */
   /* decode measId */
   RTXCTXTPUSHELEMNAME (pctxt, "measId");

   stat = asn1PD_MeasId (pctxt, &pvalue->measId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measObjectId */
   RTXCTXTPUSHELEMNAME (pctxt, "measObjectId");

   stat = asn1PD_MeasObjectId (pctxt, &pvalue->measObjectId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reportConfigId */
   RTXCTXTPUSHELEMNAME (pctxt, "reportConfigId");

   stat = asn1PD_ReportConfigId (pctxt, &pvalue->reportConfigId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_MeasIdToAddModList (OSCTXT* pctxt, MeasIdToAddModList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasIdToAddModList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasIdToAddModList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasIdToAddMod", xx1);

      stat = asn1PE_MeasIdToAddMod (pctxt, ((MeasIdToAddMod*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasIdToAddModList (OSCTXT* pctxt, MeasIdToAddModList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasIdToAddModList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MeasIdToAddMod* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasIdToAddMod", xx1);

      rtxDListAllocNodeAndData (pctxt, MeasIdToAddMod, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_MeasIdToAddMod (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasIdToAddModList (MeasIdToAddModList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_QuantityConfigEUTRA (OSCTXT* pctxt, QuantityConfigEUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QuantityConfigEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("QuantityConfigEUTRA"));

   stat = rtxEncBit (pctxt, (OSBOOL)(pvalue->filterCoefficientRSRP != fc4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)(pvalue->filterCoefficientRSRQ != fc4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode filterCoefficientRSRP */

   if (pvalue->filterCoefficientRSRP != fc4) {
      RTXCTXTPUSHELEMNAME (pctxt, "filterCoefficientRSRP");

      stat = asn1PE_FilterCoefficient (pctxt, pvalue->filterCoefficientRSRP);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode filterCoefficientRSRQ */

   if (pvalue->filterCoefficientRSRQ != fc4) {
      RTXCTXTPUSHELEMNAME (pctxt, "filterCoefficientRSRQ");

      stat = asn1PE_FilterCoefficient (pctxt, pvalue->filterCoefficientRSRQ);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_QuantityConfigEUTRA (OSCTXT* pctxt, QuantityConfigEUTRA* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "QuantityConfigEUTRA");

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode filterCoefficientRSRP */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "filterCoefficientRSRP");

      stat = asn1PD_FilterCoefficient (pctxt, &pvalue->filterCoefficientRSRP);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->filterCoefficientRSRP = fc4;
   }

   /* decode filterCoefficientRSRQ */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "filterCoefficientRSRQ");

      stat = asn1PD_FilterCoefficient (pctxt, &pvalue->filterCoefficientRSRQ);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->filterCoefficientRSRQ = fc4;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_QuantityConfigEUTRA (QuantityConfigEUTRA* pvalue)
{
   if (0 == pvalue) return;
   pvalue->filterCoefficientRSRP = fc4;
   pvalue->filterCoefficientRSRQ = fc4;
}

EXTERN int asn1PE_QuantityConfigUTRA (OSCTXT* pctxt, QuantityConfigUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QuantityConfigUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("QuantityConfigUTRA"));

   stat = rtxEncBit (pctxt, (OSBOOL)(pvalue->filterCoefficient != fc4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measQuantityUTRA_FDD */

   RTXCTXTPUSHELEMNAME (pctxt, "measQuantityUTRA-FDD");

   stat = asn1PE_QuantityConfigUTRA_measQuantityUTRA_FDD (pctxt, pvalue->measQuantityUTRA_FDD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode measQuantityUTRA_TDD */

   RTXCTXTPUSHELEMNAME (pctxt, "measQuantityUTRA-TDD");

   stat = asn1PE_QuantityConfigUTRA_measQuantityUTRA_TDD (pctxt, pvalue->measQuantityUTRA_TDD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode filterCoefficient */

   if (pvalue->filterCoefficient != fc4) {
      RTXCTXTPUSHELEMNAME (pctxt, "filterCoefficient");

      stat = asn1PE_FilterCoefficient (pctxt, pvalue->filterCoefficient);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_QuantityConfigUTRA (OSCTXT* pctxt, QuantityConfigUTRA* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "QuantityConfigUTRA");

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode measQuantityUTRA_FDD */
   RTXCTXTPUSHELEMNAME (pctxt, "measQuantityUTRA-FDD");

   stat = asn1PD_QuantityConfigUTRA_measQuantityUTRA_FDD (pctxt, &pvalue->measQuantityUTRA_FDD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measQuantityUTRA_TDD */
   RTXCTXTPUSHELEMNAME (pctxt, "measQuantityUTRA-TDD");

   stat = asn1PD_QuantityConfigUTRA_measQuantityUTRA_TDD (pctxt, &pvalue->measQuantityUTRA_TDD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode filterCoefficient */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "filterCoefficient");

      stat = asn1PD_FilterCoefficient (pctxt, &pvalue->filterCoefficient);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->filterCoefficient = fc4;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_QuantityConfigUTRA (QuantityConfigUTRA* pvalue)
{
   if (0 == pvalue) return;
   pvalue->filterCoefficient = fc4;
}

EXTERN int asn1PE_QuantityConfigGERAN (OSCTXT* pctxt, QuantityConfigGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QuantityConfigGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("QuantityConfigGERAN"));

   stat = rtxEncBit (pctxt, (OSBOOL)(pvalue->filterCoefficient != fc2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measQuantityGERAN */

   RTXCTXTPUSHELEMNAME (pctxt, "measQuantityGERAN");

   stat = asn1PE_QuantityConfigGERAN_measQuantityGERAN (pctxt, pvalue->measQuantityGERAN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode filterCoefficient */

   if (pvalue->filterCoefficient != fc2) {
      RTXCTXTPUSHELEMNAME (pctxt, "filterCoefficient");

      stat = asn1PE_FilterCoefficient (pctxt, pvalue->filterCoefficient);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_QuantityConfigGERAN (OSCTXT* pctxt, QuantityConfigGERAN* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "QuantityConfigGERAN");

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode measQuantityGERAN */
   RTXCTXTPUSHELEMNAME (pctxt, "measQuantityGERAN");

   stat = asn1PD_QuantityConfigGERAN_measQuantityGERAN (pctxt, &pvalue->measQuantityGERAN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode filterCoefficient */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "filterCoefficient");

      stat = asn1PD_FilterCoefficient (pctxt, &pvalue->filterCoefficient);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->filterCoefficient = fc2;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_QuantityConfigGERAN (QuantityConfigGERAN* pvalue)
{
   if (0 == pvalue) return;
   pvalue->filterCoefficient = fc2;
}

EXTERN int asn1PE_QuantityConfigCDMA2000 (OSCTXT* pctxt, QuantityConfigCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QuantityConfigCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("QuantityConfigCDMA2000"));

   /* encode measQuantityCDMA2000 */

   RTXCTXTPUSHELEMNAME (pctxt, "measQuantityCDMA2000");

   stat = asn1PE_QuantityConfigCDMA2000_measQuantityCDMA2000 (pctxt, pvalue->measQuantityCDMA2000);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_QuantityConfigCDMA2000 (OSCTXT* pctxt, QuantityConfigCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QuantityConfigCDMA2000");

   /* decode root elements */
   /* decode measQuantityCDMA2000 */
   RTXCTXTPUSHELEMNAME (pctxt, "measQuantityCDMA2000");

   stat = asn1PD_QuantityConfigCDMA2000_measQuantityCDMA2000 (pctxt, &pvalue->measQuantityCDMA2000);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_QuantityConfig (OSCTXT* pctxt, QuantityConfig* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "QuantityConfig");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("QuantityConfig"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.quantityConfigEUTRAPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.quantityConfigUTRAPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.quantityConfigGERANPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.quantityConfigCDMA2000Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode quantityConfigEUTRA */

   if (pvalue->m.quantityConfigEUTRAPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "quantityConfigEUTRA");

      stat = asn1PE_QuantityConfigEUTRA (pctxt, &pvalue->quantityConfigEUTRA);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode quantityConfigUTRA */

   if (pvalue->m.quantityConfigUTRAPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "quantityConfigUTRA");

      stat = asn1PE_QuantityConfigUTRA (pctxt, &pvalue->quantityConfigUTRA);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode quantityConfigGERAN */

   if (pvalue->m.quantityConfigGERANPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "quantityConfigGERAN");

      stat = asn1PE_QuantityConfigGERAN (pctxt, &pvalue->quantityConfigGERAN);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode quantityConfigCDMA2000 */

   if (pvalue->m.quantityConfigCDMA2000Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "quantityConfigCDMA2000");

      stat = asn1PE_QuantityConfigCDMA2000 (pctxt, &pvalue->quantityConfigCDMA2000);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_QuantityConfig (OSCTXT* pctxt, QuantityConfig* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "QuantityConfig");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode quantityConfigEUTRA */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "quantityConfigEUTRA");

      pvalue->m.quantityConfigEUTRAPresent = 1;

      stat = asn1PD_QuantityConfigEUTRA (pctxt, &pvalue->quantityConfigEUTRA);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode quantityConfigUTRA */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "quantityConfigUTRA");

      pvalue->m.quantityConfigUTRAPresent = 1;

      stat = asn1PD_QuantityConfigUTRA (pctxt, &pvalue->quantityConfigUTRA);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode quantityConfigGERAN */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "quantityConfigGERAN");

      pvalue->m.quantityConfigGERANPresent = 1;

      stat = asn1PD_QuantityConfigGERAN (pctxt, &pvalue->quantityConfigGERAN);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode quantityConfigCDMA2000 */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "quantityConfigCDMA2000");

      pvalue->m.quantityConfigCDMA2000Present = 1;

      stat = asn1PD_QuantityConfigCDMA2000 (pctxt, &pvalue->quantityConfigCDMA2000);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_QuantityConfig (QuantityConfig* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_QuantityConfigEUTRA (&pvalue->quantityConfigEUTRA);
   asn1Init_QuantityConfigUTRA (&pvalue->quantityConfigUTRA);
   asn1Init_QuantityConfigGERAN (&pvalue->quantityConfigGERAN);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_MeasGapConfig_setup_gapOffset (OSCTXT* pctxt, MeasGapConfig_setup_gapOffset* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasGapConfig_setup_gapOffset"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* gp0 */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "gp0");

            if ( (pvalue->u.gp0 <= OSUINTCONST(39)) ) {
               stat = pe_ConsUnsigned (pctxt, pvalue->u.gp0, OSUINTCONST(0), OSUINTCONST(39));
               if (stat != 0) return LOG_RTERR (pctxt, stat);
            }
            else {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddUIntParm (pctxt, pvalue->u.gp0);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* gp1 */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "gp1");

            if ( (pvalue->u.gp1 <= OSUINTCONST(79)) ) {
               stat = pe_ConsUnsigned (pctxt, pvalue->u.gp1, OSUINTCONST(0), OSUINTCONST(79));
               if (stat != 0) return LOG_RTERR (pctxt, stat);
            }
            else {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddUIntParm (pctxt, pvalue->u.gp1);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasGapConfig_setup_gapOffset (OSCTXT* pctxt, MeasGapConfig_setup_gapOffset* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* gp0 */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "gp0");

            stat = pd_ConsUInt8 (pctxt, &pvalue->u.gp0, OSUINTCONST(0), OSUINTCONST(39));
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* gp1 */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "gp1");

            stat = pd_ConsUInt8 (pctxt, &pvalue->u.gp1, OSUINTCONST(0), OSUINTCONST(79));
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

void asn1Init_MeasGapConfig_setup_gapOffset (
   MeasGapConfig_setup_gapOffset* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MeasGapConfig_setup (OSCTXT* pctxt, MeasGapConfig_setup* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasGapConfig_setup"));

   /* encode gapOffset */

   RTXCTXTPUSHELEMNAME (pctxt, "gapOffset");

   stat = asn1PE_MeasGapConfig_setup_gapOffset (pctxt, &pvalue->gapOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasGapConfig_setup (OSCTXT* pctxt, MeasGapConfig_setup* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode gapOffset */
   RTXCTXTPUSHELEMNAME (pctxt, "gapOffset");

   stat = asn1PD_MeasGapConfig_setup_gapOffset (pctxt, &pvalue->gapOffset);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_MeasGapConfig_setup (MeasGapConfig_setup* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_MeasGapConfig_setup_gapOffset (&pvalue->gapOffset);
}

EXTERN int asn1PE_MeasGapConfig (OSCTXT* pctxt, MeasGapConfig* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasGapConfig");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasGapConfig"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_MeasGapConfig_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasGapConfig (OSCTXT* pctxt, MeasGapConfig* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasGapConfig");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         pvalue->u.setup = rtxMemAllocType (pctxt, MeasGapConfig_setup);

         if (pvalue->u.setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MeasGapConfig_setup (pvalue->u.setup);

         stat = asn1PD_MeasGapConfig_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasGapConfig (MeasGapConfig* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MeasConfig_speedStatePars_setup (OSCTXT* pctxt, MeasConfig_speedStatePars_setup* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasConfig_speedStatePars_setup"));

   /* encode mobilityStateParameters */

   RTXCTXTPUSHELEMNAME (pctxt, "mobilityStateParameters");

   stat = asn1PE_MobilityStateParameters (pctxt, &pvalue->mobilityStateParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode timeToTrigger_SF */

   RTXCTXTPUSHELEMNAME (pctxt, "timeToTrigger-SF");

   stat = asn1PE_SpeedStateScaleFactors (pctxt, &pvalue->timeToTrigger_SF);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasConfig_speedStatePars_setup (OSCTXT* pctxt, MeasConfig_speedStatePars_setup* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode mobilityStateParameters */
   RTXCTXTPUSHELEMNAME (pctxt, "mobilityStateParameters");

   stat = asn1PD_MobilityStateParameters (pctxt, &pvalue->mobilityStateParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeToTrigger_SF */
   RTXCTXTPUSHELEMNAME (pctxt, "timeToTrigger-SF");

   stat = asn1PD_SpeedStateScaleFactors (pctxt, &pvalue->timeToTrigger_SF);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_MeasConfig_speedStatePars (OSCTXT* pctxt, MeasConfig_speedStatePars* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasConfig_speedStatePars"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_MeasConfig_speedStatePars_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasConfig_speedStatePars (OSCTXT* pctxt, MeasConfig_speedStatePars* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         pvalue->u.setup = rtxMemAllocTypeZ (pctxt, 
            MeasConfig_speedStatePars_setup);

         if (pvalue->u.setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_MeasConfig_speedStatePars_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_MeasConfig_speedStatePars (MeasConfig_speedStatePars* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MeasConfig (OSCTXT* pctxt, MeasConfig* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasConfig");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasConfig"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measObjectToRemoveListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measObjectToAddModListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.reportConfigToRemoveListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.reportConfigToAddModListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measIdToRemoveListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measIdToAddModListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.quantityConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measGapConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.s_MeasurePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.preRegistrationInfoHRPDPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedStateParsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measObjectToRemoveList */

   if (pvalue->m.measObjectToRemoveListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "measObjectToRemoveList");

      stat = asn1PE_MeasObjectToRemoveList (pctxt, &pvalue->measObjectToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode measObjectToAddModList */

   if (pvalue->m.measObjectToAddModListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "measObjectToAddModList");

      stat = asn1PE_MeasObjectToAddModList (pctxt, &pvalue->measObjectToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode reportConfigToRemoveList */

   if (pvalue->m.reportConfigToRemoveListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "reportConfigToRemoveList");

      stat = asn1PE_ReportConfigToRemoveList (pctxt, &pvalue->reportConfigToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode reportConfigToAddModList */

   if (pvalue->m.reportConfigToAddModListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "reportConfigToAddModList");

      stat = asn1PE_ReportConfigToAddModList (pctxt, &pvalue->reportConfigToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode measIdToRemoveList */

   if (pvalue->m.measIdToRemoveListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "measIdToRemoveList");

      stat = asn1PE_MeasIdToRemoveList (pctxt, &pvalue->measIdToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode measIdToAddModList */

   if (pvalue->m.measIdToAddModListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "measIdToAddModList");

      stat = asn1PE_MeasIdToAddModList (pctxt, &pvalue->measIdToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode quantityConfig */

   if (pvalue->m.quantityConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "quantityConfig");

      stat = asn1PE_QuantityConfig (pctxt, &pvalue->quantityConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode measGapConfig */

   if (pvalue->m.measGapConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "measGapConfig");

      stat = asn1PE_MeasGapConfig (pctxt, &pvalue->measGapConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode s_Measure */

   if (pvalue->m.s_MeasurePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "s-Measure");

      stat = asn1PE_RSRP_Range (pctxt, pvalue->s_Measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode preRegistrationInfoHRPD */

   if (pvalue->m.preRegistrationInfoHRPDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "preRegistrationInfoHRPD");

      stat = asn1PE_PreRegistrationInfoHRPD (pctxt, &pvalue->preRegistrationInfoHRPD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode speedStatePars */

   if (pvalue->m.speedStateParsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "speedStatePars");

      stat = asn1PE_MeasConfig_speedStatePars (pctxt, &pvalue->speedStatePars);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasConfig (OSCTXT* pctxt, MeasConfig* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[11];

   RTXCTXTPUSHTYPENAME (pctxt, "MeasConfig");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 11; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode measObjectToRemoveList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measObjectToRemoveList");

      pvalue->m.measObjectToRemoveListPresent = 1;

      stat = asn1PD_MeasObjectToRemoveList (pctxt, &pvalue->measObjectToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measObjectToAddModList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measObjectToAddModList");

      pvalue->m.measObjectToAddModListPresent = 1;

      stat = asn1PD_MeasObjectToAddModList (pctxt, &pvalue->measObjectToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode reportConfigToRemoveList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "reportConfigToRemoveList");

      pvalue->m.reportConfigToRemoveListPresent = 1;

      stat = asn1PD_ReportConfigToRemoveList (pctxt, &pvalue->reportConfigToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode reportConfigToAddModList */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "reportConfigToAddModList");

      pvalue->m.reportConfigToAddModListPresent = 1;

      stat = asn1PD_ReportConfigToAddModList (pctxt, &pvalue->reportConfigToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measIdToRemoveList */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measIdToRemoveList");

      pvalue->m.measIdToRemoveListPresent = 1;

      stat = asn1PD_MeasIdToRemoveList (pctxt, &pvalue->measIdToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measIdToAddModList */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measIdToAddModList");

      pvalue->m.measIdToAddModListPresent = 1;

      stat = asn1PD_MeasIdToAddModList (pctxt, &pvalue->measIdToAddModList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode quantityConfig */
   if (optbits[6]) {
      RTXCTXTPUSHELEMNAME (pctxt, "quantityConfig");

      pvalue->m.quantityConfigPresent = 1;

      stat = asn1PD_QuantityConfig (pctxt, &pvalue->quantityConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measGapConfig */
   if (optbits[7]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measGapConfig");

      pvalue->m.measGapConfigPresent = 1;

      stat = asn1PD_MeasGapConfig (pctxt, &pvalue->measGapConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode s_Measure */
   if (optbits[8]) {
      RTXCTXTPUSHELEMNAME (pctxt, "s-Measure");

      pvalue->m.s_MeasurePresent = 1;

      stat = asn1PD_RSRP_Range (pctxt, &pvalue->s_Measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode preRegistrationInfoHRPD */
   if (optbits[9]) {
      RTXCTXTPUSHELEMNAME (pctxt, "preRegistrationInfoHRPD");

      pvalue->m.preRegistrationInfoHRPDPresent = 1;

      stat = asn1PD_PreRegistrationInfoHRPD (pctxt, &pvalue->preRegistrationInfoHRPD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode speedStatePars */
   if (optbits[10]) {
      RTXCTXTPUSHELEMNAME (pctxt, "speedStatePars");

      pvalue->m.speedStateParsPresent = 1;

      stat = asn1PD_MeasConfig_speedStatePars (pctxt, &pvalue->speedStatePars);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasConfig (MeasConfig* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_MeasObjectToRemoveList (&pvalue->measObjectToRemoveList);
   asn1Init_MeasObjectToAddModList (&pvalue->measObjectToAddModList);
   asn1Init_ReportConfigToRemoveList (&pvalue->reportConfigToRemoveList);
   asn1Init_ReportConfigToAddModList (&pvalue->reportConfigToAddModList);
   asn1Init_MeasIdToRemoveList (&pvalue->measIdToRemoveList);
   asn1Init_MeasIdToAddModList (&pvalue->measIdToAddModList);
   asn1Init_QuantityConfig (&pvalue->quantityConfig);
   asn1Init_MeasGapConfig (&pvalue->measGapConfig);
   asn1Init_PreRegistrationInfoHRPD (&pvalue->preRegistrationInfoHRPD);
   asn1Init_MeasConfig_speedStatePars (&pvalue->speedStatePars);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_CarrierFreqEUTRA (OSCTXT* pctxt, CarrierFreqEUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierFreqEUTRA"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ul_CarrierFreqPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dl_CarrierFreq */

   RTXCTXTPUSHELEMNAME (pctxt, "dl-CarrierFreq");

   stat = asn1PE_ARFCN_ValueEUTRA (pctxt, pvalue->dl_CarrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ul_CarrierFreq */

   if (pvalue->m.ul_CarrierFreqPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CarrierFreq");

      stat = asn1PE_ARFCN_ValueEUTRA (pctxt, pvalue->ul_CarrierFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierFreqEUTRA (OSCTXT* pctxt, CarrierFreqEUTRA* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierFreqEUTRA");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_CarrierFreq */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-CarrierFreq");

   stat = asn1PD_ARFCN_ValueEUTRA (pctxt, &pvalue->dl_CarrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_CarrierFreq */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-CarrierFreq");

      pvalue->m.ul_CarrierFreqPresent = 1;

      stat = asn1PD_ARFCN_ValueEUTRA (pctxt, &pvalue->ul_CarrierFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CarrierFreqEUTRA (CarrierFreqEUTRA* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_CarrierBandwidthEUTRA (OSCTXT* pctxt, CarrierBandwidthEUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierBandwidthEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CarrierBandwidthEUTRA"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ul_BandwidthPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dl_Bandwidth */

   RTXCTXTPUSHELEMNAME (pctxt, "dl-Bandwidth");

   stat = asn1PE_CarrierBandwidthEUTRA_dl_Bandwidth (pctxt, pvalue->dl_Bandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ul_Bandwidth */

   if (pvalue->m.ul_BandwidthPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-Bandwidth");

      stat = asn1PE_CarrierBandwidthEUTRA_ul_Bandwidth (pctxt, pvalue->ul_Bandwidth);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CarrierBandwidthEUTRA (OSCTXT* pctxt, CarrierBandwidthEUTRA* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CarrierBandwidthEUTRA");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_Bandwidth */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-Bandwidth");

   stat = asn1PD_CarrierBandwidthEUTRA_dl_Bandwidth (pctxt, &pvalue->dl_Bandwidth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ul_Bandwidth */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-Bandwidth");

      pvalue->m.ul_BandwidthPresent = 1;

      stat = asn1PD_CarrierBandwidthEUTRA_ul_Bandwidth (pctxt, &pvalue->ul_Bandwidth);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CarrierBandwidthEUTRA (CarrierBandwidthEUTRA* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_PRACH_Config (OSCTXT* pctxt, PRACH_Config* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PRACH-Config");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PRACH_Config"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.prach_ConfigInfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rootSequenceIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "rootSequenceIndex");

   if ( (pvalue->rootSequenceIndex <= OSUINTCONST(837)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->rootSequenceIndex, OSUINTCONST(0), OSUINTCONST(837));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->rootSequenceIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode prach_ConfigInfo */

   if (pvalue->m.prach_ConfigInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "prach-ConfigInfo");

      stat = asn1PE_PRACH_ConfigInfo (pctxt, &pvalue->prach_ConfigInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PRACH_Config (OSCTXT* pctxt, PRACH_Config* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PRACH-Config");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rootSequenceIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "rootSequenceIndex");

   stat = pd_ConsUInt16 (pctxt, &pvalue->rootSequenceIndex, OSUINTCONST(0), OSUINTCONST(837));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode prach_ConfigInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "prach-ConfigInfo");

      pvalue->m.prach_ConfigInfoPresent = 1;

      stat = asn1PD_PRACH_ConfigInfo (pctxt, &pvalue->prach_ConfigInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PRACH_Config (PRACH_Config* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_AntennaInfoCommon (OSCTXT* pctxt, AntennaInfoCommon* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AntennaInfoCommon");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("AntennaInfoCommon"));

   /* encode antennaPortsCount */

   RTXCTXTPUSHELEMNAME (pctxt, "antennaPortsCount");

   stat = asn1PE_AntennaInfoCommon_antennaPortsCount (pctxt, pvalue->antennaPortsCount);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AntennaInfoCommon (OSCTXT* pctxt, AntennaInfoCommon* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AntennaInfoCommon");

   /* decode root elements */
   /* decode antennaPortsCount */
   RTXCTXTPUSHELEMNAME (pctxt, "antennaPortsCount");

   stat = asn1PD_AntennaInfoCommon_antennaPortsCount (pctxt, &pvalue->antennaPortsCount);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RadioResourceConfigCommon (OSCTXT* pctxt, RadioResourceConfigCommon* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RadioResourceConfigCommon");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RadioResourceConfigCommon"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rach_ConfigCommonPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.pdsch_ConfigCommonPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.phich_ConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.pucch_ConfigCommonPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.soundingRS_UL_ConfigCommonPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uplinkPowerControlCommonPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.antennaInfoCommonPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.p_MaxPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.tdd_ConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rach_ConfigCommon */

   if (pvalue->m.rach_ConfigCommonPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rach-ConfigCommon");

      stat = asn1PE_RACH_ConfigCommon (pctxt, &pvalue->rach_ConfigCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode prach_Config */

   RTXCTXTPUSHELEMNAME (pctxt, "prach-Config");

   stat = asn1PE_PRACH_Config (pctxt, &pvalue->prach_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pdsch_ConfigCommon */

   if (pvalue->m.pdsch_ConfigCommonPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdsch-ConfigCommon");

      stat = asn1PE_PDSCH_ConfigCommon (pctxt, &pvalue->pdsch_ConfigCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode pusch_ConfigCommon */

   RTXCTXTPUSHELEMNAME (pctxt, "pusch-ConfigCommon");

   stat = asn1PE_PUSCH_ConfigCommon (pctxt, &pvalue->pusch_ConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode phich_Config */

   if (pvalue->m.phich_ConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "phich-Config");

      stat = asn1PE_PHICH_Config (pctxt, &pvalue->phich_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode pucch_ConfigCommon */

   if (pvalue->m.pucch_ConfigCommonPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pucch-ConfigCommon");

      stat = asn1PE_PUCCH_ConfigCommon (pctxt, &pvalue->pucch_ConfigCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode soundingRS_UL_ConfigCommon */

   if (pvalue->m.soundingRS_UL_ConfigCommonPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "soundingRS-UL-ConfigCommon");

      stat = asn1PE_SoundingRS_UL_ConfigCommon (pctxt, &pvalue->soundingRS_UL_ConfigCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode uplinkPowerControlCommon */

   if (pvalue->m.uplinkPowerControlCommonPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "uplinkPowerControlCommon");

      stat = asn1PE_UplinkPowerControlCommon (pctxt, &pvalue->uplinkPowerControlCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode antennaInfoCommon */

   if (pvalue->m.antennaInfoCommonPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "antennaInfoCommon");

      stat = asn1PE_AntennaInfoCommon (pctxt, &pvalue->antennaInfoCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode p_Max */

   if (pvalue->m.p_MaxPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "p-Max");

      stat = asn1PE_P_Max (pctxt, pvalue->p_Max);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode tdd_Config */

   if (pvalue->m.tdd_ConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "tdd-Config");

      stat = asn1PE_TDD_Config (pctxt, &pvalue->tdd_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode ul_CyclicPrefixLength */

   RTXCTXTPUSHELEMNAME (pctxt, "ul-CyclicPrefixLength");

   stat = asn1PE_UL_CyclicPrefixLength (pctxt, pvalue->ul_CyclicPrefixLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RadioResourceConfigCommon (OSCTXT* pctxt, RadioResourceConfigCommon* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[9];

   RTXCTXTPUSHTYPENAME (pctxt, "RadioResourceConfigCommon");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 9; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rach_ConfigCommon */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rach-ConfigCommon");

      pvalue->m.rach_ConfigCommonPresent = 1;

      stat = asn1PD_RACH_ConfigCommon (pctxt, &pvalue->rach_ConfigCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode prach_Config */
   RTXCTXTPUSHELEMNAME (pctxt, "prach-Config");

   stat = asn1PD_PRACH_Config (pctxt, &pvalue->prach_Config);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdsch_ConfigCommon */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pdsch-ConfigCommon");

      pvalue->m.pdsch_ConfigCommonPresent = 1;

      stat = asn1PD_PDSCH_ConfigCommon (pctxt, &pvalue->pdsch_ConfigCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pusch_ConfigCommon */
   RTXCTXTPUSHELEMNAME (pctxt, "pusch-ConfigCommon");

   stat = asn1PD_PUSCH_ConfigCommon (pctxt, &pvalue->pusch_ConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode phich_Config */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "phich-Config");

      pvalue->m.phich_ConfigPresent = 1;

      stat = asn1PD_PHICH_Config (pctxt, &pvalue->phich_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pucch_ConfigCommon */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pucch-ConfigCommon");

      pvalue->m.pucch_ConfigCommonPresent = 1;

      stat = asn1PD_PUCCH_ConfigCommon (pctxt, &pvalue->pucch_ConfigCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode soundingRS_UL_ConfigCommon */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "soundingRS-UL-ConfigCommon");

      pvalue->m.soundingRS_UL_ConfigCommonPresent = 1;

      stat = asn1PD_SoundingRS_UL_ConfigCommon (pctxt, &pvalue->soundingRS_UL_ConfigCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uplinkPowerControlCommon */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uplinkPowerControlCommon");

      pvalue->m.uplinkPowerControlCommonPresent = 1;

      stat = asn1PD_UplinkPowerControlCommon (pctxt, &pvalue->uplinkPowerControlCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode antennaInfoCommon */
   if (optbits[6]) {
      RTXCTXTPUSHELEMNAME (pctxt, "antennaInfoCommon");

      pvalue->m.antennaInfoCommonPresent = 1;

      stat = asn1PD_AntennaInfoCommon (pctxt, &pvalue->antennaInfoCommon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode p_Max */
   if (optbits[7]) {
      RTXCTXTPUSHELEMNAME (pctxt, "p-Max");

      pvalue->m.p_MaxPresent = 1;

      stat = asn1PD_P_Max (pctxt, &pvalue->p_Max);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tdd_Config */
   if (optbits[8]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tdd-Config");

      pvalue->m.tdd_ConfigPresent = 1;

      stat = asn1PD_TDD_Config (pctxt, &pvalue->tdd_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_CyclicPrefixLength */
   RTXCTXTPUSHELEMNAME (pctxt, "ul-CyclicPrefixLength");

   stat = asn1PD_UL_CyclicPrefixLength (pctxt, &pvalue->ul_CyclicPrefixLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RadioResourceConfigCommon (RadioResourceConfigCommon* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RACH_ConfigCommon (&pvalue->rach_ConfigCommon);
   asn1Init_PRACH_Config (&pvalue->prach_Config);
   asn1Init_SoundingRS_UL_ConfigCommon (&pvalue->soundingRS_UL_ConfigCommon);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_RACH_ConfigDedicated (OSCTXT* pctxt, RACH_ConfigDedicated* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RACH-ConfigDedicated");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RACH_ConfigDedicated"));

   /* encode ra_PreambleIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "ra-PreambleIndex");

   if ( (pvalue->ra_PreambleIndex <= OSUINTCONST(63)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ra_PreambleIndex, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ra_PreambleIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ra_PRACH_MaskIndex */

   RTXCTXTPUSHELEMNAME (pctxt, "ra-PRACH-MaskIndex");

   if ( (pvalue->ra_PRACH_MaskIndex <= OSUINTCONST(15)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ra_PRACH_MaskIndex, OSUINTCONST(0), OSUINTCONST(15));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ra_PRACH_MaskIndex);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RACH_ConfigDedicated (OSCTXT* pctxt, RACH_ConfigDedicated* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RACH-ConfigDedicated");

   /* decode root elements */
   /* decode ra_PreambleIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "ra-PreambleIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ra_PreambleIndex, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ra_PRACH_MaskIndex */
   RTXCTXTPUSHELEMNAME (pctxt, "ra-PRACH-MaskIndex");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ra_PRACH_MaskIndex, OSUINTCONST(0), OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_MobilityControlInfo (OSCTXT* pctxt, MobilityControlInfo* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityControlInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MobilityControlInfo"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.carrierFreqPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.carrierBandwidthPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.additionalSpectrumEmissionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rach_ConfigDedicatedPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode targetPhysCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "targetPhysCellId");

   stat = asn1PE_PhysCellId (pctxt, pvalue->targetPhysCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode carrierFreq */

   if (pvalue->m.carrierFreqPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

      stat = asn1PE_CarrierFreqEUTRA (pctxt, &pvalue->carrierFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode carrierBandwidth */

   if (pvalue->m.carrierBandwidthPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "carrierBandwidth");

      stat = asn1PE_CarrierBandwidthEUTRA (pctxt, &pvalue->carrierBandwidth);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode additionalSpectrumEmission */

   if (pvalue->m.additionalSpectrumEmissionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalSpectrumEmission");

      stat = asn1PE_AdditionalSpectrumEmission (pctxt, pvalue->additionalSpectrumEmission);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode t304 */

   RTXCTXTPUSHELEMNAME (pctxt, "t304");

   stat = asn1PE_MobilityControlInfo_t304 (pctxt, pvalue->t304);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode newUE_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "newUE-Identity");

   stat = asn1PE_C_RNTI (pctxt, pvalue->newUE_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode radioResourceConfigCommon */

   RTXCTXTPUSHELEMNAME (pctxt, "radioResourceConfigCommon");

   stat = asn1PE_RadioResourceConfigCommon (pctxt, &pvalue->radioResourceConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rach_ConfigDedicated */

   if (pvalue->m.rach_ConfigDedicatedPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rach-ConfigDedicated");

      stat = asn1PE_RACH_ConfigDedicated (pctxt, &pvalue->rach_ConfigDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityControlInfo (OSCTXT* pctxt, MobilityControlInfo* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityControlInfo");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode targetPhysCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "targetPhysCellId");

   stat = asn1PD_PhysCellId (pctxt, &pvalue->targetPhysCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode carrierFreq */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

      pvalue->m.carrierFreqPresent = 1;

      stat = asn1PD_CarrierFreqEUTRA (pctxt, &pvalue->carrierFreq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode carrierBandwidth */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "carrierBandwidth");

      pvalue->m.carrierBandwidthPresent = 1;

      stat = asn1PD_CarrierBandwidthEUTRA (pctxt, &pvalue->carrierBandwidth);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode additionalSpectrumEmission */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalSpectrumEmission");

      pvalue->m.additionalSpectrumEmissionPresent = 1;

      stat = asn1PD_AdditionalSpectrumEmission (pctxt, &pvalue->additionalSpectrumEmission);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode t304 */
   RTXCTXTPUSHELEMNAME (pctxt, "t304");

   stat = asn1PD_MobilityControlInfo_t304 (pctxt, &pvalue->t304);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode newUE_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "newUE-Identity");

   stat = asn1PD_C_RNTI (pctxt, &pvalue->newUE_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode radioResourceConfigCommon */
   RTXCTXTPUSHELEMNAME (pctxt, "radioResourceConfigCommon");

   stat = asn1PD_RadioResourceConfigCommon (pctxt, &pvalue->radioResourceConfigCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rach_ConfigDedicated */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rach-ConfigDedicated");

      pvalue->m.rach_ConfigDedicatedPresent = 1;

      stat = asn1PD_RACH_ConfigDedicated (pctxt, &pvalue->rach_ConfigDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MobilityControlInfo (MobilityControlInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CarrierFreqEUTRA (&pvalue->carrierFreq);
   asn1Init_CarrierBandwidthEUTRA (&pvalue->carrierBandwidth);
   asn1Init_C_RNTI (&pvalue->newUE_Identity);
   asn1Init_RadioResourceConfigCommon (&pvalue->radioResourceConfigCommon);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_RRCConnectionReconfiguration_r8_IEs_dedicatedInfoNASList (OSCTXT* pctxt, RRCConnectionReconfiguration_r8_IEs_dedicatedInfoNASList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfiguration_r8_IEs_dedicatedInfoNASList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(11), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DedicatedInfoNAS", xx1);

      stat = asn1PE_DedicatedInfoNAS (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfiguration_r8_IEs_dedicatedInfoNASList (OSCTXT* pctxt, RRCConnectionReconfiguration_r8_IEs_dedicatedInfoNASList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 11) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DedicatedInfoNAS", xx1);

      asn1Init_DedicatedInfoNAS (&pvalue->elem[xx1]);

      stat = asn1PD_DedicatedInfoNAS (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_RRCConnectionReconfiguration_r8_IEs_dedicatedInfoNASList (
   RRCConnectionReconfiguration_r8_IEs_dedicatedInfoNASList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_SecurityAlgorithmConfig (OSCTXT* pctxt, SecurityAlgorithmConfig* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityAlgorithmConfig");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityAlgorithmConfig"));

   /* encode cipheringAlgorithm */

   RTXCTXTPUSHELEMNAME (pctxt, "cipheringAlgorithm");

   stat = asn1PE_SecurityAlgorithmConfig_cipheringAlgorithm (pctxt, pvalue->cipheringAlgorithm);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode integrityProtAlgorithm */

   RTXCTXTPUSHELEMNAME (pctxt, "integrityProtAlgorithm");

   stat = asn1PE_SecurityAlgorithmConfig_integrityProtAlgorithm (pctxt, pvalue->integrityProtAlgorithm);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityAlgorithmConfig (OSCTXT* pctxt, SecurityAlgorithmConfig* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityAlgorithmConfig");

   /* decode root elements */
   /* decode cipheringAlgorithm */
   RTXCTXTPUSHELEMNAME (pctxt, "cipheringAlgorithm");

   stat = asn1PD_SecurityAlgorithmConfig_cipheringAlgorithm (pctxt, &pvalue->cipheringAlgorithm);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode integrityProtAlgorithm */
   RTXCTXTPUSHELEMNAME (pctxt, "integrityProtAlgorithm");

   stat = asn1PD_SecurityAlgorithmConfig_integrityProtAlgorithm (pctxt, &pvalue->integrityProtAlgorithm);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SecurityConfigHO_handoverType_intraLTE (OSCTXT* pctxt, SecurityConfigHO_handoverType_intraLTE* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityConfigHO_handoverType_intraLTE"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.securityAlgorithmConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode securityAlgorithmConfig */

   if (pvalue->m.securityAlgorithmConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "securityAlgorithmConfig");

      stat = asn1PE_SecurityAlgorithmConfig (pctxt, &pvalue->securityAlgorithmConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode keyChangeIndicator */

   RTXCTXTPUSHELEMNAME (pctxt, "keyChangeIndicator");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->keyChangeIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nextHopChainingCount */

   RTXCTXTPUSHELEMNAME (pctxt, "nextHopChainingCount");

   stat = asn1PE_NextHopChainingCount (pctxt, pvalue->nextHopChainingCount);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityConfigHO_handoverType_intraLTE (OSCTXT* pctxt, SecurityConfigHO_handoverType_intraLTE* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode securityAlgorithmConfig */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "securityAlgorithmConfig");

      pvalue->m.securityAlgorithmConfigPresent = 1;

      stat = asn1PD_SecurityAlgorithmConfig (pctxt, &pvalue->securityAlgorithmConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode keyChangeIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "keyChangeIndicator");

   stat = DEC_BIT (pctxt, &pvalue->keyChangeIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nextHopChainingCount */
   RTXCTXTPUSHELEMNAME (pctxt, "nextHopChainingCount");

   stat = asn1PD_NextHopChainingCount (pctxt, &pvalue->nextHopChainingCount);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_SecurityConfigHO_handoverType_intraLTE (
   SecurityConfigHO_handoverType_intraLTE* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_SecurityConfigHO_handoverType_interRAT (OSCTXT* pctxt, SecurityConfigHO_handoverType_interRAT* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityConfigHO_handoverType_interRAT"));

   /* encode securityAlgorithmConfig */

   RTXCTXTPUSHELEMNAME (pctxt, "securityAlgorithmConfig");

   stat = asn1PE_SecurityAlgorithmConfig (pctxt, &pvalue->securityAlgorithmConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nas_SecurityParamToEUTRA */

   RTXCTXTPUSHELEMNAME (pctxt, "nas-SecurityParamToEUTRA");

   stat = asn1PE_SecurityConfigHO_handoverType_interRAT_nas_SecurityParamToEUTRA (pctxt, &pvalue->nas_SecurityParamToEUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityConfigHO_handoverType_interRAT (OSCTXT* pctxt, SecurityConfigHO_handoverType_interRAT* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode securityAlgorithmConfig */
   RTXCTXTPUSHELEMNAME (pctxt, "securityAlgorithmConfig");

   stat = asn1PD_SecurityAlgorithmConfig (pctxt, &pvalue->securityAlgorithmConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nas_SecurityParamToEUTRA */
   RTXCTXTPUSHELEMNAME (pctxt, "nas-SecurityParamToEUTRA");

   stat = asn1PD_SecurityConfigHO_handoverType_interRAT_nas_SecurityParamToEUTRA (pctxt, &pvalue->nas_SecurityParamToEUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_SecurityConfigHO_handoverType_interRAT (
   SecurityConfigHO_handoverType_interRAT* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SecurityConfigHO_handoverType_interRAT_nas_SecurityParamToEUTRA (&pvalue->nas_SecurityParamToEUTRA);
}

EXTERN int asn1PE_SecurityConfigHO_handoverType (OSCTXT* pctxt, SecurityConfigHO_handoverType* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityConfigHO_handoverType"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* intraLTE */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "intraLTE");

         stat = asn1PE_SecurityConfigHO_handoverType_intraLTE (pctxt, pvalue->u.intraLTE);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* interRAT */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "interRAT");

         stat = asn1PE_SecurityConfigHO_handoverType_interRAT (pctxt, pvalue->u.interRAT);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityConfigHO_handoverType (OSCTXT* pctxt, SecurityConfigHO_handoverType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* intraLTE */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "intraLTE");

         pvalue->u.intraLTE = rtxMemAllocType (pctxt, 
            SecurityConfigHO_handoverType_intraLTE);

         if (pvalue->u.intraLTE == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SecurityConfigHO_handoverType_intraLTE (pvalue->u.intraLTE);

         stat = asn1PD_SecurityConfigHO_handoverType_intraLTE (pctxt, pvalue->u.intraLTE);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* interRAT */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "interRAT");

         pvalue->u.interRAT = rtxMemAllocType (pctxt, 
            SecurityConfigHO_handoverType_interRAT);

         if (pvalue->u.interRAT == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SecurityConfigHO_handoverType_interRAT (pvalue->u.interRAT);

         stat = asn1PD_SecurityConfigHO_handoverType_interRAT (pctxt, pvalue->u.interRAT);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_SecurityConfigHO_handoverType (
   SecurityConfigHO_handoverType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_SecurityConfigHO (OSCTXT* pctxt, SecurityConfigHO* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityConfigHO");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityConfigHO"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode handoverType */

   RTXCTXTPUSHELEMNAME (pctxt, "handoverType");

   stat = asn1PE_SecurityConfigHO_handoverType (pctxt, &pvalue->handoverType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityConfigHO (OSCTXT* pctxt, SecurityConfigHO* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityConfigHO");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode handoverType */
   RTXCTXTPUSHELEMNAME (pctxt, "handoverType");

   stat = asn1PD_SecurityConfigHO_handoverType (pctxt, &pvalue->handoverType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SecurityConfigHO (SecurityConfigHO* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SecurityConfigHO_handoverType (&pvalue->handoverType);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_ReportProximityConfig_r9 (OSCTXT* pctxt, ReportProximityConfig_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportProximityConfig-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReportProximityConfig_r9"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.proximityIndicationEUTRA_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.proximityIndicationUTRA_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode proximityIndicationEUTRA_r9 */

   if (pvalue->m.proximityIndicationEUTRA_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "proximityIndicationEUTRA-r9");

      stat = asn1PE_ReportProximityConfig_r9_proximityIndicationEUTRA_r9 (pctxt, pvalue->proximityIndicationEUTRA_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode proximityIndicationUTRA_r9 */

   if (pvalue->m.proximityIndicationUTRA_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "proximityIndicationUTRA-r9");

      stat = asn1PE_ReportProximityConfig_r9_proximityIndicationUTRA_r9 (pctxt, pvalue->proximityIndicationUTRA_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportProximityConfig_r9 (OSCTXT* pctxt, ReportProximityConfig_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "ReportProximityConfig-r9");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode proximityIndicationEUTRA_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "proximityIndicationEUTRA-r9");

      pvalue->m.proximityIndicationEUTRA_r9Present = 1;

      stat = asn1PD_ReportProximityConfig_r9_proximityIndicationEUTRA_r9 (pctxt, &pvalue->proximityIndicationEUTRA_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode proximityIndicationUTRA_r9 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "proximityIndicationUTRA-r9");

      pvalue->m.proximityIndicationUTRA_r9Present = 1;

      stat = asn1PD_ReportProximityConfig_r9_proximityIndicationUTRA_r9 (pctxt, &pvalue->proximityIndicationUTRA_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ReportProximityConfig_r9 (ReportProximityConfig_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_OtherConfig_r9 (OSCTXT* pctxt, OtherConfig_r9* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OtherConfig-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("OtherConfig_r9"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.reportProximityConfig_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode reportProximityConfig_r9 */

   if (pvalue->m.reportProximityConfig_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "reportProximityConfig-r9");

      stat = asn1PE_ReportProximityConfig_r9 (pctxt, &pvalue->reportProximityConfig_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_OtherConfig_r9 (OSCTXT* pctxt, OtherConfig_r9* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "OtherConfig-r9");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode reportProximityConfig_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "reportProximityConfig-r9");

      pvalue->m.reportProximityConfig_r9Present = 1;

      stat = asn1PD_ReportProximityConfig_r9 (pctxt, &pvalue->reportProximityConfig_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_OtherConfig_r9 (OtherConfig_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ReportProximityConfig_r9 (&pvalue->reportProximityConfig_r9);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_RRCConnectionReconfiguration_v920_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionReconfiguration_v920_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfiguration_v920_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfiguration_v920_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionReconfiguration_v920_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionReconfiguration_v920_IEs (OSCTXT* pctxt, RRCConnectionReconfiguration_v920_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReconfiguration-v920-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfiguration_v920_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.otherConfig_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.fullConfig_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode otherConfig_r9 */

   if (pvalue->m.otherConfig_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "otherConfig-r9");

      stat = asn1PE_OtherConfig_r9 (pctxt, &pvalue->otherConfig_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode fullConfig_r9 */

   if (pvalue->m.fullConfig_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "fullConfig-r9");

      stat = asn1PE_RRCConnectionReconfiguration_v920_IEs_fullConfig_r9 (pctxt, pvalue->fullConfig_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionReconfiguration_v920_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfiguration_v920_IEs (OSCTXT* pctxt, RRCConnectionReconfiguration_v920_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReconfiguration-v920-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode otherConfig_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "otherConfig-r9");

      pvalue->m.otherConfig_r9Present = 1;

      stat = asn1PD_OtherConfig_r9 (pctxt, &pvalue->otherConfig_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode fullConfig_r9 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "fullConfig-r9");

      pvalue->m.fullConfig_r9Present = 1;

      stat = asn1PD_RRCConnectionReconfiguration_v920_IEs_fullConfig_r9 (pctxt, &pvalue->fullConfig_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionReconfiguration_v920_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReconfiguration_v920_IEs (
   RRCConnectionReconfiguration_v920_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_OtherConfig_r9 (&pvalue->otherConfig_r9);
}

EXTERN int asn1PE_RRCConnectionReconfiguration_v890_IEs (OSCTXT* pctxt, RRCConnectionReconfiguration_v890_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReconfiguration-v890-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfiguration_v890_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionReconfiguration_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfiguration_v890_IEs (OSCTXT* pctxt, RRCConnectionReconfiguration_v890_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReconfiguration-v890-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionReconfiguration_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReconfiguration_v890_IEs (
   RRCConnectionReconfiguration_v890_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   asn1Init_RRCConnectionReconfiguration_v920_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_RRCConnectionReconfiguration_r8_IEs (OSCTXT* pctxt, RRCConnectionReconfiguration_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReconfiguration-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfiguration_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.mobilityControlInfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dedicatedInfoNASListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.radioResourceConfigDedicatedPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.securityConfigHOPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measConfig */

   if (pvalue->m.measConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "measConfig");

      stat = asn1PE_MeasConfig (pctxt, &pvalue->measConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode mobilityControlInfo */

   if (pvalue->m.mobilityControlInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "mobilityControlInfo");

      stat = asn1PE_MobilityControlInfo (pctxt, &pvalue->mobilityControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode dedicatedInfoNASList */

   if (pvalue->m.dedicatedInfoNASListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoNASList");

      stat = asn1PE_RRCConnectionReconfiguration_r8_IEs_dedicatedInfoNASList (pctxt, &pvalue->dedicatedInfoNASList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode radioResourceConfigDedicated */

   if (pvalue->m.radioResourceConfigDedicatedPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "radioResourceConfigDedicated");

      stat = asn1PE_RadioResourceConfigDedicated (pctxt, &pvalue->radioResourceConfigDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode securityConfigHO */

   if (pvalue->m.securityConfigHOPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "securityConfigHO");

      stat = asn1PE_SecurityConfigHO (pctxt, &pvalue->securityConfigHO);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionReconfiguration_v890_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfiguration_r8_IEs (OSCTXT* pctxt, RRCConnectionReconfiguration_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[6];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReconfiguration-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode measConfig */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measConfig");

      pvalue->m.measConfigPresent = 1;

      stat = asn1PD_MeasConfig (pctxt, &pvalue->measConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mobilityControlInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mobilityControlInfo");

      pvalue->m.mobilityControlInfoPresent = 1;

      stat = asn1PD_MobilityControlInfo (pctxt, &pvalue->mobilityControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dedicatedInfoNASList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoNASList");

      pvalue->m.dedicatedInfoNASListPresent = 1;

      stat = asn1PD_RRCConnectionReconfiguration_r8_IEs_dedicatedInfoNASList (pctxt, &pvalue->dedicatedInfoNASList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode radioResourceConfigDedicated */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "radioResourceConfigDedicated");

      pvalue->m.radioResourceConfigDedicatedPresent = 1;

      stat = asn1PD_RadioResourceConfigDedicated (pctxt, &pvalue->radioResourceConfigDedicated);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode securityConfigHO */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "securityConfigHO");

      pvalue->m.securityConfigHOPresent = 1;

      stat = asn1PD_SecurityConfigHO (pctxt, &pvalue->securityConfigHO);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionReconfiguration_v890_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReconfiguration_r8_IEs (
   RRCConnectionReconfiguration_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_MeasConfig (&pvalue->measConfig);
   asn1Init_MobilityControlInfo (&pvalue->mobilityControlInfo);
   asn1Init_RRCConnectionReconfiguration_r8_IEs_dedicatedInfoNASList (&pvalue->dedicatedInfoNASList);
   asn1Init_RadioResourceConfigDedicated (&pvalue->radioResourceConfigDedicated);
   asn1Init_SecurityConfigHO (&pvalue->securityConfigHO);
   asn1Init_RRCConnectionReconfiguration_v890_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_RRCConnectionReconfiguration_criticalExtensions_c1 (OSCTXT* pctxt, RRCConnectionReconfiguration_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfiguration_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* rrcConnectionReconfiguration_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReconfiguration-r8");

         stat = asn1PE_RRCConnectionReconfiguration_r8_IEs (pctxt, pvalue->u.rrcConnectionReconfiguration_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare7 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare6 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare5 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare4 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfiguration_criticalExtensions_c1 (OSCTXT* pctxt, RRCConnectionReconfiguration_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rrcConnectionReconfiguration_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReconfiguration-r8");

         pvalue->u.rrcConnectionReconfiguration_r8 = rtxMemAllocType (pctxt, 
            RRCConnectionReconfiguration_r8_IEs);

         if (pvalue->u.rrcConnectionReconfiguration_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReconfiguration_r8_IEs (pvalue->u.rrcConnectionReconfiguration_r8);

         stat = asn1PD_RRCConnectionReconfiguration_r8_IEs (pctxt, pvalue->u.rrcConnectionReconfiguration_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare7 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare6 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare5 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare4 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionReconfiguration_criticalExtensions_c1 (
   RRCConnectionReconfiguration_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionReconfiguration_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionReconfiguration_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfiguration_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfiguration_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionReconfiguration_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionReconfiguration_criticalExtensions (OSCTXT* pctxt, RRCConnectionReconfiguration_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfiguration_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_RRCConnectionReconfiguration_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_RRCConnectionReconfiguration_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfiguration_criticalExtensions (OSCTXT* pctxt, RRCConnectionReconfiguration_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            RRCConnectionReconfiguration_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReconfiguration_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_RRCConnectionReconfiguration_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            RRCConnectionReconfiguration_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_RRCConnectionReconfiguration_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionReconfiguration_criticalExtensions (
   RRCConnectionReconfiguration_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionReconfiguration (OSCTXT* pctxt, RRCConnectionReconfiguration* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReconfiguration");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfiguration"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_RRCConnectionReconfiguration_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfiguration (OSCTXT* pctxt, RRCConnectionReconfiguration* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReconfiguration");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_RRCConnectionReconfiguration_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReconfiguration (
   RRCConnectionReconfiguration* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_RRCConnectionReconfiguration_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_RedirectedCarrierInfo (OSCTXT* pctxt, RedirectedCarrierInfo* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RedirectedCarrierInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RedirectedCarrierInfo"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 6);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* eutra */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "eutra");

            stat = asn1PE_ARFCN_ValueEUTRA (pctxt, pvalue->u.eutra);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* geran */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "geran");

            stat = asn1PE_CarrierFreqsGERAN (pctxt, pvalue->u.geran);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* utra_FDD */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "utra-FDD");

            stat = asn1PE_ARFCN_ValueUTRA (pctxt, pvalue->u.utra_FDD);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* utra_TDD */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "utra-TDD");

            stat = asn1PE_ARFCN_ValueUTRA (pctxt, pvalue->u.utra_TDD);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* cdma2000_HRPD */
         case 5:
            RTXCTXTPUSHELEMNAME (pctxt, "cdma2000-HRPD");

            stat = asn1PE_CarrierFreqCDMA2000 (pctxt, pvalue->u.cdma2000_HRPD);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* cdma2000_1xRTT */
         case 6:
            RTXCTXTPUSHELEMNAME (pctxt, "cdma2000-1xRTT");

            stat = asn1PE_CarrierFreqCDMA2000 (pctxt, pvalue->u.cdma2000_1xRTT);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 7);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RedirectedCarrierInfo (OSCTXT* pctxt, RedirectedCarrierInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "RedirectedCarrierInfo");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* eutra */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "eutra");

            stat = asn1PD_ARFCN_ValueEUTRA (pctxt, &pvalue->u.eutra);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* geran */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "geran");

            pvalue->u.geran = rtxMemAllocType (pctxt, CarrierFreqsGERAN);

            if (pvalue->u.geran == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CarrierFreqsGERAN (pvalue->u.geran);

            stat = asn1PD_CarrierFreqsGERAN (pctxt, pvalue->u.geran);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* utra_FDD */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "utra-FDD");

            stat = asn1PD_ARFCN_ValueUTRA (pctxt, &pvalue->u.utra_FDD);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* utra_TDD */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "utra-TDD");

            stat = asn1PD_ARFCN_ValueUTRA (pctxt, &pvalue->u.utra_TDD);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* cdma2000_HRPD */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "cdma2000-HRPD");

            pvalue->u.cdma2000_HRPD = rtxMemAllocTypeZ (pctxt, 
               CarrierFreqCDMA2000);

            if (pvalue->u.cdma2000_HRPD == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            stat = asn1PD_CarrierFreqCDMA2000 (pctxt, pvalue->u.cdma2000_HRPD);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* cdma2000_1xRTT */
         case 5:
            RTXCTXTPUSHELEMNAME (pctxt, "cdma2000-1xRTT");

            pvalue->u.cdma2000_1xRTT = rtxMemAllocTypeZ (pctxt, 
               CarrierFreqCDMA2000);

            if (pvalue->u.cdma2000_1xRTT == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            stat = asn1PD_CarrierFreqCDMA2000 (pctxt, pvalue->u.cdma2000_1xRTT);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 7;

      if (pvalue->t < 7) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RedirectedCarrierInfo (RedirectedCarrierInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_FreqPriorityEUTRA (OSCTXT* pctxt, FreqPriorityEUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqPriorityEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("FreqPriorityEUTRA"));

   /* encode carrierFreq */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PE_ARFCN_ValueEUTRA (pctxt, pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellReselectionPriority */

   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

   stat = asn1PE_CellReselectionPriority (pctxt, pvalue->cellReselectionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_FreqPriorityEUTRA (OSCTXT* pctxt, FreqPriorityEUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqPriorityEUTRA");

   /* decode root elements */
   /* decode carrierFreq */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PD_ARFCN_ValueEUTRA (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellReselectionPriority */
   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

   stat = asn1PD_CellReselectionPriority (pctxt, &pvalue->cellReselectionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_FreqPriorityListEUTRA (OSCTXT* pctxt, FreqPriorityListEUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqPriorityListEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("FreqPriorityListEUTRA"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "FreqPriorityEUTRA", xx1);

      stat = asn1PE_FreqPriorityEUTRA (pctxt, ((FreqPriorityEUTRA*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_FreqPriorityListEUTRA (OSCTXT* pctxt, FreqPriorityListEUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqPriorityListEUTRA");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      FreqPriorityEUTRA* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "FreqPriorityEUTRA", xx1);

      rtxDListAllocNodeAndData (pctxt, FreqPriorityEUTRA, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_FreqPriorityEUTRA (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_FreqPriorityListEUTRA (FreqPriorityListEUTRA* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_FreqsPriorityGERAN (OSCTXT* pctxt, FreqsPriorityGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqsPriorityGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("FreqsPriorityGERAN"));

   /* encode carrierFreqs */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreqs");

   stat = asn1PE_CarrierFreqsGERAN (pctxt, &pvalue->carrierFreqs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellReselectionPriority */

   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

   stat = asn1PE_CellReselectionPriority (pctxt, pvalue->cellReselectionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_FreqsPriorityGERAN (OSCTXT* pctxt, FreqsPriorityGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqsPriorityGERAN");

   /* decode root elements */
   /* decode carrierFreqs */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreqs");

   stat = asn1PD_CarrierFreqsGERAN (pctxt, &pvalue->carrierFreqs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellReselectionPriority */
   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

   stat = asn1PD_CellReselectionPriority (pctxt, &pvalue->cellReselectionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_FreqsPriorityGERAN (FreqsPriorityGERAN* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_CarrierFreqsGERAN (&pvalue->carrierFreqs);
}

EXTERN int asn1PE_FreqsPriorityListGERAN (OSCTXT* pctxt, FreqsPriorityListGERAN* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqsPriorityListGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("FreqsPriorityListGERAN"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "FreqsPriorityGERAN", xx1);

      stat = asn1PE_FreqsPriorityGERAN (pctxt, ((FreqsPriorityGERAN*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_FreqsPriorityListGERAN (OSCTXT* pctxt, FreqsPriorityListGERAN* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqsPriorityListGERAN");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      FreqsPriorityGERAN* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "FreqsPriorityGERAN", xx1);

      rtxDListAllocNodeAndData (pctxt, FreqsPriorityGERAN, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FreqsPriorityGERAN (pdata);

      stat = asn1PD_FreqsPriorityGERAN (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_FreqsPriorityListGERAN (FreqsPriorityListGERAN* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_FreqPriorityUTRA_FDD (OSCTXT* pctxt, FreqPriorityUTRA_FDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqPriorityUTRA-FDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("FreqPriorityUTRA_FDD"));

   /* encode carrierFreq */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PE_ARFCN_ValueUTRA (pctxt, pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellReselectionPriority */

   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

   stat = asn1PE_CellReselectionPriority (pctxt, pvalue->cellReselectionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_FreqPriorityUTRA_FDD (OSCTXT* pctxt, FreqPriorityUTRA_FDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqPriorityUTRA-FDD");

   /* decode root elements */
   /* decode carrierFreq */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PD_ARFCN_ValueUTRA (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellReselectionPriority */
   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

   stat = asn1PD_CellReselectionPriority (pctxt, &pvalue->cellReselectionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_FreqPriorityListUTRA_FDD (OSCTXT* pctxt, FreqPriorityListUTRA_FDD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqPriorityListUTRA-FDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("FreqPriorityListUTRA_FDD"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "FreqPriorityUTRA-FDD", xx1);

      stat = asn1PE_FreqPriorityUTRA_FDD (pctxt, ((FreqPriorityUTRA_FDD*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_FreqPriorityListUTRA_FDD (OSCTXT* pctxt, FreqPriorityListUTRA_FDD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqPriorityListUTRA-FDD");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      FreqPriorityUTRA_FDD* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "FreqPriorityUTRA-FDD", xx1);

      rtxDListAllocNodeAndData (pctxt, FreqPriorityUTRA_FDD, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_FreqPriorityUTRA_FDD (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_FreqPriorityListUTRA_FDD (FreqPriorityListUTRA_FDD* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_FreqPriorityUTRA_TDD (OSCTXT* pctxt, FreqPriorityUTRA_TDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqPriorityUTRA-TDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("FreqPriorityUTRA_TDD"));

   /* encode carrierFreq */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PE_ARFCN_ValueUTRA (pctxt, pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellReselectionPriority */

   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

   stat = asn1PE_CellReselectionPriority (pctxt, pvalue->cellReselectionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_FreqPriorityUTRA_TDD (OSCTXT* pctxt, FreqPriorityUTRA_TDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqPriorityUTRA-TDD");

   /* decode root elements */
   /* decode carrierFreq */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PD_ARFCN_ValueUTRA (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellReselectionPriority */
   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

   stat = asn1PD_CellReselectionPriority (pctxt, &pvalue->cellReselectionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_FreqPriorityListUTRA_TDD (OSCTXT* pctxt, FreqPriorityListUTRA_TDD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqPriorityListUTRA-TDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("FreqPriorityListUTRA_TDD"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "FreqPriorityUTRA-TDD", xx1);

      stat = asn1PE_FreqPriorityUTRA_TDD (pctxt, ((FreqPriorityUTRA_TDD*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_FreqPriorityListUTRA_TDD (OSCTXT* pctxt, FreqPriorityListUTRA_TDD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FreqPriorityListUTRA-TDD");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      FreqPriorityUTRA_TDD* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "FreqPriorityUTRA-TDD", xx1);

      rtxDListAllocNodeAndData (pctxt, FreqPriorityUTRA_TDD, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_FreqPriorityUTRA_TDD (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_FreqPriorityListUTRA_TDD (FreqPriorityListUTRA_TDD* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_BandClassPriorityHRPD (OSCTXT* pctxt, BandClassPriorityHRPD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BandClassPriorityHRPD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BandClassPriorityHRPD"));

   /* encode bandClass */

   RTXCTXTPUSHELEMNAME (pctxt, "bandClass");

   stat = asn1PE_BandclassCDMA2000 (pctxt, pvalue->bandClass);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellReselectionPriority */

   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

   stat = asn1PE_CellReselectionPriority (pctxt, pvalue->cellReselectionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BandClassPriorityHRPD (OSCTXT* pctxt, BandClassPriorityHRPD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BandClassPriorityHRPD");

   /* decode root elements */
   /* decode bandClass */
   RTXCTXTPUSHELEMNAME (pctxt, "bandClass");

   stat = asn1PD_BandclassCDMA2000 (pctxt, &pvalue->bandClass);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellReselectionPriority */
   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

   stat = asn1PD_CellReselectionPriority (pctxt, &pvalue->cellReselectionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_BandClassPriorityListHRPD (OSCTXT* pctxt, BandClassPriorityListHRPD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "BandClassPriorityListHRPD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BandClassPriorityListHRPD"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BandClassPriorityHRPD", xx1);

      stat = asn1PE_BandClassPriorityHRPD (pctxt, ((BandClassPriorityHRPD*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BandClassPriorityListHRPD (OSCTXT* pctxt, BandClassPriorityListHRPD* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BandClassPriorityListHRPD");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      BandClassPriorityHRPD* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BandClassPriorityHRPD", xx1);

      rtxDListAllocNodeAndData (pctxt, BandClassPriorityHRPD, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_BandClassPriorityHRPD (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_BandClassPriorityListHRPD (BandClassPriorityListHRPD* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_BandClassPriority1XRTT (OSCTXT* pctxt, BandClassPriority1XRTT* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BandClassPriority1XRTT");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BandClassPriority1XRTT"));

   /* encode bandClass */

   RTXCTXTPUSHELEMNAME (pctxt, "bandClass");

   stat = asn1PE_BandclassCDMA2000 (pctxt, pvalue->bandClass);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellReselectionPriority */

   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

   stat = asn1PE_CellReselectionPriority (pctxt, pvalue->cellReselectionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BandClassPriority1XRTT (OSCTXT* pctxt, BandClassPriority1XRTT* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BandClassPriority1XRTT");

   /* decode root elements */
   /* decode bandClass */
   RTXCTXTPUSHELEMNAME (pctxt, "bandClass");

   stat = asn1PD_BandclassCDMA2000 (pctxt, &pvalue->bandClass);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellReselectionPriority */
   RTXCTXTPUSHELEMNAME (pctxt, "cellReselectionPriority");

   stat = asn1PD_CellReselectionPriority (pctxt, &pvalue->cellReselectionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_BandClassPriorityList1XRTT (OSCTXT* pctxt, BandClassPriorityList1XRTT* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "BandClassPriorityList1XRTT");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BandClassPriorityList1XRTT"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BandClassPriority1XRTT", xx1);

      stat = asn1PE_BandClassPriority1XRTT (pctxt, ((BandClassPriority1XRTT*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BandClassPriorityList1XRTT (OSCTXT* pctxt, BandClassPriorityList1XRTT* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BandClassPriorityList1XRTT");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      BandClassPriority1XRTT* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BandClassPriority1XRTT", xx1);

      rtxDListAllocNodeAndData (pctxt, BandClassPriority1XRTT, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_BandClassPriority1XRTT (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_BandClassPriorityList1XRTT (BandClassPriorityList1XRTT* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_IdleModeMobilityControlInfo (OSCTXT* pctxt, IdleModeMobilityControlInfo* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "IdleModeMobilityControlInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IdleModeMobilityControlInfo"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.freqPriorityListEUTRAPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.freqPriorityListGERANPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.freqPriorityListUTRA_FDDPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.freqPriorityListUTRA_TDDPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.bandClassPriorityListHRPDPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.bandClassPriorityList1XRTTPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.t320Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode freqPriorityListEUTRA */

   if (pvalue->m.freqPriorityListEUTRAPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "freqPriorityListEUTRA");

      stat = asn1PE_FreqPriorityListEUTRA (pctxt, &pvalue->freqPriorityListEUTRA);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode freqPriorityListGERAN */

   if (pvalue->m.freqPriorityListGERANPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "freqPriorityListGERAN");

      stat = asn1PE_FreqsPriorityListGERAN (pctxt, &pvalue->freqPriorityListGERAN);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode freqPriorityListUTRA_FDD */

   if (pvalue->m.freqPriorityListUTRA_FDDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "freqPriorityListUTRA-FDD");

      stat = asn1PE_FreqPriorityListUTRA_FDD (pctxt, &pvalue->freqPriorityListUTRA_FDD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode freqPriorityListUTRA_TDD */

   if (pvalue->m.freqPriorityListUTRA_TDDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "freqPriorityListUTRA-TDD");

      stat = asn1PE_FreqPriorityListUTRA_TDD (pctxt, &pvalue->freqPriorityListUTRA_TDD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode bandClassPriorityListHRPD */

   if (pvalue->m.bandClassPriorityListHRPDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "bandClassPriorityListHRPD");

      stat = asn1PE_BandClassPriorityListHRPD (pctxt, &pvalue->bandClassPriorityListHRPD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode bandClassPriorityList1XRTT */

   if (pvalue->m.bandClassPriorityList1XRTTPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "bandClassPriorityList1XRTT");

      stat = asn1PE_BandClassPriorityList1XRTT (pctxt, &pvalue->bandClassPriorityList1XRTT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode t320 */

   if (pvalue->m.t320Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "t320");

      stat = asn1PE_IdleModeMobilityControlInfo_t320 (pctxt, pvalue->t320);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IdleModeMobilityControlInfo (OSCTXT* pctxt, IdleModeMobilityControlInfo* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];

   RTXCTXTPUSHTYPENAME (pctxt, "IdleModeMobilityControlInfo");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode freqPriorityListEUTRA */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "freqPriorityListEUTRA");

      pvalue->m.freqPriorityListEUTRAPresent = 1;

      stat = asn1PD_FreqPriorityListEUTRA (pctxt, &pvalue->freqPriorityListEUTRA);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode freqPriorityListGERAN */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "freqPriorityListGERAN");

      pvalue->m.freqPriorityListGERANPresent = 1;

      stat = asn1PD_FreqsPriorityListGERAN (pctxt, &pvalue->freqPriorityListGERAN);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode freqPriorityListUTRA_FDD */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "freqPriorityListUTRA-FDD");

      pvalue->m.freqPriorityListUTRA_FDDPresent = 1;

      stat = asn1PD_FreqPriorityListUTRA_FDD (pctxt, &pvalue->freqPriorityListUTRA_FDD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode freqPriorityListUTRA_TDD */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "freqPriorityListUTRA-TDD");

      pvalue->m.freqPriorityListUTRA_TDDPresent = 1;

      stat = asn1PD_FreqPriorityListUTRA_TDD (pctxt, &pvalue->freqPriorityListUTRA_TDD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode bandClassPriorityListHRPD */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "bandClassPriorityListHRPD");

      pvalue->m.bandClassPriorityListHRPDPresent = 1;

      stat = asn1PD_BandClassPriorityListHRPD (pctxt, &pvalue->bandClassPriorityListHRPD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode bandClassPriorityList1XRTT */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "bandClassPriorityList1XRTT");

      pvalue->m.bandClassPriorityList1XRTTPresent = 1;

      stat = asn1PD_BandClassPriorityList1XRTT (pctxt, &pvalue->bandClassPriorityList1XRTT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode t320 */
   if (optbits[6]) {
      RTXCTXTPUSHELEMNAME (pctxt, "t320");

      pvalue->m.t320Present = 1;

      stat = asn1PD_IdleModeMobilityControlInfo_t320 (pctxt, &pvalue->t320);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_IdleModeMobilityControlInfo (IdleModeMobilityControlInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_FreqPriorityListEUTRA (&pvalue->freqPriorityListEUTRA);
   asn1Init_FreqsPriorityListGERAN (&pvalue->freqPriorityListGERAN);
   asn1Init_FreqPriorityListUTRA_FDD (&pvalue->freqPriorityListUTRA_FDD);
   asn1Init_FreqPriorityListUTRA_TDD (&pvalue->freqPriorityListUTRA_TDD);
   asn1Init_BandClassPriorityListHRPD (&pvalue->bandClassPriorityListHRPD);
   asn1Init_BandClassPriorityList1XRTT (&pvalue->bandClassPriorityList1XRTT);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_CellInfoGERAN_r9 (OSCTXT* pctxt, CellInfoGERAN_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellInfoGERAN-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellInfoGERAN_r9"));

   /* encode physCellId_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId-r9");

   stat = asn1PE_PhysCellIdGERAN (pctxt, &pvalue->physCellId_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode carrierFreq_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq-r9");

   stat = asn1PE_CarrierFreqGERAN (pctxt, &pvalue->carrierFreq_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode systemInformation_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "systemInformation-r9");

   stat = asn1PE_SystemInfoListGERAN (pctxt, &pvalue->systemInformation_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellInfoGERAN_r9 (OSCTXT* pctxt, CellInfoGERAN_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellInfoGERAN-r9");

   /* decode root elements */
   /* decode physCellId_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId-r9");

   stat = asn1PD_PhysCellIdGERAN (pctxt, &pvalue->physCellId_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode carrierFreq_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq-r9");

   stat = asn1PD_CarrierFreqGERAN (pctxt, &pvalue->carrierFreq_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode systemInformation_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "systemInformation-r9");

   stat = asn1PD_SystemInfoListGERAN (pctxt, &pvalue->systemInformation_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellInfoGERAN_r9 (CellInfoGERAN_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_PhysCellIdGERAN (&pvalue->physCellId_r9);
   asn1Init_SystemInfoListGERAN (&pvalue->systemInformation_r9);
}

EXTERN int asn1PE_CellInfoListGERAN_r9 (OSCTXT* pctxt, CellInfoListGERAN_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CellInfoListGERAN-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellInfoListGERAN_r9"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellInfoGERAN-r9", xx1);

      stat = asn1PE_CellInfoGERAN_r9 (pctxt, ((CellInfoGERAN_r9*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellInfoListGERAN_r9 (OSCTXT* pctxt, CellInfoListGERAN_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellInfoListGERAN-r9");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellInfoGERAN_r9* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellInfoGERAN-r9", xx1);

      rtxDListAllocNodeAndData (pctxt, CellInfoGERAN_r9, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellInfoGERAN_r9 (pdata);

      stat = asn1PD_CellInfoGERAN_r9 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellInfoListGERAN_r9 (CellInfoListGERAN_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_CellInfoUTRA_FDD_r9 (OSCTXT* pctxt, CellInfoUTRA_FDD_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellInfoUTRA-FDD-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellInfoUTRA_FDD_r9"));

   /* encode physCellId_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId-r9");

   stat = asn1PE_PhysCellIdUTRA_FDD (pctxt, pvalue->physCellId_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode utra_BCCH_Container_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "utra-BCCH-Container-r9");

   stat = pe_OctetString (pctxt, pvalue->utra_BCCH_Container_r9.numocts, pvalue->utra_BCCH_Container_r9.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellInfoUTRA_FDD_r9 (OSCTXT* pctxt, CellInfoUTRA_FDD_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellInfoUTRA-FDD-r9");

   /* decode root elements */
   /* decode physCellId_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId-r9");

   stat = asn1PD_PhysCellIdUTRA_FDD (pctxt, &pvalue->physCellId_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode utra_BCCH_Container_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "utra-BCCH-Container-r9");

   stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->utra_BCCH_Container_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellInfoUTRA_FDD_r9 (CellInfoUTRA_FDD_r9* pvalue)
{
   if (0 == pvalue) return;
   pvalue->utra_BCCH_Container_r9.numocts = 0;
   pvalue->utra_BCCH_Container_r9.data = 0;
}

EXTERN int asn1PE_CellInfoListUTRA_FDD_r9 (OSCTXT* pctxt, CellInfoListUTRA_FDD_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CellInfoListUTRA-FDD-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellInfoListUTRA_FDD_r9"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellInfoUTRA-FDD-r9", xx1);

      stat = asn1PE_CellInfoUTRA_FDD_r9 (pctxt, ((CellInfoUTRA_FDD_r9*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellInfoListUTRA_FDD_r9 (OSCTXT* pctxt, CellInfoListUTRA_FDD_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellInfoListUTRA-FDD-r9");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellInfoUTRA_FDD_r9* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellInfoUTRA-FDD-r9", xx1);

      rtxDListAllocNodeAndData (pctxt, CellInfoUTRA_FDD_r9, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellInfoUTRA_FDD_r9 (pdata);

      stat = asn1PD_CellInfoUTRA_FDD_r9 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellInfoListUTRA_FDD_r9 (CellInfoListUTRA_FDD_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_CellInfoUTRA_TDD_r9 (OSCTXT* pctxt, CellInfoUTRA_TDD_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellInfoUTRA-TDD-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellInfoUTRA_TDD_r9"));

   /* encode physCellId_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId-r9");

   stat = asn1PE_PhysCellIdUTRA_TDD (pctxt, pvalue->physCellId_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode utra_BCCH_Container_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "utra-BCCH-Container-r9");

   stat = pe_OctetString (pctxt, pvalue->utra_BCCH_Container_r9.numocts, pvalue->utra_BCCH_Container_r9.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellInfoUTRA_TDD_r9 (OSCTXT* pctxt, CellInfoUTRA_TDD_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellInfoUTRA-TDD-r9");

   /* decode root elements */
   /* decode physCellId_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId-r9");

   stat = asn1PD_PhysCellIdUTRA_TDD (pctxt, &pvalue->physCellId_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode utra_BCCH_Container_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "utra-BCCH-Container-r9");

   stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->utra_BCCH_Container_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellInfoUTRA_TDD_r9 (CellInfoUTRA_TDD_r9* pvalue)
{
   if (0 == pvalue) return;
   pvalue->utra_BCCH_Container_r9.numocts = 0;
   pvalue->utra_BCCH_Container_r9.data = 0;
}

EXTERN int asn1PE_CellInfoListUTRA_TDD_r9 (OSCTXT* pctxt, CellInfoListUTRA_TDD_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CellInfoListUTRA-TDD-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellInfoListUTRA_TDD_r9"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellInfoUTRA-TDD-r9", xx1);

      stat = asn1PE_CellInfoUTRA_TDD_r9 (pctxt, ((CellInfoUTRA_TDD_r9*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellInfoListUTRA_TDD_r9 (OSCTXT* pctxt, CellInfoListUTRA_TDD_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellInfoListUTRA-TDD-r9");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellInfoUTRA_TDD_r9* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellInfoUTRA-TDD-r9", xx1);

      rtxDListAllocNodeAndData (pctxt, CellInfoUTRA_TDD_r9, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellInfoUTRA_TDD_r9 (pdata);

      stat = asn1PD_CellInfoUTRA_TDD_r9 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellInfoListUTRA_TDD_r9 (CellInfoListUTRA_TDD_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_RRCConnectionRelease_v920_IEs_cellInfoList_r9 (OSCTXT* pctxt, RRCConnectionRelease_v920_IEs_cellInfoList_r9* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionRelease_v920_IEs_cellInfoList_r9"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 3);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* geran_r9 */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "geran-r9");

            stat = asn1PE_CellInfoListGERAN_r9 (pctxt, pvalue->u.geran_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* utra_FDD_r9 */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "utra-FDD-r9");

            stat = asn1PE_CellInfoListUTRA_FDD_r9 (pctxt, pvalue->u.utra_FDD_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* utra_TDD_r9 */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "utra-TDD-r9");

            stat = asn1PE_CellInfoListUTRA_TDD_r9 (pctxt, pvalue->u.utra_TDD_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionRelease_v920_IEs_cellInfoList_r9 (OSCTXT* pctxt, RRCConnectionRelease_v920_IEs_cellInfoList_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* geran_r9 */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "geran-r9");

            pvalue->u.geran_r9 = rtxMemAllocType (pctxt, 
               CellInfoListGERAN_r9);

            if (pvalue->u.geran_r9 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CellInfoListGERAN_r9 (pvalue->u.geran_r9);

            stat = asn1PD_CellInfoListGERAN_r9 (pctxt, pvalue->u.geran_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* utra_FDD_r9 */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "utra-FDD-r9");

            pvalue->u.utra_FDD_r9 = rtxMemAllocType (pctxt, 
               CellInfoListUTRA_FDD_r9);

            if (pvalue->u.utra_FDD_r9 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CellInfoListUTRA_FDD_r9 (pvalue->u.utra_FDD_r9);

            stat = asn1PD_CellInfoListUTRA_FDD_r9 (pctxt, pvalue->u.utra_FDD_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* utra_TDD_r9 */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "utra-TDD-r9");

            pvalue->u.utra_TDD_r9 = rtxMemAllocType (pctxt, 
               CellInfoListUTRA_TDD_r9);

            if (pvalue->u.utra_TDD_r9 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CellInfoListUTRA_TDD_r9 (pvalue->u.utra_TDD_r9);

            stat = asn1PD_CellInfoListUTRA_TDD_r9 (pctxt, pvalue->u.utra_TDD_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

void asn1Init_RRCConnectionRelease_v920_IEs_cellInfoList_r9 (
   RRCConnectionRelease_v920_IEs_cellInfoList_r9* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionRelease_v920_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionRelease_v920_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionRelease_v920_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionRelease_v920_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionRelease_v920_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionRelease_v920_IEs (OSCTXT* pctxt, RRCConnectionRelease_v920_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionRelease-v920-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionRelease_v920_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellInfoList_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cellInfoList_r9 */

   if (pvalue->m.cellInfoList_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellInfoList-r9");

      stat = asn1PE_RRCConnectionRelease_v920_IEs_cellInfoList_r9 (pctxt, &pvalue->cellInfoList_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionRelease_v920_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionRelease_v920_IEs (OSCTXT* pctxt, RRCConnectionRelease_v920_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionRelease-v920-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cellInfoList_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellInfoList-r9");

      pvalue->m.cellInfoList_r9Present = 1;

      stat = asn1PD_RRCConnectionRelease_v920_IEs_cellInfoList_r9 (pctxt, &pvalue->cellInfoList_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionRelease_v920_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionRelease_v920_IEs (
   RRCConnectionRelease_v920_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RRCConnectionRelease_v920_IEs_cellInfoList_r9 (&pvalue->cellInfoList_r9);
}

EXTERN int asn1PE_RRCConnectionRelease_v890_IEs (OSCTXT* pctxt, RRCConnectionRelease_v890_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionRelease-v890-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionRelease_v890_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionRelease_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionRelease_v890_IEs (OSCTXT* pctxt, RRCConnectionRelease_v890_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionRelease-v890-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionRelease_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionRelease_v890_IEs (
   RRCConnectionRelease_v890_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
   asn1Init_RRCConnectionRelease_v920_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_RRCConnectionRelease_r8_IEs (OSCTXT* pctxt, RRCConnectionRelease_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionRelease-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionRelease_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.redirectedCarrierInfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.idleModeMobilityControlInfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode releaseCause */

   RTXCTXTPUSHELEMNAME (pctxt, "releaseCause");

   stat = asn1PE_ReleaseCause (pctxt, pvalue->releaseCause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode redirectedCarrierInfo */

   if (pvalue->m.redirectedCarrierInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "redirectedCarrierInfo");

      stat = asn1PE_RedirectedCarrierInfo (pctxt, &pvalue->redirectedCarrierInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode idleModeMobilityControlInfo */

   if (pvalue->m.idleModeMobilityControlInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "idleModeMobilityControlInfo");

      stat = asn1PE_IdleModeMobilityControlInfo (pctxt, &pvalue->idleModeMobilityControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionRelease_v890_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionRelease_r8_IEs (OSCTXT* pctxt, RRCConnectionRelease_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionRelease-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode releaseCause */
   RTXCTXTPUSHELEMNAME (pctxt, "releaseCause");

   stat = asn1PD_ReleaseCause (pctxt, &pvalue->releaseCause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode redirectedCarrierInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "redirectedCarrierInfo");

      pvalue->m.redirectedCarrierInfoPresent = 1;

      stat = asn1PD_RedirectedCarrierInfo (pctxt, &pvalue->redirectedCarrierInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode idleModeMobilityControlInfo */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "idleModeMobilityControlInfo");

      pvalue->m.idleModeMobilityControlInfoPresent = 1;

      stat = asn1PD_IdleModeMobilityControlInfo (pctxt, &pvalue->idleModeMobilityControlInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionRelease_v890_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionRelease_r8_IEs (RRCConnectionRelease_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RedirectedCarrierInfo (&pvalue->redirectedCarrierInfo);
   asn1Init_IdleModeMobilityControlInfo (&pvalue->idleModeMobilityControlInfo);
   asn1Init_RRCConnectionRelease_v890_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_RRCConnectionRelease_criticalExtensions_c1 (OSCTXT* pctxt, RRCConnectionRelease_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionRelease_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* rrcConnectionRelease_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionRelease-r8");

         stat = asn1PE_RRCConnectionRelease_r8_IEs (pctxt, pvalue->u.rrcConnectionRelease_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionRelease_criticalExtensions_c1 (OSCTXT* pctxt, RRCConnectionRelease_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rrcConnectionRelease_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionRelease-r8");

         pvalue->u.rrcConnectionRelease_r8 = rtxMemAllocType (pctxt, 
            RRCConnectionRelease_r8_IEs);

         if (pvalue->u.rrcConnectionRelease_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionRelease_r8_IEs (pvalue->u.rrcConnectionRelease_r8);

         stat = asn1PD_RRCConnectionRelease_r8_IEs (pctxt, pvalue->u.rrcConnectionRelease_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionRelease_criticalExtensions_c1 (
   RRCConnectionRelease_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionRelease_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionRelease_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionRelease_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionRelease_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionRelease_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionRelease_criticalExtensions (OSCTXT* pctxt, RRCConnectionRelease_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionRelease_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_RRCConnectionRelease_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_RRCConnectionRelease_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionRelease_criticalExtensions (OSCTXT* pctxt, RRCConnectionRelease_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            RRCConnectionRelease_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionRelease_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_RRCConnectionRelease_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            RRCConnectionRelease_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_RRCConnectionRelease_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionRelease_criticalExtensions (
   RRCConnectionRelease_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionRelease (OSCTXT* pctxt, RRCConnectionRelease* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionRelease");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionRelease"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_RRCConnectionRelease_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionRelease (OSCTXT* pctxt, RRCConnectionRelease* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionRelease");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_RRCConnectionRelease_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionRelease (RRCConnectionRelease* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_RRCConnectionRelease_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_SecurityConfigSMC (OSCTXT* pctxt, SecurityConfigSMC* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityConfigSMC");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityConfigSMC"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode securityAlgorithmConfig */

   RTXCTXTPUSHELEMNAME (pctxt, "securityAlgorithmConfig");

   stat = asn1PE_SecurityAlgorithmConfig (pctxt, &pvalue->securityAlgorithmConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityConfigSMC (OSCTXT* pctxt, SecurityConfigSMC* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityConfigSMC");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode securityAlgorithmConfig */
   RTXCTXTPUSHELEMNAME (pctxt, "securityAlgorithmConfig");

   stat = asn1PD_SecurityAlgorithmConfig (pctxt, &pvalue->securityAlgorithmConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SecurityConfigSMC (SecurityConfigSMC* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_SecurityModeCommand_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, SecurityModeCommand_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeCommand_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeCommand_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, SecurityModeCommand_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_SecurityModeCommand_v8a0_IEs (OSCTXT* pctxt, SecurityModeCommand_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeCommand-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeCommand_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_SecurityModeCommand_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeCommand_v8a0_IEs (OSCTXT* pctxt, SecurityModeCommand_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeCommand-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_SecurityModeCommand_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SecurityModeCommand_v8a0_IEs (
   SecurityModeCommand_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_SecurityModeCommand_r8_IEs (OSCTXT* pctxt, SecurityModeCommand_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeCommand-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeCommand_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode securityConfigSMC */

   RTXCTXTPUSHELEMNAME (pctxt, "securityConfigSMC");

   stat = asn1PE_SecurityConfigSMC (pctxt, &pvalue->securityConfigSMC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_SecurityModeCommand_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeCommand_r8_IEs (OSCTXT* pctxt, SecurityModeCommand_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeCommand-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode securityConfigSMC */
   RTXCTXTPUSHELEMNAME (pctxt, "securityConfigSMC");

   stat = asn1PD_SecurityConfigSMC (pctxt, &pvalue->securityConfigSMC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_SecurityModeCommand_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SecurityModeCommand_r8_IEs (SecurityModeCommand_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SecurityConfigSMC (&pvalue->securityConfigSMC);
   asn1Init_SecurityModeCommand_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_SecurityModeCommand_criticalExtensions_c1 (OSCTXT* pctxt, SecurityModeCommand_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeCommand_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* securityModeCommand_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "securityModeCommand-r8");

         stat = asn1PE_SecurityModeCommand_r8_IEs (pctxt, pvalue->u.securityModeCommand_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeCommand_criticalExtensions_c1 (OSCTXT* pctxt, SecurityModeCommand_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* securityModeCommand_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "securityModeCommand-r8");

         pvalue->u.securityModeCommand_r8 = rtxMemAllocType (pctxt, 
            SecurityModeCommand_r8_IEs);

         if (pvalue->u.securityModeCommand_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SecurityModeCommand_r8_IEs (pvalue->u.securityModeCommand_r8);

         stat = asn1PD_SecurityModeCommand_r8_IEs (pctxt, pvalue->u.securityModeCommand_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_SecurityModeCommand_criticalExtensions_c1 (
   SecurityModeCommand_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_SecurityModeCommand_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, SecurityModeCommand_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeCommand_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeCommand_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, SecurityModeCommand_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_SecurityModeCommand_criticalExtensions (OSCTXT* pctxt, SecurityModeCommand_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeCommand_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_SecurityModeCommand_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_SecurityModeCommand_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeCommand_criticalExtensions (OSCTXT* pctxt, SecurityModeCommand_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            SecurityModeCommand_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SecurityModeCommand_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_SecurityModeCommand_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            SecurityModeCommand_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_SecurityModeCommand_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_SecurityModeCommand_criticalExtensions (
   SecurityModeCommand_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_SecurityModeCommand (OSCTXT* pctxt, SecurityModeCommand* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeCommand");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeCommand"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_SecurityModeCommand_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeCommand (OSCTXT* pctxt, SecurityModeCommand* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeCommand");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_SecurityModeCommand_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SecurityModeCommand (SecurityModeCommand* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SecurityModeCommand_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_UE_CapabilityRequest (OSCTXT* pctxt, UE_CapabilityRequest* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-CapabilityRequest");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_CapabilityRequest"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAT-Type", xx1);

      stat = asn1PE_RAT_Type (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_CapabilityRequest (OSCTXT* pctxt, UE_CapabilityRequest* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-CapabilityRequest");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 8) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAT-Type", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (RAT_Type));
      stat = asn1PD_RAT_Type (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UE_CapabilityRequest (UE_CapabilityRequest* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_UECapabilityEnquiry_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, UECapabilityEnquiry_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UECapabilityEnquiry_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UECapabilityEnquiry_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, UECapabilityEnquiry_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_UECapabilityEnquiry_v8a0_IEs (OSCTXT* pctxt, UECapabilityEnquiry_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UECapabilityEnquiry-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UECapabilityEnquiry_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_UECapabilityEnquiry_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UECapabilityEnquiry_v8a0_IEs (OSCTXT* pctxt, UECapabilityEnquiry_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "UECapabilityEnquiry-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_UECapabilityEnquiry_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UECapabilityEnquiry_v8a0_IEs (
   UECapabilityEnquiry_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_UECapabilityEnquiry_r8_IEs (OSCTXT* pctxt, UECapabilityEnquiry_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UECapabilityEnquiry-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UECapabilityEnquiry_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ue_CapabilityRequest */

   RTXCTXTPUSHELEMNAME (pctxt, "ue-CapabilityRequest");

   stat = asn1PE_UE_CapabilityRequest (pctxt, &pvalue->ue_CapabilityRequest);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_UECapabilityEnquiry_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UECapabilityEnquiry_r8_IEs (OSCTXT* pctxt, UECapabilityEnquiry_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UECapabilityEnquiry-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ue_CapabilityRequest */
   RTXCTXTPUSHELEMNAME (pctxt, "ue-CapabilityRequest");

   stat = asn1PD_UE_CapabilityRequest (pctxt, &pvalue->ue_CapabilityRequest);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_UECapabilityEnquiry_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UECapabilityEnquiry_r8_IEs (UECapabilityEnquiry_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_UE_CapabilityRequest (&pvalue->ue_CapabilityRequest);
   asn1Init_UECapabilityEnquiry_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_UECapabilityEnquiry_criticalExtensions_c1 (OSCTXT* pctxt, UECapabilityEnquiry_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UECapabilityEnquiry_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* ueCapabilityEnquiry_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ueCapabilityEnquiry-r8");

         stat = asn1PE_UECapabilityEnquiry_r8_IEs (pctxt, pvalue->u.ueCapabilityEnquiry_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UECapabilityEnquiry_criticalExtensions_c1 (OSCTXT* pctxt, UECapabilityEnquiry_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* ueCapabilityEnquiry_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "ueCapabilityEnquiry-r8");

         pvalue->u.ueCapabilityEnquiry_r8 = rtxMemAllocType (pctxt, 
            UECapabilityEnquiry_r8_IEs);

         if (pvalue->u.ueCapabilityEnquiry_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UECapabilityEnquiry_r8_IEs (pvalue->u.ueCapabilityEnquiry_r8);

         stat = asn1PD_UECapabilityEnquiry_r8_IEs (pctxt, pvalue->u.ueCapabilityEnquiry_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_UECapabilityEnquiry_criticalExtensions_c1 (
   UECapabilityEnquiry_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_UECapabilityEnquiry_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, UECapabilityEnquiry_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UECapabilityEnquiry_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UECapabilityEnquiry_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, UECapabilityEnquiry_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_UECapabilityEnquiry_criticalExtensions (OSCTXT* pctxt, UECapabilityEnquiry_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UECapabilityEnquiry_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_UECapabilityEnquiry_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_UECapabilityEnquiry_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UECapabilityEnquiry_criticalExtensions (OSCTXT* pctxt, UECapabilityEnquiry_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            UECapabilityEnquiry_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UECapabilityEnquiry_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_UECapabilityEnquiry_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            UECapabilityEnquiry_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_UECapabilityEnquiry_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_UECapabilityEnquiry_criticalExtensions (
   UECapabilityEnquiry_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_UECapabilityEnquiry (OSCTXT* pctxt, UECapabilityEnquiry* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UECapabilityEnquiry");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UECapabilityEnquiry"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_UECapabilityEnquiry_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UECapabilityEnquiry (OSCTXT* pctxt, UECapabilityEnquiry* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UECapabilityEnquiry");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_UECapabilityEnquiry_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UECapabilityEnquiry (UECapabilityEnquiry* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_UECapabilityEnquiry_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_DRB_CountMSB_Info (OSCTXT* pctxt, DRB_CountMSB_Info* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-CountMSB-Info");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRB_CountMSB_Info"));

   /* encode drb_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "drb-Identity");

   stat = asn1PE_DRB_Identity (pctxt, pvalue->drb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode countMSB_Uplink */

   RTXCTXTPUSHELEMNAME (pctxt, "countMSB-Uplink");

   if ( (pvalue->countMSB_Uplink <= OSUINTCONST(33554431)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->countMSB_Uplink, OSUINTCONST(0), OSUINTCONST(33554431));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->countMSB_Uplink);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode countMSB_Downlink */

   RTXCTXTPUSHELEMNAME (pctxt, "countMSB-Downlink");

   if ( (pvalue->countMSB_Downlink <= OSUINTCONST(33554431)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->countMSB_Downlink, OSUINTCONST(0), OSUINTCONST(33554431));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->countMSB_Downlink);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRB_CountMSB_Info (OSCTXT* pctxt, DRB_CountMSB_Info* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-CountMSB-Info");

   /* decode root elements */
   /* decode drb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "drb-Identity");

   stat = asn1PD_DRB_Identity (pctxt, &pvalue->drb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode countMSB_Uplink */
   RTXCTXTPUSHELEMNAME (pctxt, "countMSB-Uplink");

   stat = pd_ConsUnsigned (pctxt, &pvalue->countMSB_Uplink, OSUINTCONST(0), OSUINTCONST(33554431));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode countMSB_Downlink */
   RTXCTXTPUSHELEMNAME (pctxt, "countMSB-Downlink");

   stat = pd_ConsUnsigned (pctxt, &pvalue->countMSB_Downlink, OSUINTCONST(0), OSUINTCONST(33554431));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_DRB_CountMSB_InfoList (OSCTXT* pctxt, DRB_CountMSB_InfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-CountMSB-InfoList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRB_CountMSB_InfoList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(11), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DRB-CountMSB-Info", xx1);

      stat = asn1PE_DRB_CountMSB_Info (pctxt, ((DRB_CountMSB_Info*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRB_CountMSB_InfoList (OSCTXT* pctxt, DRB_CountMSB_InfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-CountMSB-InfoList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(11), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DRB_CountMSB_Info* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DRB-CountMSB-Info", xx1);

      rtxDListAllocNodeAndData (pctxt, DRB_CountMSB_Info, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_DRB_CountMSB_Info (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DRB_CountMSB_InfoList (DRB_CountMSB_InfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_CounterCheck_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, CounterCheck_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CounterCheck_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CounterCheck_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, CounterCheck_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_CounterCheck_v8a0_IEs (OSCTXT* pctxt, CounterCheck_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CounterCheck-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CounterCheck_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_CounterCheck_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CounterCheck_v8a0_IEs (OSCTXT* pctxt, CounterCheck_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "CounterCheck-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_CounterCheck_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CounterCheck_v8a0_IEs (CounterCheck_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_CounterCheck_r8_IEs (OSCTXT* pctxt, CounterCheck_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CounterCheck-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CounterCheck_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode drb_CountMSB_InfoList */

   RTXCTXTPUSHELEMNAME (pctxt, "drb-CountMSB-InfoList");

   stat = asn1PE_DRB_CountMSB_InfoList (pctxt, &pvalue->drb_CountMSB_InfoList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_CounterCheck_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CounterCheck_r8_IEs (OSCTXT* pctxt, CounterCheck_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CounterCheck-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode drb_CountMSB_InfoList */
   RTXCTXTPUSHELEMNAME (pctxt, "drb-CountMSB-InfoList");

   stat = asn1PD_DRB_CountMSB_InfoList (pctxt, &pvalue->drb_CountMSB_InfoList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_CounterCheck_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CounterCheck_r8_IEs (CounterCheck_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_DRB_CountMSB_InfoList (&pvalue->drb_CountMSB_InfoList);
   asn1Init_CounterCheck_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_CounterCheck_criticalExtensions_c1 (OSCTXT* pctxt, CounterCheck_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CounterCheck_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* counterCheck_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "counterCheck-r8");

         stat = asn1PE_CounterCheck_r8_IEs (pctxt, pvalue->u.counterCheck_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CounterCheck_criticalExtensions_c1 (OSCTXT* pctxt, CounterCheck_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* counterCheck_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "counterCheck-r8");

         pvalue->u.counterCheck_r8 = rtxMemAllocType (pctxt, 
            CounterCheck_r8_IEs);

         if (pvalue->u.counterCheck_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CounterCheck_r8_IEs (pvalue->u.counterCheck_r8);

         stat = asn1PD_CounterCheck_r8_IEs (pctxt, pvalue->u.counterCheck_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_CounterCheck_criticalExtensions_c1 (
   CounterCheck_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_CounterCheck_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, CounterCheck_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CounterCheck_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CounterCheck_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, CounterCheck_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_CounterCheck_criticalExtensions (OSCTXT* pctxt, CounterCheck_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CounterCheck_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_CounterCheck_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_CounterCheck_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CounterCheck_criticalExtensions (OSCTXT* pctxt, CounterCheck_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            CounterCheck_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CounterCheck_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_CounterCheck_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            CounterCheck_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_CounterCheck_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_CounterCheck_criticalExtensions (
   CounterCheck_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_CounterCheck (OSCTXT* pctxt, CounterCheck* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CounterCheck");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CounterCheck"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_CounterCheck_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CounterCheck (OSCTXT* pctxt, CounterCheck* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CounterCheck");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_CounterCheck_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CounterCheck (CounterCheck* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_CounterCheck_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_UEInformationRequest_v930_IEs_nonCriticalExtension (OSCTXT* pctxt, UEInformationRequest_v930_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationRequest_v930_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationRequest_v930_IEs_nonCriticalExtension (OSCTXT* pctxt, UEInformationRequest_v930_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_UEInformationRequest_v930_IEs (OSCTXT* pctxt, UEInformationRequest_v930_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UEInformationRequest-v930-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationRequest_v930_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_UEInformationRequest_v930_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationRequest_v930_IEs (OSCTXT* pctxt, UEInformationRequest_v930_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "UEInformationRequest-v930-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_UEInformationRequest_v930_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UEInformationRequest_v930_IEs (
   UEInformationRequest_v930_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_UEInformationRequest_r9_IEs (OSCTXT* pctxt, UEInformationRequest_r9_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UEInformationRequest-r9-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationRequest_r9_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rach_ReportReq_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "rach-ReportReq-r9");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->rach_ReportReq_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rlf_ReportReq_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "rlf-ReportReq-r9");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->rlf_ReportReq_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_UEInformationRequest_v930_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationRequest_r9_IEs (OSCTXT* pctxt, UEInformationRequest_r9_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UEInformationRequest-r9-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rach_ReportReq_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "rach-ReportReq-r9");

   stat = DEC_BIT (pctxt, &pvalue->rach_ReportReq_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rlf_ReportReq_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "rlf-ReportReq-r9");

   stat = DEC_BIT (pctxt, &pvalue->rlf_ReportReq_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_UEInformationRequest_v930_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UEInformationRequest_r9_IEs (UEInformationRequest_r9_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_UEInformationRequest_v930_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_UEInformationRequest_r9_criticalExtensions_c1 (OSCTXT* pctxt, UEInformationRequest_r9_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationRequest_r9_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* ueInformationRequest_r9 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ueInformationRequest-r9");

         stat = asn1PE_UEInformationRequest_r9_IEs (pctxt, pvalue->u.ueInformationRequest_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationRequest_r9_criticalExtensions_c1 (OSCTXT* pctxt, UEInformationRequest_r9_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* ueInformationRequest_r9 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "ueInformationRequest-r9");

         pvalue->u.ueInformationRequest_r9 = rtxMemAllocType (pctxt, 
            UEInformationRequest_r9_IEs);

         if (pvalue->u.ueInformationRequest_r9 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEInformationRequest_r9_IEs (pvalue->u.ueInformationRequest_r9);

         stat = asn1PD_UEInformationRequest_r9_IEs (pctxt, pvalue->u.ueInformationRequest_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_UEInformationRequest_r9_criticalExtensions_c1 (
   UEInformationRequest_r9_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_UEInformationRequest_r9_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, UEInformationRequest_r9_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationRequest_r9_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationRequest_r9_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, UEInformationRequest_r9_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_UEInformationRequest_r9_criticalExtensions (OSCTXT* pctxt, UEInformationRequest_r9_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationRequest_r9_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_UEInformationRequest_r9_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_UEInformationRequest_r9_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationRequest_r9_criticalExtensions (OSCTXT* pctxt, UEInformationRequest_r9_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            UEInformationRequest_r9_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEInformationRequest_r9_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_UEInformationRequest_r9_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            UEInformationRequest_r9_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_UEInformationRequest_r9_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_UEInformationRequest_r9_criticalExtensions (
   UEInformationRequest_r9_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_UEInformationRequest_r9 (OSCTXT* pctxt, UEInformationRequest_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UEInformationRequest-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationRequest_r9"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_UEInformationRequest_r9_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationRequest_r9 (OSCTXT* pctxt, UEInformationRequest_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UEInformationRequest-r9");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_UEInformationRequest_r9_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UEInformationRequest_r9 (UEInformationRequest_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_UEInformationRequest_r9_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_DL_DCCH_MessageType_c1 (OSCTXT* pctxt, DL_DCCH_MessageType_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DL_DCCH_MessageType_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 15);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* csfbParametersResponseCDMA2000 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "csfbParametersResponseCDMA2000");

         stat = asn1PE_CSFBParametersResponseCDMA2000 (pctxt, pvalue->u.csfbParametersResponseCDMA2000);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* dlInformationTransfer */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "dlInformationTransfer");

         stat = asn1PE_DLInformationTransfer (pctxt, pvalue->u.dlInformationTransfer);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* handoverFromEUTRAPreparationRequest */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "handoverFromEUTRAPreparationRequest");

         stat = asn1PE_HandoverFromEUTRAPreparationRequest (pctxt, pvalue->u.handoverFromEUTRAPreparationRequest);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* mobilityFromEUTRACommand */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "mobilityFromEUTRACommand");

         stat = asn1PE_MobilityFromEUTRACommand (pctxt, pvalue->u.mobilityFromEUTRACommand);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* rrcConnectionReconfiguration */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReconfiguration");

         stat = asn1PE_RRCConnectionReconfiguration (pctxt, pvalue->u.rrcConnectionReconfiguration);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* rrcConnectionRelease */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionRelease");

         stat = asn1PE_RRCConnectionRelease (pctxt, pvalue->u.rrcConnectionRelease);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* securityModeCommand */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "securityModeCommand");

         stat = asn1PE_SecurityModeCommand (pctxt, pvalue->u.securityModeCommand);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* ueCapabilityEnquiry */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "ueCapabilityEnquiry");

         stat = asn1PE_UECapabilityEnquiry (pctxt, pvalue->u.ueCapabilityEnquiry);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* counterCheck */
      case 9:
         RTXCTXTPUSHELEMNAME (pctxt, "counterCheck");

         stat = asn1PE_CounterCheck (pctxt, pvalue->u.counterCheck);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* ueInformationRequest_r9 */
      case 10:
         RTXCTXTPUSHELEMNAME (pctxt, "ueInformationRequest-r9");

         stat = asn1PE_UEInformationRequest_r9 (pctxt, pvalue->u.ueInformationRequest_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare6 */
      case 11:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare5 */
      case 12:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare4 */
      case 13:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 14:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 15:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 16:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DL_DCCH_MessageType_c1 (OSCTXT* pctxt, DL_DCCH_MessageType_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* csfbParametersResponseCDMA2000 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "csfbParametersResponseCDMA2000");

         pvalue->u.csfbParametersResponseCDMA2000 = rtxMemAllocType (pctxt, 
            CSFBParametersResponseCDMA2000);

         if (pvalue->u.csfbParametersResponseCDMA2000 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CSFBParametersResponseCDMA2000 (pvalue->u.csfbParametersResponseCDMA2000);

         stat = asn1PD_CSFBParametersResponseCDMA2000 (pctxt, pvalue->u.csfbParametersResponseCDMA2000);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dlInformationTransfer */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dlInformationTransfer");

         pvalue->u.dlInformationTransfer = rtxMemAllocType (pctxt, 
            DLInformationTransfer);

         if (pvalue->u.dlInformationTransfer == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DLInformationTransfer (pvalue->u.dlInformationTransfer);

         stat = asn1PD_DLInformationTransfer (pctxt, pvalue->u.dlInformationTransfer);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* handoverFromEUTRAPreparationRequest */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "handoverFromEUTRAPreparationRequest");

         pvalue->u.handoverFromEUTRAPreparationRequest
             = rtxMemAllocType (pctxt, HandoverFromEUTRAPreparationRequest);

         if (pvalue->u.handoverFromEUTRAPreparationRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HandoverFromEUTRAPreparationRequest (pvalue->u.handoverFromEUTRAPreparationRequest);

         stat = asn1PD_HandoverFromEUTRAPreparationRequest (pctxt, pvalue->u.handoverFromEUTRAPreparationRequest);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* mobilityFromEUTRACommand */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "mobilityFromEUTRACommand");

         pvalue->u.mobilityFromEUTRACommand = rtxMemAllocType (pctxt, 
            MobilityFromEUTRACommand);

         if (pvalue->u.mobilityFromEUTRACommand == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MobilityFromEUTRACommand (pvalue->u.mobilityFromEUTRACommand);

         stat = asn1PD_MobilityFromEUTRACommand (pctxt, pvalue->u.mobilityFromEUTRACommand);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* rrcConnectionReconfiguration */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReconfiguration");

         pvalue->u.rrcConnectionReconfiguration = rtxMemAllocType (pctxt, 
            RRCConnectionReconfiguration);

         if (pvalue->u.rrcConnectionReconfiguration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReconfiguration (pvalue->u.rrcConnectionReconfiguration);

         stat = asn1PD_RRCConnectionReconfiguration (pctxt, pvalue->u.rrcConnectionReconfiguration);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* rrcConnectionRelease */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionRelease");

         pvalue->u.rrcConnectionRelease = rtxMemAllocType (pctxt, 
            RRCConnectionRelease);

         if (pvalue->u.rrcConnectionRelease == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionRelease (pvalue->u.rrcConnectionRelease);

         stat = asn1PD_RRCConnectionRelease (pctxt, pvalue->u.rrcConnectionRelease);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* securityModeCommand */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "securityModeCommand");

         pvalue->u.securityModeCommand = rtxMemAllocType (pctxt, 
            SecurityModeCommand);

         if (pvalue->u.securityModeCommand == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SecurityModeCommand (pvalue->u.securityModeCommand);

         stat = asn1PD_SecurityModeCommand (pctxt, pvalue->u.securityModeCommand);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueCapabilityEnquiry */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "ueCapabilityEnquiry");

         pvalue->u.ueCapabilityEnquiry = rtxMemAllocType (pctxt, 
            UECapabilityEnquiry);

         if (pvalue->u.ueCapabilityEnquiry == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UECapabilityEnquiry (pvalue->u.ueCapabilityEnquiry);

         stat = asn1PD_UECapabilityEnquiry (pctxt, pvalue->u.ueCapabilityEnquiry);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* counterCheck */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "counterCheck");

         pvalue->u.counterCheck = rtxMemAllocType (pctxt, CounterCheck);

         if (pvalue->u.counterCheck == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CounterCheck (pvalue->u.counterCheck);

         stat = asn1PD_CounterCheck (pctxt, pvalue->u.counterCheck);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueInformationRequest_r9 */
      case 9:
         RTXCTXTPUSHELEMNAME (pctxt, "ueInformationRequest-r9");

         pvalue->u.ueInformationRequest_r9 = rtxMemAllocType (pctxt, 
            UEInformationRequest_r9);

         if (pvalue->u.ueInformationRequest_r9 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEInformationRequest_r9 (pvalue->u.ueInformationRequest_r9);

         stat = asn1PD_UEInformationRequest_r9 (pctxt, pvalue->u.ueInformationRequest_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare6 */
      case 10:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare5 */
      case 11:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare4 */
      case 12:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 13:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 14:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 15:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_DL_DCCH_MessageType_c1 (DL_DCCH_MessageType_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_DL_DCCH_MessageType_messageClassExtension (OSCTXT* pctxt, DL_DCCH_MessageType_messageClassExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("DL_DCCH_MessageType_messageClassExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DL_DCCH_MessageType_messageClassExtension (OSCTXT* pctxt, DL_DCCH_MessageType_messageClassExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_DL_DCCH_MessageType (OSCTXT* pctxt, DL_DCCH_MessageType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DCCH-MessageType");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DL_DCCH_MessageType"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_DL_DCCH_MessageType_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* messageClassExtension */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "messageClassExtension");

         stat = asn1PE_DL_DCCH_MessageType_messageClassExtension (pctxt, pvalue->u.messageClassExtension);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DL_DCCH_MessageType (OSCTXT* pctxt, DL_DCCH_MessageType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DCCH-MessageType");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, DL_DCCH_MessageType_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DL_DCCH_MessageType_c1 (pvalue->u.c1);

         stat = asn1PD_DL_DCCH_MessageType_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* messageClassExtension */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "messageClassExtension");

         pvalue->u.messageClassExtension = rtxMemAllocTypeZ (pctxt, 
            DL_DCCH_MessageType_messageClassExtension);

         if (pvalue->u.messageClassExtension == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_DL_DCCH_MessageType_messageClassExtension (pctxt, pvalue->u.messageClassExtension);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DL_DCCH_MessageType (DL_DCCH_MessageType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_DL_DCCH_Message (OSCTXT* pctxt, DL_DCCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DCCH-Message");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DL_DCCH_Message"));

   /* encode message */

   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PE_DL_DCCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DL_DCCH_Message (OSCTXT* pctxt, DL_DCCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-DCCH-Message");

   /* decode root elements */
   /* decode message */
   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PD_DL_DCCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DL_DCCH_Message (DL_DCCH_Message* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_DL_DCCH_MessageType (&pvalue->message);
}

EXTERN int asn1PE_ReestabUE_Identity (OSCTXT* pctxt, ReestabUE_Identity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReestabUE-Identity");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReestabUE_Identity"));

   /* encode c_RNTI */

   RTXCTXTPUSHELEMNAME (pctxt, "c-RNTI");

   stat = asn1PE_C_RNTI (pctxt, pvalue->c_RNTI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode physCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PE_PhysCellId (pctxt, pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode shortMAC_I */

   RTXCTXTPUSHELEMNAME (pctxt, "shortMAC-I");

   stat = asn1PE_ShortMAC_I (pctxt, pvalue->shortMAC_I);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReestabUE_Identity (OSCTXT* pctxt, ReestabUE_Identity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReestabUE-Identity");

   /* decode root elements */
   /* decode c_RNTI */
   RTXCTXTPUSHELEMNAME (pctxt, "c-RNTI");

   stat = asn1PD_C_RNTI (pctxt, &pvalue->c_RNTI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode physCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PD_PhysCellId (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode shortMAC_I */
   RTXCTXTPUSHELEMNAME (pctxt, "shortMAC-I");

   stat = asn1PD_ShortMAC_I (pctxt, &pvalue->shortMAC_I);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ReestabUE_Identity (ReestabUE_Identity* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_C_RNTI (&pvalue->c_RNTI);
   asn1Init_ShortMAC_I (&pvalue->shortMAC_I);
}

EXTERN int asn1PE_RRCConnectionReestablishmentRequest_r8_IEs (OSCTXT* pctxt, RRCConnectionReestablishmentRequest_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentRequest-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentRequest_r8_IEs"));

   /* encode ue_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "ue-Identity");

   stat = asn1PE_ReestabUE_Identity (pctxt, &pvalue->ue_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode reestablishmentCause */

   RTXCTXTPUSHELEMNAME (pctxt, "reestablishmentCause");

   stat = asn1PE_ReestablishmentCause (pctxt, pvalue->reestablishmentCause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->spare, OSUINTCONST(2), OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentRequest_r8_IEs (OSCTXT* pctxt, RRCConnectionReestablishmentRequest_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentRequest-r8-IEs");

   /* decode root elements */
   /* decode ue_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "ue-Identity");

   stat = asn1PD_ReestabUE_Identity (pctxt, &pvalue->ue_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reestablishmentCause */
   RTXCTXTPUSHELEMNAME (pctxt, "reestablishmentCause");

   stat = asn1PD_ReestablishmentCause (pctxt, &pvalue->reestablishmentCause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode spare */
   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->spare
      , OSUINTCONST(2), OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReestablishmentRequest_r8_IEs (
   RRCConnectionReestablishmentRequest_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_ReestabUE_Identity (&pvalue->ue_Identity);
   pvalue->spare.numbits = 0;
}

EXTERN int asn1PE_RRCConnectionReestablishmentRequest_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionReestablishmentRequest_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentRequest_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentRequest_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionReestablishmentRequest_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionReestablishmentRequest_criticalExtensions (OSCTXT* pctxt, RRCConnectionReestablishmentRequest_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentRequest_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* rrcConnectionReestablishmentRequest_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishmentRequest-r8");

         stat = asn1PE_RRCConnectionReestablishmentRequest_r8_IEs (pctxt, pvalue->u.rrcConnectionReestablishmentRequest_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_RRCConnectionReestablishmentRequest_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentRequest_criticalExtensions (OSCTXT* pctxt, RRCConnectionReestablishmentRequest_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rrcConnectionReestablishmentRequest_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishmentRequest-r8");

         pvalue->u.rrcConnectionReestablishmentRequest_r8
             = rtxMemAllocType (pctxt, 
            RRCConnectionReestablishmentRequest_r8_IEs);

         if (pvalue->u.rrcConnectionReestablishmentRequest_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReestablishmentRequest_r8_IEs (pvalue->u.rrcConnectionReestablishmentRequest_r8);

         stat = asn1PD_RRCConnectionReestablishmentRequest_r8_IEs (pctxt, pvalue->u.rrcConnectionReestablishmentRequest_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            RRCConnectionReestablishmentRequest_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_RRCConnectionReestablishmentRequest_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionReestablishmentRequest_criticalExtensions (
   RRCConnectionReestablishmentRequest_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionReestablishmentRequest (OSCTXT* pctxt, RRCConnectionReestablishmentRequest* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentRequest");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentRequest"));

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_RRCConnectionReestablishmentRequest_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentRequest (OSCTXT* pctxt, RRCConnectionReestablishmentRequest* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentRequest");

   /* decode root elements */
   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_RRCConnectionReestablishmentRequest_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReestablishmentRequest (
   RRCConnectionReestablishmentRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_RRCConnectionReestablishmentRequest_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_InitialUE_Identity (OSCTXT* pctxt, InitialUE_Identity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialUE-Identity");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("InitialUE_Identity"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* s_TMSI */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "s-TMSI");

         stat = asn1PE_S_TMSI (pctxt, pvalue->u.s_TMSI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* randomValue */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "randomValue");

         stat = asn1PE_InitialUE_Identity_randomValue (pctxt, pvalue->u.randomValue);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_InitialUE_Identity (OSCTXT* pctxt, InitialUE_Identity* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialUE-Identity");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* s_TMSI */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "s-TMSI");

         pvalue->u.s_TMSI = rtxMemAllocType (pctxt, S_TMSI);

         if (pvalue->u.s_TMSI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_S_TMSI (pvalue->u.s_TMSI);

         stat = asn1PD_S_TMSI (pctxt, pvalue->u.s_TMSI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* randomValue */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "randomValue");

         pvalue->u.randomValue = rtxMemAllocType (pctxt, 
            InitialUE_Identity_randomValue);

         if (pvalue->u.randomValue == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_InitialUE_Identity_randomValue (pvalue->u.randomValue);

         stat = asn1PD_InitialUE_Identity_randomValue (pctxt, pvalue->u.randomValue);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_InitialUE_Identity (InitialUE_Identity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionRequest_r8_IEs (OSCTXT* pctxt, RRCConnectionRequest_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionRequest-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionRequest_r8_IEs"));

   /* encode ue_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "ue-Identity");

   stat = asn1PE_InitialUE_Identity (pctxt, &pvalue->ue_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode establishmentCause */

   RTXCTXTPUSHELEMNAME (pctxt, "establishmentCause");

   stat = asn1PE_EstablishmentCause (pctxt, pvalue->establishmentCause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->spare, OSUINTCONST(1), OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionRequest_r8_IEs (OSCTXT* pctxt, RRCConnectionRequest_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionRequest-r8-IEs");

   /* decode root elements */
   /* decode ue_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "ue-Identity");

   stat = asn1PD_InitialUE_Identity (pctxt, &pvalue->ue_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode establishmentCause */
   RTXCTXTPUSHELEMNAME (pctxt, "establishmentCause");

   stat = asn1PD_EstablishmentCause (pctxt, &pvalue->establishmentCause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode spare */
   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->spare
      , OSUINTCONST(1), OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionRequest_r8_IEs (RRCConnectionRequest_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_InitialUE_Identity (&pvalue->ue_Identity);
   pvalue->spare.numbits = 0;
}

EXTERN int asn1PE_RRCConnectionRequest_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionRequest_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionRequest_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionRequest_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionRequest_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionRequest_criticalExtensions (OSCTXT* pctxt, RRCConnectionRequest_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionRequest_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* rrcConnectionRequest_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionRequest-r8");

         stat = asn1PE_RRCConnectionRequest_r8_IEs (pctxt, pvalue->u.rrcConnectionRequest_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_RRCConnectionRequest_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionRequest_criticalExtensions (OSCTXT* pctxt, RRCConnectionRequest_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rrcConnectionRequest_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionRequest-r8");

         pvalue->u.rrcConnectionRequest_r8 = rtxMemAllocType (pctxt, 
            RRCConnectionRequest_r8_IEs);

         if (pvalue->u.rrcConnectionRequest_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionRequest_r8_IEs (pvalue->u.rrcConnectionRequest_r8);

         stat = asn1PD_RRCConnectionRequest_r8_IEs (pctxt, pvalue->u.rrcConnectionRequest_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            RRCConnectionRequest_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_RRCConnectionRequest_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionRequest_criticalExtensions (
   RRCConnectionRequest_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionRequest (OSCTXT* pctxt, RRCConnectionRequest* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionRequest");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionRequest"));

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_RRCConnectionRequest_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionRequest (OSCTXT* pctxt, RRCConnectionRequest* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionRequest");

   /* decode root elements */
   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_RRCConnectionRequest_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionRequest (RRCConnectionRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_RRCConnectionRequest_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_UL_CCCH_MessageType_c1 (OSCTXT* pctxt, UL_CCCH_MessageType_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UL_CCCH_MessageType_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* rrcConnectionReestablishmentRequest */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishmentRequest");

         stat = asn1PE_RRCConnectionReestablishmentRequest (pctxt, pvalue->u.rrcConnectionReestablishmentRequest);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* rrcConnectionRequest */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionRequest");

         stat = asn1PE_RRCConnectionRequest (pctxt, pvalue->u.rrcConnectionRequest);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_CCCH_MessageType_c1 (OSCTXT* pctxt, UL_CCCH_MessageType_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rrcConnectionReestablishmentRequest */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishmentRequest");

         pvalue->u.rrcConnectionReestablishmentRequest
             = rtxMemAllocType (pctxt, RRCConnectionReestablishmentRequest);

         if (pvalue->u.rrcConnectionReestablishmentRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReestablishmentRequest (pvalue->u.rrcConnectionReestablishmentRequest);

         stat = asn1PD_RRCConnectionReestablishmentRequest (pctxt, pvalue->u.rrcConnectionReestablishmentRequest);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* rrcConnectionRequest */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionRequest");

         pvalue->u.rrcConnectionRequest = rtxMemAllocType (pctxt, 
            RRCConnectionRequest);

         if (pvalue->u.rrcConnectionRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionRequest (pvalue->u.rrcConnectionRequest);

         stat = asn1PD_RRCConnectionRequest (pctxt, pvalue->u.rrcConnectionRequest);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_UL_CCCH_MessageType_c1 (UL_CCCH_MessageType_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_UL_CCCH_MessageType_messageClassExtension (OSCTXT* pctxt, UL_CCCH_MessageType_messageClassExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UL_CCCH_MessageType_messageClassExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_CCCH_MessageType_messageClassExtension (OSCTXT* pctxt, UL_CCCH_MessageType_messageClassExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_UL_CCCH_MessageType (OSCTXT* pctxt, UL_CCCH_MessageType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CCCH-MessageType");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UL_CCCH_MessageType"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_UL_CCCH_MessageType_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* messageClassExtension */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "messageClassExtension");

         stat = asn1PE_UL_CCCH_MessageType_messageClassExtension (pctxt, pvalue->u.messageClassExtension);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_CCCH_MessageType (OSCTXT* pctxt, UL_CCCH_MessageType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CCCH-MessageType");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, UL_CCCH_MessageType_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UL_CCCH_MessageType_c1 (pvalue->u.c1);

         stat = asn1PD_UL_CCCH_MessageType_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* messageClassExtension */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "messageClassExtension");

         pvalue->u.messageClassExtension = rtxMemAllocTypeZ (pctxt, 
            UL_CCCH_MessageType_messageClassExtension);

         if (pvalue->u.messageClassExtension == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_UL_CCCH_MessageType_messageClassExtension (pctxt, pvalue->u.messageClassExtension);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UL_CCCH_MessageType (UL_CCCH_MessageType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_UL_CCCH_Message (OSCTXT* pctxt, UL_CCCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CCCH-Message");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UL_CCCH_Message"));

   /* encode message */

   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PE_UL_CCCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_CCCH_Message (OSCTXT* pctxt, UL_CCCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-CCCH-Message");

   /* decode root elements */
   /* decode message */
   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PD_UL_CCCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UL_CCCH_Message (UL_CCCH_Message* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_UL_CCCH_MessageType (&pvalue->message);
}

EXTERN int asn1PE_CSFBParametersRequestCDMA2000_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, CSFBParametersRequestCDMA2000_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFBParametersRequestCDMA2000_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFBParametersRequestCDMA2000_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, CSFBParametersRequestCDMA2000_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_CSFBParametersRequestCDMA2000_v8a0_IEs (OSCTXT* pctxt, CSFBParametersRequestCDMA2000_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSFBParametersRequestCDMA2000-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFBParametersRequestCDMA2000_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_CSFBParametersRequestCDMA2000_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFBParametersRequestCDMA2000_v8a0_IEs (OSCTXT* pctxt, CSFBParametersRequestCDMA2000_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "CSFBParametersRequestCDMA2000-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_CSFBParametersRequestCDMA2000_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CSFBParametersRequestCDMA2000_v8a0_IEs (
   CSFBParametersRequestCDMA2000_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_CSFBParametersRequestCDMA2000_r8_IEs (OSCTXT* pctxt, CSFBParametersRequestCDMA2000_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSFBParametersRequestCDMA2000-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFBParametersRequestCDMA2000_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_CSFBParametersRequestCDMA2000_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFBParametersRequestCDMA2000_r8_IEs (OSCTXT* pctxt, CSFBParametersRequestCDMA2000_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CSFBParametersRequestCDMA2000-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_CSFBParametersRequestCDMA2000_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CSFBParametersRequestCDMA2000_r8_IEs (
   CSFBParametersRequestCDMA2000_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CSFBParametersRequestCDMA2000_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_CSFBParametersRequestCDMA2000_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, CSFBParametersRequestCDMA2000_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFBParametersRequestCDMA2000_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFBParametersRequestCDMA2000_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, CSFBParametersRequestCDMA2000_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_CSFBParametersRequestCDMA2000_criticalExtensions (OSCTXT* pctxt, CSFBParametersRequestCDMA2000_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFBParametersRequestCDMA2000_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* csfbParametersRequestCDMA2000_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "csfbParametersRequestCDMA2000-r8");

         stat = asn1PE_CSFBParametersRequestCDMA2000_r8_IEs (pctxt, pvalue->u.csfbParametersRequestCDMA2000_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_CSFBParametersRequestCDMA2000_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFBParametersRequestCDMA2000_criticalExtensions (OSCTXT* pctxt, CSFBParametersRequestCDMA2000_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* csfbParametersRequestCDMA2000_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "csfbParametersRequestCDMA2000-r8");

         pvalue->u.csfbParametersRequestCDMA2000_r8 = rtxMemAllocType (pctxt, 
            CSFBParametersRequestCDMA2000_r8_IEs);

         if (pvalue->u.csfbParametersRequestCDMA2000_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CSFBParametersRequestCDMA2000_r8_IEs (pvalue->u.csfbParametersRequestCDMA2000_r8);

         stat = asn1PD_CSFBParametersRequestCDMA2000_r8_IEs (pctxt, pvalue->u.csfbParametersRequestCDMA2000_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            CSFBParametersRequestCDMA2000_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_CSFBParametersRequestCDMA2000_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_CSFBParametersRequestCDMA2000_criticalExtensions (
   CSFBParametersRequestCDMA2000_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_CSFBParametersRequestCDMA2000 (OSCTXT* pctxt, CSFBParametersRequestCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSFBParametersRequestCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSFBParametersRequestCDMA2000"));

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_CSFBParametersRequestCDMA2000_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSFBParametersRequestCDMA2000 (OSCTXT* pctxt, CSFBParametersRequestCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSFBParametersRequestCDMA2000");

   /* decode root elements */
   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_CSFBParametersRequestCDMA2000_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CSFBParametersRequestCDMA2000 (
   CSFBParametersRequestCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_CSFBParametersRequestCDMA2000_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_MeasResults_measResultServCell (OSCTXT* pctxt, MeasResults_measResultServCell* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResults_measResultServCell"));

   /* encode rsrpResult */

   RTXCTXTPUSHELEMNAME (pctxt, "rsrpResult");

   stat = asn1PE_RSRP_Range (pctxt, pvalue->rsrpResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rsrqResult */

   RTXCTXTPUSHELEMNAME (pctxt, "rsrqResult");

   stat = asn1PE_RSRQ_Range (pctxt, pvalue->rsrqResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResults_measResultServCell (OSCTXT* pctxt, MeasResults_measResultServCell* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode rsrpResult */
   RTXCTXTPUSHELEMNAME (pctxt, "rsrpResult");

   stat = asn1PD_RSRP_Range (pctxt, &pvalue->rsrpResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rsrqResult */
   RTXCTXTPUSHELEMNAME (pctxt, "rsrqResult");

   stat = asn1PD_RSRQ_Range (pctxt, &pvalue->rsrqResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_CellGlobalIdEUTRA (OSCTXT* pctxt, CellGlobalIdEUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellGlobalIdEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellGlobalIdEUTRA"));

   /* encode plmn_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "plmn-Identity");

   stat = asn1PE_PLMN_Identity (pctxt, &pvalue->plmn_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "cellIdentity");

   stat = asn1PE_CellIdentity (pctxt, pvalue->cellIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellGlobalIdEUTRA (OSCTXT* pctxt, CellGlobalIdEUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellGlobalIdEUTRA");

   /* decode root elements */
   /* decode plmn_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "plmn-Identity");

   stat = asn1PD_PLMN_Identity (pctxt, &pvalue->plmn_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "cellIdentity");

   stat = asn1PD_CellIdentity (pctxt, &pvalue->cellIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellGlobalIdEUTRA (CellGlobalIdEUTRA* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_PLMN_Identity (&pvalue->plmn_Identity);
   asn1Init_CellIdentity (&pvalue->cellIdentity);
}

EXTERN int asn1PE_PLMN_IdentityList2 (OSCTXT* pctxt, PLMN_IdentityList2* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMN-IdentityList2");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PLMN_IdentityList2"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(5), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PLMN-Identity", xx1);

      stat = asn1PE_PLMN_Identity (pctxt, ((PLMN_Identity*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PLMN_IdentityList2 (OSCTXT* pctxt, PLMN_IdentityList2* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMN-IdentityList2");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(5), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PLMN_Identity* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PLMN-Identity", xx1);

      rtxDListAllocNodeAndData (pctxt, PLMN_Identity, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PLMN_Identity (pdata);

      stat = asn1PD_PLMN_Identity (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PLMN_IdentityList2 (PLMN_IdentityList2* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_MeasResultEUTRA_cgi_Info (OSCTXT* pctxt, MeasResultEUTRA_cgi_Info* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultEUTRA_cgi_Info"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.plmn_IdentityListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cellGlobalId */

   RTXCTXTPUSHELEMNAME (pctxt, "cellGlobalId");

   stat = asn1PE_CellGlobalIdEUTRA (pctxt, &pvalue->cellGlobalId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode trackingAreaCode */

   RTXCTXTPUSHELEMNAME (pctxt, "trackingAreaCode");

   stat = asn1PE_TrackingAreaCode (pctxt, pvalue->trackingAreaCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode plmn_IdentityList */

   if (pvalue->m.plmn_IdentityListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "plmn-IdentityList");

      stat = asn1PE_PLMN_IdentityList2 (pctxt, &pvalue->plmn_IdentityList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultEUTRA_cgi_Info (OSCTXT* pctxt, MeasResultEUTRA_cgi_Info* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cellGlobalId */
   RTXCTXTPUSHELEMNAME (pctxt, "cellGlobalId");

   stat = asn1PD_CellGlobalIdEUTRA (pctxt, &pvalue->cellGlobalId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode trackingAreaCode */
   RTXCTXTPUSHELEMNAME (pctxt, "trackingAreaCode");

   stat = asn1PD_TrackingAreaCode (pctxt, &pvalue->trackingAreaCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode plmn_IdentityList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "plmn-IdentityList");

      pvalue->m.plmn_IdentityListPresent = 1;

      stat = asn1PD_PLMN_IdentityList2 (pctxt, &pvalue->plmn_IdentityList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_MeasResultEUTRA_cgi_Info (MeasResultEUTRA_cgi_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CellGlobalIdEUTRA (&pvalue->cellGlobalId);
   asn1Init_TrackingAreaCode (&pvalue->trackingAreaCode);
   asn1Init_PLMN_IdentityList2 (&pvalue->plmn_IdentityList);
}

EXTERN int asn1PE_AdditionalSI_Info_r9 (OSCTXT* pctxt, AdditionalSI_Info_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AdditionalSI-Info-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("AdditionalSI_Info_r9"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.csg_MemberStatus_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.csg_Identity_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode csg_MemberStatus_r9 */

   if (pvalue->m.csg_MemberStatus_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "csg-MemberStatus-r9");

      stat = asn1PE_AdditionalSI_Info_r9_csg_MemberStatus_r9 (pctxt, pvalue->csg_MemberStatus_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode csg_Identity_r9 */

   if (pvalue->m.csg_Identity_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "csg-Identity-r9");

      stat = asn1PE_CSG_Identity (pctxt, pvalue->csg_Identity_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AdditionalSI_Info_r9 (OSCTXT* pctxt, AdditionalSI_Info_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "AdditionalSI-Info-r9");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode csg_MemberStatus_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "csg-MemberStatus-r9");

      pvalue->m.csg_MemberStatus_r9Present = 1;

      stat = asn1PD_AdditionalSI_Info_r9_csg_MemberStatus_r9 (pctxt, &pvalue->csg_MemberStatus_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode csg_Identity_r9 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "csg-Identity-r9");

      pvalue->m.csg_Identity_r9Present = 1;

      stat = asn1PD_CSG_Identity (pctxt, &pvalue->csg_Identity_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_AdditionalSI_Info_r9 (AdditionalSI_Info_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CSG_Identity (&pvalue->csg_Identity_r9);
}

EXTERN int asn1PE_MeasResultEUTRA_measResult (OSCTXT* pctxt, MeasResultEUTRA_measResult* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultEUTRA_measResult"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m._v2ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rsrpResultPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rsrqResultPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rsrpResult */

   if (pvalue->m.rsrpResultPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rsrpResult");

      stat = asn1PE_RSRP_Range (pctxt, pvalue->rsrpResult);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode rsrqResult */

   if (pvalue->m.rsrqResultPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rsrqResult");

      stat = asn1PE_RSRQ_Range (pctxt, pvalue->rsrqResult);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v2ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m._v2ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.additionalSI_Info_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode additionalSI_Info_r9 */

         if (pvalue->m.additionalSI_Info_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "additionalSI-Info-r9");

            stat = asn1PE_AdditionalSI_Info_r9 (pctxt, &pvalue->additionalSI_Info_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultEUTRA_measResult (OSCTXT* pctxt, MeasResultEUTRA_measResult* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rsrpResult */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rsrpResult");

      pvalue->m.rsrpResultPresent = 1;

      stat = asn1PD_RSRP_Range (pctxt, &pvalue->rsrpResult);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rsrqResult */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rsrqResult");

      pvalue->m.rsrqResultPresent = 1;

      stat = asn1PD_RSRQ_Range (pctxt, &pvalue->rsrqResult);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m._v2ExtPresent = 1;
                        {
                           OSOCTET extoptbits[1];

                           stat = DEC_BIT (pctxt, &extoptbits[0]);
                           if (stat != 0)  {
                              rtxMemFreePtr (pctxt, poptbits);
                           }
                           if (extoptbits[0]) {
                              pvalue->m.additionalSI_Info_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "additionalSI-Info-r9");

                              stat = asn1PD_AdditionalSI_Info_r9 (pctxt, &pvalue->additionalSI_Info_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;

                        /* Coverity 55337 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

void asn1Init_MeasResultEUTRA_measResult (MeasResultEUTRA_measResult* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_AdditionalSI_Info_r9 (&pvalue->additionalSI_Info_r9);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_MeasResultEUTRA (OSCTXT* pctxt, MeasResultEUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultEUTRA"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cgi_InfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode physCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PE_PhysCellId (pctxt, pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cgi_Info */

   if (pvalue->m.cgi_InfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cgi-Info");

      stat = asn1PE_MeasResultEUTRA_cgi_Info (pctxt, &pvalue->cgi_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode measResult */

   RTXCTXTPUSHELEMNAME (pctxt, "measResult");

   stat = asn1PE_MeasResultEUTRA_measResult (pctxt, &pvalue->measResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultEUTRA (OSCTXT* pctxt, MeasResultEUTRA* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultEUTRA");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode physCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PD_PhysCellId (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cgi_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cgi-Info");

      pvalue->m.cgi_InfoPresent = 1;

      stat = asn1PD_MeasResultEUTRA_cgi_Info (pctxt, &pvalue->cgi_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measResult */
   RTXCTXTPUSHELEMNAME (pctxt, "measResult");

   stat = asn1PD_MeasResultEUTRA_measResult (pctxt, &pvalue->measResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResultEUTRA (MeasResultEUTRA* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_MeasResultEUTRA_cgi_Info (&pvalue->cgi_Info);
   asn1Init_MeasResultEUTRA_measResult (&pvalue->measResult);
}

EXTERN int asn1PE_MeasResultListEUTRA (OSCTXT* pctxt, MeasResultListEUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultListEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultListEUTRA"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasResultEUTRA", xx1);

      stat = asn1PE_MeasResultEUTRA (pctxt, ((MeasResultEUTRA*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultListEUTRA (OSCTXT* pctxt, MeasResultListEUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultListEUTRA");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MeasResultEUTRA* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasResultEUTRA", xx1);

      rtxDListAllocNodeAndData (pctxt, MeasResultEUTRA, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MeasResultEUTRA (pdata);

      stat = asn1PD_MeasResultEUTRA (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResultListEUTRA (MeasResultListEUTRA* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_MeasResultUTRA_physCellId (OSCTXT* pctxt, MeasResultUTRA_physCellId* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultUTRA_physCellId"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* fdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         stat = asn1PE_PhysCellIdUTRA_FDD (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* tdd */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         stat = asn1PE_PhysCellIdUTRA_TDD (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultUTRA_physCellId (OSCTXT* pctxt, MeasResultUTRA_physCellId* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         stat = asn1PD_PhysCellIdUTRA_FDD (pctxt, &pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         stat = asn1PD_PhysCellIdUTRA_TDD (pctxt, &pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_MeasResultUTRA_physCellId (MeasResultUTRA_physCellId* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_CellGlobalIdUTRA (OSCTXT* pctxt, CellGlobalIdUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellGlobalIdUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellGlobalIdUTRA"));

   /* encode plmn_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "plmn-Identity");

   stat = asn1PE_PLMN_Identity (pctxt, &pvalue->plmn_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "cellIdentity");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(28), OSUINTCONST(28), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->cellIdentity, OSUINTCONST(28), OSUINTCONST(28));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellGlobalIdUTRA (OSCTXT* pctxt, CellGlobalIdUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellGlobalIdUTRA");

   /* decode root elements */
   /* decode plmn_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "plmn-Identity");

   stat = asn1PD_PLMN_Identity (pctxt, &pvalue->plmn_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "cellIdentity");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(28), OSUINTCONST(28), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->cellIdentity
      , OSUINTCONST(28), OSUINTCONST(28));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellGlobalIdUTRA (CellGlobalIdUTRA* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_PLMN_Identity (&pvalue->plmn_Identity);
   pvalue->cellIdentity.numbits = 0;
}

EXTERN int asn1PE_MeasResultUTRA_cgi_Info (OSCTXT* pctxt, MeasResultUTRA_cgi_Info* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultUTRA_cgi_Info"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.locationAreaCodePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.routingAreaCodePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.plmn_IdentityListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cellGlobalId */

   RTXCTXTPUSHELEMNAME (pctxt, "cellGlobalId");

   stat = asn1PE_CellGlobalIdUTRA (pctxt, &pvalue->cellGlobalId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode locationAreaCode */

   if (pvalue->m.locationAreaCodePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "locationAreaCode");

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

      stat = pe_BitString32 (pctxt, &pvalue->locationAreaCode, OSUINTCONST(16), OSUINTCONST(16));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode routingAreaCode */

   if (pvalue->m.routingAreaCodePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "routingAreaCode");

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

      stat = pe_BitString32 (pctxt, &pvalue->routingAreaCode, OSUINTCONST(8), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode plmn_IdentityList */

   if (pvalue->m.plmn_IdentityListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "plmn-IdentityList");

      stat = asn1PE_PLMN_IdentityList2 (pctxt, &pvalue->plmn_IdentityList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultUTRA_cgi_Info (OSCTXT* pctxt, MeasResultUTRA_cgi_Info* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cellGlobalId */
   RTXCTXTPUSHELEMNAME (pctxt, "cellGlobalId");

   stat = asn1PD_CellGlobalIdUTRA (pctxt, &pvalue->cellGlobalId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode locationAreaCode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "locationAreaCode");

      pvalue->m.locationAreaCodePresent = 1;

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

      stat = pd_BitString32 (pctxt, &pvalue->locationAreaCode
         , OSUINTCONST(16), OSUINTCONST(16));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode routingAreaCode */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "routingAreaCode");

      pvalue->m.routingAreaCodePresent = 1;

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

      stat = pd_BitString32 (pctxt, &pvalue->routingAreaCode
         , OSUINTCONST(8), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode plmn_IdentityList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "plmn-IdentityList");

      pvalue->m.plmn_IdentityListPresent = 1;

      stat = asn1PD_PLMN_IdentityList2 (pctxt, &pvalue->plmn_IdentityList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_MeasResultUTRA_cgi_Info (MeasResultUTRA_cgi_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CellGlobalIdUTRA (&pvalue->cellGlobalId);
   pvalue->locationAreaCode.numbits = 0;
   pvalue->routingAreaCode.numbits = 0;
   asn1Init_PLMN_IdentityList2 (&pvalue->plmn_IdentityList);
}

EXTERN int asn1PE_MeasResultUTRA_measResult (OSCTXT* pctxt, MeasResultUTRA_measResult* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultUTRA_measResult"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m._v2ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.utra_RSCPPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.utra_EcN0Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode utra_RSCP */

   if (pvalue->m.utra_RSCPPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "utra-RSCP");

      if ( (pvalue->utra_RSCP >= OSINTCONST(-5) && pvalue->utra_RSCP
          <= OSINTCONST(91)) ) {
         stat = pe_ConsInteger (pctxt, pvalue->utra_RSCP, OSINTCONST(-5), OSINTCONST(91));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddIntParm (pctxt, pvalue->utra_RSCP);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode utra_EcN0 */

   if (pvalue->m.utra_EcN0Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "utra-EcN0");

      if ( (pvalue->utra_EcN0 <= OSUINTCONST(49)) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->utra_EcN0, OSUINTCONST(0), OSUINTCONST(49));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->utra_EcN0);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v2ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m._v2ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.additionalSI_Info_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode additionalSI_Info_r9 */

         if (pvalue->m.additionalSI_Info_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "additionalSI-Info-r9");

            stat = asn1PE_AdditionalSI_Info_r9 (pctxt, &pvalue->additionalSI_Info_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultUTRA_measResult (OSCTXT* pctxt, MeasResultUTRA_measResult* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode utra_RSCP */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "utra-RSCP");

      pvalue->m.utra_RSCPPresent = 1;

      stat = pd_ConsInt8 (pctxt, &pvalue->utra_RSCP, OSINTCONST(-5), OSINTCONST(91));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode utra_EcN0 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "utra-EcN0");

      pvalue->m.utra_EcN0Present = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->utra_EcN0, OSUINTCONST(0), OSUINTCONST(49));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m._v2ExtPresent = 1;
                        {
                           OSOCTET extoptbits[1];

                           stat = DEC_BIT (pctxt, &extoptbits[0]);
                           if (stat != 0)  {
                              rtxMemFreePtr (pctxt, poptbits);
                           }
                           if (extoptbits[0]) {
                              pvalue->m.additionalSI_Info_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "additionalSI-Info-r9");

                              stat = asn1PD_AdditionalSI_Info_r9 (pctxt, &pvalue->additionalSI_Info_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;
                        /* Coverity 55336 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

void asn1Init_MeasResultUTRA_measResult (MeasResultUTRA_measResult* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_AdditionalSI_Info_r9 (&pvalue->additionalSI_Info_r9);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_MeasResultUTRA (OSCTXT* pctxt, MeasResultUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultUTRA"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cgi_InfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode physCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PE_MeasResultUTRA_physCellId (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cgi_Info */

   if (pvalue->m.cgi_InfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cgi-Info");

      stat = asn1PE_MeasResultUTRA_cgi_Info (pctxt, &pvalue->cgi_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode measResult */

   RTXCTXTPUSHELEMNAME (pctxt, "measResult");

   stat = asn1PE_MeasResultUTRA_measResult (pctxt, &pvalue->measResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultUTRA (OSCTXT* pctxt, MeasResultUTRA* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultUTRA");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode physCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PD_MeasResultUTRA_physCellId (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cgi_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cgi-Info");

      pvalue->m.cgi_InfoPresent = 1;

      stat = asn1PD_MeasResultUTRA_cgi_Info (pctxt, &pvalue->cgi_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measResult */
   RTXCTXTPUSHELEMNAME (pctxt, "measResult");

   stat = asn1PD_MeasResultUTRA_measResult (pctxt, &pvalue->measResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResultUTRA (MeasResultUTRA* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_MeasResultUTRA_physCellId (&pvalue->physCellId);
   asn1Init_MeasResultUTRA_cgi_Info (&pvalue->cgi_Info);
   asn1Init_MeasResultUTRA_measResult (&pvalue->measResult);
}

EXTERN int asn1PE_MeasResultListUTRA (OSCTXT* pctxt, MeasResultListUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultListUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultListUTRA"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasResultUTRA", xx1);

      stat = asn1PE_MeasResultUTRA (pctxt, ((MeasResultUTRA*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultListUTRA (OSCTXT* pctxt, MeasResultListUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultListUTRA");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MeasResultUTRA* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasResultUTRA", xx1);

      rtxDListAllocNodeAndData (pctxt, MeasResultUTRA, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MeasResultUTRA (pdata);

      stat = asn1PD_MeasResultUTRA (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResultListUTRA (MeasResultListUTRA* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_CellGlobalIdGERAN (OSCTXT* pctxt, CellGlobalIdGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellGlobalIdGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellGlobalIdGERAN"));

   /* encode plmn_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "plmn-Identity");

   stat = asn1PE_PLMN_Identity (pctxt, &pvalue->plmn_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode locationAreaCode */

   RTXCTXTPUSHELEMNAME (pctxt, "locationAreaCode");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->locationAreaCode, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "cellIdentity");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->cellIdentity, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellGlobalIdGERAN (OSCTXT* pctxt, CellGlobalIdGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellGlobalIdGERAN");

   /* decode root elements */
   /* decode plmn_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "plmn-Identity");

   stat = asn1PD_PLMN_Identity (pctxt, &pvalue->plmn_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode locationAreaCode */
   RTXCTXTPUSHELEMNAME (pctxt, "locationAreaCode");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->locationAreaCode
      , OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "cellIdentity");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->cellIdentity
      , OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellGlobalIdGERAN (CellGlobalIdGERAN* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_PLMN_Identity (&pvalue->plmn_Identity);
   pvalue->locationAreaCode.numbits = 0;
   pvalue->cellIdentity.numbits = 0;
}

EXTERN int asn1PE_MeasResultGERAN_cgi_Info (OSCTXT* pctxt, MeasResultGERAN_cgi_Info* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultGERAN_cgi_Info"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.routingAreaCodePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cellGlobalId */

   RTXCTXTPUSHELEMNAME (pctxt, "cellGlobalId");

   stat = asn1PE_CellGlobalIdGERAN (pctxt, &pvalue->cellGlobalId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode routingAreaCode */

   if (pvalue->m.routingAreaCodePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "routingAreaCode");

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

      stat = pe_BitString32 (pctxt, &pvalue->routingAreaCode, OSUINTCONST(8), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultGERAN_cgi_Info (OSCTXT* pctxt, MeasResultGERAN_cgi_Info* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cellGlobalId */
   RTXCTXTPUSHELEMNAME (pctxt, "cellGlobalId");

   stat = asn1PD_CellGlobalIdGERAN (pctxt, &pvalue->cellGlobalId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode routingAreaCode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "routingAreaCode");

      pvalue->m.routingAreaCodePresent = 1;

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

      stat = pd_BitString32 (pctxt, &pvalue->routingAreaCode
         , OSUINTCONST(8), OSUINTCONST(8));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_MeasResultGERAN_cgi_Info (MeasResultGERAN_cgi_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CellGlobalIdGERAN (&pvalue->cellGlobalId);
   pvalue->routingAreaCode.numbits = 0;
}

EXTERN int asn1PE_MeasResultGERAN_measResult (OSCTXT* pctxt, MeasResultGERAN_measResult* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultGERAN_measResult"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rssi */

   RTXCTXTPUSHELEMNAME (pctxt, "rssi");

   if ( (pvalue->rssi <= OSUINTCONST(63)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->rssi, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->rssi);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultGERAN_measResult (OSCTXT* pctxt, MeasResultGERAN_measResult* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode rssi */
   RTXCTXTPUSHELEMNAME (pctxt, "rssi");

   stat = pd_ConsUInt8 (pctxt, &pvalue->rssi, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

void asn1Init_MeasResultGERAN_measResult (MeasResultGERAN_measResult* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_MeasResultGERAN (OSCTXT* pctxt, MeasResultGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultGERAN"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cgi_InfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode carrierFreq */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PE_CarrierFreqGERAN (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode physCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PE_PhysCellIdGERAN (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cgi_Info */

   if (pvalue->m.cgi_InfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cgi-Info");

      stat = asn1PE_MeasResultGERAN_cgi_Info (pctxt, &pvalue->cgi_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode measResult */

   RTXCTXTPUSHELEMNAME (pctxt, "measResult");

   stat = asn1PE_MeasResultGERAN_measResult (pctxt, &pvalue->measResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultGERAN (OSCTXT* pctxt, MeasResultGERAN* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultGERAN");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode carrierFreq */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PD_CarrierFreqGERAN (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode physCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PD_PhysCellIdGERAN (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cgi_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cgi-Info");

      pvalue->m.cgi_InfoPresent = 1;

      stat = asn1PD_MeasResultGERAN_cgi_Info (pctxt, &pvalue->cgi_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measResult */
   RTXCTXTPUSHELEMNAME (pctxt, "measResult");

   stat = asn1PD_MeasResultGERAN_measResult (pctxt, &pvalue->measResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResultGERAN (MeasResultGERAN* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PhysCellIdGERAN (&pvalue->physCellId);
   asn1Init_MeasResultGERAN_cgi_Info (&pvalue->cgi_Info);
   asn1Init_MeasResultGERAN_measResult (&pvalue->measResult);
}

EXTERN int asn1PE_MeasResultListGERAN (OSCTXT* pctxt, MeasResultListGERAN* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultListGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultListGERAN"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasResultGERAN", xx1);

      stat = asn1PE_MeasResultGERAN (pctxt, ((MeasResultGERAN*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultListGERAN (OSCTXT* pctxt, MeasResultListGERAN* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultListGERAN");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MeasResultGERAN* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasResultGERAN", xx1);

      rtxDListAllocNodeAndData (pctxt, MeasResultGERAN, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MeasResultGERAN (pdata);

      stat = asn1PD_MeasResultGERAN (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResultListGERAN (MeasResultListGERAN* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_CellGlobalIdCDMA2000 (OSCTXT* pctxt, CellGlobalIdCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellGlobalIdCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellGlobalIdCDMA2000"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* cellGlobalId1XRTT */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "cellGlobalId1XRTT");

         stat = asn1PE_CellGlobalIdCDMA2000_cellGlobalId1XRTT (pctxt, pvalue->u.cellGlobalId1XRTT);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* cellGlobalIdHRPD */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "cellGlobalIdHRPD");

         stat = asn1PE_CellGlobalIdCDMA2000_cellGlobalIdHRPD (pctxt, pvalue->u.cellGlobalIdHRPD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellGlobalIdCDMA2000 (OSCTXT* pctxt, CellGlobalIdCDMA2000* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "CellGlobalIdCDMA2000");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* cellGlobalId1XRTT */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "cellGlobalId1XRTT");

         pvalue->u.cellGlobalId1XRTT = rtxMemAllocType (pctxt, 
            CellGlobalIdCDMA2000_cellGlobalId1XRTT);

         if (pvalue->u.cellGlobalId1XRTT == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CellGlobalIdCDMA2000_cellGlobalId1XRTT (pvalue->u.cellGlobalId1XRTT);

         stat = asn1PD_CellGlobalIdCDMA2000_cellGlobalId1XRTT (pctxt, pvalue->u.cellGlobalId1XRTT);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* cellGlobalIdHRPD */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "cellGlobalIdHRPD");

         pvalue->u.cellGlobalIdHRPD = rtxMemAllocType (pctxt, 
            CellGlobalIdCDMA2000_cellGlobalIdHRPD);

         if (pvalue->u.cellGlobalIdHRPD == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CellGlobalIdCDMA2000_cellGlobalIdHRPD (pvalue->u.cellGlobalIdHRPD);

         stat = asn1PD_CellGlobalIdCDMA2000_cellGlobalIdHRPD (pctxt, pvalue->u.cellGlobalIdHRPD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellGlobalIdCDMA2000 (CellGlobalIdCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MeasResultCDMA2000_measResult (OSCTXT* pctxt, MeasResultCDMA2000_measResult* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultCDMA2000_measResult"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.pilotPnPhasePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pilotPnPhase */

   if (pvalue->m.pilotPnPhasePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pilotPnPhase");

      if ( (pvalue->pilotPnPhase <= OSUINTCONST(32767)) ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->pilotPnPhase, OSUINTCONST(0), OSUINTCONST(32767));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->pilotPnPhase);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode pilotStrength */

   RTXCTXTPUSHELEMNAME (pctxt, "pilotStrength");

   if ( (pvalue->pilotStrength <= OSUINTCONST(63)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->pilotStrength, OSUINTCONST(0), OSUINTCONST(63));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->pilotStrength);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultCDMA2000_measResult (OSCTXT* pctxt, MeasResultCDMA2000_measResult* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pilotPnPhase */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pilotPnPhase");

      pvalue->m.pilotPnPhasePresent = 1;

      stat = pd_ConsUInt16 (pctxt, &pvalue->pilotPnPhase, OSUINTCONST(0), OSUINTCONST(32767));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pilotStrength */
   RTXCTXTPUSHELEMNAME (pctxt, "pilotStrength");

   stat = pd_ConsUInt8 (pctxt, &pvalue->pilotStrength, OSUINTCONST(0), OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

void asn1Init_MeasResultCDMA2000_measResult (
   MeasResultCDMA2000_measResult* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_MeasResultCDMA2000 (OSCTXT* pctxt, MeasResultCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultCDMA2000"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cgi_InfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode physCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PE_PhysCellIdCDMA2000 (pctxt, pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cgi_Info */

   if (pvalue->m.cgi_InfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cgi-Info");

      stat = asn1PE_CellGlobalIdCDMA2000 (pctxt, &pvalue->cgi_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode measResult */

   RTXCTXTPUSHELEMNAME (pctxt, "measResult");

   stat = asn1PE_MeasResultCDMA2000_measResult (pctxt, &pvalue->measResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultCDMA2000 (OSCTXT* pctxt, MeasResultCDMA2000* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultCDMA2000");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode physCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PD_PhysCellIdCDMA2000 (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cgi_Info */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cgi-Info");

      pvalue->m.cgi_InfoPresent = 1;

      stat = asn1PD_CellGlobalIdCDMA2000 (pctxt, &pvalue->cgi_Info);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measResult */
   RTXCTXTPUSHELEMNAME (pctxt, "measResult");

   stat = asn1PD_MeasResultCDMA2000_measResult (pctxt, &pvalue->measResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResultCDMA2000 (MeasResultCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CellGlobalIdCDMA2000 (&pvalue->cgi_Info);
   asn1Init_MeasResultCDMA2000_measResult (&pvalue->measResult);
}

EXTERN int asn1PE_MeasResultListCDMA2000 (OSCTXT* pctxt, MeasResultListCDMA2000* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultListCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultListCDMA2000"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasResultCDMA2000", xx1);

      stat = asn1PE_MeasResultCDMA2000 (pctxt, ((MeasResultCDMA2000*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultListCDMA2000 (OSCTXT* pctxt, MeasResultListCDMA2000* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultListCDMA2000");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MeasResultCDMA2000* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasResultCDMA2000", xx1);

      rtxDListAllocNodeAndData (pctxt, MeasResultCDMA2000, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MeasResultCDMA2000 (pdata);

      stat = asn1PD_MeasResultCDMA2000 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResultListCDMA2000 (MeasResultListCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_MeasResultsCDMA2000 (OSCTXT* pctxt, MeasResultsCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultsCDMA2000");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultsCDMA2000"));

   /* encode preRegistrationStatusHRPD */

   RTXCTXTPUSHELEMNAME (pctxt, "preRegistrationStatusHRPD");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->preRegistrationStatusHRPD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode measResultListCDMA2000 */

   RTXCTXTPUSHELEMNAME (pctxt, "measResultListCDMA2000");

   stat = asn1PE_MeasResultListCDMA2000 (pctxt, &pvalue->measResultListCDMA2000);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultsCDMA2000 (OSCTXT* pctxt, MeasResultsCDMA2000* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultsCDMA2000");

   /* decode root elements */
   /* decode preRegistrationStatusHRPD */
   RTXCTXTPUSHELEMNAME (pctxt, "preRegistrationStatusHRPD");

   stat = DEC_BIT (pctxt, &pvalue->preRegistrationStatusHRPD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measResultListCDMA2000 */
   RTXCTXTPUSHELEMNAME (pctxt, "measResultListCDMA2000");

   stat = asn1PD_MeasResultListCDMA2000 (pctxt, &pvalue->measResultListCDMA2000);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResultsCDMA2000 (MeasResultsCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_MeasResultListCDMA2000 (&pvalue->measResultListCDMA2000);
}

EXTERN int asn1PE_MeasResults_measResultNeighCells (OSCTXT* pctxt, MeasResults_measResultNeighCells* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResults_measResultNeighCells"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 4);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* measResultListEUTRA */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "measResultListEUTRA");

            stat = asn1PE_MeasResultListEUTRA (pctxt, pvalue->u.measResultListEUTRA);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* measResultListUTRA */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "measResultListUTRA");

            stat = asn1PE_MeasResultListUTRA (pctxt, pvalue->u.measResultListUTRA);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* measResultListGERAN */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "measResultListGERAN");

            stat = asn1PE_MeasResultListGERAN (pctxt, pvalue->u.measResultListGERAN);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* measResultsCDMA2000 */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "measResultsCDMA2000");

            stat = asn1PE_MeasResultsCDMA2000 (pctxt, pvalue->u.measResultsCDMA2000);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResults_measResultNeighCells (OSCTXT* pctxt, MeasResults_measResultNeighCells* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* measResultListEUTRA */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "measResultListEUTRA");

            pvalue->u.measResultListEUTRA = rtxMemAllocType (pctxt, 
               MeasResultListEUTRA);

            if (pvalue->u.measResultListEUTRA == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MeasResultListEUTRA (pvalue->u.measResultListEUTRA);

            stat = asn1PD_MeasResultListEUTRA (pctxt, pvalue->u.measResultListEUTRA);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* measResultListUTRA */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "measResultListUTRA");

            pvalue->u.measResultListUTRA = rtxMemAllocType (pctxt, 
               MeasResultListUTRA);

            if (pvalue->u.measResultListUTRA == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MeasResultListUTRA (pvalue->u.measResultListUTRA);

            stat = asn1PD_MeasResultListUTRA (pctxt, pvalue->u.measResultListUTRA);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* measResultListGERAN */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "measResultListGERAN");

            pvalue->u.measResultListGERAN = rtxMemAllocType (pctxt, 
               MeasResultListGERAN);

            if (pvalue->u.measResultListGERAN == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MeasResultListGERAN (pvalue->u.measResultListGERAN);

            stat = asn1PD_MeasResultListGERAN (pctxt, pvalue->u.measResultListGERAN);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* measResultsCDMA2000 */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "measResultsCDMA2000");

            pvalue->u.measResultsCDMA2000 = rtxMemAllocType (pctxt, 
               MeasResultsCDMA2000);

            if (pvalue->u.measResultsCDMA2000 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MeasResultsCDMA2000 (pvalue->u.measResultsCDMA2000);

            stat = asn1PD_MeasResultsCDMA2000 (pctxt, pvalue->u.measResultsCDMA2000);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

void asn1Init_MeasResults_measResultNeighCells (
   MeasResults_measResultNeighCells* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MeasResultForECID_r9 (OSCTXT* pctxt, MeasResultForECID_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultForECID-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultForECID_r9"));

   /* encode ue_RxTxTimeDiffResult_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "ue-RxTxTimeDiffResult-r9");

   if ( (pvalue->ue_RxTxTimeDiffResult_r9 <= OSUINTCONST(4095)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ue_RxTxTimeDiffResult_r9, OSUINTCONST(0), OSUINTCONST(4095));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ue_RxTxTimeDiffResult_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode currentSFN_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "currentSFN-r9");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(10), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->currentSFN_r9, OSUINTCONST(10), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultForECID_r9 (OSCTXT* pctxt, MeasResultForECID_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultForECID-r9");

   /* decode root elements */
   /* decode ue_RxTxTimeDiffResult_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "ue-RxTxTimeDiffResult-r9");

   stat = pd_ConsUInt16 (pctxt, &pvalue->ue_RxTxTimeDiffResult_r9, OSUINTCONST(0), OSUINTCONST(4095));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode currentSFN_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "currentSFN-r9");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(10), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->currentSFN_r9
      , OSUINTCONST(10), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResultForECID_r9 (MeasResultForECID_r9* pvalue)
{
   if (0 == pvalue) return;
   pvalue->currentSFN_r9.numbits = 0;
}

EXTERN int asn1PE_MeasResults (OSCTXT* pctxt, MeasResults* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResults");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResults"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m._v2ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measResultNeighCellsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measId */

   RTXCTXTPUSHELEMNAME (pctxt, "measId");

   stat = asn1PE_MeasId (pctxt, pvalue->measId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode measResultServCell */

   RTXCTXTPUSHELEMNAME (pctxt, "measResultServCell");

   stat = asn1PE_MeasResults_measResultServCell (pctxt, &pvalue->measResultServCell);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode measResultNeighCells */

   if (pvalue->m.measResultNeighCellsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "measResultNeighCells");

      stat = asn1PE_MeasResults_measResultNeighCells (pctxt, &pvalue->measResultNeighCells);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v2ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m._v2ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measResultForECID_r9Present);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode measResultForECID_r9 */

         if (pvalue->m.measResultForECID_r9Present) {
            RTXCTXTPUSHELEMNAME (pctxt, "measResultForECID-r9");

            stat = asn1PE_MeasResultForECID_r9 (pctxt, &pvalue->measResultForECID_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResults (OSCTXT* pctxt, MeasResults* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResults");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode measId */
   RTXCTXTPUSHELEMNAME (pctxt, "measId");

   stat = asn1PD_MeasId (pctxt, &pvalue->measId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measResultServCell */
   RTXCTXTPUSHELEMNAME (pctxt, "measResultServCell");

   stat = asn1PD_MeasResults_measResultServCell (pctxt, &pvalue->measResultServCell);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measResultNeighCells */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measResultNeighCells");

      pvalue->m.measResultNeighCellsPresent = 1;

      stat = asn1PD_MeasResults_measResultNeighCells (pctxt, &pvalue->measResultNeighCells);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m._v2ExtPresent = 1;
                        {
                           OSOCTET extoptbits[1];

                           stat = DEC_BIT (pctxt, &extoptbits[0]);
                           if (stat != 0)  {
                              rtxMemFreePtr (pctxt, poptbits);
                           }
                           if (extoptbits[0]) {
                              pvalue->m.measResultForECID_r9Present = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "measResultForECID-r9");

                              stat = asn1PD_MeasResultForECID_r9 (pctxt, &pvalue->measResultForECID_r9);

                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                        }
                        break;
                        /* Coverity 55335 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResults (MeasResults* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_MeasResults_measResultNeighCells (&pvalue->measResultNeighCells);
   asn1Init_MeasResultForECID_r9 (&pvalue->measResultForECID_r9);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_MeasurementReport_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, MeasurementReport_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasurementReport_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasurementReport_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, MeasurementReport_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_MeasurementReport_v8a0_IEs (OSCTXT* pctxt, MeasurementReport_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementReport-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasurementReport_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_MeasurementReport_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasurementReport_v8a0_IEs (OSCTXT* pctxt, MeasurementReport_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementReport-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_MeasurementReport_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasurementReport_v8a0_IEs (MeasurementReport_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_MeasurementReport_r8_IEs (OSCTXT* pctxt, MeasurementReport_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementReport-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasurementReport_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measResults */

   RTXCTXTPUSHELEMNAME (pctxt, "measResults");

   stat = asn1PE_MeasResults (pctxt, &pvalue->measResults);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_MeasurementReport_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasurementReport_r8_IEs (OSCTXT* pctxt, MeasurementReport_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementReport-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode measResults */
   RTXCTXTPUSHELEMNAME (pctxt, "measResults");

   stat = asn1PD_MeasResults (pctxt, &pvalue->measResults);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_MeasurementReport_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasurementReport_r8_IEs (MeasurementReport_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_MeasResults (&pvalue->measResults);
   asn1Init_MeasurementReport_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_MeasurementReport_criticalExtensions_c1 (OSCTXT* pctxt, MeasurementReport_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasurementReport_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* measurementReport_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "measurementReport-r8");

         stat = asn1PE_MeasurementReport_r8_IEs (pctxt, pvalue->u.measurementReport_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare7 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare6 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare5 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare4 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasurementReport_criticalExtensions_c1 (OSCTXT* pctxt, MeasurementReport_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* measurementReport_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "measurementReport-r8");

         pvalue->u.measurementReport_r8 = rtxMemAllocType (pctxt, 
            MeasurementReport_r8_IEs);

         if (pvalue->u.measurementReport_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MeasurementReport_r8_IEs (pvalue->u.measurementReport_r8);

         stat = asn1PD_MeasurementReport_r8_IEs (pctxt, pvalue->u.measurementReport_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare7 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare6 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare5 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare4 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_MeasurementReport_criticalExtensions_c1 (
   MeasurementReport_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MeasurementReport_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, MeasurementReport_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasurementReport_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasurementReport_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, MeasurementReport_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_MeasurementReport_criticalExtensions (OSCTXT* pctxt, MeasurementReport_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasurementReport_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_MeasurementReport_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_MeasurementReport_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasurementReport_criticalExtensions (OSCTXT* pctxt, MeasurementReport_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            MeasurementReport_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MeasurementReport_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_MeasurementReport_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            MeasurementReport_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_MeasurementReport_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_MeasurementReport_criticalExtensions (
   MeasurementReport_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_MeasurementReport (OSCTXT* pctxt, MeasurementReport* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementReport");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasurementReport"));

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_MeasurementReport_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasurementReport (OSCTXT* pctxt, MeasurementReport* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementReport");

   /* decode root elements */
   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_MeasurementReport_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasurementReport (MeasurementReport* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_MeasurementReport_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_RRCConnectionReconfigurationComplete_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionReconfigurationComplete_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfigurationComplete_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfigurationComplete_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionReconfigurationComplete_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionReconfigurationComplete_v8a0_IEs (OSCTXT* pctxt, RRCConnectionReconfigurationComplete_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReconfigurationComplete-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfigurationComplete_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionReconfigurationComplete_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfigurationComplete_v8a0_IEs (OSCTXT* pctxt, RRCConnectionReconfigurationComplete_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReconfigurationComplete-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionReconfigurationComplete_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReconfigurationComplete_v8a0_IEs (
   RRCConnectionReconfigurationComplete_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_RRCConnectionReconfigurationComplete_r8_IEs (OSCTXT* pctxt, RRCConnectionReconfigurationComplete_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReconfigurationComplete-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfigurationComplete_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionReconfigurationComplete_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfigurationComplete_r8_IEs (OSCTXT* pctxt, RRCConnectionReconfigurationComplete_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReconfigurationComplete-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionReconfigurationComplete_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReconfigurationComplete_r8_IEs (
   RRCConnectionReconfigurationComplete_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RRCConnectionReconfigurationComplete_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_RRCConnectionReconfigurationComplete_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionReconfigurationComplete_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfigurationComplete_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfigurationComplete_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionReconfigurationComplete_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionReconfigurationComplete_criticalExtensions (OSCTXT* pctxt, RRCConnectionReconfigurationComplete_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfigurationComplete_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* rrcConnectionReconfigurationComplete_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReconfigurationComplete-r8");

         stat = asn1PE_RRCConnectionReconfigurationComplete_r8_IEs (pctxt, pvalue->u.rrcConnectionReconfigurationComplete_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_RRCConnectionReconfigurationComplete_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfigurationComplete_criticalExtensions (OSCTXT* pctxt, RRCConnectionReconfigurationComplete_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rrcConnectionReconfigurationComplete_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReconfigurationComplete-r8");

         pvalue->u.rrcConnectionReconfigurationComplete_r8
             = rtxMemAllocType (pctxt, 
            RRCConnectionReconfigurationComplete_r8_IEs);

         if (pvalue->u.rrcConnectionReconfigurationComplete_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReconfigurationComplete_r8_IEs (pvalue->u.rrcConnectionReconfigurationComplete_r8);

         stat = asn1PD_RRCConnectionReconfigurationComplete_r8_IEs (pctxt, pvalue->u.rrcConnectionReconfigurationComplete_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            RRCConnectionReconfigurationComplete_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_RRCConnectionReconfigurationComplete_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionReconfigurationComplete_criticalExtensions (
   RRCConnectionReconfigurationComplete_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionReconfigurationComplete (OSCTXT* pctxt, RRCConnectionReconfigurationComplete* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReconfigurationComplete");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReconfigurationComplete"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_RRCConnectionReconfigurationComplete_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReconfigurationComplete (OSCTXT* pctxt, RRCConnectionReconfigurationComplete* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReconfigurationComplete");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_RRCConnectionReconfigurationComplete_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReconfigurationComplete (
   RRCConnectionReconfigurationComplete* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_RRCConnectionReconfigurationComplete_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_RRCConnectionReestablishmentComplete_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionReestablishmentComplete_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentComplete_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentComplete_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionReestablishmentComplete_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionReestablishmentComplete_v8a0_IEs (OSCTXT* pctxt, RRCConnectionReestablishmentComplete_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentComplete-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentComplete_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionReestablishmentComplete_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentComplete_v8a0_IEs (OSCTXT* pctxt, RRCConnectionReestablishmentComplete_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentComplete-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionReestablishmentComplete_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReestablishmentComplete_v8a0_IEs (
   RRCConnectionReestablishmentComplete_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_RRCConnectionReestablishmentComplete_v920_IEs (OSCTXT* pctxt, RRCConnectionReestablishmentComplete_v920_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentComplete-v920-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentComplete_v920_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rlf_InfoAvailable_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rlf_InfoAvailable_r9 */

   if (pvalue->m.rlf_InfoAvailable_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlf-InfoAvailable-r9");

      stat = asn1PE_RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9 (pctxt, pvalue->rlf_InfoAvailable_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionReestablishmentComplete_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentComplete_v920_IEs (OSCTXT* pctxt, RRCConnectionReestablishmentComplete_v920_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentComplete-v920-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rlf_InfoAvailable_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlf-InfoAvailable-r9");

      pvalue->m.rlf_InfoAvailable_r9Present = 1;

      stat = asn1PD_RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9 (pctxt, &pvalue->rlf_InfoAvailable_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionReestablishmentComplete_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReestablishmentComplete_v920_IEs (
   RRCConnectionReestablishmentComplete_v920_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RRCConnectionReestablishmentComplete_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_RRCConnectionReestablishmentComplete_r8_IEs (OSCTXT* pctxt, RRCConnectionReestablishmentComplete_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentComplete-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentComplete_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionReestablishmentComplete_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentComplete_r8_IEs (OSCTXT* pctxt, RRCConnectionReestablishmentComplete_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentComplete-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionReestablishmentComplete_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReestablishmentComplete_r8_IEs (
   RRCConnectionReestablishmentComplete_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RRCConnectionReestablishmentComplete_v920_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_RRCConnectionReestablishmentComplete_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionReestablishmentComplete_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentComplete_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentComplete_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionReestablishmentComplete_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionReestablishmentComplete_criticalExtensions (OSCTXT* pctxt, RRCConnectionReestablishmentComplete_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentComplete_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* rrcConnectionReestablishmentComplete_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishmentComplete-r8");

         stat = asn1PE_RRCConnectionReestablishmentComplete_r8_IEs (pctxt, pvalue->u.rrcConnectionReestablishmentComplete_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_RRCConnectionReestablishmentComplete_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentComplete_criticalExtensions (OSCTXT* pctxt, RRCConnectionReestablishmentComplete_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rrcConnectionReestablishmentComplete_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishmentComplete-r8");

         pvalue->u.rrcConnectionReestablishmentComplete_r8
             = rtxMemAllocType (pctxt, 
            RRCConnectionReestablishmentComplete_r8_IEs);

         if (pvalue->u.rrcConnectionReestablishmentComplete_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReestablishmentComplete_r8_IEs (pvalue->u.rrcConnectionReestablishmentComplete_r8);

         stat = asn1PD_RRCConnectionReestablishmentComplete_r8_IEs (pctxt, pvalue->u.rrcConnectionReestablishmentComplete_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            RRCConnectionReestablishmentComplete_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_RRCConnectionReestablishmentComplete_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionReestablishmentComplete_criticalExtensions (
   RRCConnectionReestablishmentComplete_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionReestablishmentComplete (OSCTXT* pctxt, RRCConnectionReestablishmentComplete* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentComplete");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionReestablishmentComplete"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_RRCConnectionReestablishmentComplete_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionReestablishmentComplete (OSCTXT* pctxt, RRCConnectionReestablishmentComplete* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionReestablishmentComplete");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_RRCConnectionReestablishmentComplete_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionReestablishmentComplete (
   RRCConnectionReestablishmentComplete* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_RRCConnectionReestablishmentComplete_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_RegisteredMME (OSCTXT* pctxt, RegisteredMME* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RegisteredMME");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RegisteredMME"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.plmn_IdentityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode plmn_Identity */

   if (pvalue->m.plmn_IdentityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "plmn-Identity");

      stat = asn1PE_PLMN_Identity (pctxt, &pvalue->plmn_Identity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode mmegi */

   RTXCTXTPUSHELEMNAME (pctxt, "mmegi");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->mmegi, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode mmec */

   RTXCTXTPUSHELEMNAME (pctxt, "mmec");

   stat = asn1PE_MMEC (pctxt, pvalue->mmec);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RegisteredMME (OSCTXT* pctxt, RegisteredMME* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RegisteredMME");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode plmn_Identity */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "plmn-Identity");

      pvalue->m.plmn_IdentityPresent = 1;

      stat = asn1PD_PLMN_Identity (pctxt, &pvalue->plmn_Identity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode mmegi */
   RTXCTXTPUSHELEMNAME (pctxt, "mmegi");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->mmegi
      , OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mmec */
   RTXCTXTPUSHELEMNAME (pctxt, "mmec");

   stat = asn1PD_MMEC (pctxt, &pvalue->mmec);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RegisteredMME (RegisteredMME* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PLMN_Identity (&pvalue->plmn_Identity);
   pvalue->mmegi.numbits = 0;
   asn1Init_MMEC (&pvalue->mmec);
}

EXTERN int asn1PE_RRCConnectionSetupComplete_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionSetupComplete_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionSetupComplete_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionSetupComplete_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, RRCConnectionSetupComplete_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionSetupComplete_v8a0_IEs (OSCTXT* pctxt, RRCConnectionSetupComplete_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionSetupComplete-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionSetupComplete_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionSetupComplete_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionSetupComplete_v8a0_IEs (OSCTXT* pctxt, RRCConnectionSetupComplete_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionSetupComplete-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionSetupComplete_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionSetupComplete_v8a0_IEs (
   RRCConnectionSetupComplete_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_RRCConnectionSetupComplete_r8_IEs (OSCTXT* pctxt, RRCConnectionSetupComplete_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionSetupComplete-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionSetupComplete_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.registeredMMEPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode selectedPLMN_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "selectedPLMN-Identity");

   if ( (pvalue->selectedPLMN_Identity >= OSUINTCONST(1) && pvalue->
      selectedPLMN_Identity <= OSUINTCONST(6)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->selectedPLMN_Identity, OSUINTCONST(1), OSUINTCONST(6));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->selectedPLMN_Identity);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode registeredMME */

   if (pvalue->m.registeredMMEPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "registeredMME");

      stat = asn1PE_RegisteredMME (pctxt, &pvalue->registeredMME);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode dedicatedInfoNAS */

   RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoNAS");

   stat = asn1PE_DedicatedInfoNAS (pctxt, pvalue->dedicatedInfoNAS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_RRCConnectionSetupComplete_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionSetupComplete_r8_IEs (OSCTXT* pctxt, RRCConnectionSetupComplete_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionSetupComplete-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode selectedPLMN_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "selectedPLMN-Identity");

   stat = pd_ConsUInt8 (pctxt, &pvalue->selectedPLMN_Identity, OSUINTCONST(1), OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode registeredMME */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "registeredMME");

      pvalue->m.registeredMMEPresent = 1;

      stat = asn1PD_RegisteredMME (pctxt, &pvalue->registeredMME);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dedicatedInfoNAS */
   RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoNAS");

   stat = asn1PD_DedicatedInfoNAS (pctxt, &pvalue->dedicatedInfoNAS);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_RRCConnectionSetupComplete_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionSetupComplete_r8_IEs (
   RRCConnectionSetupComplete_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RegisteredMME (&pvalue->registeredMME);
   asn1Init_DedicatedInfoNAS (&pvalue->dedicatedInfoNAS);
   asn1Init_RRCConnectionSetupComplete_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_RRCConnectionSetupComplete_criticalExtensions_c1 (OSCTXT* pctxt, RRCConnectionSetupComplete_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionSetupComplete_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* rrcConnectionSetupComplete_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionSetupComplete-r8");

         stat = asn1PE_RRCConnectionSetupComplete_r8_IEs (pctxt, pvalue->u.rrcConnectionSetupComplete_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionSetupComplete_criticalExtensions_c1 (OSCTXT* pctxt, RRCConnectionSetupComplete_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* rrcConnectionSetupComplete_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionSetupComplete-r8");

         pvalue->u.rrcConnectionSetupComplete_r8 = rtxMemAllocType (pctxt, 
            RRCConnectionSetupComplete_r8_IEs);

         if (pvalue->u.rrcConnectionSetupComplete_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionSetupComplete_r8_IEs (pvalue->u.rrcConnectionSetupComplete_r8);

         stat = asn1PD_RRCConnectionSetupComplete_r8_IEs (pctxt, pvalue->u.rrcConnectionSetupComplete_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionSetupComplete_criticalExtensions_c1 (
   RRCConnectionSetupComplete_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionSetupComplete_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionSetupComplete_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionSetupComplete_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionSetupComplete_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, RRCConnectionSetupComplete_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_RRCConnectionSetupComplete_criticalExtensions (OSCTXT* pctxt, RRCConnectionSetupComplete_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionSetupComplete_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_RRCConnectionSetupComplete_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_RRCConnectionSetupComplete_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionSetupComplete_criticalExtensions (OSCTXT* pctxt, RRCConnectionSetupComplete_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            RRCConnectionSetupComplete_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionSetupComplete_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_RRCConnectionSetupComplete_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            RRCConnectionSetupComplete_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_RRCConnectionSetupComplete_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_RRCConnectionSetupComplete_criticalExtensions (
   RRCConnectionSetupComplete_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_RRCConnectionSetupComplete (OSCTXT* pctxt, RRCConnectionSetupComplete* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionSetupComplete");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRCConnectionSetupComplete"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_RRCConnectionSetupComplete_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCConnectionSetupComplete (OSCTXT* pctxt, RRCConnectionSetupComplete* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCConnectionSetupComplete");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_RRCConnectionSetupComplete_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRCConnectionSetupComplete (RRCConnectionSetupComplete* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_RRCConnectionSetupComplete_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_SecurityModeComplete_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, SecurityModeComplete_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeComplete_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeComplete_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, SecurityModeComplete_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_SecurityModeComplete_v8a0_IEs (OSCTXT* pctxt, SecurityModeComplete_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeComplete-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeComplete_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_SecurityModeComplete_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeComplete_v8a0_IEs (OSCTXT* pctxt, SecurityModeComplete_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeComplete-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_SecurityModeComplete_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SecurityModeComplete_v8a0_IEs (
   SecurityModeComplete_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_SecurityModeComplete_r8_IEs (OSCTXT* pctxt, SecurityModeComplete_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeComplete-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeComplete_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_SecurityModeComplete_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeComplete_r8_IEs (OSCTXT* pctxt, SecurityModeComplete_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeComplete-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_SecurityModeComplete_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SecurityModeComplete_r8_IEs (SecurityModeComplete_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SecurityModeComplete_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_SecurityModeComplete_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, SecurityModeComplete_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeComplete_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeComplete_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, SecurityModeComplete_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_SecurityModeComplete_criticalExtensions (OSCTXT* pctxt, SecurityModeComplete_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeComplete_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* securityModeComplete_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "securityModeComplete-r8");

         stat = asn1PE_SecurityModeComplete_r8_IEs (pctxt, pvalue->u.securityModeComplete_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_SecurityModeComplete_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeComplete_criticalExtensions (OSCTXT* pctxt, SecurityModeComplete_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* securityModeComplete_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "securityModeComplete-r8");

         pvalue->u.securityModeComplete_r8 = rtxMemAllocType (pctxt, 
            SecurityModeComplete_r8_IEs);

         if (pvalue->u.securityModeComplete_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SecurityModeComplete_r8_IEs (pvalue->u.securityModeComplete_r8);

         stat = asn1PD_SecurityModeComplete_r8_IEs (pctxt, pvalue->u.securityModeComplete_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            SecurityModeComplete_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_SecurityModeComplete_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_SecurityModeComplete_criticalExtensions (
   SecurityModeComplete_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_SecurityModeComplete (OSCTXT* pctxt, SecurityModeComplete* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeComplete");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeComplete"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_SecurityModeComplete_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeComplete (OSCTXT* pctxt, SecurityModeComplete* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeComplete");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_SecurityModeComplete_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SecurityModeComplete (SecurityModeComplete* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SecurityModeComplete_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_SecurityModeFailure_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, SecurityModeFailure_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeFailure_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeFailure_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, SecurityModeFailure_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_SecurityModeFailure_v8a0_IEs (OSCTXT* pctxt, SecurityModeFailure_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeFailure-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeFailure_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_SecurityModeFailure_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeFailure_v8a0_IEs (OSCTXT* pctxt, SecurityModeFailure_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeFailure-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_SecurityModeFailure_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SecurityModeFailure_v8a0_IEs (
   SecurityModeFailure_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_SecurityModeFailure_r8_IEs (OSCTXT* pctxt, SecurityModeFailure_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeFailure-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeFailure_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_SecurityModeFailure_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeFailure_r8_IEs (OSCTXT* pctxt, SecurityModeFailure_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeFailure-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_SecurityModeFailure_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SecurityModeFailure_r8_IEs (SecurityModeFailure_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SecurityModeFailure_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_SecurityModeFailure_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, SecurityModeFailure_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeFailure_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeFailure_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, SecurityModeFailure_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_SecurityModeFailure_criticalExtensions (OSCTXT* pctxt, SecurityModeFailure_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeFailure_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* securityModeFailure_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "securityModeFailure-r8");

         stat = asn1PE_SecurityModeFailure_r8_IEs (pctxt, pvalue->u.securityModeFailure_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_SecurityModeFailure_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeFailure_criticalExtensions (OSCTXT* pctxt, SecurityModeFailure_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* securityModeFailure_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "securityModeFailure-r8");

         pvalue->u.securityModeFailure_r8 = rtxMemAllocType (pctxt, 
            SecurityModeFailure_r8_IEs);

         if (pvalue->u.securityModeFailure_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SecurityModeFailure_r8_IEs (pvalue->u.securityModeFailure_r8);

         stat = asn1PD_SecurityModeFailure_r8_IEs (pctxt, pvalue->u.securityModeFailure_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            SecurityModeFailure_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_SecurityModeFailure_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_SecurityModeFailure_criticalExtensions (
   SecurityModeFailure_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_SecurityModeFailure (OSCTXT* pctxt, SecurityModeFailure* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeFailure");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SecurityModeFailure"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_SecurityModeFailure_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityModeFailure (OSCTXT* pctxt, SecurityModeFailure* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeFailure");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_SecurityModeFailure_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SecurityModeFailure (SecurityModeFailure* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SecurityModeFailure_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_UE_CapabilityRAT_Container (OSCTXT* pctxt, UE_CapabilityRAT_Container* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-CapabilityRAT-Container");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_CapabilityRAT_Container"));

   /* encode rat_Type */

   RTXCTXTPUSHELEMNAME (pctxt, "rat-Type");

   stat = asn1PE_RAT_Type (pctxt, pvalue->rat_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ueCapabilityRAT_Container */

   RTXCTXTPUSHELEMNAME (pctxt, "ueCapabilityRAT-Container");

   stat = pe_OctetString (pctxt, pvalue->ueCapabilityRAT_Container.numocts, pvalue->ueCapabilityRAT_Container.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_CapabilityRAT_Container (OSCTXT* pctxt, UE_CapabilityRAT_Container* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-CapabilityRAT-Container");

   /* decode root elements */
   /* decode rat_Type */
   RTXCTXTPUSHELEMNAME (pctxt, "rat-Type");

   stat = asn1PD_RAT_Type (pctxt, &pvalue->rat_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ueCapabilityRAT_Container */
   RTXCTXTPUSHELEMNAME (pctxt, "ueCapabilityRAT-Container");

   stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->ueCapabilityRAT_Container);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UE_CapabilityRAT_Container (UE_CapabilityRAT_Container* pvalue)
{
   if (0 == pvalue) return;
   pvalue->ueCapabilityRAT_Container.numocts = 0;
   pvalue->ueCapabilityRAT_Container.data = 0;
}

EXTERN int asn1PE_UE_CapabilityRAT_ContainerList (OSCTXT* pctxt, UE_CapabilityRAT_ContainerList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-CapabilityRAT-ContainerList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_CapabilityRAT_ContainerList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UE-CapabilityRAT-Container", xx1);

      stat = asn1PE_UE_CapabilityRAT_Container (pctxt, ((UE_CapabilityRAT_Container*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_CapabilityRAT_ContainerList (OSCTXT* pctxt, UE_CapabilityRAT_ContainerList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-CapabilityRAT-ContainerList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UE_CapabilityRAT_Container* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UE-CapabilityRAT-Container", xx1);

      rtxDListAllocNodeAndData (pctxt, UE_CapabilityRAT_Container, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UE_CapabilityRAT_Container (pdata);

      stat = asn1PD_UE_CapabilityRAT_Container (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UE_CapabilityRAT_ContainerList (
   UE_CapabilityRAT_ContainerList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_UECapabilityInformation_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, UECapabilityInformation_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UECapabilityInformation_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UECapabilityInformation_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, UECapabilityInformation_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_UECapabilityInformation_v8a0_IEs (OSCTXT* pctxt, UECapabilityInformation_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UECapabilityInformation-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UECapabilityInformation_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_UECapabilityInformation_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UECapabilityInformation_v8a0_IEs (OSCTXT* pctxt, UECapabilityInformation_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "UECapabilityInformation-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_UECapabilityInformation_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UECapabilityInformation_v8a0_IEs (
   UECapabilityInformation_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_UECapabilityInformation_r8_IEs (OSCTXT* pctxt, UECapabilityInformation_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UECapabilityInformation-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UECapabilityInformation_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ue_CapabilityRAT_ContainerList */

   RTXCTXTPUSHELEMNAME (pctxt, "ue-CapabilityRAT-ContainerList");

   stat = asn1PE_UE_CapabilityRAT_ContainerList (pctxt, &pvalue->ue_CapabilityRAT_ContainerList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_UECapabilityInformation_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UECapabilityInformation_r8_IEs (OSCTXT* pctxt, UECapabilityInformation_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UECapabilityInformation-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ue_CapabilityRAT_ContainerList */
   RTXCTXTPUSHELEMNAME (pctxt, "ue-CapabilityRAT-ContainerList");

   stat = asn1PD_UE_CapabilityRAT_ContainerList (pctxt, &pvalue->ue_CapabilityRAT_ContainerList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_UECapabilityInformation_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UECapabilityInformation_r8_IEs (
   UECapabilityInformation_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_UE_CapabilityRAT_ContainerList (&pvalue->ue_CapabilityRAT_ContainerList);
   asn1Init_UECapabilityInformation_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_UECapabilityInformation_criticalExtensions_c1 (OSCTXT* pctxt, UECapabilityInformation_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UECapabilityInformation_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* ueCapabilityInformation_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ueCapabilityInformation-r8");

         stat = asn1PE_UECapabilityInformation_r8_IEs (pctxt, pvalue->u.ueCapabilityInformation_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare7 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare6 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare5 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare4 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UECapabilityInformation_criticalExtensions_c1 (OSCTXT* pctxt, UECapabilityInformation_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* ueCapabilityInformation_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "ueCapabilityInformation-r8");

         pvalue->u.ueCapabilityInformation_r8 = rtxMemAllocType (pctxt, 
            UECapabilityInformation_r8_IEs);

         if (pvalue->u.ueCapabilityInformation_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UECapabilityInformation_r8_IEs (pvalue->u.ueCapabilityInformation_r8);

         stat = asn1PD_UECapabilityInformation_r8_IEs (pctxt, pvalue->u.ueCapabilityInformation_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare7 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare6 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare5 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare4 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_UECapabilityInformation_criticalExtensions_c1 (
   UECapabilityInformation_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_UECapabilityInformation_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, UECapabilityInformation_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UECapabilityInformation_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UECapabilityInformation_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, UECapabilityInformation_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_UECapabilityInformation_criticalExtensions (OSCTXT* pctxt, UECapabilityInformation_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UECapabilityInformation_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_UECapabilityInformation_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_UECapabilityInformation_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UECapabilityInformation_criticalExtensions (OSCTXT* pctxt, UECapabilityInformation_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            UECapabilityInformation_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UECapabilityInformation_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_UECapabilityInformation_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            UECapabilityInformation_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_UECapabilityInformation_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_UECapabilityInformation_criticalExtensions (
   UECapabilityInformation_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_UECapabilityInformation (OSCTXT* pctxt, UECapabilityInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UECapabilityInformation");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UECapabilityInformation"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_UECapabilityInformation_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UECapabilityInformation (OSCTXT* pctxt, UECapabilityInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UECapabilityInformation");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_UECapabilityInformation_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UECapabilityInformation (UECapabilityInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_UECapabilityInformation_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_ULHandoverPreparationTransfer_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, ULHandoverPreparationTransfer_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULHandoverPreparationTransfer_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULHandoverPreparationTransfer_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, ULHandoverPreparationTransfer_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_ULHandoverPreparationTransfer_v8a0_IEs (OSCTXT* pctxt, ULHandoverPreparationTransfer_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ULHandoverPreparationTransfer-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULHandoverPreparationTransfer_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_ULHandoverPreparationTransfer_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULHandoverPreparationTransfer_v8a0_IEs (OSCTXT* pctxt, ULHandoverPreparationTransfer_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "ULHandoverPreparationTransfer-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_ULHandoverPreparationTransfer_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ULHandoverPreparationTransfer_v8a0_IEs (
   ULHandoverPreparationTransfer_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_ULHandoverPreparationTransfer_r8_IEs (OSCTXT* pctxt, ULHandoverPreparationTransfer_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ULHandoverPreparationTransfer-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULHandoverPreparationTransfer_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.meidPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cdma2000_Type */

   RTXCTXTPUSHELEMNAME (pctxt, "cdma2000-Type");

   stat = asn1PE_CDMA2000_Type (pctxt, pvalue->cdma2000_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode meid */

   if (pvalue->m.meidPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "meid");

      stat = asn1PE_ULHandoverPreparationTransfer_r8_IEs_meid (pctxt, &pvalue->meid);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode dedicatedInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfo");

   stat = asn1PE_DedicatedInfoCDMA2000 (pctxt, pvalue->dedicatedInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_ULHandoverPreparationTransfer_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULHandoverPreparationTransfer_r8_IEs (OSCTXT* pctxt, ULHandoverPreparationTransfer_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "ULHandoverPreparationTransfer-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cdma2000_Type */
   RTXCTXTPUSHELEMNAME (pctxt, "cdma2000-Type");

   stat = asn1PD_CDMA2000_Type (pctxt, &pvalue->cdma2000_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode meid */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "meid");

      pvalue->m.meidPresent = 1;

      stat = asn1PD_ULHandoverPreparationTransfer_r8_IEs_meid (pctxt, &pvalue->meid);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dedicatedInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfo");

   stat = asn1PD_DedicatedInfoCDMA2000 (pctxt, &pvalue->dedicatedInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_ULHandoverPreparationTransfer_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ULHandoverPreparationTransfer_r8_IEs (
   ULHandoverPreparationTransfer_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ULHandoverPreparationTransfer_r8_IEs_meid (&pvalue->meid);
   asn1Init_DedicatedInfoCDMA2000 (&pvalue->dedicatedInfo);
   asn1Init_ULHandoverPreparationTransfer_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_ULHandoverPreparationTransfer_criticalExtensions_c1 (OSCTXT* pctxt, ULHandoverPreparationTransfer_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULHandoverPreparationTransfer_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* ulHandoverPreparationTransfer_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ulHandoverPreparationTransfer-r8");

         stat = asn1PE_ULHandoverPreparationTransfer_r8_IEs (pctxt, pvalue->u.ulHandoverPreparationTransfer_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULHandoverPreparationTransfer_criticalExtensions_c1 (OSCTXT* pctxt, ULHandoverPreparationTransfer_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* ulHandoverPreparationTransfer_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "ulHandoverPreparationTransfer-r8");

         pvalue->u.ulHandoverPreparationTransfer_r8 = rtxMemAllocType (pctxt, 
            ULHandoverPreparationTransfer_r8_IEs);

         if (pvalue->u.ulHandoverPreparationTransfer_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ULHandoverPreparationTransfer_r8_IEs (pvalue->u.ulHandoverPreparationTransfer_r8);

         stat = asn1PD_ULHandoverPreparationTransfer_r8_IEs (pctxt, pvalue->u.ulHandoverPreparationTransfer_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_ULHandoverPreparationTransfer_criticalExtensions_c1 (
   ULHandoverPreparationTransfer_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ULHandoverPreparationTransfer_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, ULHandoverPreparationTransfer_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULHandoverPreparationTransfer_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULHandoverPreparationTransfer_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, ULHandoverPreparationTransfer_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_ULHandoverPreparationTransfer_criticalExtensions (OSCTXT* pctxt, ULHandoverPreparationTransfer_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULHandoverPreparationTransfer_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_ULHandoverPreparationTransfer_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_ULHandoverPreparationTransfer_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULHandoverPreparationTransfer_criticalExtensions (OSCTXT* pctxt, ULHandoverPreparationTransfer_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            ULHandoverPreparationTransfer_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ULHandoverPreparationTransfer_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_ULHandoverPreparationTransfer_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            ULHandoverPreparationTransfer_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_ULHandoverPreparationTransfer_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_ULHandoverPreparationTransfer_criticalExtensions (
   ULHandoverPreparationTransfer_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ULHandoverPreparationTransfer (OSCTXT* pctxt, ULHandoverPreparationTransfer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ULHandoverPreparationTransfer");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULHandoverPreparationTransfer"));

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_ULHandoverPreparationTransfer_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULHandoverPreparationTransfer (OSCTXT* pctxt, ULHandoverPreparationTransfer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ULHandoverPreparationTransfer");

   /* decode root elements */
   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_ULHandoverPreparationTransfer_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ULHandoverPreparationTransfer (
   ULHandoverPreparationTransfer* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_ULHandoverPreparationTransfer_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_ULInformationTransfer_r8_IEs_dedicatedInfoType (OSCTXT* pctxt, ULInformationTransfer_r8_IEs_dedicatedInfoType* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULInformationTransfer_r8_IEs_dedicatedInfoType"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* dedicatedInfoNAS */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoNAS");

         stat = asn1PE_DedicatedInfoNAS (pctxt, *pvalue->u.dedicatedInfoNAS);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* dedicatedInfoCDMA2000_1XRTT */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoCDMA2000-1XRTT");

         stat = asn1PE_DedicatedInfoCDMA2000 (pctxt, *pvalue->u.dedicatedInfoCDMA2000_1XRTT);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* dedicatedInfoCDMA2000_HRPD */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoCDMA2000-HRPD");

         stat = asn1PE_DedicatedInfoCDMA2000 (pctxt, *pvalue->u.dedicatedInfoCDMA2000_HRPD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULInformationTransfer_r8_IEs_dedicatedInfoType (OSCTXT* pctxt, ULInformationTransfer_r8_IEs_dedicatedInfoType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* dedicatedInfoNAS */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoNAS");

         pvalue->u.dedicatedInfoNAS = rtxMemAllocType (pctxt, 
            DedicatedInfoNAS);

         if (pvalue->u.dedicatedInfoNAS == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DedicatedInfoNAS (pvalue->u.dedicatedInfoNAS);

         stat = asn1PD_DedicatedInfoNAS (pctxt, pvalue->u.dedicatedInfoNAS);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dedicatedInfoCDMA2000_1XRTT */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoCDMA2000-1XRTT");

         pvalue->u.dedicatedInfoCDMA2000_1XRTT = rtxMemAllocType (pctxt, 
            DedicatedInfoCDMA2000);

         if (pvalue->u.dedicatedInfoCDMA2000_1XRTT == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DedicatedInfoCDMA2000 (pvalue->u.dedicatedInfoCDMA2000_1XRTT);

         stat = asn1PD_DedicatedInfoCDMA2000 (pctxt, pvalue->u.dedicatedInfoCDMA2000_1XRTT);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dedicatedInfoCDMA2000_HRPD */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoCDMA2000-HRPD");

         pvalue->u.dedicatedInfoCDMA2000_HRPD = rtxMemAllocType (pctxt, 
            DedicatedInfoCDMA2000);

         if (pvalue->u.dedicatedInfoCDMA2000_HRPD == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DedicatedInfoCDMA2000 (pvalue->u.dedicatedInfoCDMA2000_HRPD);

         stat = asn1PD_DedicatedInfoCDMA2000 (pctxt, pvalue->u.dedicatedInfoCDMA2000_HRPD);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_ULInformationTransfer_r8_IEs_dedicatedInfoType (
   ULInformationTransfer_r8_IEs_dedicatedInfoType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ULInformationTransfer_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, ULInformationTransfer_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULInformationTransfer_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULInformationTransfer_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, ULInformationTransfer_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_ULInformationTransfer_v8a0_IEs (OSCTXT* pctxt, ULInformationTransfer_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ULInformationTransfer-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULInformationTransfer_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_ULInformationTransfer_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULInformationTransfer_v8a0_IEs (OSCTXT* pctxt, ULInformationTransfer_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "ULInformationTransfer-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_ULInformationTransfer_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ULInformationTransfer_v8a0_IEs (
   ULInformationTransfer_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_ULInformationTransfer_r8_IEs (OSCTXT* pctxt, ULInformationTransfer_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ULInformationTransfer-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULInformationTransfer_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dedicatedInfoType */

   RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoType");

   stat = asn1PE_ULInformationTransfer_r8_IEs_dedicatedInfoType (pctxt, &pvalue->dedicatedInfoType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_ULInformationTransfer_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULInformationTransfer_r8_IEs (OSCTXT* pctxt, ULInformationTransfer_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ULInformationTransfer-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dedicatedInfoType */
   RTXCTXTPUSHELEMNAME (pctxt, "dedicatedInfoType");

   stat = asn1PD_ULInformationTransfer_r8_IEs_dedicatedInfoType (pctxt, &pvalue->dedicatedInfoType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_ULInformationTransfer_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ULInformationTransfer_r8_IEs (
   ULInformationTransfer_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ULInformationTransfer_r8_IEs_dedicatedInfoType (&pvalue->dedicatedInfoType);
   asn1Init_ULInformationTransfer_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_ULInformationTransfer_criticalExtensions_c1 (OSCTXT* pctxt, ULInformationTransfer_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULInformationTransfer_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* ulInformationTransfer_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ulInformationTransfer-r8");

         stat = asn1PE_ULInformationTransfer_r8_IEs (pctxt, pvalue->u.ulInformationTransfer_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULInformationTransfer_criticalExtensions_c1 (OSCTXT* pctxt, ULInformationTransfer_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* ulInformationTransfer_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "ulInformationTransfer-r8");

         pvalue->u.ulInformationTransfer_r8 = rtxMemAllocType (pctxt, 
            ULInformationTransfer_r8_IEs);

         if (pvalue->u.ulInformationTransfer_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ULInformationTransfer_r8_IEs (pvalue->u.ulInformationTransfer_r8);

         stat = asn1PD_ULInformationTransfer_r8_IEs (pctxt, pvalue->u.ulInformationTransfer_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_ULInformationTransfer_criticalExtensions_c1 (
   ULInformationTransfer_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ULInformationTransfer_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, ULInformationTransfer_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULInformationTransfer_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULInformationTransfer_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, ULInformationTransfer_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_ULInformationTransfer_criticalExtensions (OSCTXT* pctxt, ULInformationTransfer_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULInformationTransfer_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_ULInformationTransfer_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_ULInformationTransfer_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULInformationTransfer_criticalExtensions (OSCTXT* pctxt, ULInformationTransfer_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            ULInformationTransfer_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ULInformationTransfer_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_ULInformationTransfer_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            ULInformationTransfer_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_ULInformationTransfer_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_ULInformationTransfer_criticalExtensions (
   ULInformationTransfer_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ULInformationTransfer (OSCTXT* pctxt, ULInformationTransfer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ULInformationTransfer");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ULInformationTransfer"));

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_ULInformationTransfer_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULInformationTransfer (OSCTXT* pctxt, ULInformationTransfer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ULInformationTransfer");

   /* decode root elements */
   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_ULInformationTransfer_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ULInformationTransfer (ULInformationTransfer* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_ULInformationTransfer_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_DRB_CountInfo (OSCTXT* pctxt, DRB_CountInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-CountInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRB_CountInfo"));

   /* encode drb_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "drb-Identity");

   stat = asn1PE_DRB_Identity (pctxt, pvalue->drb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode count_Uplink */

   RTXCTXTPUSHELEMNAME (pctxt, "count-Uplink");

   stat = pe_ConsUnsigned (pctxt, pvalue->count_Uplink, OSUINTCONST(0), OSUINT32_MAX);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode count_Downlink */

   RTXCTXTPUSHELEMNAME (pctxt, "count-Downlink");

   stat = pe_ConsUnsigned (pctxt, pvalue->count_Downlink, OSUINTCONST(0), OSUINT32_MAX);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRB_CountInfo (OSCTXT* pctxt, DRB_CountInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-CountInfo");

   /* decode root elements */
   /* decode drb_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "drb-Identity");

   stat = asn1PD_DRB_Identity (pctxt, &pvalue->drb_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode count_Uplink */
   RTXCTXTPUSHELEMNAME (pctxt, "count-Uplink");

   stat = pd_ConsUnsigned (pctxt, &pvalue->count_Uplink, OSUINTCONST(0), OSUINT32_MAX);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode count_Downlink */
   RTXCTXTPUSHELEMNAME (pctxt, "count-Downlink");

   stat = pd_ConsUnsigned (pctxt, &pvalue->count_Downlink, OSUINTCONST(0), OSUINT32_MAX);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_DRB_CountInfoList (OSCTXT* pctxt, DRB_CountInfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-CountInfoList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("DRB_CountInfoList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(11), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DRB-CountInfo", xx1);

      stat = asn1PE_DRB_CountInfo (pctxt, ((DRB_CountInfo*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRB_CountInfoList (OSCTXT* pctxt, DRB_CountInfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-CountInfoList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(11), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DRB_CountInfo* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DRB-CountInfo", xx1);

      rtxDListAllocNodeAndData (pctxt, DRB_CountInfo, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_DRB_CountInfo (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_DRB_CountInfoList (DRB_CountInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_CounterCheckResponse_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, CounterCheckResponse_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CounterCheckResponse_v8a0_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CounterCheckResponse_v8a0_IEs_nonCriticalExtension (OSCTXT* pctxt, CounterCheckResponse_v8a0_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_CounterCheckResponse_v8a0_IEs (OSCTXT* pctxt, CounterCheckResponse_v8a0_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CounterCheckResponse-v8a0-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CounterCheckResponse_v8a0_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_CounterCheckResponse_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CounterCheckResponse_v8a0_IEs (OSCTXT* pctxt, CounterCheckResponse_v8a0_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "CounterCheckResponse-v8a0-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_CounterCheckResponse_v8a0_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CounterCheckResponse_v8a0_IEs (
   CounterCheckResponse_v8a0_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_CounterCheckResponse_r8_IEs (OSCTXT* pctxt, CounterCheckResponse_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CounterCheckResponse-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CounterCheckResponse_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode drb_CountInfoList */

   RTXCTXTPUSHELEMNAME (pctxt, "drb-CountInfoList");

   stat = asn1PE_DRB_CountInfoList (pctxt, &pvalue->drb_CountInfoList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_CounterCheckResponse_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CounterCheckResponse_r8_IEs (OSCTXT* pctxt, CounterCheckResponse_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CounterCheckResponse-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode drb_CountInfoList */
   RTXCTXTPUSHELEMNAME (pctxt, "drb-CountInfoList");

   stat = asn1PD_DRB_CountInfoList (pctxt, &pvalue->drb_CountInfoList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_CounterCheckResponse_v8a0_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CounterCheckResponse_r8_IEs (CounterCheckResponse_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_DRB_CountInfoList (&pvalue->drb_CountInfoList);
   asn1Init_CounterCheckResponse_v8a0_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_CounterCheckResponse_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, CounterCheckResponse_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CounterCheckResponse_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CounterCheckResponse_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, CounterCheckResponse_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_CounterCheckResponse_criticalExtensions (OSCTXT* pctxt, CounterCheckResponse_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CounterCheckResponse_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* counterCheckResponse_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "counterCheckResponse-r8");

         stat = asn1PE_CounterCheckResponse_r8_IEs (pctxt, pvalue->u.counterCheckResponse_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_CounterCheckResponse_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CounterCheckResponse_criticalExtensions (OSCTXT* pctxt, CounterCheckResponse_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* counterCheckResponse_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "counterCheckResponse-r8");

         pvalue->u.counterCheckResponse_r8 = rtxMemAllocType (pctxt, 
            CounterCheckResponse_r8_IEs);

         if (pvalue->u.counterCheckResponse_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CounterCheckResponse_r8_IEs (pvalue->u.counterCheckResponse_r8);

         stat = asn1PD_CounterCheckResponse_r8_IEs (pctxt, pvalue->u.counterCheckResponse_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            CounterCheckResponse_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_CounterCheckResponse_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_CounterCheckResponse_criticalExtensions (
   CounterCheckResponse_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_CounterCheckResponse (OSCTXT* pctxt, CounterCheckResponse* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CounterCheckResponse");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CounterCheckResponse"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_CounterCheckResponse_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CounterCheckResponse (OSCTXT* pctxt, CounterCheckResponse* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CounterCheckResponse");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_CounterCheckResponse_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CounterCheckResponse (CounterCheckResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_CounterCheckResponse_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_UEInformationResponse_r9_IEs_rach_Report_r9 (OSCTXT* pctxt, UEInformationResponse_r9_IEs_rach_Report_r9* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationResponse_r9_IEs_rach_Report_r9"));

   /* encode numberOfPreamblesSent_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "numberOfPreamblesSent-r9");

   if ( (pvalue->numberOfPreamblesSent_r9 >= OSUINTCONST(1) && pvalue->
      numberOfPreamblesSent_r9 <= OSUINTCONST(200)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->numberOfPreamblesSent_r9, OSUINTCONST(1), OSUINTCONST(200));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->numberOfPreamblesSent_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode contentionDetected_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "contentionDetected-r9");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->contentionDetected_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationResponse_r9_IEs_rach_Report_r9 (OSCTXT* pctxt, UEInformationResponse_r9_IEs_rach_Report_r9* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode numberOfPreamblesSent_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfPreamblesSent-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->numberOfPreamblesSent_r9, OSUINTCONST(1), OSUINTCONST(200));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode contentionDetected_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "contentionDetected-r9");

   stat = DEC_BIT (pctxt, &pvalue->contentionDetected_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RLF_Report_r9_measResultLastServCell_r9 (OSCTXT* pctxt, RLF_Report_r9_measResultLastServCell_r9* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLF_Report_r9_measResultLastServCell_r9"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rsrqResult_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rsrpResult_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "rsrpResult-r9");

   stat = asn1PE_RSRP_Range (pctxt, pvalue->rsrpResult_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rsrqResult_r9 */

   if (pvalue->m.rsrqResult_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "rsrqResult-r9");

      stat = asn1PE_RSRQ_Range (pctxt, pvalue->rsrqResult_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLF_Report_r9_measResultLastServCell_r9 (OSCTXT* pctxt, RLF_Report_r9_measResultLastServCell_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rsrpResult_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "rsrpResult-r9");

   stat = asn1PD_RSRP_Range (pctxt, &pvalue->rsrpResult_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rsrqResult_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rsrqResult-r9");

      pvalue->m.rsrqResult_r9Present = 1;

      stat = asn1PD_RSRQ_Range (pctxt, &pvalue->rsrqResult_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_RLF_Report_r9_measResultLastServCell_r9 (
   RLF_Report_r9_measResultLastServCell_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_MeasResult2EUTRA_r9 (OSCTXT* pctxt, MeasResult2EUTRA_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResult2EUTRA-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResult2EUTRA_r9"));

   /* encode carrierFreq_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq-r9");

   stat = asn1PE_ARFCN_ValueEUTRA (pctxt, pvalue->carrierFreq_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode measResultList_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "measResultList-r9");

   stat = asn1PE_MeasResultListEUTRA (pctxt, &pvalue->measResultList_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResult2EUTRA_r9 (OSCTXT* pctxt, MeasResult2EUTRA_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResult2EUTRA-r9");

   /* decode root elements */
   /* decode carrierFreq_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq-r9");

   stat = asn1PD_ARFCN_ValueEUTRA (pctxt, &pvalue->carrierFreq_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measResultList_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "measResultList-r9");

   stat = asn1PD_MeasResultListEUTRA (pctxt, &pvalue->measResultList_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResult2EUTRA_r9 (MeasResult2EUTRA_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_MeasResultListEUTRA (&pvalue->measResultList_r9);
}

EXTERN int asn1PE_MeasResultList2EUTRA_r9 (OSCTXT* pctxt, MeasResultList2EUTRA_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultList2EUTRA-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultList2EUTRA_r9"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasResult2EUTRA-r9", xx1);

      stat = asn1PE_MeasResult2EUTRA_r9 (pctxt, ((MeasResult2EUTRA_r9*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultList2EUTRA_r9 (OSCTXT* pctxt, MeasResultList2EUTRA_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultList2EUTRA-r9");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MeasResult2EUTRA_r9* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasResult2EUTRA-r9", xx1);

      rtxDListAllocNodeAndData (pctxt, MeasResult2EUTRA_r9, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MeasResult2EUTRA_r9 (pdata);

      stat = asn1PD_MeasResult2EUTRA_r9 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResultList2EUTRA_r9 (MeasResultList2EUTRA_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_MeasResult2UTRA_r9 (OSCTXT* pctxt, MeasResult2UTRA_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResult2UTRA-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResult2UTRA_r9"));

   /* encode carrierFreq_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq-r9");

   stat = asn1PE_ARFCN_ValueUTRA (pctxt, pvalue->carrierFreq_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode measResultList_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "measResultList-r9");

   stat = asn1PE_MeasResultListUTRA (pctxt, &pvalue->measResultList_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResult2UTRA_r9 (OSCTXT* pctxt, MeasResult2UTRA_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResult2UTRA-r9");

   /* decode root elements */
   /* decode carrierFreq_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq-r9");

   stat = asn1PD_ARFCN_ValueUTRA (pctxt, &pvalue->carrierFreq_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measResultList_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "measResultList-r9");

   stat = asn1PD_MeasResultListUTRA (pctxt, &pvalue->measResultList_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResult2UTRA_r9 (MeasResult2UTRA_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_MeasResultListUTRA (&pvalue->measResultList_r9);
}

EXTERN int asn1PE_MeasResultList2UTRA_r9 (OSCTXT* pctxt, MeasResultList2UTRA_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultList2UTRA-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultList2UTRA_r9"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasResult2UTRA-r9", xx1);

      stat = asn1PE_MeasResult2UTRA_r9 (pctxt, ((MeasResult2UTRA_r9*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultList2UTRA_r9 (OSCTXT* pctxt, MeasResultList2UTRA_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultList2UTRA-r9");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MeasResult2UTRA_r9* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasResult2UTRA-r9", xx1);

      rtxDListAllocNodeAndData (pctxt, MeasResult2UTRA_r9, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MeasResult2UTRA_r9 (pdata);

      stat = asn1PD_MeasResult2UTRA_r9 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResultList2UTRA_r9 (MeasResultList2UTRA_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_MeasResult2CDMA2000_r9 (OSCTXT* pctxt, MeasResult2CDMA2000_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResult2CDMA2000-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResult2CDMA2000_r9"));

   /* encode carrierFreq_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq-r9");

   stat = asn1PE_CarrierFreqCDMA2000 (pctxt, &pvalue->carrierFreq_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode measResultList_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "measResultList-r9");

   stat = asn1PE_MeasResultsCDMA2000 (pctxt, &pvalue->measResultList_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResult2CDMA2000_r9 (OSCTXT* pctxt, MeasResult2CDMA2000_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResult2CDMA2000-r9");

   /* decode root elements */
   /* decode carrierFreq_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq-r9");

   stat = asn1PD_CarrierFreqCDMA2000 (pctxt, &pvalue->carrierFreq_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measResultList_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "measResultList-r9");

   stat = asn1PD_MeasResultsCDMA2000 (pctxt, &pvalue->measResultList_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResult2CDMA2000_r9 (MeasResult2CDMA2000_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_MeasResultsCDMA2000 (&pvalue->measResultList_r9);
}

EXTERN int asn1PE_MeasResultList2CDMA2000_r9 (OSCTXT* pctxt, MeasResultList2CDMA2000_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultList2CDMA2000-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasResultList2CDMA2000_r9"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasResult2CDMA2000-r9", xx1);

      stat = asn1PE_MeasResult2CDMA2000_r9 (pctxt, ((MeasResult2CDMA2000_r9*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasResultList2CDMA2000_r9 (OSCTXT* pctxt, MeasResultList2CDMA2000_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasResultList2CDMA2000-r9");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MeasResult2CDMA2000_r9* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MeasResult2CDMA2000-r9", xx1);

      rtxDListAllocNodeAndData (pctxt, MeasResult2CDMA2000_r9, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MeasResult2CDMA2000_r9 (pdata);

      stat = asn1PD_MeasResult2CDMA2000_r9 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasResultList2CDMA2000_r9 (MeasResultList2CDMA2000_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_RLF_Report_r9_measResultNeighCells_r9 (OSCTXT* pctxt, RLF_Report_r9_measResultNeighCells_r9* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLF_Report_r9_measResultNeighCells_r9"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measResultListEUTRA_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measResultListUTRA_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measResultListGERAN_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measResultsCDMA2000_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measResultListEUTRA_r9 */

   if (pvalue->m.measResultListEUTRA_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "measResultListEUTRA-r9");

      stat = asn1PE_MeasResultList2EUTRA_r9 (pctxt, &pvalue->measResultListEUTRA_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode measResultListUTRA_r9 */

   if (pvalue->m.measResultListUTRA_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "measResultListUTRA-r9");

      stat = asn1PE_MeasResultList2UTRA_r9 (pctxt, &pvalue->measResultListUTRA_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode measResultListGERAN_r9 */

   if (pvalue->m.measResultListGERAN_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "measResultListGERAN-r9");

      stat = asn1PE_MeasResultListGERAN (pctxt, &pvalue->measResultListGERAN_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode measResultsCDMA2000_r9 */

   if (pvalue->m.measResultsCDMA2000_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "measResultsCDMA2000-r9");

      stat = asn1PE_MeasResultList2CDMA2000_r9 (pctxt, &pvalue->measResultsCDMA2000_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLF_Report_r9_measResultNeighCells_r9 (OSCTXT* pctxt, RLF_Report_r9_measResultNeighCells_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode measResultListEUTRA_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measResultListEUTRA-r9");

      pvalue->m.measResultListEUTRA_r9Present = 1;

      stat = asn1PD_MeasResultList2EUTRA_r9 (pctxt, &pvalue->measResultListEUTRA_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measResultListUTRA_r9 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measResultListUTRA-r9");

      pvalue->m.measResultListUTRA_r9Present = 1;

      stat = asn1PD_MeasResultList2UTRA_r9 (pctxt, &pvalue->measResultListUTRA_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measResultListGERAN_r9 */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measResultListGERAN-r9");

      pvalue->m.measResultListGERAN_r9Present = 1;

      stat = asn1PD_MeasResultListGERAN (pctxt, &pvalue->measResultListGERAN_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measResultsCDMA2000_r9 */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measResultsCDMA2000-r9");

      pvalue->m.measResultsCDMA2000_r9Present = 1;

      stat = asn1PD_MeasResultList2CDMA2000_r9 (pctxt, &pvalue->measResultsCDMA2000_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_RLF_Report_r9_measResultNeighCells_r9 (
   RLF_Report_r9_measResultNeighCells_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_MeasResultList2EUTRA_r9 (&pvalue->measResultListEUTRA_r9);
   asn1Init_MeasResultList2UTRA_r9 (&pvalue->measResultListUTRA_r9);
   asn1Init_MeasResultListGERAN (&pvalue->measResultListGERAN_r9);
   asn1Init_MeasResultList2CDMA2000_r9 (&pvalue->measResultsCDMA2000_r9);
}

EXTERN int asn1PE_RLF_Report_r9 (OSCTXT* pctxt, RLF_Report_r9* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RLF-Report-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RLF_Report_r9"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measResultNeighCells_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measResultLastServCell_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "measResultLastServCell-r9");

   stat = asn1PE_RLF_Report_r9_measResultLastServCell_r9 (pctxt, &pvalue->measResultLastServCell_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode measResultNeighCells_r9 */

   if (pvalue->m.measResultNeighCells_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "measResultNeighCells-r9");

      stat = asn1PE_RLF_Report_r9_measResultNeighCells_r9 (pctxt, &pvalue->measResultNeighCells_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RLF_Report_r9 (OSCTXT* pctxt, RLF_Report_r9* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RLF-Report-r9");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode measResultLastServCell_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "measResultLastServCell-r9");

   stat = asn1PD_RLF_Report_r9_measResultLastServCell_r9 (pctxt, &pvalue->measResultLastServCell_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measResultNeighCells_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measResultNeighCells-r9");

      pvalue->m.measResultNeighCells_r9Present = 1;

      stat = asn1PD_RLF_Report_r9_measResultNeighCells_r9 (pctxt, &pvalue->measResultNeighCells_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RLF_Report_r9 (RLF_Report_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RLF_Report_r9_measResultLastServCell_r9 (&pvalue->measResultLastServCell_r9);
   asn1Init_RLF_Report_r9_measResultNeighCells_r9 (&pvalue->measResultNeighCells_r9);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_UEInformationResponse_v930_IEs_nonCriticalExtension (OSCTXT* pctxt, UEInformationResponse_v930_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationResponse_v930_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationResponse_v930_IEs_nonCriticalExtension (OSCTXT* pctxt, UEInformationResponse_v930_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_UEInformationResponse_v930_IEs (OSCTXT* pctxt, UEInformationResponse_v930_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UEInformationResponse-v930-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationResponse_v930_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_UEInformationResponse_v930_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationResponse_v930_IEs (OSCTXT* pctxt, UEInformationResponse_v930_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "UEInformationResponse-v930-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_UEInformationResponse_v930_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UEInformationResponse_v930_IEs (
   UEInformationResponse_v930_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_UEInformationResponse_r9_IEs (OSCTXT* pctxt, UEInformationResponse_r9_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UEInformationResponse-r9-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationResponse_r9_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rach_Report_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rlfReport_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rach_Report_r9 */

   if (pvalue->m.rach_Report_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "rach-Report-r9");

      stat = asn1PE_UEInformationResponse_r9_IEs_rach_Report_r9 (pctxt, &pvalue->rach_Report_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode rlfReport_r9 */

   if (pvalue->m.rlfReport_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlfReport-r9");

      stat = asn1PE_RLF_Report_r9 (pctxt, &pvalue->rlfReport_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_UEInformationResponse_v930_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationResponse_r9_IEs (OSCTXT* pctxt, UEInformationResponse_r9_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "UEInformationResponse-r9-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rach_Report_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rach-Report-r9");

      pvalue->m.rach_Report_r9Present = 1;

      stat = asn1PD_UEInformationResponse_r9_IEs_rach_Report_r9 (pctxt, &pvalue->rach_Report_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rlfReport_r9 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rlfReport-r9");

      pvalue->m.rlfReport_r9Present = 1;

      stat = asn1PD_RLF_Report_r9 (pctxt, &pvalue->rlfReport_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_UEInformationResponse_v930_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UEInformationResponse_r9_IEs (
   UEInformationResponse_r9_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RLF_Report_r9 (&pvalue->rlfReport_r9);
   asn1Init_UEInformationResponse_v930_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_UEInformationResponse_r9_criticalExtensions_c1 (OSCTXT* pctxt, UEInformationResponse_r9_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationResponse_r9_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* ueInformationResponse_r9 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ueInformationResponse-r9");

         stat = asn1PE_UEInformationResponse_r9_IEs (pctxt, pvalue->u.ueInformationResponse_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationResponse_r9_criticalExtensions_c1 (OSCTXT* pctxt, UEInformationResponse_r9_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* ueInformationResponse_r9 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "ueInformationResponse-r9");

         pvalue->u.ueInformationResponse_r9 = rtxMemAllocType (pctxt, 
            UEInformationResponse_r9_IEs);

         if (pvalue->u.ueInformationResponse_r9 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEInformationResponse_r9_IEs (pvalue->u.ueInformationResponse_r9);

         stat = asn1PD_UEInformationResponse_r9_IEs (pctxt, pvalue->u.ueInformationResponse_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_UEInformationResponse_r9_criticalExtensions_c1 (
   UEInformationResponse_r9_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_UEInformationResponse_r9_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, UEInformationResponse_r9_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationResponse_r9_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationResponse_r9_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, UEInformationResponse_r9_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_UEInformationResponse_r9_criticalExtensions (OSCTXT* pctxt, UEInformationResponse_r9_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationResponse_r9_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_UEInformationResponse_r9_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_UEInformationResponse_r9_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationResponse_r9_criticalExtensions (OSCTXT* pctxt, UEInformationResponse_r9_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            UEInformationResponse_r9_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEInformationResponse_r9_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_UEInformationResponse_r9_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            UEInformationResponse_r9_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_UEInformationResponse_r9_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_UEInformationResponse_r9_criticalExtensions (
   UEInformationResponse_r9_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_UEInformationResponse_r9 (OSCTXT* pctxt, UEInformationResponse_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UEInformationResponse-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UEInformationResponse_r9"));

   /* encode rrc_TransactionIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PE_RRC_TransactionIdentifier (pctxt, pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_UEInformationResponse_r9_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationResponse_r9 (OSCTXT* pctxt, UEInformationResponse_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UEInformationResponse-r9");

   /* decode root elements */
   /* decode rrc_TransactionIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "rrc-TransactionIdentifier");

   stat = asn1PD_RRC_TransactionIdentifier (pctxt, &pvalue->rrc_TransactionIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_UEInformationResponse_r9_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UEInformationResponse_r9 (UEInformationResponse_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_UEInformationResponse_r9_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_ProximityIndication_r9_IEs_carrierFreq_r9 (OSCTXT* pctxt, ProximityIndication_r9_IEs_carrierFreq_r9* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ProximityIndication_r9_IEs_carrierFreq_r9"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* eutra_r9 */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "eutra-r9");

            stat = asn1PE_ARFCN_ValueEUTRA (pctxt, pvalue->u.eutra_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* utra_r9 */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "utra-r9");

            stat = asn1PE_ARFCN_ValueUTRA (pctxt, pvalue->u.utra_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ProximityIndication_r9_IEs_carrierFreq_r9 (OSCTXT* pctxt, ProximityIndication_r9_IEs_carrierFreq_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* eutra_r9 */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "eutra-r9");

            stat = asn1PD_ARFCN_ValueEUTRA (pctxt, &pvalue->u.eutra_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* utra_r9 */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "utra-r9");

            stat = asn1PD_ARFCN_ValueUTRA (pctxt, &pvalue->u.utra_r9);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

void asn1Init_ProximityIndication_r9_IEs_carrierFreq_r9 (
   ProximityIndication_r9_IEs_carrierFreq_r9* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ProximityIndication_v930_IEs_nonCriticalExtension (OSCTXT* pctxt, ProximityIndication_v930_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ProximityIndication_v930_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ProximityIndication_v930_IEs_nonCriticalExtension (OSCTXT* pctxt, ProximityIndication_v930_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_ProximityIndication_v930_IEs (OSCTXT* pctxt, ProximityIndication_v930_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProximityIndication-v930-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ProximityIndication_v930_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_ProximityIndication_v930_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ProximityIndication_v930_IEs (OSCTXT* pctxt, ProximityIndication_v930_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "ProximityIndication-v930-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_ProximityIndication_v930_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ProximityIndication_v930_IEs (
   ProximityIndication_v930_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_ProximityIndication_r9_IEs (OSCTXT* pctxt, ProximityIndication_r9_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProximityIndication-r9-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ProximityIndication_r9_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode type_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "type-r9");

   stat = asn1PE_ProximityIndication_r9_IEs_type_r9 (pctxt, pvalue->type_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode carrierFreq_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq-r9");

   stat = asn1PE_ProximityIndication_r9_IEs_carrierFreq_r9 (pctxt, &pvalue->carrierFreq_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_ProximityIndication_v930_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ProximityIndication_r9_IEs (OSCTXT* pctxt, ProximityIndication_r9_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ProximityIndication-r9-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode type_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "type-r9");

   stat = asn1PD_ProximityIndication_r9_IEs_type_r9 (pctxt, &pvalue->type_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode carrierFreq_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq-r9");

   stat = asn1PD_ProximityIndication_r9_IEs_carrierFreq_r9 (pctxt, &pvalue->carrierFreq_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_ProximityIndication_v930_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ProximityIndication_r9_IEs (ProximityIndication_r9_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ProximityIndication_r9_IEs_carrierFreq_r9 (&pvalue->carrierFreq_r9);
   asn1Init_ProximityIndication_v930_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_ProximityIndication_r9_criticalExtensions_c1 (OSCTXT* pctxt, ProximityIndication_r9_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ProximityIndication_r9_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* proximityIndication_r9 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "proximityIndication-r9");

         stat = asn1PE_ProximityIndication_r9_IEs (pctxt, pvalue->u.proximityIndication_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ProximityIndication_r9_criticalExtensions_c1 (OSCTXT* pctxt, ProximityIndication_r9_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* proximityIndication_r9 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "proximityIndication-r9");

         pvalue->u.proximityIndication_r9 = rtxMemAllocType (pctxt, 
            ProximityIndication_r9_IEs);

         if (pvalue->u.proximityIndication_r9 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ProximityIndication_r9_IEs (pvalue->u.proximityIndication_r9);

         stat = asn1PD_ProximityIndication_r9_IEs (pctxt, pvalue->u.proximityIndication_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_ProximityIndication_r9_criticalExtensions_c1 (
   ProximityIndication_r9_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ProximityIndication_r9_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, ProximityIndication_r9_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ProximityIndication_r9_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ProximityIndication_r9_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, ProximityIndication_r9_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_ProximityIndication_r9_criticalExtensions (OSCTXT* pctxt, ProximityIndication_r9_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("ProximityIndication_r9_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_ProximityIndication_r9_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_ProximityIndication_r9_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ProximityIndication_r9_criticalExtensions (OSCTXT* pctxt, ProximityIndication_r9_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            ProximityIndication_r9_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ProximityIndication_r9_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_ProximityIndication_r9_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            ProximityIndication_r9_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_ProximityIndication_r9_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_ProximityIndication_r9_criticalExtensions (
   ProximityIndication_r9_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_ProximityIndication_r9 (OSCTXT* pctxt, ProximityIndication_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProximityIndication-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ProximityIndication_r9"));

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_ProximityIndication_r9_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ProximityIndication_r9 (OSCTXT* pctxt, ProximityIndication_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProximityIndication-r9");

   /* decode root elements */
   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_ProximityIndication_r9_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ProximityIndication_r9 (ProximityIndication_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_ProximityIndication_r9_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_UL_DCCH_MessageType_c1 (OSCTXT* pctxt, UL_DCCH_MessageType_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UL_DCCH_MessageType_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 15);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* csfbParametersRequestCDMA2000 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "csfbParametersRequestCDMA2000");

         stat = asn1PE_CSFBParametersRequestCDMA2000 (pctxt, pvalue->u.csfbParametersRequestCDMA2000);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* measurementReport */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "measurementReport");

         stat = asn1PE_MeasurementReport (pctxt, pvalue->u.measurementReport);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* rrcConnectionReconfigurationComplete */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReconfigurationComplete");

         stat = asn1PE_RRCConnectionReconfigurationComplete (pctxt, pvalue->u.rrcConnectionReconfigurationComplete);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* rrcConnectionReestablishmentComplete */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishmentComplete");

         stat = asn1PE_RRCConnectionReestablishmentComplete (pctxt, pvalue->u.rrcConnectionReestablishmentComplete);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* rrcConnectionSetupComplete */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionSetupComplete");

         stat = asn1PE_RRCConnectionSetupComplete (pctxt, pvalue->u.rrcConnectionSetupComplete);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* securityModeComplete */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "securityModeComplete");

         stat = asn1PE_SecurityModeComplete (pctxt, pvalue->u.securityModeComplete);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* securityModeFailure */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "securityModeFailure");

         stat = asn1PE_SecurityModeFailure (pctxt, pvalue->u.securityModeFailure);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* ueCapabilityInformation */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "ueCapabilityInformation");

         stat = asn1PE_UECapabilityInformation (pctxt, pvalue->u.ueCapabilityInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* ulHandoverPreparationTransfer */
      case 9:
         RTXCTXTPUSHELEMNAME (pctxt, "ulHandoverPreparationTransfer");

         stat = asn1PE_ULHandoverPreparationTransfer (pctxt, pvalue->u.ulHandoverPreparationTransfer);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* ulInformationTransfer */
      case 10:
         RTXCTXTPUSHELEMNAME (pctxt, "ulInformationTransfer");

         stat = asn1PE_ULInformationTransfer (pctxt, pvalue->u.ulInformationTransfer);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* counterCheckResponse */
      case 11:
         RTXCTXTPUSHELEMNAME (pctxt, "counterCheckResponse");

         stat = asn1PE_CounterCheckResponse (pctxt, pvalue->u.counterCheckResponse);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* ueInformationResponse_r9 */
      case 12:
         RTXCTXTPUSHELEMNAME (pctxt, "ueInformationResponse-r9");

         stat = asn1PE_UEInformationResponse_r9 (pctxt, pvalue->u.ueInformationResponse_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* proximityIndication_r9 */
      case 13:
         RTXCTXTPUSHELEMNAME (pctxt, "proximityIndication-r9");

         stat = asn1PE_ProximityIndication_r9 (pctxt, pvalue->u.proximityIndication_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 14:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 15:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 16:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_DCCH_MessageType_c1 (OSCTXT* pctxt, UL_DCCH_MessageType_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(15));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* csfbParametersRequestCDMA2000 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "csfbParametersRequestCDMA2000");

         pvalue->u.csfbParametersRequestCDMA2000 = rtxMemAllocType (pctxt, 
            CSFBParametersRequestCDMA2000);

         if (pvalue->u.csfbParametersRequestCDMA2000 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CSFBParametersRequestCDMA2000 (pvalue->u.csfbParametersRequestCDMA2000);

         stat = asn1PD_CSFBParametersRequestCDMA2000 (pctxt, pvalue->u.csfbParametersRequestCDMA2000);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* measurementReport */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "measurementReport");

         pvalue->u.measurementReport = rtxMemAllocType (pctxt, 
            MeasurementReport);

         if (pvalue->u.measurementReport == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MeasurementReport (pvalue->u.measurementReport);

         stat = asn1PD_MeasurementReport (pctxt, pvalue->u.measurementReport);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* rrcConnectionReconfigurationComplete */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReconfigurationComplete");

         pvalue->u.rrcConnectionReconfigurationComplete
             = rtxMemAllocType (pctxt, RRCConnectionReconfigurationComplete);

         if (pvalue->u.rrcConnectionReconfigurationComplete == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReconfigurationComplete (pvalue->u.rrcConnectionReconfigurationComplete);

         stat = asn1PD_RRCConnectionReconfigurationComplete (pctxt, pvalue->u.rrcConnectionReconfigurationComplete);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* rrcConnectionReestablishmentComplete */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionReestablishmentComplete");

         pvalue->u.rrcConnectionReestablishmentComplete
             = rtxMemAllocType (pctxt, RRCConnectionReestablishmentComplete);

         if (pvalue->u.rrcConnectionReestablishmentComplete == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionReestablishmentComplete (pvalue->u.rrcConnectionReestablishmentComplete);

         stat = asn1PD_RRCConnectionReestablishmentComplete (pctxt, pvalue->u.rrcConnectionReestablishmentComplete);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* rrcConnectionSetupComplete */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "rrcConnectionSetupComplete");

         pvalue->u.rrcConnectionSetupComplete = rtxMemAllocType (pctxt, 
            RRCConnectionSetupComplete);

         if (pvalue->u.rrcConnectionSetupComplete == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RRCConnectionSetupComplete (pvalue->u.rrcConnectionSetupComplete);

         stat = asn1PD_RRCConnectionSetupComplete (pctxt, pvalue->u.rrcConnectionSetupComplete);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* securityModeComplete */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "securityModeComplete");

         pvalue->u.securityModeComplete = rtxMemAllocType (pctxt, 
            SecurityModeComplete);

         if (pvalue->u.securityModeComplete == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SecurityModeComplete (pvalue->u.securityModeComplete);

         stat = asn1PD_SecurityModeComplete (pctxt, pvalue->u.securityModeComplete);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* securityModeFailure */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "securityModeFailure");

         pvalue->u.securityModeFailure = rtxMemAllocType (pctxt, 
            SecurityModeFailure);

         if (pvalue->u.securityModeFailure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SecurityModeFailure (pvalue->u.securityModeFailure);

         stat = asn1PD_SecurityModeFailure (pctxt, pvalue->u.securityModeFailure);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueCapabilityInformation */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "ueCapabilityInformation");

         pvalue->u.ueCapabilityInformation = rtxMemAllocType (pctxt, 
            UECapabilityInformation);

         if (pvalue->u.ueCapabilityInformation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UECapabilityInformation (pvalue->u.ueCapabilityInformation);

         stat = asn1PD_UECapabilityInformation (pctxt, pvalue->u.ueCapabilityInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ulHandoverPreparationTransfer */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "ulHandoverPreparationTransfer");

         pvalue->u.ulHandoverPreparationTransfer = rtxMemAllocType (pctxt, 
            ULHandoverPreparationTransfer);

         if (pvalue->u.ulHandoverPreparationTransfer == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ULHandoverPreparationTransfer (pvalue->u.ulHandoverPreparationTransfer);

         stat = asn1PD_ULHandoverPreparationTransfer (pctxt, pvalue->u.ulHandoverPreparationTransfer);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ulInformationTransfer */
      case 9:
         RTXCTXTPUSHELEMNAME (pctxt, "ulInformationTransfer");

         pvalue->u.ulInformationTransfer = rtxMemAllocType (pctxt, 
            ULInformationTransfer);

         if (pvalue->u.ulInformationTransfer == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ULInformationTransfer (pvalue->u.ulInformationTransfer);

         stat = asn1PD_ULInformationTransfer (pctxt, pvalue->u.ulInformationTransfer);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* counterCheckResponse */
      case 10:
         RTXCTXTPUSHELEMNAME (pctxt, "counterCheckResponse");

         pvalue->u.counterCheckResponse = rtxMemAllocType (pctxt, 
            CounterCheckResponse);

         if (pvalue->u.counterCheckResponse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CounterCheckResponse (pvalue->u.counterCheckResponse);

         stat = asn1PD_CounterCheckResponse (pctxt, pvalue->u.counterCheckResponse);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* ueInformationResponse_r9 */
      case 11:
         RTXCTXTPUSHELEMNAME (pctxt, "ueInformationResponse-r9");

         pvalue->u.ueInformationResponse_r9 = rtxMemAllocType (pctxt, 
            UEInformationResponse_r9);

         if (pvalue->u.ueInformationResponse_r9 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEInformationResponse_r9 (pvalue->u.ueInformationResponse_r9);

         stat = asn1PD_UEInformationResponse_r9 (pctxt, pvalue->u.ueInformationResponse_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* proximityIndication_r9 */
      case 12:
         RTXCTXTPUSHELEMNAME (pctxt, "proximityIndication-r9");

         pvalue->u.proximityIndication_r9 = rtxMemAllocType (pctxt, 
            ProximityIndication_r9);

         if (pvalue->u.proximityIndication_r9 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ProximityIndication_r9 (pvalue->u.proximityIndication_r9);

         stat = asn1PD_ProximityIndication_r9 (pctxt, pvalue->u.proximityIndication_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 13:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 14:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 15:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_UL_DCCH_MessageType_c1 (UL_DCCH_MessageType_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_UL_DCCH_MessageType_messageClassExtension (OSCTXT* pctxt, UL_DCCH_MessageType_messageClassExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UL_DCCH_MessageType_messageClassExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_DCCH_MessageType_messageClassExtension (OSCTXT* pctxt, UL_DCCH_MessageType_messageClassExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_UL_DCCH_MessageType (OSCTXT* pctxt, UL_DCCH_MessageType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DCCH-MessageType");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UL_DCCH_MessageType"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_UL_DCCH_MessageType_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* messageClassExtension */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "messageClassExtension");

         stat = asn1PE_UL_DCCH_MessageType_messageClassExtension (pctxt, pvalue->u.messageClassExtension);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_DCCH_MessageType (OSCTXT* pctxt, UL_DCCH_MessageType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DCCH-MessageType");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, UL_DCCH_MessageType_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UL_DCCH_MessageType_c1 (pvalue->u.c1);

         stat = asn1PD_UL_DCCH_MessageType_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* messageClassExtension */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "messageClassExtension");

         pvalue->u.messageClassExtension = rtxMemAllocTypeZ (pctxt, 
            UL_DCCH_MessageType_messageClassExtension);

         if (pvalue->u.messageClassExtension == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_UL_DCCH_MessageType_messageClassExtension (pctxt, pvalue->u.messageClassExtension);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UL_DCCH_MessageType (UL_DCCH_MessageType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_UL_DCCH_Message (OSCTXT* pctxt, UL_DCCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DCCH-Message");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UL_DCCH_Message"));

   /* encode message */

   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PE_UL_DCCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_DCCH_Message (OSCTXT* pctxt, UL_DCCH_Message* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-DCCH-Message");

   /* decode root elements */
   /* decode message */
   RTXCTXTPUSHELEMNAME (pctxt, "message");

   stat = asn1PD_UL_DCCH_MessageType (pctxt, &pvalue->message);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UL_DCCH_Message (UL_DCCH_Message* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_UL_DCCH_MessageType (&pvalue->message);
}

EXTERN int asn1PE_PDCP_Parameters_supportedROHC_Profiles (OSCTXT* pctxt, PDCP_Parameters_supportedROHC_Profiles* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("PDCP_Parameters_supportedROHC_Profiles"));

   /* encode profile0x0001 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0001");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0001);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0002 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0002");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0002);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0003 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0003");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0003);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0004 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0004");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0004);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0006 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0006");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0006);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0101 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0101");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0101);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0102 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0102");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0102);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0103 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0103");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0103);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode profile0x0104 */

   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0104");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->profile0x0104);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDCP_Parameters_supportedROHC_Profiles (OSCTXT* pctxt, PDCP_Parameters_supportedROHC_Profiles* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode profile0x0001 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0001");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0001);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0002 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0002");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0002);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0003 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0003");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0003);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0004 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0004");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0004);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0006 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0006");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0006);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0101 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0101");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0101);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0102 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0102");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0102);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0103 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0103");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0103);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode profile0x0104 */
   RTXCTXTPUSHELEMNAME (pctxt, "profile0x0104");

   stat = DEC_BIT (pctxt, &pvalue->profile0x0104);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PDCP_Parameters (OSCTXT* pctxt, PDCP_Parameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDCP-Parameters");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PDCP_Parameters"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)(pvalue->maxNumberROHC_ContextSessions != cs16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode supportedROHC_Profiles */

   RTXCTXTPUSHELEMNAME (pctxt, "supportedROHC-Profiles");

   stat = asn1PE_PDCP_Parameters_supportedROHC_Profiles (pctxt, &pvalue->supportedROHC_Profiles);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode maxNumberROHC_ContextSessions */

   if (pvalue->maxNumberROHC_ContextSessions != cs16) {
      RTXCTXTPUSHELEMNAME (pctxt, "maxNumberROHC-ContextSessions");

      stat = asn1PE_PDCP_Parameters_maxNumberROHC_ContextSessions (pctxt, pvalue->maxNumberROHC_ContextSessions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDCP_Parameters (OSCTXT* pctxt, PDCP_Parameters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDCP-Parameters");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode supportedROHC_Profiles */
   RTXCTXTPUSHELEMNAME (pctxt, "supportedROHC-Profiles");

   stat = asn1PD_PDCP_Parameters_supportedROHC_Profiles (pctxt, &pvalue->supportedROHC_Profiles);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maxNumberROHC_ContextSessions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "maxNumberROHC-ContextSessions");

      stat = asn1PD_PDCP_Parameters_maxNumberROHC_ContextSessions (pctxt, &pvalue->maxNumberROHC_ContextSessions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }
   else {
      pvalue->maxNumberROHC_ContextSessions = cs16;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PDCP_Parameters (PDCP_Parameters* pvalue)
{
   if (0 == pvalue) return;
   pvalue->maxNumberROHC_ContextSessions = cs16;
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_PhyLayerParameters (OSCTXT* pctxt, PhyLayerParameters* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhyLayerParameters");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhyLayerParameters"));

   /* encode ue_TxAntennaSelectionSupported */

   RTXCTXTPUSHELEMNAME (pctxt, "ue-TxAntennaSelectionSupported");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->ue_TxAntennaSelectionSupported);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ue_SpecificRefSigsSupported */

   RTXCTXTPUSHELEMNAME (pctxt, "ue-SpecificRefSigsSupported");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->ue_SpecificRefSigsSupported);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhyLayerParameters (OSCTXT* pctxt, PhyLayerParameters* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhyLayerParameters");

   /* decode root elements */
   /* decode ue_TxAntennaSelectionSupported */
   RTXCTXTPUSHELEMNAME (pctxt, "ue-TxAntennaSelectionSupported");

   stat = DEC_BIT (pctxt, &pvalue->ue_TxAntennaSelectionSupported);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ue_SpecificRefSigsSupported */
   RTXCTXTPUSHELEMNAME (pctxt, "ue-SpecificRefSigsSupported");

   stat = DEC_BIT (pctxt, &pvalue->ue_SpecificRefSigsSupported);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SupportedBandEUTRA (OSCTXT* pctxt, SupportedBandEUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SupportedBandEUTRA"));

   /* encode bandEUTRA */

   RTXCTXTPUSHELEMNAME (pctxt, "bandEUTRA");

   if ( (pvalue->bandEUTRA >= OSUINTCONST(1) && pvalue->bandEUTRA <= OSUINTCONST(64)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->bandEUTRA, OSUINTCONST(1), OSUINTCONST(64));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->bandEUTRA);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode halfDuplex */

   RTXCTXTPUSHELEMNAME (pctxt, "halfDuplex");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->halfDuplex);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedBandEUTRA (OSCTXT* pctxt, SupportedBandEUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandEUTRA");

   /* decode root elements */
   /* decode bandEUTRA */
   RTXCTXTPUSHELEMNAME (pctxt, "bandEUTRA");

   stat = pd_ConsUInt8 (pctxt, &pvalue->bandEUTRA, OSUINTCONST(1), OSUINTCONST(64));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode halfDuplex */
   RTXCTXTPUSHELEMNAME (pctxt, "halfDuplex");

   stat = DEC_BIT (pctxt, &pvalue->halfDuplex);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SupportedBandListEUTRA (OSCTXT* pctxt, SupportedBandListEUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandListEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SupportedBandListEUTRA"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedBandEUTRA", xx1);

      stat = asn1PE_SupportedBandEUTRA (pctxt, ((SupportedBandEUTRA*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedBandListEUTRA (OSCTXT* pctxt, SupportedBandListEUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandListEUTRA");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SupportedBandEUTRA* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedBandEUTRA", xx1);

      rtxDListAllocNodeAndData (pctxt, SupportedBandEUTRA, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_SupportedBandEUTRA (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SupportedBandListEUTRA (SupportedBandListEUTRA* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_RF_Parameters (OSCTXT* pctxt, RF_Parameters* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RF-Parameters");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RF_Parameters"));

   /* encode supportedBandListEUTRA */

   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandListEUTRA");

   stat = asn1PE_SupportedBandListEUTRA (pctxt, &pvalue->supportedBandListEUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RF_Parameters (OSCTXT* pctxt, RF_Parameters* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RF-Parameters");

   /* decode root elements */
   /* decode supportedBandListEUTRA */
   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandListEUTRA");

   stat = asn1PD_SupportedBandListEUTRA (pctxt, &pvalue->supportedBandListEUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RF_Parameters (RF_Parameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SupportedBandListEUTRA (&pvalue->supportedBandListEUTRA);
}

EXTERN int asn1PE_InterFreqBandInfo (OSCTXT* pctxt, InterFreqBandInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterFreqBandInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("InterFreqBandInfo"));

   /* encode interFreqNeedForGaps */

   RTXCTXTPUSHELEMNAME (pctxt, "interFreqNeedForGaps");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->interFreqNeedForGaps);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_InterFreqBandInfo (OSCTXT* pctxt, InterFreqBandInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterFreqBandInfo");

   /* decode root elements */
   /* decode interFreqNeedForGaps */
   RTXCTXTPUSHELEMNAME (pctxt, "interFreqNeedForGaps");

   stat = DEC_BIT (pctxt, &pvalue->interFreqNeedForGaps);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_InterFreqBandList (OSCTXT* pctxt, InterFreqBandList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "InterFreqBandList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("InterFreqBandList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InterFreqBandInfo", xx1);

      stat = asn1PE_InterFreqBandInfo (pctxt, ((InterFreqBandInfo*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_InterFreqBandList (OSCTXT* pctxt, InterFreqBandList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterFreqBandList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      InterFreqBandInfo* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InterFreqBandInfo", xx1);

      rtxDListAllocNodeAndData (pctxt, InterFreqBandInfo, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_InterFreqBandInfo (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_InterFreqBandList (InterFreqBandList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_InterRAT_BandInfo (OSCTXT* pctxt, InterRAT_BandInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterRAT-BandInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("InterRAT_BandInfo"));

   /* encode interRAT_NeedForGaps */

   RTXCTXTPUSHELEMNAME (pctxt, "interRAT-NeedForGaps");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->interRAT_NeedForGaps);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_InterRAT_BandInfo (OSCTXT* pctxt, InterRAT_BandInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterRAT-BandInfo");

   /* decode root elements */
   /* decode interRAT_NeedForGaps */
   RTXCTXTPUSHELEMNAME (pctxt, "interRAT-NeedForGaps");

   stat = DEC_BIT (pctxt, &pvalue->interRAT_NeedForGaps);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_InterRAT_BandList (OSCTXT* pctxt, InterRAT_BandList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "InterRAT-BandList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("InterRAT_BandList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InterRAT-BandInfo", xx1);

      stat = asn1PE_InterRAT_BandInfo (pctxt, ((InterRAT_BandInfo*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_InterRAT_BandList (OSCTXT* pctxt, InterRAT_BandList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterRAT-BandList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      InterRAT_BandInfo* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InterRAT-BandInfo", xx1);

      rtxDListAllocNodeAndData (pctxt, InterRAT_BandInfo, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_InterRAT_BandInfo (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_InterRAT_BandList (InterRAT_BandList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_BandInfoEUTRA (OSCTXT* pctxt, BandInfoEUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BandInfoEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BandInfoEUTRA"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.interRAT_BandListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode interFreqBandList */

   RTXCTXTPUSHELEMNAME (pctxt, "interFreqBandList");

   stat = asn1PE_InterFreqBandList (pctxt, &pvalue->interFreqBandList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode interRAT_BandList */

   if (pvalue->m.interRAT_BandListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "interRAT-BandList");

      stat = asn1PE_InterRAT_BandList (pctxt, &pvalue->interRAT_BandList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BandInfoEUTRA (OSCTXT* pctxt, BandInfoEUTRA* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "BandInfoEUTRA");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode interFreqBandList */
   RTXCTXTPUSHELEMNAME (pctxt, "interFreqBandList");

   stat = asn1PD_InterFreqBandList (pctxt, &pvalue->interFreqBandList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode interRAT_BandList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "interRAT-BandList");

      pvalue->m.interRAT_BandListPresent = 1;

      stat = asn1PD_InterRAT_BandList (pctxt, &pvalue->interRAT_BandList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_BandInfoEUTRA (BandInfoEUTRA* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_InterFreqBandList (&pvalue->interFreqBandList);
   asn1Init_InterRAT_BandList (&pvalue->interRAT_BandList);
}

EXTERN int asn1PE_BandListEUTRA (OSCTXT* pctxt, BandListEUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "BandListEUTRA");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("BandListEUTRA"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BandInfoEUTRA", xx1);

      stat = asn1PE_BandInfoEUTRA (pctxt, ((BandInfoEUTRA*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_BandListEUTRA (OSCTXT* pctxt, BandListEUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BandListEUTRA");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      BandInfoEUTRA* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BandInfoEUTRA", xx1);

      rtxDListAllocNodeAndData (pctxt, BandInfoEUTRA, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BandInfoEUTRA (pdata);

      stat = asn1PD_BandInfoEUTRA (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_BandListEUTRA (BandListEUTRA* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_MeasParameters (OSCTXT* pctxt, MeasParameters* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasParameters");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MeasParameters"));

   /* encode bandListEUTRA */

   RTXCTXTPUSHELEMNAME (pctxt, "bandListEUTRA");

   stat = asn1PE_BandListEUTRA (pctxt, &pvalue->bandListEUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MeasParameters (OSCTXT* pctxt, MeasParameters* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasParameters");

   /* decode root elements */
   /* decode bandListEUTRA */
   RTXCTXTPUSHELEMNAME (pctxt, "bandListEUTRA");

   stat = asn1PD_BandListEUTRA (pctxt, &pvalue->bandListEUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MeasParameters (MeasParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_BandListEUTRA (&pvalue->bandListEUTRA);
}

EXTERN int asn1PE_SupportedBandListUTRA_FDD (OSCTXT* pctxt, SupportedBandListUTRA_FDD* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandListUTRA-FDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SupportedBandListUTRA_FDD"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedBandUTRA-FDD", xx1);

      stat = asn1PE_SupportedBandUTRA_FDD (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedBandListUTRA_FDD (OSCTXT* pctxt, SupportedBandListUTRA_FDD* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandListUTRA-FDD");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 6);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 64) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedBandUTRA-FDD", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (SupportedBandUTRA_FDD));
      stat = asn1PD_SupportedBandUTRA_FDD (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SupportedBandListUTRA_FDD (SupportedBandListUTRA_FDD* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_IRAT_ParametersUTRA_FDD (OSCTXT* pctxt, IRAT_ParametersUTRA_FDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersUTRA-FDD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersUTRA_FDD"));

   /* encode supportedBandListUTRA_FDD */

   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandListUTRA-FDD");

   stat = asn1PE_SupportedBandListUTRA_FDD (pctxt, &pvalue->supportedBandListUTRA_FDD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersUTRA_FDD (OSCTXT* pctxt, IRAT_ParametersUTRA_FDD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersUTRA-FDD");

   /* decode root elements */
   /* decode supportedBandListUTRA_FDD */
   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandListUTRA-FDD");

   stat = asn1PD_SupportedBandListUTRA_FDD (pctxt, &pvalue->supportedBandListUTRA_FDD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_IRAT_ParametersUTRA_FDD (IRAT_ParametersUTRA_FDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SupportedBandListUTRA_FDD (&pvalue->supportedBandListUTRA_FDD);
}

EXTERN int asn1PE_SupportedBandListUTRA_TDD128 (OSCTXT* pctxt, SupportedBandListUTRA_TDD128* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandListUTRA-TDD128");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SupportedBandListUTRA_TDD128"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedBandUTRA-TDD128", xx1);

      stat = asn1PE_SupportedBandUTRA_TDD128 (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedBandListUTRA_TDD128 (OSCTXT* pctxt, SupportedBandListUTRA_TDD128* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandListUTRA-TDD128");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 6);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 64) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedBandUTRA-TDD128", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (SupportedBandUTRA_TDD128));
      stat = asn1PD_SupportedBandUTRA_TDD128 (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SupportedBandListUTRA_TDD128 (
   SupportedBandListUTRA_TDD128* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_IRAT_ParametersUTRA_TDD128 (OSCTXT* pctxt, IRAT_ParametersUTRA_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersUTRA-TDD128");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersUTRA_TDD128"));

   /* encode supportedBandListUTRA_TDD128 */

   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandListUTRA-TDD128");

   stat = asn1PE_SupportedBandListUTRA_TDD128 (pctxt, &pvalue->supportedBandListUTRA_TDD128);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersUTRA_TDD128 (OSCTXT* pctxt, IRAT_ParametersUTRA_TDD128* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersUTRA-TDD128");

   /* decode root elements */
   /* decode supportedBandListUTRA_TDD128 */
   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandListUTRA-TDD128");

   stat = asn1PD_SupportedBandListUTRA_TDD128 (pctxt, &pvalue->supportedBandListUTRA_TDD128);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_IRAT_ParametersUTRA_TDD128 (IRAT_ParametersUTRA_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SupportedBandListUTRA_TDD128 (&pvalue->supportedBandListUTRA_TDD128);
}

EXTERN int asn1PE_SupportedBandListUTRA_TDD384 (OSCTXT* pctxt, SupportedBandListUTRA_TDD384* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandListUTRA-TDD384");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SupportedBandListUTRA_TDD384"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedBandUTRA-TDD384", xx1);

      stat = asn1PE_SupportedBandUTRA_TDD384 (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedBandListUTRA_TDD384 (OSCTXT* pctxt, SupportedBandListUTRA_TDD384* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandListUTRA-TDD384");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 6);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 64) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedBandUTRA-TDD384", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (SupportedBandUTRA_TDD384));
      stat = asn1PD_SupportedBandUTRA_TDD384 (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SupportedBandListUTRA_TDD384 (
   SupportedBandListUTRA_TDD384* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_IRAT_ParametersUTRA_TDD384 (OSCTXT* pctxt, IRAT_ParametersUTRA_TDD384* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersUTRA-TDD384");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersUTRA_TDD384"));

   /* encode supportedBandListUTRA_TDD384 */

   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandListUTRA-TDD384");

   stat = asn1PE_SupportedBandListUTRA_TDD384 (pctxt, &pvalue->supportedBandListUTRA_TDD384);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersUTRA_TDD384 (OSCTXT* pctxt, IRAT_ParametersUTRA_TDD384* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersUTRA-TDD384");

   /* decode root elements */
   /* decode supportedBandListUTRA_TDD384 */
   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandListUTRA-TDD384");

   stat = asn1PD_SupportedBandListUTRA_TDD384 (pctxt, &pvalue->supportedBandListUTRA_TDD384);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_IRAT_ParametersUTRA_TDD384 (IRAT_ParametersUTRA_TDD384* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SupportedBandListUTRA_TDD384 (&pvalue->supportedBandListUTRA_TDD384);
}

EXTERN int asn1PE_SupportedBandListUTRA_TDD768 (OSCTXT* pctxt, SupportedBandListUTRA_TDD768* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandListUTRA-TDD768");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SupportedBandListUTRA_TDD768"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedBandUTRA-TDD768", xx1);

      stat = asn1PE_SupportedBandUTRA_TDD768 (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedBandListUTRA_TDD768 (OSCTXT* pctxt, SupportedBandListUTRA_TDD768* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandListUTRA-TDD768");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 6);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 64) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedBandUTRA-TDD768", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (SupportedBandUTRA_TDD768));
      stat = asn1PD_SupportedBandUTRA_TDD768 (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SupportedBandListUTRA_TDD768 (
   SupportedBandListUTRA_TDD768* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_IRAT_ParametersUTRA_TDD768 (OSCTXT* pctxt, IRAT_ParametersUTRA_TDD768* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersUTRA-TDD768");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersUTRA_TDD768"));

   /* encode supportedBandListUTRA_TDD768 */

   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandListUTRA-TDD768");

   stat = asn1PE_SupportedBandListUTRA_TDD768 (pctxt, &pvalue->supportedBandListUTRA_TDD768);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersUTRA_TDD768 (OSCTXT* pctxt, IRAT_ParametersUTRA_TDD768* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersUTRA-TDD768");

   /* decode root elements */
   /* decode supportedBandListUTRA_TDD768 */
   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandListUTRA-TDD768");

   stat = asn1PD_SupportedBandListUTRA_TDD768 (pctxt, &pvalue->supportedBandListUTRA_TDD768);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_IRAT_ParametersUTRA_TDD768 (IRAT_ParametersUTRA_TDD768* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SupportedBandListUTRA_TDD768 (&pvalue->supportedBandListUTRA_TDD768);
}

EXTERN int asn1PE_SupportedBandListGERAN (OSCTXT* pctxt, SupportedBandListGERAN* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandListGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SupportedBandListGERAN"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedBandGERAN", xx1);

      stat = asn1PE_SupportedBandGERAN (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedBandListGERAN (OSCTXT* pctxt, SupportedBandListGERAN* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandListGERAN");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 6);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 64) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedBandGERAN", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (SupportedBandGERAN));
      stat = asn1PD_SupportedBandGERAN (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SupportedBandListGERAN (SupportedBandListGERAN* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_IRAT_ParametersGERAN (OSCTXT* pctxt, IRAT_ParametersGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersGERAN");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersGERAN"));

   /* encode supportedBandListGERAN */

   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandListGERAN");

   stat = asn1PE_SupportedBandListGERAN (pctxt, &pvalue->supportedBandListGERAN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode interRAT_PS_HO_ToGERAN */

   RTXCTXTPUSHELEMNAME (pctxt, "interRAT-PS-HO-ToGERAN");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->interRAT_PS_HO_ToGERAN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersGERAN (OSCTXT* pctxt, IRAT_ParametersGERAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersGERAN");

   /* decode root elements */
   /* decode supportedBandListGERAN */
   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandListGERAN");

   stat = asn1PD_SupportedBandListGERAN (pctxt, &pvalue->supportedBandListGERAN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode interRAT_PS_HO_ToGERAN */
   RTXCTXTPUSHELEMNAME (pctxt, "interRAT-PS-HO-ToGERAN");

   stat = DEC_BIT (pctxt, &pvalue->interRAT_PS_HO_ToGERAN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_IRAT_ParametersGERAN (IRAT_ParametersGERAN* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SupportedBandListGERAN (&pvalue->supportedBandListGERAN);
}

EXTERN int asn1PE_SupportedBandListHRPD (OSCTXT* pctxt, SupportedBandListHRPD* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandListHRPD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SupportedBandListHRPD"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BandclassCDMA2000", xx1);

      stat = asn1PE_BandclassCDMA2000 (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedBandListHRPD (OSCTXT* pctxt, SupportedBandListHRPD* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandListHRPD");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 5);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 32) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BandclassCDMA2000", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (BandclassCDMA2000));
      stat = asn1PD_BandclassCDMA2000 (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SupportedBandListHRPD (SupportedBandListHRPD* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_IRAT_ParametersCDMA2000_HRPD (OSCTXT* pctxt, IRAT_ParametersCDMA2000_HRPD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersCDMA2000-HRPD");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersCDMA2000_HRPD"));

   /* encode supportedBandListHRPD */

   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandListHRPD");

   stat = asn1PE_SupportedBandListHRPD (pctxt, &pvalue->supportedBandListHRPD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode tx_ConfigHRPD */

   RTXCTXTPUSHELEMNAME (pctxt, "tx-ConfigHRPD");

   stat = asn1PE_IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD (pctxt, pvalue->tx_ConfigHRPD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rx_ConfigHRPD */

   RTXCTXTPUSHELEMNAME (pctxt, "rx-ConfigHRPD");

   stat = asn1PE_IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD (pctxt, pvalue->rx_ConfigHRPD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersCDMA2000_HRPD (OSCTXT* pctxt, IRAT_ParametersCDMA2000_HRPD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersCDMA2000-HRPD");

   /* decode root elements */
   /* decode supportedBandListHRPD */
   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandListHRPD");

   stat = asn1PD_SupportedBandListHRPD (pctxt, &pvalue->supportedBandListHRPD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tx_ConfigHRPD */
   RTXCTXTPUSHELEMNAME (pctxt, "tx-ConfigHRPD");

   stat = asn1PD_IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD (pctxt, &pvalue->tx_ConfigHRPD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rx_ConfigHRPD */
   RTXCTXTPUSHELEMNAME (pctxt, "rx-ConfigHRPD");

   stat = asn1PD_IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD (pctxt, &pvalue->rx_ConfigHRPD);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_IRAT_ParametersCDMA2000_HRPD (
   IRAT_ParametersCDMA2000_HRPD* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SupportedBandListHRPD (&pvalue->supportedBandListHRPD);
}

EXTERN int asn1PE_SupportedBandList1XRTT (OSCTXT* pctxt, SupportedBandList1XRTT* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandList1XRTT");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SupportedBandList1XRTT"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BandclassCDMA2000", xx1);

      stat = asn1PE_BandclassCDMA2000 (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedBandList1XRTT (OSCTXT* pctxt, SupportedBandList1XRTT* pvalue)
{
   int stat = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBandList1XRTT");

   /* decode length determinant */

   stat = rtxDecBits (pctxt, &pvalue->n, 5);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   /* decode elements */

   if (pvalue->n > 32) {
      pvalue->n = 0;
      return LOG_RTERR (pctxt, RTERR_TOOBIG);
   }

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BandclassCDMA2000", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (BandclassCDMA2000));
      stat = asn1PD_BandclassCDMA2000 (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SupportedBandList1XRTT (SupportedBandList1XRTT* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

EXTERN int asn1PE_IRAT_ParametersCDMA2000_1XRTT (OSCTXT* pctxt, IRAT_ParametersCDMA2000_1XRTT* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersCDMA2000-1XRTT");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersCDMA2000_1XRTT"));

   /* encode supportedBandList1XRTT */

   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandList1XRTT");

   stat = asn1PE_SupportedBandList1XRTT (pctxt, &pvalue->supportedBandList1XRTT);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode tx_Config1XRTT */

   RTXCTXTPUSHELEMNAME (pctxt, "tx-Config1XRTT");

   stat = asn1PE_IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT (pctxt, pvalue->tx_Config1XRTT);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rx_Config1XRTT */

   RTXCTXTPUSHELEMNAME (pctxt, "rx-Config1XRTT");

   stat = asn1PE_IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT (pctxt, pvalue->rx_Config1XRTT);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersCDMA2000_1XRTT (OSCTXT* pctxt, IRAT_ParametersCDMA2000_1XRTT* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersCDMA2000-1XRTT");

   /* decode root elements */
   /* decode supportedBandList1XRTT */
   RTXCTXTPUSHELEMNAME (pctxt, "supportedBandList1XRTT");

   stat = asn1PD_SupportedBandList1XRTT (pctxt, &pvalue->supportedBandList1XRTT);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tx_Config1XRTT */
   RTXCTXTPUSHELEMNAME (pctxt, "tx-Config1XRTT");

   stat = asn1PD_IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT (pctxt, &pvalue->tx_Config1XRTT);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rx_Config1XRTT */
   RTXCTXTPUSHELEMNAME (pctxt, "rx-Config1XRTT");

   stat = asn1PD_IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT (pctxt, &pvalue->rx_Config1XRTT);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_IRAT_ParametersCDMA2000_1XRTT (
   IRAT_ParametersCDMA2000_1XRTT* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_SupportedBandList1XRTT (&pvalue->supportedBandList1XRTT);
}

EXTERN int asn1PE_UE_EUTRA_Capability_interRAT_Parameters (OSCTXT* pctxt, UE_EUTRA_Capability_interRAT_Parameters* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_EUTRA_Capability_interRAT_Parameters"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.utraFDDPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.utraTDD128Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.utraTDD384Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.utraTDD768Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.geranPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cdma2000_HRPDPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cdma2000_1xRTTPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode utraFDD */

   if (pvalue->m.utraFDDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "utraFDD");

      stat = asn1PE_IRAT_ParametersUTRA_FDD (pctxt, &pvalue->utraFDD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode utraTDD128 */

   if (pvalue->m.utraTDD128Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "utraTDD128");

      stat = asn1PE_IRAT_ParametersUTRA_TDD128 (pctxt, &pvalue->utraTDD128);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode utraTDD384 */

   if (pvalue->m.utraTDD384Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "utraTDD384");

      stat = asn1PE_IRAT_ParametersUTRA_TDD384 (pctxt, &pvalue->utraTDD384);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode utraTDD768 */

   if (pvalue->m.utraTDD768Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "utraTDD768");

      stat = asn1PE_IRAT_ParametersUTRA_TDD768 (pctxt, &pvalue->utraTDD768);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode geran */

   if (pvalue->m.geranPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "geran");

      stat = asn1PE_IRAT_ParametersGERAN (pctxt, &pvalue->geran);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cdma2000_HRPD */

   if (pvalue->m.cdma2000_HRPDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cdma2000-HRPD");

      stat = asn1PE_IRAT_ParametersCDMA2000_HRPD (pctxt, &pvalue->cdma2000_HRPD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cdma2000_1xRTT */

   if (pvalue->m.cdma2000_1xRTTPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cdma2000-1xRTT");

      stat = asn1PE_IRAT_ParametersCDMA2000_1XRTT (pctxt, &pvalue->cdma2000_1xRTT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_EUTRA_Capability_interRAT_Parameters (OSCTXT* pctxt, UE_EUTRA_Capability_interRAT_Parameters* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[7];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode utraFDD */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "utraFDD");

      pvalue->m.utraFDDPresent = 1;

      stat = asn1PD_IRAT_ParametersUTRA_FDD (pctxt, &pvalue->utraFDD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode utraTDD128 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "utraTDD128");

      pvalue->m.utraTDD128Present = 1;

      stat = asn1PD_IRAT_ParametersUTRA_TDD128 (pctxt, &pvalue->utraTDD128);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode utraTDD384 */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "utraTDD384");

      pvalue->m.utraTDD384Present = 1;

      stat = asn1PD_IRAT_ParametersUTRA_TDD384 (pctxt, &pvalue->utraTDD384);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode utraTDD768 */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "utraTDD768");

      pvalue->m.utraTDD768Present = 1;

      stat = asn1PD_IRAT_ParametersUTRA_TDD768 (pctxt, &pvalue->utraTDD768);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode geran */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "geran");

      pvalue->m.geranPresent = 1;

      stat = asn1PD_IRAT_ParametersGERAN (pctxt, &pvalue->geran);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cdma2000_HRPD */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cdma2000-HRPD");

      pvalue->m.cdma2000_HRPDPresent = 1;

      stat = asn1PD_IRAT_ParametersCDMA2000_HRPD (pctxt, &pvalue->cdma2000_HRPD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cdma2000_1xRTT */
   if (optbits[6]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cdma2000-1xRTT");

      pvalue->m.cdma2000_1xRTTPresent = 1;

      stat = asn1PD_IRAT_ParametersCDMA2000_1XRTT (pctxt, &pvalue->cdma2000_1xRTT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

void asn1Init_UE_EUTRA_Capability_interRAT_Parameters (
   UE_EUTRA_Capability_interRAT_Parameters* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_IRAT_ParametersUTRA_FDD (&pvalue->utraFDD);
   asn1Init_IRAT_ParametersUTRA_TDD128 (&pvalue->utraTDD128);
   asn1Init_IRAT_ParametersUTRA_TDD384 (&pvalue->utraTDD384);
   asn1Init_IRAT_ParametersUTRA_TDD768 (&pvalue->utraTDD768);
   asn1Init_IRAT_ParametersGERAN (&pvalue->geran);
   asn1Init_IRAT_ParametersCDMA2000_HRPD (&pvalue->cdma2000_HRPD);
   asn1Init_IRAT_ParametersCDMA2000_1XRTT (&pvalue->cdma2000_1xRTT);
}

EXTERN int asn1PE_PhyLayerParameters_v920 (OSCTXT* pctxt, PhyLayerParameters_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhyLayerParameters-v920");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("PhyLayerParameters_v920"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.enhancedDualLayerFDD_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.enhancedDualLayerTDD_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode enhancedDualLayerFDD_r9 */

   if (pvalue->m.enhancedDualLayerFDD_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "enhancedDualLayerFDD-r9");

      stat = asn1PE_PhyLayerParameters_v920_enhancedDualLayerFDD_r9 (pctxt, pvalue->enhancedDualLayerFDD_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode enhancedDualLayerTDD_r9 */

   if (pvalue->m.enhancedDualLayerTDD_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "enhancedDualLayerTDD-r9");

      stat = asn1PE_PhyLayerParameters_v920_enhancedDualLayerTDD_r9 (pctxt, pvalue->enhancedDualLayerTDD_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_PhyLayerParameters_v920 (OSCTXT* pctxt, PhyLayerParameters_v920* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "PhyLayerParameters-v920");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode enhancedDualLayerFDD_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "enhancedDualLayerFDD-r9");

      pvalue->m.enhancedDualLayerFDD_r9Present = 1;

      stat = asn1PD_PhyLayerParameters_v920_enhancedDualLayerFDD_r9 (pctxt, &pvalue->enhancedDualLayerFDD_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode enhancedDualLayerTDD_r9 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "enhancedDualLayerTDD-r9");

      pvalue->m.enhancedDualLayerTDD_r9Present = 1;

      stat = asn1PD_PhyLayerParameters_v920_enhancedDualLayerTDD_r9 (pctxt, &pvalue->enhancedDualLayerTDD_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_PhyLayerParameters_v920 (PhyLayerParameters_v920* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_IRAT_ParametersGERAN_v920 (OSCTXT* pctxt, IRAT_ParametersGERAN_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersGERAN-v920");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersGERAN_v920"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dtm_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.e_RedirectionGERAN_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dtm_r9 */

   if (pvalue->m.dtm_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "dtm-r9");

      stat = asn1PE_IRAT_ParametersGERAN_v920_dtm_r9 (pctxt, pvalue->dtm_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode e_RedirectionGERAN_r9 */

   if (pvalue->m.e_RedirectionGERAN_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RedirectionGERAN-r9");

      stat = asn1PE_IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9 (pctxt, pvalue->e_RedirectionGERAN_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersGERAN_v920 (OSCTXT* pctxt, IRAT_ParametersGERAN_v920* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersGERAN-v920");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dtm_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dtm-r9");

      pvalue->m.dtm_r9Present = 1;

      stat = asn1PD_IRAT_ParametersGERAN_v920_dtm_r9 (pctxt, &pvalue->dtm_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_RedirectionGERAN_r9 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RedirectionGERAN-r9");

      pvalue->m.e_RedirectionGERAN_r9Present = 1;

      stat = asn1PD_IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9 (pctxt, &pvalue->e_RedirectionGERAN_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_IRAT_ParametersGERAN_v920 (IRAT_ParametersGERAN_v920* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_IRAT_ParametersUTRA_v920 (OSCTXT* pctxt, IRAT_ParametersUTRA_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersUTRA-v920");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersUTRA_v920"));

   /* encode e_RedirectionUTRA_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "e-RedirectionUTRA-r9");

   stat = asn1PE_IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9 (pctxt, pvalue->e_RedirectionUTRA_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersUTRA_v920 (OSCTXT* pctxt, IRAT_ParametersUTRA_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersUTRA-v920");

   /* decode root elements */
   /* decode e_RedirectionUTRA_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "e-RedirectionUTRA-r9");

   stat = asn1PD_IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9 (pctxt, &pvalue->e_RedirectionUTRA_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_IRAT_ParametersCDMA2000_1XRTT_v920 (OSCTXT* pctxt, IRAT_ParametersCDMA2000_1XRTT_v920* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersCDMA2000-1XRTT-v920");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("IRAT_ParametersCDMA2000_1XRTT_v920"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.e_CSFB_ConcPS_Mob1XRTT_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode e_CSFB_1XRTT_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "e-CSFB-1XRTT-r9");

   stat = asn1PE_IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9 (pctxt, pvalue->e_CSFB_1XRTT_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode e_CSFB_ConcPS_Mob1XRTT_r9 */

   if (pvalue->m.e_CSFB_ConcPS_Mob1XRTT_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-CSFB-ConcPS-Mob1XRTT-r9");

      stat = asn1PE_IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9 (pctxt, pvalue->e_CSFB_ConcPS_Mob1XRTT_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_IRAT_ParametersCDMA2000_1XRTT_v920 (OSCTXT* pctxt, IRAT_ParametersCDMA2000_1XRTT_v920* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-ParametersCDMA2000-1XRTT-v920");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode e_CSFB_1XRTT_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "e-CSFB-1XRTT-r9");

   stat = asn1PD_IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9 (pctxt, &pvalue->e_CSFB_1XRTT_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_CSFB_ConcPS_Mob1XRTT_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-CSFB-ConcPS-Mob1XRTT-r9");

      pvalue->m.e_CSFB_ConcPS_Mob1XRTT_r9Present = 1;

      stat = asn1PD_IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9 (pctxt, &pvalue->e_CSFB_ConcPS_Mob1XRTT_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_IRAT_ParametersCDMA2000_1XRTT_v920 (
   IRAT_ParametersCDMA2000_1XRTT_v920* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_CSG_ProximityIndicationParameters_r9 (OSCTXT* pctxt, CSG_ProximityIndicationParameters_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSG-ProximityIndicationParameters-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CSG_ProximityIndicationParameters_r9"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.intraFreqProximityIndication_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.interFreqProximityIndication_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.utran_ProximityIndication_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode intraFreqProximityIndication_r9 */

   if (pvalue->m.intraFreqProximityIndication_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "intraFreqProximityIndication-r9");

      stat = asn1PE_CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9 (pctxt, pvalue->intraFreqProximityIndication_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode interFreqProximityIndication_r9 */

   if (pvalue->m.interFreqProximityIndication_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "interFreqProximityIndication-r9");

      stat = asn1PE_CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9 (pctxt, pvalue->interFreqProximityIndication_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode utran_ProximityIndication_r9 */

   if (pvalue->m.utran_ProximityIndication_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "utran-ProximityIndication-r9");

      stat = asn1PE_CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9 (pctxt, pvalue->utran_ProximityIndication_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CSG_ProximityIndicationParameters_r9 (OSCTXT* pctxt, CSG_ProximityIndicationParameters_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "CSG-ProximityIndicationParameters-r9");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode intraFreqProximityIndication_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "intraFreqProximityIndication-r9");

      pvalue->m.intraFreqProximityIndication_r9Present = 1;

      stat = asn1PD_CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9 (pctxt, &pvalue->intraFreqProximityIndication_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode interFreqProximityIndication_r9 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "interFreqProximityIndication-r9");

      pvalue->m.interFreqProximityIndication_r9Present = 1;

      stat = asn1PD_CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9 (pctxt, &pvalue->interFreqProximityIndication_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode utran_ProximityIndication_r9 */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "utran-ProximityIndication-r9");

      pvalue->m.utran_ProximityIndication_r9Present = 1;

      stat = asn1PD_CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9 (pctxt, &pvalue->utran_ProximityIndication_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CSG_ProximityIndicationParameters_r9 (
   CSG_ProximityIndicationParameters_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_NeighCellSI_AcquisitionParameters_r9 (OSCTXT* pctxt, NeighCellSI_AcquisitionParameters_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellSI-AcquisitionParameters-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("NeighCellSI_AcquisitionParameters_r9"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.intraFreqSI_AcquisitionForHO_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.interFreqSI_AcquisitionForHO_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.utran_SI_AcquisitionForHO_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode intraFreqSI_AcquisitionForHO_r9 */

   if (pvalue->m.intraFreqSI_AcquisitionForHO_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "intraFreqSI-AcquisitionForHO-r9");

      stat = asn1PE_NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9 (pctxt, pvalue->intraFreqSI_AcquisitionForHO_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode interFreqSI_AcquisitionForHO_r9 */

   if (pvalue->m.interFreqSI_AcquisitionForHO_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "interFreqSI-AcquisitionForHO-r9");

      stat = asn1PE_NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9 (pctxt, pvalue->interFreqSI_AcquisitionForHO_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode utran_SI_AcquisitionForHO_r9 */

   if (pvalue->m.utran_SI_AcquisitionForHO_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "utran-SI-AcquisitionForHO-r9");

      stat = asn1PE_NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9 (pctxt, pvalue->utran_SI_AcquisitionForHO_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_NeighCellSI_AcquisitionParameters_r9 (OSCTXT* pctxt, NeighCellSI_AcquisitionParameters_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "NeighCellSI-AcquisitionParameters-r9");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode intraFreqSI_AcquisitionForHO_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "intraFreqSI-AcquisitionForHO-r9");

      pvalue->m.intraFreqSI_AcquisitionForHO_r9Present = 1;

      stat = asn1PD_NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9 (pctxt, &pvalue->intraFreqSI_AcquisitionForHO_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode interFreqSI_AcquisitionForHO_r9 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "interFreqSI-AcquisitionForHO-r9");

      pvalue->m.interFreqSI_AcquisitionForHO_r9Present = 1;

      stat = asn1PD_NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9 (pctxt, &pvalue->interFreqSI_AcquisitionForHO_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode utran_SI_AcquisitionForHO_r9 */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "utran-SI-AcquisitionForHO-r9");

      pvalue->m.utran_SI_AcquisitionForHO_r9Present = 1;

      stat = asn1PD_NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9 (pctxt, &pvalue->utran_SI_AcquisitionForHO_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_NeighCellSI_AcquisitionParameters_r9 (
   NeighCellSI_AcquisitionParameters_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_SON_Parameters_r9 (OSCTXT* pctxt, SON_Parameters_r9* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SON-Parameters-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("SON_Parameters_r9"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rach_Report_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rach_Report_r9 */

   if (pvalue->m.rach_Report_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "rach-Report-r9");

      stat = asn1PE_SON_Parameters_r9_rach_Report_r9 (pctxt, pvalue->rach_Report_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_SON_Parameters_r9 (OSCTXT* pctxt, SON_Parameters_r9* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SON-Parameters-r9");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rach_Report_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rach-Report-r9");

      pvalue->m.rach_Report_r9Present = 1;

      stat = asn1PD_SON_Parameters_r9_rach_Report_r9 (pctxt, &pvalue->rach_Report_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_SON_Parameters_r9 (SON_Parameters_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_UE_EUTRA_Capability_v940_IEs_nonCriticalExtension (OSCTXT* pctxt, UE_EUTRA_Capability_v940_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_EUTRA_Capability_v940_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_EUTRA_Capability_v940_IEs_nonCriticalExtension (OSCTXT* pctxt, UE_EUTRA_Capability_v940_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_UE_EUTRA_Capability_v940_IEs (OSCTXT* pctxt, UE_EUTRA_Capability_v940_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-EUTRA-Capability-v940-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_EUTRA_Capability_v940_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.lateNonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lateNonCriticalExtension */

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      stat = pe_OctetString (pctxt, pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_UE_EUTRA_Capability_v940_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_EUTRA_Capability_v940_IEs (OSCTXT* pctxt, UE_EUTRA_Capability_v940_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "UE-EUTRA-Capability-v940-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lateNonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "lateNonCriticalExtension");

      pvalue->m.lateNonCriticalExtensionPresent = 1;

      stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->lateNonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_UE_EUTRA_Capability_v940_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UE_EUTRA_Capability_v940_IEs (
   UE_EUTRA_Capability_v940_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->lateNonCriticalExtension.numocts = 0;
   pvalue->lateNonCriticalExtension.data = 0;
}

EXTERN int asn1PE_UE_EUTRA_Capability_v920_IEs (OSCTXT* pctxt, UE_EUTRA_Capability_v920_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-EUTRA-Capability-v920-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_EUTRA_Capability_v920_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.interRAT_ParametersUTRA_v920Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.interRAT_ParametersCDMA2000_v920Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.deviceType_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode phyLayerParameters_v920 */

   RTXCTXTPUSHELEMNAME (pctxt, "phyLayerParameters-v920");

   stat = asn1PE_PhyLayerParameters_v920 (pctxt, &pvalue->phyLayerParameters_v920);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode interRAT_ParametersGERAN_v920 */

   RTXCTXTPUSHELEMNAME (pctxt, "interRAT-ParametersGERAN-v920");

   stat = asn1PE_IRAT_ParametersGERAN_v920 (pctxt, &pvalue->interRAT_ParametersGERAN_v920);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode interRAT_ParametersUTRA_v920 */

   if (pvalue->m.interRAT_ParametersUTRA_v920Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "interRAT-ParametersUTRA-v920");

      stat = asn1PE_IRAT_ParametersUTRA_v920 (pctxt, &pvalue->interRAT_ParametersUTRA_v920);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode interRAT_ParametersCDMA2000_v920 */

   if (pvalue->m.interRAT_ParametersCDMA2000_v920Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "interRAT-ParametersCDMA2000-v920");

      stat = asn1PE_IRAT_ParametersCDMA2000_1XRTT_v920 (pctxt, &pvalue->interRAT_ParametersCDMA2000_v920);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode deviceType_r9 */

   if (pvalue->m.deviceType_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "deviceType-r9");

      stat = asn1PE_UE_EUTRA_Capability_v920_IEs_deviceType_r9 (pctxt, pvalue->deviceType_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode csg_ProximityIndicationParameters_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "csg-ProximityIndicationParameters-r9");

   stat = asn1PE_CSG_ProximityIndicationParameters_r9 (pctxt, &pvalue->csg_ProximityIndicationParameters_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode neighCellSI_AcquisitionParameters_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "neighCellSI-AcquisitionParameters-r9");

   stat = asn1PE_NeighCellSI_AcquisitionParameters_r9 (pctxt, &pvalue->neighCellSI_AcquisitionParameters_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode son_Parameters_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "son-Parameters-r9");

   stat = asn1PE_SON_Parameters_r9 (pctxt, &pvalue->son_Parameters_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_UE_EUTRA_Capability_v940_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_EUTRA_Capability_v920_IEs (OSCTXT* pctxt, UE_EUTRA_Capability_v920_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "UE-EUTRA-Capability-v920-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode phyLayerParameters_v920 */
   RTXCTXTPUSHELEMNAME (pctxt, "phyLayerParameters-v920");

   stat = asn1PD_PhyLayerParameters_v920 (pctxt, &pvalue->phyLayerParameters_v920);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode interRAT_ParametersGERAN_v920 */
   RTXCTXTPUSHELEMNAME (pctxt, "interRAT-ParametersGERAN-v920");

   stat = asn1PD_IRAT_ParametersGERAN_v920 (pctxt, &pvalue->interRAT_ParametersGERAN_v920);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode interRAT_ParametersUTRA_v920 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "interRAT-ParametersUTRA-v920");

      pvalue->m.interRAT_ParametersUTRA_v920Present = 1;

      stat = asn1PD_IRAT_ParametersUTRA_v920 (pctxt, &pvalue->interRAT_ParametersUTRA_v920);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode interRAT_ParametersCDMA2000_v920 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "interRAT-ParametersCDMA2000-v920");

      pvalue->m.interRAT_ParametersCDMA2000_v920Present = 1;

      stat = asn1PD_IRAT_ParametersCDMA2000_1XRTT_v920 (pctxt, &pvalue->interRAT_ParametersCDMA2000_v920);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode deviceType_r9 */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "deviceType-r9");

      pvalue->m.deviceType_r9Present = 1;

      stat = asn1PD_UE_EUTRA_Capability_v920_IEs_deviceType_r9 (pctxt, &pvalue->deviceType_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode csg_ProximityIndicationParameters_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "csg-ProximityIndicationParameters-r9");

   stat = asn1PD_CSG_ProximityIndicationParameters_r9 (pctxt, &pvalue->csg_ProximityIndicationParameters_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode neighCellSI_AcquisitionParameters_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "neighCellSI-AcquisitionParameters-r9");

   stat = asn1PD_NeighCellSI_AcquisitionParameters_r9 (pctxt, &pvalue->neighCellSI_AcquisitionParameters_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode son_Parameters_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "son-Parameters-r9");

   stat = asn1PD_SON_Parameters_r9 (pctxt, &pvalue->son_Parameters_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_UE_EUTRA_Capability_v940_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UE_EUTRA_Capability_v920_IEs (
   UE_EUTRA_Capability_v920_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PhyLayerParameters_v920 (&pvalue->phyLayerParameters_v920);
   asn1Init_IRAT_ParametersGERAN_v920 (&pvalue->interRAT_ParametersGERAN_v920);
   asn1Init_IRAT_ParametersCDMA2000_1XRTT_v920 (&pvalue->interRAT_ParametersCDMA2000_v920);
   asn1Init_CSG_ProximityIndicationParameters_r9 (&pvalue->csg_ProximityIndicationParameters_r9);
   asn1Init_NeighCellSI_AcquisitionParameters_r9 (&pvalue->neighCellSI_AcquisitionParameters_r9);
   asn1Init_SON_Parameters_r9 (&pvalue->son_Parameters_r9);
   asn1Init_UE_EUTRA_Capability_v940_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_UE_EUTRA_Capability (OSCTXT* pctxt, UE_EUTRA_Capability* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-EUTRA-Capability");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UE_EUTRA_Capability"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.featureGroupIndicatorsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accessStratumRelease */

   RTXCTXTPUSHELEMNAME (pctxt, "accessStratumRelease");

   stat = asn1PE_AccessStratumRelease (pctxt, pvalue->accessStratumRelease);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ue_Category */

   RTXCTXTPUSHELEMNAME (pctxt, "ue-Category");

   if ( (pvalue->ue_Category >= OSUINTCONST(1) && pvalue->ue_Category
       <= OSUINTCONST(5)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ue_Category, OSUINTCONST(1), OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ue_Category);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pdcp_Parameters */

   RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Parameters");

   stat = asn1PE_PDCP_Parameters (pctxt, &pvalue->pdcp_Parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode phyLayerParameters */

   RTXCTXTPUSHELEMNAME (pctxt, "phyLayerParameters");

   stat = asn1PE_PhyLayerParameters (pctxt, &pvalue->phyLayerParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rf_Parameters */

   RTXCTXTPUSHELEMNAME (pctxt, "rf-Parameters");

   stat = asn1PE_RF_Parameters (pctxt, &pvalue->rf_Parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode measParameters */

   RTXCTXTPUSHELEMNAME (pctxt, "measParameters");

   stat = asn1PE_MeasParameters (pctxt, &pvalue->measParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode featureGroupIndicators */

   if (pvalue->m.featureGroupIndicatorsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "featureGroupIndicators");

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(32), OSUINTCONST(32), 0, 0);

      stat = pe_BitString32 (pctxt, &pvalue->featureGroupIndicators, OSUINTCONST(32), OSUINTCONST(32));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode interRAT_Parameters */

   RTXCTXTPUSHELEMNAME (pctxt, "interRAT-Parameters");

   stat = asn1PE_UE_EUTRA_Capability_interRAT_Parameters (pctxt, &pvalue->interRAT_Parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_UE_EUTRA_Capability_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_EUTRA_Capability (OSCTXT* pctxt, UE_EUTRA_Capability* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "UE-EUTRA-Capability");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode accessStratumRelease */
   RTXCTXTPUSHELEMNAME (pctxt, "accessStratumRelease");

   stat = asn1PD_AccessStratumRelease (pctxt, &pvalue->accessStratumRelease);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ue_Category */
   RTXCTXTPUSHELEMNAME (pctxt, "ue-Category");

   stat = pd_ConsUInt8 (pctxt, &pvalue->ue_Category, OSUINTCONST(1), OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdcp_Parameters */
   RTXCTXTPUSHELEMNAME (pctxt, "pdcp-Parameters");

   stat = asn1PD_PDCP_Parameters (pctxt, &pvalue->pdcp_Parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode phyLayerParameters */
   RTXCTXTPUSHELEMNAME (pctxt, "phyLayerParameters");

   stat = asn1PD_PhyLayerParameters (pctxt, &pvalue->phyLayerParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rf_Parameters */
   RTXCTXTPUSHELEMNAME (pctxt, "rf-Parameters");

   stat = asn1PD_RF_Parameters (pctxt, &pvalue->rf_Parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measParameters */
   RTXCTXTPUSHELEMNAME (pctxt, "measParameters");

   stat = asn1PD_MeasParameters (pctxt, &pvalue->measParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode featureGroupIndicators */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "featureGroupIndicators");

      pvalue->m.featureGroupIndicatorsPresent = 1;

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(32), OSUINTCONST(32), 0, 0);

      stat = pd_BitString32 (pctxt, &pvalue->featureGroupIndicators
         , OSUINTCONST(32), OSUINTCONST(32));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode interRAT_Parameters */
   RTXCTXTPUSHELEMNAME (pctxt, "interRAT-Parameters");

   stat = asn1PD_UE_EUTRA_Capability_interRAT_Parameters (pctxt, &pvalue->interRAT_Parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_UE_EUTRA_Capability_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UE_EUTRA_Capability (UE_EUTRA_Capability* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PDCP_Parameters (&pvalue->pdcp_Parameters);
   asn1Init_RF_Parameters (&pvalue->rf_Parameters);
   asn1Init_MeasParameters (&pvalue->measParameters);
   pvalue->featureGroupIndicators.numbits = 0;
   asn1Init_UE_EUTRA_Capability_interRAT_Parameters (&pvalue->interRAT_Parameters);
   asn1Init_UE_EUTRA_Capability_v920_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_MBSFN_AreaInfo_r9_mcch_Config_r9 (OSCTXT* pctxt, MBSFN_AreaInfo_r9_mcch_Config_r9* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFN_AreaInfo_r9_mcch_Config_r9"));

   /* encode mcch_RepetitionPeriod_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "mcch-RepetitionPeriod-r9");

   stat = asn1PE_MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9 (pctxt, pvalue->mcch_RepetitionPeriod_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode mcch_Offset_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "mcch-Offset-r9");

   if ( (pvalue->mcch_Offset_r9 <= OSUINTCONST(10)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->mcch_Offset_r9, OSUINTCONST(0), OSUINTCONST(10));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->mcch_Offset_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode mcch_ModificationPeriod_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "mcch-ModificationPeriod-r9");

   stat = asn1PE_MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9 (pctxt, pvalue->mcch_ModificationPeriod_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sf_AllocInfo_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "sf-AllocInfo-r9");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->sf_AllocInfo_r9, OSUINTCONST(6), OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode signallingMCS_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "signallingMCS-r9");

   stat = asn1PE_MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9 (pctxt, pvalue->signallingMCS_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFN_AreaInfo_r9_mcch_Config_r9 (OSCTXT* pctxt, MBSFN_AreaInfo_r9_mcch_Config_r9* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode mcch_RepetitionPeriod_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "mcch-RepetitionPeriod-r9");

   stat = asn1PD_MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9 (pctxt, &pvalue->mcch_RepetitionPeriod_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mcch_Offset_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "mcch-Offset-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->mcch_Offset_r9, OSUINTCONST(0), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mcch_ModificationPeriod_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "mcch-ModificationPeriod-r9");

   stat = asn1PD_MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9 (pctxt, &pvalue->mcch_ModificationPeriod_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sf_AllocInfo_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "sf-AllocInfo-r9");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->sf_AllocInfo_r9
      , OSUINTCONST(6), OSUINTCONST(6));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode signallingMCS_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "signallingMCS-r9");

   stat = asn1PD_MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9 (pctxt, &pvalue->signallingMCS_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_MBSFN_AreaInfo_r9_mcch_Config_r9 (
   MBSFN_AreaInfo_r9_mcch_Config_r9* pvalue)
{
   if (0 == pvalue) return;
   pvalue->sf_AllocInfo_r9.numbits = 0;
}

EXTERN int asn1PE_MBSFN_AreaInfo_r9 (OSCTXT* pctxt, MBSFN_AreaInfo_r9* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBSFN-AreaInfo-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFN_AreaInfo_r9"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode mbsfn_AreaId_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "mbsfn-AreaId-r9");

   stat = pe_ConsUnsigned (pctxt, pvalue->mbsfn_AreaId_r9, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode non_MBSFNregionLength */

   RTXCTXTPUSHELEMNAME (pctxt, "non-MBSFNregionLength");

   stat = asn1PE_MBSFN_AreaInfo_r9_non_MBSFNregionLength (pctxt, pvalue->non_MBSFNregionLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode notificationIndicator_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "notificationIndicator-r9");

   if ( (pvalue->notificationIndicator_r9 <= OSUINTCONST(7)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->notificationIndicator_r9, OSUINTCONST(0), OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->notificationIndicator_r9);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode mcch_Config_r9 */

   RTXCTXTPUSHELEMNAME (pctxt, "mcch-Config-r9");

   stat = asn1PE_MBSFN_AreaInfo_r9_mcch_Config_r9 (pctxt, &pvalue->mcch_Config_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFN_AreaInfo_r9 (OSCTXT* pctxt, MBSFN_AreaInfo_r9* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBSFN-AreaInfo-r9");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode mbsfn_AreaId_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "mbsfn-AreaId-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->mbsfn_AreaId_r9, OSUINTCONST(0), OSUINTCONST(255));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode non_MBSFNregionLength */
   RTXCTXTPUSHELEMNAME (pctxt, "non-MBSFNregionLength");

   stat = asn1PD_MBSFN_AreaInfo_r9_non_MBSFNregionLength (pctxt, &pvalue->non_MBSFNregionLength);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode notificationIndicator_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "notificationIndicator-r9");

   stat = pd_ConsUInt8 (pctxt, &pvalue->notificationIndicator_r9, OSUINTCONST(0), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mcch_Config_r9 */
   RTXCTXTPUSHELEMNAME (pctxt, "mcch-Config-r9");

   stat = asn1PD_MBSFN_AreaInfo_r9_mcch_Config_r9 (pctxt, &pvalue->mcch_Config_r9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MBSFN_AreaInfo_r9 (MBSFN_AreaInfo_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_MBSFN_AreaInfo_r9_mcch_Config_r9 (&pvalue->mcch_Config_r9);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_MBSFN_AreaInfoList_r9 (OSCTXT* pctxt, MBSFN_AreaInfoList_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MBSFN-AreaInfoList-r9");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("MBSFN_AreaInfoList_r9"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MBSFN-AreaInfo-r9", xx1);

      stat = asn1PE_MBSFN_AreaInfo_r9 (pctxt, ((MBSFN_AreaInfo_r9*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_MBSFN_AreaInfoList_r9 (OSCTXT* pctxt, MBSFN_AreaInfoList_r9* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBSFN-AreaInfoList-r9");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MBSFN_AreaInfo_r9* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MBSFN-AreaInfo-r9", xx1);

      rtxDListAllocNodeAndData (pctxt, MBSFN_AreaInfo_r9, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MBSFN_AreaInfo_r9 (pdata);

      stat = asn1PD_MBSFN_AreaInfo_r9 (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_MBSFN_AreaInfoList_r9 (MBSFN_AreaInfoList_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Print_MasterInformationBlock_dl_Bandwidth 
   (const char* name, const MasterInformationBlock_dl_Bandwidth* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n6\n"); break;
      case 1: printf ("n15\n"); break;
      case 2: printf ("n25\n"); break;
      case 3: printf ("n50\n"); break;
      case 4: printf ("n75\n"); break;
      case 5: printf ("n100\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PHICH_Config_phich_Duration 
   (const char* name, const PHICH_Config_phich_Duration* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("normal\n"); break;
      case 1: printf ("extended\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PHICH_Config_phich_Resource 
   (const char* name, const PHICH_Config_phich_Resource* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("oneSixth\n"); break;
      case 1: printf ("half\n"); break;
      case 2: printf ("one\n"); break;
      case 3: printf ("two\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PHICH_Config (const char* name, const PHICH_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PHICH_Config_phich_Duration ("phich_Duration", &pvalue->
      phich_Duration);

   asn1Print_PHICH_Config_phich_Resource ("phich_Resource", &pvalue->
      phich_Resource);

   rtxPrintCloseBrace ();
}

void asn1Print_MasterInformationBlock 
   (const char* name, const MasterInformationBlock* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MasterInformationBlock_dl_Bandwidth ("dl_Bandwidth", &pvalue->
      dl_Bandwidth);

   asn1Print_PHICH_Config ("phich_Config", &pvalue->phich_Config);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("systemFrameNumber", pvalue->systemFrameNumber.numbits, pvalue->systemFrameNumber.data);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("spare", pvalue->spare.numbits, pvalue->spare.data);

   rtxPrintCloseBrace ();
}

void asn1Print_BCCH_BCH_MessageType 
   (const char* name, const BCCH_BCH_MessageType* pvalue)
{
   asn1Print_MasterInformationBlock (name, pvalue);
}

void asn1Print_IMSI_Digit (const char* name, const IMSI_Digit* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ReestablishmentCause 
   (const char* name, const ReestablishmentCause* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("reconfigurationFailure\n"); break;
      case 1: printf ("handoverFailure\n"); break;
      case 2: printf ("otherFailure\n"); break;
      case 3: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ReleaseCause (const char* name, const ReleaseCause* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("loadBalancingTAUrequired\n"); break;
      case 1: printf ("other\n"); break;
      case 2: printf ("spare2\n"); break;
      case 3: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_EstablishmentCause 
   (const char* name, const EstablishmentCause* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("emergency\n"); break;
      case 1: printf ("highPriorityAccess\n"); break;
      case 2: printf ("mt-Access\n"); break;
      case 3: printf ("mo-Signalling\n"); break;
      case 4: printf ("mo-Data\n"); break;
      case 5: printf ("spare3\n"); break;
      case 6: printf ("spare2\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SIB_Type (const char* name, const SIB_Type* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sibType3\n"); break;
      case 1: printf ("sibType4\n"); break;
      case 2: printf ("sibType5\n"); break;
      case 3: printf ("sibType6\n"); break;
      case 4: printf ("sibType7\n"); break;
      case 5: printf ("sibType8\n"); break;
      case 6: printf ("sibType9\n"); break;
      case 7: printf ("sibType10\n"); break;
      case 8: printf ("sibType11\n"); break;
      case 9: printf ("sibType12-v920\n"); break;
      case 10: printf ("sibType13-v920\n"); break;
      case 11: printf ("spare5\n"); break;
      case 12: printf ("spare4\n"); break;
      case 13: printf ("spare3\n"); break;
      case 14: printf ("spare2\n"); break;
      case 15: printf ("spare1\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_DRB_Identity (const char* name, const DRB_Identity* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_P_Max (const char* name, const P_Max* pvalue)
{
   rtxPrintIndent ();
   rtxPrintInteger (name, *pvalue);
}

void asn1Print_PresenceAntennaPort1 
   (const char* name, const PresenceAntennaPort1* pvalue)
{
   rtxPrintIndent ();
   rtxPrintBoolean (name, *pvalue);
}

void asn1Print_UL_CyclicPrefixLength 
   (const char* name, const UL_CyclicPrefixLength* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("len1\n"); break;
      case 1: printf ("len2\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SN_FieldLength (const char* name, const SN_FieldLength* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("size5\n"); break;
      case 1: printf ("size10\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_T_PollRetransmit 
   (const char* name, const T_PollRetransmit* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms5\n"); break;
      case 1: printf ("ms10\n"); break;
      case 2: printf ("ms15\n"); break;
      case 3: printf ("ms20\n"); break;
      case 4: printf ("ms25\n"); break;
      case 5: printf ("ms30\n"); break;
      case 6: printf ("ms35\n"); break;
      case 7: printf ("ms40\n"); break;
      case 8: printf ("ms45\n"); break;
      case 9: printf ("ms50\n"); break;
      case 10: printf ("ms55\n"); break;
      case 11: printf ("ms60\n"); break;
      case 12: printf ("ms65\n"); break;
      case 13: printf ("ms70\n"); break;
      case 14: printf ("ms75\n"); break;
      case 15: printf ("ms80\n"); break;
      case 16: printf ("ms85\n"); break;
      case 17: printf ("ms90\n"); break;
      case 18: printf ("ms95\n"); break;
      case 19: printf ("ms100\n"); break;
      case 20: printf ("ms105\n"); break;
      case 21: printf ("ms110\n"); break;
      case 22: printf ("ms115\n"); break;
      case 23: printf ("ms120\n"); break;
      case 24: printf ("ms125\n"); break;
      case 25: printf ("ms130\n"); break;
      case 26: printf ("ms135\n"); break;
      case 27: printf ("ms140\n"); break;
      case 28: printf ("ms145\n"); break;
      case 29: printf ("ms150\n"); break;
      case 30: printf ("ms155\n"); break;
      case 31: printf ("ms160\n"); break;
      case 32: printf ("ms165\n"); break;
      case 33: printf ("ms170\n"); break;
      case 34: printf ("ms175\n"); break;
      case 35: printf ("ms180\n"); break;
      case 36: printf ("ms185\n"); break;
      case 37: printf ("ms190\n"); break;
      case 38: printf ("ms195\n"); break;
      case 39: printf ("ms200\n"); break;
      case 40: printf ("ms205\n"); break;
      case 41: printf ("ms210\n"); break;
      case 42: printf ("ms215\n"); break;
      case 43: printf ("ms220\n"); break;
      case 44: printf ("ms225\n"); break;
      case 45: printf ("ms230\n"); break;
      case 46: printf ("ms235\n"); break;
      case 47: printf ("ms240\n"); break;
      case 48: printf ("ms245\n"); break;
      case 49: printf ("ms250\n"); break;
      case 50: printf ("ms300\n"); break;
      case 51: printf ("ms350\n"); break;
      case 52: printf ("ms400\n"); break;
      case 53: printf ("ms450\n"); break;
      case 54: printf ("ms500\n"); break;
      case 55: printf ("spare9\n"); break;
      case 56: printf ("spare8\n"); break;
      case 57: printf ("spare7\n"); break;
      case 58: printf ("spare6\n"); break;
      case 59: printf ("spare5\n"); break;
      case 60: printf ("spare4\n"); break;
      case 61: printf ("spare3\n"); break;
      case 62: printf ("spare2\n"); break;
      case 63: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PollPDU (const char* name, const PollPDU* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("p4\n"); break;
      case 1: printf ("p8\n"); break;
      case 2: printf ("p16\n"); break;
      case 3: printf ("p32\n"); break;
      case 4: printf ("p64\n"); break;
      case 5: printf ("p128\n"); break;
      case 6: printf ("p256\n"); break;
      case 7: printf ("pInfinity\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PollByte (const char* name, const PollByte* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("kB25\n"); break;
      case 1: printf ("kB50\n"); break;
      case 2: printf ("kB75\n"); break;
      case 3: printf ("kB100\n"); break;
      case 4: printf ("kB125\n"); break;
      case 5: printf ("kB250\n"); break;
      case 6: printf ("kB375\n"); break;
      case 7: printf ("kB500\n"); break;
      case 8: printf ("kB750\n"); break;
      case 9: printf ("kB1000\n"); break;
      case 10: printf ("kB1250\n"); break;
      case 11: printf ("kB1500\n"); break;
      case 12: printf ("kB2000\n"); break;
      case 13: printf ("kB3000\n"); break;
      case 14: printf ("kBinfinity\n"); break;
      case 15: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_T_Reordering (const char* name, const T_Reordering* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms0\n"); break;
      case 1: printf ("ms5\n"); break;
      case 2: printf ("ms10\n"); break;
      case 3: printf ("ms15\n"); break;
      case 4: printf ("ms20\n"); break;
      case 5: printf ("ms25\n"); break;
      case 6: printf ("ms30\n"); break;
      case 7: printf ("ms35\n"); break;
      case 8: printf ("ms40\n"); break;
      case 9: printf ("ms45\n"); break;
      case 10: printf ("ms50\n"); break;
      case 11: printf ("ms55\n"); break;
      case 12: printf ("ms60\n"); break;
      case 13: printf ("ms65\n"); break;
      case 14: printf ("ms70\n"); break;
      case 15: printf ("ms75\n"); break;
      case 16: printf ("ms80\n"); break;
      case 17: printf ("ms85\n"); break;
      case 18: printf ("ms90\n"); break;
      case 19: printf ("ms95\n"); break;
      case 20: printf ("ms100\n"); break;
      case 21: printf ("ms110\n"); break;
      case 22: printf ("ms120\n"); break;
      case 23: printf ("ms130\n"); break;
      case 24: printf ("ms140\n"); break;
      case 25: printf ("ms150\n"); break;
      case 26: printf ("ms160\n"); break;
      case 27: printf ("ms170\n"); break;
      case 28: printf ("ms180\n"); break;
      case 29: printf ("ms190\n"); break;
      case 30: printf ("ms200\n"); break;
      case 31: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_T_StatusProhibit 
   (const char* name, const T_StatusProhibit* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms0\n"); break;
      case 1: printf ("ms5\n"); break;
      case 2: printf ("ms10\n"); break;
      case 3: printf ("ms15\n"); break;
      case 4: printf ("ms20\n"); break;
      case 5: printf ("ms25\n"); break;
      case 6: printf ("ms30\n"); break;
      case 7: printf ("ms35\n"); break;
      case 8: printf ("ms40\n"); break;
      case 9: printf ("ms45\n"); break;
      case 10: printf ("ms50\n"); break;
      case 11: printf ("ms55\n"); break;
      case 12: printf ("ms60\n"); break;
      case 13: printf ("ms65\n"); break;
      case 14: printf ("ms70\n"); break;
      case 15: printf ("ms75\n"); break;
      case 16: printf ("ms80\n"); break;
      case 17: printf ("ms85\n"); break;
      case 18: printf ("ms90\n"); break;
      case 19: printf ("ms95\n"); break;
      case 20: printf ("ms100\n"); break;
      case 21: printf ("ms105\n"); break;
      case 22: printf ("ms110\n"); break;
      case 23: printf ("ms115\n"); break;
      case 24: printf ("ms120\n"); break;
      case 25: printf ("ms125\n"); break;
      case 26: printf ("ms130\n"); break;
      case 27: printf ("ms135\n"); break;
      case 28: printf ("ms140\n"); break;
      case 29: printf ("ms145\n"); break;
      case 30: printf ("ms150\n"); break;
      case 31: printf ("ms155\n"); break;
      case 32: printf ("ms160\n"); break;
      case 33: printf ("ms165\n"); break;
      case 34: printf ("ms170\n"); break;
      case 35: printf ("ms175\n"); break;
      case 36: printf ("ms180\n"); break;
      case 37: printf ("ms185\n"); break;
      case 38: printf ("ms190\n"); break;
      case 39: printf ("ms195\n"); break;
      case 40: printf ("ms200\n"); break;
      case 41: printf ("ms205\n"); break;
      case 42: printf ("ms210\n"); break;
      case 43: printf ("ms215\n"); break;
      case 44: printf ("ms220\n"); break;
      case 45: printf ("ms225\n"); break;
      case 46: printf ("ms230\n"); break;
      case 47: printf ("ms235\n"); break;
      case 48: printf ("ms240\n"); break;
      case 49: printf ("ms245\n"); break;
      case 50: printf ("ms250\n"); break;
      case 51: printf ("ms300\n"); break;
      case 52: printf ("ms350\n"); break;
      case 53: printf ("ms400\n"); break;
      case 54: printf ("ms450\n"); break;
      case 55: printf ("ms500\n"); break;
      case 56: printf ("spare8\n"); break;
      case 57: printf ("spare7\n"); break;
      case 58: printf ("spare6\n"); break;
      case 59: printf ("spare5\n"); break;
      case 60: printf ("spare4\n"); break;
      case 61: printf ("spare3\n"); break;
      case 62: printf ("spare2\n"); break;
      case 63: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_TimeAlignmentTimer 
   (const char* name, const TimeAlignmentTimer* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sf500\n"); break;
      case 1: printf ("sf750\n"); break;
      case 2: printf ("sf1280\n"); break;
      case 3: printf ("sf1920\n"); break;
      case 4: printf ("sf2560\n"); break;
      case 5: printf ("sf5120\n"); break;
      case 6: printf ("sf10240\n"); break;
      case 7: printf ("infinity\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_NextHopChainingCount 
   (const char* name, const NextHopChainingCount* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ShortMAC_I (const char* name, const ShortMAC_I* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_AdditionalSpectrumEmission 
   (const char* name, const AdditionalSpectrumEmission* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ARFCN_ValueCDMA2000 
   (const char* name, const ARFCN_ValueCDMA2000* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ARFCN_ValueEUTRA 
   (const char* name, const ARFCN_ValueEUTRA* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ARFCN_ValueGERAN 
   (const char* name, const ARFCN_ValueGERAN* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ARFCN_ValueUTRA 
   (const char* name, const ARFCN_ValueUTRA* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_BandclassCDMA2000 
   (const char* name, const BandclassCDMA2000* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("bc0\n"); break;
      case 1: printf ("bc1\n"); break;
      case 2: printf ("bc2\n"); break;
      case 3: printf ("bc3\n"); break;
      case 4: printf ("bc4\n"); break;
      case 5: printf ("bc5\n"); break;
      case 6: printf ("bc6\n"); break;
      case 7: printf ("bc7\n"); break;
      case 8: printf ("bc8\n"); break;
      case 9: printf ("bc9\n"); break;
      case 10: printf ("bc10\n"); break;
      case 11: printf ("bc11\n"); break;
      case 12: printf ("bc12\n"); break;
      case 13: printf ("bc13\n"); break;
      case 14: printf ("bc14\n"); break;
      case 15: printf ("bc15\n"); break;
      case 16: printf ("bc16\n"); break;
      case 17: printf ("bc17\n"); break;
      case 18: printf ("spare14\n"); break;
      case 19: printf ("spare13\n"); break;
      case 20: printf ("spare12\n"); break;
      case 21: printf ("spare11\n"); break;
      case 22: printf ("spare10\n"); break;
      case 23: printf ("spare9\n"); break;
      case 24: printf ("spare8\n"); break;
      case 25: printf ("spare7\n"); break;
      case 26: printf ("spare6\n"); break;
      case 27: printf ("spare5\n"); break;
      case 28: printf ("spare4\n"); break;
      case 29: printf ("spare3\n"); break;
      case 30: printf ("spare2\n"); break;
      case 31: printf ("spare1\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_BandIndicatorGERAN 
   (const char* name, const BandIndicatorGERAN* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("dcs1800\n"); break;
      case 1: printf ("pcs1900\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_CDMA2000_Type (const char* name, const CDMA2000_Type* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("type1XRTT\n"); break;
      case 1: printf ("typeHRPD\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_CellIdentity (const char* name, const CellIdentity* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_CellIndex (const char* name, const CellIndex* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_CellReselectionPriority 
   (const char* name, const CellReselectionPriority* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_CSG_Identity (const char* name, const CSG_Identity* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_MobilityParametersCDMA2000 
   (const char* name, const MobilityParametersCDMA2000* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_PhysCellId (const char* name, const PhysCellId* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_PhysCellIdCDMA2000 
   (const char* name, const PhysCellIdCDMA2000* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_PhysCellIdUTRA_FDD 
   (const char* name, const PhysCellIdUTRA_FDD* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_PhysCellIdUTRA_TDD 
   (const char* name, const PhysCellIdUTRA_TDD* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_MCC_MNC_Digit (const char* name, const MCC_MNC_Digit* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_PreRegistrationZoneIdHRPD 
   (const char* name, const PreRegistrationZoneIdHRPD* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_Q_QualMin_r9 (const char* name, const Q_QualMin_r9* pvalue)
{
   rtxPrintIndent ();
   rtxPrintInteger (name, *pvalue);
}

void asn1Print_Q_RxLevMin (const char* name, const Q_RxLevMin* pvalue)
{
   rtxPrintIndent ();
   rtxPrintInteger (name, *pvalue);
}

void asn1Print_Q_OffsetRange (const char* name, const Q_OffsetRange* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("dB-24\n"); break;
      case 1: printf ("dB-22\n"); break;
      case 2: printf ("dB-20\n"); break;
      case 3: printf ("dB-18\n"); break;
      case 4: printf ("dB-16\n"); break;
      case 5: printf ("dB-14\n"); break;
      case 6: printf ("dB-12\n"); break;
      case 7: printf ("dB-10\n"); break;
      case 8: printf ("dB-8\n"); break;
      case 9: printf ("dB-6\n"); break;
      case 10: printf ("dB-5\n"); break;
      case 11: printf ("dB-4\n"); break;
      case 12: printf ("dB-3\n"); break;
      case 13: printf ("dB-2\n"); break;
      case 14: printf ("dB-1\n"); break;
      case 15: printf ("dB0\n"); break;
      case 16: printf ("dB1\n"); break;
      case 17: printf ("dB2\n"); break;
      case 18: printf ("dB3\n"); break;
      case 19: printf ("dB4\n"); break;
      case 20: printf ("dB5\n"); break;
      case 21: printf ("dB6\n"); break;
      case 22: printf ("dB8\n"); break;
      case 23: printf ("dB10\n"); break;
      case 24: printf ("dB12\n"); break;
      case 25: printf ("dB14\n"); break;
      case 26: printf ("dB16\n"); break;
      case 27: printf ("dB18\n"); break;
      case 28: printf ("dB20\n"); break;
      case 29: printf ("dB22\n"); break;
      case 30: printf ("dB24\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_Q_OffsetRangeInterRAT 
   (const char* name, const Q_OffsetRangeInterRAT* pvalue)
{
   rtxPrintIndent ();
   rtxPrintInteger (name, *pvalue);
}

void asn1Print_ReselectionThreshold 
   (const char* name, const ReselectionThreshold* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ReselectionThresholdQ_r9 
   (const char* name, const ReselectionThresholdQ_r9* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_TrackingAreaCode 
   (const char* name, const TrackingAreaCode* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_T_Reselection (const char* name, const T_Reselection* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_AllowedMeasBandwidth 
   (const char* name, const AllowedMeasBandwidth* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("mbw6\n"); break;
      case 1: printf ("mbw15\n"); break;
      case 2: printf ("mbw25\n"); break;
      case 3: printf ("mbw50\n"); break;
      case 4: printf ("mbw75\n"); break;
      case 5: printf ("mbw100\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_Hysteresis (const char* name, const Hysteresis* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_MeasId (const char* name, const MeasId* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_MeasObjectId (const char* name, const MeasObjectId* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ReportConfigId (const char* name, const ReportConfigId* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ThresholdGERAN (const char* name, const ThresholdGERAN* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ThresholdCDMA2000 
   (const char* name, const ThresholdCDMA2000* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ReportInterval (const char* name, const ReportInterval* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms120\n"); break;
      case 1: printf ("ms240\n"); break;
      case 2: printf ("ms480\n"); break;
      case 3: printf ("ms640\n"); break;
      case 4: printf ("ms1024\n"); break;
      case 5: printf ("ms2048\n"); break;
      case 6: printf ("ms5120\n"); break;
      case 7: printf ("ms10240\n"); break;
      case 8: printf ("min1\n"); break;
      case 9: printf ("min6\n"); break;
      case 10: printf ("min12\n"); break;
      case 11: printf ("min30\n"); break;
      case 12: printf ("min60\n"); break;
      case 13: printf ("spare3\n"); break;
      case 14: printf ("spare2\n"); break;
      case 15: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RSRP_Range (const char* name, const RSRP_Range* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_RSRQ_Range (const char* name, const RSRQ_Range* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_TimeToTrigger (const char* name, const TimeToTrigger* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms0\n"); break;
      case 1: printf ("ms40\n"); break;
      case 2: printf ("ms64\n"); break;
      case 3: printf ("ms80\n"); break;
      case 4: printf ("ms100\n"); break;
      case 5: printf ("ms128\n"); break;
      case 6: printf ("ms160\n"); break;
      case 7: printf ("ms256\n"); break;
      case 8: printf ("ms320\n"); break;
      case 9: printf ("ms480\n"); break;
      case 10: printf ("ms512\n"); break;
      case 11: printf ("ms640\n"); break;
      case 12: printf ("ms1024\n"); break;
      case 13: printf ("ms1280\n"); break;
      case 14: printf ("ms2560\n"); break;
      case 15: printf ("ms5120\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_C_RNTI (const char* name, const C_RNTI* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_DedicatedInfoCDMA2000 
   (const char* name, const DedicatedInfoCDMA2000* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_DedicatedInfoNAS 
   (const char* name, const DedicatedInfoNAS* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_FilterCoefficient 
   (const char* name, const FilterCoefficient* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("fc0\n"); break;
      case 1: printf ("fc1\n"); break;
      case 2: printf ("fc2\n"); break;
      case 3: printf ("fc3\n"); break;
      case 4: printf ("fc4\n"); break;
      case 5: printf ("fc5\n"); break;
      case 6: printf ("fc6\n"); break;
      case 7: printf ("fc7\n"); break;
      case 8: printf ("fc8\n"); break;
      case 9: printf ("fc9\n"); break;
      case 10: printf ("fc11\n"); break;
      case 11: printf ("fc13\n"); break;
      case 12: printf ("fc15\n"); break;
      case 13: printf ("fc17\n"); break;
      case 14: printf ("fc19\n"); break;
      case 15: printf ("spare1\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_MMEC (const char* name, const MMEC* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_NeighCellConfig 
   (const char* name, const NeighCellConfig* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_RAND_CDMA2000 (const char* name, const RAND_CDMA2000* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_RAT_Type (const char* name, const RAT_Type* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("eutra\n"); break;
      case 1: printf ("utra\n"); break;
      case 2: printf ("geran-cs\n"); break;
      case 3: printf ("geran-ps\n"); break;
      case 4: printf ("cdma2000-1XRTT\n"); break;
      case 5: printf ("spare3\n"); break;
      case 6: printf ("spare2\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_RRC_TransactionIdentifier 
   (const char* name, const RRC_TransactionIdentifier* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_AccessStratumRelease 
   (const char* name, const AccessStratumRelease* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("rel8\n"); break;
      case 1: printf ("rel9\n"); break;
      case 2: printf ("spare6\n"); break;
      case 3: printf ("spare5\n"); break;
      case 4: printf ("spare4\n"); break;
      case 5: printf ("spare3\n"); break;
      case 6: printf ("spare2\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_SupportedBandUTRA_FDD 
   (const char* name, const SupportedBandUTRA_FDD* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("bandI\n"); break;
      case 1: printf ("bandII\n"); break;
      case 2: printf ("bandIII\n"); break;
      case 3: printf ("bandIV\n"); break;
      case 4: printf ("bandV\n"); break;
      case 5: printf ("bandVI\n"); break;
      case 6: printf ("bandVII\n"); break;
      case 7: printf ("bandVIII\n"); break;
      case 8: printf ("bandIX\n"); break;
      case 9: printf ("bandX\n"); break;
      case 10: printf ("bandXI\n"); break;
      case 11: printf ("bandXII\n"); break;
      case 12: printf ("bandXIII\n"); break;
      case 13: printf ("bandXIV\n"); break;
      case 14: printf ("bandXV\n"); break;
      case 15: printf ("bandXVI\n"); break;
      case 16: printf ("bandXVII-8a0\n"); break;
      case 17: printf ("bandXVIII-8a0\n"); break;
      case 18: printf ("bandXIX-8a0\n"); break;
      case 19: printf ("bandXX-8a0\n"); break;
      case 20: printf ("bandXXI-8a0\n"); break;
      case 21: printf ("bandXXII-8a0\n"); break;
      case 22: printf ("bandXXIII-8a0\n"); break;
      case 23: printf ("bandXXIV-8a0\n"); break;
      case 24: printf ("bandXXV-8a0\n"); break;
      case 25: printf ("bandXXVI-8a0\n"); break;
      case 26: printf ("bandXXVII-8a0\n"); break;
      case 27: printf ("bandXXVIII-8a0\n"); break;
      case 28: printf ("bandXXIX-8a0\n"); break;
      case 29: printf ("bandXXX-8a0\n"); break;
      case 30: printf ("bandXXXI-8a0\n"); break;
      case 31: printf ("bandXXXII-8a0\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_SupportedBandUTRA_TDD128 
   (const char* name, const SupportedBandUTRA_TDD128* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("a\n"); break;
      case 1: printf ("b\n"); break;
      case 2: printf ("c\n"); break;
      case 3: printf ("d\n"); break;
      case 4: printf ("e\n"); break;
      case 5: printf ("f\n"); break;
      case 6: printf ("g\n"); break;
      case 7: printf ("h\n"); break;
      case 8: printf ("i\n"); break;
      case 9: printf ("j\n"); break;
      case 10: printf ("k\n"); break;
      case 11: printf ("l\n"); break;
      case 12: printf ("m\n"); break;
      case 13: printf ("n\n"); break;
      case 14: printf ("o\n"); break;
      case 15: printf ("p\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_SupportedBandUTRA_TDD384 
   (const char* name, const SupportedBandUTRA_TDD384* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("a\n"); break;
      case 1: printf ("b\n"); break;
      case 2: printf ("c\n"); break;
      case 3: printf ("d\n"); break;
      case 4: printf ("e\n"); break;
      case 5: printf ("f\n"); break;
      case 6: printf ("g\n"); break;
      case 7: printf ("h\n"); break;
      case 8: printf ("i\n"); break;
      case 9: printf ("j\n"); break;
      case 10: printf ("k\n"); break;
      case 11: printf ("l\n"); break;
      case 12: printf ("m\n"); break;
      case 13: printf ("n\n"); break;
      case 14: printf ("o\n"); break;
      case 15: printf ("p\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_SupportedBandUTRA_TDD768 
   (const char* name, const SupportedBandUTRA_TDD768* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("a\n"); break;
      case 1: printf ("b\n"); break;
      case 2: printf ("c\n"); break;
      case 3: printf ("d\n"); break;
      case 4: printf ("e\n"); break;
      case 5: printf ("f\n"); break;
      case 6: printf ("g\n"); break;
      case 7: printf ("h\n"); break;
      case 8: printf ("i\n"); break;
      case 9: printf ("j\n"); break;
      case 10: printf ("k\n"); break;
      case 11: printf ("l\n"); break;
      case 12: printf ("m\n"); break;
      case 13: printf ("n\n"); break;
      case 14: printf ("o\n"); break;
      case 15: printf ("p\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_SupportedBandGERAN 
   (const char* name, const SupportedBandGERAN* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("gsm450\n"); break;
      case 1: printf ("gsm480\n"); break;
      case 2: printf ("gsm710\n"); break;
      case 3: printf ("gsm750\n"); break;
      case 4: printf ("gsm810\n"); break;
      case 5: printf ("gsm850\n"); break;
      case 6: printf ("gsm900P\n"); break;
      case 7: printf ("gsm900E\n"); break;
      case 8: printf ("gsm900R\n"); break;
      case 9: printf ("gsm1800\n"); break;
      case 10: printf ("gsm1900\n"); break;
      case 11: printf ("spare5\n"); break;
      case 12: printf ("spare4\n"); break;
      case 13: printf ("spare3\n"); break;
      case 14: printf ("spare2\n"); break;
      case 15: printf ("spare1\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9 
   (const char* name, const MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("rf4\n"); break;
      case 1: printf ("rf8\n"); break;
      case 2: printf ("rf16\n"); break;
      case 3: printf ("rf32\n"); break;
      case 4: printf ("rf64\n"); break;
      case 5: printf ("rf128\n"); break;
      case 6: printf ("rf256\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_Handover_targetRAT_Type 
   (const char* name, const Handover_targetRAT_Type* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("utra\n"); break;
      case 1: printf ("geran\n"); break;
      case 2: printf ("cdma2000-1XRTT\n"); break;
      case 3: printf ("cdma2000-HRPD\n"); break;
      case 4: printf ("spare4\n"); break;
      case 5: printf ("spare3\n"); break;
      case 6: printf ("spare2\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_Handover_nas_SecurityParamFromEUTRA 
   (const char* name, const Handover_nas_SecurityParamFromEUTRA* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_CellChangeOrder_t304 
   (const char* name, const CellChangeOrder_t304* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms100\n"); break;
      case 1: printf ("ms200\n"); break;
      case 2: printf ("ms500\n"); break;
      case 3: printf ("ms1000\n"); break;
      case 4: printf ("ms2000\n"); break;
      case 5: printf ("ms4000\n"); break;
      case 6: printf ("ms8000\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_E_CSFB_r9_mobilityCDMA2000_HRPD_r9 
   (const char* name, const E_CSFB_r9_mobilityCDMA2000_HRPD_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("handover\n"); break;
      case 1: printf ("redirection\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_Paging_systemInfoModification 
   (const char* name, const Paging_systemInfoModification* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("true\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_Paging_etws_Indication 
   (const char* name, const Paging_etws_Indication* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("true\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_Paging_v920_IEs_cmas_Indication_r9 
   (const char* name, const Paging_v920_IEs_cmas_Indication_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("true\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PagingRecord_cn_Domain 
   (const char* name, const PagingRecord_cn_Domain* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ps\n"); break;
      case 1: printf ("cs\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ProximityIndication_r9_IEs_type_r9 
   (const char* name, const ProximityIndication_r9_IEs_type_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("entering\n"); break;
      case 1: printf ("leaving\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RRCConnectionReconfiguration_v920_IEs_fullConfig_r9 
   (const char* name, const RRCConnectionReconfiguration_v920_IEs_fullConfig_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("true\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SecurityConfigHO_handoverType_interRAT_nas_SecurityParamToEUTRA 
   (const char* name, const SecurityConfigHO_handoverType_interRAT_nas_SecurityParamToEUTRA* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9 
   (const char* name, const RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("true\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_IdleModeMobilityControlInfo_t320 
   (const char* name, const IdleModeMobilityControlInfo_t320* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("min5\n"); break;
      case 1: printf ("min10\n"); break;
      case 2: printf ("min20\n"); break;
      case 3: printf ("min30\n"); break;
      case 4: printf ("min60\n"); break;
      case 5: printf ("min120\n"); break;
      case 6: printf ("min180\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_InitialUE_Identity_randomValue 
   (const char* name, const InitialUE_Identity_randomValue* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred 
   (const char* name, const SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("barred\n"); break;
      case 1: printf ("notBarred\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection 
   (const char* name, const SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("allowed\n"); break;
      case 1: printf ("notAllowed\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SystemInformationBlockType1_si_WindowLength 
   (const char* name, const SystemInformationBlockType1_si_WindowLength* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms1\n"); break;
      case 1: printf ("ms2\n"); break;
      case 2: printf ("ms5\n"); break;
      case 3: printf ("ms10\n"); break;
      case 4: printf ("ms15\n"); break;
      case 5: printf ("ms20\n"); break;
      case 6: printf ("ms40\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9 
   (const char* name, const SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("true\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PLMN_IdentityInfo_cellReservedForOperatorUse 
   (const char* name, const PLMN_IdentityInfo_cellReservedForOperatorUse* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("reserved\n"); break;
      case 1: printf ("notReserved\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SchedulingInfo_si_Periodicity 
   (const char* name, const SchedulingInfo_si_Periodicity* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("rf8\n"); break;
      case 1: printf ("rf16\n"); break;
      case 2: printf ("rf32\n"); break;
      case 3: printf ("rf64\n"); break;
      case 4: printf ("rf128\n"); break;
      case 5: printf ("rf256\n"); break;
      case 6: printf ("rf512\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ULHandoverPreparationTransfer_r8_IEs_meid 
   (const char* name, const ULHandoverPreparationTransfer_r8_IEs_meid* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_SystemInformationBlockType2_freqInfo_ul_Bandwidth 
   (const char* name, const SystemInformationBlockType2_freqInfo_ul_Bandwidth* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n6\n"); break;
      case 1: printf ("n15\n"); break;
      case 2: printf ("n25\n"); break;
      case 3: printf ("n50\n"); break;
      case 4: printf ("n75\n"); break;
      case 5: printf ("n100\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_AC_BarringConfig_ac_BarringFactor 
   (const char* name, const AC_BarringConfig_ac_BarringFactor* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("p00\n"); break;
      case 1: printf ("p05\n"); break;
      case 2: printf ("p10\n"); break;
      case 3: printf ("p15\n"); break;
      case 4: printf ("p20\n"); break;
      case 5: printf ("p25\n"); break;
      case 6: printf ("p30\n"); break;
      case 7: printf ("p40\n"); break;
      case 8: printf ("p50\n"); break;
      case 9: printf ("p60\n"); break;
      case 10: printf ("p70\n"); break;
      case 11: printf ("p75\n"); break;
      case 12: printf ("p80\n"); break;
      case 13: printf ("p85\n"); break;
      case 14: printf ("p90\n"); break;
      case 15: printf ("p95\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_AC_BarringConfig_ac_BarringTime 
   (const char* name, const AC_BarringConfig_ac_BarringTime* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("s4\n"); break;
      case 1: printf ("s8\n"); break;
      case 2: printf ("s16\n"); break;
      case 3: printf ("s32\n"); break;
      case 4: printf ("s64\n"); break;
      case 5: printf ("s128\n"); break;
      case 6: printf ("s256\n"); break;
      case 7: printf ("s512\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst 
   (const char* name, const SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("dB0\n"); break;
      case 1: printf ("dB1\n"); break;
      case 2: printf ("dB2\n"); break;
      case 3: printf ("dB3\n"); break;
      case 4: printf ("dB4\n"); break;
      case 5: printf ("dB5\n"); break;
      case 6: printf ("dB6\n"); break;
      case 7: printf ("dB8\n"); break;
      case 8: printf ("dB10\n"); break;
      case 9: printf ("dB12\n"); break;
      case 10: printf ("dB14\n"); break;
      case 11: printf ("dB16\n"); break;
      case 12: printf ("dB18\n"); break;
      case 13: printf ("dB20\n"); break;
      case 14: printf ("dB22\n"); break;
      case 15: printf ("dB24\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium 
   (const char* name, const SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("dB-6\n"); break;
      case 1: printf ("dB-4\n"); break;
      case 2: printf ("dB-2\n"); break;
      case 3: printf ("dB0\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High 
   (const char* name, const SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("dB-6\n"); break;
      case 1: printf ("dB-4\n"); break;
      case 2: printf ("dB-2\n"); break;
      case 3: printf ("dB0\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT 
   (const char* name, const SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_SystemInformationBlockType9_hnb_Name 
   (const char* name, const SystemInformationBlockType9_hnb_Name* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_SystemInformationBlockType10_warningType 
   (const char* name, const SystemInformationBlockType10_warningType* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_SystemInformationBlockType10_warningSecurityInfo 
   (const char* name, const SystemInformationBlockType10_warningSecurityInfo* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_SystemInformationBlockType11_warningMessageSegmentType 
   (const char* name, const SystemInformationBlockType11_warningMessageSegmentType* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("notLastSegment\n"); break;
      case 1: printf ("lastSegment\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SystemInformationBlockType11_dataCodingScheme 
   (const char* name, const SystemInformationBlockType11_dataCodingScheme* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_SystemInformationBlockType12_r9_warningMessageSegmentType_r9 
   (const char* name, const SystemInformationBlockType12_r9_warningMessageSegmentType_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("notLastSegment\n"); break;
      case 1: printf ("lastSegment\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SystemInformationBlockType12_r9_dataCodingScheme_r9 
   (const char* name, const SystemInformationBlockType12_r9_dataCodingScheme_r9* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_AntennaInfoCommon_antennaPortsCount 
   (const char* name, const AntennaInfoCommon_antennaPortsCount* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("an1\n"); break;
      case 1: printf ("an2\n"); break;
      case 2: printf ("an4\n"); break;
      case 3: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_AntennaInfoDedicated_transmissionMode 
   (const char* name, const AntennaInfoDedicated_transmissionMode* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("tm1\n"); break;
      case 1: printf ("tm2\n"); break;
      case 2: printf ("tm3\n"); break;
      case 3: printf ("tm4\n"); break;
      case 4: printf ("tm5\n"); break;
      case 5: printf ("tm6\n"); break;
      case 6: printf ("tm7\n"); break;
      case 7: printf ("tm8-v920\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4 
   (const char* name, const AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_AntennaInfoDedicated_ue_TransmitAntennaSelection_setup 
   (const char* name, const AntennaInfoDedicated_ue_TransmitAntennaSelection_setup* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("closedLoop\n"); break;
      case 1: printf ("openLoop\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_CQI_ReportConfig_cqi_ReportModeAperiodic 
   (const char* name, const CQI_ReportConfig_cqi_ReportModeAperiodic* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("rm12\n"); break;
      case 1: printf ("rm20\n"); break;
      case 2: printf ("rm22\n"); break;
      case 3: printf ("rm30\n"); break;
      case 4: printf ("rm31\n"); break;
      case 5: printf ("spare3\n"); break;
      case 6: printf ("spare2\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_CQI_ReportConfig_v920_cqi_Mask_r9 
   (const char* name, const CQI_ReportConfig_v920_cqi_Mask_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("setup\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_CQI_ReportConfig_v920_pmi_RI_Report_r9 
   (const char* name, const CQI_ReportConfig_v920_pmi_RI_Report_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("setup\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate 
   (const char* name, const LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("kBps0\n"); break;
      case 1: printf ("kBps8\n"); break;
      case 2: printf ("kBps16\n"); break;
      case 3: printf ("kBps32\n"); break;
      case 4: printf ("kBps64\n"); break;
      case 5: printf ("kBps128\n"); break;
      case 6: printf ("kBps256\n"); break;
      case 7: printf ("infinity\n"); break;
      case 8: printf ("spare8\n"); break;
      case 9: printf ("spare7\n"); break;
      case 10: printf ("spare6\n"); break;
      case 11: printf ("spare5\n"); break;
      case 12: printf ("spare4\n"); break;
      case 13: printf ("spare3\n"); break;
      case 14: printf ("spare2\n"); break;
      case 15: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration 
   (const char* name, const LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms50\n"); break;
      case 1: printf ("ms100\n"); break;
      case 2: printf ("ms150\n"); break;
      case 3: printf ("ms300\n"); break;
      case 4: printf ("ms500\n"); break;
      case 5: printf ("ms1000\n"); break;
      case 6: printf ("spare2\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_LogicalChannelConfig_logicalChannelSR_Mask_r9 
   (const char* name, const LogicalChannelConfig_logicalChannelSR_Mask_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("setup\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx 
   (const char* name, const MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n1\n"); break;
      case 1: printf ("n2\n"); break;
      case 2: printf ("n3\n"); break;
      case 3: printf ("n4\n"); break;
      case 4: printf ("n5\n"); break;
      case 5: printf ("n6\n"); break;
      case 6: printf ("n7\n"); break;
      case 7: printf ("n8\n"); break;
      case 8: printf ("n10\n"); break;
      case 9: printf ("n12\n"); break;
      case 10: printf ("n16\n"); break;
      case 11: printf ("n20\n"); break;
      case 12: printf ("n24\n"); break;
      case 13: printf ("n28\n"); break;
      case 14: printf ("spare2\n"); break;
      case 15: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer 
   (const char* name, const MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sf5\n"); break;
      case 1: printf ("sf10\n"); break;
      case 2: printf ("sf16\n"); break;
      case 3: printf ("sf20\n"); break;
      case 4: printf ("sf32\n"); break;
      case 5: printf ("sf40\n"); break;
      case 6: printf ("sf64\n"); break;
      case 7: printf ("sf80\n"); break;
      case 8: printf ("sf128\n"); break;
      case 9: printf ("sf160\n"); break;
      case 10: printf ("sf320\n"); break;
      case 11: printf ("sf640\n"); break;
      case 12: printf ("sf1280\n"); break;
      case 13: printf ("sf2560\n"); break;
      case 14: printf ("infinity\n"); break;
      case 15: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MAC_MainConfig_ul_SCH_Config_retxBSR_Timer 
   (const char* name, const MAC_MainConfig_ul_SCH_Config_retxBSR_Timer* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sf320\n"); break;
      case 1: printf ("sf640\n"); break;
      case 2: printf ("sf1280\n"); break;
      case 3: printf ("sf2560\n"); break;
      case 4: printf ("sf5120\n"); break;
      case 5: printf ("sf10240\n"); break;
      case 6: printf ("spare2\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MAC_MainConfig_phr_Config_setup_periodicPHR_Timer 
   (const char* name, const MAC_MainConfig_phr_Config_setup_periodicPHR_Timer* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sf10\n"); break;
      case 1: printf ("sf20\n"); break;
      case 2: printf ("sf50\n"); break;
      case 3: printf ("sf100\n"); break;
      case 4: printf ("sf200\n"); break;
      case 5: printf ("sf500\n"); break;
      case 6: printf ("sf1000\n"); break;
      case 7: printf ("infinity\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer 
   (const char* name, const MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sf0\n"); break;
      case 1: printf ("sf10\n"); break;
      case 2: printf ("sf20\n"); break;
      case 3: printf ("sf50\n"); break;
      case 4: printf ("sf100\n"); break;
      case 5: printf ("sf200\n"); break;
      case 6: printf ("sf500\n"); break;
      case 7: printf ("sf1000\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MAC_MainConfig_phr_Config_setup_dl_PathlossChange 
   (const char* name, const MAC_MainConfig_phr_Config_setup_dl_PathlossChange* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("dB1\n"); break;
      case 1: printf ("dB3\n"); break;
      case 2: printf ("dB6\n"); break;
      case 3: printf ("infinity\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_DRX_Config_setup_onDurationTimer 
   (const char* name, const DRX_Config_setup_onDurationTimer* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("psf1\n"); break;
      case 1: printf ("psf2\n"); break;
      case 2: printf ("psf3\n"); break;
      case 3: printf ("psf4\n"); break;
      case 4: printf ("psf5\n"); break;
      case 5: printf ("psf6\n"); break;
      case 6: printf ("psf8\n"); break;
      case 7: printf ("psf10\n"); break;
      case 8: printf ("psf20\n"); break;
      case 9: printf ("psf30\n"); break;
      case 10: printf ("psf40\n"); break;
      case 11: printf ("psf50\n"); break;
      case 12: printf ("psf60\n"); break;
      case 13: printf ("psf80\n"); break;
      case 14: printf ("psf100\n"); break;
      case 15: printf ("psf200\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_DRX_Config_setup_drx_InactivityTimer 
   (const char* name, const DRX_Config_setup_drx_InactivityTimer* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("psf1\n"); break;
      case 1: printf ("psf2\n"); break;
      case 2: printf ("psf3\n"); break;
      case 3: printf ("psf4\n"); break;
      case 4: printf ("psf5\n"); break;
      case 5: printf ("psf6\n"); break;
      case 6: printf ("psf8\n"); break;
      case 7: printf ("psf10\n"); break;
      case 8: printf ("psf20\n"); break;
      case 9: printf ("psf30\n"); break;
      case 10: printf ("psf40\n"); break;
      case 11: printf ("psf50\n"); break;
      case 12: printf ("psf60\n"); break;
      case 13: printf ("psf80\n"); break;
      case 14: printf ("psf100\n"); break;
      case 15: printf ("psf200\n"); break;
      case 16: printf ("psf300\n"); break;
      case 17: printf ("psf500\n"); break;
      case 18: printf ("psf750\n"); break;
      case 19: printf ("psf1280\n"); break;
      case 20: printf ("psf1920\n"); break;
      case 21: printf ("psf2560\n"); break;
      case 22: printf ("spare10\n"); break;
      case 23: printf ("spare9\n"); break;
      case 24: printf ("spare8\n"); break;
      case 25: printf ("spare7\n"); break;
      case 26: printf ("spare6\n"); break;
      case 27: printf ("spare5\n"); break;
      case 28: printf ("spare4\n"); break;
      case 29: printf ("spare3\n"); break;
      case 30: printf ("spare2\n"); break;
      case 31: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_DRX_Config_setup_drx_RetransmissionTimer 
   (const char* name, const DRX_Config_setup_drx_RetransmissionTimer* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("psf1\n"); break;
      case 1: printf ("psf2\n"); break;
      case 2: printf ("psf4\n"); break;
      case 3: printf ("psf6\n"); break;
      case 4: printf ("psf8\n"); break;
      case 5: printf ("psf16\n"); break;
      case 6: printf ("psf24\n"); break;
      case 7: printf ("psf33\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_DRX_Config_setup_shortDRX_shortDRX_Cycle 
   (const char* name, const DRX_Config_setup_shortDRX_shortDRX_Cycle* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sf2\n"); break;
      case 1: printf ("sf5\n"); break;
      case 2: printf ("sf8\n"); break;
      case 3: printf ("sf10\n"); break;
      case 4: printf ("sf16\n"); break;
      case 5: printf ("sf20\n"); break;
      case 6: printf ("sf32\n"); break;
      case 7: printf ("sf40\n"); break;
      case 8: printf ("sf64\n"); break;
      case 9: printf ("sf80\n"); break;
      case 10: printf ("sf128\n"); break;
      case 11: printf ("sf160\n"); break;
      case 12: printf ("sf256\n"); break;
      case 13: printf ("sf320\n"); break;
      case 14: printf ("sf512\n"); break;
      case 15: printf ("sf640\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PDCP_Config_discardTimer 
   (const char* name, const PDCP_Config_discardTimer* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms50\n"); break;
      case 1: printf ("ms100\n"); break;
      case 2: printf ("ms150\n"); break;
      case 3: printf ("ms300\n"); break;
      case 4: printf ("ms500\n"); break;
      case 5: printf ("ms750\n"); break;
      case 6: printf ("ms1500\n"); break;
      case 7: printf ("infinity\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PDCP_Config_rlc_UM_pdcp_SN_Size 
   (const char* name, const PDCP_Config_rlc_UM_pdcp_SN_Size* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("len7bits\n"); break;
      case 1: printf ("len12bits\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PDSCH_ConfigDedicated_p_a 
   (const char* name, const PDSCH_ConfigDedicated_p_a* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("dB-6\n"); break;
      case 1: printf ("dB-4dot77\n"); break;
      case 2: printf ("dB-3\n"); break;
      case 3: printf ("dB-1dot77\n"); break;
      case 4: printf ("dB0\n"); break;
      case 5: printf ("dB1\n"); break;
      case 6: printf ("dB2\n"); break;
      case 7: printf ("dB3\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PUCCH_ConfigCommon_deltaPUCCH_Shift 
   (const char* name, const PUCCH_ConfigCommon_deltaPUCCH_Shift* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ds1\n"); break;
      case 1: printf ("ds2\n"); break;
      case 2: printf ("ds3\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor 
   (const char* name, const PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n2\n"); break;
      case 1: printf ("n4\n"); break;
      case 2: printf ("n6\n"); break;
      case 3: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode 
   (const char* name, const PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("bundling\n"); break;
      case 1: printf ("multiplexing\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode 
   (const char* name, const PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("interSubFrame\n"); break;
      case 1: printf ("intraAndInterSubFrame\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles 
   (const char* name, const RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n4\n"); break;
      case 1: printf ("n8\n"); break;
      case 2: printf ("n12\n"); break;
      case 3: printf ("n16\n"); break;
      case 4: printf ("n20\n"); break;
      case 5: printf ("n24\n"); break;
      case 6: printf ("n28\n"); break;
      case 7: printf ("n32\n"); break;
      case 8: printf ("n36\n"); break;
      case 9: printf ("n40\n"); break;
      case 10: printf ("n44\n"); break;
      case 11: printf ("n48\n"); break;
      case 12: printf ("n52\n"); break;
      case 13: printf ("n56\n"); break;
      case 14: printf ("n60\n"); break;
      case 15: printf ("n64\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA 
   (const char* name, const RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n4\n"); break;
      case 1: printf ("n8\n"); break;
      case 2: printf ("n12\n"); break;
      case 3: printf ("n16\n"); break;
      case 4: printf ("n20\n"); break;
      case 5: printf ("n24\n"); break;
      case 6: printf ("n28\n"); break;
      case 7: printf ("n32\n"); break;
      case 8: printf ("n36\n"); break;
      case 9: printf ("n40\n"); break;
      case 10: printf ("n44\n"); break;
      case 11: printf ("n48\n"); break;
      case 12: printf ("n52\n"); break;
      case 13: printf ("n56\n"); break;
      case 14: printf ("n60\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA 
   (const char* name, const RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("b56\n"); break;
      case 1: printf ("b144\n"); break;
      case 2: printf ("b208\n"); break;
      case 3: printf ("b256\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB 
   (const char* name, const RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("minusinfinity\n"); break;
      case 1: printf ("dB0\n"); break;
      case 2: printf ("dB5\n"); break;
      case 3: printf ("dB8\n"); break;
      case 4: printf ("dB10\n"); break;
      case 5: printf ("dB12\n"); break;
      case 6: printf ("dB15\n"); break;
      case 7: printf ("dB18\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RACH_ConfigCommon_powerRampingParameters_powerRampingStep 
   (const char* name, const RACH_ConfigCommon_powerRampingParameters_powerRampingStep* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("dB0\n"); break;
      case 1: printf ("dB2\n"); break;
      case 2: printf ("dB4\n"); break;
      case 3: printf ("dB6\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower 
   (const char* name, const RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("dBm-120\n"); break;
      case 1: printf ("dBm-118\n"); break;
      case 2: printf ("dBm-116\n"); break;
      case 3: printf ("dBm-114\n"); break;
      case 4: printf ("dBm-112\n"); break;
      case 5: printf ("dBm-110\n"); break;
      case 6: printf ("dBm-108\n"); break;
      case 7: printf ("dBm-106\n"); break;
      case 8: printf ("dBm-104\n"); break;
      case 9: printf ("dBm-102\n"); break;
      case 10: printf ("dBm-100\n"); break;
      case 11: printf ("dBm-98\n"); break;
      case 12: printf ("dBm-96\n"); break;
      case 13: printf ("dBm-94\n"); break;
      case 14: printf ("dBm-92\n"); break;
      case 15: printf ("dBm-90\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax 
   (const char* name, const RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n3\n"); break;
      case 1: printf ("n4\n"); break;
      case 2: printf ("n5\n"); break;
      case 3: printf ("n6\n"); break;
      case 4: printf ("n7\n"); break;
      case 5: printf ("n8\n"); break;
      case 6: printf ("n10\n"); break;
      case 7: printf ("n20\n"); break;
      case 8: printf ("n50\n"); break;
      case 9: printf ("n100\n"); break;
      case 10: printf ("n200\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize 
   (const char* name, const RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sf2\n"); break;
      case 1: printf ("sf3\n"); break;
      case 2: printf ("sf4\n"); break;
      case 3: printf ("sf5\n"); break;
      case 4: printf ("sf6\n"); break;
      case 5: printf ("sf7\n"); break;
      case 6: printf ("sf8\n"); break;
      case 7: printf ("sf10\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer 
   (const char* name, const RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sf8\n"); break;
      case 1: printf ("sf16\n"); break;
      case 2: printf ("sf24\n"); break;
      case 3: printf ("sf32\n"); break;
      case 4: printf ("sf40\n"); break;
      case 5: printf ("sf48\n"); break;
      case 6: printf ("sf56\n"); break;
      case 7: printf ("sf64\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_BCCH_Config_modificationPeriodCoeff 
   (const char* name, const BCCH_Config_modificationPeriodCoeff* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n2\n"); break;
      case 1: printf ("n4\n"); break;
      case 2: printf ("n8\n"); break;
      case 3: printf ("n16\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PCCH_Config_defaultPagingCycle 
   (const char* name, const PCCH_Config_defaultPagingCycle* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("rf32\n"); break;
      case 1: printf ("rf64\n"); break;
      case 2: printf ("rf128\n"); break;
      case 3: printf ("rf256\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PCCH_Config_nB (const char* name, const PCCH_Config_nB* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("fourT\n"); break;
      case 1: printf ("twoT\n"); break;
      case 2: printf ("oneT\n"); break;
      case 3: printf ("halfT\n"); break;
      case 4: printf ("quarterT\n"); break;
      case 5: printf ("oneEighthT\n"); break;
      case 6: printf ("oneSixteenthT\n"); break;
      case 7: printf ("oneThirtySecondT\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_UL_AM_RLC_maxRetxThreshold 
   (const char* name, const UL_AM_RLC_maxRetxThreshold* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("t1\n"); break;
      case 1: printf ("t2\n"); break;
      case 2: printf ("t3\n"); break;
      case 3: printf ("t4\n"); break;
      case 4: printf ("t6\n"); break;
      case 5: printf ("t8\n"); break;
      case 6: printf ("t16\n"); break;
      case 7: printf ("t32\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RLF_TimersAndConstants_r9_setup_t301_r9 
   (const char* name, const RLF_TimersAndConstants_r9_setup_t301_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms100\n"); break;
      case 1: printf ("ms200\n"); break;
      case 2: printf ("ms300\n"); break;
      case 3: printf ("ms400\n"); break;
      case 4: printf ("ms600\n"); break;
      case 5: printf ("ms1000\n"); break;
      case 6: printf ("ms1500\n"); break;
      case 7: printf ("ms2000\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RLF_TimersAndConstants_r9_setup_t310_r9 
   (const char* name, const RLF_TimersAndConstants_r9_setup_t310_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms0\n"); break;
      case 1: printf ("ms50\n"); break;
      case 2: printf ("ms100\n"); break;
      case 3: printf ("ms200\n"); break;
      case 4: printf ("ms500\n"); break;
      case 5: printf ("ms1000\n"); break;
      case 6: printf ("ms2000\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RLF_TimersAndConstants_r9_setup_n310_r9 
   (const char* name, const RLF_TimersAndConstants_r9_setup_n310_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n1\n"); break;
      case 1: printf ("n2\n"); break;
      case 2: printf ("n3\n"); break;
      case 3: printf ("n4\n"); break;
      case 4: printf ("n6\n"); break;
      case 5: printf ("n8\n"); break;
      case 6: printf ("n10\n"); break;
      case 7: printf ("n20\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RLF_TimersAndConstants_r9_setup_t311_r9 
   (const char* name, const RLF_TimersAndConstants_r9_setup_t311_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms1000\n"); break;
      case 1: printf ("ms3000\n"); break;
      case 2: printf ("ms5000\n"); break;
      case 3: printf ("ms10000\n"); break;
      case 4: printf ("ms15000\n"); break;
      case 5: printf ("ms20000\n"); break;
      case 6: printf ("ms30000\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_RLF_TimersAndConstants_r9_setup_n311_r9 
   (const char* name, const RLF_TimersAndConstants_r9_setup_n311_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n1\n"); break;
      case 1: printf ("n2\n"); break;
      case 2: printf ("n3\n"); break;
      case 3: printf ("n4\n"); break;
      case 4: printf ("n5\n"); break;
      case 5: printf ("n6\n"); break;
      case 6: printf ("n8\n"); break;
      case 7: printf ("n10\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SchedulingRequestConfig_setup_dsr_TransMax 
   (const char* name, const SchedulingRequestConfig_setup_dsr_TransMax* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n4\n"); break;
      case 1: printf ("n8\n"); break;
      case 2: printf ("n16\n"); break;
      case 3: printf ("n32\n"); break;
      case 4: printf ("n64\n"); break;
      case 5: printf ("spare3\n"); break;
      case 6: printf ("spare2\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig 
   (const char* name, const SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("bw0\n"); break;
      case 1: printf ("bw1\n"); break;
      case 2: printf ("bw2\n"); break;
      case 3: printf ("bw3\n"); break;
      case 4: printf ("bw4\n"); break;
      case 5: printf ("bw5\n"); break;
      case 6: printf ("bw6\n"); break;
      case 7: printf ("bw7\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig 
   (const char* name, const SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sc0\n"); break;
      case 1: printf ("sc1\n"); break;
      case 2: printf ("sc2\n"); break;
      case 3: printf ("sc3\n"); break;
      case 4: printf ("sc4\n"); break;
      case 5: printf ("sc5\n"); break;
      case 6: printf ("sc6\n"); break;
      case 7: printf ("sc7\n"); break;
      case 8: printf ("sc8\n"); break;
      case 9: printf ("sc9\n"); break;
      case 10: printf ("sc10\n"); break;
      case 11: printf ("sc11\n"); break;
      case 12: printf ("sc12\n"); break;
      case 13: printf ("sc13\n"); break;
      case 14: printf ("sc14\n"); break;
      case 15: printf ("sc15\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts 
   (const char* name, const SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("true\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth 
   (const char* name, const SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("bw0\n"); break;
      case 1: printf ("bw1\n"); break;
      case 2: printf ("bw2\n"); break;
      case 3: printf ("bw3\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth 
   (const char* name, const SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("hbw0\n"); break;
      case 1: printf ("hbw1\n"); break;
      case 2: printf ("hbw2\n"); break;
      case 3: printf ("hbw3\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SoundingRS_UL_ConfigDedicated_setup_cyclicShift 
   (const char* name, const SoundingRS_UL_ConfigDedicated_setup_cyclicShift* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("cs0\n"); break;
      case 1: printf ("cs1\n"); break;
      case 2: printf ("cs2\n"); break;
      case 3: printf ("cs3\n"); break;
      case 4: printf ("cs4\n"); break;
      case 5: printf ("cs5\n"); break;
      case 6: printf ("cs6\n"); break;
      case 7: printf ("cs7\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SPS_ConfigDL_setup_semiPersistSchedIntervalDL 
   (const char* name, const SPS_ConfigDL_setup_semiPersistSchedIntervalDL* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sf10\n"); break;
      case 1: printf ("sf20\n"); break;
      case 2: printf ("sf32\n"); break;
      case 3: printf ("sf40\n"); break;
      case 4: printf ("sf64\n"); break;
      case 5: printf ("sf80\n"); break;
      case 6: printf ("sf128\n"); break;
      case 7: printf ("sf160\n"); break;
      case 8: printf ("sf320\n"); break;
      case 9: printf ("sf640\n"); break;
      case 10: printf ("spare6\n"); break;
      case 11: printf ("spare5\n"); break;
      case 12: printf ("spare4\n"); break;
      case 13: printf ("spare3\n"); break;
      case 14: printf ("spare2\n"); break;
      case 15: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SPS_ConfigUL_setup_semiPersistSchedIntervalUL 
   (const char* name, const SPS_ConfigUL_setup_semiPersistSchedIntervalUL* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sf10\n"); break;
      case 1: printf ("sf20\n"); break;
      case 2: printf ("sf32\n"); break;
      case 3: printf ("sf40\n"); break;
      case 4: printf ("sf64\n"); break;
      case 5: printf ("sf80\n"); break;
      case 6: printf ("sf128\n"); break;
      case 7: printf ("sf160\n"); break;
      case 8: printf ("sf320\n"); break;
      case 9: printf ("sf640\n"); break;
      case 10: printf ("spare6\n"); break;
      case 11: printf ("spare5\n"); break;
      case 12: printf ("spare4\n"); break;
      case 13: printf ("spare3\n"); break;
      case 14: printf ("spare2\n"); break;
      case 15: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SPS_ConfigUL_setup_implicitReleaseAfter 
   (const char* name, const SPS_ConfigUL_setup_implicitReleaseAfter* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("e2\n"); break;
      case 1: printf ("e3\n"); break;
      case 2: printf ("e4\n"); break;
      case 3: printf ("e8\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SPS_ConfigUL_setup_twoIntervalsConfig 
   (const char* name, const SPS_ConfigUL_setup_twoIntervalsConfig* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("true\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_TDD_Config_subframeAssignment 
   (const char* name, const TDD_Config_subframeAssignment* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sa0\n"); break;
      case 1: printf ("sa1\n"); break;
      case 2: printf ("sa2\n"); break;
      case 3: printf ("sa3\n"); break;
      case 4: printf ("sa4\n"); break;
      case 5: printf ("sa5\n"); break;
      case 6: printf ("sa6\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_TDD_Config_specialSubframePatterns 
   (const char* name, const TDD_Config_specialSubframePatterns* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ssp0\n"); break;
      case 1: printf ("ssp1\n"); break;
      case 2: printf ("ssp2\n"); break;
      case 3: printf ("ssp3\n"); break;
      case 4: printf ("ssp4\n"); break;
      case 5: printf ("ssp5\n"); break;
      case 6: printf ("ssp6\n"); break;
      case 7: printf ("ssp7\n"); break;
      case 8: printf ("ssp8\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_UplinkPowerControlCommon_alpha 
   (const char* name, const UplinkPowerControlCommon_alpha* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("al0\n"); break;
      case 1: printf ("al04\n"); break;
      case 2: printf ("al05\n"); break;
      case 3: printf ("al06\n"); break;
      case 4: printf ("al07\n"); break;
      case 5: printf ("al08\n"); break;
      case 6: printf ("al09\n"); break;
      case 7: printf ("al1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_UplinkPowerControlDedicated_deltaMCS_Enabled 
   (const char* name, const UplinkPowerControlDedicated_deltaMCS_Enabled* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("en0\n"); break;
      case 1: printf ("en1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_DeltaFList_PUCCH_deltaF_PUCCH_Format1 
   (const char* name, const DeltaFList_PUCCH_deltaF_PUCCH_Format1* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("deltaF-2\n"); break;
      case 1: printf ("deltaF0\n"); break;
      case 2: printf ("deltaF2\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_DeltaFList_PUCCH_deltaF_PUCCH_Format1b 
   (const char* name, const DeltaFList_PUCCH_deltaF_PUCCH_Format1b* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("deltaF1\n"); break;
      case 1: printf ("deltaF3\n"); break;
      case 2: printf ("deltaF5\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_DeltaFList_PUCCH_deltaF_PUCCH_Format2 
   (const char* name, const DeltaFList_PUCCH_deltaF_PUCCH_Format2* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("deltaF-2\n"); break;
      case 1: printf ("deltaF0\n"); break;
      case 2: printf ("deltaF1\n"); break;
      case 3: printf ("deltaF2\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_DeltaFList_PUCCH_deltaF_PUCCH_Format2a 
   (const char* name, const DeltaFList_PUCCH_deltaF_PUCCH_Format2a* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("deltaF-2\n"); break;
      case 1: printf ("deltaF0\n"); break;
      case 2: printf ("deltaF2\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_DeltaFList_PUCCH_deltaF_PUCCH_Format2b 
   (const char* name, const DeltaFList_PUCCH_deltaF_PUCCH_Format2b* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("deltaF-2\n"); break;
      case 1: printf ("deltaF0\n"); break;
      case 2: printf ("deltaF2\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SecurityAlgorithmConfig_cipheringAlgorithm 
   (const char* name, const SecurityAlgorithmConfig_cipheringAlgorithm* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("eea0\n"); break;
      case 1: printf ("eea1\n"); break;
      case 2: printf ("eea2\n"); break;
      case 3: printf ("spare5\n"); break;
      case 4: printf ("spare4\n"); break;
      case 5: printf ("spare3\n"); break;
      case 6: printf ("spare2\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_SecurityAlgorithmConfig_integrityProtAlgorithm 
   (const char* name, const SecurityAlgorithmConfig_integrityProtAlgorithm* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("eia0-v920\n"); break;
      case 1: printf ("eia1\n"); break;
      case 2: printf ("eia2\n"); break;
      case 3: printf ("spare5\n"); break;
      case 4: printf ("spare4\n"); break;
      case 5: printf ("spare3\n"); break;
      case 6: printf ("spare2\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs 
   (const char* name, const CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9 
   (const char* name, const CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("true\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_CellGlobalIdCDMA2000_cellGlobalId1XRTT 
   (const char* name, const CellGlobalIdCDMA2000_cellGlobalId1XRTT* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_CellGlobalIdCDMA2000_cellGlobalIdHRPD 
   (const char* name, const CellGlobalIdCDMA2000_cellGlobalIdHRPD* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_MobilityControlInfo_t304 
   (const char* name, const MobilityControlInfo_t304* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms50\n"); break;
      case 1: printf ("ms100\n"); break;
      case 2: printf ("ms150\n"); break;
      case 3: printf ("ms200\n"); break;
      case 4: printf ("ms500\n"); break;
      case 5: printf ("ms1000\n"); break;
      case 6: printf ("ms2000\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_CarrierBandwidthEUTRA_dl_Bandwidth 
   (const char* name, const CarrierBandwidthEUTRA_dl_Bandwidth* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n6\n"); break;
      case 1: printf ("n15\n"); break;
      case 2: printf ("n25\n"); break;
      case 3: printf ("n50\n"); break;
      case 4: printf ("n75\n"); break;
      case 5: printf ("n100\n"); break;
      case 6: printf ("spare10\n"); break;
      case 7: printf ("spare9\n"); break;
      case 8: printf ("spare8\n"); break;
      case 9: printf ("spare7\n"); break;
      case 10: printf ("spare6\n"); break;
      case 11: printf ("spare5\n"); break;
      case 12: printf ("spare4\n"); break;
      case 13: printf ("spare3\n"); break;
      case 14: printf ("spare2\n"); break;
      case 15: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_CarrierBandwidthEUTRA_ul_Bandwidth 
   (const char* name, const CarrierBandwidthEUTRA_ul_Bandwidth* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n6\n"); break;
      case 1: printf ("n15\n"); break;
      case 2: printf ("n25\n"); break;
      case 3: printf ("n50\n"); break;
      case 4: printf ("n75\n"); break;
      case 5: printf ("n100\n"); break;
      case 6: printf ("spare10\n"); break;
      case 7: printf ("spare9\n"); break;
      case 8: printf ("spare8\n"); break;
      case 9: printf ("spare7\n"); break;
      case 10: printf ("spare6\n"); break;
      case 11: printf ("spare5\n"); break;
      case 12: printf ("spare4\n"); break;
      case 13: printf ("spare3\n"); break;
      case 14: printf ("spare2\n"); break;
      case 15: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MobilityStateParameters_t_Evaluation 
   (const char* name, const MobilityStateParameters_t_Evaluation* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("s30\n"); break;
      case 1: printf ("s60\n"); break;
      case 2: printf ("s120\n"); break;
      case 3: printf ("s180\n"); break;
      case 4: printf ("s240\n"); break;
      case 5: printf ("spare3\n"); break;
      case 6: printf ("spare2\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MobilityStateParameters_t_HystNormal 
   (const char* name, const MobilityStateParameters_t_HystNormal* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("s30\n"); break;
      case 1: printf ("s60\n"); break;
      case 2: printf ("s120\n"); break;
      case 3: printf ("s180\n"); break;
      case 4: printf ("s240\n"); break;
      case 5: printf ("spare3\n"); break;
      case 6: printf ("spare2\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PhysCellIdRange_range 
   (const char* name, const PhysCellIdRange_range* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n4\n"); break;
      case 1: printf ("n8\n"); break;
      case 2: printf ("n12\n"); break;
      case 3: printf ("n16\n"); break;
      case 4: printf ("n24\n"); break;
      case 5: printf ("n32\n"); break;
      case 6: printf ("n48\n"); break;
      case 7: printf ("n64\n"); break;
      case 8: printf ("n84\n"); break;
      case 9: printf ("n96\n"); break;
      case 10: printf ("n128\n"); break;
      case 11: printf ("n168\n"); break;
      case 12: printf ("n252\n"); break;
      case 13: printf ("n504\n"); break;
      case 14: printf ("spare2\n"); break;
      case 15: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SpeedStateScaleFactors_sf_Medium 
   (const char* name, const SpeedStateScaleFactors_sf_Medium* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("oDot25\n"); break;
      case 1: printf ("oDot5\n"); break;
      case 2: printf ("oDot75\n"); break;
      case 3: printf ("lDot0\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SpeedStateScaleFactors_sf_High 
   (const char* name, const SpeedStateScaleFactors_sf_High* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("oDot25\n"); break;
      case 1: printf ("oDot5\n"); break;
      case 2: printf ("oDot75\n"); break;
      case 3: printf ("lDot0\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SystemInfoListGERAN_element 
   (const char* name, const SystemInfoListGERAN_element* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime 
   (const char* name, const SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime 
   (const char* name, const SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_AdditionalSI_Info_r9_csg_MemberStatus_r9 
   (const char* name, const AdditionalSI_Info_r9_csg_MemberStatus_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("member\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_QuantityConfigUTRA_measQuantityUTRA_FDD 
   (const char* name, const QuantityConfigUTRA_measQuantityUTRA_FDD* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("cpich-RSCP\n"); break;
      case 1: printf ("cpich-EcN0\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_QuantityConfigUTRA_measQuantityUTRA_TDD 
   (const char* name, const QuantityConfigUTRA_measQuantityUTRA_TDD* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("pccpch-RSCP\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_QuantityConfigGERAN_measQuantityGERAN 
   (const char* name, const QuantityConfigGERAN_measQuantityGERAN* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("rssi\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_QuantityConfigCDMA2000_measQuantityCDMA2000 
   (const char* name, const QuantityConfigCDMA2000_measQuantityCDMA2000* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("pilotStrength\n"); break;
      case 1: printf ("pilotPnPhaseAndPilotStrength\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ReportConfigEUTRA_triggerType_periodical_purpose 
   (const char* name, const ReportConfigEUTRA_triggerType_periodical_purpose* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("reportStrongestCells\n"); break;
      case 1: printf ("reportCGI\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ReportConfigEUTRA_triggerQuantity 
   (const char* name, const ReportConfigEUTRA_triggerQuantity* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("rsrp\n"); break;
      case 1: printf ("rsrq\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ReportConfigEUTRA_reportQuantity 
   (const char* name, const ReportConfigEUTRA_reportQuantity* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sameAsTriggerQuantity\n"); break;
      case 1: printf ("both\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ReportConfigEUTRA_reportAmount 
   (const char* name, const ReportConfigEUTRA_reportAmount* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("r1\n"); break;
      case 1: printf ("r2\n"); break;
      case 2: printf ("r4\n"); break;
      case 3: printf ("r8\n"); break;
      case 4: printf ("r16\n"); break;
      case 5: printf ("r32\n"); break;
      case 6: printf ("r64\n"); break;
      case 7: printf ("infinity\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ReportConfigEUTRA_si_RequestForHO_r9 
   (const char* name, const ReportConfigEUTRA_si_RequestForHO_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("setup\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9 
   (const char* name, const ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("setup\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ReportConfigInterRAT_triggerType_periodical_purpose 
   (const char* name, const ReportConfigInterRAT_triggerType_periodical_purpose* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("reportStrongestCells\n"); break;
      case 1: printf ("reportStrongestCellsForSON\n"); break;
      case 2: printf ("reportCGI\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ReportConfigInterRAT_reportAmount 
   (const char* name, const ReportConfigInterRAT_reportAmount* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("r1\n"); break;
      case 1: printf ("r2\n"); break;
      case 2: printf ("r4\n"); break;
      case 3: printf ("r8\n"); break;
      case 4: printf ("r16\n"); break;
      case 5: printf ("r32\n"); break;
      case 6: printf ("r64\n"); break;
      case 7: printf ("infinity\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ReportConfigInterRAT_si_RequestForHO_r9 
   (const char* name, const ReportConfigInterRAT_si_RequestForHO_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("setup\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ReportProximityConfig_r9_proximityIndicationEUTRA_r9 
   (const char* name, const ReportProximityConfig_r9_proximityIndicationEUTRA_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("enabled\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ReportProximityConfig_r9_proximityIndicationUTRA_r9 
   (const char* name, const ReportProximityConfig_r9_proximityIndicationUTRA_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("enabled\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_UE_EUTRA_Capability_v920_IEs_deviceType_r9 
   (const char* name, const UE_EUTRA_Capability_v920_IEs_deviceType_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("noBenFromBatConsumpOpt\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PDCP_Parameters_maxNumberROHC_ContextSessions 
   (const char* name, const PDCP_Parameters_maxNumberROHC_ContextSessions* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("cs2\n"); break;
      case 1: printf ("cs4\n"); break;
      case 2: printf ("cs8\n"); break;
      case 3: printf ("cs12\n"); break;
      case 4: printf ("cs16\n"); break;
      case 5: printf ("cs24\n"); break;
      case 6: printf ("cs32\n"); break;
      case 7: printf ("cs48\n"); break;
      case 8: printf ("cs64\n"); break;
      case 9: printf ("cs128\n"); break;
      case 10: printf ("cs256\n"); break;
      case 11: printf ("cs512\n"); break;
      case 12: printf ("cs1024\n"); break;
      case 13: printf ("cs16384\n"); break;
      case 14: printf ("spare2\n"); break;
      case 15: printf ("spare1\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PhyLayerParameters_v920_enhancedDualLayerFDD_r9 
   (const char* name, const PhyLayerParameters_v920_enhancedDualLayerFDD_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_PhyLayerParameters_v920_enhancedDualLayerTDD_r9 
   (const char* name, const PhyLayerParameters_v920_enhancedDualLayerTDD_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9 
   (const char* name, const IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_IRAT_ParametersGERAN_v920_dtm_r9 
   (const char* name, const IRAT_ParametersGERAN_v920_dtm_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9 
   (const char* name, const IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD 
   (const char* name, const IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("single\n"); break;
      case 1: printf ("dual\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD 
   (const char* name, const IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("single\n"); break;
      case 1: printf ("dual\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT 
   (const char* name, const IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("single\n"); break;
      case 1: printf ("dual\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT 
   (const char* name, const IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("single\n"); break;
      case 1: printf ("dual\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9 
   (const char* name, const IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9 
   (const char* name, const IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9 
   (const char* name, const CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9 
   (const char* name, const CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9 
   (const char* name, const CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9 
   (const char* name, const NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9 
   (const char* name, const NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9 
   (const char* name, const NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_SON_Parameters_r9_rach_Report_r9 
   (const char* name, const SON_Parameters_r9_rach_Report_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_UE_TimersAndConstants_t300 
   (const char* name, const UE_TimersAndConstants_t300* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms100\n"); break;
      case 1: printf ("ms200\n"); break;
      case 2: printf ("ms300\n"); break;
      case 3: printf ("ms400\n"); break;
      case 4: printf ("ms600\n"); break;
      case 5: printf ("ms1000\n"); break;
      case 6: printf ("ms1500\n"); break;
      case 7: printf ("ms2000\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_UE_TimersAndConstants_t301 
   (const char* name, const UE_TimersAndConstants_t301* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms100\n"); break;
      case 1: printf ("ms200\n"); break;
      case 2: printf ("ms300\n"); break;
      case 3: printf ("ms400\n"); break;
      case 4: printf ("ms600\n"); break;
      case 5: printf ("ms1000\n"); break;
      case 6: printf ("ms1500\n"); break;
      case 7: printf ("ms2000\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_UE_TimersAndConstants_t310 
   (const char* name, const UE_TimersAndConstants_t310* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms0\n"); break;
      case 1: printf ("ms50\n"); break;
      case 2: printf ("ms100\n"); break;
      case 3: printf ("ms200\n"); break;
      case 4: printf ("ms500\n"); break;
      case 5: printf ("ms1000\n"); break;
      case 6: printf ("ms2000\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_UE_TimersAndConstants_n310 
   (const char* name, const UE_TimersAndConstants_n310* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n1\n"); break;
      case 1: printf ("n2\n"); break;
      case 2: printf ("n3\n"); break;
      case 3: printf ("n4\n"); break;
      case 4: printf ("n6\n"); break;
      case 5: printf ("n8\n"); break;
      case 6: printf ("n10\n"); break;
      case 7: printf ("n20\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_UE_TimersAndConstants_t311 
   (const char* name, const UE_TimersAndConstants_t311* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms1000\n"); break;
      case 1: printf ("ms3000\n"); break;
      case 2: printf ("ms5000\n"); break;
      case 3: printf ("ms10000\n"); break;
      case 4: printf ("ms15000\n"); break;
      case 5: printf ("ms20000\n"); break;
      case 6: printf ("ms30000\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_UE_TimersAndConstants_n311 
   (const char* name, const UE_TimersAndConstants_n311* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n1\n"); break;
      case 1: printf ("n2\n"); break;
      case 2: printf ("n3\n"); break;
      case 3: printf ("n4\n"); break;
      case 4: printf ("n5\n"); break;
      case 5: printf ("n6\n"); break;
      case 6: printf ("n8\n"); break;
      case 7: printf ("n10\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9 
   (const char* name, const MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n2\n"); break;
      case 1: printf ("n4\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MBSFN_AreaInfo_r9_non_MBSFNregionLength 
   (const char* name, const MBSFN_AreaInfo_r9_non_MBSFNregionLength* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("s1\n"); break;
      case 1: printf ("s2\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9 
   (const char* name, const MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("rf32\n"); break;
      case 1: printf ("rf64\n"); break;
      case 2: printf ("rf128\n"); break;
      case 3: printf ("rf256\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9 
   (const char* name, const MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("rf512\n"); break;
      case 1: printf ("rf1024\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9 
   (const char* name, const MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n2\n"); break;
      case 1: printf ("n7\n"); break;
      case 2: printf ("n13\n"); break;
      case 3: printf ("n19\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MBSFN_SubframeConfig_radioframeAllocationPeriod 
   (const char* name, const MBSFN_SubframeConfig_radioframeAllocationPeriod* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n1\n"); break;
      case 1: printf ("n2\n"); break;
      case 2: printf ("n4\n"); break;
      case 3: printf ("n8\n"); break;
      case 4: printf ("n16\n"); break;
      case 5: printf ("n32\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_MBMS_SessionInfo_r9_sessionId_r9 
   (const char* name, const MBMS_SessionInfo_r9_sessionId_r9* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_PMCH_Config_r9_mch_SchedulingPeriod_r9 
   (const char* name, const PMCH_Config_r9_mch_SchedulingPeriod_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("rf8\n"); break;
      case 1: printf ("rf16\n"); break;
      case 2: printf ("rf32\n"); break;
      case 3: printf ("rf64\n"); break;
      case 4: printf ("rf128\n"); break;
      case 5: printf ("rf256\n"); break;
      case 6: printf ("rf512\n"); break;
      case 7: printf ("rf1024\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_TMGI_r9_serviceId_r9 
   (const char* name, const TMGI_r9_serviceId_r9* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_BCCH_BCH_Message 
   (const char* name, const BCCH_BCH_Message* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_BCCH_BCH_MessageType ("message", &pvalue->message);

   rtxPrintCloseBrace ();
}

void asn1Print_AC_BarringConfig 
   (const char* name, const AC_BarringConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_AC_BarringConfig_ac_BarringFactor ("ac_BarringFactor", &pvalue->
      ac_BarringFactor);

   asn1Print_AC_BarringConfig_ac_BarringTime ("ac_BarringTime", &pvalue->
      ac_BarringTime);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("ac_BarringForSpecialAC", pvalue->ac_BarringForSpecialAC.numbits, pvalue->ac_BarringForSpecialAC.data);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType2_ac_BarringInfo 
   (const char* name, const SystemInformationBlockType2_ac_BarringInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("ac_BarringForEmergency", pvalue->ac_BarringForEmergency);

   if (pvalue->m.ac_BarringForMO_SignallingPresent) {
      asn1Print_AC_BarringConfig ("ac_BarringForMO_Signalling", &pvalue->
         ac_BarringForMO_Signalling);
   }

   if (pvalue->m.ac_BarringForMO_DataPresent) {
      asn1Print_AC_BarringConfig ("ac_BarringForMO_Data", &pvalue->
         ac_BarringForMO_Data);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig 
   (const char* name, const RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA (
      "sizeOfRA_PreamblesGroupA", &pvalue->sizeOfRA_PreamblesGroupA);

   asn1Print_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA (
      "messageSizeGroupA", &pvalue->messageSizeGroupA);

   asn1Print_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB (
      "messagePowerOffsetGroupB", &pvalue->messagePowerOffsetGroupB);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_RACH_ConfigCommon_preambleInfo 
   (const char* name, const RACH_ConfigCommon_preambleInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles (
      "numberOfRA_Preambles", &pvalue->numberOfRA_Preambles);

   if (pvalue->m.preamblesGroupAConfigPresent) {
      asn1Print_RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig (
         "preamblesGroupAConfig", &pvalue->preamblesGroupAConfig);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RACH_ConfigCommon_powerRampingParameters 
   (const char* name, const RACH_ConfigCommon_powerRampingParameters* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RACH_ConfigCommon_powerRampingParameters_powerRampingStep (
      "powerRampingStep", &pvalue->powerRampingStep);

   asn1Print_RACH_ConfigCommon_powerRampingParameters_preambleInitialReceivedTargetPower (
      "preambleInitialReceivedTargetPower", &pvalue->
      preambleInitialReceivedTargetPower);

   rtxPrintCloseBrace ();
}

void asn1Print_RACH_ConfigCommon_ra_SupervisionInfo 
   (const char* name, const RACH_ConfigCommon_ra_SupervisionInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RACH_ConfigCommon_ra_SupervisionInfo_preambleTransMax (
      "preambleTransMax", &pvalue->preambleTransMax);

   asn1Print_RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize (
      "ra_ResponseWindowSize", &pvalue->ra_ResponseWindowSize);

   asn1Print_RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer (
      "mac_ContentionResolutionTimer", &pvalue->mac_ContentionResolutionTimer
      );

   rtxPrintCloseBrace ();
}

void asn1Print_RACH_ConfigCommon 
   (const char* name, const RACH_ConfigCommon* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RACH_ConfigCommon_preambleInfo ("preambleInfo", &pvalue->
      preambleInfo);

   asn1Print_RACH_ConfigCommon_powerRampingParameters (
      "powerRampingParameters", &pvalue->powerRampingParameters);

   asn1Print_RACH_ConfigCommon_ra_SupervisionInfo ("ra_SupervisionInfo", &
      pvalue->ra_SupervisionInfo);

   rtxPrintIndent ();
   rtxPrintUnsigned ("maxHARQ_Msg3Tx", pvalue->maxHARQ_Msg3Tx);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_BCCH_Config (const char* name, const BCCH_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_BCCH_Config_modificationPeriodCoeff ("modificationPeriodCoeff", &
      pvalue->modificationPeriodCoeff);

   rtxPrintCloseBrace ();
}

void asn1Print_PCCH_Config (const char* name, const PCCH_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PCCH_Config_defaultPagingCycle ("defaultPagingCycle", &pvalue->
      defaultPagingCycle);

   asn1Print_PCCH_Config_nB ("nB", &pvalue->nB);

   rtxPrintCloseBrace ();
}

void asn1Print_PRACH_ConfigInfo 
   (const char* name, const PRACH_ConfigInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("prach_ConfigIndex", pvalue->prach_ConfigIndex);

   rtxPrintIndent ();
   rtxPrintBoolean ("highSpeedFlag", pvalue->highSpeedFlag);

   rtxPrintIndent ();
   rtxPrintUnsigned ("zeroCorrelationZoneConfig", pvalue->zeroCorrelationZoneConfig);

   rtxPrintIndent ();
   rtxPrintUnsigned ("prach_FreqOffset", pvalue->prach_FreqOffset);

   rtxPrintCloseBrace ();
}

void asn1Print_PRACH_ConfigSIB 
   (const char* name, const PRACH_ConfigSIB* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("rootSequenceIndex", pvalue->rootSequenceIndex);

   asn1Print_PRACH_ConfigInfo ("prach_ConfigInfo", &pvalue->prach_ConfigInfo);

   rtxPrintCloseBrace ();
}

void asn1Print_PDSCH_ConfigCommon 
   (const char* name, const PDSCH_ConfigCommon* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintInteger ("referenceSignalPower", pvalue->referenceSignalPower);

   rtxPrintIndent ();
   rtxPrintUnsigned ("p_b", pvalue->p_b);

   rtxPrintCloseBrace ();
}

void asn1Print_PUSCH_ConfigCommon_pusch_ConfigBasic 
   (const char* name, const PUSCH_ConfigCommon_pusch_ConfigBasic* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("n_SB", pvalue->n_SB);

   asn1Print_PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode ("hoppingMode", &
      pvalue->hoppingMode);

   rtxPrintIndent ();
   rtxPrintUnsigned ("pusch_HoppingOffset", pvalue->pusch_HoppingOffset);

   rtxPrintIndent ();
   rtxPrintBoolean ("enable64QAM", pvalue->enable64QAM);

   rtxPrintCloseBrace ();
}

void asn1Print_UL_ReferenceSignalsPUSCH 
   (const char* name, const UL_ReferenceSignalsPUSCH* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("groupHoppingEnabled", pvalue->groupHoppingEnabled);

   rtxPrintIndent ();
   rtxPrintUnsigned ("groupAssignmentPUSCH", pvalue->groupAssignmentPUSCH);

   rtxPrintIndent ();
   rtxPrintBoolean ("sequenceHoppingEnabled", pvalue->sequenceHoppingEnabled);

   rtxPrintIndent ();
   rtxPrintUnsigned ("cyclicShift", pvalue->cyclicShift);

   rtxPrintCloseBrace ();
}

void asn1Print_PUSCH_ConfigCommon 
   (const char* name, const PUSCH_ConfigCommon* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PUSCH_ConfigCommon_pusch_ConfigBasic ("pusch_ConfigBasic", &pvalue
      ->pusch_ConfigBasic);

   asn1Print_UL_ReferenceSignalsPUSCH ("ul_ReferenceSignalsPUSCH", &pvalue->
      ul_ReferenceSignalsPUSCH);

   rtxPrintCloseBrace ();
}

void asn1Print_PUCCH_ConfigCommon 
   (const char* name, const PUCCH_ConfigCommon* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PUCCH_ConfigCommon_deltaPUCCH_Shift ("deltaPUCCH_Shift", &pvalue->
      deltaPUCCH_Shift);

   rtxPrintIndent ();
   rtxPrintUnsigned ("nRB_CQI", pvalue->nRB_CQI);

   rtxPrintIndent ();
   rtxPrintUnsigned ("nCS_AN", pvalue->nCS_AN);

   rtxPrintIndent ();
   rtxPrintUnsigned ("n1PUCCH_AN", pvalue->n1PUCCH_AN);

   rtxPrintCloseBrace ();
}

void asn1Print_SoundingRS_UL_ConfigCommon_setup 
   (const char* name, const SoundingRS_UL_ConfigCommon_setup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig (
      "srs_BandwidthConfig", &pvalue->srs_BandwidthConfig);

   asn1Print_SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig (
      "srs_SubframeConfig", &pvalue->srs_SubframeConfig);

   rtxPrintIndent ();
   rtxPrintBoolean ("ackNackSRS_SimultaneousTransmission", pvalue->ackNackSRS_SimultaneousTransmission);

   if (pvalue->m.srs_MaxUpPtsPresent) {
      asn1Print_SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts ("srs_MaxUpPts", 
         &pvalue->srs_MaxUpPts);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SoundingRS_UL_ConfigCommon 
   (const char* name, const SoundingRS_UL_ConfigCommon* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_SoundingRS_UL_ConfigCommon_setup ("setup", pvalue->u.setup
            );
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_DeltaFList_PUCCH 
   (const char* name, const DeltaFList_PUCCH* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_DeltaFList_PUCCH_deltaF_PUCCH_Format1 ("deltaF_PUCCH_Format1", &
      pvalue->deltaF_PUCCH_Format1);

   asn1Print_DeltaFList_PUCCH_deltaF_PUCCH_Format1b ("deltaF_PUCCH_Format1b", &
      pvalue->deltaF_PUCCH_Format1b);

   asn1Print_DeltaFList_PUCCH_deltaF_PUCCH_Format2 ("deltaF_PUCCH_Format2", &
      pvalue->deltaF_PUCCH_Format2);

   asn1Print_DeltaFList_PUCCH_deltaF_PUCCH_Format2a ("deltaF_PUCCH_Format2a", &
      pvalue->deltaF_PUCCH_Format2a);

   asn1Print_DeltaFList_PUCCH_deltaF_PUCCH_Format2b ("deltaF_PUCCH_Format2b", &
      pvalue->deltaF_PUCCH_Format2b);

   rtxPrintCloseBrace ();
}

void asn1Print_UplinkPowerControlCommon 
   (const char* name, const UplinkPowerControlCommon* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintInteger ("p0_NominalPUSCH", pvalue->p0_NominalPUSCH);

   asn1Print_UplinkPowerControlCommon_alpha ("alpha", &pvalue->alpha);

   rtxPrintIndent ();
   rtxPrintInteger ("p0_NominalPUCCH", pvalue->p0_NominalPUCCH);

   asn1Print_DeltaFList_PUCCH ("deltaFList_PUCCH", &pvalue->deltaFList_PUCCH);

   rtxPrintIndent ();
   rtxPrintInteger ("deltaPreambleMsg3", pvalue->deltaPreambleMsg3);

   rtxPrintCloseBrace ();
}

void asn1Print_RadioResourceConfigCommonSIB 
   (const char* name, const RadioResourceConfigCommonSIB* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RACH_ConfigCommon ("rach_ConfigCommon", &pvalue->rach_ConfigCommon
      );

   asn1Print_BCCH_Config ("bcch_Config", &pvalue->bcch_Config);

   asn1Print_PCCH_Config ("pcch_Config", &pvalue->pcch_Config);

   asn1Print_PRACH_ConfigSIB ("prach_Config", &pvalue->prach_Config);

   asn1Print_PDSCH_ConfigCommon ("pdsch_ConfigCommon", &pvalue->
      pdsch_ConfigCommon);

   asn1Print_PUSCH_ConfigCommon ("pusch_ConfigCommon", &pvalue->
      pusch_ConfigCommon);

   asn1Print_PUCCH_ConfigCommon ("pucch_ConfigCommon", &pvalue->
      pucch_ConfigCommon);

   asn1Print_SoundingRS_UL_ConfigCommon ("soundingRS_UL_ConfigCommon", &pvalue
      ->soundingRS_UL_ConfigCommon);

   asn1Print_UplinkPowerControlCommon ("uplinkPowerControlCommon", &pvalue->
      uplinkPowerControlCommon);

   asn1Print_UL_CyclicPrefixLength ("ul_CyclicPrefixLength", &pvalue->
      ul_CyclicPrefixLength);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_UE_TimersAndConstants 
   (const char* name, const UE_TimersAndConstants* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_UE_TimersAndConstants_t300 ("t300", &pvalue->t300);

   asn1Print_UE_TimersAndConstants_t301 ("t301", &pvalue->t301);

   asn1Print_UE_TimersAndConstants_t310 ("t310", &pvalue->t310);

   asn1Print_UE_TimersAndConstants_n310 ("n310", &pvalue->n310);

   asn1Print_UE_TimersAndConstants_t311 ("t311", &pvalue->t311);

   asn1Print_UE_TimersAndConstants_n311 ("n311", &pvalue->n311);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType2_freqInfo 
   (const char* name, const SystemInformationBlockType2_freqInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.ul_CarrierFreqPresent) {
      asn1Print_ARFCN_ValueEUTRA ("ul_CarrierFreq", &pvalue->ul_CarrierFreq);
   }

   if (pvalue->m.ul_BandwidthPresent) {
      asn1Print_SystemInformationBlockType2_freqInfo_ul_Bandwidth (
         "ul_Bandwidth", &pvalue->ul_Bandwidth);
   }

   asn1Print_AdditionalSpectrumEmission ("additionalSpectrumEmission", &pvalue
      ->additionalSpectrumEmission);

   rtxPrintCloseBrace ();
}

void asn1Print_MBSFN_SubframeConfig_subframeAllocation 
   (const char* name, const MBSFN_SubframeConfig_subframeAllocation* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* oneFrame */
      case 1:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("oneFrame", pvalue->u.oneFrame->numbits, pvalue->u.oneFrame->data);
         break;
      }
      /* fourFrames */
      case 2:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("fourFrames", pvalue->u.fourFrames->numbits, pvalue->u.fourFrames->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MBSFN_SubframeConfig 
   (const char* name, const MBSFN_SubframeConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MBSFN_SubframeConfig_radioframeAllocationPeriod (
      "radioframeAllocationPeriod", &pvalue->radioframeAllocationPeriod);

   rtxPrintIndent ();
   rtxPrintUnsigned ("radioframeAllocationOffset", pvalue->radioframeAllocationOffset);

   asn1Print_MBSFN_SubframeConfig_subframeAllocation ("subframeAllocation", &
      pvalue->subframeAllocation);

   rtxPrintCloseBrace ();
}

void asn1Print_MBSFN_SubframeConfigList 
   (const char* name, const MBSFN_SubframeConfigList* pvalue)
{
   MBSFN_SubframeConfig* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (MBSFN_SubframeConfig*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MBSFN_SubframeConfig (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_SystemInformationBlockType2 
   (const char* name, const SystemInformationBlockType2* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.ac_BarringInfoPresent) {
      asn1Print_SystemInformationBlockType2_ac_BarringInfo ("ac_BarringInfo", &
         pvalue->ac_BarringInfo);
   }

   asn1Print_RadioResourceConfigCommonSIB ("radioResourceConfigCommon", &pvalue
      ->radioResourceConfigCommon);

   asn1Print_UE_TimersAndConstants ("ue_TimersAndConstants", &pvalue->
      ue_TimersAndConstants);

   asn1Print_SystemInformationBlockType2_freqInfo ("freqInfo", &pvalue->
      freqInfo);

   if (pvalue->m.mbsfn_SubframeConfigListPresent) {
      asn1Print_MBSFN_SubframeConfigList ("mbsfn_SubframeConfigList", &pvalue->
         mbsfn_SubframeConfigList);
   }

   asn1Print_TimeAlignmentTimer ("timeAlignmentTimerCommon", &pvalue->
      timeAlignmentTimerCommon);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m._v3ExtPresent) {
      if (pvalue->m.ssac_BarringForMMTEL_Voice_r9Present) {
         asn1Print_AC_BarringConfig ("ssac_BarringForMMTEL_Voice_r9", &pvalue->
            ssac_BarringForMMTEL_Voice_r9);
      }
      if (pvalue->m.ssac_BarringForMMTEL_Video_r9Present) {
         asn1Print_AC_BarringConfig ("ssac_BarringForMMTEL_Video_r9", &pvalue->
            ssac_BarringForMMTEL_Video_r9);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_MobilityStateParameters 
   (const char* name, const MobilityStateParameters* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MobilityStateParameters_t_Evaluation ("t_Evaluation", &pvalue->
      t_Evaluation);

   asn1Print_MobilityStateParameters_t_HystNormal ("t_HystNormal", &pvalue->
      t_HystNormal);

   rtxPrintIndent ();
   rtxPrintUnsigned ("n_CellChangeMedium", pvalue->n_CellChangeMedium);

   rtxPrintIndent ();
   rtxPrintUnsigned ("n_CellChangeHigh", pvalue->n_CellChangeHigh);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF 
   (const char* name, const SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium (
      "sf_Medium", &pvalue->sf_Medium);

   asn1Print_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High (
      "sf_High", &pvalue->sf_High);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars 
   (const char* name, const SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MobilityStateParameters ("mobilityStateParameters", &pvalue->
      mobilityStateParameters);

   asn1Print_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF (
      "q_HystSF", &pvalue->q_HystSF);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType3_cellReselectionInfoCommon 
   (const char* name, const SystemInformationBlockType3_cellReselectionInfoCommon* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst (
      "q_Hyst", &pvalue->q_Hyst);

   if (pvalue->m.speedStateReselectionParsPresent) {
      asn1Print_SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars (
         "speedStateReselectionPars", &pvalue->speedStateReselectionPars);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType3_cellReselectionServingFreqInfo 
   (const char* name, const SystemInformationBlockType3_cellReselectionServingFreqInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.s_NonIntraSearchPresent) {
      asn1Print_ReselectionThreshold ("s_NonIntraSearch", &pvalue->
         s_NonIntraSearch);
   }

   asn1Print_ReselectionThreshold ("threshServingLow", &pvalue->
      threshServingLow);

   asn1Print_CellReselectionPriority ("cellReselectionPriority", &pvalue->
      cellReselectionPriority);

   rtxPrintCloseBrace ();
}

void asn1Print_SpeedStateScaleFactors 
   (const char* name, const SpeedStateScaleFactors* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SpeedStateScaleFactors_sf_Medium ("sf_Medium", &pvalue->sf_Medium
      );

   asn1Print_SpeedStateScaleFactors_sf_High ("sf_High", &pvalue->sf_High);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType3_intraFreqCellReselectionInfo 
   (const char* name, const SystemInformationBlockType3_intraFreqCellReselectionInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_Q_RxLevMin ("q_RxLevMin", &pvalue->q_RxLevMin);

   if (pvalue->m.p_MaxPresent) {
      asn1Print_P_Max ("p_Max", &pvalue->p_Max);
   }

   if (pvalue->m.s_IntraSearchPresent) {
      asn1Print_ReselectionThreshold ("s_IntraSearch", &pvalue->s_IntraSearch
         );
   }

   if (pvalue->m.allowedMeasBandwidthPresent) {
      asn1Print_AllowedMeasBandwidth ("allowedMeasBandwidth", &pvalue->
         allowedMeasBandwidth);
   }

   asn1Print_PresenceAntennaPort1 ("presenceAntennaPort1", &pvalue->
      presenceAntennaPort1);

   asn1Print_NeighCellConfig ("neighCellConfig", &pvalue->neighCellConfig);

   asn1Print_T_Reselection ("t_ReselectionEUTRA", &pvalue->t_ReselectionEUTRA
      );

   if (pvalue->m.t_ReselectionEUTRA_SFPresent) {
      asn1Print_SpeedStateScaleFactors ("t_ReselectionEUTRA_SF", &pvalue->
         t_ReselectionEUTRA_SF);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType3_s_IntraSearch_v920 
   (const char* name, const SystemInformationBlockType3_s_IntraSearch_v920* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ReselectionThreshold ("s_IntraSearchP_r9", &pvalue->
      s_IntraSearchP_r9);

   asn1Print_ReselectionThresholdQ_r9 ("s_IntraSearchQ_r9", &pvalue->
      s_IntraSearchQ_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType3_s_NonIntraSearch_v920 
   (const char* name, const SystemInformationBlockType3_s_NonIntraSearch_v920* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ReselectionThreshold ("s_NonIntraSearchP_r9", &pvalue->
      s_NonIntraSearchP_r9);

   asn1Print_ReselectionThresholdQ_r9 ("s_NonIntraSearchQ_r9", &pvalue->
      s_NonIntraSearchQ_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType3 
   (const char* name, const SystemInformationBlockType3* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SystemInformationBlockType3_cellReselectionInfoCommon (
      "cellReselectionInfoCommon", &pvalue->cellReselectionInfoCommon);

   asn1Print_SystemInformationBlockType3_cellReselectionServingFreqInfo (
      "cellReselectionServingFreqInfo", &pvalue->cellReselectionServingFreqInfo
      );

   asn1Print_SystemInformationBlockType3_intraFreqCellReselectionInfo (
      "intraFreqCellReselectionInfo", &pvalue->intraFreqCellReselectionInfo);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m._v3ExtPresent) {
      if (pvalue->m.s_IntraSearch_v920Present) {
         asn1Print_SystemInformationBlockType3_s_IntraSearch_v920 (
            "s_IntraSearch_v920", &pvalue->s_IntraSearch_v920);
      }
      if (pvalue->m.s_NonIntraSearch_v920Present) {
         asn1Print_SystemInformationBlockType3_s_NonIntraSearch_v920 (
            "s_NonIntraSearch_v920", &pvalue->s_NonIntraSearch_v920);
      }
      if (pvalue->m.q_QualMin_r9Present) {
         asn1Print_Q_QualMin_r9 ("q_QualMin_r9", &pvalue->q_QualMin_r9);
      }
      if (pvalue->m.threshServingLowQ_r9Present) {
         asn1Print_ReselectionThresholdQ_r9 ("threshServingLowQ_r9", &pvalue->
            threshServingLowQ_r9);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_IntraFreqNeighCellInfo 
   (const char* name, const IntraFreqNeighCellInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PhysCellId ("physCellId", &pvalue->physCellId);

   asn1Print_Q_OffsetRange ("q_OffsetCell", &pvalue->q_OffsetCell);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_IntraFreqNeighCellList 
   (const char* name, const IntraFreqNeighCellList* pvalue)
{
   IntraFreqNeighCellInfo* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (IntraFreqNeighCellInfo*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_IntraFreqNeighCellInfo (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_PhysCellIdRange 
   (const char* name, const PhysCellIdRange* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PhysCellId ("start", &pvalue->start);

   if (pvalue->m.rangePresent) {
      asn1Print_PhysCellIdRange_range ("range", &pvalue->range);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_IntraFreqBlackCellList 
   (const char* name, const IntraFreqBlackCellList* pvalue)
{
   PhysCellIdRange* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (PhysCellIdRange*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_PhysCellIdRange (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_SystemInformationBlockType4 
   (const char* name, const SystemInformationBlockType4* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.intraFreqNeighCellListPresent) {
      asn1Print_IntraFreqNeighCellList ("intraFreqNeighCellList", &pvalue->
         intraFreqNeighCellList);
   }

   if (pvalue->m.intraFreqBlackCellListPresent) {
      asn1Print_IntraFreqBlackCellList ("intraFreqBlackCellList", &pvalue->
         intraFreqBlackCellList);
   }

   if (pvalue->m.csg_PhysCellIdRangePresent) {
      asn1Print_PhysCellIdRange ("csg_PhysCellIdRange", &pvalue->
         csg_PhysCellIdRange);
   }

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_InterFreqNeighCellInfo 
   (const char* name, const InterFreqNeighCellInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PhysCellId ("physCellId", &pvalue->physCellId);

   asn1Print_Q_OffsetRange ("q_OffsetCell", &pvalue->q_OffsetCell);

   rtxPrintCloseBrace ();
}

void asn1Print_InterFreqNeighCellList 
   (const char* name, const InterFreqNeighCellList* pvalue)
{
   InterFreqNeighCellInfo* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (InterFreqNeighCellInfo*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_InterFreqNeighCellInfo (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_InterFreqBlackCellList 
   (const char* name, const InterFreqBlackCellList* pvalue)
{
   PhysCellIdRange* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (PhysCellIdRange*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_PhysCellIdRange (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_InterFreqCarrierFreqInfo_threshX_Q_r9 
   (const char* name, const InterFreqCarrierFreqInfo_threshX_Q_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ReselectionThresholdQ_r9 ("threshX_HighQ_r9", &pvalue->
      threshX_HighQ_r9);

   asn1Print_ReselectionThresholdQ_r9 ("threshX_LowQ_r9", &pvalue->
      threshX_LowQ_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_InterFreqCarrierFreqInfo 
   (const char* name, const InterFreqCarrierFreqInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ARFCN_ValueEUTRA ("dl_CarrierFreq", &pvalue->dl_CarrierFreq);

   asn1Print_Q_RxLevMin ("q_RxLevMin", &pvalue->q_RxLevMin);

   if (pvalue->m.p_MaxPresent) {
      asn1Print_P_Max ("p_Max", &pvalue->p_Max);
   }

   asn1Print_T_Reselection ("t_ReselectionEUTRA", &pvalue->t_ReselectionEUTRA
      );

   if (pvalue->m.t_ReselectionEUTRA_SFPresent) {
      asn1Print_SpeedStateScaleFactors ("t_ReselectionEUTRA_SF", &pvalue->
         t_ReselectionEUTRA_SF);
   }

   asn1Print_ReselectionThreshold ("threshX_High", &pvalue->threshX_High);

   asn1Print_ReselectionThreshold ("threshX_Low", &pvalue->threshX_Low);

   asn1Print_AllowedMeasBandwidth ("allowedMeasBandwidth", &pvalue->
      allowedMeasBandwidth);

   asn1Print_PresenceAntennaPort1 ("presenceAntennaPort1", &pvalue->
      presenceAntennaPort1);

   if (pvalue->m.cellReselectionPriorityPresent) {
      asn1Print_CellReselectionPriority ("cellReselectionPriority", &pvalue->
         cellReselectionPriority);
   }

   asn1Print_NeighCellConfig ("neighCellConfig", &pvalue->neighCellConfig);

   asn1Print_Q_OffsetRange ("q_OffsetFreq", &pvalue->q_OffsetFreq);

   if (pvalue->m.interFreqNeighCellListPresent) {
      asn1Print_InterFreqNeighCellList ("interFreqNeighCellList", &pvalue->
         interFreqNeighCellList);
   }

   if (pvalue->m.interFreqBlackCellListPresent) {
      asn1Print_InterFreqBlackCellList ("interFreqBlackCellList", &pvalue->
         interFreqBlackCellList);
   }

   if (pvalue->m._v2ExtPresent) {
      if (pvalue->m.q_QualMin_r9Present) {
         asn1Print_Q_QualMin_r9 ("q_QualMin_r9", &pvalue->q_QualMin_r9);
      }
      if (pvalue->m.threshX_Q_r9Present) {
         asn1Print_InterFreqCarrierFreqInfo_threshX_Q_r9 ("threshX_Q_r9", &
            pvalue->threshX_Q_r9);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_InterFreqCarrierFreqList 
   (const char* name, const InterFreqCarrierFreqList* pvalue)
{
   InterFreqCarrierFreqInfo* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (InterFreqCarrierFreqInfo*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_InterFreqCarrierFreqInfo (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_SystemInformationBlockType5 
   (const char* name, const SystemInformationBlockType5* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_InterFreqCarrierFreqList ("interFreqCarrierFreqList", &pvalue->
      interFreqCarrierFreqList);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_CarrierFreqUTRA_FDD_threshX_Q_r9 
   (const char* name, const CarrierFreqUTRA_FDD_threshX_Q_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ReselectionThresholdQ_r9 ("threshX_HighQ_r9", &pvalue->
      threshX_HighQ_r9);

   asn1Print_ReselectionThresholdQ_r9 ("threshX_LowQ_r9", &pvalue->
      threshX_LowQ_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_CarrierFreqUTRA_FDD 
   (const char* name, const CarrierFreqUTRA_FDD* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ARFCN_ValueUTRA ("carrierFreq", &pvalue->carrierFreq);

   if (pvalue->m.cellReselectionPriorityPresent) {
      asn1Print_CellReselectionPriority ("cellReselectionPriority", &pvalue->
         cellReselectionPriority);
   }

   asn1Print_ReselectionThreshold ("threshX_High", &pvalue->threshX_High);

   asn1Print_ReselectionThreshold ("threshX_Low", &pvalue->threshX_Low);

   rtxPrintIndent ();
   rtxPrintInteger ("q_RxLevMin", pvalue->q_RxLevMin);

   rtxPrintIndent ();
   rtxPrintInteger ("p_MaxUTRA", pvalue->p_MaxUTRA);

   rtxPrintIndent ();
   rtxPrintInteger ("q_QualMin", pvalue->q_QualMin);

   if (pvalue->m._v2ExtPresent) {
      if (pvalue->m.threshX_Q_r9Present) {
         asn1Print_CarrierFreqUTRA_FDD_threshX_Q_r9 ("threshX_Q_r9", &pvalue->
            threshX_Q_r9);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_CarrierFreqListUTRA_FDD 
   (const char* name, const CarrierFreqListUTRA_FDD* pvalue)
{
   CarrierFreqUTRA_FDD* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (CarrierFreqUTRA_FDD*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_CarrierFreqUTRA_FDD (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_CarrierFreqUTRA_TDD 
   (const char* name, const CarrierFreqUTRA_TDD* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ARFCN_ValueUTRA ("carrierFreq", &pvalue->carrierFreq);

   if (pvalue->m.cellReselectionPriorityPresent) {
      asn1Print_CellReselectionPriority ("cellReselectionPriority", &pvalue->
         cellReselectionPriority);
   }

   asn1Print_ReselectionThreshold ("threshX_High", &pvalue->threshX_High);

   asn1Print_ReselectionThreshold ("threshX_Low", &pvalue->threshX_Low);

   rtxPrintIndent ();
   rtxPrintInteger ("q_RxLevMin", pvalue->q_RxLevMin);

   rtxPrintIndent ();
   rtxPrintInteger ("p_MaxUTRA", pvalue->p_MaxUTRA);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_CarrierFreqListUTRA_TDD 
   (const char* name, const CarrierFreqListUTRA_TDD* pvalue)
{
   CarrierFreqUTRA_TDD* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (CarrierFreqUTRA_TDD*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_CarrierFreqUTRA_TDD (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_SystemInformationBlockType6 
   (const char* name, const SystemInformationBlockType6* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.carrierFreqListUTRA_FDDPresent) {
      asn1Print_CarrierFreqListUTRA_FDD ("carrierFreqListUTRA_FDD", &pvalue->
         carrierFreqListUTRA_FDD);
   }

   if (pvalue->m.carrierFreqListUTRA_TDDPresent) {
      asn1Print_CarrierFreqListUTRA_TDD ("carrierFreqListUTRA_TDD", &pvalue->
         carrierFreqListUTRA_TDD);
   }

   asn1Print_T_Reselection ("t_ReselectionUTRA", &pvalue->t_ReselectionUTRA);

   if (pvalue->m.t_ReselectionUTRA_SFPresent) {
      asn1Print_SpeedStateScaleFactors ("t_ReselectionUTRA_SF", &pvalue->
         t_ReselectionUTRA_SF);
   }

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ExplicitListOfARFCNs 
   (const char* name, const ExplicitListOfARFCNs* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ARFCN_ValueGERAN (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs 
   (const char* name, const CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("arfcn_Spacing", pvalue->arfcn_Spacing);

   rtxPrintIndent ();
   rtxPrintUnsigned ("numberOfFollowingARFCNs", pvalue->numberOfFollowingARFCNs);

   rtxPrintCloseBrace ();
}

void asn1Print_CarrierFreqsGERAN_followingARFCNs 
   (const char* name, const CarrierFreqsGERAN_followingARFCNs* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* explicitListOfARFCNs */
      case 1:
      {
         asn1Print_ExplicitListOfARFCNs ("explicitListOfARFCNs", pvalue->
            u.explicitListOfARFCNs);
         break;
      }
      /* equallySpacedARFCNs */
      case 2:
      {
         asn1Print_CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs (
            "equallySpacedARFCNs", pvalue->u.equallySpacedARFCNs);
         break;
      }
      /* variableBitMapOfARFCNs */
      case 3:
      {
         asn1Print_CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs (
            "variableBitMapOfARFCNs", pvalue->u.variableBitMapOfARFCNs);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CarrierFreqsGERAN 
   (const char* name, const CarrierFreqsGERAN* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ARFCN_ValueGERAN ("startingARFCN", &pvalue->startingARFCN);

   asn1Print_BandIndicatorGERAN ("bandIndicator", &pvalue->bandIndicator);

   asn1Print_CarrierFreqsGERAN_followingARFCNs ("followingARFCNs", &pvalue->
      followingARFCNs);

   rtxPrintCloseBrace ();
}

void asn1Print_CarrierFreqsInfoGERAN_commonInfo 
   (const char* name, const CarrierFreqsInfoGERAN_commonInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.cellReselectionPriorityPresent) {
      asn1Print_CellReselectionPriority ("cellReselectionPriority", &pvalue->
         cellReselectionPriority);
   }

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("ncc_Permitted", pvalue->ncc_Permitted.numbits, pvalue->ncc_Permitted.data);

   rtxPrintIndent ();
   rtxPrintUnsigned ("q_RxLevMin", pvalue->q_RxLevMin);

   if (pvalue->m.p_MaxGERANPresent) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("p_MaxGERAN", pvalue->p_MaxGERAN);
   }

   asn1Print_ReselectionThreshold ("threshX_High", &pvalue->threshX_High);

   asn1Print_ReselectionThreshold ("threshX_Low", &pvalue->threshX_Low);

   rtxPrintCloseBrace ();
}

void asn1Print_CarrierFreqsInfoGERAN 
   (const char* name, const CarrierFreqsInfoGERAN* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CarrierFreqsGERAN ("carrierFreqs", &pvalue->carrierFreqs);

   asn1Print_CarrierFreqsInfoGERAN_commonInfo ("commonInfo", &pvalue->
      commonInfo);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_CarrierFreqsInfoListGERAN 
   (const char* name, const CarrierFreqsInfoListGERAN* pvalue)
{
   CarrierFreqsInfoGERAN* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (CarrierFreqsInfoGERAN*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_CarrierFreqsInfoGERAN (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_SystemInformationBlockType7 
   (const char* name, const SystemInformationBlockType7* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_T_Reselection ("t_ReselectionGERAN", &pvalue->t_ReselectionGERAN
      );

   if (pvalue->m.t_ReselectionGERAN_SFPresent) {
      asn1Print_SpeedStateScaleFactors ("t_ReselectionGERAN_SF", &pvalue->
         t_ReselectionGERAN_SF);
   }

   if (pvalue->m.carrierFreqsInfoListPresent) {
      asn1Print_CarrierFreqsInfoListGERAN ("carrierFreqsInfoList", &pvalue->
         carrierFreqsInfoList);
   }

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemTimeInfoCDMA2000_cdma_SystemTime 
   (const char* name, const SystemTimeInfoCDMA2000_cdma_SystemTime* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* synchronousSystemTime */
      case 1:
      {
         asn1Print_SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime (
            "synchronousSystemTime", pvalue->u.synchronousSystemTime);
         break;
      }
      /* asynchronousSystemTime */
      case 2:
      {
         asn1Print_SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime (
            "asynchronousSystemTime", pvalue->u.asynchronousSystemTime);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SystemTimeInfoCDMA2000 
   (const char* name, const SystemTimeInfoCDMA2000* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("cdma_EUTRA_Synchronisation", pvalue->cdma_EUTRA_Synchronisation);

   asn1Print_SystemTimeInfoCDMA2000_cdma_SystemTime ("cdma_SystemTime", &pvalue
      ->cdma_SystemTime);

   rtxPrintCloseBrace ();
}

void asn1Print_SecondaryPreRegistrationZoneIdListHRPD 
   (const char* name, const SecondaryPreRegistrationZoneIdListHRPD* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_PreRegistrationZoneIdHRPD (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_PreRegistrationInfoHRPD 
   (const char* name, const PreRegistrationInfoHRPD* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("preRegistrationAllowed", pvalue->preRegistrationAllowed);

   if (pvalue->m.preRegistrationZoneIdPresent) {
      asn1Print_PreRegistrationZoneIdHRPD ("preRegistrationZoneId", &pvalue->
         preRegistrationZoneId);
   }

   if (pvalue->m.secondaryPreRegistrationZoneIdListPresent) {
      asn1Print_SecondaryPreRegistrationZoneIdListHRPD (
         "secondaryPreRegistrationZoneIdList", &pvalue->
         secondaryPreRegistrationZoneIdList);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_BandClassInfoCDMA2000 
   (const char* name, const BandClassInfoCDMA2000* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_BandclassCDMA2000 ("bandClass", &pvalue->bandClass);

   if (pvalue->m.cellReselectionPriorityPresent) {
      asn1Print_CellReselectionPriority ("cellReselectionPriority", &pvalue->
         cellReselectionPriority);
   }

   rtxPrintIndent ();
   rtxPrintUnsigned ("threshX_High", pvalue->threshX_High);

   rtxPrintIndent ();
   rtxPrintUnsigned ("threshX_Low", pvalue->threshX_Low);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_BandClassListCDMA2000 
   (const char* name, const BandClassListCDMA2000* pvalue)
{
   BandClassInfoCDMA2000* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (BandClassInfoCDMA2000*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_BandClassInfoCDMA2000 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_PhysCellIdListCDMA2000 
   (const char* name, const PhysCellIdListCDMA2000* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_PhysCellIdCDMA2000 (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_NeighCellsPerBandclassCDMA2000 
   (const char* name, const NeighCellsPerBandclassCDMA2000* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ARFCN_ValueCDMA2000 ("arfcn", &pvalue->arfcn);

   asn1Print_PhysCellIdListCDMA2000 ("physCellIdList", &pvalue->physCellIdList
      );

   rtxPrintCloseBrace ();
}

void asn1Print_NeighCellsPerBandclassListCDMA2000 
   (const char* name, const NeighCellsPerBandclassListCDMA2000* pvalue)
{
   NeighCellsPerBandclassCDMA2000* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (NeighCellsPerBandclassCDMA2000*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_NeighCellsPerBandclassCDMA2000 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_NeighCellCDMA2000 
   (const char* name, const NeighCellCDMA2000* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_BandclassCDMA2000 ("bandClass", &pvalue->bandClass);

   asn1Print_NeighCellsPerBandclassListCDMA2000 ("neighCellsPerFreqList", &
      pvalue->neighCellsPerFreqList);

   rtxPrintCloseBrace ();
}

void asn1Print_NeighCellListCDMA2000 
   (const char* name, const NeighCellListCDMA2000* pvalue)
{
   NeighCellCDMA2000* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (NeighCellCDMA2000*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_NeighCellCDMA2000 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_CellReselectionParametersCDMA2000 
   (const char* name, const CellReselectionParametersCDMA2000* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_BandClassListCDMA2000 ("bandClassList", &pvalue->bandClassList);

   asn1Print_NeighCellListCDMA2000 ("neighCellList", &pvalue->neighCellList);

   asn1Print_T_Reselection ("t_ReselectionCDMA2000", &pvalue->
      t_ReselectionCDMA2000);

   if (pvalue->m.t_ReselectionCDMA2000_SFPresent) {
      asn1Print_SpeedStateScaleFactors ("t_ReselectionCDMA2000_SF", &pvalue->
         t_ReselectionCDMA2000_SF);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType8_parametersHRPD 
   (const char* name, const SystemInformationBlockType8_parametersHRPD* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PreRegistrationInfoHRPD ("preRegistrationInfoHRPD", &pvalue->
      preRegistrationInfoHRPD);

   if (pvalue->m.cellReselectionParametersHRPDPresent) {
      asn1Print_CellReselectionParametersCDMA2000 (
         "cellReselectionParametersHRPD", &pvalue->
         cellReselectionParametersHRPD);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CSFB_RegistrationParam1XRTT 
   (const char* name, const CSFB_RegistrationParam1XRTT* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("sid", pvalue->sid.numbits, pvalue->sid.data);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("nid", pvalue->nid.numbits, pvalue->nid.data);

   rtxPrintIndent ();
   rtxPrintBoolean ("multipleSID", pvalue->multipleSID);

   rtxPrintIndent ();
   rtxPrintBoolean ("multipleNID", pvalue->multipleNID);

   rtxPrintIndent ();
   rtxPrintBoolean ("homeReg", pvalue->homeReg);

   rtxPrintIndent ();
   rtxPrintBoolean ("foreignSIDReg", pvalue->foreignSIDReg);

   rtxPrintIndent ();
   rtxPrintBoolean ("foreignNIDReg", pvalue->foreignNIDReg);

   rtxPrintIndent ();
   rtxPrintBoolean ("parameterReg", pvalue->parameterReg);

   rtxPrintIndent ();
   rtxPrintBoolean ("powerUpReg", pvalue->powerUpReg);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("registrationPeriod", pvalue->registrationPeriod.numbits, pvalue->registrationPeriod.data);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("registrationZone", pvalue->registrationZone.numbits, pvalue->registrationZone.data);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("totalZone", pvalue->totalZone.numbits, pvalue->totalZone.data);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("zoneTimer", pvalue->zoneTimer.numbits, pvalue->zoneTimer.data);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType8_parameters1XRTT 
   (const char* name, const SystemInformationBlockType8_parameters1XRTT* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.csfb_RegistrationParam1XRTTPresent) {
      asn1Print_CSFB_RegistrationParam1XRTT ("csfb_RegistrationParam1XRTT", &
         pvalue->csfb_RegistrationParam1XRTT);
   }

   if (pvalue->m.longCodeState1XRTTPresent) {
      asn1Print_SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT (
         "longCodeState1XRTT", &pvalue->longCodeState1XRTT);
   }

   if (pvalue->m.cellReselectionParameters1XRTTPresent) {
      asn1Print_CellReselectionParametersCDMA2000 (
         "cellReselectionParameters1XRTT", &pvalue->
         cellReselectionParameters1XRTT);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PhysCellIdListCDMA2000_v920 
   (const char* name, const PhysCellIdListCDMA2000_v920* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_PhysCellIdCDMA2000 (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_NeighCellsPerBandclassCDMA2000_v920 
   (const char* name, const NeighCellsPerBandclassCDMA2000_v920* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PhysCellIdListCDMA2000_v920 ("physCellIdList_v920", &pvalue->
      physCellIdList_v920);

   rtxPrintCloseBrace ();
}

void asn1Print_NeighCellsPerBandclassListCDMA2000_v920 
   (const char* name, const NeighCellsPerBandclassListCDMA2000_v920* pvalue)
{
   NeighCellsPerBandclassCDMA2000_v920* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (NeighCellsPerBandclassCDMA2000_v920*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_NeighCellsPerBandclassCDMA2000_v920 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_NeighCellCDMA2000_v920 
   (const char* name, const NeighCellCDMA2000_v920* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_NeighCellsPerBandclassListCDMA2000_v920 (
      "neighCellsPerFreqList_v920", &pvalue->neighCellsPerFreqList_v920);

   rtxPrintCloseBrace ();
}

void asn1Print_NeighCellListCDMA2000_v920 
   (const char* name, const NeighCellListCDMA2000_v920* pvalue)
{
   NeighCellCDMA2000_v920* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (NeighCellCDMA2000_v920*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_NeighCellCDMA2000_v920 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_CellReselectionParametersCDMA2000_v920 
   (const char* name, const CellReselectionParametersCDMA2000_v920* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_NeighCellListCDMA2000_v920 ("neighCellList_v920", &pvalue->
      neighCellList_v920);

   rtxPrintCloseBrace ();
}

void asn1Print_CSFB_RegistrationParam1XRTT_v920 
   (const char* name, const CSFB_RegistrationParam1XRTT_v920* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9 (
      "powerDownReg_r9", &pvalue->powerDownReg_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_AC_BarringConfig1XRTT_r9 
   (const char* name, const AC_BarringConfig1XRTT_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ac_Barring0to9_r9", pvalue->ac_Barring0to9_r9);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ac_Barring10_r9", pvalue->ac_Barring10_r9);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ac_Barring11_r9", pvalue->ac_Barring11_r9);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ac_Barring12_r9", pvalue->ac_Barring12_r9);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ac_Barring13_r9", pvalue->ac_Barring13_r9);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ac_Barring14_r9", pvalue->ac_Barring14_r9);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ac_Barring15_r9", pvalue->ac_Barring15_r9);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ac_BarringMsg_r9", pvalue->ac_BarringMsg_r9);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ac_BarringReg_r9", pvalue->ac_BarringReg_r9);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ac_BarringEmg_r9", pvalue->ac_BarringEmg_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType8 
   (const char* name, const SystemInformationBlockType8* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.systemTimeInfoPresent) {
      asn1Print_SystemTimeInfoCDMA2000 ("systemTimeInfo", &pvalue->
         systemTimeInfo);
   }

   if (pvalue->m.searchWindowSizePresent) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("searchWindowSize", pvalue->searchWindowSize);
   }

   if (pvalue->m.parametersHRPDPresent) {
      asn1Print_SystemInformationBlockType8_parametersHRPD ("parametersHRPD", &
         pvalue->parametersHRPD);
   }

   if (pvalue->m.parameters1XRTTPresent) {
      asn1Print_SystemInformationBlockType8_parameters1XRTT (
         "parameters1XRTT", &pvalue->parameters1XRTT);
   }

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m._v3ExtPresent) {
      if (pvalue->m.csfb_SupportForDualRxUEs_r9Present) {
         rtxPrintIndent ();
         rtxPrintBoolean ("csfb_SupportForDualRxUEs_r9", pvalue->csfb_SupportForDualRxUEs_r9);
      }
      if (pvalue->m.cellReselectionParametersHRPD_v920Present) {
         asn1Print_CellReselectionParametersCDMA2000_v920 (
            "cellReselectionParametersHRPD_v920", &pvalue->
            cellReselectionParametersHRPD_v920);
      }
      if (pvalue->m.cellReselectionParameters1XRTT_v920Present) {
         asn1Print_CellReselectionParametersCDMA2000_v920 (
            "cellReselectionParameters1XRTT_v920", &pvalue->
            cellReselectionParameters1XRTT_v920);
      }
      if (pvalue->m.csfb_RegistrationParam1XRTT_v920Present) {
         asn1Print_CSFB_RegistrationParam1XRTT_v920 (
            "csfb_RegistrationParam1XRTT_v920", &pvalue->
            csfb_RegistrationParam1XRTT_v920);
      }
      if (pvalue->m.ac_BarringConfig1XRTT_r9Present) {
         asn1Print_AC_BarringConfig1XRTT_r9 ("ac_BarringConfig1XRTT_r9", &
            pvalue->ac_BarringConfig1XRTT_r9);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType9 
   (const char* name, const SystemInformationBlockType9* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.hnb_NamePresent) {
      asn1Print_SystemInformationBlockType9_hnb_Name ("hnb_Name", &pvalue->
         hnb_Name);
   }

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType10 
   (const char* name, const SystemInformationBlockType10* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("messageIdentifier", pvalue->messageIdentifier.numbits, pvalue->messageIdentifier.data);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("serialNumber", pvalue->serialNumber.numbits, pvalue->serialNumber.data);

   asn1Print_SystemInformationBlockType10_warningType ("warningType", &pvalue->
      warningType);

   if (pvalue->m.warningSecurityInfoPresent) {
      asn1Print_SystemInformationBlockType10_warningSecurityInfo (
         "warningSecurityInfo", &pvalue->warningSecurityInfo);
   }

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType11 
   (const char* name, const SystemInformationBlockType11* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("messageIdentifier", pvalue->messageIdentifier.numbits, pvalue->messageIdentifier.data);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("serialNumber", pvalue->serialNumber.numbits, pvalue->serialNumber.data);

   asn1Print_SystemInformationBlockType11_warningMessageSegmentType (
      "warningMessageSegmentType", &pvalue->warningMessageSegmentType);

   rtxPrintIndent ();
   rtxPrintUnsigned ("warningMessageSegmentNumber", pvalue->warningMessageSegmentNumber);

   rtxPrintIndent ();
   rtxPrintHexStr ("warningMessageSegment", pvalue->warningMessageSegment.numocts, pvalue->warningMessageSegment.data);

   if (pvalue->m.dataCodingSchemePresent) {
      asn1Print_SystemInformationBlockType11_dataCodingScheme (
         "dataCodingScheme", &pvalue->dataCodingScheme);
   }

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType12_r9 
   (const char* name, const SystemInformationBlockType12_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("messageIdentifier_r9", pvalue->messageIdentifier_r9.numbits, pvalue->messageIdentifier_r9.data);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("serialNumber_r9", pvalue->serialNumber_r9.numbits, pvalue->serialNumber_r9.data);

   asn1Print_SystemInformationBlockType12_r9_warningMessageSegmentType_r9 (
      "warningMessageSegmentType_r9", &pvalue->warningMessageSegmentType_r9);

   rtxPrintIndent ();
   rtxPrintUnsigned ("warningMessageSegmentNumber_r9", pvalue->warningMessageSegmentNumber_r9);

   rtxPrintIndent ();
   rtxPrintHexStr ("warningMessageSegment_r9", pvalue->warningMessageSegment_r9.numocts, pvalue->warningMessageSegment_r9.data);

   if (pvalue->m.dataCodingScheme_r9Present) {
      asn1Print_SystemInformationBlockType12_r9_dataCodingScheme_r9 (
         "dataCodingScheme_r9", &pvalue->dataCodingScheme_r9);
   }

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_MBMS_NotificationConfig_r9 
   (const char* name, const MBMS_NotificationConfig_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9 (
      "notificationRepetitionCoeff_r9", &pvalue->notificationRepetitionCoeff_r9
      );

   rtxPrintIndent ();
   rtxPrintUnsigned ("notificationOffset_r9", pvalue->notificationOffset_r9);

   rtxPrintIndent ();
   rtxPrintUnsigned ("notificationSF_Index_r9", pvalue->notificationSF_Index_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType13_r9 
   (const char* name, const SystemInformationBlockType13_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MBMS_NotificationConfig_r9 ("notificationConfig_r9", &pvalue->
      notificationConfig_r9);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformation_r8_IEs_sib_TypeAndInfo_element 
   (const char* name, const SystemInformation_r8_IEs_sib_TypeAndInfo_element* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* sib2 */
      case 1:
      {
         asn1Print_SystemInformationBlockType2 ("sib2", pvalue->u.sib2);
         break;
      }
      /* sib3 */
      case 2:
      {
         asn1Print_SystemInformationBlockType3 ("sib3", pvalue->u.sib3);
         break;
      }
      /* sib4 */
      case 3:
      {
         asn1Print_SystemInformationBlockType4 ("sib4", pvalue->u.sib4);
         break;
      }
      /* sib5 */
      case 4:
      {
         asn1Print_SystemInformationBlockType5 ("sib5", pvalue->u.sib5);
         break;
      }
      /* sib6 */
      case 5:
      {
         asn1Print_SystemInformationBlockType6 ("sib6", pvalue->u.sib6);
         break;
      }
      /* sib7 */
      case 6:
      {
         asn1Print_SystemInformationBlockType7 ("sib7", pvalue->u.sib7);
         break;
      }
      /* sib8 */
      case 7:
      {
         asn1Print_SystemInformationBlockType8 ("sib8", pvalue->u.sib8);
         break;
      }
      /* sib9 */
      case 8:
      {
         asn1Print_SystemInformationBlockType9 ("sib9", pvalue->u.sib9);
         break;
      }
      /* sib10 */
      case 9:
      {
         asn1Print_SystemInformationBlockType10 ("sib10", pvalue->u.sib10);
         break;
      }
      /* sib11 */
      case 10:
      {
         asn1Print_SystemInformationBlockType11 ("sib11", pvalue->u.sib11);
         break;
      }
      /* sib12-v920 */
      case 11:
      {
         asn1Print_SystemInformationBlockType12_r9 ("sib12-v920", pvalue->
            u.sib12_v920);
         break;
      }
      /* sib13-v920 */
      case 12:
      {
         asn1Print_SystemInformationBlockType13_r9 ("sib13-v920", pvalue->
            u.sib13_v920);
         break;
      }
      /* extElem1 */
      case 13:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformation_r8_IEs_sib_TypeAndInfo 
   (const char* name, const SystemInformation_r8_IEs_sib_TypeAndInfo* pvalue)
{
   SystemInformation_r8_IEs_sib_TypeAndInfo_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (SystemInformation_r8_IEs_sib_TypeAndInfo_element*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_SystemInformation_r8_IEs_sib_TypeAndInfo_element (namebuf, 
         pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_SystemInformation_v8a0_IEs_nonCriticalExtension 
   (const char* name, const SystemInformation_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_SystemInformation_v8a0_IEs 
   (const char* name, const SystemInformation_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_SystemInformation_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformation_r8_IEs 
   (const char* name, const SystemInformation_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SystemInformation_r8_IEs_sib_TypeAndInfo ("sib_TypeAndInfo", &
      pvalue->sib_TypeAndInfo);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_SystemInformation_v8a0_IEs ("nonCriticalExtension", &pvalue->
         nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformation_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const SystemInformation_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_SystemInformation_criticalExtensions 
   (const char* name, const SystemInformation_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* systemInformation-r8 */
      case 1:
      {
         asn1Print_SystemInformation_r8_IEs ("systemInformation-r8", pvalue->
            u.systemInformation_r8);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_SystemInformation_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformation 
   (const char* name, const SystemInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SystemInformation_criticalExtensions ("criticalExtensions", &
      pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_MCC (const char* name, const MCC* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MCC_MNC_Digit (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_MNC (const char* name, const MNC* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MCC_MNC_Digit (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_PLMN_Identity (const char* name, const PLMN_Identity* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.mccPresent) {
      asn1Print_MCC ("mcc", &pvalue->mcc);
   }

   asn1Print_MNC ("mnc", &pvalue->mnc);

   rtxPrintCloseBrace ();
}

void asn1Print_PLMN_IdentityInfo 
   (const char* name, const PLMN_IdentityInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PLMN_Identity ("plmn_Identity", &pvalue->plmn_Identity);

   asn1Print_PLMN_IdentityInfo_cellReservedForOperatorUse (
      "cellReservedForOperatorUse", &pvalue->cellReservedForOperatorUse);

   rtxPrintCloseBrace ();
}

void asn1Print_PLMN_IdentityList 
   (const char* name, const PLMN_IdentityList* pvalue)
{
   PLMN_IdentityInfo* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (PLMN_IdentityInfo*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_PLMN_IdentityInfo (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_SystemInformationBlockType1_cellAccessRelatedInfo 
   (const char* name, const SystemInformationBlockType1_cellAccessRelatedInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PLMN_IdentityList ("plmn_IdentityList", &pvalue->plmn_IdentityList
      );

   asn1Print_TrackingAreaCode ("trackingAreaCode", &pvalue->trackingAreaCode);

   asn1Print_CellIdentity ("cellIdentity", &pvalue->cellIdentity);

   asn1Print_SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred (
      "cellBarred", &pvalue->cellBarred);

   asn1Print_SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection (
      "intraFreqReselection", &pvalue->intraFreqReselection);

   rtxPrintIndent ();
   rtxPrintBoolean ("csg_Indication", pvalue->csg_Indication);

   if (pvalue->m.csg_IdentityPresent) {
      asn1Print_CSG_Identity ("csg_Identity", &pvalue->csg_Identity);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType1_cellSelectionInfo 
   (const char* name, const SystemInformationBlockType1_cellSelectionInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_Q_RxLevMin ("q_RxLevMin", &pvalue->q_RxLevMin);

   if (pvalue->m.q_RxLevMinOffsetPresent) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("q_RxLevMinOffset", pvalue->q_RxLevMinOffset);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SIB_MappingInfo 
   (const char* name, const SIB_MappingInfo* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_SIB_Type (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_SchedulingInfo (const char* name, const SchedulingInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SchedulingInfo_si_Periodicity ("si_Periodicity", &pvalue->
      si_Periodicity);

   asn1Print_SIB_MappingInfo ("sib_MappingInfo", &pvalue->sib_MappingInfo);

   rtxPrintCloseBrace ();
}

void asn1Print_SchedulingInfoList 
   (const char* name, const SchedulingInfoList* pvalue)
{
   SchedulingInfo* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (SchedulingInfo*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_SchedulingInfo (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_TDD_Config (const char* name, const TDD_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_TDD_Config_subframeAssignment ("subframeAssignment", &pvalue->
      subframeAssignment);

   asn1Print_TDD_Config_specialSubframePatterns ("specialSubframePatterns", &
      pvalue->specialSubframePatterns);

   rtxPrintCloseBrace ();
}

void asn1Print_CellSelectionInfo_v920 
   (const char* name, const CellSelectionInfo_v920* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_Q_QualMin_r9 ("q_QualMin_r9", &pvalue->q_QualMin_r9);

   if (pvalue->m.q_QualMinOffset_r9Present) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("q_QualMinOffset_r9", pvalue->q_QualMinOffset_r9);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType1_v920_IEs_nonCriticalExtension 
   (const char* name, const SystemInformationBlockType1_v920_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_SystemInformationBlockType1_v920_IEs 
   (const char* name, const SystemInformationBlockType1_v920_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.ims_EmergencySupport_r9Present) {
      asn1Print_SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9 (
         "ims_EmergencySupport_r9", &pvalue->ims_EmergencySupport_r9);
   }

   if (pvalue->m.cellSelectionInfo_v920Present) {
      asn1Print_CellSelectionInfo_v920 ("cellSelectionInfo_v920", &pvalue->
         cellSelectionInfo_v920);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_SystemInformationBlockType1_v920_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType1_v890_IEs 
   (const char* name, const SystemInformationBlockType1_v890_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_SystemInformationBlockType1_v920_IEs ("nonCriticalExtension", &
         pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInformationBlockType1 
   (const char* name, const SystemInformationBlockType1* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SystemInformationBlockType1_cellAccessRelatedInfo (
      "cellAccessRelatedInfo", &pvalue->cellAccessRelatedInfo);

   asn1Print_SystemInformationBlockType1_cellSelectionInfo (
      "cellSelectionInfo", &pvalue->cellSelectionInfo);

   if (pvalue->m.p_MaxPresent) {
      asn1Print_P_Max ("p_Max", &pvalue->p_Max);
   }

   rtxPrintIndent ();
   rtxPrintUnsigned ("freqBandIndicator", pvalue->freqBandIndicator);

   asn1Print_SchedulingInfoList ("schedulingInfoList", &pvalue->
      schedulingInfoList);

   if (pvalue->m.tdd_ConfigPresent) {
      asn1Print_TDD_Config ("tdd_Config", &pvalue->tdd_Config);
   }

   asn1Print_SystemInformationBlockType1_si_WindowLength ("si_WindowLength", &
      pvalue->si_WindowLength);

   rtxPrintIndent ();
   rtxPrintUnsigned ("systemInfoValueTag", pvalue->systemInfoValueTag);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_SystemInformationBlockType1_v890_IEs ("nonCriticalExtension", &
         pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_BCCH_DL_SCH_MessageType_c1 
   (const char* name, const BCCH_DL_SCH_MessageType_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* systemInformation */
      case 1:
      {
         asn1Print_SystemInformation ("systemInformation", pvalue->
            u.systemInformation);
         break;
      }
      /* systemInformationBlockType1 */
      case 2:
      {
         asn1Print_SystemInformationBlockType1 ("systemInformationBlockType1", 
            pvalue->u.systemInformationBlockType1);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_BCCH_DL_SCH_MessageType_messageClassExtension 
   (const char* name, const BCCH_DL_SCH_MessageType_messageClassExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_BCCH_DL_SCH_MessageType 
   (const char* name, const BCCH_DL_SCH_MessageType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_BCCH_DL_SCH_MessageType_c1 ("c1", pvalue->u.c1);
         break;
      }
      /* messageClassExtension */
      case 2:
      {
         asn1Print_BCCH_DL_SCH_MessageType_messageClassExtension (
            "messageClassExtension", pvalue->u.messageClassExtension);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_BCCH_DL_SCH_Message 
   (const char* name, const BCCH_DL_SCH_Message* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_BCCH_DL_SCH_MessageType ("message", &pvalue->message);

   rtxPrintCloseBrace ();
}

void asn1Print_CommonSF_AllocPatternList_r9 
   (const char* name, const CommonSF_AllocPatternList_r9* pvalue)
{
   MBSFN_SubframeConfig* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (MBSFN_SubframeConfig*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MBSFN_SubframeConfig (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_PMCH_Config_r9 (const char* name, const PMCH_Config_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("sf_AllocEnd_r9", pvalue->sf_AllocEnd_r9);

   rtxPrintIndent ();
   rtxPrintUnsigned ("dataMCS_r9", pvalue->dataMCS_r9);

   asn1Print_PMCH_Config_r9_mch_SchedulingPeriod_r9 (
      "mch_SchedulingPeriod_r9", &pvalue->mch_SchedulingPeriod_r9);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_TMGI_r9_plmn_Id_r9 
   (const char* name, const TMGI_r9_plmn_Id_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* plmn-Index-r9 */
      case 1:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("plmn-Index-r9", pvalue->u.plmn_Index_r9);
         break;
      }
      /* explicitValue-r9 */
      case 2:
      {
         asn1Print_PLMN_Identity ("explicitValue-r9", pvalue->
            u.explicitValue_r9);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_TMGI_r9 (const char* name, const TMGI_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_TMGI_r9_plmn_Id_r9 ("plmn_Id_r9", &pvalue->plmn_Id_r9);

   asn1Print_TMGI_r9_serviceId_r9 ("serviceId_r9", &pvalue->serviceId_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_MBMS_SessionInfo_r9 
   (const char* name, const MBMS_SessionInfo_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_TMGI_r9 ("tmgi_r9", &pvalue->tmgi_r9);

   if (pvalue->m.sessionId_r9Present) {
      asn1Print_MBMS_SessionInfo_r9_sessionId_r9 ("sessionId_r9", &pvalue->
         sessionId_r9);
   }

   rtxPrintIndent ();
   rtxPrintUnsigned ("logicalChannelIdentity_r9", pvalue->logicalChannelIdentity_r9);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_MBMS_SessionInfoList_r9 
   (const char* name, const MBMS_SessionInfoList_r9* pvalue)
{
   MBMS_SessionInfo_r9* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (MBMS_SessionInfo_r9*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MBMS_SessionInfo_r9 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_PMCH_Info_r9 (const char* name, const PMCH_Info_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PMCH_Config_r9 ("pmch_Config_r9", &pvalue->pmch_Config_r9);

   asn1Print_MBMS_SessionInfoList_r9 ("mbms_SessionInfoList_r9", &pvalue->
      mbms_SessionInfoList_r9);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_PMCH_InfoList_r9 
   (const char* name, const PMCH_InfoList_r9* pvalue)
{
   PMCH_Info_r9* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (PMCH_Info_r9*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_PMCH_Info_r9 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_MBSFNAreaConfiguration_v930_IEs_nonCriticalExtension 
   (const char* name, const MBSFNAreaConfiguration_v930_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_MBSFNAreaConfiguration_v930_IEs 
   (const char* name, const MBSFNAreaConfiguration_v930_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_MBSFNAreaConfiguration_v930_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MBSFNAreaConfiguration_r9 
   (const char* name, const MBSFNAreaConfiguration_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CommonSF_AllocPatternList_r9 ("commonSF_Alloc_r9", &pvalue->
      commonSF_Alloc_r9);

   asn1Print_MBSFNAreaConfiguration_r9_commonSF_AllocPeriod_r9 (
      "commonSF_AllocPeriod_r9", &pvalue->commonSF_AllocPeriod_r9);

   asn1Print_PMCH_InfoList_r9 ("pmch_InfoList_r9", &pvalue->pmch_InfoList_r9);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_MBSFNAreaConfiguration_v930_IEs ("nonCriticalExtension", &
         pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MCCH_MessageType_c1 
   (const char* name, const MCCH_MessageType_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* mbsfnAreaConfiguration-r9 */
      case 1:
      {
         asn1Print_MBSFNAreaConfiguration_r9 ("mbsfnAreaConfiguration-r9", 
            pvalue->u.mbsfnAreaConfiguration_r9);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MCCH_MessageType_messageClassExtension 
   (const char* name, const MCCH_MessageType_messageClassExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_MCCH_MessageType 
   (const char* name, const MCCH_MessageType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_MCCH_MessageType_c1 ("c1", pvalue->u.c1);
         break;
      }
      /* messageClassExtension */
      case 2:
      {
         asn1Print_MCCH_MessageType_messageClassExtension (
            "messageClassExtension", pvalue->u.messageClassExtension);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MCCH_Message (const char* name, const MCCH_Message* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MCCH_MessageType ("message", &pvalue->message);

   rtxPrintCloseBrace ();
}

void asn1Print_S_TMSI (const char* name, const S_TMSI* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MMEC ("mmec", &pvalue->mmec);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("m_TMSI", pvalue->m_TMSI.numbits, pvalue->m_TMSI.data);

   rtxPrintCloseBrace ();
}

void asn1Print_IMSI (const char* name, const IMSI* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_IMSI_Digit (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_PagingUE_Identity 
   (const char* name, const PagingUE_Identity* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* s-TMSI */
      case 1:
      {
         asn1Print_S_TMSI ("s-TMSI", pvalue->u.s_TMSI);
         break;
      }
      /* imsi */
      case 2:
      {
         asn1Print_IMSI ("imsi", pvalue->u.imsi);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PagingRecord (const char* name, const PagingRecord* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PagingUE_Identity ("ue_Identity", &pvalue->ue_Identity);

   asn1Print_PagingRecord_cn_Domain ("cn_Domain", &pvalue->cn_Domain);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_PagingRecordList 
   (const char* name, const PagingRecordList* pvalue)
{
   PagingRecord* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (PagingRecord*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_PagingRecord (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_Paging_v920_IEs_nonCriticalExtension 
   (const char* name, const Paging_v920_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_Paging_v920_IEs 
   (const char* name, const Paging_v920_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.cmas_Indication_r9Present) {
      asn1Print_Paging_v920_IEs_cmas_Indication_r9 ("cmas_Indication_r9", &
         pvalue->cmas_Indication_r9);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_Paging_v920_IEs_nonCriticalExtension ("nonCriticalExtension", &
         pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_Paging_v890_IEs 
   (const char* name, const Paging_v890_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_Paging_v920_IEs ("nonCriticalExtension", &pvalue->
         nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_Paging (const char* name, const Paging* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.pagingRecordListPresent) {
      asn1Print_PagingRecordList ("pagingRecordList", &pvalue->pagingRecordList
         );
   }

   if (pvalue->m.systemInfoModificationPresent) {
      asn1Print_Paging_systemInfoModification ("systemInfoModification", &
         pvalue->systemInfoModification);
   }

   if (pvalue->m.etws_IndicationPresent) {
      asn1Print_Paging_etws_Indication ("etws_Indication", &pvalue->
         etws_Indication);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_Paging_v890_IEs ("nonCriticalExtension", &pvalue->
         nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PCCH_MessageType_c1 
   (const char* name, const PCCH_MessageType_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* paging */
      case 1:
      {
         asn1Print_Paging ("paging", pvalue->u.paging);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PCCH_MessageType_messageClassExtension 
   (const char* name, const PCCH_MessageType_messageClassExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_PCCH_MessageType 
   (const char* name, const PCCH_MessageType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_PCCH_MessageType_c1 ("c1", pvalue->u.c1);
         break;
      }
      /* messageClassExtension */
      case 2:
      {
         asn1Print_PCCH_MessageType_messageClassExtension (
            "messageClassExtension", pvalue->u.messageClassExtension);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PCCH_Message (const char* name, const PCCH_Message* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PCCH_MessageType ("message", &pvalue->message);

   rtxPrintCloseBrace ();
}

void asn1Print_UL_AM_RLC (const char* name, const UL_AM_RLC* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_T_PollRetransmit ("t_PollRetransmit", &pvalue->t_PollRetransmit);

   asn1Print_PollPDU ("pollPDU", &pvalue->pollPDU);

   asn1Print_PollByte ("pollByte", &pvalue->pollByte);

   asn1Print_UL_AM_RLC_maxRetxThreshold ("maxRetxThreshold", &pvalue->
      maxRetxThreshold);

   rtxPrintCloseBrace ();
}

void asn1Print_DL_AM_RLC (const char* name, const DL_AM_RLC* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_T_Reordering ("t_Reordering", &pvalue->t_Reordering);

   asn1Print_T_StatusProhibit ("t_StatusProhibit", &pvalue->t_StatusProhibit);

   rtxPrintCloseBrace ();
}

void asn1Print_RLC_Config_am (const char* name, const RLC_Config_am* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_UL_AM_RLC ("ul_AM_RLC", &pvalue->ul_AM_RLC);

   asn1Print_DL_AM_RLC ("dl_AM_RLC", &pvalue->dl_AM_RLC);

   rtxPrintCloseBrace ();
}

void asn1Print_UL_UM_RLC (const char* name, const UL_UM_RLC* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SN_FieldLength ("sn_FieldLength", &pvalue->sn_FieldLength);

   rtxPrintCloseBrace ();
}

void asn1Print_DL_UM_RLC (const char* name, const DL_UM_RLC* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SN_FieldLength ("sn_FieldLength", &pvalue->sn_FieldLength);

   asn1Print_T_Reordering ("t_Reordering", &pvalue->t_Reordering);

   rtxPrintCloseBrace ();
}

void asn1Print_RLC_Config_um_Bi_Directional 
   (const char* name, const RLC_Config_um_Bi_Directional* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_UL_UM_RLC ("ul_UM_RLC", &pvalue->ul_UM_RLC);

   asn1Print_DL_UM_RLC ("dl_UM_RLC", &pvalue->dl_UM_RLC);

   rtxPrintCloseBrace ();
}

void asn1Print_RLC_Config_um_Uni_Directional_UL 
   (const char* name, const RLC_Config_um_Uni_Directional_UL* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_UL_UM_RLC ("ul_UM_RLC", &pvalue->ul_UM_RLC);

   rtxPrintCloseBrace ();
}

void asn1Print_RLC_Config_um_Uni_Directional_DL 
   (const char* name, const RLC_Config_um_Uni_Directional_DL* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_DL_UM_RLC ("dl_UM_RLC", &pvalue->dl_UM_RLC);

   rtxPrintCloseBrace ();
}

void asn1Print_RLC_Config (const char* name, const RLC_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* am */
      case 1:
      {
         asn1Print_RLC_Config_am ("am", pvalue->u.am);
         break;
      }
      /* um-Bi-Directional */
      case 2:
      {
         asn1Print_RLC_Config_um_Bi_Directional ("um-Bi-Directional", pvalue->
            u.um_Bi_Directional);
         break;
      }
      /* um-Uni-Directional-UL */
      case 3:
      {
         asn1Print_RLC_Config_um_Uni_Directional_UL ("um-Uni-Directional-UL", 
            pvalue->u.um_Uni_Directional_UL);
         break;
      }
      /* um-Uni-Directional-DL */
      case 4:
      {
         asn1Print_RLC_Config_um_Uni_Directional_DL ("um-Uni-Directional-DL", 
            pvalue->u.um_Uni_Directional_DL);
         break;
      }
      /* extElem1 */
      case 5:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SRB_ToAddMod_rlc_Config 
   (const char* name, const SRB_ToAddMod_rlc_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* explicitValue */
      case 1:
      {
         asn1Print_RLC_Config ("explicitValue", pvalue->u.explicitValue);
         break;
      }
      /* defaultValue */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("defaultValue");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_LogicalChannelConfig_ul_SpecificParameters 
   (const char* name, const LogicalChannelConfig_ul_SpecificParameters* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("priority", pvalue->priority);

   asn1Print_LogicalChannelConfig_ul_SpecificParameters_prioritisedBitRate (
      "prioritisedBitRate", &pvalue->prioritisedBitRate);

   asn1Print_LogicalChannelConfig_ul_SpecificParameters_bucketSizeDuration (
      "bucketSizeDuration", &pvalue->bucketSizeDuration);

   if (pvalue->m.logicalChannelGroupPresent) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("logicalChannelGroup", pvalue->logicalChannelGroup);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_LogicalChannelConfig 
   (const char* name, const LogicalChannelConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.ul_SpecificParametersPresent) {
      asn1Print_LogicalChannelConfig_ul_SpecificParameters (
         "ul_SpecificParameters", &pvalue->ul_SpecificParameters);
   }

   if (pvalue->m._v2ExtPresent) {
      if (pvalue->m.logicalChannelSR_Mask_r9Present) {
         asn1Print_LogicalChannelConfig_logicalChannelSR_Mask_r9 (
            "logicalChannelSR_Mask_r9", &pvalue->logicalChannelSR_Mask_r9);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_SRB_ToAddMod_logicalChannelConfig 
   (const char* name, const SRB_ToAddMod_logicalChannelConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* explicitValue */
      case 1:
      {
         asn1Print_LogicalChannelConfig ("explicitValue", pvalue->
            u.explicitValue);
         break;
      }
      /* defaultValue */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("defaultValue");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SRB_ToAddMod (const char* name, const SRB_ToAddMod* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("srb_Identity", pvalue->srb_Identity);

   if (pvalue->m.rlc_ConfigPresent) {
      asn1Print_SRB_ToAddMod_rlc_Config ("rlc_Config", &pvalue->rlc_Config);
   }

   if (pvalue->m.logicalChannelConfigPresent) {
      asn1Print_SRB_ToAddMod_logicalChannelConfig ("logicalChannelConfig", &
         pvalue->logicalChannelConfig);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_SRB_ToAddModList 
   (const char* name, const SRB_ToAddModList* pvalue)
{
   SRB_ToAddMod* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (SRB_ToAddMod*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_SRB_ToAddMod (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_PDCP_Config_rlc_AM 
   (const char* name, const PDCP_Config_rlc_AM* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("statusReportRequired", pvalue->statusReportRequired);

   rtxPrintCloseBrace ();
}

void asn1Print_PDCP_Config_rlc_UM 
   (const char* name, const PDCP_Config_rlc_UM* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PDCP_Config_rlc_UM_pdcp_SN_Size ("pdcp_SN_Size", &pvalue->
      pdcp_SN_Size);

   rtxPrintCloseBrace ();
}

void asn1Print_PDCP_Config_headerCompression_rohc_profiles 
   (const char* name, const PDCP_Config_headerCompression_rohc_profiles* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0001", pvalue->profile0x0001);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0002", pvalue->profile0x0002);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0003", pvalue->profile0x0003);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0004", pvalue->profile0x0004);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0006", pvalue->profile0x0006);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0101", pvalue->profile0x0101);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0102", pvalue->profile0x0102);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0103", pvalue->profile0x0103);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0104", pvalue->profile0x0104);

   rtxPrintCloseBrace ();
}

void asn1Print_PDCP_Config_headerCompression_rohc 
   (const char* name, const PDCP_Config_headerCompression_rohc* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("maxCID", pvalue->maxCID);

   asn1Print_PDCP_Config_headerCompression_rohc_profiles ("profiles", &pvalue->
      profiles);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_PDCP_Config_headerCompression 
   (const char* name, const PDCP_Config_headerCompression* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* notUsed */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("notUsed");
         break;
      }
      /* rohc */
      case 2:
      {
         asn1Print_PDCP_Config_headerCompression_rohc ("rohc", pvalue->u.rohc
            );
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PDCP_Config (const char* name, const PDCP_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.discardTimerPresent) {
      asn1Print_PDCP_Config_discardTimer ("discardTimer", &pvalue->discardTimer
         );
   }

   if (pvalue->m.rlc_AMPresent) {
      asn1Print_PDCP_Config_rlc_AM ("rlc_AM", &pvalue->rlc_AM);
   }

   if (pvalue->m.rlc_UMPresent) {
      asn1Print_PDCP_Config_rlc_UM ("rlc_UM", &pvalue->rlc_UM);
   }

   asn1Print_PDCP_Config_headerCompression ("headerCompression", &pvalue->
      headerCompression);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_DRB_ToAddMod (const char* name, const DRB_ToAddMod* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.eps_BearerIdentityPresent) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("eps_BearerIdentity", pvalue->eps_BearerIdentity);
   }

   asn1Print_DRB_Identity ("drb_Identity", &pvalue->drb_Identity);

   if (pvalue->m.pdcp_ConfigPresent) {
      asn1Print_PDCP_Config ("pdcp_Config", &pvalue->pdcp_Config);
   }

   if (pvalue->m.rlc_ConfigPresent) {
      asn1Print_RLC_Config ("rlc_Config", &pvalue->rlc_Config);
   }

   if (pvalue->m.logicalChannelIdentityPresent) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("logicalChannelIdentity", pvalue->logicalChannelIdentity);
   }

   if (pvalue->m.logicalChannelConfigPresent) {
      asn1Print_LogicalChannelConfig ("logicalChannelConfig", &pvalue->
         logicalChannelConfig);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_DRB_ToAddModList 
   (const char* name, const DRB_ToAddModList* pvalue)
{
   DRB_ToAddMod* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (DRB_ToAddMod*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_DRB_ToAddMod (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_DRB_ToReleaseList 
   (const char* name, const DRB_ToReleaseList* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_DRB_Identity (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_MAC_MainConfig_ul_SCH_Config 
   (const char* name, const MAC_MainConfig_ul_SCH_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.maxHARQ_TxPresent) {
      asn1Print_MAC_MainConfig_ul_SCH_Config_maxHARQ_Tx ("maxHARQ_Tx", &pvalue
         ->maxHARQ_Tx);
   }

   if (pvalue->m.periodicBSR_TimerPresent) {
      asn1Print_MAC_MainConfig_ul_SCH_Config_periodicBSR_Timer (
         "periodicBSR_Timer", &pvalue->periodicBSR_Timer);
   }

   asn1Print_MAC_MainConfig_ul_SCH_Config_retxBSR_Timer ("retxBSR_Timer", &
      pvalue->retxBSR_Timer);

   rtxPrintIndent ();
   rtxPrintBoolean ("ttiBundling", pvalue->ttiBundling);

   rtxPrintCloseBrace ();
}

void asn1Print_DRX_Config_setup_longDRX_CycleStartOffset 
   (const char* name, const DRX_Config_setup_longDRX_CycleStartOffset* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* sf10 */
      case 1:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf10", pvalue->u.sf10);
         break;
      }
      /* sf20 */
      case 2:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf20", pvalue->u.sf20);
         break;
      }
      /* sf32 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf32", pvalue->u.sf32);
         break;
      }
      /* sf40 */
      case 4:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf40", pvalue->u.sf40);
         break;
      }
      /* sf64 */
      case 5:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf64", pvalue->u.sf64);
         break;
      }
      /* sf80 */
      case 6:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf80", pvalue->u.sf80);
         break;
      }
      /* sf128 */
      case 7:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf128", pvalue->u.sf128);
         break;
      }
      /* sf160 */
      case 8:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf160", pvalue->u.sf160);
         break;
      }
      /* sf256 */
      case 9:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf256", pvalue->u.sf256);
         break;
      }
      /* sf320 */
      case 10:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf320", pvalue->u.sf320);
         break;
      }
      /* sf512 */
      case 11:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf512", pvalue->u.sf512);
         break;
      }
      /* sf640 */
      case 12:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf640", pvalue->u.sf640);
         break;
      }
      /* sf1024 */
      case 13:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf1024", pvalue->u.sf1024);
         break;
      }
      /* sf1280 */
      case 14:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf1280", pvalue->u.sf1280);
         break;
      }
      /* sf2048 */
      case 15:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf2048", pvalue->u.sf2048);
         break;
      }
      /* sf2560 */
      case 16:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sf2560", pvalue->u.sf2560);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_DRX_Config_setup_shortDRX 
   (const char* name, const DRX_Config_setup_shortDRX* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_DRX_Config_setup_shortDRX_shortDRX_Cycle ("shortDRX_Cycle", &
      pvalue->shortDRX_Cycle);

   rtxPrintIndent ();
   rtxPrintUnsigned ("drxShortCycleTimer", pvalue->drxShortCycleTimer);

   rtxPrintCloseBrace ();
}

void asn1Print_DRX_Config_setup 
   (const char* name, const DRX_Config_setup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_DRX_Config_setup_onDurationTimer ("onDurationTimer", &pvalue->
      onDurationTimer);

   asn1Print_DRX_Config_setup_drx_InactivityTimer ("drx_InactivityTimer", &
      pvalue->drx_InactivityTimer);

   asn1Print_DRX_Config_setup_drx_RetransmissionTimer (
      "drx_RetransmissionTimer", &pvalue->drx_RetransmissionTimer);

   asn1Print_DRX_Config_setup_longDRX_CycleStartOffset (
      "longDRX_CycleStartOffset", &pvalue->longDRX_CycleStartOffset);

   if (pvalue->m.shortDRXPresent) {
      asn1Print_DRX_Config_setup_shortDRX ("shortDRX", &pvalue->shortDRX);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_DRX_Config (const char* name, const DRX_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_DRX_Config_setup ("setup", pvalue->u.setup);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MAC_MainConfig_phr_Config_setup 
   (const char* name, const MAC_MainConfig_phr_Config_setup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MAC_MainConfig_phr_Config_setup_periodicPHR_Timer (
      "periodicPHR_Timer", &pvalue->periodicPHR_Timer);

   asn1Print_MAC_MainConfig_phr_Config_setup_prohibitPHR_Timer (
      "prohibitPHR_Timer", &pvalue->prohibitPHR_Timer);

   asn1Print_MAC_MainConfig_phr_Config_setup_dl_PathlossChange (
      "dl_PathlossChange", &pvalue->dl_PathlossChange);

   rtxPrintCloseBrace ();
}

void asn1Print_MAC_MainConfig_phr_Config 
   (const char* name, const MAC_MainConfig_phr_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_MAC_MainConfig_phr_Config_setup ("setup", pvalue->u.setup);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MAC_MainConfig (const char* name, const MAC_MainConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.ul_SCH_ConfigPresent) {
      asn1Print_MAC_MainConfig_ul_SCH_Config ("ul_SCH_Config", &pvalue->
         ul_SCH_Config);
   }

   if (pvalue->m.drx_ConfigPresent) {
      asn1Print_DRX_Config ("drx_Config", &pvalue->drx_Config);
   }

   asn1Print_TimeAlignmentTimer ("timeAlignmentTimerDedicated", &pvalue->
      timeAlignmentTimerDedicated);

   if (pvalue->m.phr_ConfigPresent) {
      asn1Print_MAC_MainConfig_phr_Config ("phr_Config", &pvalue->phr_Config);
   }

   if (pvalue->m._v2ExtPresent) {
      if (pvalue->m.sr_ProhibitTimer_r9Present) {
         rtxPrintIndent ();
         rtxPrintUnsigned ("sr_ProhibitTimer_r9", pvalue->sr_ProhibitTimer_r9);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_RadioResourceConfigDedicated_mac_MainConfig 
   (const char* name, const RadioResourceConfigDedicated_mac_MainConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* explicitValue */
      case 1:
      {
         asn1Print_MAC_MainConfig ("explicitValue", pvalue->u.explicitValue);
         break;
      }
      /* defaultValue */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("defaultValue");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_N1_PUCCH_AN_PersistentList 
   (const char* name, const N1_PUCCH_AN_PersistentList* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      rtxPrintIndent ();
      rtxPrintUnsigned (namebuf, pvalue->elem[xx1]);
   }
}

void asn1Print_SPS_ConfigDL_setup 
   (const char* name, const SPS_ConfigDL_setup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SPS_ConfigDL_setup_semiPersistSchedIntervalDL (
      "semiPersistSchedIntervalDL", &pvalue->semiPersistSchedIntervalDL);

   rtxPrintIndent ();
   rtxPrintUnsigned ("numberOfConfSPS_Processes", pvalue->numberOfConfSPS_Processes);

   asn1Print_N1_PUCCH_AN_PersistentList ("n1_PUCCH_AN_PersistentList", &pvalue
      ->n1_PUCCH_AN_PersistentList);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_SPS_ConfigDL (const char* name, const SPS_ConfigDL* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_SPS_ConfigDL_setup ("setup", pvalue->u.setup);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SPS_ConfigUL_setup_p0_Persistent 
   (const char* name, const SPS_ConfigUL_setup_p0_Persistent* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintInteger ("p0_NominalPUSCH_Persistent", pvalue->p0_NominalPUSCH_Persistent);

   rtxPrintIndent ();
   rtxPrintInteger ("p0_UE_PUSCH_Persistent", pvalue->p0_UE_PUSCH_Persistent);

   rtxPrintCloseBrace ();
}

void asn1Print_SPS_ConfigUL_setup 
   (const char* name, const SPS_ConfigUL_setup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SPS_ConfigUL_setup_semiPersistSchedIntervalUL (
      "semiPersistSchedIntervalUL", &pvalue->semiPersistSchedIntervalUL);

   asn1Print_SPS_ConfigUL_setup_implicitReleaseAfter ("implicitReleaseAfter", &
      pvalue->implicitReleaseAfter);

   if (pvalue->m.p0_PersistentPresent) {
      asn1Print_SPS_ConfigUL_setup_p0_Persistent ("p0_Persistent", &pvalue->
         p0_Persistent);
   }

   if (pvalue->m.twoIntervalsConfigPresent) {
      asn1Print_SPS_ConfigUL_setup_twoIntervalsConfig ("twoIntervalsConfig", &
         pvalue->twoIntervalsConfig);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_SPS_ConfigUL (const char* name, const SPS_ConfigUL* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_SPS_ConfigUL_setup ("setup", pvalue->u.setup);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SPS_Config (const char* name, const SPS_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.semiPersistSchedC_RNTIPresent) {
      asn1Print_C_RNTI ("semiPersistSchedC_RNTI", &pvalue->
         semiPersistSchedC_RNTI);
   }

   if (pvalue->m.sps_ConfigDLPresent) {
      asn1Print_SPS_ConfigDL ("sps_ConfigDL", &pvalue->sps_ConfigDL);
   }

   if (pvalue->m.sps_ConfigULPresent) {
      asn1Print_SPS_ConfigUL ("sps_ConfigUL", &pvalue->sps_ConfigUL);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PDSCH_ConfigDedicated 
   (const char* name, const PDSCH_ConfigDedicated* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PDSCH_ConfigDedicated_p_a ("p_a", &pvalue->p_a);

   rtxPrintCloseBrace ();
}

void asn1Print_PUCCH_ConfigDedicated_ackNackRepetition_setup 
   (const char* name, const PUCCH_ConfigDedicated_ackNackRepetition_setup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor (
      "repetitionFactor", &pvalue->repetitionFactor);

   rtxPrintIndent ();
   rtxPrintUnsigned ("n1PUCCH_AN_Rep", pvalue->n1PUCCH_AN_Rep);

   rtxPrintCloseBrace ();
}

void asn1Print_PUCCH_ConfigDedicated_ackNackRepetition 
   (const char* name, const PUCCH_ConfigDedicated_ackNackRepetition* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_PUCCH_ConfigDedicated_ackNackRepetition_setup ("setup", 
            pvalue->u.setup);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PUCCH_ConfigDedicated 
   (const char* name, const PUCCH_ConfigDedicated* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PUCCH_ConfigDedicated_ackNackRepetition ("ackNackRepetition", &
      pvalue->ackNackRepetition);

   if (pvalue->m.tdd_AckNackFeedbackModePresent) {
      asn1Print_PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode (
         "tdd_AckNackFeedbackMode", &pvalue->tdd_AckNackFeedbackMode);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PUSCH_ConfigDedicated 
   (const char* name, const PUSCH_ConfigDedicated* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("betaOffset_ACK_Index", pvalue->betaOffset_ACK_Index);

   rtxPrintIndent ();
   rtxPrintUnsigned ("betaOffset_RI_Index", pvalue->betaOffset_RI_Index);

   rtxPrintIndent ();
   rtxPrintUnsigned ("betaOffset_CQI_Index", pvalue->betaOffset_CQI_Index);

   rtxPrintCloseBrace ();
}

void asn1Print_UplinkPowerControlDedicated 
   (const char* name, const UplinkPowerControlDedicated* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintInteger ("p0_UE_PUSCH", pvalue->p0_UE_PUSCH);

   asn1Print_UplinkPowerControlDedicated_deltaMCS_Enabled ("deltaMCS_Enabled", 
      &pvalue->deltaMCS_Enabled);

   rtxPrintIndent ();
   rtxPrintBoolean ("accumulationEnabled", pvalue->accumulationEnabled);

   rtxPrintIndent ();
   rtxPrintInteger ("p0_UE_PUCCH", pvalue->p0_UE_PUCCH);

   rtxPrintIndent ();
   rtxPrintUnsigned ("pSRS_Offset", pvalue->pSRS_Offset);

   asn1Print_FilterCoefficient ("filterCoefficient", &pvalue->filterCoefficient
      );

   rtxPrintCloseBrace ();
}

void asn1Print_TPC_Index (const char* name, const TPC_Index* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* indexOfFormat3 */
      case 1:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("indexOfFormat3", pvalue->u.indexOfFormat3);
         break;
      }
      /* indexOfFormat3A */
      case 2:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("indexOfFormat3A", pvalue->u.indexOfFormat3A);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_TPC_PDCCH_Config_setup 
   (const char* name, const TPC_PDCCH_Config_setup* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("tpc_RNTI", pvalue->tpc_RNTI.numbits, pvalue->tpc_RNTI.data);

   asn1Print_TPC_Index ("tpc_Index", &pvalue->tpc_Index);

   rtxPrintCloseBrace ();
}

void asn1Print_TPC_PDCCH_Config 
   (const char* name, const TPC_PDCCH_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_TPC_PDCCH_Config_setup ("setup", pvalue->u.setup);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI 
   (const char* name, const CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("k", pvalue->k);

   rtxPrintCloseBrace ();
}

void asn1Print_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic 
   (const char* name, const CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* widebandCQI */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("widebandCQI");
         break;
      }
      /* subbandCQI */
      case 2:
      {
         asn1Print_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI (
            "subbandCQI", pvalue->u.subbandCQI);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CQI_ReportPeriodic_setup 
   (const char* name, const CQI_ReportPeriodic_setup* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("cqi_PUCCH_ResourceIndex", pvalue->cqi_PUCCH_ResourceIndex);

   rtxPrintIndent ();
   rtxPrintUnsigned ("cqi_pmi_ConfigIndex", pvalue->cqi_pmi_ConfigIndex);

   asn1Print_CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic (
      "cqi_FormatIndicatorPeriodic", &pvalue->cqi_FormatIndicatorPeriodic);

   if (pvalue->m.ri_ConfigIndexPresent) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("ri_ConfigIndex", pvalue->ri_ConfigIndex);
   }

   rtxPrintIndent ();
   rtxPrintBoolean ("simultaneousAckNackAndCQI", pvalue->simultaneousAckNackAndCQI);

   rtxPrintCloseBrace ();
}

void asn1Print_CQI_ReportPeriodic 
   (const char* name, const CQI_ReportPeriodic* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_CQI_ReportPeriodic_setup ("setup", pvalue->u.setup);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CQI_ReportConfig 
   (const char* name, const CQI_ReportConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.cqi_ReportModeAperiodicPresent) {
      asn1Print_CQI_ReportConfig_cqi_ReportModeAperiodic (
         "cqi_ReportModeAperiodic", &pvalue->cqi_ReportModeAperiodic);
   }

   rtxPrintIndent ();
   rtxPrintInteger ("nomPDSCH_RS_EPRE_Offset", pvalue->nomPDSCH_RS_EPRE_Offset);

   if (pvalue->m.cqi_ReportPeriodicPresent) {
      asn1Print_CQI_ReportPeriodic ("cqi_ReportPeriodic", &pvalue->
         cqi_ReportPeriodic);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SoundingRS_UL_ConfigDedicated_setup 
   (const char* name, const SoundingRS_UL_ConfigDedicated_setup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth (
      "srs_Bandwidth", &pvalue->srs_Bandwidth);

   asn1Print_SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth (
      "srs_HoppingBandwidth", &pvalue->srs_HoppingBandwidth);

   rtxPrintIndent ();
   rtxPrintUnsigned ("freqDomainPosition", pvalue->freqDomainPosition);

   rtxPrintIndent ();
   rtxPrintBoolean ("duration", pvalue->duration);

   rtxPrintIndent ();
   rtxPrintUnsigned ("srs_ConfigIndex", pvalue->srs_ConfigIndex);

   rtxPrintIndent ();
   rtxPrintUnsigned ("transmissionComb", pvalue->transmissionComb);

   asn1Print_SoundingRS_UL_ConfigDedicated_setup_cyclicShift ("cyclicShift", &
      pvalue->cyclicShift);

   rtxPrintCloseBrace ();
}

void asn1Print_SoundingRS_UL_ConfigDedicated 
   (const char* name, const SoundingRS_UL_ConfigDedicated* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_SoundingRS_UL_ConfigDedicated_setup ("setup", pvalue->
            u.setup);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_AntennaInfoDedicated_codebookSubsetRestriction 
   (const char* name, const AntennaInfoDedicated_codebookSubsetRestriction* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* n2TxAntenna-tm3 */
      case 1:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("n2TxAntenna-tm3", pvalue->u.n2TxAntenna_tm3->numbits, pvalue->u.n2TxAntenna_tm3->data);
         break;
      }
      /* n4TxAntenna-tm3 */
      case 2:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("n4TxAntenna-tm3", pvalue->u.n4TxAntenna_tm3->numbits, pvalue->u.n4TxAntenna_tm3->data);
         break;
      }
      /* n2TxAntenna-tm4 */
      case 3:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("n2TxAntenna-tm4", pvalue->u.n2TxAntenna_tm4->numbits, pvalue->u.n2TxAntenna_tm4->data);
         break;
      }
      /* n4TxAntenna-tm4 */
      case 4:
      {
         asn1Print_AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4 (
            "n4TxAntenna-tm4", pvalue->u.n4TxAntenna_tm4);
         break;
      }
      /* n2TxAntenna-tm5 */
      case 5:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("n2TxAntenna-tm5", pvalue->u.n2TxAntenna_tm5->numbits, pvalue->u.n2TxAntenna_tm5->data);
         break;
      }
      /* n4TxAntenna-tm5 */
      case 6:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("n4TxAntenna-tm5", pvalue->u.n4TxAntenna_tm5->numbits, pvalue->u.n4TxAntenna_tm5->data);
         break;
      }
      /* n2TxAntenna-tm6 */
      case 7:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("n2TxAntenna-tm6", pvalue->u.n2TxAntenna_tm6->numbits, pvalue->u.n2TxAntenna_tm6->data);
         break;
      }
      /* n4TxAntenna-tm6 */
      case 8:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("n4TxAntenna-tm6", pvalue->u.n4TxAntenna_tm6->numbits, pvalue->u.n4TxAntenna_tm6->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_AntennaInfoDedicated_ue_TransmitAntennaSelection 
   (const char* name, const AntennaInfoDedicated_ue_TransmitAntennaSelection* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_AntennaInfoDedicated_ue_TransmitAntennaSelection_setup (
            "setup", &pvalue->u.setup);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_AntennaInfoDedicated 
   (const char* name, const AntennaInfoDedicated* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_AntennaInfoDedicated_transmissionMode ("transmissionMode", &pvalue
      ->transmissionMode);

   if (pvalue->m.codebookSubsetRestrictionPresent) {
      asn1Print_AntennaInfoDedicated_codebookSubsetRestriction (
         "codebookSubsetRestriction", &pvalue->codebookSubsetRestriction);
   }

   asn1Print_AntennaInfoDedicated_ue_TransmitAntennaSelection (
      "ue_TransmitAntennaSelection", &pvalue->ue_TransmitAntennaSelection);

   rtxPrintCloseBrace ();
}

void asn1Print_PhysicalConfigDedicated_antennaInfo 
   (const char* name, const PhysicalConfigDedicated_antennaInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* explicitValue */
      case 1:
      {
         asn1Print_AntennaInfoDedicated ("explicitValue", pvalue->
            u.explicitValue);
         break;
      }
      /* defaultValue */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("defaultValue");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SchedulingRequestConfig_setup 
   (const char* name, const SchedulingRequestConfig_setup* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("sr_PUCCH_ResourceIndex", pvalue->sr_PUCCH_ResourceIndex);

   rtxPrintIndent ();
   rtxPrintUnsigned ("sr_ConfigIndex", pvalue->sr_ConfigIndex);

   asn1Print_SchedulingRequestConfig_setup_dsr_TransMax ("dsr_TransMax", &
      pvalue->dsr_TransMax);

   rtxPrintCloseBrace ();
}

void asn1Print_SchedulingRequestConfig 
   (const char* name, const SchedulingRequestConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_SchedulingRequestConfig_setup ("setup", pvalue->u.setup);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CQI_ReportConfig_v920 
   (const char* name, const CQI_ReportConfig_v920* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.cqi_Mask_r9Present) {
      asn1Print_CQI_ReportConfig_v920_cqi_Mask_r9 ("cqi_Mask_r9", &pvalue->
         cqi_Mask_r9);
   }

   if (pvalue->m.pmi_RI_Report_r9Present) {
      asn1Print_CQI_ReportConfig_v920_pmi_RI_Report_r9 ("pmi_RI_Report_r9", &
         pvalue->pmi_RI_Report_r9);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_AntennaInfoDedicated_v920_codebookSubsetRestriction_v920 
   (const char* name, const AntennaInfoDedicated_v920_codebookSubsetRestriction_v920* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* n2TxAntenna-tm8-r9 */
      case 1:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("n2TxAntenna-tm8-r9", pvalue->u.n2TxAntenna_tm8_r9->numbits, pvalue->u.n2TxAntenna_tm8_r9->data);
         break;
      }
      /* n4TxAntenna-tm8-r9 */
      case 2:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("n4TxAntenna-tm8-r9", pvalue->u.n4TxAntenna_tm8_r9->numbits, pvalue->u.n4TxAntenna_tm8_r9->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_AntennaInfoDedicated_v920 
   (const char* name, const AntennaInfoDedicated_v920* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.codebookSubsetRestriction_v920Present) {
      asn1Print_AntennaInfoDedicated_v920_codebookSubsetRestriction_v920 (
         "codebookSubsetRestriction_v920", &pvalue->
         codebookSubsetRestriction_v920);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PhysicalConfigDedicated 
   (const char* name, const PhysicalConfigDedicated* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.pdsch_ConfigDedicatedPresent) {
      asn1Print_PDSCH_ConfigDedicated ("pdsch_ConfigDedicated", &pvalue->
         pdsch_ConfigDedicated);
   }

   if (pvalue->m.pucch_ConfigDedicatedPresent) {
      asn1Print_PUCCH_ConfigDedicated ("pucch_ConfigDedicated", &pvalue->
         pucch_ConfigDedicated);
   }

   if (pvalue->m.pusch_ConfigDedicatedPresent) {
      asn1Print_PUSCH_ConfigDedicated ("pusch_ConfigDedicated", &pvalue->
         pusch_ConfigDedicated);
   }

   if (pvalue->m.uplinkPowerControlDedicatedPresent) {
      asn1Print_UplinkPowerControlDedicated ("uplinkPowerControlDedicated", &
         pvalue->uplinkPowerControlDedicated);
   }

   if (pvalue->m.tpc_PDCCH_ConfigPUCCHPresent) {
      asn1Print_TPC_PDCCH_Config ("tpc_PDCCH_ConfigPUCCH", &pvalue->
         tpc_PDCCH_ConfigPUCCH);
   }

   if (pvalue->m.tpc_PDCCH_ConfigPUSCHPresent) {
      asn1Print_TPC_PDCCH_Config ("tpc_PDCCH_ConfigPUSCH", &pvalue->
         tpc_PDCCH_ConfigPUSCH);
   }

   if (pvalue->m.cqi_ReportConfigPresent) {
      asn1Print_CQI_ReportConfig ("cqi_ReportConfig", &pvalue->cqi_ReportConfig
         );
   }

   if (pvalue->m.soundingRS_UL_ConfigDedicatedPresent) {
      asn1Print_SoundingRS_UL_ConfigDedicated (
         "soundingRS_UL_ConfigDedicated", &pvalue->
         soundingRS_UL_ConfigDedicated);
   }

   if (pvalue->m.antennaInfoPresent) {
      asn1Print_PhysicalConfigDedicated_antennaInfo ("antennaInfo", &pvalue->
         antennaInfo);
   }

   if (pvalue->m.schedulingRequestConfigPresent) {
      asn1Print_SchedulingRequestConfig ("schedulingRequestConfig", &pvalue->
         schedulingRequestConfig);
   }

   if (pvalue->m._v2ExtPresent) {
      if (pvalue->m.cqi_ReportConfig_v920Present) {
         asn1Print_CQI_ReportConfig_v920 ("cqi_ReportConfig_v920", &pvalue->
            cqi_ReportConfig_v920);
      }
      if (pvalue->m.antennaInfo_v920Present) {
         asn1Print_AntennaInfoDedicated_v920 ("antennaInfo_v920", &pvalue->
            antennaInfo_v920);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_RLF_TimersAndConstants_r9_setup 
   (const char* name, const RLF_TimersAndConstants_r9_setup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RLF_TimersAndConstants_r9_setup_t301_r9 ("t301_r9", &pvalue->
      t301_r9);

   asn1Print_RLF_TimersAndConstants_r9_setup_t310_r9 ("t310_r9", &pvalue->
      t310_r9);

   asn1Print_RLF_TimersAndConstants_r9_setup_n310_r9 ("n310_r9", &pvalue->
      n310_r9);

   asn1Print_RLF_TimersAndConstants_r9_setup_t311_r9 ("t311_r9", &pvalue->
      t311_r9);

   asn1Print_RLF_TimersAndConstants_r9_setup_n311_r9 ("n311_r9", &pvalue->
      n311_r9);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_RLF_TimersAndConstants_r9 
   (const char* name, const RLF_TimersAndConstants_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_RLF_TimersAndConstants_r9_setup ("setup", pvalue->u.setup);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RadioResourceConfigDedicated 
   (const char* name, const RadioResourceConfigDedicated* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.srb_ToAddModListPresent) {
      asn1Print_SRB_ToAddModList ("srb_ToAddModList", &pvalue->srb_ToAddModList
         );
   }

   if (pvalue->m.drb_ToAddModListPresent) {
      asn1Print_DRB_ToAddModList ("drb_ToAddModList", &pvalue->drb_ToAddModList
         );
   }

   if (pvalue->m.drb_ToReleaseListPresent) {
      asn1Print_DRB_ToReleaseList ("drb_ToReleaseList", &pvalue->
         drb_ToReleaseList);
   }

   if (pvalue->m.mac_MainConfigPresent) {
      asn1Print_RadioResourceConfigDedicated_mac_MainConfig ("mac_MainConfig", 
         &pvalue->mac_MainConfig);
   }

   if (pvalue->m.sps_ConfigPresent) {
      asn1Print_SPS_Config ("sps_Config", &pvalue->sps_Config);
   }

   if (pvalue->m.physicalConfigDedicatedPresent) {
      asn1Print_PhysicalConfigDedicated ("physicalConfigDedicated", &pvalue->
         physicalConfigDedicated);
   }

   if (pvalue->m._v2ExtPresent) {
      if (pvalue->m.rlf_TimersAndConstants_r9Present) {
         asn1Print_RLF_TimersAndConstants_r9 ("rlf_TimersAndConstants_r9", &
            pvalue->rlf_TimersAndConstants_r9);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishment_v8a0_IEs_nonCriticalExtension 
   (const char* name, const RRCConnectionReestablishment_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionReestablishment_v8a0_IEs 
   (const char* name, const RRCConnectionReestablishment_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionReestablishment_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishment_r8_IEs 
   (const char* name, const RRCConnectionReestablishment_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RadioResourceConfigDedicated ("radioResourceConfigDedicated", &
      pvalue->radioResourceConfigDedicated);

   asn1Print_NextHopChainingCount ("nextHopChainingCount", &pvalue->
      nextHopChainingCount);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionReestablishment_v8a0_IEs ("nonCriticalExtension", 
         &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishment_criticalExtensions_c1 
   (const char* name, const RRCConnectionReestablishment_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rrcConnectionReestablishment-r8 */
      case 1:
      {
         asn1Print_RRCConnectionReestablishment_r8_IEs (
            "rrcConnectionReestablishment-r8", pvalue->
            u.rrcConnectionReestablishment_r8);
         break;
      }
      /* spare7 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare7");
         break;
      }
      /* spare6 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare6");
         break;
      }
      /* spare5 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare5");
         break;
      }
      /* spare4 */
      case 5:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare4");
         break;
      }
      /* spare3 */
      case 6:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 7:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 8:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishment_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const RRCConnectionReestablishment_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionReestablishment_criticalExtensions 
   (const char* name, const RRCConnectionReestablishment_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_RRCConnectionReestablishment_criticalExtensions_c1 ("c1", 
            pvalue->u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_RRCConnectionReestablishment_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishment 
   (const char* name, const RRCConnectionReestablishment* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_RRCConnectionReestablishment_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishmentReject_v8a0_IEs_nonCriticalExtension 
   (const char* name, const RRCConnectionReestablishmentReject_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionReestablishmentReject_v8a0_IEs 
   (const char* name, const RRCConnectionReestablishmentReject_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionReestablishmentReject_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishmentReject_r8_IEs 
   (const char* name, const RRCConnectionReestablishmentReject_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionReestablishmentReject_v8a0_IEs (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishmentReject_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const RRCConnectionReestablishmentReject_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionReestablishmentReject_criticalExtensions 
   (const char* name, const RRCConnectionReestablishmentReject_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rrcConnectionReestablishmentReject-r8 */
      case 1:
      {
         asn1Print_RRCConnectionReestablishmentReject_r8_IEs (
            "rrcConnectionReestablishmentReject-r8", pvalue->
            u.rrcConnectionReestablishmentReject_r8);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_RRCConnectionReestablishmentReject_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishmentReject 
   (const char* name, const RRCConnectionReestablishmentReject* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRCConnectionReestablishmentReject_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReject_v8a0_IEs_nonCriticalExtension 
   (const char* name, const RRCConnectionReject_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionReject_v8a0_IEs 
   (const char* name, const RRCConnectionReject_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionReject_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReject_r8_IEs 
   (const char* name, const RRCConnectionReject_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("waitTime", pvalue->waitTime);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionReject_v8a0_IEs ("nonCriticalExtension", &pvalue->
         nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReject_criticalExtensions_c1 
   (const char* name, const RRCConnectionReject_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rrcConnectionReject-r8 */
      case 1:
      {
         asn1Print_RRCConnectionReject_r8_IEs ("rrcConnectionReject-r8", pvalue
            ->u.rrcConnectionReject_r8);
         break;
      }
      /* spare3 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReject_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const RRCConnectionReject_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionReject_criticalExtensions 
   (const char* name, const RRCConnectionReject_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_RRCConnectionReject_criticalExtensions_c1 ("c1", pvalue->
            u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_RRCConnectionReject_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReject 
   (const char* name, const RRCConnectionReject* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRCConnectionReject_criticalExtensions ("criticalExtensions", &
      pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionSetup_v8a0_IEs_nonCriticalExtension 
   (const char* name, const RRCConnectionSetup_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionSetup_v8a0_IEs 
   (const char* name, const RRCConnectionSetup_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionSetup_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionSetup_r8_IEs 
   (const char* name, const RRCConnectionSetup_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RadioResourceConfigDedicated ("radioResourceConfigDedicated", &
      pvalue->radioResourceConfigDedicated);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionSetup_v8a0_IEs ("nonCriticalExtension", &pvalue->
         nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionSetup_criticalExtensions_c1 
   (const char* name, const RRCConnectionSetup_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rrcConnectionSetup-r8 */
      case 1:
      {
         asn1Print_RRCConnectionSetup_r8_IEs ("rrcConnectionSetup-r8", pvalue->
            u.rrcConnectionSetup_r8);
         break;
      }
      /* spare7 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare7");
         break;
      }
      /* spare6 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare6");
         break;
      }
      /* spare5 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare5");
         break;
      }
      /* spare4 */
      case 5:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare4");
         break;
      }
      /* spare3 */
      case 6:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 7:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 8:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionSetup_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const RRCConnectionSetup_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionSetup_criticalExtensions 
   (const char* name, const RRCConnectionSetup_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_RRCConnectionSetup_criticalExtensions_c1 ("c1", pvalue->u.c1
            );
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_RRCConnectionSetup_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionSetup 
   (const char* name, const RRCConnectionSetup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_RRCConnectionSetup_criticalExtensions ("criticalExtensions", &
      pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_DL_CCCH_MessageType_c1 
   (const char* name, const DL_CCCH_MessageType_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rrcConnectionReestablishment */
      case 1:
      {
         asn1Print_RRCConnectionReestablishment (
            "rrcConnectionReestablishment", pvalue->
            u.rrcConnectionReestablishment);
         break;
      }
      /* rrcConnectionReestablishmentReject */
      case 2:
      {
         asn1Print_RRCConnectionReestablishmentReject (
            "rrcConnectionReestablishmentReject", pvalue->
            u.rrcConnectionReestablishmentReject);
         break;
      }
      /* rrcConnectionReject */
      case 3:
      {
         asn1Print_RRCConnectionReject ("rrcConnectionReject", pvalue->
            u.rrcConnectionReject);
         break;
      }
      /* rrcConnectionSetup */
      case 4:
      {
         asn1Print_RRCConnectionSetup ("rrcConnectionSetup", pvalue->
            u.rrcConnectionSetup);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_DL_CCCH_MessageType_messageClassExtension 
   (const char* name, const DL_CCCH_MessageType_messageClassExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_DL_CCCH_MessageType 
   (const char* name, const DL_CCCH_MessageType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_DL_CCCH_MessageType_c1 ("c1", pvalue->u.c1);
         break;
      }
      /* messageClassExtension */
      case 2:
      {
         asn1Print_DL_CCCH_MessageType_messageClassExtension (
            "messageClassExtension", pvalue->u.messageClassExtension);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_DL_CCCH_Message 
   (const char* name, const DL_CCCH_Message* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_DL_CCCH_MessageType ("message", &pvalue->message);

   rtxPrintCloseBrace ();
}

void asn1Print_CSFBParametersResponseCDMA2000_v8a0_IEs_nonCriticalExtension 
   (const char* name, const CSFBParametersResponseCDMA2000_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_CSFBParametersResponseCDMA2000_v8a0_IEs 
   (const char* name, const CSFBParametersResponseCDMA2000_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_CSFBParametersResponseCDMA2000_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CSFBParametersResponseCDMA2000_r8_IEs 
   (const char* name, const CSFBParametersResponseCDMA2000_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RAND_CDMA2000 ("rand_", &pvalue->rand_);

   asn1Print_MobilityParametersCDMA2000 ("mobilityParameters", &pvalue->
      mobilityParameters);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_CSFBParametersResponseCDMA2000_v8a0_IEs (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CSFBParametersResponseCDMA2000_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const CSFBParametersResponseCDMA2000_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_CSFBParametersResponseCDMA2000_criticalExtensions 
   (const char* name, const CSFBParametersResponseCDMA2000_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* csfbParametersResponseCDMA2000-r8 */
      case 1:
      {
         asn1Print_CSFBParametersResponseCDMA2000_r8_IEs (
            "csfbParametersResponseCDMA2000-r8", pvalue->
            u.csfbParametersResponseCDMA2000_r8);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_CSFBParametersResponseCDMA2000_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CSFBParametersResponseCDMA2000 
   (const char* name, const CSFBParametersResponseCDMA2000* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_CSFBParametersResponseCDMA2000_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_DLInformationTransfer_r8_IEs_dedicatedInfoType 
   (const char* name, const DLInformationTransfer_r8_IEs_dedicatedInfoType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* dedicatedInfoNAS */
      case 1:
      {
         asn1Print_DedicatedInfoNAS ("dedicatedInfoNAS", pvalue->
            u.dedicatedInfoNAS);
         break;
      }
      /* dedicatedInfoCDMA2000-1XRTT */
      case 2:
      {
         asn1Print_DedicatedInfoCDMA2000 ("dedicatedInfoCDMA2000-1XRTT", pvalue
            ->u.dedicatedInfoCDMA2000_1XRTT);
         break;
      }
      /* dedicatedInfoCDMA2000-HRPD */
      case 3:
      {
         asn1Print_DedicatedInfoCDMA2000 ("dedicatedInfoCDMA2000-HRPD", pvalue
            ->u.dedicatedInfoCDMA2000_HRPD);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_DLInformationTransfer_v8a0_IEs_nonCriticalExtension 
   (const char* name, const DLInformationTransfer_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_DLInformationTransfer_v8a0_IEs 
   (const char* name, const DLInformationTransfer_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_DLInformationTransfer_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_DLInformationTransfer_r8_IEs 
   (const char* name, const DLInformationTransfer_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_DLInformationTransfer_r8_IEs_dedicatedInfoType (
      "dedicatedInfoType", &pvalue->dedicatedInfoType);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_DLInformationTransfer_v8a0_IEs ("nonCriticalExtension", &pvalue
         ->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_DLInformationTransfer_criticalExtensions_c1 
   (const char* name, const DLInformationTransfer_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* dlInformationTransfer-r8 */
      case 1:
      {
         asn1Print_DLInformationTransfer_r8_IEs ("dlInformationTransfer-r8", 
            pvalue->u.dlInformationTransfer_r8);
         break;
      }
      /* spare3 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_DLInformationTransfer_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const DLInformationTransfer_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_DLInformationTransfer_criticalExtensions 
   (const char* name, const DLInformationTransfer_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_DLInformationTransfer_criticalExtensions_c1 ("c1", pvalue->
            u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_DLInformationTransfer_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_DLInformationTransfer 
   (const char* name, const DLInformationTransfer* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_DLInformationTransfer_criticalExtensions ("criticalExtensions", &
      pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_HandoverFromEUTRAPreparationRequest_v920_IEs_nonCriticalExtension 
   (const char* name, const HandoverFromEUTRAPreparationRequest_v920_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_HandoverFromEUTRAPreparationRequest_v920_IEs 
   (const char* name, const HandoverFromEUTRAPreparationRequest_v920_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.concurrPrepCDMA2000_HRPD_r9Present) {
      rtxPrintIndent ();
      rtxPrintBoolean ("concurrPrepCDMA2000_HRPD_r9", pvalue->concurrPrepCDMA2000_HRPD_r9);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_HandoverFromEUTRAPreparationRequest_v920_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_HandoverFromEUTRAPreparationRequest_v890_IEs 
   (const char* name, const HandoverFromEUTRAPreparationRequest_v890_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_HandoverFromEUTRAPreparationRequest_v920_IEs (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_HandoverFromEUTRAPreparationRequest_r8_IEs 
   (const char* name, const HandoverFromEUTRAPreparationRequest_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CDMA2000_Type ("cdma2000_Type", &pvalue->cdma2000_Type);

   if (pvalue->m.rand_Present) {
      asn1Print_RAND_CDMA2000 ("rand_", &pvalue->rand_);
   }

   if (pvalue->m.mobilityParametersPresent) {
      asn1Print_MobilityParametersCDMA2000 ("mobilityParameters", &pvalue->
         mobilityParameters);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_HandoverFromEUTRAPreparationRequest_v890_IEs (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_HandoverFromEUTRAPreparationRequest_criticalExtensions_c1 
   (const char* name, const HandoverFromEUTRAPreparationRequest_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* handoverFromEUTRAPreparationRequest-r8 */
      case 1:
      {
         asn1Print_HandoverFromEUTRAPreparationRequest_r8_IEs (
            "handoverFromEUTRAPreparationRequest-r8", pvalue->
            u.handoverFromEUTRAPreparationRequest_r8);
         break;
      }
      /* spare3 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_HandoverFromEUTRAPreparationRequest_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const HandoverFromEUTRAPreparationRequest_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_HandoverFromEUTRAPreparationRequest_criticalExtensions 
   (const char* name, const HandoverFromEUTRAPreparationRequest_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_HandoverFromEUTRAPreparationRequest_criticalExtensions_c1 (
            "c1", pvalue->u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_HandoverFromEUTRAPreparationRequest_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_HandoverFromEUTRAPreparationRequest 
   (const char* name, const HandoverFromEUTRAPreparationRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_HandoverFromEUTRAPreparationRequest_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_SystemInfoListGERAN 
   (const char* name, const SystemInfoListGERAN* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_SystemInfoListGERAN_element (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_SI_OrPSI_GERAN (const char* name, const SI_OrPSI_GERAN* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* si */
      case 1:
      {
         asn1Print_SystemInfoListGERAN ("si", pvalue->u.si);
         break;
      }
      /* psi */
      case 2:
      {
         asn1Print_SystemInfoListGERAN ("psi", pvalue->u.psi);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_Handover (const char* name, const Handover* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_Handover_targetRAT_Type ("targetRAT_Type", &pvalue->targetRAT_Type
      );

   rtxPrintIndent ();
   rtxPrintHexStr ("targetRAT_MessageContainer", pvalue->targetRAT_MessageContainer.numocts, pvalue->targetRAT_MessageContainer.data);

   if (pvalue->m.nas_SecurityParamFromEUTRAPresent) {
      asn1Print_Handover_nas_SecurityParamFromEUTRA (
         "nas_SecurityParamFromEUTRA", &pvalue->nas_SecurityParamFromEUTRA);
   }

   if (pvalue->m.systemInformationPresent) {
      asn1Print_SI_OrPSI_GERAN ("systemInformation", &pvalue->systemInformation
         );
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PhysCellIdGERAN 
   (const char* name, const PhysCellIdGERAN* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("networkColourCode", pvalue->networkColourCode.numbits, pvalue->networkColourCode.data);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("baseStationColourCode", pvalue->baseStationColourCode.numbits, pvalue->baseStationColourCode.data);

   rtxPrintCloseBrace ();
}

void asn1Print_CarrierFreqGERAN 
   (const char* name, const CarrierFreqGERAN* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ARFCN_ValueGERAN ("arfcn", &pvalue->arfcn);

   asn1Print_BandIndicatorGERAN ("bandIndicator", &pvalue->bandIndicator);

   rtxPrintCloseBrace ();
}

void asn1Print_CellChangeOrder_targetRAT_Type_geran 
   (const char* name, const CellChangeOrder_targetRAT_Type_geran* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PhysCellIdGERAN ("physCellId", &pvalue->physCellId);

   asn1Print_CarrierFreqGERAN ("carrierFreq", &pvalue->carrierFreq);

   if (pvalue->m.networkControlOrderPresent) {
      rtxPrintIndent ();
      rtPrintBitStrBraceText ("networkControlOrder", pvalue->networkControlOrder.numbits, pvalue->networkControlOrder.data);
   }

   if (pvalue->m.systemInformationPresent) {
      asn1Print_SI_OrPSI_GERAN ("systemInformation", &pvalue->systemInformation
         );
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CellChangeOrder_targetRAT_Type 
   (const char* name, const CellChangeOrder_targetRAT_Type* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* geran */
      case 1:
      {
         asn1Print_CellChangeOrder_targetRAT_Type_geran ("geran", pvalue->
            u.geran);
         break;
      }
      /* extElem1 */
      case 2:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CellChangeOrder 
   (const char* name, const CellChangeOrder* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CellChangeOrder_t304 ("t304", &pvalue->t304);

   asn1Print_CellChangeOrder_targetRAT_Type ("targetRAT_Type", &pvalue->
      targetRAT_Type);

   rtxPrintCloseBrace ();
}

void asn1Print_MobilityFromEUTRACommand_r8_IEs_purpose 
   (const char* name, const MobilityFromEUTRACommand_r8_IEs_purpose* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* handover */
      case 1:
      {
         asn1Print_Handover ("handover", pvalue->u.handover);
         break;
      }
      /* cellChangeOrder */
      case 2:
      {
         asn1Print_CellChangeOrder ("cellChangeOrder", pvalue->
            u.cellChangeOrder);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MobilityFromEUTRACommand_v8d0_IEs_nonCriticalExtension 
   (const char* name, const MobilityFromEUTRACommand_v8d0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_MobilityFromEUTRACommand_v8d0_IEs 
   (const char* name, const MobilityFromEUTRACommand_v8d0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.bandIndicatorPresent) {
      asn1Print_BandIndicatorGERAN ("bandIndicator", &pvalue->bandIndicator);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_MobilityFromEUTRACommand_v8d0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MobilityFromEUTRACommand_v8a0_IEs 
   (const char* name, const MobilityFromEUTRACommand_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_MobilityFromEUTRACommand_v8d0_IEs ("nonCriticalExtension", &
         pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MobilityFromEUTRACommand_r8_IEs 
   (const char* name, const MobilityFromEUTRACommand_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("cs_FallbackIndicator", pvalue->cs_FallbackIndicator);

   asn1Print_MobilityFromEUTRACommand_r8_IEs_purpose ("purpose", &pvalue->
      purpose);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_MobilityFromEUTRACommand_v8a0_IEs ("nonCriticalExtension", &
         pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CarrierFreqCDMA2000 
   (const char* name, const CarrierFreqCDMA2000* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_BandclassCDMA2000 ("bandClass", &pvalue->bandClass);

   asn1Print_ARFCN_ValueCDMA2000 ("arfcn", &pvalue->arfcn);

   rtxPrintCloseBrace ();
}

void asn1Print_E_CSFB_r9 (const char* name, const E_CSFB_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.messageContCDMA2000_1XRTT_r9Present) {
      rtxPrintIndent ();
      rtxPrintHexStr ("messageContCDMA2000_1XRTT_r9", pvalue->messageContCDMA2000_1XRTT_r9.numocts, pvalue->messageContCDMA2000_1XRTT_r9.data);
   }

   if (pvalue->m.mobilityCDMA2000_HRPD_r9Present) {
      asn1Print_E_CSFB_r9_mobilityCDMA2000_HRPD_r9 (
         "mobilityCDMA2000_HRPD_r9", &pvalue->mobilityCDMA2000_HRPD_r9);
   }

   if (pvalue->m.messageContCDMA2000_HRPD_r9Present) {
      rtxPrintIndent ();
      rtxPrintHexStr ("messageContCDMA2000_HRPD_r9", pvalue->messageContCDMA2000_HRPD_r9.numocts, pvalue->messageContCDMA2000_HRPD_r9.data);
   }

   if (pvalue->m.redirectCarrierCDMA2000_HRPD_r9Present) {
      asn1Print_CarrierFreqCDMA2000 ("redirectCarrierCDMA2000_HRPD_r9", &pvalue
         ->redirectCarrierCDMA2000_HRPD_r9);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MobilityFromEUTRACommand_r9_IEs_purpose 
   (const char* name, const MobilityFromEUTRACommand_r9_IEs_purpose* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* handover */
      case 1:
      {
         asn1Print_Handover ("handover", pvalue->u.handover);
         break;
      }
      /* cellChangeOrder */
      case 2:
      {
         asn1Print_CellChangeOrder ("cellChangeOrder", pvalue->
            u.cellChangeOrder);
         break;
      }
      /* e-CSFB-r9 */
      case 3:
      {
         asn1Print_E_CSFB_r9 ("e-CSFB-r9", pvalue->u.e_CSFB_r9);
         break;
      }
      /* extElem1 */
      case 4:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MobilityFromEUTRACommand_v960_IEs_nonCriticalExtension 
   (const char* name, const MobilityFromEUTRACommand_v960_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_MobilityFromEUTRACommand_v960_IEs 
   (const char* name, const MobilityFromEUTRACommand_v960_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.bandIndicatorPresent) {
      asn1Print_BandIndicatorGERAN ("bandIndicator", &pvalue->bandIndicator);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_MobilityFromEUTRACommand_v960_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MobilityFromEUTRACommand_v930_IEs 
   (const char* name, const MobilityFromEUTRACommand_v930_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_MobilityFromEUTRACommand_v960_IEs ("nonCriticalExtension", &
         pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MobilityFromEUTRACommand_r9_IEs 
   (const char* name, const MobilityFromEUTRACommand_r9_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("cs_FallbackIndicator", pvalue->cs_FallbackIndicator);

   asn1Print_MobilityFromEUTRACommand_r9_IEs_purpose ("purpose", &pvalue->
      purpose);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_MobilityFromEUTRACommand_v930_IEs ("nonCriticalExtension", &
         pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MobilityFromEUTRACommand_criticalExtensions_c1 
   (const char* name, const MobilityFromEUTRACommand_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* mobilityFromEUTRACommand-r8 */
      case 1:
      {
         asn1Print_MobilityFromEUTRACommand_r8_IEs (
            "mobilityFromEUTRACommand-r8", pvalue->
            u.mobilityFromEUTRACommand_r8);
         break;
      }
      /* mobilityFromEUTRACommand-r9 */
      case 2:
      {
         asn1Print_MobilityFromEUTRACommand_r9_IEs (
            "mobilityFromEUTRACommand-r9", pvalue->
            u.mobilityFromEUTRACommand_r9);
         break;
      }
      /* spare2 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MobilityFromEUTRACommand_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const MobilityFromEUTRACommand_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_MobilityFromEUTRACommand_criticalExtensions 
   (const char* name, const MobilityFromEUTRACommand_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_MobilityFromEUTRACommand_criticalExtensions_c1 ("c1", pvalue
            ->u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_MobilityFromEUTRACommand_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MobilityFromEUTRACommand 
   (const char* name, const MobilityFromEUTRACommand* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_MobilityFromEUTRACommand_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasObjectToRemoveList 
   (const char* name, const MeasObjectToRemoveList* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MeasObjectId (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_CellIndexList (const char* name, const CellIndexList* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_CellIndex (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_CellsToAddMod (const char* name, const CellsToAddMod* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("cellIndex", pvalue->cellIndex);

   asn1Print_PhysCellId ("physCellId", &pvalue->physCellId);

   asn1Print_Q_OffsetRange ("cellIndividualOffset", &pvalue->
      cellIndividualOffset);

   rtxPrintCloseBrace ();
}

void asn1Print_CellsToAddModList 
   (const char* name, const CellsToAddModList* pvalue)
{
   CellsToAddMod* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (CellsToAddMod*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_CellsToAddMod (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_BlackCellsToAddMod 
   (const char* name, const BlackCellsToAddMod* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("cellIndex", pvalue->cellIndex);

   asn1Print_PhysCellIdRange ("physCellIdRange", &pvalue->physCellIdRange);

   rtxPrintCloseBrace ();
}

void asn1Print_BlackCellsToAddModList 
   (const char* name, const BlackCellsToAddModList* pvalue)
{
   BlackCellsToAddMod* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (BlackCellsToAddMod*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_BlackCellsToAddMod (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_MeasObjectEUTRA 
   (const char* name, const MeasObjectEUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ARFCN_ValueEUTRA ("carrierFreq", &pvalue->carrierFreq);

   asn1Print_AllowedMeasBandwidth ("allowedMeasBandwidth", &pvalue->
      allowedMeasBandwidth);

   asn1Print_PresenceAntennaPort1 ("presenceAntennaPort1", &pvalue->
      presenceAntennaPort1);

   asn1Print_NeighCellConfig ("neighCellConfig", &pvalue->neighCellConfig);

   asn1Print_Q_OffsetRange ("offsetFreq", &pvalue->offsetFreq);

   if (pvalue->m.cellsToRemoveListPresent) {
      asn1Print_CellIndexList ("cellsToRemoveList", &pvalue->cellsToRemoveList
         );
   }

   if (pvalue->m.cellsToAddModListPresent) {
      asn1Print_CellsToAddModList ("cellsToAddModList", &pvalue->
         cellsToAddModList);
   }

   if (pvalue->m.blackCellsToRemoveListPresent) {
      asn1Print_CellIndexList ("blackCellsToRemoveList", &pvalue->
         blackCellsToRemoveList);
   }

   if (pvalue->m.blackCellsToAddModListPresent) {
      asn1Print_BlackCellsToAddModList ("blackCellsToAddModList", &pvalue->
         blackCellsToAddModList);
   }

   if (pvalue->m.cellForWhichToReportCGIPresent) {
      asn1Print_PhysCellId ("cellForWhichToReportCGI", &pvalue->
         cellForWhichToReportCGI);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_CellsToAddModUTRA_FDD 
   (const char* name, const CellsToAddModUTRA_FDD* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("cellIndex", pvalue->cellIndex);

   asn1Print_PhysCellIdUTRA_FDD ("physCellId", &pvalue->physCellId);

   rtxPrintCloseBrace ();
}

void asn1Print_CellsToAddModListUTRA_FDD 
   (const char* name, const CellsToAddModListUTRA_FDD* pvalue)
{
   CellsToAddModUTRA_FDD* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (CellsToAddModUTRA_FDD*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_CellsToAddModUTRA_FDD (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_CellsToAddModUTRA_TDD 
   (const char* name, const CellsToAddModUTRA_TDD* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("cellIndex", pvalue->cellIndex);

   asn1Print_PhysCellIdUTRA_TDD ("physCellId", &pvalue->physCellId);

   rtxPrintCloseBrace ();
}

void asn1Print_CellsToAddModListUTRA_TDD 
   (const char* name, const CellsToAddModListUTRA_TDD* pvalue)
{
   CellsToAddModUTRA_TDD* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (CellsToAddModUTRA_TDD*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_CellsToAddModUTRA_TDD (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_MeasObjectUTRA_cellsToAddModList 
   (const char* name, const MeasObjectUTRA_cellsToAddModList* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* cellsToAddModListUTRA-FDD */
      case 1:
      {
         asn1Print_CellsToAddModListUTRA_FDD ("cellsToAddModListUTRA-FDD", 
            pvalue->u.cellsToAddModListUTRA_FDD);
         break;
      }
      /* cellsToAddModListUTRA-TDD */
      case 2:
      {
         asn1Print_CellsToAddModListUTRA_TDD ("cellsToAddModListUTRA-TDD", 
            pvalue->u.cellsToAddModListUTRA_TDD);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasObjectUTRA_cellForWhichToReportCGI 
   (const char* name, const MeasObjectUTRA_cellForWhichToReportCGI* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* utra-FDD */
      case 1:
      {
         asn1Print_PhysCellIdUTRA_FDD ("utra-FDD", &pvalue->u.utra_FDD);
         break;
      }
      /* utra-TDD */
      case 2:
      {
         asn1Print_PhysCellIdUTRA_TDD ("utra-TDD", &pvalue->u.utra_TDD);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PhysCellIdRangeUTRA_FDD_r9 
   (const char* name, const PhysCellIdRangeUTRA_FDD_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PhysCellIdUTRA_FDD ("start_r9", &pvalue->start_r9);

   if (pvalue->m.range_r9Present) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("range_r9", pvalue->range_r9);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PhysCellIdRangeUTRA_FDDList_r9 
   (const char* name, const PhysCellIdRangeUTRA_FDDList_r9* pvalue)
{
   PhysCellIdRangeUTRA_FDD_r9* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (PhysCellIdRangeUTRA_FDD_r9*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_PhysCellIdRangeUTRA_FDD_r9 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_CSG_AllowedReportingCells_r9 
   (const char* name, const CSG_AllowedReportingCells_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.physCellIdRangeUTRA_FDDList_r9Present) {
      asn1Print_PhysCellIdRangeUTRA_FDDList_r9 (
         "physCellIdRangeUTRA_FDDList_r9", &pvalue->
         physCellIdRangeUTRA_FDDList_r9);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasObjectUTRA (const char* name, const MeasObjectUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ARFCN_ValueUTRA ("carrierFreq", &pvalue->carrierFreq);

   asn1Print_Q_OffsetRangeInterRAT ("offsetFreq", &pvalue->offsetFreq);

   if (pvalue->m.cellsToRemoveListPresent) {
      asn1Print_CellIndexList ("cellsToRemoveList", &pvalue->cellsToRemoveList
         );
   }

   if (pvalue->m.cellsToAddModListPresent) {
      asn1Print_MeasObjectUTRA_cellsToAddModList ("cellsToAddModList", &pvalue
         ->cellsToAddModList);
   }

   if (pvalue->m.cellForWhichToReportCGIPresent) {
      asn1Print_MeasObjectUTRA_cellForWhichToReportCGI (
         "cellForWhichToReportCGI", &pvalue->cellForWhichToReportCGI);
   }

   if (pvalue->m._v2ExtPresent) {
      if (pvalue->m.csg_allowedReportingCells_v930Present) {
         asn1Print_CSG_AllowedReportingCells_r9 (
            "csg_allowedReportingCells_v930", &pvalue->
            csg_allowedReportingCells_v930);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasObjectGERAN 
   (const char* name, const MeasObjectGERAN* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CarrierFreqsGERAN ("carrierFreqs", &pvalue->carrierFreqs);

   asn1Print_Q_OffsetRangeInterRAT ("offsetFreq", &pvalue->offsetFreq);

   if (pvalue->m.ncc_PermittedPresent) {
      rtxPrintIndent ();
      rtPrintBitStrBraceText ("ncc_Permitted", pvalue->ncc_Permitted.numbits, pvalue->ncc_Permitted.data);
   }

   if (pvalue->m.cellForWhichToReportCGIPresent) {
      asn1Print_PhysCellIdGERAN ("cellForWhichToReportCGI", &pvalue->
         cellForWhichToReportCGI);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_CellsToAddModCDMA2000 
   (const char* name, const CellsToAddModCDMA2000* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("cellIndex", pvalue->cellIndex);

   asn1Print_PhysCellIdCDMA2000 ("physCellId", &pvalue->physCellId);

   rtxPrintCloseBrace ();
}

void asn1Print_CellsToAddModListCDMA2000 
   (const char* name, const CellsToAddModListCDMA2000* pvalue)
{
   CellsToAddModCDMA2000* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (CellsToAddModCDMA2000*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_CellsToAddModCDMA2000 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_MeasObjectCDMA2000 
   (const char* name, const MeasObjectCDMA2000* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CDMA2000_Type ("cdma2000_Type", &pvalue->cdma2000_Type);

   asn1Print_CarrierFreqCDMA2000 ("carrierFreq", &pvalue->carrierFreq);

   if (pvalue->m.searchWindowSizePresent) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("searchWindowSize", pvalue->searchWindowSize);
   }

   asn1Print_Q_OffsetRangeInterRAT ("offsetFreq", &pvalue->offsetFreq);

   if (pvalue->m.cellsToRemoveListPresent) {
      asn1Print_CellIndexList ("cellsToRemoveList", &pvalue->cellsToRemoveList
         );
   }

   if (pvalue->m.cellsToAddModListPresent) {
      asn1Print_CellsToAddModListCDMA2000 ("cellsToAddModList", &pvalue->
         cellsToAddModList);
   }

   if (pvalue->m.cellForWhichToReportCGIPresent) {
      asn1Print_PhysCellIdCDMA2000 ("cellForWhichToReportCGI", &pvalue->
         cellForWhichToReportCGI);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasObjectToAddMod_measObject 
   (const char* name, const MeasObjectToAddMod_measObject* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* measObjectEUTRA */
      case 1:
      {
         asn1Print_MeasObjectEUTRA ("measObjectEUTRA", pvalue->
            u.measObjectEUTRA);
         break;
      }
      /* measObjectUTRA */
      case 2:
      {
         asn1Print_MeasObjectUTRA ("measObjectUTRA", pvalue->u.measObjectUTRA
            );
         break;
      }
      /* measObjectGERAN */
      case 3:
      {
         asn1Print_MeasObjectGERAN ("measObjectGERAN", pvalue->
            u.measObjectGERAN);
         break;
      }
      /* measObjectCDMA2000 */
      case 4:
      {
         asn1Print_MeasObjectCDMA2000 ("measObjectCDMA2000", pvalue->
            u.measObjectCDMA2000);
         break;
      }
      /* extElem1 */
      case 5:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasObjectToAddMod 
   (const char* name, const MeasObjectToAddMod* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MeasObjectId ("measObjectId", &pvalue->measObjectId);

   asn1Print_MeasObjectToAddMod_measObject ("measObject", &pvalue->measObject
      );

   rtxPrintCloseBrace ();
}

void asn1Print_MeasObjectToAddModList 
   (const char* name, const MeasObjectToAddModList* pvalue)
{
   MeasObjectToAddMod* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (MeasObjectToAddMod*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MeasObjectToAddMod (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_ReportConfigToRemoveList 
   (const char* name, const ReportConfigToRemoveList* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ReportConfigId (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ThresholdEUTRA (const char* name, const ThresholdEUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* threshold-RSRP */
      case 1:
      {
         asn1Print_RSRP_Range ("threshold-RSRP", &pvalue->u.threshold_RSRP);
         break;
      }
      /* threshold-RSRQ */
      case 2:
      {
         asn1Print_RSRQ_Range ("threshold-RSRQ", &pvalue->u.threshold_RSRQ);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigEUTRA_triggerType_event_eventId_eventA1 
   (const char* name, const ReportConfigEUTRA_triggerType_event_eventId_eventA1* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ThresholdEUTRA ("a1_Threshold", &pvalue->a1_Threshold);

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigEUTRA_triggerType_event_eventId_eventA2 
   (const char* name, const ReportConfigEUTRA_triggerType_event_eventId_eventA2* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ThresholdEUTRA ("a2_Threshold", &pvalue->a2_Threshold);

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigEUTRA_triggerType_event_eventId_eventA3 
   (const char* name, const ReportConfigEUTRA_triggerType_event_eventId_eventA3* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintInteger ("a3_Offset", pvalue->a3_Offset);

   rtxPrintIndent ();
   rtxPrintBoolean ("reportOnLeave", pvalue->reportOnLeave);

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigEUTRA_triggerType_event_eventId_eventA4 
   (const char* name, const ReportConfigEUTRA_triggerType_event_eventId_eventA4* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ThresholdEUTRA ("a4_Threshold", &pvalue->a4_Threshold);

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigEUTRA_triggerType_event_eventId_eventA5 
   (const char* name, const ReportConfigEUTRA_triggerType_event_eventId_eventA5* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ThresholdEUTRA ("a5_Threshold1", &pvalue->a5_Threshold1);

   asn1Print_ThresholdEUTRA ("a5_Threshold2", &pvalue->a5_Threshold2);

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigEUTRA_triggerType_event_eventId 
   (const char* name, const ReportConfigEUTRA_triggerType_event_eventId* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* eventA1 */
      case 1:
      {
         asn1Print_ReportConfigEUTRA_triggerType_event_eventId_eventA1 (
            "eventA1", pvalue->u.eventA1);
         break;
      }
      /* eventA2 */
      case 2:
      {
         asn1Print_ReportConfigEUTRA_triggerType_event_eventId_eventA2 (
            "eventA2", pvalue->u.eventA2);
         break;
      }
      /* eventA3 */
      case 3:
      {
         asn1Print_ReportConfigEUTRA_triggerType_event_eventId_eventA3 (
            "eventA3", pvalue->u.eventA3);
         break;
      }
      /* eventA4 */
      case 4:
      {
         asn1Print_ReportConfigEUTRA_triggerType_event_eventId_eventA4 (
            "eventA4", pvalue->u.eventA4);
         break;
      }
      /* eventA5 */
      case 5:
      {
         asn1Print_ReportConfigEUTRA_triggerType_event_eventId_eventA5 (
            "eventA5", pvalue->u.eventA5);
         break;
      }
      /* extElem1 */
      case 6:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigEUTRA_triggerType_event 
   (const char* name, const ReportConfigEUTRA_triggerType_event* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ReportConfigEUTRA_triggerType_event_eventId ("eventId", &pvalue->
      eventId);

   asn1Print_Hysteresis ("hysteresis", &pvalue->hysteresis);

   asn1Print_TimeToTrigger ("timeToTrigger", &pvalue->timeToTrigger);

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigEUTRA_triggerType_periodical 
   (const char* name, const ReportConfigEUTRA_triggerType_periodical* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ReportConfigEUTRA_triggerType_periodical_purpose ("purpose", &
      pvalue->purpose);

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigEUTRA_triggerType 
   (const char* name, const ReportConfigEUTRA_triggerType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* event */
      case 1:
      {
         asn1Print_ReportConfigEUTRA_triggerType_event ("event", pvalue->
            u.event);
         break;
      }
      /* periodical */
      case 2:
      {
         asn1Print_ReportConfigEUTRA_triggerType_periodical ("periodical", 
            pvalue->u.periodical);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigEUTRA 
   (const char* name, const ReportConfigEUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ReportConfigEUTRA_triggerType ("triggerType", &pvalue->triggerType
      );

   asn1Print_ReportConfigEUTRA_triggerQuantity ("triggerQuantity", &pvalue->
      triggerQuantity);

   asn1Print_ReportConfigEUTRA_reportQuantity ("reportQuantity", &pvalue->
      reportQuantity);

   rtxPrintIndent ();
   rtxPrintUnsigned ("maxReportCells", pvalue->maxReportCells);

   asn1Print_ReportInterval ("reportInterval", &pvalue->reportInterval);

   asn1Print_ReportConfigEUTRA_reportAmount ("reportAmount", &pvalue->
      reportAmount);

   if (pvalue->m._v2ExtPresent) {
      if (pvalue->m.si_RequestForHO_r9Present) {
         asn1Print_ReportConfigEUTRA_si_RequestForHO_r9 ("si_RequestForHO_r9", 
            &pvalue->si_RequestForHO_r9);
      }
      if (pvalue->m.ue_RxTxTimeDiffPeriodical_r9Present) {
         asn1Print_ReportConfigEUTRA_ue_RxTxTimeDiffPeriodical_r9 (
            "ue_RxTxTimeDiffPeriodical_r9", &pvalue->
            ue_RxTxTimeDiffPeriodical_r9);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ThresholdUTRA (const char* name, const ThresholdUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* utra-RSCP */
      case 1:
      {
         rtxPrintIndent ();
         rtxPrintInteger ("utra-RSCP", pvalue->u.utra_RSCP);
         break;
      }
      /* utra-EcN0 */
      case 2:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("utra-EcN0", pvalue->u.utra_EcN0);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold 
   (const char* name, const ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* b1-ThresholdUTRA */
      case 1:
      {
         asn1Print_ThresholdUTRA ("b1-ThresholdUTRA", pvalue->
            u.b1_ThresholdUTRA);
         break;
      }
      /* b1-ThresholdGERAN */
      case 2:
      {
         asn1Print_ThresholdGERAN ("b1-ThresholdGERAN", &pvalue->
            u.b1_ThresholdGERAN);
         break;
      }
      /* b1-ThresholdCDMA2000 */
      case 3:
      {
         asn1Print_ThresholdCDMA2000 ("b1-ThresholdCDMA2000", &pvalue->
            u.b1_ThresholdCDMA2000);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigInterRAT_triggerType_event_eventId_eventB1 
   (const char* name, const ReportConfigInterRAT_triggerType_event_eventId_eventB1* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ReportConfigInterRAT_triggerType_event_eventId_eventB1_b1_Threshold (
      "b1_Threshold", &pvalue->b1_Threshold);

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2 
   (const char* name, const ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* b2-Threshold2UTRA */
      case 1:
      {
         asn1Print_ThresholdUTRA ("b2-Threshold2UTRA", pvalue->
            u.b2_Threshold2UTRA);
         break;
      }
      /* b2-Threshold2GERAN */
      case 2:
      {
         asn1Print_ThresholdGERAN ("b2-Threshold2GERAN", &pvalue->
            u.b2_Threshold2GERAN);
         break;
      }
      /* b2-Threshold2CDMA2000 */
      case 3:
      {
         asn1Print_ThresholdCDMA2000 ("b2-Threshold2CDMA2000", &pvalue->
            u.b2_Threshold2CDMA2000);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigInterRAT_triggerType_event_eventId_eventB2 
   (const char* name, const ReportConfigInterRAT_triggerType_event_eventId_eventB2* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ThresholdEUTRA ("b2_Threshold1", &pvalue->b2_Threshold1);

   asn1Print_ReportConfigInterRAT_triggerType_event_eventId_eventB2_b2_Threshold2 (
      "b2_Threshold2", &pvalue->b2_Threshold2);

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigInterRAT_triggerType_event_eventId 
   (const char* name, const ReportConfigInterRAT_triggerType_event_eventId* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* eventB1 */
      case 1:
      {
         asn1Print_ReportConfigInterRAT_triggerType_event_eventId_eventB1 (
            "eventB1", pvalue->u.eventB1);
         break;
      }
      /* eventB2 */
      case 2:
      {
         asn1Print_ReportConfigInterRAT_triggerType_event_eventId_eventB2 (
            "eventB2", pvalue->u.eventB2);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigInterRAT_triggerType_event 
   (const char* name, const ReportConfigInterRAT_triggerType_event* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ReportConfigInterRAT_triggerType_event_eventId ("eventId", &pvalue
      ->eventId);

   asn1Print_Hysteresis ("hysteresis", &pvalue->hysteresis);

   asn1Print_TimeToTrigger ("timeToTrigger", &pvalue->timeToTrigger);

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigInterRAT_triggerType_periodical 
   (const char* name, const ReportConfigInterRAT_triggerType_periodical* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ReportConfigInterRAT_triggerType_periodical_purpose ("purpose", &
      pvalue->purpose);

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigInterRAT_triggerType 
   (const char* name, const ReportConfigInterRAT_triggerType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* event */
      case 1:
      {
         asn1Print_ReportConfigInterRAT_triggerType_event ("event", pvalue->
            u.event);
         break;
      }
      /* periodical */
      case 2:
      {
         asn1Print_ReportConfigInterRAT_triggerType_periodical ("periodical", 
            pvalue->u.periodical);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigInterRAT 
   (const char* name, const ReportConfigInterRAT* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ReportConfigInterRAT_triggerType ("triggerType", &pvalue->
      triggerType);

   rtxPrintIndent ();
   rtxPrintUnsigned ("maxReportCells", pvalue->maxReportCells);

   asn1Print_ReportInterval ("reportInterval", &pvalue->reportInterval);

   asn1Print_ReportConfigInterRAT_reportAmount ("reportAmount", &pvalue->
      reportAmount);

   if (pvalue->m._v2ExtPresent) {
      if (pvalue->m.si_RequestForHO_r9Present) {
         asn1Print_ReportConfigInterRAT_si_RequestForHO_r9 (
            "si_RequestForHO_r9", &pvalue->si_RequestForHO_r9);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigToAddMod_reportConfig 
   (const char* name, const ReportConfigToAddMod_reportConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* reportConfigEUTRA */
      case 1:
      {
         asn1Print_ReportConfigEUTRA ("reportConfigEUTRA", pvalue->
            u.reportConfigEUTRA);
         break;
      }
      /* reportConfigInterRAT */
      case 2:
      {
         asn1Print_ReportConfigInterRAT ("reportConfigInterRAT", pvalue->
            u.reportConfigInterRAT);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigToAddMod 
   (const char* name, const ReportConfigToAddMod* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ReportConfigId ("reportConfigId", &pvalue->reportConfigId);

   asn1Print_ReportConfigToAddMod_reportConfig ("reportConfig", &pvalue->
      reportConfig);

   rtxPrintCloseBrace ();
}

void asn1Print_ReportConfigToAddModList 
   (const char* name, const ReportConfigToAddModList* pvalue)
{
   ReportConfigToAddMod* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (ReportConfigToAddMod*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ReportConfigToAddMod (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_MeasIdToRemoveList 
   (const char* name, const MeasIdToRemoveList* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MeasId (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_MeasIdToAddMod (const char* name, const MeasIdToAddMod* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MeasId ("measId", &pvalue->measId);

   asn1Print_MeasObjectId ("measObjectId", &pvalue->measObjectId);

   asn1Print_ReportConfigId ("reportConfigId", &pvalue->reportConfigId);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasIdToAddModList 
   (const char* name, const MeasIdToAddModList* pvalue)
{
   MeasIdToAddMod* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (MeasIdToAddMod*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MeasIdToAddMod (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_QuantityConfigEUTRA 
   (const char* name, const QuantityConfigEUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_FilterCoefficient ("filterCoefficientRSRP", &pvalue->
      filterCoefficientRSRP);

   asn1Print_FilterCoefficient ("filterCoefficientRSRQ", &pvalue->
      filterCoefficientRSRQ);

   rtxPrintCloseBrace ();
}

void asn1Print_QuantityConfigUTRA 
   (const char* name, const QuantityConfigUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_QuantityConfigUTRA_measQuantityUTRA_FDD ("measQuantityUTRA_FDD", &
      pvalue->measQuantityUTRA_FDD);

   asn1Print_QuantityConfigUTRA_measQuantityUTRA_TDD ("measQuantityUTRA_TDD", &
      pvalue->measQuantityUTRA_TDD);

   asn1Print_FilterCoefficient ("filterCoefficient", &pvalue->filterCoefficient
      );

   rtxPrintCloseBrace ();
}

void asn1Print_QuantityConfigGERAN 
   (const char* name, const QuantityConfigGERAN* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_QuantityConfigGERAN_measQuantityGERAN ("measQuantityGERAN", &
      pvalue->measQuantityGERAN);

   asn1Print_FilterCoefficient ("filterCoefficient", &pvalue->filterCoefficient
      );

   rtxPrintCloseBrace ();
}

void asn1Print_QuantityConfigCDMA2000 
   (const char* name, const QuantityConfigCDMA2000* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_QuantityConfigCDMA2000_measQuantityCDMA2000 (
      "measQuantityCDMA2000", &pvalue->measQuantityCDMA2000);

   rtxPrintCloseBrace ();
}

void asn1Print_QuantityConfig (const char* name, const QuantityConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.quantityConfigEUTRAPresent) {
      asn1Print_QuantityConfigEUTRA ("quantityConfigEUTRA", &pvalue->
         quantityConfigEUTRA);
   }

   if (pvalue->m.quantityConfigUTRAPresent) {
      asn1Print_QuantityConfigUTRA ("quantityConfigUTRA", &pvalue->
         quantityConfigUTRA);
   }

   if (pvalue->m.quantityConfigGERANPresent) {
      asn1Print_QuantityConfigGERAN ("quantityConfigGERAN", &pvalue->
         quantityConfigGERAN);
   }

   if (pvalue->m.quantityConfigCDMA2000Present) {
      asn1Print_QuantityConfigCDMA2000 ("quantityConfigCDMA2000", &pvalue->
         quantityConfigCDMA2000);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasGapConfig_setup_gapOffset 
   (const char* name, const MeasGapConfig_setup_gapOffset* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* gp0 */
      case 1:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("gp0", pvalue->u.gp0);
         break;
      }
      /* gp1 */
      case 2:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("gp1", pvalue->u.gp1);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasGapConfig_setup 
   (const char* name, const MeasGapConfig_setup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MeasGapConfig_setup_gapOffset ("gapOffset", &pvalue->gapOffset);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasGapConfig (const char* name, const MeasGapConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_MeasGapConfig_setup ("setup", pvalue->u.setup);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasConfig_speedStatePars_setup 
   (const char* name, const MeasConfig_speedStatePars_setup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MobilityStateParameters ("mobilityStateParameters", &pvalue->
      mobilityStateParameters);

   asn1Print_SpeedStateScaleFactors ("timeToTrigger_SF", &pvalue->
      timeToTrigger_SF);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasConfig_speedStatePars 
   (const char* name, const MeasConfig_speedStatePars* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_MeasConfig_speedStatePars_setup ("setup", pvalue->u.setup);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasConfig (const char* name, const MeasConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.measObjectToRemoveListPresent) {
      asn1Print_MeasObjectToRemoveList ("measObjectToRemoveList", &pvalue->
         measObjectToRemoveList);
   }

   if (pvalue->m.measObjectToAddModListPresent) {
      asn1Print_MeasObjectToAddModList ("measObjectToAddModList", &pvalue->
         measObjectToAddModList);
   }

   if (pvalue->m.reportConfigToRemoveListPresent) {
      asn1Print_ReportConfigToRemoveList ("reportConfigToRemoveList", &pvalue->
         reportConfigToRemoveList);
   }

   if (pvalue->m.reportConfigToAddModListPresent) {
      asn1Print_ReportConfigToAddModList ("reportConfigToAddModList", &pvalue->
         reportConfigToAddModList);
   }

   if (pvalue->m.measIdToRemoveListPresent) {
      asn1Print_MeasIdToRemoveList ("measIdToRemoveList", &pvalue->
         measIdToRemoveList);
   }

   if (pvalue->m.measIdToAddModListPresent) {
      asn1Print_MeasIdToAddModList ("measIdToAddModList", &pvalue->
         measIdToAddModList);
   }

   if (pvalue->m.quantityConfigPresent) {
      asn1Print_QuantityConfig ("quantityConfig", &pvalue->quantityConfig);
   }

   if (pvalue->m.measGapConfigPresent) {
      asn1Print_MeasGapConfig ("measGapConfig", &pvalue->measGapConfig);
   }

   if (pvalue->m.s_MeasurePresent) {
      asn1Print_RSRP_Range ("s_Measure", &pvalue->s_Measure);
   }

   if (pvalue->m.preRegistrationInfoHRPDPresent) {
      asn1Print_PreRegistrationInfoHRPD ("preRegistrationInfoHRPD", &pvalue->
         preRegistrationInfoHRPD);
   }

   if (pvalue->m.speedStateParsPresent) {
      asn1Print_MeasConfig_speedStatePars ("speedStatePars", &pvalue->
         speedStatePars);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_CarrierFreqEUTRA 
   (const char* name, const CarrierFreqEUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ARFCN_ValueEUTRA ("dl_CarrierFreq", &pvalue->dl_CarrierFreq);

   if (pvalue->m.ul_CarrierFreqPresent) {
      asn1Print_ARFCN_ValueEUTRA ("ul_CarrierFreq", &pvalue->ul_CarrierFreq);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CarrierBandwidthEUTRA 
   (const char* name, const CarrierBandwidthEUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CarrierBandwidthEUTRA_dl_Bandwidth ("dl_Bandwidth", &pvalue->
      dl_Bandwidth);

   if (pvalue->m.ul_BandwidthPresent) {
      asn1Print_CarrierBandwidthEUTRA_ul_Bandwidth ("ul_Bandwidth", &pvalue->
         ul_Bandwidth);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PRACH_Config (const char* name, const PRACH_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("rootSequenceIndex", pvalue->rootSequenceIndex);

   if (pvalue->m.prach_ConfigInfoPresent) {
      asn1Print_PRACH_ConfigInfo ("prach_ConfigInfo", &pvalue->prach_ConfigInfo
         );
   }

   rtxPrintCloseBrace ();
}

void asn1Print_AntennaInfoCommon 
   (const char* name, const AntennaInfoCommon* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_AntennaInfoCommon_antennaPortsCount ("antennaPortsCount", &pvalue
      ->antennaPortsCount);

   rtxPrintCloseBrace ();
}

void asn1Print_RadioResourceConfigCommon 
   (const char* name, const RadioResourceConfigCommon* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.rach_ConfigCommonPresent) {
      asn1Print_RACH_ConfigCommon ("rach_ConfigCommon", &pvalue->
         rach_ConfigCommon);
   }

   asn1Print_PRACH_Config ("prach_Config", &pvalue->prach_Config);

   if (pvalue->m.pdsch_ConfigCommonPresent) {
      asn1Print_PDSCH_ConfigCommon ("pdsch_ConfigCommon", &pvalue->
         pdsch_ConfigCommon);
   }

   asn1Print_PUSCH_ConfigCommon ("pusch_ConfigCommon", &pvalue->
      pusch_ConfigCommon);

   if (pvalue->m.phich_ConfigPresent) {
      asn1Print_PHICH_Config ("phich_Config", &pvalue->phich_Config);
   }

   if (pvalue->m.pucch_ConfigCommonPresent) {
      asn1Print_PUCCH_ConfigCommon ("pucch_ConfigCommon", &pvalue->
         pucch_ConfigCommon);
   }

   if (pvalue->m.soundingRS_UL_ConfigCommonPresent) {
      asn1Print_SoundingRS_UL_ConfigCommon ("soundingRS_UL_ConfigCommon", &
         pvalue->soundingRS_UL_ConfigCommon);
   }

   if (pvalue->m.uplinkPowerControlCommonPresent) {
      asn1Print_UplinkPowerControlCommon ("uplinkPowerControlCommon", &pvalue->
         uplinkPowerControlCommon);
   }

   if (pvalue->m.antennaInfoCommonPresent) {
      asn1Print_AntennaInfoCommon ("antennaInfoCommon", &pvalue->
         antennaInfoCommon);
   }

   if (pvalue->m.p_MaxPresent) {
      asn1Print_P_Max ("p_Max", &pvalue->p_Max);
   }

   if (pvalue->m.tdd_ConfigPresent) {
      asn1Print_TDD_Config ("tdd_Config", &pvalue->tdd_Config);
   }

   asn1Print_UL_CyclicPrefixLength ("ul_CyclicPrefixLength", &pvalue->
      ul_CyclicPrefixLength);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_RACH_ConfigDedicated 
   (const char* name, const RACH_ConfigDedicated* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ra_PreambleIndex", pvalue->ra_PreambleIndex);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ra_PRACH_MaskIndex", pvalue->ra_PRACH_MaskIndex);

   rtxPrintCloseBrace ();
}

void asn1Print_MobilityControlInfo 
   (const char* name, const MobilityControlInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PhysCellId ("targetPhysCellId", &pvalue->targetPhysCellId);

   if (pvalue->m.carrierFreqPresent) {
      asn1Print_CarrierFreqEUTRA ("carrierFreq", &pvalue->carrierFreq);
   }

   if (pvalue->m.carrierBandwidthPresent) {
      asn1Print_CarrierBandwidthEUTRA ("carrierBandwidth", &pvalue->
         carrierBandwidth);
   }

   if (pvalue->m.additionalSpectrumEmissionPresent) {
      asn1Print_AdditionalSpectrumEmission ("additionalSpectrumEmission", &
         pvalue->additionalSpectrumEmission);
   }

   asn1Print_MobilityControlInfo_t304 ("t304", &pvalue->t304);

   asn1Print_C_RNTI ("newUE_Identity", &pvalue->newUE_Identity);

   asn1Print_RadioResourceConfigCommon ("radioResourceConfigCommon", &pvalue->
      radioResourceConfigCommon);

   if (pvalue->m.rach_ConfigDedicatedPresent) {
      asn1Print_RACH_ConfigDedicated ("rach_ConfigDedicated", &pvalue->
         rach_ConfigDedicated);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReconfiguration_r8_IEs_dedicatedInfoNASList 
   (const char* name, const RRCConnectionReconfiguration_r8_IEs_dedicatedInfoNASList* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_DedicatedInfoNAS (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_SecurityAlgorithmConfig 
   (const char* name, const SecurityAlgorithmConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SecurityAlgorithmConfig_cipheringAlgorithm ("cipheringAlgorithm", 
      &pvalue->cipheringAlgorithm);

   asn1Print_SecurityAlgorithmConfig_integrityProtAlgorithm (
      "integrityProtAlgorithm", &pvalue->integrityProtAlgorithm);

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityConfigHO_handoverType_intraLTE 
   (const char* name, const SecurityConfigHO_handoverType_intraLTE* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.securityAlgorithmConfigPresent) {
      asn1Print_SecurityAlgorithmConfig ("securityAlgorithmConfig", &pvalue->
         securityAlgorithmConfig);
   }

   rtxPrintIndent ();
   rtxPrintBoolean ("keyChangeIndicator", pvalue->keyChangeIndicator);

   asn1Print_NextHopChainingCount ("nextHopChainingCount", &pvalue->
      nextHopChainingCount);

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityConfigHO_handoverType_interRAT 
   (const char* name, const SecurityConfigHO_handoverType_interRAT* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SecurityAlgorithmConfig ("securityAlgorithmConfig", &pvalue->
      securityAlgorithmConfig);

   asn1Print_SecurityConfigHO_handoverType_interRAT_nas_SecurityParamToEUTRA (
      "nas_SecurityParamToEUTRA", &pvalue->nas_SecurityParamToEUTRA);

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityConfigHO_handoverType 
   (const char* name, const SecurityConfigHO_handoverType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* intraLTE */
      case 1:
      {
         asn1Print_SecurityConfigHO_handoverType_intraLTE ("intraLTE", pvalue->
            u.intraLTE);
         break;
      }
      /* interRAT */
      case 2:
      {
         asn1Print_SecurityConfigHO_handoverType_interRAT ("interRAT", pvalue->
            u.interRAT);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityConfigHO 
   (const char* name, const SecurityConfigHO* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SecurityConfigHO_handoverType ("handoverType", &pvalue->
      handoverType);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ReportProximityConfig_r9 
   (const char* name, const ReportProximityConfig_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.proximityIndicationEUTRA_r9Present) {
      asn1Print_ReportProximityConfig_r9_proximityIndicationEUTRA_r9 (
         "proximityIndicationEUTRA_r9", &pvalue->proximityIndicationEUTRA_r9);
   }

   if (pvalue->m.proximityIndicationUTRA_r9Present) {
      asn1Print_ReportProximityConfig_r9_proximityIndicationUTRA_r9 (
         "proximityIndicationUTRA_r9", &pvalue->proximityIndicationUTRA_r9);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_OtherConfig_r9 (const char* name, const OtherConfig_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.reportProximityConfig_r9Present) {
      asn1Print_ReportProximityConfig_r9 ("reportProximityConfig_r9", &pvalue->
         reportProximityConfig_r9);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReconfiguration_v920_IEs_nonCriticalExtension 
   (const char* name, const RRCConnectionReconfiguration_v920_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionReconfiguration_v920_IEs 
   (const char* name, const RRCConnectionReconfiguration_v920_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.otherConfig_r9Present) {
      asn1Print_OtherConfig_r9 ("otherConfig_r9", &pvalue->otherConfig_r9);
   }

   if (pvalue->m.fullConfig_r9Present) {
      asn1Print_RRCConnectionReconfiguration_v920_IEs_fullConfig_r9 (
         "fullConfig_r9", &pvalue->fullConfig_r9);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionReconfiguration_v920_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReconfiguration_v890_IEs 
   (const char* name, const RRCConnectionReconfiguration_v890_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionReconfiguration_v920_IEs ("nonCriticalExtension", 
         &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReconfiguration_r8_IEs 
   (const char* name, const RRCConnectionReconfiguration_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.measConfigPresent) {
      asn1Print_MeasConfig ("measConfig", &pvalue->measConfig);
   }

   if (pvalue->m.mobilityControlInfoPresent) {
      asn1Print_MobilityControlInfo ("mobilityControlInfo", &pvalue->
         mobilityControlInfo);
   }

   if (pvalue->m.dedicatedInfoNASListPresent) {
      asn1Print_RRCConnectionReconfiguration_r8_IEs_dedicatedInfoNASList (
         "dedicatedInfoNASList", &pvalue->dedicatedInfoNASList);
   }

   if (pvalue->m.radioResourceConfigDedicatedPresent) {
      asn1Print_RadioResourceConfigDedicated ("radioResourceConfigDedicated", &
         pvalue->radioResourceConfigDedicated);
   }

   if (pvalue->m.securityConfigHOPresent) {
      asn1Print_SecurityConfigHO ("securityConfigHO", &pvalue->securityConfigHO
         );
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionReconfiguration_v890_IEs ("nonCriticalExtension", 
         &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReconfiguration_criticalExtensions_c1 
   (const char* name, const RRCConnectionReconfiguration_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rrcConnectionReconfiguration-r8 */
      case 1:
      {
         asn1Print_RRCConnectionReconfiguration_r8_IEs (
            "rrcConnectionReconfiguration-r8", pvalue->
            u.rrcConnectionReconfiguration_r8);
         break;
      }
      /* spare7 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare7");
         break;
      }
      /* spare6 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare6");
         break;
      }
      /* spare5 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare5");
         break;
      }
      /* spare4 */
      case 5:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare4");
         break;
      }
      /* spare3 */
      case 6:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 7:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 8:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReconfiguration_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const RRCConnectionReconfiguration_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionReconfiguration_criticalExtensions 
   (const char* name, const RRCConnectionReconfiguration_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_RRCConnectionReconfiguration_criticalExtensions_c1 ("c1", 
            pvalue->u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_RRCConnectionReconfiguration_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReconfiguration 
   (const char* name, const RRCConnectionReconfiguration* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_RRCConnectionReconfiguration_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_RedirectedCarrierInfo 
   (const char* name, const RedirectedCarrierInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* eutra */
      case 1:
      {
         asn1Print_ARFCN_ValueEUTRA ("eutra", &pvalue->u.eutra);
         break;
      }
      /* geran */
      case 2:
      {
         asn1Print_CarrierFreqsGERAN ("geran", pvalue->u.geran);
         break;
      }
      /* utra-FDD */
      case 3:
      {
         asn1Print_ARFCN_ValueUTRA ("utra-FDD", &pvalue->u.utra_FDD);
         break;
      }
      /* utra-TDD */
      case 4:
      {
         asn1Print_ARFCN_ValueUTRA ("utra-TDD", &pvalue->u.utra_TDD);
         break;
      }
      /* cdma2000-HRPD */
      case 5:
      {
         asn1Print_CarrierFreqCDMA2000 ("cdma2000-HRPD", pvalue->
            u.cdma2000_HRPD);
         break;
      }
      /* cdma2000-1xRTT */
      case 6:
      {
         asn1Print_CarrierFreqCDMA2000 ("cdma2000-1xRTT", pvalue->
            u.cdma2000_1xRTT);
         break;
      }
      /* extElem1 */
      case 7:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_FreqPriorityEUTRA 
   (const char* name, const FreqPriorityEUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ARFCN_ValueEUTRA ("carrierFreq", &pvalue->carrierFreq);

   asn1Print_CellReselectionPriority ("cellReselectionPriority", &pvalue->
      cellReselectionPriority);

   rtxPrintCloseBrace ();
}

void asn1Print_FreqPriorityListEUTRA 
   (const char* name, const FreqPriorityListEUTRA* pvalue)
{
   FreqPriorityEUTRA* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (FreqPriorityEUTRA*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_FreqPriorityEUTRA (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_FreqsPriorityGERAN 
   (const char* name, const FreqsPriorityGERAN* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CarrierFreqsGERAN ("carrierFreqs", &pvalue->carrierFreqs);

   asn1Print_CellReselectionPriority ("cellReselectionPriority", &pvalue->
      cellReselectionPriority);

   rtxPrintCloseBrace ();
}

void asn1Print_FreqsPriorityListGERAN 
   (const char* name, const FreqsPriorityListGERAN* pvalue)
{
   FreqsPriorityGERAN* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (FreqsPriorityGERAN*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_FreqsPriorityGERAN (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_FreqPriorityUTRA_FDD 
   (const char* name, const FreqPriorityUTRA_FDD* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ARFCN_ValueUTRA ("carrierFreq", &pvalue->carrierFreq);

   asn1Print_CellReselectionPriority ("cellReselectionPriority", &pvalue->
      cellReselectionPriority);

   rtxPrintCloseBrace ();
}

void asn1Print_FreqPriorityListUTRA_FDD 
   (const char* name, const FreqPriorityListUTRA_FDD* pvalue)
{
   FreqPriorityUTRA_FDD* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (FreqPriorityUTRA_FDD*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_FreqPriorityUTRA_FDD (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_FreqPriorityUTRA_TDD 
   (const char* name, const FreqPriorityUTRA_TDD* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ARFCN_ValueUTRA ("carrierFreq", &pvalue->carrierFreq);

   asn1Print_CellReselectionPriority ("cellReselectionPriority", &pvalue->
      cellReselectionPriority);

   rtxPrintCloseBrace ();
}

void asn1Print_FreqPriorityListUTRA_TDD 
   (const char* name, const FreqPriorityListUTRA_TDD* pvalue)
{
   FreqPriorityUTRA_TDD* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (FreqPriorityUTRA_TDD*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_FreqPriorityUTRA_TDD (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_BandClassPriorityHRPD 
   (const char* name, const BandClassPriorityHRPD* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_BandclassCDMA2000 ("bandClass", &pvalue->bandClass);

   asn1Print_CellReselectionPriority ("cellReselectionPriority", &pvalue->
      cellReselectionPriority);

   rtxPrintCloseBrace ();
}

void asn1Print_BandClassPriorityListHRPD 
   (const char* name, const BandClassPriorityListHRPD* pvalue)
{
   BandClassPriorityHRPD* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (BandClassPriorityHRPD*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_BandClassPriorityHRPD (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_BandClassPriority1XRTT 
   (const char* name, const BandClassPriority1XRTT* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_BandclassCDMA2000 ("bandClass", &pvalue->bandClass);

   asn1Print_CellReselectionPriority ("cellReselectionPriority", &pvalue->
      cellReselectionPriority);

   rtxPrintCloseBrace ();
}

void asn1Print_BandClassPriorityList1XRTT 
   (const char* name, const BandClassPriorityList1XRTT* pvalue)
{
   BandClassPriority1XRTT* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (BandClassPriority1XRTT*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_BandClassPriority1XRTT (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_IdleModeMobilityControlInfo 
   (const char* name, const IdleModeMobilityControlInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.freqPriorityListEUTRAPresent) {
      asn1Print_FreqPriorityListEUTRA ("freqPriorityListEUTRA", &pvalue->
         freqPriorityListEUTRA);
   }

   if (pvalue->m.freqPriorityListGERANPresent) {
      asn1Print_FreqsPriorityListGERAN ("freqPriorityListGERAN", &pvalue->
         freqPriorityListGERAN);
   }

   if (pvalue->m.freqPriorityListUTRA_FDDPresent) {
      asn1Print_FreqPriorityListUTRA_FDD ("freqPriorityListUTRA_FDD", &pvalue->
         freqPriorityListUTRA_FDD);
   }

   if (pvalue->m.freqPriorityListUTRA_TDDPresent) {
      asn1Print_FreqPriorityListUTRA_TDD ("freqPriorityListUTRA_TDD", &pvalue->
         freqPriorityListUTRA_TDD);
   }

   if (pvalue->m.bandClassPriorityListHRPDPresent) {
      asn1Print_BandClassPriorityListHRPD ("bandClassPriorityListHRPD", &pvalue
         ->bandClassPriorityListHRPD);
   }

   if (pvalue->m.bandClassPriorityList1XRTTPresent) {
      asn1Print_BandClassPriorityList1XRTT ("bandClassPriorityList1XRTT", &
         pvalue->bandClassPriorityList1XRTT);
   }

   if (pvalue->m.t320Present) {
      asn1Print_IdleModeMobilityControlInfo_t320 ("t320", &pvalue->t320);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_CellInfoGERAN_r9 
   (const char* name, const CellInfoGERAN_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PhysCellIdGERAN ("physCellId_r9", &pvalue->physCellId_r9);

   asn1Print_CarrierFreqGERAN ("carrierFreq_r9", &pvalue->carrierFreq_r9);

   asn1Print_SystemInfoListGERAN ("systemInformation_r9", &pvalue->
      systemInformation_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_CellInfoListGERAN_r9 
   (const char* name, const CellInfoListGERAN_r9* pvalue)
{
   CellInfoGERAN_r9* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (CellInfoGERAN_r9*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_CellInfoGERAN_r9 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_CellInfoUTRA_FDD_r9 
   (const char* name, const CellInfoUTRA_FDD_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PhysCellIdUTRA_FDD ("physCellId_r9", &pvalue->physCellId_r9);

   rtxPrintIndent ();
   rtxPrintHexStr ("utra_BCCH_Container_r9", pvalue->utra_BCCH_Container_r9.numocts, pvalue->utra_BCCH_Container_r9.data);

   rtxPrintCloseBrace ();
}

void asn1Print_CellInfoListUTRA_FDD_r9 
   (const char* name, const CellInfoListUTRA_FDD_r9* pvalue)
{
   CellInfoUTRA_FDD_r9* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (CellInfoUTRA_FDD_r9*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_CellInfoUTRA_FDD_r9 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_CellInfoUTRA_TDD_r9 
   (const char* name, const CellInfoUTRA_TDD_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PhysCellIdUTRA_TDD ("physCellId_r9", &pvalue->physCellId_r9);

   rtxPrintIndent ();
   rtxPrintHexStr ("utra_BCCH_Container_r9", pvalue->utra_BCCH_Container_r9.numocts, pvalue->utra_BCCH_Container_r9.data);

   rtxPrintCloseBrace ();
}

void asn1Print_CellInfoListUTRA_TDD_r9 
   (const char* name, const CellInfoListUTRA_TDD_r9* pvalue)
{
   CellInfoUTRA_TDD_r9* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (CellInfoUTRA_TDD_r9*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_CellInfoUTRA_TDD_r9 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_RRCConnectionRelease_v920_IEs_cellInfoList_r9 
   (const char* name, const RRCConnectionRelease_v920_IEs_cellInfoList_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* geran-r9 */
      case 1:
      {
         asn1Print_CellInfoListGERAN_r9 ("geran-r9", pvalue->u.geran_r9);
         break;
      }
      /* utra-FDD-r9 */
      case 2:
      {
         asn1Print_CellInfoListUTRA_FDD_r9 ("utra-FDD-r9", pvalue->
            u.utra_FDD_r9);
         break;
      }
      /* utra-TDD-r9 */
      case 3:
      {
         asn1Print_CellInfoListUTRA_TDD_r9 ("utra-TDD-r9", pvalue->
            u.utra_TDD_r9);
         break;
      }
      /* extElem1 */
      case 4:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionRelease_v920_IEs_nonCriticalExtension 
   (const char* name, const RRCConnectionRelease_v920_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionRelease_v920_IEs 
   (const char* name, const RRCConnectionRelease_v920_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.cellInfoList_r9Present) {
      asn1Print_RRCConnectionRelease_v920_IEs_cellInfoList_r9 (
         "cellInfoList_r9", &pvalue->cellInfoList_r9);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionRelease_v920_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionRelease_v890_IEs 
   (const char* name, const RRCConnectionRelease_v890_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionRelease_v920_IEs ("nonCriticalExtension", &pvalue
         ->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionRelease_r8_IEs 
   (const char* name, const RRCConnectionRelease_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ReleaseCause ("releaseCause", &pvalue->releaseCause);

   if (pvalue->m.redirectedCarrierInfoPresent) {
      asn1Print_RedirectedCarrierInfo ("redirectedCarrierInfo", &pvalue->
         redirectedCarrierInfo);
   }

   if (pvalue->m.idleModeMobilityControlInfoPresent) {
      asn1Print_IdleModeMobilityControlInfo ("idleModeMobilityControlInfo", &
         pvalue->idleModeMobilityControlInfo);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionRelease_v890_IEs ("nonCriticalExtension", &pvalue
         ->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionRelease_criticalExtensions_c1 
   (const char* name, const RRCConnectionRelease_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rrcConnectionRelease-r8 */
      case 1:
      {
         asn1Print_RRCConnectionRelease_r8_IEs ("rrcConnectionRelease-r8", 
            pvalue->u.rrcConnectionRelease_r8);
         break;
      }
      /* spare3 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionRelease_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const RRCConnectionRelease_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionRelease_criticalExtensions 
   (const char* name, const RRCConnectionRelease_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_RRCConnectionRelease_criticalExtensions_c1 ("c1", pvalue->
            u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_RRCConnectionRelease_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionRelease 
   (const char* name, const RRCConnectionRelease* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_RRCConnectionRelease_criticalExtensions ("criticalExtensions", &
      pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityConfigSMC 
   (const char* name, const SecurityConfigSMC* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SecurityAlgorithmConfig ("securityAlgorithmConfig", &pvalue->
      securityAlgorithmConfig);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityModeCommand_v8a0_IEs_nonCriticalExtension 
   (const char* name, const SecurityModeCommand_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_SecurityModeCommand_v8a0_IEs 
   (const char* name, const SecurityModeCommand_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_SecurityModeCommand_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityModeCommand_r8_IEs 
   (const char* name, const SecurityModeCommand_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SecurityConfigSMC ("securityConfigSMC", &pvalue->securityConfigSMC
      );

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_SecurityModeCommand_v8a0_IEs ("nonCriticalExtension", &pvalue->
         nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityModeCommand_criticalExtensions_c1 
   (const char* name, const SecurityModeCommand_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* securityModeCommand-r8 */
      case 1:
      {
         asn1Print_SecurityModeCommand_r8_IEs ("securityModeCommand-r8", pvalue
            ->u.securityModeCommand_r8);
         break;
      }
      /* spare3 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityModeCommand_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const SecurityModeCommand_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_SecurityModeCommand_criticalExtensions 
   (const char* name, const SecurityModeCommand_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_SecurityModeCommand_criticalExtensions_c1 ("c1", pvalue->
            u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_SecurityModeCommand_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityModeCommand 
   (const char* name, const SecurityModeCommand* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_SecurityModeCommand_criticalExtensions ("criticalExtensions", &
      pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_UE_CapabilityRequest 
   (const char* name, const UE_CapabilityRequest* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_RAT_Type (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_UECapabilityEnquiry_v8a0_IEs_nonCriticalExtension 
   (const char* name, const UECapabilityEnquiry_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_UECapabilityEnquiry_v8a0_IEs 
   (const char* name, const UECapabilityEnquiry_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_UECapabilityEnquiry_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UECapabilityEnquiry_r8_IEs 
   (const char* name, const UECapabilityEnquiry_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_UE_CapabilityRequest ("ue_CapabilityRequest", &pvalue->
      ue_CapabilityRequest);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_UECapabilityEnquiry_v8a0_IEs ("nonCriticalExtension", &pvalue->
         nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UECapabilityEnquiry_criticalExtensions_c1 
   (const char* name, const UECapabilityEnquiry_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* ueCapabilityEnquiry-r8 */
      case 1:
      {
         asn1Print_UECapabilityEnquiry_r8_IEs ("ueCapabilityEnquiry-r8", pvalue
            ->u.ueCapabilityEnquiry_r8);
         break;
      }
      /* spare3 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UECapabilityEnquiry_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const UECapabilityEnquiry_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_UECapabilityEnquiry_criticalExtensions 
   (const char* name, const UECapabilityEnquiry_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_UECapabilityEnquiry_criticalExtensions_c1 ("c1", pvalue->
            u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_UECapabilityEnquiry_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UECapabilityEnquiry 
   (const char* name, const UECapabilityEnquiry* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_UECapabilityEnquiry_criticalExtensions ("criticalExtensions", &
      pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_DRB_CountMSB_Info 
   (const char* name, const DRB_CountMSB_Info* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_DRB_Identity ("drb_Identity", &pvalue->drb_Identity);

   rtxPrintIndent ();
   rtxPrintUnsigned ("countMSB_Uplink", pvalue->countMSB_Uplink);

   rtxPrintIndent ();
   rtxPrintUnsigned ("countMSB_Downlink", pvalue->countMSB_Downlink);

   rtxPrintCloseBrace ();
}

void asn1Print_DRB_CountMSB_InfoList 
   (const char* name, const DRB_CountMSB_InfoList* pvalue)
{
   DRB_CountMSB_Info* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (DRB_CountMSB_Info*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_DRB_CountMSB_Info (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_CounterCheck_v8a0_IEs_nonCriticalExtension 
   (const char* name, const CounterCheck_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_CounterCheck_v8a0_IEs 
   (const char* name, const CounterCheck_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_CounterCheck_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CounterCheck_r8_IEs 
   (const char* name, const CounterCheck_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_DRB_CountMSB_InfoList ("drb_CountMSB_InfoList", &pvalue->
      drb_CountMSB_InfoList);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_CounterCheck_v8a0_IEs ("nonCriticalExtension", &pvalue->
         nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CounterCheck_criticalExtensions_c1 
   (const char* name, const CounterCheck_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* counterCheck-r8 */
      case 1:
      {
         asn1Print_CounterCheck_r8_IEs ("counterCheck-r8", pvalue->
            u.counterCheck_r8);
         break;
      }
      /* spare3 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CounterCheck_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const CounterCheck_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_CounterCheck_criticalExtensions 
   (const char* name, const CounterCheck_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_CounterCheck_criticalExtensions_c1 ("c1", pvalue->u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_CounterCheck_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CounterCheck (const char* name, const CounterCheck* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_CounterCheck_criticalExtensions ("criticalExtensions", &pvalue->
      criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_UEInformationRequest_v930_IEs_nonCriticalExtension 
   (const char* name, const UEInformationRequest_v930_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_UEInformationRequest_v930_IEs 
   (const char* name, const UEInformationRequest_v930_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_UEInformationRequest_v930_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UEInformationRequest_r9_IEs 
   (const char* name, const UEInformationRequest_r9_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("rach_ReportReq_r9", pvalue->rach_ReportReq_r9);

   rtxPrintIndent ();
   rtxPrintBoolean ("rlf_ReportReq_r9", pvalue->rlf_ReportReq_r9);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_UEInformationRequest_v930_IEs ("nonCriticalExtension", &pvalue
         ->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UEInformationRequest_r9_criticalExtensions_c1 
   (const char* name, const UEInformationRequest_r9_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* ueInformationRequest-r9 */
      case 1:
      {
         asn1Print_UEInformationRequest_r9_IEs ("ueInformationRequest-r9", 
            pvalue->u.ueInformationRequest_r9);
         break;
      }
      /* spare3 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UEInformationRequest_r9_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const UEInformationRequest_r9_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_UEInformationRequest_r9_criticalExtensions 
   (const char* name, const UEInformationRequest_r9_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_UEInformationRequest_r9_criticalExtensions_c1 ("c1", pvalue
            ->u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_UEInformationRequest_r9_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UEInformationRequest_r9 
   (const char* name, const UEInformationRequest_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_UEInformationRequest_r9_criticalExtensions ("criticalExtensions", 
      &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_DL_DCCH_MessageType_c1 
   (const char* name, const DL_DCCH_MessageType_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* csfbParametersResponseCDMA2000 */
      case 1:
      {
         asn1Print_CSFBParametersResponseCDMA2000 (
            "csfbParametersResponseCDMA2000", pvalue->
            u.csfbParametersResponseCDMA2000);
         break;
      }
      /* dlInformationTransfer */
      case 2:
      {
         asn1Print_DLInformationTransfer ("dlInformationTransfer", pvalue->
            u.dlInformationTransfer);
         break;
      }
      /* handoverFromEUTRAPreparationRequest */
      case 3:
      {
         asn1Print_HandoverFromEUTRAPreparationRequest (
            "handoverFromEUTRAPreparationRequest", pvalue->
            u.handoverFromEUTRAPreparationRequest);
         break;
      }
      /* mobilityFromEUTRACommand */
      case 4:
      {
         asn1Print_MobilityFromEUTRACommand ("mobilityFromEUTRACommand", pvalue
            ->u.mobilityFromEUTRACommand);
         break;
      }
      /* rrcConnectionReconfiguration */
      case 5:
      {
         asn1Print_RRCConnectionReconfiguration (
            "rrcConnectionReconfiguration", pvalue->
            u.rrcConnectionReconfiguration);
         break;
      }
      /* rrcConnectionRelease */
      case 6:
      {
         asn1Print_RRCConnectionRelease ("rrcConnectionRelease", pvalue->
            u.rrcConnectionRelease);
         break;
      }
      /* securityModeCommand */
      case 7:
      {
         asn1Print_SecurityModeCommand ("securityModeCommand", pvalue->
            u.securityModeCommand);
         break;
      }
      /* ueCapabilityEnquiry */
      case 8:
      {
         asn1Print_UECapabilityEnquiry ("ueCapabilityEnquiry", pvalue->
            u.ueCapabilityEnquiry);
         break;
      }
      /* counterCheck */
      case 9:
      {
         asn1Print_CounterCheck ("counterCheck", pvalue->u.counterCheck);
         break;
      }
      /* ueInformationRequest-r9 */
      case 10:
      {
         asn1Print_UEInformationRequest_r9 ("ueInformationRequest-r9", pvalue->
            u.ueInformationRequest_r9);
         break;
      }
      /* spare6 */
      case 11:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare6");
         break;
      }
      /* spare5 */
      case 12:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare5");
         break;
      }
      /* spare4 */
      case 13:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare4");
         break;
      }
      /* spare3 */
      case 14:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 15:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 16:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_DL_DCCH_MessageType_messageClassExtension 
   (const char* name, const DL_DCCH_MessageType_messageClassExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_DL_DCCH_MessageType 
   (const char* name, const DL_DCCH_MessageType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_DL_DCCH_MessageType_c1 ("c1", pvalue->u.c1);
         break;
      }
      /* messageClassExtension */
      case 2:
      {
         asn1Print_DL_DCCH_MessageType_messageClassExtension (
            "messageClassExtension", pvalue->u.messageClassExtension);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_DL_DCCH_Message 
   (const char* name, const DL_DCCH_Message* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_DL_DCCH_MessageType ("message", &pvalue->message);

   rtxPrintCloseBrace ();
}

void asn1Print_ReestabUE_Identity 
   (const char* name, const ReestabUE_Identity* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_C_RNTI ("c_RNTI", &pvalue->c_RNTI);

   asn1Print_PhysCellId ("physCellId", &pvalue->physCellId);

   asn1Print_ShortMAC_I ("shortMAC_I", &pvalue->shortMAC_I);

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishmentRequest_r8_IEs 
   (const char* name, const RRCConnectionReestablishmentRequest_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ReestabUE_Identity ("ue_Identity", &pvalue->ue_Identity);

   asn1Print_ReestablishmentCause ("reestablishmentCause", &pvalue->
      reestablishmentCause);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("spare", pvalue->spare.numbits, pvalue->spare.data);

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishmentRequest_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const RRCConnectionReestablishmentRequest_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionReestablishmentRequest_criticalExtensions 
   (const char* name, const RRCConnectionReestablishmentRequest_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rrcConnectionReestablishmentRequest-r8 */
      case 1:
      {
         asn1Print_RRCConnectionReestablishmentRequest_r8_IEs (
            "rrcConnectionReestablishmentRequest-r8", pvalue->
            u.rrcConnectionReestablishmentRequest_r8);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_RRCConnectionReestablishmentRequest_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishmentRequest 
   (const char* name, const RRCConnectionReestablishmentRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRCConnectionReestablishmentRequest_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_InitialUE_Identity 
   (const char* name, const InitialUE_Identity* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* s-TMSI */
      case 1:
      {
         asn1Print_S_TMSI ("s-TMSI", pvalue->u.s_TMSI);
         break;
      }
      /* randomValue */
      case 2:
      {
         asn1Print_InitialUE_Identity_randomValue ("randomValue", pvalue->
            u.randomValue);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionRequest_r8_IEs 
   (const char* name, const RRCConnectionRequest_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_InitialUE_Identity ("ue_Identity", &pvalue->ue_Identity);

   asn1Print_EstablishmentCause ("establishmentCause", &pvalue->
      establishmentCause);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("spare", pvalue->spare.numbits, pvalue->spare.data);

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionRequest_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const RRCConnectionRequest_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionRequest_criticalExtensions 
   (const char* name, const RRCConnectionRequest_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rrcConnectionRequest-r8 */
      case 1:
      {
         asn1Print_RRCConnectionRequest_r8_IEs ("rrcConnectionRequest-r8", 
            pvalue->u.rrcConnectionRequest_r8);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_RRCConnectionRequest_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionRequest 
   (const char* name, const RRCConnectionRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRCConnectionRequest_criticalExtensions ("criticalExtensions", &
      pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_UL_CCCH_MessageType_c1 
   (const char* name, const UL_CCCH_MessageType_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rrcConnectionReestablishmentRequest */
      case 1:
      {
         asn1Print_RRCConnectionReestablishmentRequest (
            "rrcConnectionReestablishmentRequest", pvalue->
            u.rrcConnectionReestablishmentRequest);
         break;
      }
      /* rrcConnectionRequest */
      case 2:
      {
         asn1Print_RRCConnectionRequest ("rrcConnectionRequest", pvalue->
            u.rrcConnectionRequest);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UL_CCCH_MessageType_messageClassExtension 
   (const char* name, const UL_CCCH_MessageType_messageClassExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_UL_CCCH_MessageType 
   (const char* name, const UL_CCCH_MessageType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_UL_CCCH_MessageType_c1 ("c1", pvalue->u.c1);
         break;
      }
      /* messageClassExtension */
      case 2:
      {
         asn1Print_UL_CCCH_MessageType_messageClassExtension (
            "messageClassExtension", pvalue->u.messageClassExtension);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UL_CCCH_Message 
   (const char* name, const UL_CCCH_Message* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_UL_CCCH_MessageType ("message", &pvalue->message);

   rtxPrintCloseBrace ();
}

void asn1Print_CSFBParametersRequestCDMA2000_v8a0_IEs_nonCriticalExtension 
   (const char* name, const CSFBParametersRequestCDMA2000_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_CSFBParametersRequestCDMA2000_v8a0_IEs 
   (const char* name, const CSFBParametersRequestCDMA2000_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_CSFBParametersRequestCDMA2000_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CSFBParametersRequestCDMA2000_r8_IEs 
   (const char* name, const CSFBParametersRequestCDMA2000_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_CSFBParametersRequestCDMA2000_v8a0_IEs (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CSFBParametersRequestCDMA2000_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const CSFBParametersRequestCDMA2000_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_CSFBParametersRequestCDMA2000_criticalExtensions 
   (const char* name, const CSFBParametersRequestCDMA2000_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* csfbParametersRequestCDMA2000-r8 */
      case 1:
      {
         asn1Print_CSFBParametersRequestCDMA2000_r8_IEs (
            "csfbParametersRequestCDMA2000-r8", pvalue->
            u.csfbParametersRequestCDMA2000_r8);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_CSFBParametersRequestCDMA2000_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CSFBParametersRequestCDMA2000 
   (const char* name, const CSFBParametersRequestCDMA2000* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CSFBParametersRequestCDMA2000_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResults_measResultServCell 
   (const char* name, const MeasResults_measResultServCell* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RSRP_Range ("rsrpResult", &pvalue->rsrpResult);

   asn1Print_RSRQ_Range ("rsrqResult", &pvalue->rsrqResult);

   rtxPrintCloseBrace ();
}

void asn1Print_CellGlobalIdEUTRA 
   (const char* name, const CellGlobalIdEUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PLMN_Identity ("plmn_Identity", &pvalue->plmn_Identity);

   asn1Print_CellIdentity ("cellIdentity", &pvalue->cellIdentity);

   rtxPrintCloseBrace ();
}

void asn1Print_PLMN_IdentityList2 
   (const char* name, const PLMN_IdentityList2* pvalue)
{
   PLMN_Identity* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (PLMN_Identity*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_PLMN_Identity (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_MeasResultEUTRA_cgi_Info 
   (const char* name, const MeasResultEUTRA_cgi_Info* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CellGlobalIdEUTRA ("cellGlobalId", &pvalue->cellGlobalId);

   asn1Print_TrackingAreaCode ("trackingAreaCode", &pvalue->trackingAreaCode);

   if (pvalue->m.plmn_IdentityListPresent) {
      asn1Print_PLMN_IdentityList2 ("plmn_IdentityList", &pvalue->
         plmn_IdentityList);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_AdditionalSI_Info_r9 
   (const char* name, const AdditionalSI_Info_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.csg_MemberStatus_r9Present) {
      asn1Print_AdditionalSI_Info_r9_csg_MemberStatus_r9 (
         "csg_MemberStatus_r9", &pvalue->csg_MemberStatus_r9);
   }

   if (pvalue->m.csg_Identity_r9Present) {
      asn1Print_CSG_Identity ("csg_Identity_r9", &pvalue->csg_Identity_r9);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultEUTRA_measResult 
   (const char* name, const MeasResultEUTRA_measResult* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.rsrpResultPresent) {
      asn1Print_RSRP_Range ("rsrpResult", &pvalue->rsrpResult);
   }

   if (pvalue->m.rsrqResultPresent) {
      asn1Print_RSRQ_Range ("rsrqResult", &pvalue->rsrqResult);
   }

   if (pvalue->m._v2ExtPresent) {
      if (pvalue->m.additionalSI_Info_r9Present) {
         asn1Print_AdditionalSI_Info_r9 ("additionalSI_Info_r9", &pvalue->
            additionalSI_Info_r9);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultEUTRA 
   (const char* name, const MeasResultEUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PhysCellId ("physCellId", &pvalue->physCellId);

   if (pvalue->m.cgi_InfoPresent) {
      asn1Print_MeasResultEUTRA_cgi_Info ("cgi_Info", &pvalue->cgi_Info);
   }

   asn1Print_MeasResultEUTRA_measResult ("measResult", &pvalue->measResult);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultListEUTRA 
   (const char* name, const MeasResultListEUTRA* pvalue)
{
   MeasResultEUTRA* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (MeasResultEUTRA*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MeasResultEUTRA (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_MeasResultUTRA_physCellId 
   (const char* name, const MeasResultUTRA_physCellId* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* fdd */
      case 1:
      {
         asn1Print_PhysCellIdUTRA_FDD ("fdd", &pvalue->u.fdd);
         break;
      }
      /* tdd */
      case 2:
      {
         asn1Print_PhysCellIdUTRA_TDD ("tdd", &pvalue->u.tdd);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CellGlobalIdUTRA 
   (const char* name, const CellGlobalIdUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PLMN_Identity ("plmn_Identity", &pvalue->plmn_Identity);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("cellIdentity", pvalue->cellIdentity.numbits, pvalue->cellIdentity.data);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultUTRA_cgi_Info 
   (const char* name, const MeasResultUTRA_cgi_Info* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CellGlobalIdUTRA ("cellGlobalId", &pvalue->cellGlobalId);

   if (pvalue->m.locationAreaCodePresent) {
      rtxPrintIndent ();
      rtPrintBitStrBraceText ("locationAreaCode", pvalue->locationAreaCode.numbits, pvalue->locationAreaCode.data);
   }

   if (pvalue->m.routingAreaCodePresent) {
      rtxPrintIndent ();
      rtPrintBitStrBraceText ("routingAreaCode", pvalue->routingAreaCode.numbits, pvalue->routingAreaCode.data);
   }

   if (pvalue->m.plmn_IdentityListPresent) {
      asn1Print_PLMN_IdentityList2 ("plmn_IdentityList", &pvalue->
         plmn_IdentityList);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultUTRA_measResult 
   (const char* name, const MeasResultUTRA_measResult* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.utra_RSCPPresent) {
      rtxPrintIndent ();
      rtxPrintInteger ("utra_RSCP", pvalue->utra_RSCP);
   }

   if (pvalue->m.utra_EcN0Present) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("utra_EcN0", pvalue->utra_EcN0);
   }

   if (pvalue->m._v2ExtPresent) {
      if (pvalue->m.additionalSI_Info_r9Present) {
         asn1Print_AdditionalSI_Info_r9 ("additionalSI_Info_r9", &pvalue->
            additionalSI_Info_r9);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultUTRA (const char* name, const MeasResultUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MeasResultUTRA_physCellId ("physCellId", &pvalue->physCellId);

   if (pvalue->m.cgi_InfoPresent) {
      asn1Print_MeasResultUTRA_cgi_Info ("cgi_Info", &pvalue->cgi_Info);
   }

   asn1Print_MeasResultUTRA_measResult ("measResult", &pvalue->measResult);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultListUTRA 
   (const char* name, const MeasResultListUTRA* pvalue)
{
   MeasResultUTRA* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (MeasResultUTRA*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MeasResultUTRA (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_CellGlobalIdGERAN 
   (const char* name, const CellGlobalIdGERAN* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PLMN_Identity ("plmn_Identity", &pvalue->plmn_Identity);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("locationAreaCode", pvalue->locationAreaCode.numbits, pvalue->locationAreaCode.data);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("cellIdentity", pvalue->cellIdentity.numbits, pvalue->cellIdentity.data);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultGERAN_cgi_Info 
   (const char* name, const MeasResultGERAN_cgi_Info* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CellGlobalIdGERAN ("cellGlobalId", &pvalue->cellGlobalId);

   if (pvalue->m.routingAreaCodePresent) {
      rtxPrintIndent ();
      rtPrintBitStrBraceText ("routingAreaCode", pvalue->routingAreaCode.numbits, pvalue->routingAreaCode.data);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultGERAN_measResult 
   (const char* name, const MeasResultGERAN_measResult* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("rssi", pvalue->rssi);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultGERAN 
   (const char* name, const MeasResultGERAN* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CarrierFreqGERAN ("carrierFreq", &pvalue->carrierFreq);

   asn1Print_PhysCellIdGERAN ("physCellId", &pvalue->physCellId);

   if (pvalue->m.cgi_InfoPresent) {
      asn1Print_MeasResultGERAN_cgi_Info ("cgi_Info", &pvalue->cgi_Info);
   }

   asn1Print_MeasResultGERAN_measResult ("measResult", &pvalue->measResult);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultListGERAN 
   (const char* name, const MeasResultListGERAN* pvalue)
{
   MeasResultGERAN* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (MeasResultGERAN*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MeasResultGERAN (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_CellGlobalIdCDMA2000 
   (const char* name, const CellGlobalIdCDMA2000* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* cellGlobalId1XRTT */
      case 1:
      {
         asn1Print_CellGlobalIdCDMA2000_cellGlobalId1XRTT (
            "cellGlobalId1XRTT", pvalue->u.cellGlobalId1XRTT);
         break;
      }
      /* cellGlobalIdHRPD */
      case 2:
      {
         asn1Print_CellGlobalIdCDMA2000_cellGlobalIdHRPD ("cellGlobalIdHRPD", 
            pvalue->u.cellGlobalIdHRPD);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultCDMA2000_measResult 
   (const char* name, const MeasResultCDMA2000_measResult* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.pilotPnPhasePresent) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("pilotPnPhase", pvalue->pilotPnPhase);
   }

   rtxPrintIndent ();
   rtxPrintUnsigned ("pilotStrength", pvalue->pilotStrength);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultCDMA2000 
   (const char* name, const MeasResultCDMA2000* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PhysCellIdCDMA2000 ("physCellId", &pvalue->physCellId);

   if (pvalue->m.cgi_InfoPresent) {
      asn1Print_CellGlobalIdCDMA2000 ("cgi_Info", &pvalue->cgi_Info);
   }

   asn1Print_MeasResultCDMA2000_measResult ("measResult", &pvalue->measResult
      );

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultListCDMA2000 
   (const char* name, const MeasResultListCDMA2000* pvalue)
{
   MeasResultCDMA2000* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (MeasResultCDMA2000*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MeasResultCDMA2000 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_MeasResultsCDMA2000 
   (const char* name, const MeasResultsCDMA2000* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("preRegistrationStatusHRPD", pvalue->preRegistrationStatusHRPD);

   asn1Print_MeasResultListCDMA2000 ("measResultListCDMA2000", &pvalue->
      measResultListCDMA2000);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResults_measResultNeighCells 
   (const char* name, const MeasResults_measResultNeighCells* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* measResultListEUTRA */
      case 1:
      {
         asn1Print_MeasResultListEUTRA ("measResultListEUTRA", pvalue->
            u.measResultListEUTRA);
         break;
      }
      /* measResultListUTRA */
      case 2:
      {
         asn1Print_MeasResultListUTRA ("measResultListUTRA", pvalue->
            u.measResultListUTRA);
         break;
      }
      /* measResultListGERAN */
      case 3:
      {
         asn1Print_MeasResultListGERAN ("measResultListGERAN", pvalue->
            u.measResultListGERAN);
         break;
      }
      /* measResultsCDMA2000 */
      case 4:
      {
         asn1Print_MeasResultsCDMA2000 ("measResultsCDMA2000", pvalue->
            u.measResultsCDMA2000);
         break;
      }
      /* extElem1 */
      case 5:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultForECID_r9 
   (const char* name, const MeasResultForECID_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ue_RxTxTimeDiffResult_r9", pvalue->ue_RxTxTimeDiffResult_r9);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("currentSFN_r9", pvalue->currentSFN_r9.numbits, pvalue->currentSFN_r9.data);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResults (const char* name, const MeasResults* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MeasId ("measId", &pvalue->measId);

   asn1Print_MeasResults_measResultServCell ("measResultServCell", &pvalue->
      measResultServCell);

   if (pvalue->m.measResultNeighCellsPresent) {
      asn1Print_MeasResults_measResultNeighCells ("measResultNeighCells", &
         pvalue->measResultNeighCells);
   }

   if (pvalue->m._v2ExtPresent) {
      if (pvalue->m.measResultForECID_r9Present) {
         asn1Print_MeasResultForECID_r9 ("measResultForECID_r9", &pvalue->
            measResultForECID_r9);
      }
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasurementReport_v8a0_IEs_nonCriticalExtension 
   (const char* name, const MeasurementReport_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_MeasurementReport_v8a0_IEs 
   (const char* name, const MeasurementReport_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_MeasurementReport_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasurementReport_r8_IEs 
   (const char* name, const MeasurementReport_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MeasResults ("measResults", &pvalue->measResults);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_MeasurementReport_v8a0_IEs ("nonCriticalExtension", &pvalue->
         nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasurementReport_criticalExtensions_c1 
   (const char* name, const MeasurementReport_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* measurementReport-r8 */
      case 1:
      {
         asn1Print_MeasurementReport_r8_IEs ("measurementReport-r8", pvalue->
            u.measurementReport_r8);
         break;
      }
      /* spare7 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare7");
         break;
      }
      /* spare6 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare6");
         break;
      }
      /* spare5 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare5");
         break;
      }
      /* spare4 */
      case 5:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare4");
         break;
      }
      /* spare3 */
      case 6:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 7:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 8:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasurementReport_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const MeasurementReport_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_MeasurementReport_criticalExtensions 
   (const char* name, const MeasurementReport_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_MeasurementReport_criticalExtensions_c1 ("c1", pvalue->u.c1
            );
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_MeasurementReport_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasurementReport 
   (const char* name, const MeasurementReport* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MeasurementReport_criticalExtensions ("criticalExtensions", &
      pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReconfigurationComplete_v8a0_IEs_nonCriticalExtension 
   (const char* name, const RRCConnectionReconfigurationComplete_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionReconfigurationComplete_v8a0_IEs 
   (const char* name, const RRCConnectionReconfigurationComplete_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionReconfigurationComplete_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReconfigurationComplete_r8_IEs 
   (const char* name, const RRCConnectionReconfigurationComplete_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionReconfigurationComplete_v8a0_IEs (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReconfigurationComplete_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const RRCConnectionReconfigurationComplete_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionReconfigurationComplete_criticalExtensions 
   (const char* name, const RRCConnectionReconfigurationComplete_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rrcConnectionReconfigurationComplete-r8 */
      case 1:
      {
         asn1Print_RRCConnectionReconfigurationComplete_r8_IEs (
            "rrcConnectionReconfigurationComplete-r8", pvalue->
            u.rrcConnectionReconfigurationComplete_r8);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_RRCConnectionReconfigurationComplete_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReconfigurationComplete 
   (const char* name, const RRCConnectionReconfigurationComplete* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_RRCConnectionReconfigurationComplete_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishmentComplete_v8a0_IEs_nonCriticalExtension 
   (const char* name, const RRCConnectionReestablishmentComplete_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionReestablishmentComplete_v8a0_IEs 
   (const char* name, const RRCConnectionReestablishmentComplete_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionReestablishmentComplete_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishmentComplete_v920_IEs 
   (const char* name, const RRCConnectionReestablishmentComplete_v920_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.rlf_InfoAvailable_r9Present) {
      asn1Print_RRCConnectionReestablishmentComplete_v920_IEs_rlf_InfoAvailable_r9 (
         "rlf_InfoAvailable_r9", &pvalue->rlf_InfoAvailable_r9);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionReestablishmentComplete_v8a0_IEs (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishmentComplete_r8_IEs 
   (const char* name, const RRCConnectionReestablishmentComplete_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionReestablishmentComplete_v920_IEs (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishmentComplete_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const RRCConnectionReestablishmentComplete_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionReestablishmentComplete_criticalExtensions 
   (const char* name, const RRCConnectionReestablishmentComplete_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rrcConnectionReestablishmentComplete-r8 */
      case 1:
      {
         asn1Print_RRCConnectionReestablishmentComplete_r8_IEs (
            "rrcConnectionReestablishmentComplete-r8", pvalue->
            u.rrcConnectionReestablishmentComplete_r8);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_RRCConnectionReestablishmentComplete_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionReestablishmentComplete 
   (const char* name, const RRCConnectionReestablishmentComplete* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_RRCConnectionReestablishmentComplete_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_RegisteredMME (const char* name, const RegisteredMME* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.plmn_IdentityPresent) {
      asn1Print_PLMN_Identity ("plmn_Identity", &pvalue->plmn_Identity);
   }

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("mmegi", pvalue->mmegi.numbits, pvalue->mmegi.data);

   asn1Print_MMEC ("mmec", &pvalue->mmec);

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionSetupComplete_v8a0_IEs_nonCriticalExtension 
   (const char* name, const RRCConnectionSetupComplete_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionSetupComplete_v8a0_IEs 
   (const char* name, const RRCConnectionSetupComplete_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionSetupComplete_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionSetupComplete_r8_IEs 
   (const char* name, const RRCConnectionSetupComplete_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("selectedPLMN_Identity", pvalue->selectedPLMN_Identity);

   if (pvalue->m.registeredMMEPresent) {
      asn1Print_RegisteredMME ("registeredMME", &pvalue->registeredMME);
   }

   asn1Print_DedicatedInfoNAS ("dedicatedInfoNAS", &pvalue->dedicatedInfoNAS);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_RRCConnectionSetupComplete_v8a0_IEs ("nonCriticalExtension", &
         pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionSetupComplete_criticalExtensions_c1 
   (const char* name, const RRCConnectionSetupComplete_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rrcConnectionSetupComplete-r8 */
      case 1:
      {
         asn1Print_RRCConnectionSetupComplete_r8_IEs (
            "rrcConnectionSetupComplete-r8", pvalue->
            u.rrcConnectionSetupComplete_r8);
         break;
      }
      /* spare3 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionSetupComplete_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const RRCConnectionSetupComplete_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_RRCConnectionSetupComplete_criticalExtensions 
   (const char* name, const RRCConnectionSetupComplete_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_RRCConnectionSetupComplete_criticalExtensions_c1 ("c1", 
            pvalue->u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_RRCConnectionSetupComplete_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RRCConnectionSetupComplete 
   (const char* name, const RRCConnectionSetupComplete* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_RRCConnectionSetupComplete_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityModeComplete_v8a0_IEs_nonCriticalExtension 
   (const char* name, const SecurityModeComplete_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_SecurityModeComplete_v8a0_IEs 
   (const char* name, const SecurityModeComplete_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_SecurityModeComplete_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityModeComplete_r8_IEs 
   (const char* name, const SecurityModeComplete_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_SecurityModeComplete_v8a0_IEs ("nonCriticalExtension", &pvalue
         ->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityModeComplete_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const SecurityModeComplete_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_SecurityModeComplete_criticalExtensions 
   (const char* name, const SecurityModeComplete_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* securityModeComplete-r8 */
      case 1:
      {
         asn1Print_SecurityModeComplete_r8_IEs ("securityModeComplete-r8", 
            pvalue->u.securityModeComplete_r8);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_SecurityModeComplete_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityModeComplete 
   (const char* name, const SecurityModeComplete* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_SecurityModeComplete_criticalExtensions ("criticalExtensions", &
      pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityModeFailure_v8a0_IEs_nonCriticalExtension 
   (const char* name, const SecurityModeFailure_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_SecurityModeFailure_v8a0_IEs 
   (const char* name, const SecurityModeFailure_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_SecurityModeFailure_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityModeFailure_r8_IEs 
   (const char* name, const SecurityModeFailure_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_SecurityModeFailure_v8a0_IEs ("nonCriticalExtension", &pvalue->
         nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityModeFailure_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const SecurityModeFailure_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_SecurityModeFailure_criticalExtensions 
   (const char* name, const SecurityModeFailure_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* securityModeFailure-r8 */
      case 1:
      {
         asn1Print_SecurityModeFailure_r8_IEs ("securityModeFailure-r8", pvalue
            ->u.securityModeFailure_r8);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_SecurityModeFailure_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SecurityModeFailure 
   (const char* name, const SecurityModeFailure* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_SecurityModeFailure_criticalExtensions ("criticalExtensions", &
      pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_UE_CapabilityRAT_Container 
   (const char* name, const UE_CapabilityRAT_Container* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RAT_Type ("rat_Type", &pvalue->rat_Type);

   rtxPrintIndent ();
   rtxPrintHexStr ("ueCapabilityRAT_Container", pvalue->ueCapabilityRAT_Container.numocts, pvalue->ueCapabilityRAT_Container.data);

   rtxPrintCloseBrace ();
}

void asn1Print_UE_CapabilityRAT_ContainerList 
   (const char* name, const UE_CapabilityRAT_ContainerList* pvalue)
{
   UE_CapabilityRAT_Container* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (UE_CapabilityRAT_Container*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_UE_CapabilityRAT_Container (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_UECapabilityInformation_v8a0_IEs_nonCriticalExtension 
   (const char* name, const UECapabilityInformation_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_UECapabilityInformation_v8a0_IEs 
   (const char* name, const UECapabilityInformation_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_UECapabilityInformation_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UECapabilityInformation_r8_IEs 
   (const char* name, const UECapabilityInformation_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_UE_CapabilityRAT_ContainerList ("ue_CapabilityRAT_ContainerList", 
      &pvalue->ue_CapabilityRAT_ContainerList);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_UECapabilityInformation_v8a0_IEs ("nonCriticalExtension", &
         pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UECapabilityInformation_criticalExtensions_c1 
   (const char* name, const UECapabilityInformation_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* ueCapabilityInformation-r8 */
      case 1:
      {
         asn1Print_UECapabilityInformation_r8_IEs (
            "ueCapabilityInformation-r8", pvalue->u.ueCapabilityInformation_r8
            );
         break;
      }
      /* spare7 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare7");
         break;
      }
      /* spare6 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare6");
         break;
      }
      /* spare5 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare5");
         break;
      }
      /* spare4 */
      case 5:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare4");
         break;
      }
      /* spare3 */
      case 6:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 7:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 8:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UECapabilityInformation_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const UECapabilityInformation_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_UECapabilityInformation_criticalExtensions 
   (const char* name, const UECapabilityInformation_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_UECapabilityInformation_criticalExtensions_c1 ("c1", pvalue
            ->u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_UECapabilityInformation_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UECapabilityInformation 
   (const char* name, const UECapabilityInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_UECapabilityInformation_criticalExtensions ("criticalExtensions", 
      &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_ULHandoverPreparationTransfer_v8a0_IEs_nonCriticalExtension 
   (const char* name, const ULHandoverPreparationTransfer_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_ULHandoverPreparationTransfer_v8a0_IEs 
   (const char* name, const ULHandoverPreparationTransfer_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_ULHandoverPreparationTransfer_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ULHandoverPreparationTransfer_r8_IEs 
   (const char* name, const ULHandoverPreparationTransfer_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CDMA2000_Type ("cdma2000_Type", &pvalue->cdma2000_Type);

   if (pvalue->m.meidPresent) {
      asn1Print_ULHandoverPreparationTransfer_r8_IEs_meid ("meid", &pvalue->
         meid);
   }

   asn1Print_DedicatedInfoCDMA2000 ("dedicatedInfo", &pvalue->dedicatedInfo);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_ULHandoverPreparationTransfer_v8a0_IEs (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ULHandoverPreparationTransfer_criticalExtensions_c1 
   (const char* name, const ULHandoverPreparationTransfer_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* ulHandoverPreparationTransfer-r8 */
      case 1:
      {
         asn1Print_ULHandoverPreparationTransfer_r8_IEs (
            "ulHandoverPreparationTransfer-r8", pvalue->
            u.ulHandoverPreparationTransfer_r8);
         break;
      }
      /* spare3 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ULHandoverPreparationTransfer_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const ULHandoverPreparationTransfer_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_ULHandoverPreparationTransfer_criticalExtensions 
   (const char* name, const ULHandoverPreparationTransfer_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_ULHandoverPreparationTransfer_criticalExtensions_c1 ("c1", 
            pvalue->u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_ULHandoverPreparationTransfer_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ULHandoverPreparationTransfer 
   (const char* name, const ULHandoverPreparationTransfer* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ULHandoverPreparationTransfer_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_ULInformationTransfer_r8_IEs_dedicatedInfoType 
   (const char* name, const ULInformationTransfer_r8_IEs_dedicatedInfoType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* dedicatedInfoNAS */
      case 1:
      {
         asn1Print_DedicatedInfoNAS ("dedicatedInfoNAS", pvalue->
            u.dedicatedInfoNAS);
         break;
      }
      /* dedicatedInfoCDMA2000-1XRTT */
      case 2:
      {
         asn1Print_DedicatedInfoCDMA2000 ("dedicatedInfoCDMA2000-1XRTT", pvalue
            ->u.dedicatedInfoCDMA2000_1XRTT);
         break;
      }
      /* dedicatedInfoCDMA2000-HRPD */
      case 3:
      {
         asn1Print_DedicatedInfoCDMA2000 ("dedicatedInfoCDMA2000-HRPD", pvalue
            ->u.dedicatedInfoCDMA2000_HRPD);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ULInformationTransfer_v8a0_IEs_nonCriticalExtension 
   (const char* name, const ULInformationTransfer_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_ULInformationTransfer_v8a0_IEs 
   (const char* name, const ULInformationTransfer_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_ULInformationTransfer_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ULInformationTransfer_r8_IEs 
   (const char* name, const ULInformationTransfer_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ULInformationTransfer_r8_IEs_dedicatedInfoType (
      "dedicatedInfoType", &pvalue->dedicatedInfoType);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_ULInformationTransfer_v8a0_IEs ("nonCriticalExtension", &pvalue
         ->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ULInformationTransfer_criticalExtensions_c1 
   (const char* name, const ULInformationTransfer_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* ulInformationTransfer-r8 */
      case 1:
      {
         asn1Print_ULInformationTransfer_r8_IEs ("ulInformationTransfer-r8", 
            pvalue->u.ulInformationTransfer_r8);
         break;
      }
      /* spare3 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ULInformationTransfer_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const ULInformationTransfer_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_ULInformationTransfer_criticalExtensions 
   (const char* name, const ULInformationTransfer_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_ULInformationTransfer_criticalExtensions_c1 ("c1", pvalue->
            u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_ULInformationTransfer_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ULInformationTransfer 
   (const char* name, const ULInformationTransfer* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ULInformationTransfer_criticalExtensions ("criticalExtensions", &
      pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_DRB_CountInfo (const char* name, const DRB_CountInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_DRB_Identity ("drb_Identity", &pvalue->drb_Identity);

   rtxPrintIndent ();
   rtxPrintUnsigned ("count_Uplink", pvalue->count_Uplink);

   rtxPrintIndent ();
   rtxPrintUnsigned ("count_Downlink", pvalue->count_Downlink);

   rtxPrintCloseBrace ();
}

void asn1Print_DRB_CountInfoList 
   (const char* name, const DRB_CountInfoList* pvalue)
{
   DRB_CountInfo* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (DRB_CountInfo*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_DRB_CountInfo (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_CounterCheckResponse_v8a0_IEs_nonCriticalExtension 
   (const char* name, const CounterCheckResponse_v8a0_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_CounterCheckResponse_v8a0_IEs 
   (const char* name, const CounterCheckResponse_v8a0_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_CounterCheckResponse_v8a0_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CounterCheckResponse_r8_IEs 
   (const char* name, const CounterCheckResponse_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_DRB_CountInfoList ("drb_CountInfoList", &pvalue->drb_CountInfoList
      );

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_CounterCheckResponse_v8a0_IEs ("nonCriticalExtension", &pvalue
         ->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CounterCheckResponse_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const CounterCheckResponse_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_CounterCheckResponse_criticalExtensions 
   (const char* name, const CounterCheckResponse_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* counterCheckResponse-r8 */
      case 1:
      {
         asn1Print_CounterCheckResponse_r8_IEs ("counterCheckResponse-r8", 
            pvalue->u.counterCheckResponse_r8);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_CounterCheckResponse_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CounterCheckResponse 
   (const char* name, const CounterCheckResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_CounterCheckResponse_criticalExtensions ("criticalExtensions", &
      pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_UEInformationResponse_r9_IEs_rach_Report_r9 
   (const char* name, const UEInformationResponse_r9_IEs_rach_Report_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("numberOfPreamblesSent_r9", pvalue->numberOfPreamblesSent_r9);

   rtxPrintIndent ();
   rtxPrintBoolean ("contentionDetected_r9", pvalue->contentionDetected_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_RLF_Report_r9_measResultLastServCell_r9 
   (const char* name, const RLF_Report_r9_measResultLastServCell_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RSRP_Range ("rsrpResult_r9", &pvalue->rsrpResult_r9);

   if (pvalue->m.rsrqResult_r9Present) {
      asn1Print_RSRQ_Range ("rsrqResult_r9", &pvalue->rsrqResult_r9);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResult2EUTRA_r9 
   (const char* name, const MeasResult2EUTRA_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ARFCN_ValueEUTRA ("carrierFreq_r9", &pvalue->carrierFreq_r9);

   asn1Print_MeasResultListEUTRA ("measResultList_r9", &pvalue->
      measResultList_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultList2EUTRA_r9 
   (const char* name, const MeasResultList2EUTRA_r9* pvalue)
{
   MeasResult2EUTRA_r9* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (MeasResult2EUTRA_r9*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MeasResult2EUTRA_r9 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_MeasResult2UTRA_r9 
   (const char* name, const MeasResult2UTRA_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ARFCN_ValueUTRA ("carrierFreq_r9", &pvalue->carrierFreq_r9);

   asn1Print_MeasResultListUTRA ("measResultList_r9", &pvalue->
      measResultList_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultList2UTRA_r9 
   (const char* name, const MeasResultList2UTRA_r9* pvalue)
{
   MeasResult2UTRA_r9* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (MeasResult2UTRA_r9*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MeasResult2UTRA_r9 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_MeasResult2CDMA2000_r9 
   (const char* name, const MeasResult2CDMA2000_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CarrierFreqCDMA2000 ("carrierFreq_r9", &pvalue->carrierFreq_r9);

   asn1Print_MeasResultsCDMA2000 ("measResultList_r9", &pvalue->
      measResultList_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_MeasResultList2CDMA2000_r9 
   (const char* name, const MeasResultList2CDMA2000_r9* pvalue)
{
   MeasResult2CDMA2000_r9* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (MeasResult2CDMA2000_r9*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MeasResult2CDMA2000_r9 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_RLF_Report_r9_measResultNeighCells_r9 
   (const char* name, const RLF_Report_r9_measResultNeighCells_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.measResultListEUTRA_r9Present) {
      asn1Print_MeasResultList2EUTRA_r9 ("measResultListEUTRA_r9", &pvalue->
         measResultListEUTRA_r9);
   }

   if (pvalue->m.measResultListUTRA_r9Present) {
      asn1Print_MeasResultList2UTRA_r9 ("measResultListUTRA_r9", &pvalue->
         measResultListUTRA_r9);
   }

   if (pvalue->m.measResultListGERAN_r9Present) {
      asn1Print_MeasResultListGERAN ("measResultListGERAN_r9", &pvalue->
         measResultListGERAN_r9);
   }

   if (pvalue->m.measResultsCDMA2000_r9Present) {
      asn1Print_MeasResultList2CDMA2000_r9 ("measResultsCDMA2000_r9", &pvalue->
         measResultsCDMA2000_r9);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_RLF_Report_r9 (const char* name, const RLF_Report_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RLF_Report_r9_measResultLastServCell_r9 (
      "measResultLastServCell_r9", &pvalue->measResultLastServCell_r9);

   if (pvalue->m.measResultNeighCells_r9Present) {
      asn1Print_RLF_Report_r9_measResultNeighCells_r9 (
         "measResultNeighCells_r9", &pvalue->measResultNeighCells_r9);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_UEInformationResponse_v930_IEs_nonCriticalExtension 
   (const char* name, const UEInformationResponse_v930_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_UEInformationResponse_v930_IEs 
   (const char* name, const UEInformationResponse_v930_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_UEInformationResponse_v930_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UEInformationResponse_r9_IEs 
   (const char* name, const UEInformationResponse_r9_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.rach_Report_r9Present) {
      asn1Print_UEInformationResponse_r9_IEs_rach_Report_r9 ("rach_Report_r9", 
         &pvalue->rach_Report_r9);
   }

   if (pvalue->m.rlfReport_r9Present) {
      asn1Print_RLF_Report_r9 ("rlfReport_r9", &pvalue->rlfReport_r9);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_UEInformationResponse_v930_IEs ("nonCriticalExtension", &pvalue
         ->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UEInformationResponse_r9_criticalExtensions_c1 
   (const char* name, const UEInformationResponse_r9_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* ueInformationResponse-r9 */
      case 1:
      {
         asn1Print_UEInformationResponse_r9_IEs ("ueInformationResponse-r9", 
            pvalue->u.ueInformationResponse_r9);
         break;
      }
      /* spare3 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UEInformationResponse_r9_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const UEInformationResponse_r9_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_UEInformationResponse_r9_criticalExtensions 
   (const char* name, const UEInformationResponse_r9_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_UEInformationResponse_r9_criticalExtensions_c1 ("c1", pvalue
            ->u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_UEInformationResponse_r9_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UEInformationResponse_r9 
   (const char* name, const UEInformationResponse_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_RRC_TransactionIdentifier ("rrc_TransactionIdentifier", &pvalue->
      rrc_TransactionIdentifier);

   asn1Print_UEInformationResponse_r9_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_ProximityIndication_r9_IEs_carrierFreq_r9 
   (const char* name, const ProximityIndication_r9_IEs_carrierFreq_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* eutra-r9 */
      case 1:
      {
         asn1Print_ARFCN_ValueEUTRA ("eutra-r9", &pvalue->u.eutra_r9);
         break;
      }
      /* utra-r9 */
      case 2:
      {
         asn1Print_ARFCN_ValueUTRA ("utra-r9", &pvalue->u.utra_r9);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ProximityIndication_v930_IEs_nonCriticalExtension 
   (const char* name, const ProximityIndication_v930_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_ProximityIndication_v930_IEs 
   (const char* name, const ProximityIndication_v930_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_ProximityIndication_v930_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ProximityIndication_r9_IEs 
   (const char* name, const ProximityIndication_r9_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ProximityIndication_r9_IEs_type_r9 ("type_r9", &pvalue->type_r9);

   asn1Print_ProximityIndication_r9_IEs_carrierFreq_r9 ("carrierFreq_r9", &
      pvalue->carrierFreq_r9);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_ProximityIndication_v930_IEs ("nonCriticalExtension", &pvalue->
         nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ProximityIndication_r9_criticalExtensions_c1 
   (const char* name, const ProximityIndication_r9_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* proximityIndication-r9 */
      case 1:
      {
         asn1Print_ProximityIndication_r9_IEs ("proximityIndication-r9", pvalue
            ->u.proximityIndication_r9);
         break;
      }
      /* spare3 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ProximityIndication_r9_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const ProximityIndication_r9_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_ProximityIndication_r9_criticalExtensions 
   (const char* name, const ProximityIndication_r9_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_ProximityIndication_r9_criticalExtensions_c1 ("c1", pvalue->
            u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_ProximityIndication_r9_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ProximityIndication_r9 
   (const char* name, const ProximityIndication_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ProximityIndication_r9_criticalExtensions ("criticalExtensions", &
      pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_UL_DCCH_MessageType_c1 
   (const char* name, const UL_DCCH_MessageType_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* csfbParametersRequestCDMA2000 */
      case 1:
      {
         asn1Print_CSFBParametersRequestCDMA2000 (
            "csfbParametersRequestCDMA2000", pvalue->
            u.csfbParametersRequestCDMA2000);
         break;
      }
      /* measurementReport */
      case 2:
      {
         asn1Print_MeasurementReport ("measurementReport", pvalue->
            u.measurementReport);
         break;
      }
      /* rrcConnectionReconfigurationComplete */
      case 3:
      {
         asn1Print_RRCConnectionReconfigurationComplete (
            "rrcConnectionReconfigurationComplete", pvalue->
            u.rrcConnectionReconfigurationComplete);
         break;
      }
      /* rrcConnectionReestablishmentComplete */
      case 4:
      {
         asn1Print_RRCConnectionReestablishmentComplete (
            "rrcConnectionReestablishmentComplete", pvalue->
            u.rrcConnectionReestablishmentComplete);
         break;
      }
      /* rrcConnectionSetupComplete */
      case 5:
      {
         asn1Print_RRCConnectionSetupComplete ("rrcConnectionSetupComplete", 
            pvalue->u.rrcConnectionSetupComplete);
         break;
      }
      /* securityModeComplete */
      case 6:
      {
         asn1Print_SecurityModeComplete ("securityModeComplete", pvalue->
            u.securityModeComplete);
         break;
      }
      /* securityModeFailure */
      case 7:
      {
         asn1Print_SecurityModeFailure ("securityModeFailure", pvalue->
            u.securityModeFailure);
         break;
      }
      /* ueCapabilityInformation */
      case 8:
      {
         asn1Print_UECapabilityInformation ("ueCapabilityInformation", pvalue->
            u.ueCapabilityInformation);
         break;
      }
      /* ulHandoverPreparationTransfer */
      case 9:
      {
         asn1Print_ULHandoverPreparationTransfer (
            "ulHandoverPreparationTransfer", pvalue->
            u.ulHandoverPreparationTransfer);
         break;
      }
      /* ulInformationTransfer */
      case 10:
      {
         asn1Print_ULInformationTransfer ("ulInformationTransfer", pvalue->
            u.ulInformationTransfer);
         break;
      }
      /* counterCheckResponse */
      case 11:
      {
         asn1Print_CounterCheckResponse ("counterCheckResponse", pvalue->
            u.counterCheckResponse);
         break;
      }
      /* ueInformationResponse-r9 */
      case 12:
      {
         asn1Print_UEInformationResponse_r9 ("ueInformationResponse-r9", pvalue
            ->u.ueInformationResponse_r9);
         break;
      }
      /* proximityIndication-r9 */
      case 13:
      {
         asn1Print_ProximityIndication_r9 ("proximityIndication-r9", pvalue->
            u.proximityIndication_r9);
         break;
      }
      /* spare3 */
      case 14:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 15:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 16:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UL_DCCH_MessageType_messageClassExtension 
   (const char* name, const UL_DCCH_MessageType_messageClassExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_UL_DCCH_MessageType 
   (const char* name, const UL_DCCH_MessageType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_UL_DCCH_MessageType_c1 ("c1", pvalue->u.c1);
         break;
      }
      /* messageClassExtension */
      case 2:
      {
         asn1Print_UL_DCCH_MessageType_messageClassExtension (
            "messageClassExtension", pvalue->u.messageClassExtension);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UL_DCCH_Message 
   (const char* name, const UL_DCCH_Message* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_UL_DCCH_MessageType ("message", &pvalue->message);

   rtxPrintCloseBrace ();
}

void asn1Print_PDCP_Parameters_supportedROHC_Profiles 
   (const char* name, const PDCP_Parameters_supportedROHC_Profiles* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0001", pvalue->profile0x0001);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0002", pvalue->profile0x0002);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0003", pvalue->profile0x0003);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0004", pvalue->profile0x0004);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0006", pvalue->profile0x0006);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0101", pvalue->profile0x0101);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0102", pvalue->profile0x0102);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0103", pvalue->profile0x0103);

   rtxPrintIndent ();
   rtxPrintBoolean ("profile0x0104", pvalue->profile0x0104);

   rtxPrintCloseBrace ();
}

void asn1Print_PDCP_Parameters 
   (const char* name, const PDCP_Parameters* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PDCP_Parameters_supportedROHC_Profiles ("supportedROHC_Profiles", 
      &pvalue->supportedROHC_Profiles);

   asn1Print_PDCP_Parameters_maxNumberROHC_ContextSessions (
      "maxNumberROHC_ContextSessions", &pvalue->maxNumberROHC_ContextSessions
      );

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_PhyLayerParameters 
   (const char* name, const PhyLayerParameters* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("ue_TxAntennaSelectionSupported", pvalue->ue_TxAntennaSelectionSupported);

   rtxPrintIndent ();
   rtxPrintBoolean ("ue_SpecificRefSigsSupported", pvalue->ue_SpecificRefSigsSupported);

   rtxPrintCloseBrace ();
}

void asn1Print_SupportedBandEUTRA 
   (const char* name, const SupportedBandEUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("bandEUTRA", pvalue->bandEUTRA);

   rtxPrintIndent ();
   rtxPrintBoolean ("halfDuplex", pvalue->halfDuplex);

   rtxPrintCloseBrace ();
}

void asn1Print_SupportedBandListEUTRA 
   (const char* name, const SupportedBandListEUTRA* pvalue)
{
   SupportedBandEUTRA* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (SupportedBandEUTRA*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_SupportedBandEUTRA (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_RF_Parameters (const char* name, const RF_Parameters* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SupportedBandListEUTRA ("supportedBandListEUTRA", &pvalue->
      supportedBandListEUTRA);

   rtxPrintCloseBrace ();
}

void asn1Print_InterFreqBandInfo 
   (const char* name, const InterFreqBandInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("interFreqNeedForGaps", pvalue->interFreqNeedForGaps);

   rtxPrintCloseBrace ();
}

void asn1Print_InterFreqBandList 
   (const char* name, const InterFreqBandList* pvalue)
{
   InterFreqBandInfo* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (InterFreqBandInfo*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_InterFreqBandInfo (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_InterRAT_BandInfo 
   (const char* name, const InterRAT_BandInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("interRAT_NeedForGaps", pvalue->interRAT_NeedForGaps);

   rtxPrintCloseBrace ();
}

void asn1Print_InterRAT_BandList 
   (const char* name, const InterRAT_BandList* pvalue)
{
   InterRAT_BandInfo* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (InterRAT_BandInfo*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_InterRAT_BandInfo (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_BandInfoEUTRA (const char* name, const BandInfoEUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_InterFreqBandList ("interFreqBandList", &pvalue->interFreqBandList
      );

   if (pvalue->m.interRAT_BandListPresent) {
      asn1Print_InterRAT_BandList ("interRAT_BandList", &pvalue->
         interRAT_BandList);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_BandListEUTRA (const char* name, const BandListEUTRA* pvalue)
{
   BandInfoEUTRA* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (BandInfoEUTRA*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_BandInfoEUTRA (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_MeasParameters (const char* name, const MeasParameters* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_BandListEUTRA ("bandListEUTRA", &pvalue->bandListEUTRA);

   rtxPrintCloseBrace ();
}

void asn1Print_SupportedBandListUTRA_FDD 
   (const char* name, const SupportedBandListUTRA_FDD* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_SupportedBandUTRA_FDD (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_IRAT_ParametersUTRA_FDD 
   (const char* name, const IRAT_ParametersUTRA_FDD* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SupportedBandListUTRA_FDD ("supportedBandListUTRA_FDD", &pvalue->
      supportedBandListUTRA_FDD);

   rtxPrintCloseBrace ();
}

void asn1Print_SupportedBandListUTRA_TDD128 
   (const char* name, const SupportedBandListUTRA_TDD128* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_SupportedBandUTRA_TDD128 (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_IRAT_ParametersUTRA_TDD128 
   (const char* name, const IRAT_ParametersUTRA_TDD128* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SupportedBandListUTRA_TDD128 ("supportedBandListUTRA_TDD128", &
      pvalue->supportedBandListUTRA_TDD128);

   rtxPrintCloseBrace ();
}

void asn1Print_SupportedBandListUTRA_TDD384 
   (const char* name, const SupportedBandListUTRA_TDD384* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_SupportedBandUTRA_TDD384 (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_IRAT_ParametersUTRA_TDD384 
   (const char* name, const IRAT_ParametersUTRA_TDD384* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SupportedBandListUTRA_TDD384 ("supportedBandListUTRA_TDD384", &
      pvalue->supportedBandListUTRA_TDD384);

   rtxPrintCloseBrace ();
}

void asn1Print_SupportedBandListUTRA_TDD768 
   (const char* name, const SupportedBandListUTRA_TDD768* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_SupportedBandUTRA_TDD768 (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_IRAT_ParametersUTRA_TDD768 
   (const char* name, const IRAT_ParametersUTRA_TDD768* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SupportedBandListUTRA_TDD768 ("supportedBandListUTRA_TDD768", &
      pvalue->supportedBandListUTRA_TDD768);

   rtxPrintCloseBrace ();
}

void asn1Print_SupportedBandListGERAN 
   (const char* name, const SupportedBandListGERAN* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_SupportedBandGERAN (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_IRAT_ParametersGERAN 
   (const char* name, const IRAT_ParametersGERAN* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SupportedBandListGERAN ("supportedBandListGERAN", &pvalue->
      supportedBandListGERAN);

   rtxPrintIndent ();
   rtxPrintBoolean ("interRAT_PS_HO_ToGERAN", pvalue->interRAT_PS_HO_ToGERAN);

   rtxPrintCloseBrace ();
}

void asn1Print_SupportedBandListHRPD 
   (const char* name, const SupportedBandListHRPD* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_BandclassCDMA2000 (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_IRAT_ParametersCDMA2000_HRPD 
   (const char* name, const IRAT_ParametersCDMA2000_HRPD* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SupportedBandListHRPD ("supportedBandListHRPD", &pvalue->
      supportedBandListHRPD);

   asn1Print_IRAT_ParametersCDMA2000_HRPD_tx_ConfigHRPD ("tx_ConfigHRPD", &
      pvalue->tx_ConfigHRPD);

   asn1Print_IRAT_ParametersCDMA2000_HRPD_rx_ConfigHRPD ("rx_ConfigHRPD", &
      pvalue->rx_ConfigHRPD);

   rtxPrintCloseBrace ();
}

void asn1Print_SupportedBandList1XRTT 
   (const char* name, const SupportedBandList1XRTT* pvalue)
{
   char namebuf[512];
   OSUINT32 xx1;

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      char numbuf[32];
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_BandclassCDMA2000 (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_IRAT_ParametersCDMA2000_1XRTT 
   (const char* name, const IRAT_ParametersCDMA2000_1XRTT* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_SupportedBandList1XRTT ("supportedBandList1XRTT", &pvalue->
      supportedBandList1XRTT);

   asn1Print_IRAT_ParametersCDMA2000_1XRTT_tx_Config1XRTT ("tx_Config1XRTT", &
      pvalue->tx_Config1XRTT);

   asn1Print_IRAT_ParametersCDMA2000_1XRTT_rx_Config1XRTT ("rx_Config1XRTT", &
      pvalue->rx_Config1XRTT);

   rtxPrintCloseBrace ();
}

void asn1Print_UE_EUTRA_Capability_interRAT_Parameters 
   (const char* name, const UE_EUTRA_Capability_interRAT_Parameters* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.utraFDDPresent) {
      asn1Print_IRAT_ParametersUTRA_FDD ("utraFDD", &pvalue->utraFDD);
   }

   if (pvalue->m.utraTDD128Present) {
      asn1Print_IRAT_ParametersUTRA_TDD128 ("utraTDD128", &pvalue->utraTDD128
         );
   }

   if (pvalue->m.utraTDD384Present) {
      asn1Print_IRAT_ParametersUTRA_TDD384 ("utraTDD384", &pvalue->utraTDD384
         );
   }

   if (pvalue->m.utraTDD768Present) {
      asn1Print_IRAT_ParametersUTRA_TDD768 ("utraTDD768", &pvalue->utraTDD768
         );
   }

   if (pvalue->m.geranPresent) {
      asn1Print_IRAT_ParametersGERAN ("geran", &pvalue->geran);
   }

   if (pvalue->m.cdma2000_HRPDPresent) {
      asn1Print_IRAT_ParametersCDMA2000_HRPD ("cdma2000_HRPD", &pvalue->
         cdma2000_HRPD);
   }

   if (pvalue->m.cdma2000_1xRTTPresent) {
      asn1Print_IRAT_ParametersCDMA2000_1XRTT ("cdma2000_1xRTT", &pvalue->
         cdma2000_1xRTT);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_PhyLayerParameters_v920 
   (const char* name, const PhyLayerParameters_v920* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.enhancedDualLayerFDD_r9Present) {
      asn1Print_PhyLayerParameters_v920_enhancedDualLayerFDD_r9 (
         "enhancedDualLayerFDD_r9", &pvalue->enhancedDualLayerFDD_r9);
   }

   if (pvalue->m.enhancedDualLayerTDD_r9Present) {
      asn1Print_PhyLayerParameters_v920_enhancedDualLayerTDD_r9 (
         "enhancedDualLayerTDD_r9", &pvalue->enhancedDualLayerTDD_r9);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_IRAT_ParametersGERAN_v920 
   (const char* name, const IRAT_ParametersGERAN_v920* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.dtm_r9Present) {
      asn1Print_IRAT_ParametersGERAN_v920_dtm_r9 ("dtm_r9", &pvalue->dtm_r9);
   }

   if (pvalue->m.e_RedirectionGERAN_r9Present) {
      asn1Print_IRAT_ParametersGERAN_v920_e_RedirectionGERAN_r9 (
         "e_RedirectionGERAN_r9", &pvalue->e_RedirectionGERAN_r9);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_IRAT_ParametersUTRA_v920 
   (const char* name, const IRAT_ParametersUTRA_v920* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_IRAT_ParametersUTRA_v920_e_RedirectionUTRA_r9 (
      "e_RedirectionUTRA_r9", &pvalue->e_RedirectionUTRA_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_IRAT_ParametersCDMA2000_1XRTT_v920 
   (const char* name, const IRAT_ParametersCDMA2000_1XRTT_v920* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_1XRTT_r9 (
      "e_CSFB_1XRTT_r9", &pvalue->e_CSFB_1XRTT_r9);

   if (pvalue->m.e_CSFB_ConcPS_Mob1XRTT_r9Present) {
      asn1Print_IRAT_ParametersCDMA2000_1XRTT_v920_e_CSFB_ConcPS_Mob1XRTT_r9 (
         "e_CSFB_ConcPS_Mob1XRTT_r9", &pvalue->e_CSFB_ConcPS_Mob1XRTT_r9);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CSG_ProximityIndicationParameters_r9 
   (const char* name, const CSG_ProximityIndicationParameters_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.intraFreqProximityIndication_r9Present) {
      asn1Print_CSG_ProximityIndicationParameters_r9_intraFreqProximityIndication_r9 (
         "intraFreqProximityIndication_r9", &pvalue->
         intraFreqProximityIndication_r9);
   }

   if (pvalue->m.interFreqProximityIndication_r9Present) {
      asn1Print_CSG_ProximityIndicationParameters_r9_interFreqProximityIndication_r9 (
         "interFreqProximityIndication_r9", &pvalue->
         interFreqProximityIndication_r9);
   }

   if (pvalue->m.utran_ProximityIndication_r9Present) {
      asn1Print_CSG_ProximityIndicationParameters_r9_utran_ProximityIndication_r9 (
         "utran_ProximityIndication_r9", &pvalue->utran_ProximityIndication_r9
         );
   }

   rtxPrintCloseBrace ();
}

void asn1Print_NeighCellSI_AcquisitionParameters_r9 
   (const char* name, const NeighCellSI_AcquisitionParameters_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.intraFreqSI_AcquisitionForHO_r9Present) {
      asn1Print_NeighCellSI_AcquisitionParameters_r9_intraFreqSI_AcquisitionForHO_r9 (
         "intraFreqSI_AcquisitionForHO_r9", &pvalue->
         intraFreqSI_AcquisitionForHO_r9);
   }

   if (pvalue->m.interFreqSI_AcquisitionForHO_r9Present) {
      asn1Print_NeighCellSI_AcquisitionParameters_r9_interFreqSI_AcquisitionForHO_r9 (
         "interFreqSI_AcquisitionForHO_r9", &pvalue->
         interFreqSI_AcquisitionForHO_r9);
   }

   if (pvalue->m.utran_SI_AcquisitionForHO_r9Present) {
      asn1Print_NeighCellSI_AcquisitionParameters_r9_utran_SI_AcquisitionForHO_r9 (
         "utran_SI_AcquisitionForHO_r9", &pvalue->utran_SI_AcquisitionForHO_r9
         );
   }

   rtxPrintCloseBrace ();
}

void asn1Print_SON_Parameters_r9 
   (const char* name, const SON_Parameters_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.rach_Report_r9Present) {
      asn1Print_SON_Parameters_r9_rach_Report_r9 ("rach_Report_r9", &pvalue->
         rach_Report_r9);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UE_EUTRA_Capability_v940_IEs_nonCriticalExtension 
   (const char* name, const UE_EUTRA_Capability_v940_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_UE_EUTRA_Capability_v940_IEs 
   (const char* name, const UE_EUTRA_Capability_v940_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.lateNonCriticalExtensionPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("lateNonCriticalExtension", pvalue->lateNonCriticalExtension.numocts, pvalue->lateNonCriticalExtension.data);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_UE_EUTRA_Capability_v940_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UE_EUTRA_Capability_v920_IEs 
   (const char* name, const UE_EUTRA_Capability_v920_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PhyLayerParameters_v920 ("phyLayerParameters_v920", &pvalue->
      phyLayerParameters_v920);

   asn1Print_IRAT_ParametersGERAN_v920 ("interRAT_ParametersGERAN_v920", &
      pvalue->interRAT_ParametersGERAN_v920);

   if (pvalue->m.interRAT_ParametersUTRA_v920Present) {
      asn1Print_IRAT_ParametersUTRA_v920 ("interRAT_ParametersUTRA_v920", &
         pvalue->interRAT_ParametersUTRA_v920);
   }

   if (pvalue->m.interRAT_ParametersCDMA2000_v920Present) {
      asn1Print_IRAT_ParametersCDMA2000_1XRTT_v920 (
         "interRAT_ParametersCDMA2000_v920", &pvalue->
         interRAT_ParametersCDMA2000_v920);
   }

   if (pvalue->m.deviceType_r9Present) {
      asn1Print_UE_EUTRA_Capability_v920_IEs_deviceType_r9 ("deviceType_r9", &
         pvalue->deviceType_r9);
   }

   asn1Print_CSG_ProximityIndicationParameters_r9 (
      "csg_ProximityIndicationParameters_r9", &pvalue->
      csg_ProximityIndicationParameters_r9);

   asn1Print_NeighCellSI_AcquisitionParameters_r9 (
      "neighCellSI_AcquisitionParameters_r9", &pvalue->
      neighCellSI_AcquisitionParameters_r9);

   asn1Print_SON_Parameters_r9 ("son_Parameters_r9", &pvalue->son_Parameters_r9
      );

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_UE_EUTRA_Capability_v940_IEs ("nonCriticalExtension", &pvalue->
         nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UE_EUTRA_Capability 
   (const char* name, const UE_EUTRA_Capability* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_AccessStratumRelease ("accessStratumRelease", &pvalue->
      accessStratumRelease);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ue_Category", pvalue->ue_Category);

   asn1Print_PDCP_Parameters ("pdcp_Parameters", &pvalue->pdcp_Parameters);

   asn1Print_PhyLayerParameters ("phyLayerParameters", &pvalue->
      phyLayerParameters);

   asn1Print_RF_Parameters ("rf_Parameters", &pvalue->rf_Parameters);

   asn1Print_MeasParameters ("measParameters", &pvalue->measParameters);

   if (pvalue->m.featureGroupIndicatorsPresent) {
      rtxPrintIndent ();
      rtPrintBitStrBraceText ("featureGroupIndicators", pvalue->featureGroupIndicators.numbits, pvalue->featureGroupIndicators.data);
   }

   asn1Print_UE_EUTRA_Capability_interRAT_Parameters ("interRAT_Parameters", &
      pvalue->interRAT_Parameters);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_UE_EUTRA_Capability_v920_IEs ("nonCriticalExtension", &pvalue->
         nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_MBSFN_AreaInfo_r9_mcch_Config_r9 
   (const char* name, const MBSFN_AreaInfo_r9_mcch_Config_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9 (
      "mcch_RepetitionPeriod_r9", &pvalue->mcch_RepetitionPeriod_r9);

   rtxPrintIndent ();
   rtxPrintUnsigned ("mcch_Offset_r9", pvalue->mcch_Offset_r9);

   asn1Print_MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9 (
      "mcch_ModificationPeriod_r9", &pvalue->mcch_ModificationPeriod_r9);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("sf_AllocInfo_r9", pvalue->sf_AllocInfo_r9.numbits, pvalue->sf_AllocInfo_r9.data);

   asn1Print_MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9 (
      "signallingMCS_r9", &pvalue->signallingMCS_r9);

   rtxPrintCloseBrace ();
}

void asn1Print_MBSFN_AreaInfo_r9 
   (const char* name, const MBSFN_AreaInfo_r9* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("mbsfn_AreaId_r9", pvalue->mbsfn_AreaId_r9);

   asn1Print_MBSFN_AreaInfo_r9_non_MBSFNregionLength ("non_MBSFNregionLength", 
      &pvalue->non_MBSFNregionLength);

   rtxPrintIndent ();
   rtxPrintUnsigned ("notificationIndicator_r9", pvalue->notificationIndicator_r9);

   asn1Print_MBSFN_AreaInfo_r9_mcch_Config_r9 ("mcch_Config_r9", &pvalue->
      mcch_Config_r9);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_MBSFN_AreaInfoList_r9 
   (const char* name, const MBSFN_AreaInfoList_r9* pvalue)
{
   MBSFN_AreaInfo_r9* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (MBSFN_AreaInfo_r9*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_MBSFN_AreaInfo_r9 (namebuf, pdata0);
      pnode = pnode->next;
   }
}

EXTERN int asn1PE_VarMeasConfig_speedStatePars_setup (OSCTXT* pctxt, VarMeasConfig_speedStatePars_setup* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("VarMeasConfig_speedStatePars_setup"));

   /* encode mobilityStateParameters */

   RTXCTXTPUSHELEMNAME (pctxt, "mobilityStateParameters");

   stat = asn1PE_MobilityStateParameters (pctxt, &pvalue->mobilityStateParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode timeToTrigger_SF */

   RTXCTXTPUSHELEMNAME (pctxt, "timeToTrigger-SF");

   stat = asn1PE_SpeedStateScaleFactors (pctxt, &pvalue->timeToTrigger_SF);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_VarMeasConfig_speedStatePars_setup (OSCTXT* pctxt, VarMeasConfig_speedStatePars_setup* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode mobilityStateParameters */
   RTXCTXTPUSHELEMNAME (pctxt, "mobilityStateParameters");

   stat = asn1PD_MobilityStateParameters (pctxt, &pvalue->mobilityStateParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeToTrigger_SF */
   RTXCTXTPUSHELEMNAME (pctxt, "timeToTrigger-SF");

   stat = asn1PD_SpeedStateScaleFactors (pctxt, &pvalue->timeToTrigger_SF);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_VarMeasConfig_speedStatePars (OSCTXT* pctxt, VarMeasConfig_speedStatePars* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("VarMeasConfig_speedStatePars"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* release */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* setup */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         stat = asn1PE_VarMeasConfig_speedStatePars_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_VarMeasConfig_speedStatePars (OSCTXT* pctxt, VarMeasConfig_speedStatePars* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "release");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* setup */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "setup");

         pvalue->u.setup = rtxMemAllocTypeZ (pctxt, 
            VarMeasConfig_speedStatePars_setup);

         if (pvalue->u.setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_VarMeasConfig_speedStatePars_setup (pctxt, pvalue->u.setup);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_VarMeasConfig_speedStatePars (
   VarMeasConfig_speedStatePars* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_VarMeasConfig (OSCTXT* pctxt, VarMeasConfig* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "VarMeasConfig");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("VarMeasConfig"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measIdListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measObjectListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.reportConfigListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.quantityConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.s_MeasurePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedStateParsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measIdList */

   if (pvalue->m.measIdListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "measIdList");

      stat = asn1PE_MeasIdToAddModList (pctxt, &pvalue->measIdList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode measObjectList */

   if (pvalue->m.measObjectListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "measObjectList");

      stat = asn1PE_MeasObjectToAddModList (pctxt, &pvalue->measObjectList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode reportConfigList */

   if (pvalue->m.reportConfigListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "reportConfigList");

      stat = asn1PE_ReportConfigToAddModList (pctxt, &pvalue->reportConfigList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode quantityConfig */

   if (pvalue->m.quantityConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "quantityConfig");

      stat = asn1PE_QuantityConfig (pctxt, &pvalue->quantityConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode s_Measure */

   if (pvalue->m.s_MeasurePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "s-Measure");

      stat = asn1PE_RSRP_Range (pctxt, pvalue->s_Measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode speedStatePars */

   if (pvalue->m.speedStateParsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "speedStatePars");

      stat = asn1PE_VarMeasConfig_speedStatePars (pctxt, &pvalue->speedStatePars);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_VarMeasConfig (OSCTXT* pctxt, VarMeasConfig* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[6];

   RTXCTXTPUSHTYPENAME (pctxt, "VarMeasConfig");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode measIdList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measIdList");

      pvalue->m.measIdListPresent = 1;

      stat = asn1PD_MeasIdToAddModList (pctxt, &pvalue->measIdList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode measObjectList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measObjectList");

      pvalue->m.measObjectListPresent = 1;

      stat = asn1PD_MeasObjectToAddModList (pctxt, &pvalue->measObjectList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode reportConfigList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "reportConfigList");

      pvalue->m.reportConfigListPresent = 1;

      stat = asn1PD_ReportConfigToAddModList (pctxt, &pvalue->reportConfigList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode quantityConfig */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "quantityConfig");

      pvalue->m.quantityConfigPresent = 1;

      stat = asn1PD_QuantityConfig (pctxt, &pvalue->quantityConfig);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode s_Measure */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "s-Measure");

      pvalue->m.s_MeasurePresent = 1;

      stat = asn1PD_RSRP_Range (pctxt, &pvalue->s_Measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode speedStatePars */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "speedStatePars");

      pvalue->m.speedStateParsPresent = 1;

      stat = asn1PD_VarMeasConfig_speedStatePars (pctxt, &pvalue->speedStatePars);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_VarMeasConfig (VarMeasConfig* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_MeasIdToAddModList (&pvalue->measIdList);
   asn1Init_MeasObjectToAddModList (&pvalue->measObjectList);
   asn1Init_ReportConfigToAddModList (&pvalue->reportConfigList);
   asn1Init_QuantityConfig (&pvalue->quantityConfig);
   asn1Init_VarMeasConfig_speedStatePars (&pvalue->speedStatePars);
}

EXTERN int asn1PE_CellsTriggeredList_element_physCellIdUTRA (OSCTXT* pctxt, CellsTriggeredList_element_physCellIdUTRA* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellsTriggeredList_element_physCellIdUTRA"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* fdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         stat = asn1PE_PhysCellIdUTRA_FDD (pctxt, pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* tdd */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         stat = asn1PE_PhysCellIdUTRA_TDD (pctxt, pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellsTriggeredList_element_physCellIdUTRA (OSCTXT* pctxt, CellsTriggeredList_element_physCellIdUTRA* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* fdd */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fdd");

         stat = asn1PD_PhysCellIdUTRA_FDD (pctxt, &pvalue->u.fdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tdd */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tdd");

         stat = asn1PD_PhysCellIdUTRA_TDD (pctxt, &pvalue->u.tdd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_CellsTriggeredList_element_physCellIdUTRA (
   CellsTriggeredList_element_physCellIdUTRA* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_CellsTriggeredList_element_physCellIdGERAN (OSCTXT* pctxt, CellsTriggeredList_element_physCellIdGERAN* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellsTriggeredList_element_physCellIdGERAN"));

   /* encode carrierFreq */

   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PE_CarrierFreqGERAN (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode physCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PE_PhysCellIdGERAN (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellsTriggeredList_element_physCellIdGERAN (OSCTXT* pctxt, CellsTriggeredList_element_physCellIdGERAN* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode carrierFreq */
   RTXCTXTPUSHELEMNAME (pctxt, "carrierFreq");

   stat = asn1PD_CarrierFreqGERAN (pctxt, &pvalue->carrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode physCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PD_PhysCellIdGERAN (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   return (stat);
}

void asn1Init_CellsTriggeredList_element_physCellIdGERAN (
   CellsTriggeredList_element_physCellIdGERAN* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_PhysCellIdGERAN (&pvalue->physCellId);
}

EXTERN int asn1PE_CellsTriggeredList_element (OSCTXT* pctxt, CellsTriggeredList_element* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellsTriggeredList_element"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* physCellIdEUTRA */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "physCellIdEUTRA");

         stat = asn1PE_PhysCellId (pctxt, pvalue->u.physCellIdEUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* physCellIdUTRA */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "physCellIdUTRA");

         stat = asn1PE_CellsTriggeredList_element_physCellIdUTRA (pctxt, pvalue->u.physCellIdUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* physCellIdGERAN */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "physCellIdGERAN");

         stat = asn1PE_CellsTriggeredList_element_physCellIdGERAN (pctxt, pvalue->u.physCellIdGERAN);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* physCellIdCDMA2000 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "physCellIdCDMA2000");

         stat = asn1PE_PhysCellIdCDMA2000 (pctxt, pvalue->u.physCellIdCDMA2000);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellsTriggeredList_element (OSCTXT* pctxt, CellsTriggeredList_element* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* physCellIdEUTRA */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "physCellIdEUTRA");

         stat = asn1PD_PhysCellId (pctxt, &pvalue->u.physCellIdEUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* physCellIdUTRA */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "physCellIdUTRA");

         pvalue->u.physCellIdUTRA = rtxMemAllocType (pctxt, 
            CellsTriggeredList_element_physCellIdUTRA);

         if (pvalue->u.physCellIdUTRA == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CellsTriggeredList_element_physCellIdUTRA (pvalue->u.physCellIdUTRA);

         stat = asn1PD_CellsTriggeredList_element_physCellIdUTRA (pctxt, pvalue->u.physCellIdUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* physCellIdGERAN */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "physCellIdGERAN");

         pvalue->u.physCellIdGERAN = rtxMemAllocType (pctxt, 
            CellsTriggeredList_element_physCellIdGERAN);

         if (pvalue->u.physCellIdGERAN == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CellsTriggeredList_element_physCellIdGERAN (pvalue->u.physCellIdGERAN);

         stat = asn1PD_CellsTriggeredList_element_physCellIdGERAN (pctxt, pvalue->u.physCellIdGERAN);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* physCellIdCDMA2000 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "physCellIdCDMA2000");

         stat = asn1PD_PhysCellIdCDMA2000 (pctxt, &pvalue->u.physCellIdCDMA2000);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_CellsTriggeredList_element (CellsTriggeredList_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_CellsTriggeredList (OSCTXT* pctxt, CellsTriggeredList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsTriggeredList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("CellsTriggeredList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CHOICE", xx1);

      stat = asn1PE_CellsTriggeredList_element (pctxt, ((CellsTriggeredList_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellsTriggeredList (OSCTXT* pctxt, CellsTriggeredList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellsTriggeredList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellsTriggeredList_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CHOICE", xx1);

      rtxDListAllocNodeAndData (pctxt, CellsTriggeredList_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellsTriggeredList_element (pdata);

      stat = asn1PD_CellsTriggeredList_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_CellsTriggeredList (CellsTriggeredList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_VarMeasReport (OSCTXT* pctxt, VarMeasReport* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "VarMeasReport");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("VarMeasReport"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cellsTriggeredListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measId */

   RTXCTXTPUSHELEMNAME (pctxt, "measId");

   stat = asn1PE_MeasId (pctxt, pvalue->measId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellsTriggeredList */

   if (pvalue->m.cellsTriggeredListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellsTriggeredList");

      stat = asn1PE_CellsTriggeredList (pctxt, &pvalue->cellsTriggeredList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode numberOfReportsSent */

   RTXCTXTPUSHELEMNAME (pctxt, "numberOfReportsSent");

   stat = pe_UnconsInteger (pctxt, pvalue->numberOfReportsSent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_VarMeasReport (OSCTXT* pctxt, VarMeasReport* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "VarMeasReport");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode measId */
   RTXCTXTPUSHELEMNAME (pctxt, "measId");

   stat = asn1PD_MeasId (pctxt, &pvalue->measId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellsTriggeredList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cellsTriggeredList");

      pvalue->m.cellsTriggeredListPresent = 1;

      stat = asn1PD_CellsTriggeredList (pctxt, &pvalue->cellsTriggeredList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode numberOfReportsSent */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfReportsSent");

   stat = pd_UnconsInteger (pctxt, &pvalue->numberOfReportsSent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_VarMeasReport (VarMeasReport* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_CellsTriggeredList (&pvalue->cellsTriggeredList);
}

EXTERN int asn1PE_VarMeasReportList (OSCTXT* pctxt, VarMeasReportList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "VarMeasReportList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("VarMeasReportList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "VarMeasReport", xx1);

      stat = asn1PE_VarMeasReport (pctxt, ((VarMeasReport*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_VarMeasReportList (OSCTXT* pctxt, VarMeasReportList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "VarMeasReportList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      VarMeasReport* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "VarMeasReport", xx1);

      rtxDListAllocNodeAndData (pctxt, VarMeasReport, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_VarMeasReport (pdata);

      stat = asn1PD_VarMeasReport (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_VarMeasReportList (VarMeasReportList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_VarShortMAC_Input (OSCTXT* pctxt, VarShortMAC_Input* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "VarShortMAC-Input");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("VarShortMAC_Input"));

   /* encode cellIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "cellIdentity");

   stat = asn1PE_CellIdentity (pctxt, pvalue->cellIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode physCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PE_PhysCellId (pctxt, pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode c_RNTI */

   RTXCTXTPUSHELEMNAME (pctxt, "c-RNTI");

   stat = asn1PE_C_RNTI (pctxt, pvalue->c_RNTI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_VarShortMAC_Input (OSCTXT* pctxt, VarShortMAC_Input* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "VarShortMAC-Input");

   /* decode root elements */
   /* decode cellIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "cellIdentity");

   stat = asn1PD_CellIdentity (pctxt, &pvalue->cellIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode physCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "physCellId");

   stat = asn1PD_PhysCellId (pctxt, &pvalue->physCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode c_RNTI */
   RTXCTXTPUSHELEMNAME (pctxt, "c-RNTI");

   stat = asn1PD_C_RNTI (pctxt, &pvalue->c_RNTI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_VarShortMAC_Input (VarShortMAC_Input* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_CellIdentity (&pvalue->cellIdentity);
   asn1Init_C_RNTI (&pvalue->c_RNTI);
}

void asn1Print_VarMeasConfig_speedStatePars_setup 
   (const char* name, const VarMeasConfig_speedStatePars_setup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MobilityStateParameters ("mobilityStateParameters", &pvalue->
      mobilityStateParameters);

   asn1Print_SpeedStateScaleFactors ("timeToTrigger_SF", &pvalue->
      timeToTrigger_SF);

   rtxPrintCloseBrace ();
}

void asn1Print_VarMeasConfig_speedStatePars 
   (const char* name, const VarMeasConfig_speedStatePars* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* release */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("release");
         break;
      }
      /* setup */
      case 2:
      {
         asn1Print_VarMeasConfig_speedStatePars_setup ("setup", pvalue->u.setup
            );
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_VarMeasConfig (const char* name, const VarMeasConfig* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.measIdListPresent) {
      asn1Print_MeasIdToAddModList ("measIdList", &pvalue->measIdList);
   }

   if (pvalue->m.measObjectListPresent) {
      asn1Print_MeasObjectToAddModList ("measObjectList", &pvalue->
         measObjectList);
   }

   if (pvalue->m.reportConfigListPresent) {
      asn1Print_ReportConfigToAddModList ("reportConfigList", &pvalue->
         reportConfigList);
   }

   if (pvalue->m.quantityConfigPresent) {
      asn1Print_QuantityConfig ("quantityConfig", &pvalue->quantityConfig);
   }

   if (pvalue->m.s_MeasurePresent) {
      asn1Print_RSRP_Range ("s_Measure", &pvalue->s_Measure);
   }

   if (pvalue->m.speedStateParsPresent) {
      asn1Print_VarMeasConfig_speedStatePars ("speedStatePars", &pvalue->
         speedStatePars);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CellsTriggeredList_element_physCellIdUTRA 
   (const char* name, const CellsTriggeredList_element_physCellIdUTRA* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* fdd */
      case 1:
      {
         asn1Print_PhysCellIdUTRA_FDD ("fdd", &pvalue->u.fdd);
         break;
      }
      /* tdd */
      case 2:
      {
         asn1Print_PhysCellIdUTRA_TDD ("tdd", &pvalue->u.tdd);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CellsTriggeredList_element_physCellIdGERAN 
   (const char* name, const CellsTriggeredList_element_physCellIdGERAN* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CarrierFreqGERAN ("carrierFreq", &pvalue->carrierFreq);

   asn1Print_PhysCellIdGERAN ("physCellId", &pvalue->physCellId);

   rtxPrintCloseBrace ();
}

void asn1Print_CellsTriggeredList_element 
   (const char* name, const CellsTriggeredList_element* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* physCellIdEUTRA */
      case 1:
      {
         asn1Print_PhysCellId ("physCellIdEUTRA", &pvalue->u.physCellIdEUTRA);
         break;
      }
      /* physCellIdUTRA */
      case 2:
      {
         asn1Print_CellsTriggeredList_element_physCellIdUTRA (
            "physCellIdUTRA", pvalue->u.physCellIdUTRA);
         break;
      }
      /* physCellIdGERAN */
      case 3:
      {
         asn1Print_CellsTriggeredList_element_physCellIdGERAN (
            "physCellIdGERAN", pvalue->u.physCellIdGERAN);
         break;
      }
      /* physCellIdCDMA2000 */
      case 4:
      {
         asn1Print_PhysCellIdCDMA2000 ("physCellIdCDMA2000", &pvalue->
            u.physCellIdCDMA2000);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_CellsTriggeredList 
   (const char* name, const CellsTriggeredList* pvalue)
{
   CellsTriggeredList_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (CellsTriggeredList_element*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_CellsTriggeredList_element (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_VarMeasReport (const char* name, const VarMeasReport* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MeasId ("measId", &pvalue->measId);

   if (pvalue->m.cellsTriggeredListPresent) {
      asn1Print_CellsTriggeredList ("cellsTriggeredList", &pvalue->
         cellsTriggeredList);
   }

   rtxPrintIndent ();
   rtxPrintInteger ("numberOfReportsSent", pvalue->numberOfReportsSent);

   rtxPrintCloseBrace ();
}

void asn1Print_VarMeasReportList 
   (const char* name, const VarMeasReportList* pvalue)
{
   VarMeasReport* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (VarMeasReport*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_VarMeasReport (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_VarShortMAC_Input 
   (const char* name, const VarShortMAC_Input* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CellIdentity ("cellIdentity", &pvalue->cellIdentity);

   asn1Print_PhysCellId ("physCellId", &pvalue->physCellId);

   asn1Print_C_RNTI ("c_RNTI", &pvalue->c_RNTI);

   rtxPrintCloseBrace ();
}

EXTERN int asn1PE_Key_eNodeB_Star (OSCTXT* pctxt, Key_eNodeB_Star* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Key-eNodeB-Star");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("Key_eNodeB_Star"));

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(256), OSUINTCONST(256), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_Key_eNodeB_Star (OSCTXT* pctxt, Key_eNodeB_Star* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Key-eNodeB-Star");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(256), OSUINTCONST(256), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_Key_eNodeB_Star (Key_eNodeB_Star* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

static const OSEnumItem HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9_ENUMTAB[] = {
   { OSUTF8("rel9"), 0, 4, 0 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 },
   { OSUTF8("spare4"), 4, 6, 4 },
   { OSUTF8("spare5"), 3, 6, 3 },
   { OSUTF8("spare6"), 2, 6, 2 },
   { OSUTF8("spare7"), 1, 6, 1 }
} ;
#define HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9_ENUMTABSIZE 8

const OSUTF8CHAR* HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9_ENUMTABSIZE) {
      return HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9_ENUMTAB
         [HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9_ENUMTAB, 
      HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9)
         HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9 (OSCTXT* pctxt, HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9 value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9"));

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9 (OSCTXT* pctxt, HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

static const OSEnumItem RRM_Config_ue_InactiveTime_ENUMTAB[] = {
   { OSUTF8("day1"), 50, 4, 52 },
   { OSUTF8("day10"), 58, 5, 55 },
   { OSUTF8("day14"), 59, 5, 58 },
   { OSUTF8("day19"), 60, 5, 61 },
   { OSUTF8("day1hr12"), 51, 8, 63 },
   { OSUTF8("day2"), 52, 4, 53 },
   { OSUTF8("day24"), 61, 5, 54 },
   { OSUTF8("day2hr12"), 53, 8, 56 },
   { OSUTF8("day3"), 54, 4, 57 },
   { OSUTF8("day30"), 62, 5, 59 },
   { OSUTF8("day4"), 55, 4, 60 },
   { OSUTF8("day5"), 56, 4, 62 },
   { OSUTF8("day7"), 57, 4, 28 },
   { OSUTF8("dayMoreThan30"), 63, 13, 33 },
   { OSUTF8("hr1"), 36, 3, 34 },
   { OSUTF8("hr10"), 46, 4, 35 },
   { OSUTF8("hr13"), 47, 4, 39 },
   { OSUTF8("hr16"), 48, 4, 40 },
   { OSUTF8("hr1min30"), 37, 8, 43 },
   { OSUTF8("hr2"), 38, 3, 44 },
   { OSUTF8("hr20"), 49, 4, 46 },
   { OSUTF8("hr2min30"), 39, 8, 48 },
   { OSUTF8("hr3"), 40, 3, 49 },
   { OSUTF8("hr3min30"), 41, 8, 50 },
   { OSUTF8("hr4"), 42, 3, 51 },
   { OSUTF8("hr5"), 43, 3, 29 },
   { OSUTF8("hr6"), 44, 3, 30 },
   { OSUTF8("hr8"), 45, 3, 31 },
   { OSUTF8("min1"), 12, 4, 32 },
   { OSUTF8("min10"), 25, 5, 36 },
   { OSUTF8("min12"), 26, 5, 37 },
   { OSUTF8("min14"), 27, 5, 38 },
   { OSUTF8("min17"), 28, 5, 41 },
   { OSUTF8("min1s20c"), 13, 8, 42 },
   { OSUTF8("min1s40"), 14, 7, 45 },
   { OSUTF8("min2"), 15, 4, 47 },
   { OSUTF8("min20"), 29, 5, 14 },
   { OSUTF8("min24"), 30, 5, 18 },
   { OSUTF8("min28"), 31, 5, 19 },
   { OSUTF8("min2s30"), 16, 7, 21 },
   { OSUTF8("min3"), 17, 4, 22 },
   { OSUTF8("min33"), 32, 5, 23 },
   { OSUTF8("min38"), 33, 5, 24 },
   { OSUTF8("min3s30"), 18, 7, 25 },
   { OSUTF8("min4"), 19, 4, 26 },
   { OSUTF8("min44"), 34, 5, 27 },
   { OSUTF8("min5"), 20, 4, 15 },
   { OSUTF8("min50"), 35, 5, 16 },
   { OSUTF8("min6"), 21, 4, 17 },
   { OSUTF8("min7"), 22, 4, 20 },
   { OSUTF8("min8"), 23, 4, 0 },
   { OSUTF8("min9"), 24, 4, 4 },
   { OSUTF8("s1"), 0, 2, 5 },
   { OSUTF8("s10"), 5, 3, 7 },
   { OSUTF8("s15"), 6, 3, 8 },
   { OSUTF8("s2"), 1, 2, 10 },
   { OSUTF8("s20"), 7, 3, 11 },
   { OSUTF8("s25"), 8, 3, 12 },
   { OSUTF8("s3"), 2, 2, 1 },
   { OSUTF8("s30"), 9, 3, 2 },
   { OSUTF8("s40"), 10, 3, 3 },
   { OSUTF8("s5"), 3, 2, 6 },
   { OSUTF8("s50"), 11, 3, 9 },
   { OSUTF8("s7"), 4, 2, 13 }
} ;
#define RRM_Config_ue_InactiveTime_ENUMTABSIZE 64

const OSUTF8CHAR* RRM_Config_ue_InactiveTime_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RRM_Config_ue_InactiveTime_ENUMTABSIZE) {
      return RRM_Config_ue_InactiveTime_ENUMTAB
         [RRM_Config_ue_InactiveTime_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RRM_Config_ue_InactiveTime_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, RRM_Config_ue_InactiveTime* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RRM_Config_ue_InactiveTime_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RRM_Config_ue_InactiveTime_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      RRM_Config_ue_InactiveTime* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RRM_Config_ue_InactiveTime_ENUMTAB, 
      RRM_Config_ue_InactiveTime_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RRM_Config_ue_InactiveTime)
         RRM_Config_ue_InactiveTime_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_RRM_Config_ue_InactiveTime (OSCTXT* pctxt, RRM_Config_ue_InactiveTime value)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRM_Config_ue_InactiveTime"));

   if (value >= 64) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRM_Config_ue_InactiveTime (OSCTXT* pctxt, RRM_Config_ue_InactiveTime* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(63));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_HandoverCommand_r8_IEs_nonCriticalExtension (OSCTXT* pctxt, HandoverCommand_r8_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverCommand_r8_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverCommand_r8_IEs_nonCriticalExtension (OSCTXT* pctxt, HandoverCommand_r8_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_HandoverCommand_r8_IEs (OSCTXT* pctxt, HandoverCommand_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverCommand-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverCommand_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode handoverCommandMessage */

   RTXCTXTPUSHELEMNAME (pctxt, "handoverCommandMessage");

   stat = pe_OctetString (pctxt, pvalue->handoverCommandMessage.numocts, pvalue->handoverCommandMessage.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_HandoverCommand_r8_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverCommand_r8_IEs (OSCTXT* pctxt, HandoverCommand_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverCommand-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode handoverCommandMessage */
   RTXCTXTPUSHELEMNAME (pctxt, "handoverCommandMessage");

   stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->handoverCommandMessage);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_HandoverCommand_r8_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_HandoverCommand_r8_IEs (HandoverCommand_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->handoverCommandMessage.numocts = 0;
   pvalue->handoverCommandMessage.data = 0;
}

EXTERN int asn1PE_HandoverCommand_criticalExtensions_c1 (OSCTXT* pctxt, HandoverCommand_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverCommand_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* handoverCommand_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "handoverCommand-r8");

         stat = asn1PE_HandoverCommand_r8_IEs (pctxt, pvalue->u.handoverCommand_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare7 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare6 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare5 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare4 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverCommand_criticalExtensions_c1 (OSCTXT* pctxt, HandoverCommand_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* handoverCommand_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "handoverCommand-r8");

         pvalue->u.handoverCommand_r8 = rtxMemAllocType (pctxt, 
            HandoverCommand_r8_IEs);

         if (pvalue->u.handoverCommand_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HandoverCommand_r8_IEs (pvalue->u.handoverCommand_r8);

         stat = asn1PD_HandoverCommand_r8_IEs (pctxt, pvalue->u.handoverCommand_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare7 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare6 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare5 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare4 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_HandoverCommand_criticalExtensions_c1 (
   HandoverCommand_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_HandoverCommand_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, HandoverCommand_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverCommand_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverCommand_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, HandoverCommand_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_HandoverCommand_criticalExtensions (OSCTXT* pctxt, HandoverCommand_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverCommand_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_HandoverCommand_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_HandoverCommand_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverCommand_criticalExtensions (OSCTXT* pctxt, HandoverCommand_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            HandoverCommand_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HandoverCommand_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_HandoverCommand_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            HandoverCommand_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_HandoverCommand_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_HandoverCommand_criticalExtensions (
   HandoverCommand_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_HandoverCommand (OSCTXT* pctxt, HandoverCommand* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverCommand");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverCommand"));

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_HandoverCommand_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverCommand (OSCTXT* pctxt, HandoverCommand* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverCommand");

   /* decode root elements */
   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_HandoverCommand_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_HandoverCommand (HandoverCommand* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_HandoverCommand_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_AS_Config (OSCTXT* pctxt, AS_Config* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "AS-Config");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("AS_Config"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m._v2ExtPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sourceMeasConfig */

   RTXCTXTPUSHELEMNAME (pctxt, "sourceMeasConfig");

   stat = asn1PE_MeasConfig (pctxt, &pvalue->sourceMeasConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sourceRadioResourceConfig */

   RTXCTXTPUSHELEMNAME (pctxt, "sourceRadioResourceConfig");

   stat = asn1PE_RadioResourceConfigDedicated (pctxt, &pvalue->sourceRadioResourceConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sourceSecurityAlgorithmConfig */

   RTXCTXTPUSHELEMNAME (pctxt, "sourceSecurityAlgorithmConfig");

   stat = asn1PE_SecurityAlgorithmConfig (pctxt, &pvalue->sourceSecurityAlgorithmConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sourceUE_Identity */

   RTXCTXTPUSHELEMNAME (pctxt, "sourceUE-Identity");

   stat = asn1PE_C_RNTI (pctxt, pvalue->sourceUE_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sourceMasterInformationBlock */

   RTXCTXTPUSHELEMNAME (pctxt, "sourceMasterInformationBlock");

   stat = asn1PE_MasterInformationBlock (pctxt, &pvalue->sourceMasterInformationBlock);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sourceSystemInformationBlockType1 */

   RTXCTXTPUSHELEMNAME (pctxt, "sourceSystemInformationBlockType1");

   stat = asn1PE_SystemInformationBlockType1 (pctxt, &pvalue->sourceSystemInformationBlockType1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sourceSystemInformationBlockType2 */

   RTXCTXTPUSHELEMNAME (pctxt, "sourceSystemInformationBlockType2");

   stat = asn1PE_SystemInformationBlockType2 (pctxt, &pvalue->sourceSystemInformationBlockType2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode antennaInfoCommon */

   RTXCTXTPUSHELEMNAME (pctxt, "antennaInfoCommon");

   stat = asn1PE_AntennaInfoCommon (pctxt, &pvalue->antennaInfoCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sourceDl_CarrierFreq */

   RTXCTXTPUSHELEMNAME (pctxt, "sourceDl-CarrierFreq");

   stat = asn1PE_ARFCN_ValueEUTRA (pctxt, pvalue->sourceDl_CarrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m._v2ExtPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m._v2ExtPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.sourceSystemInformationBlockType1ExtPresent);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         /* encode sourceSystemInformationBlockType1Ext */

         if (pvalue->m.sourceSystemInformationBlockType1ExtPresent) {
            RTXCTXTPUSHELEMNAME (pctxt, "sourceSystemInformationBlockType1Ext");

            stat = pe_OctetString (pctxt, pvalue->sourceSystemInformationBlockType1Ext.numocts, pvalue->sourceSystemInformationBlockType1Ext.data);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }

         /* encode sourceOtherConfig_r9 */

         RTXCTXTPUSHELEMNAME (pctxt, "sourceOtherConfig-r9");

         stat = asn1PE_OtherConfig_r9 (pctxt, &pvalue->sourceOtherConfig_r9);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AS_Config (OSCTXT* pctxt, AS_Config* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AS-Config");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode sourceMeasConfig */
   RTXCTXTPUSHELEMNAME (pctxt, "sourceMeasConfig");

   stat = asn1PD_MeasConfig (pctxt, &pvalue->sourceMeasConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sourceRadioResourceConfig */
   RTXCTXTPUSHELEMNAME (pctxt, "sourceRadioResourceConfig");

   stat = asn1PD_RadioResourceConfigDedicated (pctxt, &pvalue->sourceRadioResourceConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sourceSecurityAlgorithmConfig */
   RTXCTXTPUSHELEMNAME (pctxt, "sourceSecurityAlgorithmConfig");

   stat = asn1PD_SecurityAlgorithmConfig (pctxt, &pvalue->sourceSecurityAlgorithmConfig);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sourceUE_Identity */
   RTXCTXTPUSHELEMNAME (pctxt, "sourceUE-Identity");

   stat = asn1PD_C_RNTI (pctxt, &pvalue->sourceUE_Identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sourceMasterInformationBlock */
   RTXCTXTPUSHELEMNAME (pctxt, "sourceMasterInformationBlock");

   stat = asn1PD_MasterInformationBlock (pctxt, &pvalue->sourceMasterInformationBlock);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sourceSystemInformationBlockType1 */
   RTXCTXTPUSHELEMNAME (pctxt, "sourceSystemInformationBlockType1");

   stat = asn1PD_SystemInformationBlockType1 (pctxt, &pvalue->sourceSystemInformationBlockType1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sourceSystemInformationBlockType2 */
   RTXCTXTPUSHELEMNAME (pctxt, "sourceSystemInformationBlockType2");

   stat = asn1PD_SystemInformationBlockType2 (pctxt, &pvalue->sourceSystemInformationBlockType2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode antennaInfoCommon */
   RTXCTXTPUSHELEMNAME (pctxt, "antennaInfoCommon");

   stat = asn1PD_AntennaInfoCommon (pctxt, &pvalue->antennaInfoCommon);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sourceDl_CarrierFreq */
   RTXCTXTPUSHELEMNAME (pctxt, "sourceDl-CarrierFreq");

   stat = asn1PD_ARFCN_ValueEUTRA (pctxt, &pvalue->sourceDl_CarrierFreq);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m._v2ExtPresent = 1;
                        {
                           OSOCTET extoptbits[1];

                           stat = DEC_BIT (pctxt, &extoptbits[0]);
                           if (stat != 0)  {
                              rtxMemFreePtr (pctxt, poptbits);
                           }
                           if (extoptbits[0]) {
                              pvalue->m.sourceSystemInformationBlockType1ExtPresent = 1;
                              RTXCTXTPUSHELEMNAME (pctxt, "sourceSystemInformationBlockType1Ext");

                              stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->sourceSystemInformationBlockType1Ext);
                              if (stat != 0) {
                                 rtxMemFreePtr (pctxt, openType.data);
                                 break;
                              }

                              RTXCTXTPOPELEMNAME (pctxt);
                           }
                           RTXCTXTPUSHELEMNAME (pctxt, "sourceOtherConfig-r9");

                           stat = asn1PD_OtherConfig_r9 (pctxt, &pvalue->sourceOtherConfig_r9);

                           if (stat != 0) {
                              rtxMemFreePtr (pctxt, openType.data);
                              break;
                           }

                           RTXCTXTPOPELEMNAME (pctxt);
                        }
                        break;

                        /* Coverity 55352 Fix */
                        /* Default Case Deleted */
                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_AS_Config (AS_Config* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_MeasConfig (&pvalue->sourceMeasConfig);
   asn1Init_RadioResourceConfigDedicated (&pvalue->sourceRadioResourceConfig);
   asn1Init_C_RNTI (&pvalue->sourceUE_Identity);
   asn1Init_MasterInformationBlock (&pvalue->sourceMasterInformationBlock);
   asn1Init_SystemInformationBlockType1 (&pvalue->sourceSystemInformationBlockType1);
   asn1Init_SystemInformationBlockType2 (&pvalue->sourceSystemInformationBlockType2);
   pvalue->sourceSystemInformationBlockType1Ext.numocts = 0;
   pvalue->sourceSystemInformationBlockType1Ext.data = 0;
   asn1Init_OtherConfig_r9 (&pvalue->sourceOtherConfig_r9);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_RRM_Config (OSCTXT* pctxt, RRM_Config* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RRM-Config");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("RRM_Config"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ue_InactiveTimePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ue_InactiveTime */

   if (pvalue->m.ue_InactiveTimePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ue-InactiveTime");

      stat = asn1PE_RRM_Config_ue_InactiveTime (pctxt, pvalue->ue_InactiveTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRM_Config (OSCTXT* pctxt, RRM_Config* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RRM-Config");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ue_InactiveTime */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ue-InactiveTime");

      pvalue->m.ue_InactiveTimePresent = 1;

      stat = asn1PD_RRM_Config_ue_InactiveTime (pctxt, &pvalue->ue_InactiveTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_RRM_Config (RRM_Config* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_AdditionalReestabInfo (OSCTXT* pctxt, AdditionalReestabInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AdditionalReestabInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("AdditionalReestabInfo"));

   /* encode cellIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "cellIdentity");

   stat = asn1PE_CellIdentity (pctxt, pvalue->cellIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode key_eNodeB_Star */

   RTXCTXTPUSHELEMNAME (pctxt, "key-eNodeB-Star");

   stat = asn1PE_Key_eNodeB_Star (pctxt, &pvalue->key_eNodeB_Star);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode shortMAC_I */

   RTXCTXTPUSHELEMNAME (pctxt, "shortMAC-I");

   stat = asn1PE_ShortMAC_I (pctxt, pvalue->shortMAC_I);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AdditionalReestabInfo (OSCTXT* pctxt, AdditionalReestabInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AdditionalReestabInfo");

   /* decode root elements */
   /* decode cellIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "cellIdentity");

   stat = asn1PD_CellIdentity (pctxt, &pvalue->cellIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode key_eNodeB_Star */
   RTXCTXTPUSHELEMNAME (pctxt, "key-eNodeB-Star");

   stat = asn1PD_Key_eNodeB_Star (pctxt, &pvalue->key_eNodeB_Star);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode shortMAC_I */
   RTXCTXTPUSHELEMNAME (pctxt, "shortMAC-I");

   stat = asn1PD_ShortMAC_I (pctxt, &pvalue->shortMAC_I);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_AdditionalReestabInfo (AdditionalReestabInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_CellIdentity (&pvalue->cellIdentity);
   asn1Init_Key_eNodeB_Star (&pvalue->key_eNodeB_Star);
   asn1Init_ShortMAC_I (&pvalue->shortMAC_I);
}

EXTERN int asn1PE_AdditionalReestabInfoList (OSCTXT* pctxt, AdditionalReestabInfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "AdditionalReestabInfoList");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("AdditionalReestabInfoList"));

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AdditionalReestabInfo", xx1);

      stat = asn1PE_AdditionalReestabInfo (pctxt, ((AdditionalReestabInfo*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AdditionalReestabInfoList (OSCTXT* pctxt, AdditionalReestabInfoList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AdditionalReestabInfoList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AdditionalReestabInfo* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AdditionalReestabInfo", xx1);

      rtxDListAllocNodeAndData (pctxt, AdditionalReestabInfo, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AdditionalReestabInfo (pdata);

      stat = asn1PD_AdditionalReestabInfo (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_AdditionalReestabInfoList (AdditionalReestabInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

EXTERN int asn1PE_ReestablishmentInfo (OSCTXT* pctxt, ReestablishmentInfo* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ReestablishmentInfo");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("ReestablishmentInfo"));

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.additionalReestabInfoListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sourcePhysCellId */

   RTXCTXTPUSHELEMNAME (pctxt, "sourcePhysCellId");

   stat = asn1PE_PhysCellId (pctxt, pvalue->sourcePhysCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode targetCellShortMAC_I */

   RTXCTXTPUSHELEMNAME (pctxt, "targetCellShortMAC-I");

   stat = asn1PE_ShortMAC_I (pctxt, pvalue->targetCellShortMAC_I);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode additionalReestabInfoList */

   if (pvalue->m.additionalReestabInfoListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalReestabInfoList");

      stat = asn1PE_AdditionalReestabInfoList (pctxt, &pvalue->additionalReestabInfoList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReestablishmentInfo (OSCTXT* pctxt, ReestablishmentInfo* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ReestablishmentInfo");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode sourcePhysCellId */
   RTXCTXTPUSHELEMNAME (pctxt, "sourcePhysCellId");

   stat = asn1PD_PhysCellId (pctxt, &pvalue->sourcePhysCellId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode targetCellShortMAC_I */
   RTXCTXTPUSHELEMNAME (pctxt, "targetCellShortMAC-I");

   stat = asn1PD_ShortMAC_I (pctxt, &pvalue->targetCellShortMAC_I);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode additionalReestabInfoList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalReestabInfoList");

      pvalue->m.additionalReestabInfoListPresent = 1;

      stat = asn1PD_AdditionalReestabInfoList (pctxt, &pvalue->additionalReestabInfoList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_ReestablishmentInfo (ReestablishmentInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ShortMAC_I (&pvalue->targetCellShortMAC_I);
   asn1Init_AdditionalReestabInfoList (&pvalue->additionalReestabInfoList);
   rtxDListFastInit (&pvalue->extElem1);
}

EXTERN int asn1PE_AS_Context (OSCTXT* pctxt, AS_Context* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AS-Context");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("AS_Context"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.reestablishmentInfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode reestablishmentInfo */

   if (pvalue->m.reestablishmentInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "reestablishmentInfo");

      stat = asn1PE_ReestablishmentInfo (pctxt, &pvalue->reestablishmentInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_AS_Context (OSCTXT* pctxt, AS_Context* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AS-Context");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode reestablishmentInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "reestablishmentInfo");

      pvalue->m.reestablishmentInfoPresent = 1;

      stat = asn1PD_ReestablishmentInfo (pctxt, &pvalue->reestablishmentInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_AS_Context (AS_Context* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ReestablishmentInfo (&pvalue->reestablishmentInfo);
}

EXTERN int asn1PE_HandoverPreparationInformation_v920_IEs_nonCriticalExtension (OSCTXT* pctxt, HandoverPreparationInformation_v920_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverPreparationInformation_v920_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationInformation_v920_IEs_nonCriticalExtension (OSCTXT* pctxt, HandoverPreparationInformation_v920_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_HandoverPreparationInformation_v920_IEs (OSCTXT* pctxt, HandoverPreparationInformation_v920_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverPreparationInformation-v920-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverPreparationInformation_v920_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ue_ConfigRelease_r9Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ue_ConfigRelease_r9 */

   if (pvalue->m.ue_ConfigRelease_r9Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "ue-ConfigRelease-r9");

      stat = asn1PE_HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9 (pctxt, pvalue->ue_ConfigRelease_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_HandoverPreparationInformation_v920_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationInformation_v920_IEs (OSCTXT* pctxt, HandoverPreparationInformation_v920_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverPreparationInformation-v920-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ue_ConfigRelease_r9 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ue-ConfigRelease-r9");

      pvalue->m.ue_ConfigRelease_r9Present = 1;

      stat = asn1PD_HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9 (pctxt, &pvalue->ue_ConfigRelease_r9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_HandoverPreparationInformation_v920_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_HandoverPreparationInformation_v920_IEs (
   HandoverPreparationInformation_v920_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

EXTERN int asn1PE_HandoverPreparationInformation_r8_IEs (OSCTXT* pctxt, HandoverPreparationInformation_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverPreparationInformation-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverPreparationInformation_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.as_ConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rrm_ConfigPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.as_ContextPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ue_RadioAccessCapabilityInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "ue-RadioAccessCapabilityInfo");

   stat = asn1PE_UE_CapabilityRAT_ContainerList (pctxt, &pvalue->ue_RadioAccessCapabilityInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode as_Config */

   if (pvalue->m.as_ConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "as-Config");

      stat = asn1PE_AS_Config (pctxt, &pvalue->as_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode rrm_Config */

   if (pvalue->m.rrm_ConfigPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rrm-Config");

      stat = asn1PE_RRM_Config (pctxt, &pvalue->rrm_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode as_Context */

   if (pvalue->m.as_ContextPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "as-Context");

      stat = asn1PE_AS_Context (pctxt, &pvalue->as_Context);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_HandoverPreparationInformation_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationInformation_r8_IEs (OSCTXT* pctxt, HandoverPreparationInformation_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverPreparationInformation-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ue_RadioAccessCapabilityInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "ue-RadioAccessCapabilityInfo");

   stat = asn1PD_UE_CapabilityRAT_ContainerList (pctxt, &pvalue->ue_RadioAccessCapabilityInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode as_Config */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "as-Config");

      pvalue->m.as_ConfigPresent = 1;

      stat = asn1PD_AS_Config (pctxt, &pvalue->as_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rrm_Config */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rrm-Config");

      pvalue->m.rrm_ConfigPresent = 1;

      stat = asn1PD_RRM_Config (pctxt, &pvalue->rrm_Config);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode as_Context */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "as-Context");

      pvalue->m.as_ContextPresent = 1;

      stat = asn1PD_AS_Context (pctxt, &pvalue->as_Context);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nonCriticalExtension */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_HandoverPreparationInformation_v920_IEs (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_HandoverPreparationInformation_r8_IEs (
   HandoverPreparationInformation_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_UE_CapabilityRAT_ContainerList (&pvalue->ue_RadioAccessCapabilityInfo);
   asn1Init_AS_Config (&pvalue->as_Config);
   asn1Init_RRM_Config (&pvalue->rrm_Config);
   asn1Init_AS_Context (&pvalue->as_Context);
   asn1Init_HandoverPreparationInformation_v920_IEs (&pvalue->nonCriticalExtension);
}

EXTERN int asn1PE_HandoverPreparationInformation_criticalExtensions_c1 (OSCTXT* pctxt, HandoverPreparationInformation_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverPreparationInformation_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* handoverPreparationInformation_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "handoverPreparationInformation-r8");

         stat = asn1PE_HandoverPreparationInformation_r8_IEs (pctxt, pvalue->u.handoverPreparationInformation_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare7 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare6 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare5 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare4 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationInformation_criticalExtensions_c1 (OSCTXT* pctxt, HandoverPreparationInformation_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* handoverPreparationInformation_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "handoverPreparationInformation-r8");

         pvalue->u.handoverPreparationInformation_r8 = rtxMemAllocType (pctxt, 
            HandoverPreparationInformation_r8_IEs);

         if (pvalue->u.handoverPreparationInformation_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HandoverPreparationInformation_r8_IEs (pvalue->u.handoverPreparationInformation_r8);

         stat = asn1PD_HandoverPreparationInformation_r8_IEs (pctxt, pvalue->u.handoverPreparationInformation_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare7 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare6 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare5 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare4 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_HandoverPreparationInformation_criticalExtensions_c1 (
   HandoverPreparationInformation_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_HandoverPreparationInformation_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, HandoverPreparationInformation_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverPreparationInformation_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationInformation_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, HandoverPreparationInformation_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_HandoverPreparationInformation_criticalExtensions (OSCTXT* pctxt, HandoverPreparationInformation_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverPreparationInformation_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_HandoverPreparationInformation_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_HandoverPreparationInformation_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationInformation_criticalExtensions (OSCTXT* pctxt, HandoverPreparationInformation_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            HandoverPreparationInformation_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HandoverPreparationInformation_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_HandoverPreparationInformation_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            HandoverPreparationInformation_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_HandoverPreparationInformation_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_HandoverPreparationInformation_criticalExtensions (
   HandoverPreparationInformation_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_HandoverPreparationInformation (OSCTXT* pctxt, HandoverPreparationInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverPreparationInformation");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("HandoverPreparationInformation"));

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_HandoverPreparationInformation_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationInformation (OSCTXT* pctxt, HandoverPreparationInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverPreparationInformation");

   /* decode root elements */
   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_HandoverPreparationInformation_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_HandoverPreparationInformation (
   HandoverPreparationInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_HandoverPreparationInformation_criticalExtensions (&pvalue->criticalExtensions);
}

EXTERN int asn1PE_UERadioAccessCapabilityInformation_r8_IEs_nonCriticalExtension (OSCTXT* pctxt, UERadioAccessCapabilityInformation_r8_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UERadioAccessCapabilityInformation_r8_IEs_nonCriticalExtension"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioAccessCapabilityInformation_r8_IEs_nonCriticalExtension (OSCTXT* pctxt, UERadioAccessCapabilityInformation_r8_IEs_nonCriticalExtension* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_UERadioAccessCapabilityInformation_r8_IEs (OSCTXT* pctxt, UERadioAccessCapabilityInformation_r8_IEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioAccessCapabilityInformation-r8-IEs");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UERadioAccessCapabilityInformation_r8_IEs"));

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nonCriticalExtensionPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ue_RadioAccessCapabilityInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "ue-RadioAccessCapabilityInfo");

   stat = pe_OctetString (pctxt, pvalue->ue_RadioAccessCapabilityInfo.numocts, pvalue->ue_RadioAccessCapabilityInfo.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nonCriticalExtension */

   if (pvalue->m.nonCriticalExtensionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      stat = asn1PE_UERadioAccessCapabilityInformation_r8_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioAccessCapabilityInformation_r8_IEs (OSCTXT* pctxt, UERadioAccessCapabilityInformation_r8_IEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioAccessCapabilityInformation-r8-IEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode ue_RadioAccessCapabilityInfo */
   RTXCTXTPUSHELEMNAME (pctxt, "ue-RadioAccessCapabilityInfo");

   stat = pd_DynOctetString (pctxt, (OSDynOctStr*)&pvalue->ue_RadioAccessCapabilityInfo);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nonCriticalExtension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nonCriticalExtension");

      pvalue->m.nonCriticalExtensionPresent = 1;

      stat = asn1PD_UERadioAccessCapabilityInformation_r8_IEs_nonCriticalExtension (pctxt, &pvalue->nonCriticalExtension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UERadioAccessCapabilityInformation_r8_IEs (
   UERadioAccessCapabilityInformation_r8_IEs* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->ue_RadioAccessCapabilityInfo.numocts = 0;
   pvalue->ue_RadioAccessCapabilityInfo.data = 0;
}

EXTERN int asn1PE_UERadioAccessCapabilityInformation_criticalExtensions_c1 (OSCTXT* pctxt, UERadioAccessCapabilityInformation_criticalExtensions_c1* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UERadioAccessCapabilityInformation_criticalExtensions_c1"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* ueRadioAccessCapabilityInformation_r8 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ueRadioAccessCapabilityInformation-r8");

         stat = asn1PE_UERadioAccessCapabilityInformation_r8_IEs (pctxt, pvalue->u.ueRadioAccessCapabilityInformation_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare7 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare6 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare5 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare4 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare3 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare2 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* spare1 */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioAccessCapabilityInformation_criticalExtensions_c1 (OSCTXT* pctxt, UERadioAccessCapabilityInformation_criticalExtensions_c1* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* ueRadioAccessCapabilityInformation_r8 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "ueRadioAccessCapabilityInformation-r8");

         pvalue->u.ueRadioAccessCapabilityInformation_r8
             = rtxMemAllocType (pctxt, 
            UERadioAccessCapabilityInformation_r8_IEs);

         if (pvalue->u.ueRadioAccessCapabilityInformation_r8 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioAccessCapabilityInformation_r8_IEs (pvalue->u.ueRadioAccessCapabilityInformation_r8);

         stat = asn1PD_UERadioAccessCapabilityInformation_r8_IEs (pctxt, pvalue->u.ueRadioAccessCapabilityInformation_r8);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare7 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "spare7");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare6 */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "spare6");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare5 */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "spare5");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare4 */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "spare4");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare3 */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "spare3");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare2 */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "spare2");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* spare1 */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         /* NULL */

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_UERadioAccessCapabilityInformation_criticalExtensions_c1 (
   UERadioAccessCapabilityInformation_criticalExtensions_c1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_UERadioAccessCapabilityInformation_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, UERadioAccessCapabilityInformation_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UERadioAccessCapabilityInformation_criticalExtensions_criticalExtensionsFuture"));

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioAccessCapabilityInformation_criticalExtensions_criticalExtensionsFuture (OSCTXT* pctxt, UERadioAccessCapabilityInformation_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG (pvalue) ;
   OS_UNUSED_ARG (pctxt) ;

   return (stat);
}

EXTERN int asn1PE_UERadioAccessCapabilityInformation_criticalExtensions (OSCTXT* pctxt, UERadioAccessCapabilityInformation_criticalExtensions* pvalue)
{
   int stat = 0;

   rtxCtxtPushTypeName (pctxt, OSUTF8("UERadioAccessCapabilityInformation_criticalExtensions"));

   /* Encode choice index value */

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         stat = asn1PE_UERadioAccessCapabilityInformation_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* criticalExtensionsFuture */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         stat = asn1PE_UERadioAccessCapabilityInformation_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioAccessCapabilityInformation_criticalExtensions (OSCTXT* pctxt, UERadioAccessCapabilityInformation_criticalExtensions* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* c1 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "c1");

         pvalue->u.c1 = rtxMemAllocType (pctxt, 
            UERadioAccessCapabilityInformation_criticalExtensions_c1);

         if (pvalue->u.c1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioAccessCapabilityInformation_criticalExtensions_c1 (pvalue->u.c1);

         stat = asn1PD_UERadioAccessCapabilityInformation_criticalExtensions_c1 (pctxt, pvalue->u.c1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* criticalExtensionsFuture */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensionsFuture");

         pvalue->u.criticalExtensionsFuture = rtxMemAllocTypeZ (pctxt, 
            UERadioAccessCapabilityInformation_criticalExtensions_criticalExtensionsFuture);

         if (pvalue->u.criticalExtensionsFuture == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_UERadioAccessCapabilityInformation_criticalExtensions_criticalExtensionsFuture (pctxt, pvalue->u.criticalExtensionsFuture);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

void asn1Init_UERadioAccessCapabilityInformation_criticalExtensions (
   UERadioAccessCapabilityInformation_criticalExtensions* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

EXTERN int asn1PE_UERadioAccessCapabilityInformation (OSCTXT* pctxt, UERadioAccessCapabilityInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioAccessCapabilityInformation");

   RTXCTXTPOPTYPENAME (pctxt);

   rtxCtxtPushTypeName (pctxt, OSUTF8("UERadioAccessCapabilityInformation"));

   /* encode criticalExtensions */

   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PE_UERadioAccessCapabilityInformation_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   rtxCtxtPopTypeName (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioAccessCapabilityInformation (OSCTXT* pctxt, UERadioAccessCapabilityInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioAccessCapabilityInformation");

   /* decode root elements */
   /* decode criticalExtensions */
   RTXCTXTPUSHELEMNAME (pctxt, "criticalExtensions");

   stat = asn1PD_UERadioAccessCapabilityInformation_criticalExtensions (pctxt, &pvalue->criticalExtensions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Init_UERadioAccessCapabilityInformation (
   UERadioAccessCapabilityInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_UERadioAccessCapabilityInformation_criticalExtensions (&pvalue->criticalExtensions);
}

void asn1Print_Key_eNodeB_Star 
   (const char* name, const Key_eNodeB_Star* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9 
   (const char* name, const HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("rel9\n"); break;
      case 1: printf ("spare7\n"); break;
      case 2: printf ("spare6\n"); break;
      case 3: printf ("spare5\n"); break;
      case 4: printf ("spare4\n"); break;
      case 5: printf ("spare3\n"); break;
      case 6: printf ("spare2\n"); break;
      case 7: printf ("spare1\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_RRM_Config_ue_InactiveTime 
   (const char* name, const RRM_Config_ue_InactiveTime* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("s1\n"); break;
      case 1: printf ("s2\n"); break;
      case 2: printf ("s3\n"); break;
      case 3: printf ("s5\n"); break;
      case 4: printf ("s7\n"); break;
      case 5: printf ("s10\n"); break;
      case 6: printf ("s15\n"); break;
      case 7: printf ("s20\n"); break;
      case 8: printf ("s25\n"); break;
      case 9: printf ("s30\n"); break;
      case 10: printf ("s40\n"); break;
      case 11: printf ("s50\n"); break;
      case 12: printf ("min1\n"); break;
      case 13: printf ("min1s20c\n"); break;
      case 14: printf ("min1s40\n"); break;
      case 15: printf ("min2\n"); break;
      case 16: printf ("min2s30\n"); break;
      case 17: printf ("min3\n"); break;
      case 18: printf ("min3s30\n"); break;
      case 19: printf ("min4\n"); break;
      case 20: printf ("min5\n"); break;
      case 21: printf ("min6\n"); break;
      case 22: printf ("min7\n"); break;
      case 23: printf ("min8\n"); break;
      case 24: printf ("min9\n"); break;
      case 25: printf ("min10\n"); break;
      case 26: printf ("min12\n"); break;
      case 27: printf ("min14\n"); break;
      case 28: printf ("min17\n"); break;
      case 29: printf ("min20\n"); break;
      case 30: printf ("min24\n"); break;
      case 31: printf ("min28\n"); break;
      case 32: printf ("min33\n"); break;
      case 33: printf ("min38\n"); break;
      case 34: printf ("min44\n"); break;
      case 35: printf ("min50\n"); break;
      case 36: printf ("hr1\n"); break;
      case 37: printf ("hr1min30\n"); break;
      case 38: printf ("hr2\n"); break;
      case 39: printf ("hr2min30\n"); break;
      case 40: printf ("hr3\n"); break;
      case 41: printf ("hr3min30\n"); break;
      case 42: printf ("hr4\n"); break;
      case 43: printf ("hr5\n"); break;
      case 44: printf ("hr6\n"); break;
      case 45: printf ("hr8\n"); break;
      case 46: printf ("hr10\n"); break;
      case 47: printf ("hr13\n"); break;
      case 48: printf ("hr16\n"); break;
      case 49: printf ("hr20\n"); break;
      case 50: printf ("day1\n"); break;
      case 51: printf ("day1hr12\n"); break;
      case 52: printf ("day2\n"); break;
      case 53: printf ("day2hr12\n"); break;
      case 54: printf ("day3\n"); break;
      case 55: printf ("day4\n"); break;
      case 56: printf ("day5\n"); break;
      case 57: printf ("day7\n"); break;
      case 58: printf ("day10\n"); break;
      case 59: printf ("day14\n"); break;
      case 60: printf ("day19\n"); break;
      case 61: printf ("day24\n"); break;
      case 62: printf ("day30\n"); break;
      case 63: printf ("dayMoreThan30\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_HandoverCommand_r8_IEs_nonCriticalExtension 
   (const char* name, const HandoverCommand_r8_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_HandoverCommand_r8_IEs 
   (const char* name, const HandoverCommand_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintHexStr ("handoverCommandMessage", pvalue->handoverCommandMessage.numocts, pvalue->handoverCommandMessage.data);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_HandoverCommand_r8_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_HandoverCommand_criticalExtensions_c1 
   (const char* name, const HandoverCommand_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* handoverCommand-r8 */
      case 1:
      {
         asn1Print_HandoverCommand_r8_IEs ("handoverCommand-r8", pvalue->
            u.handoverCommand_r8);
         break;
      }
      /* spare7 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare7");
         break;
      }
      /* spare6 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare6");
         break;
      }
      /* spare5 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare5");
         break;
      }
      /* spare4 */
      case 5:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare4");
         break;
      }
      /* spare3 */
      case 6:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 7:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 8:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_HandoverCommand_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const HandoverCommand_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_HandoverCommand_criticalExtensions 
   (const char* name, const HandoverCommand_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_HandoverCommand_criticalExtensions_c1 ("c1", pvalue->u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_HandoverCommand_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_HandoverCommand 
   (const char* name, const HandoverCommand* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_HandoverCommand_criticalExtensions ("criticalExtensions", &pvalue
      ->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_AS_Config (const char* name, const AS_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_MeasConfig ("sourceMeasConfig", &pvalue->sourceMeasConfig);

   asn1Print_RadioResourceConfigDedicated ("sourceRadioResourceConfig", &pvalue
      ->sourceRadioResourceConfig);

   asn1Print_SecurityAlgorithmConfig ("sourceSecurityAlgorithmConfig", &pvalue
      ->sourceSecurityAlgorithmConfig);

   asn1Print_C_RNTI ("sourceUE_Identity", &pvalue->sourceUE_Identity);

   asn1Print_MasterInformationBlock ("sourceMasterInformationBlock", &pvalue->
      sourceMasterInformationBlock);

   asn1Print_SystemInformationBlockType1 ("sourceSystemInformationBlockType1", 
      &pvalue->sourceSystemInformationBlockType1);

   asn1Print_SystemInformationBlockType2 ("sourceSystemInformationBlockType2", 
      &pvalue->sourceSystemInformationBlockType2);

   asn1Print_AntennaInfoCommon ("antennaInfoCommon", &pvalue->antennaInfoCommon
      );

   asn1Print_ARFCN_ValueEUTRA ("sourceDl_CarrierFreq", &pvalue->
      sourceDl_CarrierFreq);

   if (pvalue->m._v2ExtPresent) {
      if (pvalue->m.sourceSystemInformationBlockType1ExtPresent) {
         rtxPrintIndent ();
         rtxPrintHexStr ("sourceSystemInformationBlockType1Ext", pvalue->sourceSystemInformationBlockType1Ext.numocts, pvalue->sourceSystemInformationBlockType1Ext.data);
      }
      asn1Print_OtherConfig_r9 ("sourceOtherConfig_r9", &pvalue->
         sourceOtherConfig_r9);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_RRM_Config (const char* name, const RRM_Config* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.ue_InactiveTimePresent) {
      asn1Print_RRM_Config_ue_InactiveTime ("ue_InactiveTime", &pvalue->
         ue_InactiveTime);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_AdditionalReestabInfo 
   (const char* name, const AdditionalReestabInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CellIdentity ("cellIdentity", &pvalue->cellIdentity);

   asn1Print_Key_eNodeB_Star ("key_eNodeB_Star", &pvalue->key_eNodeB_Star);

   asn1Print_ShortMAC_I ("shortMAC_I", &pvalue->shortMAC_I);

   rtxPrintCloseBrace ();
}

void asn1Print_AdditionalReestabInfoList 
   (const char* name, const AdditionalReestabInfoList* pvalue)
{
   AdditionalReestabInfo* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (AdditionalReestabInfo*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_AdditionalReestabInfo (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void asn1Print_ReestablishmentInfo 
   (const char* name, const ReestablishmentInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_PhysCellId ("sourcePhysCellId", &pvalue->sourcePhysCellId);

   asn1Print_ShortMAC_I ("targetCellShortMAC_I", &pvalue->targetCellShortMAC_I
      );

   if (pvalue->m.additionalReestabInfoListPresent) {
      asn1Print_AdditionalReestabInfoList ("additionalReestabInfoList", &pvalue
         ->additionalReestabInfoList);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_AS_Context (const char* name, const AS_Context* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.reestablishmentInfoPresent) {
      asn1Print_ReestablishmentInfo ("reestablishmentInfo", &pvalue->
         reestablishmentInfo);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_HandoverPreparationInformation_v920_IEs_nonCriticalExtension 
   (const char* name, const HandoverPreparationInformation_v920_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_HandoverPreparationInformation_v920_IEs 
   (const char* name, const HandoverPreparationInformation_v920_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.ue_ConfigRelease_r9Present) {
      asn1Print_HandoverPreparationInformation_v920_IEs_ue_ConfigRelease_r9 (
         "ue_ConfigRelease_r9", &pvalue->ue_ConfigRelease_r9);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_HandoverPreparationInformation_v920_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_HandoverPreparationInformation_r8_IEs 
   (const char* name, const HandoverPreparationInformation_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_UE_CapabilityRAT_ContainerList ("ue_RadioAccessCapabilityInfo", &
      pvalue->ue_RadioAccessCapabilityInfo);

   if (pvalue->m.as_ConfigPresent) {
      asn1Print_AS_Config ("as_Config", &pvalue->as_Config);
   }

   if (pvalue->m.rrm_ConfigPresent) {
      asn1Print_RRM_Config ("rrm_Config", &pvalue->rrm_Config);
   }

   if (pvalue->m.as_ContextPresent) {
      asn1Print_AS_Context ("as_Context", &pvalue->as_Context);
   }

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_HandoverPreparationInformation_v920_IEs (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_HandoverPreparationInformation_criticalExtensions_c1 
   (const char* name, const HandoverPreparationInformation_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* handoverPreparationInformation-r8 */
      case 1:
      {
         asn1Print_HandoverPreparationInformation_r8_IEs (
            "handoverPreparationInformation-r8", pvalue->
            u.handoverPreparationInformation_r8);
         break;
      }
      /* spare7 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare7");
         break;
      }
      /* spare6 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare6");
         break;
      }
      /* spare5 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare5");
         break;
      }
      /* spare4 */
      case 5:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare4");
         break;
      }
      /* spare3 */
      case 6:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 7:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 8:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_HandoverPreparationInformation_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const HandoverPreparationInformation_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_HandoverPreparationInformation_criticalExtensions 
   (const char* name, const HandoverPreparationInformation_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_HandoverPreparationInformation_criticalExtensions_c1 ("c1", 
            pvalue->u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_HandoverPreparationInformation_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_HandoverPreparationInformation 
   (const char* name, const HandoverPreparationInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_HandoverPreparationInformation_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

void asn1Print_UERadioAccessCapabilityInformation_r8_IEs_nonCriticalExtension 
   (const char* name, const UERadioAccessCapabilityInformation_r8_IEs_nonCriticalExtension* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_UERadioAccessCapabilityInformation_r8_IEs 
   (const char* name, const UERadioAccessCapabilityInformation_r8_IEs* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintHexStr ("ue_RadioAccessCapabilityInfo", pvalue->ue_RadioAccessCapabilityInfo.numocts, pvalue->ue_RadioAccessCapabilityInfo.data);

   if (pvalue->m.nonCriticalExtensionPresent) {
      asn1Print_UERadioAccessCapabilityInformation_r8_IEs_nonCriticalExtension (
         "nonCriticalExtension", &pvalue->nonCriticalExtension);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UERadioAccessCapabilityInformation_criticalExtensions_c1 
   (const char* name, const UERadioAccessCapabilityInformation_criticalExtensions_c1* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* ueRadioAccessCapabilityInformation-r8 */
      case 1:
      {
         asn1Print_UERadioAccessCapabilityInformation_r8_IEs (
            "ueRadioAccessCapabilityInformation-r8", pvalue->
            u.ueRadioAccessCapabilityInformation_r8);
         break;
      }
      /* spare7 */
      case 2:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare7");
         break;
      }
      /* spare6 */
      case 3:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare6");
         break;
      }
      /* spare5 */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare5");
         break;
      }
      /* spare4 */
      case 5:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare4");
         break;
      }
      /* spare3 */
      case 6:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare3");
         break;
      }
      /* spare2 */
      case 7:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare2");
         break;
      }
      /* spare1 */
      case 8:
      {
         rtxPrintIndent();
         rtxPrintNull ("spare1");
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UERadioAccessCapabilityInformation_criticalExtensions_criticalExtensionsFuture 
   (const char* name, const UERadioAccessCapabilityInformation_criticalExtensions_criticalExtensionsFuture* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintCloseBrace ();
   OS_UNUSED_ARG (pvalue);

}

void asn1Print_UERadioAccessCapabilityInformation_criticalExtensions 
   (const char* name, const UERadioAccessCapabilityInformation_criticalExtensions* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* c1 */
      case 1:
      {
         asn1Print_UERadioAccessCapabilityInformation_criticalExtensions_c1 (
            "c1", pvalue->u.c1);
         break;
      }
      /* criticalExtensionsFuture */
      case 2:
      {
         asn1Print_UERadioAccessCapabilityInformation_criticalExtensions_criticalExtensionsFuture (
            "criticalExtensionsFuture", pvalue->u.criticalExtensionsFuture);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_UERadioAccessCapabilityInformation 
   (const char* name, const UERadioAccessCapabilityInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_UERadioAccessCapabilityInformation_criticalExtensions (
      "criticalExtensions", &pvalue->criticalExtensions);

   rtxPrintCloseBrace ();
}

